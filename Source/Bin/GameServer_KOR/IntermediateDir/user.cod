; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?gSMMsg@@3PAY09UMessageStateMachine@@A		; gSMMsg
PUBLIC	?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A ; gSMAttackProcMsg
PUBLIC	?gObj@@3PAVOBJECTSTRUCT@@A			; gObj
PUBLIC	?RoadPathTable@@3PAFA				; RoadPathTable
PUBLIC	?gServerMaxUser@@3HA				; gServerMaxUser
PUBLIC	?gObjTotalUser@@3HA				; gObjTotalUser
PUBLIC	?gAllocObj@@3PAVOBJECTSTRUCT@@A			; gAllocObj
PUBLIC	?gObjCount@@3HA					; gObjCount
PUBLIC	?gObjMonCount@@3HA				; gObjMonCount
PUBLIC	?gObjCallMonCount@@3HA				; gObjCallMonCount
PUBLIC	?hThread_gObjMove@@3PAXA			; hThread_gObjMove
PUBLIC	?gObjCSFlag@@3HA				; gObjCSFlag
PUBLIC	?gItemLoop@@3HA					; gItemLoop
PUBLIC	?gItemLoop2@@3HA				; gItemLoop2
PUBLIC	?gItemLoopMax@@3HA				; gItemLoopMax
PUBLIC	?gDisconnect@@3HA				; gDisconnect
PUBLIC	?aaaaaaaaa@@3HA					; aaaaaaaaa
PUBLIC	?gCurConnectUser@@3HA				; gCurConnectUser
PUBLIC	?skillSuccess@@3HA				; skillSuccess
PUBLIC	?GuildInfoBuf@@3PAEA				; GuildInfoBuf
PUBLIC	?GuildInfoOfs@@3HA				; GuildInfoOfs
PUBLIC	?GuildInfoCount@@3HA				; GuildInfoCount
PUBLIC	?GuildUserBuf@@3PAEA				; GuildUserBuf
PUBLIC	?GuildUserOfs@@3HA				; GuildUserOfs
PUBLIC	?GuildUserCount@@3HA				; GuildUserCount
PUBLIC	?SendGBufChange@@3PAEA				; SendGBufChange
PUBLIC	?lOfsChange@@3HA				; lOfsChange
PUBLIC	?ChangeCount@@3HA				; ChangeCount
PUBLIC	?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A	; pViewportCreate
PUBLIC	?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A ; pViewportCreateChange
PUBLIC	?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A	; pViewportDestroy
PUBLIC	?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A ; pMonsterViewportCreate
PUBLIC	?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A ; pCallMonsterViewportCreate
PUBLIC	?pItemCount@@3UPWMSG_COUNT@@A			; pItemCount
PUBLIC	?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A ; pItemViewportCreate
PUBLIC	?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A ; pItemViewportDestroy
PUBLIC	?g_EnergyCheckOff@@3HA				; g_EnergyCheckOff
_BSS	SEGMENT
?gSMMsg@@3PAY09UMessageStateMachine@@A DB 0121100H DUP (?) ; gSMMsg
?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A DB 0f4240H DUP (?) ; gSMAttackProcMsg
?gObj@@3PAVOBJECTSTRUCT@@A DD 01H DUP (?)		; gObj
?gObjTotalUser@@3HA DD 01H DUP (?)			; gObjTotalUser
?gAllocObj@@3PAVOBJECTSTRUCT@@A DD 01H DUP (?)		; gAllocObj
?gObjCount@@3HA DD 01H DUP (?)				; gObjCount
?gObjMonCount@@3HA DD 01H DUP (?)			; gObjMonCount
?gObjCallMonCount@@3HA DD 01H DUP (?)			; gObjCallMonCount
?hThread_gObjMove@@3PAXA DD 01H DUP (?)			; hThread_gObjMove
?gObjCSFlag@@3HA DD 01H DUP (?)				; gObjCSFlag
?gItemLoop@@3HA DD 01H DUP (?)				; gItemLoop
?gItemLoop2@@3HA DD 01H DUP (?)				; gItemLoop2
?gItemLoopMax@@3HA DD 01H DUP (?)			; gItemLoopMax
?gDisconnect@@3HA DD 01H DUP (?)			; gDisconnect
?aaaaaaaaa@@3HA DD 01H DUP (?)				; aaaaaaaaa
?gCurConnectUser@@3HA DD 01H DUP (?)			; gCurConnectUser
?skillSuccess@@3HA DD 01H DUP (?)			; skillSuccess
?GuildInfoBuf@@3PAEA DB 02710H DUP (?)			; GuildInfoBuf
?GuildInfoOfs@@3HA DD 01H DUP (?)			; GuildInfoOfs
?GuildInfoCount@@3HA DD 01H DUP (?)			; GuildInfoCount
?GuildUserBuf@@3PAEA DB 02710H DUP (?)			; GuildUserBuf
?GuildUserOfs@@3HA DD 01H DUP (?)			; GuildUserOfs
?GuildUserCount@@3HA DD 01H DUP (?)			; GuildUserCount
?SendGBufChange@@3PAEA DB 01388H DUP (?)		; SendGBufChange
?lOfsChange@@3HA DD 01H DUP (?)				; lOfsChange
?ChangeCount@@3HA DD 01H DUP (?)			; ChangeCount
?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A DB 022H DUP (?) ; pViewportCreate
	ALIGN	4

?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A DB 016H DUP (?) ; pViewportCreateChange
	ALIGN	4

?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A DW 01H DUP (?) ; pViewportDestroy
	ALIGN	4

?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A DB 0cH DUP (?) ; pMonsterViewportCreate
?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A DB 016H DUP (?) ; pCallMonsterViewportCreate
	ALIGN	4

?pItemCount@@3UPWMSG_COUNT@@A DB 05H DUP (?)		; pItemCount
	ALIGN	4

?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A DB 09H DUP (?) ; pItemViewportCreate
	ALIGN	4

?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A DW 01H DUP (?) ; pItemViewportDestroy
_BSS	ENDS
_DATA	SEGMENT
?RoadPathTable@@3PAFA DW 0ffffH				; RoadPathTable
	DW	0ffffH
	DW	00H
	DW	0ffffH
	DW	01H
	DW	0ffffH
	DW	01H
	DW	00H
	DW	01H
	DW	01H
	DW	00H
	DW	01H
	DW	0ffffH
	DW	01H
	DW	0ffffH
	DW	00H
?gServerMaxUser@@3HA DD 01f4H				; gServerMaxUser
?g_EnergyCheckOff@@3HA DD 01H				; g_EnergyCheckOff
_DATA	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	_vsprintf
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
PUBLIC	_sqrtf
PUBLIC	?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ; ATL::_AtlGetStringResourceImage
PUBLIC	?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z ; ATL::AtlGetStringResourceImage
PUBLIC	?data@CStringData@ATL@@QAEPAXXZ			; ATL::CStringData::data
PUBLIC	?IsLocked@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsLocked
PUBLIC	?IsShared@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsShared
PUBLIC	?Release@CStringData@ATL@@QAEXXZ		; ATL::CStringData::Release
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
PUBLIC	??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
PUBLIC	??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z	; ATL::CSimpleStringT<char,0>::operator=
PUBLIC	?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ	; ATL::CSimpleStringT<char,0>::Empty
PUBLIC	?GetAllocLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetAllocLength
PUBLIC	?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
PUBLIC	?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ	; ATL::CSimpleStringT<char,0>::GetLength
PUBLIC	?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ	; ATL::CSimpleStringT<char,0>::GetString
PUBLIC	?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
PUBLIC	?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z ; ATL::CSimpleStringT<char,0>::SetString
PUBLIC	?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString
PUBLIC	?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADIPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
PUBLIC	?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADIPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
PUBLIC	?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ; ATL::CSimpleStringT<char,0>::StringLength
PUBLIC	?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
PUBLIC	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
PUBLIC	?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Fork
PUBLIC	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
PUBLIC	?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite
PUBLIC	?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
PUBLIC	?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Reallocate
PUBLIC	?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::SetLength
PUBLIC	??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
PUBLIC	??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
PUBLIC	??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
PUBLIC	?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
PUBLIC	?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
PUBLIC	?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad
PUBLIC	??0CTime@ATL@@QAE@_J@Z				; ATL::CTime::CTime
PUBLIC	?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z ; ATL::CTime::Format
PUBLIC	?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z ; ATL::ChTraitsCRT<char>::GetBaseTypeLength
PUBLIC	?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z ; ATL::ChTraitsCRT<char>::ConvertToBaseType
PUBLIC	?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance
PUBLIC	?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??4CMagicInf@@QAEAAV0@ABV0@@Z			; CMagicInf::operator=
PUBLIC	??_ECMagicInf@@UAEPAXI@Z			; CMagicInf::`vector deleting destructor'
PUBLIC	?gObjGetRandomFreeLocation@@YAHHAAE0HHH@Z	; gObjGetRandomFreeLocation
PUBLIC	?gObjCheckAttackTypeMagic@@YAHHH@Z		; gObjCheckAttackTypeMagic
PUBLIC	?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z	; gObjGetRandomItemDropLocation
PUBLIC	?gObjCheckInventorySerial0Item@@YAHPAVOBJECTSTRUCT@@@Z ; gObjCheckInventorySerial0Item
PUBLIC	?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z	; gObjCheckSerial0ItemList
PUBLIC	?gCheckSkillDistance@@YAHHHH@Z			; gCheckSkillDistance
PUBLIC	?gObjMagicAddEnergyCheckOnOff@@YAXH@Z		; gObjMagicAddEnergyCheckOnOff
PUBLIC	?gObjWeaponMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z	; gObjWeaponMagicAdd
PUBLIC	??0BILL_CLASS@@QAE@XZ				; BILL_CLASS::BILL_CLASS
PUBLIC	?Init@BILL_CLASS@@QAEXXZ			; BILL_CLASS::Init
PUBLIC	?GetEndsDays@BILL_CLASS@@QAEPADXZ		; BILL_CLASS::GetEndsDays
PUBLIC	?GetRestTime@BILL_CLASS@@QAEKXZ			; BILL_CLASS::GetRestTime
PUBLIC	?GetRestPoint@BILL_CLASS@@QAEKXZ		; BILL_CLASS::GetRestPoint
PUBLIC	?GetDeductType@BILL_CLASS@@QAEEXZ		; BILL_CLASS::GetDeductType
PUBLIC	??_UZeroMemBase@@SAPAXI@Z			; ZeroMemBase::operator new[]
PUBLIC	??_VZeroMemBase@@SAXPAX@Z			; ZeroMemBase::operator delete[]
PUBLIC	??0OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::OBJECTSTRUCT
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	?CheckAuthority@@YA_NKPAVOBJECTSTRUCT@@@Z	; CheckAuthority
PUBLIC	?gObjAddAttackProcMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHHH@Z ; gObjAddAttackProcMsgSendDelay
PUBLIC	?gObjStateAttackProc@@YAXPAVOBJECTSTRUCT@@HHHH@Z ; gObjStateAttackProc
PUBLIC	?gObjInit@@YAXXZ				; gObjInit
PUBLIC	?gObjEnd@@YAXXZ					; gObjEnd
PUBLIC	?gObjMemFree@@YAFH@Z				; gObjMemFree
PUBLIC	?gObjSometimeClose@@YAFH@Z			; gObjSometimeClose
PUBLIC	?gObjDestroy@@YAXIH@Z				; gObjDestroy
PUBLIC	?gObjAdd@@YAFIPADH@Z				; gObjAdd
PUBLIC	?gObjAddCallMon@@YAFXZ				; gObjAddCallMon
PUBLIC	?gObjAddSearch@@YAFIPAD@Z			; gObjAddSearch
PUBLIC	?gObjAddMonster@@YAFH@Z				; gObjAddMonster
PUBLIC	?gObjDel@@YAFH@Z				; gObjDel
PUBLIC	?gObjGameClose@@YAHH@Z				; gObjGameClose
PUBLIC	?gObjGetSocket@@YAHI@Z				; gObjGetSocket
PUBLIC	?gObjBillRequest@@YAXPAVOBJECTSTRUCT@@@Z	; gObjBillRequest
PUBLIC	?gObjUserKill@@YAXH@Z				; gObjUserKill
PUBLIC	?gObjViewportClose@@YAXPAVOBJECTSTRUCT@@@Z	; gObjViewportClose
PUBLIC	?gObjJoominCheck@@YAHHPAD@Z			; gObjJoominCheck
PUBLIC	?gObjInventoryRectCheck@@YAEHHHHH@Z		; gObjInventoryRectCheck
PUBLIC	?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z		; gObjOnlyInventoryRectCheck
PUBLIC	?CheckInventoryEmptySpace@@YAHPAVOBJECTSTRUCT@@HH@Z ; CheckInventoryEmptySpace
PUBLIC	?gObjGetAccountId@@YAPADH@Z			; gObjGetAccountId
PUBLIC	?gObjGetIndex@@YAHPAD@Z				; gObjGetIndex
PUBLIC	?gObjUserIdConnectCheck@@YAHPADH@Z		; gObjUserIdConnectCheck
PUBLIC	?gObjIsConnectedGP@@YAHH@Z			; gObjIsConnectedGP
PUBLIC	?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@@Z	; gObjIsConnected
PUBLIC	?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@H@Z	; gObjIsConnected
PUBLIC	?gObjIsConnected@@YAHH@Z			; gObjIsConnected
PUBLIC	?gObjIsAccontConnect@@YAHHPAD@Z			; gObjIsAccontConnect
PUBLIC	?gObjIsGamePlaing@@YAHPAVOBJECTSTRUCT@@@Z	; gObjIsGamePlaing
PUBLIC	?gObjCheckXYMapTile@@YAHPAVOBJECTSTRUCT@@H@Z	; gObjCheckXYMapTile
PUBLIC	?gObjTimeCheckSelfDefense@@YAXPAVOBJECTSTRUCT@@@Z ; gObjTimeCheckSelfDefense
PUBLIC	?gObjSetAccountLogin@@YAHHPADHH0@Z		; gObjSetAccountLogin
PUBLIC	?gObjSetCharacter@@YAHPAEH@Z			; gObjSetCharacter
PUBLIC	?gObjSetMonster@@YAHHH@Z			; gObjSetMonster
PUBLIC	?gObjSetPosMonster@@YAHHH@Z			; gObjSetPosMonster
PUBLIC	?gObjViewportListCreate@@YAXF@Z			; gObjViewportListCreate
PUBLIC	?gObjViewportListDestroy@@YAXF@Z		; gObjViewportListDestroy
PUBLIC	?gObjViewportListProtocol@@YAXF@Z		; gObjViewportListProtocol
PUBLIC	?gObjSetState@@YAXXZ				; gObjSetState
PUBLIC	?gObjSecondProc@@YAXXZ				; gObjSecondProc
PUBLIC	?PShop_ViewportListRegenarate@@YAXF@Z		; PShop_ViewportListRegenarate
PUBLIC	?PShop_CheckInventoryEmpty@@YA_NF@Z		; PShop_CheckInventoryEmpty
PUBLIC	?gObjStateSetCreate@@YAXH@Z			; gObjStateSetCreate
PUBLIC	?gObjViewportPaint@@YAXPAUHWND__@@F@Z		; gObjViewportPaint
PUBLIC	?gObjGetUserNumber@@YAHH@Z			; gObjGetUserNumber
PUBLIC	?gObjGetNumber@@YAHHAAH0@Z			; gObjGetNumber
PUBLIC	?gObjLevelUp@@YA_NPAVOBJECTSTRUCT@@HHH@Z	; gObjLevelUp
PUBLIC	?gObjLevelUpPointAdd@@YAHEPAVOBJECTSTRUCT@@@Z	; gObjLevelUpPointAdd
PUBLIC	?LevelSmallConvert@@YAEHH@Z			; LevelSmallConvert
PUBLIC	?LevelSmallConvert@@YAEH@Z			; LevelSmallConvert
PUBLIC	?gObjInventoryInsertItem@@YAEHH@Z		; gObjInventoryInsertItem
PUBLIC	?gObjInventoryInsertItem@@YAEHVCItem@@@Z	; gObjInventoryInsertItem
PUBLIC	?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z	; gObjInventoryInsertItem
PUBLIC	?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z	; gObjOnlyInventoryInsertItem
PUBLIC	?gObjInventoryInsertItemTemp@@YAEPAVOBJECTSTRUCT@@PAVCMapItem@@@Z ; gObjInventoryInsertItemTemp
PUBLIC	?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z	; gObjShopBuyInventoryInsertItem
PUBLIC	?gObjShopBuyInventoryInsertItemSerial@@YAEHVCItem@@@Z ; gObjShopBuyInventoryInsertItemSerial
PUBLIC	?gObjSearchItem@@YAHPAVOBJECTSTRUCT@@HHH@Z	; gObjSearchItem
PUBLIC	?gObjSearchItemMinus@@YAHPAVOBJECTSTRUCT@@HH@Z	; gObjSearchItemMinus
PUBLIC	?gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHH@Z ; gObjInventoryInsertItem
PUBLIC	?gObjInventoryDeleteItem@@YAEHH@Z		; gObjInventoryDeleteItem
PUBLIC	?gObjInventoryItemSet@@YAXHHE@Z			; gObjInventoryItemSet
PUBLIC	?gObjInventoryItemBoxSet@@YAXHHHHE@Z		; gObjInventoryItemBoxSet
PUBLIC	?gObjMakePreviewCharSet@@YAXH@Z			; gObjMakePreviewCharSet
PUBLIC	?gObjInventoryItemSet_PShop@@YAXHHE@Z		; gObjInventoryItemSet_PShop
PUBLIC	?gObjInventoryItemBoxSet_PShop@@YAXHHHHE@Z	; gObjInventoryItemBoxSet_PShop
PUBLIC	?gObjAddMsgSend@@YAXPAVOBJECTSTRUCT@@HHH@Z	; gObjAddMsgSend
PUBLIC	?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
PUBLIC	?gObjAddMsgSendDelayInSpecificQPos@@YAXPAVOBJECTSTRUCT@@HHHHH@Z ; gObjAddMsgSendDelayInSpecificQPos
PUBLIC	?InitFrustrum@@YAXXZ				; InitFrustrum
PUBLIC	?CreateFrustrum@@YAXHHH@Z			; CreateFrustrum
PUBLIC	?gObjAttack@@YAHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
PUBLIC	?gObjMsgProc@@YAXPAVOBJECTSTRUCT@@@Z		; gObjMsgProc
PUBLIC	?gObjBackSpring@@YAHPAVOBJECTSTRUCT@@0@Z	; gObjBackSpring
PUBLIC	?GetPathPacketDirPos@@YAEHH@Z			; GetPathPacketDirPos
PUBLIC	?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z	; gObjCalDistance
PUBLIC	?gObjTeleportMagicUse@@YAXHEE@Z			; gObjTeleportMagicUse
PUBLIC	?gObjMagicManaUse@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicManaUse
PUBLIC	?gObjMagicBPUse@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@@Z ; gObjMagicBPUse
PUBLIC	?GetMoveArea@@YAXAAF0EEEEEAAE@Z			; GetMoveArea
PUBLIC	?gObjPosMagicAttack@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@EE@Z ; gObjPosMagicAttack
PUBLIC	?gObjMovePlayer@@YAHHEEEEE@Z			; gObjMovePlayer
PUBLIC	?gObjMoveGate@@YAHHH@Z				; gObjMoveGate
PUBLIC	?gObjMoveDataLoadingOK@@YAXH@Z			; gObjMoveDataLoadingOK
PUBLIC	?gObjTeleport@@YAXHHHH@Z			; gObjTeleport
PUBLIC	?gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EEEAAE@Z	; gObjMagicAdd
PUBLIC	?gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z		; gObjMagicAdd
PUBLIC	?gObjGetMagic@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@H@Z ; gObjGetMagic
PUBLIC	?gObjGetMagicSearch@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@E@Z ; gObjGetMagicSearch
PUBLIC	?MonsterAndMsgProc@@YAXXZ			; MonsterAndMsgProc
PUBLIC	?MoveMonsterProc@@YAXXZ				; MoveMonsterProc
PUBLIC	?gObjTradeCancel@@YAXH@Z			; gObjTradeCancel
PUBLIC	?gObjTradeOkButton@@YAXH@Z			; gObjTradeOkButton
PUBLIC	?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z	; gObjInventoryMoveItem
PUBLIC	?gObjTradeInventoryMove@@YAEPAVOBJECTSTRUCT@@EE@Z ; gObjTradeInventoryMove
PUBLIC	?gObjTradeTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z	; gObjTradeTradeMove
PUBLIC	?gObjInventoryTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z ; gObjInventoryTradeMove
PUBLIC	?gObjInventoryTrans@@YAHH@Z			; gObjInventoryTrans
PUBLIC	?gObjInventoryCommit@@YAHH@Z			; gObjInventoryCommit
PUBLIC	?gObjItemLevelUp@@YAHPAVOBJECTSTRUCT@@HH@Z	; gObjItemLevelUp
PUBLIC	?gObjItemRandomLevelUp@@YAHPAVOBJECTSTRUCT@@HH@Z ; gObjItemRandomLevelUp
PUBLIC	?gObjItemRandomOption3Up@@YAHPAVOBJECTSTRUCT@@HH@Z ; gObjItemRandomOption3Up
PUBLIC	?gObjUseDrink@@YAXPAVOBJECTSTRUCT@@H@Z		; gObjUseDrink
PUBLIC	?gObjAbilityReSet@@YAXPAVOBJECTSTRUCT@@@Z	; gObjAbilityReSet
PUBLIC	?gGetItemNumber@@YAKXZ				; gGetItemNumber
PUBLIC	?gPlusItemNumber@@YAXXZ				; gPlusItemNumber
PUBLIC	?gObjAllDisconnect@@YAXXZ			; gObjAllDisconnect
PUBLIC	?gObjAllLogOut@@YAXXZ				; gObjAllLogOut
PUBLIC	?gObjCloseSet@@YAXHH@Z				; gObjCloseSet
PUBLIC	?gObjCheckViewport@@YAHHHH@Z			; gObjCheckViewport
PUBLIC	?gObjPositionCheck@@YAHPAVOBJECTSTRUCT@@@Z	; gObjPositionCheck
PUBLIC	?gObjCheckTileArea@@YAHHHHH@Z			; gObjCheckTileArea
PUBLIC	?gObjGuildMasterCapacityTest@@YAHPAVOBJECTSTRUCT@@@Z ; gObjGuildMasterCapacityTest
PUBLIC	?gObjGuildWarEndSend@@YAXPAVOBJECTSTRUCT@@EE@Z	; gObjGuildWarEndSend
PUBLIC	?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z ; gObjGuildWarEndSend
PUBLIC	?gObjGuildWarProc@@YAHPAU_GUILD_INFO_STRUCT@@0H@Z ; gObjGuildWarProc
PUBLIC	?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z	; gObjGuildWarEnd
PUBLIC	?gObjGetPkTime@@YAHPAVOBJECTSTRUCT@@AAH1@Z	; gObjGetPkTime
PUBLIC	?gObjInventorySearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
PUBLIC	?gObjSetInventory1Pointer@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer
PUBLIC	?gObjStatTextSave@@YAXPAVOBJECTSTRUCT@@@Z	; gObjStatTextSave
PUBLIC	?gObjMagicTextSave@@YAXPAVOBJECTSTRUCT@@@Z	; gObjMagicTextSave
PUBLIC	?gObjItemTextSave@@YAXPAVOBJECTSTRUCT@@@Z	; gObjItemTextSave
PUBLIC	?gObjWarehouseTextSave@@YAXPAVOBJECTSTRUCT@@@Z	; gObjWarehouseTextSave
PUBLIC	?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z	; gObjWarehouseInsertItemPos
PUBLIC	?gObjWarehouseItemSet@@YAXHHE@Z			; gObjWarehouseItemSet
PUBLIC	?gObjMonsterCall@@YAHHHHH@Z			; gObjMonsterCall
PUBLIC	?gObjMonsterCallKill@@YAXH@Z			; gObjMonsterCallKill
PUBLIC	?gObjBackSpring2@@YAHPAVOBJECTSTRUCT@@0H@Z	; gObjBackSpring2
PUBLIC	?gObjSetTradeOption@@YAXHH@Z			; gObjSetTradeOption
PUBLIC	?gObjSetDuelOption@@YAXHH@Z			; gObjSetDuelOption
PUBLIC	?IsDuelEnable@@YA_NH@Z				; IsDuelEnable
PUBLIC	?IsOnDuel@@YA_NHH@Z				; IsOnDuel
PUBLIC	?gObjClearViewportOfMine@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewportOfMine
PUBLIC	?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z	; gObjClearViewport
PUBLIC	?gObjViewportListProtocolDestroy@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy
PUBLIC	?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
PUBLIC	?GetMapMoveLevel@@YAHPAVOBJECTSTRUCT@@HH@Z	; GetMapMoveLevel
PUBLIC	?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z	; gObjChaosBoxInsertItemPos
PUBLIC	?gObjChaosItemSet@@YAXHHE@Z			; gObjChaosItemSet
PUBLIC	?gObjCanItemTouch@@YAHPAVOBJECTSTRUCT@@H@Z	; gObjCanItemTouch
PUBLIC	?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z		; ItemIsBufExOption
PUBLIC	?gObjCheckTeleportArea@@YAHHEE@Z		; gObjCheckTeleportArea
PUBLIC	?gObjCheckAttackArea@@YAHHH@Z			; gObjCheckAttackArea
PUBLIC	?gObjIsSelfDefense@@YA_NPAVOBJECTSTRUCT@@H@Z	; gObjIsSelfDefense
PUBLIC	?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@@Z		; gObjDuelCheck
PUBLIC	?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@0@Z		; gObjDuelCheck
PUBLIC	?gObjResetDuel@@YAXPAVOBJECTSTRUCT@@@Z		; gObjResetDuel
PUBLIC	?gObjSendDuelEnd@@YAXPAVOBJECTSTRUCT@@@Z	; gObjSendDuelEnd
PUBLIC	?gObjCheckAllUserDuelStop@@YAXXZ		; gObjCheckAllUserDuelStop
PUBLIC	?gUserFindDevilSquareInvitation@@YAHH@Z		; gUserFindDevilSquareInvitation
PUBLIC	?gUserFindDevilSquareKeyEyes@@YAHH@Z		; gUserFindDevilSquareKeyEyes
PUBLIC	?gObjSendUserStatistic@@YAXHHH@Z		; gObjSendUserStatistic
PUBLIC	?gObjFind@@YAPAVOBJECTSTRUCT@@PAD@Z		; gObjFind
PUBLIC	?gObjFind10EventChip@@YAHH@Z			; gObjFind10EventChip
PUBLIC	?gObjDelete10EventChip@@YAHH@Z			; gObjDelete10EventChip
PUBLIC	?gObjSetPosition@@YAXHHH@Z			; gObjSetPosition
PUBLIC	?gObjGetItemCountInIventory@@YAHHHHH@Z		; gObjGetItemCountInIventory
PUBLIC	?gObjGetItemCountInIventory@@YAHHH@Z		; gObjGetItemCountInIventory
PUBLIC	?gObjGetManaItemPos@@YAHH@Z			; gObjGetManaItemPos
PUBLIC	?gObjDelteItemCountInInventory@@YAXHHHH@Z	; gObjDelteItemCountInInventory
PUBLIC	?gObjUseCircle@@YAXHH@Z				; gObjUseCircle
PUBLIC	?gObjSetBP@@YAXH@Z				; gObjSetBP
PUBLIC	?gObjCalcMaxLifePower@@YAXH@Z			; gObjCalcMaxLifePower
PUBLIC	?gObjGetStatPointState@@YAXHAAF0@Z		; gObjGetStatPointState
PUBLIC	?gObjPenaltyDurDown@@YAXPAVOBJECTSTRUCT@@0@Z	; gObjPenaltyDurDown
PUBLIC	?gObjWeaponDurDown@@YAXPAVOBJECTSTRUCT@@0H@Z	; gObjWeaponDurDown
PUBLIC	?gObjArmorRandomDurDown@@YAXPAVOBJECTSTRUCT@@0@Z ; gObjArmorRandomDurDown
PUBLIC	?gObjTargetGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
PUBLIC	?gObjCheckSelfDefense@@YAXPAVOBJECTSTRUCT@@H@Z	; gObjCheckSelfDefense
PUBLIC	?gObjAttackQ@@YAHPAVOBJECTSTRUCT@@@Z		; gObjAttackQ
PUBLIC	?gObjLifeCheck@@YAXPAVOBJECTSTRUCT@@0HHHHE@Z	; gObjLifeCheck
PUBLIC	?retResistance@@YAHPAVOBJECTSTRUCT@@H@Z		; retResistance
PUBLIC	?retCalcSkillResistance@@YAHPAVOBJECTSTRUCT@@H@Z ; retCalcSkillResistance
PUBLIC	?gObjSpriteDamage@@YAXPAVOBJECTSTRUCT@@H@Z	; gObjSpriteDamage
PUBLIC	?gObjSatanSprite@@YAHPAVOBJECTSTRUCT@@@Z	; gObjSatanSprite
PUBLIC	?gObjAngelSprite@@YAHPAVOBJECTSTRUCT@@@Z	; gObjAngelSprite
PUBLIC	?gObjWingSprite@@YAHPAVOBJECTSTRUCT@@@Z		; gObjWingSprite
PUBLIC	?gObjUniriaSprite@@YAHPAVOBJECTSTRUCT@@@Z	; gObjUniriaSprite
PUBLIC	?gObjNextExpCal@@YAXPAVOBJECTSTRUCT@@@Z		; gObjNextExpCal
PUBLIC	?gObjDelayLifeCheck@@YAXH@Z			; gObjDelayLifeCheck
PUBLIC	?SkillFrustrum@@YAXEH@Z				; SkillFrustrum
PUBLIC	?SkillTestFrustrum@@YAHHHH@Z			; SkillTestFrustrum
PUBLIC	?gObjGetItemCountInEquipment@@YAHHHHH@Z		; gObjGetItemCountInEquipment
PUBLIC	?gObjCheckMaxZen@@YAHHH@Z			; gObjCheckMaxZen
PUBLIC	?gObjIsItemPut@@YAHPAVOBJECTSTRUCT@@PAVCItem@@H@Z ; gObjIsItemPut
PUBLIC	?MakeRandomSetItem@@YAXH@Z			; MakeRandomSetItem
PUBLIC	?gObjMagicEnergyCheck@@YAHPAVOBJECTSTRUCT@@E@Z	; gObjMagicEnergyCheck
PUBLIC	?gObjRecall@@YAXHHHH@Z				; gObjRecall
PUBLIC	?gObjSetExpPetItem@@YAXHH@Z			; gObjSetExpPetItem
PUBLIC	?gObjFixInventoryPointer@@YA_NH@Z		; gObjFixInventoryPointer
PUBLIC	?MakeRewardSetItem@@YAXHEEH@Z			; MakeRewardSetItem
PUBLIC	?MsgOutput@@YAXHPADZZ				; MsgOutput
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
PUBLIC	?Size@CTerrainManager@@QAE?BHXZ			; CTerrainManager::Size
PUBLIC	?GetMinLevel@CTerrainManager@@QAEHH@Z		; CTerrainManager::GetMinLevel
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::end
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::find
PUBLIC	?_Getcomp@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Getcomp
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,_TERRAIN_INFO>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,1>,1>::_Get_first
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,std::_Iterator_base0>
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator*
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator==
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator*
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator->
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@SAPAU?$pair@$$CBHU_TERRAIN_INFO@@@2@AAU32@@Z ; std::pointer_traits<std::pair<int const ,_TERRAIN_INFO> *>::pointer_to
PUBLIC	??$_Find@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Find<int>
PUBLIC	??$addressof@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@YAPAU?$pair@$$CBHU_TERRAIN_INFO@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_TERRAIN_INFO> >
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >
PUBLIC	??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Find_lower_bound<int>
PUBLIC	??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Lower_bound_duplicate<int>
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@ABV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > const >
PUBLIC	??$_Kfn@$$CBHU_TERRAIN_INFO@@@?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_TERRAIN_INFO@@@1@@Z ; std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0>::_Kfn<int const ,_TERRAIN_INFO>
PUBLIC	?TalkRefDel@CQeustNpcTeleport@@QAEXXZ		; CQeustNpcTeleport::TalkRefDel
PUBLIC	?GetState@CDragonEvent@@QAEEXZ			; CDragonEvent::GetState
PUBLIC	?GetMapNumber@CDragonEvent@@QAEEXZ		; CDragonEvent::GetMapNumber
PUBLIC	?gObjMonsterExpSingle@@YAHPAVOBJECTSTRUCT@@0HHAA_N@Z ; gObjMonsterExpSingle
PUBLIC	?gObjMonsterExpDivision@@YAXPAVOBJECTSTRUCT@@0HH@Z ; gObjMonsterExpDivision
PUBLIC	??0StaticObject@@QAE@XZ				; StaticObject::StaticObject
PUBLIC	??1StaticObject@@UAE@XZ				; StaticObject::~StaticObject
PUBLIC	??_GStaticObject@@UAEPAXI@Z			; StaticObject::`scalar deleting destructor'
PUBLIC	?ViewportAdd@@YAHHHH@Z				; ViewportAdd
PUBLIC	?ViewportAdd2@@YAHHHH@Z				; ViewportAdd2
PUBLIC	?gObjRefillProcess@@YAXHPAVOBJECTSTRUCT@@@Z	; gObjRefillProcess
PUBLIC	?gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHH@Z ; gObjInventoryInsertItem
PUBLIC	?gObjGiveItemSearch@@YAXPAVOBJECTSTRUCT@@H@Z	; gObjGiveItemSearch
PUBLIC	?gObjMonsterItemLoadScript@@YAXPAVOBJECTSTRUCT@@PAD@Z ; gObjMonsterItemLoadScript
PUBLIC	?gObjMonsterInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHHH@Z ; gObjMonsterInventoryInsertItem
PUBLIC	?gObjWarehouseInsertItem@@YAEPAVOBJECTSTRUCT@@HHHH@Z ; gObjWarehouseInsertItem
PUBLIC	?gObjGiveItemWarehouseSearch@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjGiveItemWarehouseSearch
PUBLIC	?gObjSkillUseProc@@YAXPAVOBJECTSTRUCT@@@Z	; gObjSkillUseProc
PUBLIC	?gObjStateProc@@YAXPAVOBJECTSTRUCT@@HHH@Z	; gObjStateProc
PUBLIC	?ViewportDel@@YAXFH@Z				; ViewportDel
PUBLIC	?Viewport2Del@@YAXFH@Z				; Viewport2Del
PUBLIC	?gObjViewportAllDel@@YAXF@Z			; gObjViewportAllDel
PUBLIC	?gObjSkillBeAttackProc@@YAXPAVOBJECTSTRUCT@@@Z	; gObjSkillBeAttackProc
PUBLIC	?gObjMagicDel@@YAHPAVOBJECTSTRUCT@@EE@Z		; gObjMagicDel
PUBLIC	?gObjManaPotionFill@@YAXPAVOBJECTSTRUCT@@@Z	; gObjManaPotionFill
PUBLIC	?gObjRestPotionFill@@YAXPAVOBJECTSTRUCT@@@Z	; gObjRestPotionFill
PUBLIC	?TradeItemInventoryPutTest@@YAHH@Z		; TradeItemInventoryPutTest
PUBLIC	?gObjMonsterDieLifePlus@@YAXPAVOBJECTSTRUCT@@0@Z ; gObjMonsterDieLifePlus
PUBLIC	?gObjInventoryInsertItemPos@@YAEHVCItem@@HH@Z	; gObjInventoryInsertItemPos
PUBLIC	?gObjTradeSave@@YAXPAVOBJECTSTRUCT@@H@Z		; gObjTradeSave
PUBLIC	?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z	; gObjMonsterMagicAdd
PUBLIC	?gObjAuthorityCodeSet@@YAXPAVOBJECTSTRUCT@@@Z	; gObjAuthorityCodeSet
PUBLIC	?gObjGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z	; gObjGuildWarCheck
PUBLIC	?gObjGuildWarMasterClose@@YAHPAVOBJECTSTRUCT@@@Z ; gObjGuildWarMasterClose
PUBLIC	?gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarItemGive
PUBLIC	?gObjWarehouseDeleteItem@@YAEHH@Z		; gObjWarehouseDeleteItem
PUBLIC	?gObjChaosBoxDeleteItem@@YAEHH@Z		; gObjChaosBoxDeleteItem
PUBLIC	?gObjChangeDurProc@@YAXPAVOBJECTSTRUCT@@@Z	; gObjChangeDurProc
PUBLIC	?gObjWingDurProc@@YAXPAVOBJECTSTRUCT@@@Z	; gObjWingDurProc
PUBLIC	?gObjInventoryRollback@@YAHH@Z			; gObjInventoryRollback
PUBLIC	?gObjSkillUseProcTime500@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSkillUseProcTime500
PUBLIC	?gObjCharTradeClear@@YAXPAVOBJECTSTRUCT@@@Z	; gObjCharTradeClear
PUBLIC	?gObjCharZeroSet@@YAXH@Z			; gObjCharZeroSet
PUBLIC	?DbItemSetInByte@@YAXPAVOBJECTSTRUCT@@PAUSDHP_DBCHAR_INFORESULT@@HPA_N@Z ; DbItemSetInByte
PUBLIC	?gObjMonsterRecall@@YAFH@Z			; gObjMonsterRecall
PUBLIC	?gObjIsConnectedGP@@YAHHPAD@Z			; gObjIsConnectedGP
PUBLIC	?gObjTaiwanJoominCheck@@YAHHPAD@Z		; gObjTaiwanJoominCheck
PUBLIC	?ExtentCheck@@YAHHHHH@Z				; ExtentCheck
PUBLIC	?gObjSetInventory2Pointer@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSetInventory2Pointer
PUBLIC	?BackSpringCheck@@YAHAAH00E@Z			; BackSpringCheck
PUBLIC	?gObjPlayerKiller@@YAXPAVOBJECTSTRUCT@@0@Z	; gObjPlayerKiller
PUBLIC	?gObjUserDie@@YAXPAVOBJECTSTRUCT@@0@Z		; gObjUserDie
PUBLIC	?gObjInterfaceTimeCheck@@YAXPAVOBJECTSTRUCT@@@Z	; gObjInterfaceTimeCheck
PUBLIC	?gObjPkDownTimeCheck@@YAXPAVOBJECTSTRUCT@@H@Z	; gObjPkDownTimeCheck
PUBLIC	?gObjSecondDurDown@@YAXPAVOBJECTSTRUCT@@@Z	; gObjSecondDurDown
PUBLIC	?gObjExpParty@@YAXPAVOBJECTSTRUCT@@0HH@Z	; gObjExpParty
PUBLIC	?gObjWerehouseRectCheck@@YAEHHHHH@Z		; gObjWerehouseRectCheck
PUBLIC	?gObjMapRectCheck@@YAEPAEHHHHHH@Z		; gObjMapRectCheck
PUBLIC	?gObjWarehouseItemBoxSet@@YAXHHHHE@Z		; gObjWarehouseItemBoxSet
PUBLIC	?gObjChaosItemBoxSet@@YAXHHHHE@Z		; gObjChaosItemBoxSet
PUBLIC	?gObjWarehouseSearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z ; gObjWarehouseSearchSerialNumber
PUBLIC	?gObjTradeRectCheck@@YAEHHHHH@Z			; gObjTradeRectCheck
PUBLIC	?gObjTradeItemBoxSet@@YAHHHHHE@Z		; gObjTradeItemBoxSet
PUBLIC	?gObjTempInventoryItemBoxSet@@YAXPAEHHHE@Z	; gObjTempInventoryItemBoxSet
PUBLIC	?gObjTempInventoryRectCheck@@YAEPAEHHHH@Z	; gObjTempInventoryRectCheck
PUBLIC	?gObjTempInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@VCItem@@PAE@Z ; gObjTempInventoryInsertItem
PUBLIC	?TradeitemInventoryPut@@YAHH@Z			; TradeitemInventoryPut
PUBLIC	?gObjAttackDamageCalc@@YAXH@Z			; gObjAttackDamageCalc
PUBLIC	?TestFrustrum2@@YA_NHHH@Z			; TestFrustrum2
PUBLIC	?gObjCurMoveMake@@YAHQAEPAVOBJECTSTRUCT@@@Z	; gObjCurMoveMake
PUBLIC	?gObjCheckAttackAreaUsedPath@@YAHHH@Z		; gObjCheckAttackAreaUsedPath
PUBLIC	?gObjCheckattackAreaUsedViewPort@@YAHHH@Z	; gObjCheckattackAreaUsedViewPort
PUBLIC	?gObjCheckStatPointUp@@YAHH@Z			; gObjCheckStatPointUp
PUBLIC	?gObjCheckStatPointDown@@YAHH@Z			; gObjCheckStatPointDown
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	?m_ObjBill@@3PAVBILL_CLASS@@A			; m_ObjBill
PUBLIC	??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd@ ; `string'
PUBLIC	?ViewGuildMng@@3VCViewportGuild@@A		; ViewGuildMng
PUBLIC	??_7StaticObject@@6B@				; StaticObject::`vftable'
PUBLIC	?g_kStaticObject@@3VStaticObject@@A		; g_kStaticObject
PUBLIC	?__LINE__Var@?0??gObjSkillUseProcTime500@@YAXPAVOBJECTSTRUCT@@@Z@4JA ; `gObjSkillUseProcTime500'::`1'::__LINE__Var
PUBLIC	??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ ; `string'
PUBLIC	??_C@_0DF@NOIKLNAL@?$KB?Z?$FLCHECK_LOG_INFINITY?$FN?5gObjIsCo@ ; `string'
PUBLIC	??_C@_0DE@GDMCBCLE@?$KB?Z?$FLCHECK_LOG_INFINITY?$FN?5?$CI?5_count@ ; `string'
PUBLIC	??_C@_0GG@GPEABMHM@?$FL?5CHECK?5POSITION?5?$FN?5MoveMosterPr@ ; `string'
PUBLIC	?__LINE__Var@?0??GetMapMoveLevel@@YAHPAVOBJECTSTRUCT@@HH@Z@4JA ; `GetMapMoveLevel'::`1'::__LINE__Var
PUBLIC	??_C@_0CA@HDKCFMCD@error?9L3?5?3?5map?5number?5not?5?$CFs?5?$CFd@ ; `string'
PUBLIC	??_C@_0GK@NPPGCJHE@error?9L2?5?3?5Unknown?5Item?5found?5?$FL@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjSetCharacter@@YAHPAEH@Z@4JA ; `gObjSetCharacter'::`1'::__LINE__Var
PUBLIC	??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@	; `string'
PUBLIC	??_C@_0CF@CDKKBDHM@error?9L1?5?3?5ChaosBox?5Init?5error?5@ ; `string'
PUBLIC	??_C@_0BG@PGPOOLHE@error?5?3?5?$CFs?5Level?5Zero@ ; `string'
PUBLIC	??_C@_0CD@JILLGNNC@error?5?3?5Map?5Number?5max?5over?4?5?$CFs@ ; `string'
PUBLIC	??_C@_0BD@DHOELAFE@error?5?3?5?$CFd?5?$CI?$CFs?5?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0CF@PDDCMPCL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Find?5Invalid?5QuestInfo@ ; `string'
PUBLIC	??_C@_0BG@DNBFMJJP@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Set?5Event?5GM@ ; `string'
PUBLIC	??_C@_0CC@GOGGAFJG@Penalty?5?3?5Item?5Don?8t?5touch?5?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0BF@JCIHPMHF@?$LO?x?$LE?B?5?$LO?F?$MA?L?E?$NL?5?$LJ?$NP?$LA?$NP?5?$CB?$CB?$CB@ ; `string'
PUBLIC	??_C@_08NKGJGPDF@?1vipinfo@			; `string'
PUBLIC	??_C@_0CA@EIDBCBFJ@?$FLCASH?5SYSTEM?$FN?5Tienes?5?$CFd?5de?5Cash@ ; `string'
PUBLIC	??_C@_0BC@JJLOFGFB@?$CFd?1?$CFm?1?$CFY?5?$CFH?3?$CFM?3?$CFS@ ; `string'
PUBLIC	??_C@_0CB@PBFGMDKK@VIP?5User?5Connected?3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0BK@EFNGMPBL@Free?5User?5Connected?3?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0HG@OJODFIFG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CharInfoSave?5?3?5Class?$DN?$CF@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjSetPosMonster@@YAHHH@Z@4JA	; `gObjSetPosMonster'::`1'::__LINE__Var
PUBLIC	??_C@_0BJ@KEIINKC@error?9L2?5?3?5?$CFd?5class?5?3?5?$CFd@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjSetMonster@@YAHHH@Z@4JA	; `gObjSetMonster'::`1'::__LINE__Var
PUBLIC	??_C@_0BF@DGECBEHF@?C?$LF?$LA?x?$LK?$LI?$LN?$LK?$LI?w?5?$LM?$LD?A?$KE?5?$LN?G?F?P@ ; `string'
PUBLIC	??_C@_0BP@GCONPPCF@SkyLand?5Boss?5Monster?5Setting?$CB?$CB@ ; `string'
PUBLIC	??_C@_0BO@HDDGJDLK@SkyLand?5Boss?5Shield?5Setting?$CB?$CB@ ; `string'
PUBLIC	??_C@_0BD@LOIPIKDB@connect?5?3?5?$FL?$CFd?$FN?$FL?$CFs?$FN@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjAddMonster@@YAFH@Z@4JA	; `gObjAddMonster'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjAddCallMon@@YAFXZ@4JA	; `gObjAddCallMon'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjMemFree@@YAFH@Z@4JA	; `gObjMemFree'::`1'::__LINE__Var
PUBLIC	??_C@_0CB@PNMAPJFE@?$CI?$CFs?$CJ?$CI?$CFd?$CJ?5?$DN?5index?5over?5error?5?$CI?$CFd@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjGameClose@@YAHH@Z@4JA	; `gObjGameClose'::`1'::__LINE__Var
PUBLIC	??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjDel@@YAFH@Z@4JA		; `gObjDel'::`1'::__LINE__Var
PUBLIC	??_C@_0BK@FHEGNDKC@?$CI?$CFd?$CJlogout?9send?5?3?5?$CFs?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0CL@DMPMEDAE@?0?5?$CI?$CFd?$CJlogout?9send?5?3?0?5Account?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0BF@FJCKJIOE@?$CI?$CFd?$CJlogout?5?3?5?$CFs?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_C@_0CG@GAOPIMKK@?0?5?$CI?$CFd?$CJlogout?5?3?0?5Account?5?$FL?$CFs?$FN?0?5I@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjSometimeClose@@YAFH@Z@4JA	; `gObjSometimeClose'::`1'::__LINE__Var
PUBLIC	??_C@_0GB@MEEFOHBG@?$FL?5CHECK?5POSITION?5?$FN?5DbgName?$FL?$CFd?$FN?5@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjSetAccountLogin@@YAHHPADHH0@Z@4JA ; `gObjSetAccountLogin'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjGetUserNumber@@YAHH@Z@4JA	; `gObjGetUserNumber'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjGetNumber@@YAHHAAH0@Z@4JA	; `gObjGetNumber'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjGetAccountId@@YAPADH@Z@4JA	; `gObjGetAccountId'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjUserIdConnectCheck@@YAHPADH@Z@4JA ; `gObjUserIdConnectCheck'::`1'::__LINE__Var
PUBLIC	??_C@_0BN@NCIMKKEA@error?5?3?5index?5error?5?$CB?$CB?5?$CFs?5?$CFd@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjStateProc@@YAXPAVOBJECTSTRUCT@@HHH@Z@4JA ; `gObjStateProc'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjStateAttackProc@@YAXPAVOBJECTSTRUCT@@HHHH@Z@4JA ; `gObjStateAttackProc'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjBackSpring@@YAHPAVOBJECTSTRUCT@@0@Z@4JA ; `gObjBackSpring'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjBackSpring2@@YAHPAVOBJECTSTRUCT@@0H@Z@4JA ; `gObjBackSpring2'::`1'::__LINE__Var
PUBLIC	??_C@_0FI@OHEIPIHL@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjLevelUpPointAdd@@YAHEPAVOBJECTSTRUCT@@@Z@4JA ; `gObjLevelUpPointAdd'::`1'::__LINE__Var
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs@	; `string'
PUBLIC	??_C@_0GE@HFNAODDP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5PK?5Info?5Set?5?$CIKilled?5Pl@ ; `string'
PUBLIC	??_C@_0CP@MMNCCLML@?$FLDevilSquare?$FN?5Dead?5In?5DevilSqua@ ; `string'
PUBLIC	??_C@_0DJ@HJPHEOFL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Try?5to?5drop@ ; `string'
PUBLIC	??_C@_0DL@COJKOION@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Try?5to?5dele@ ; `string'
PUBLIC	??_C@_0EJ@EGIDAPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Dead?5In?5Blo@ ; `string'
PUBLIC	??_C@_0EM@NNNAIELC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Dead?5In?5Blo@ ; `string'
PUBLIC	??_C@_07GOHPBKOH@Monster@			; `string'
PUBLIC	??_C@_0CI@JFDMHJOK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Killed?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pos?3?$CI?$CF@ ; `string'
PUBLIC	??_C@_0EG@HIGLADFI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CIPkLevel?5?$DN?5?$CFd?$CJ?5Killed?5@ ; `string'
PUBLIC	??_C@_0GL@DJDDMNFC@Killed?5by?5User?5State?5Victim?3?$FL?$CFs@ ; `string'
PUBLIC	??_C@_0CJ@CKMJEEKH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5User?5Die?5Item?5Drop?0?5It@ ; `string'
PUBLIC	??_C@_0CK@PAJOKIHI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Death?5reduces?5Experien@ ; `string'
PUBLIC	??_C@_0DL@HDCMLJGF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemExpDown?$FN?5?$FL?$CFs?$FN?5L@ ; `string'
PUBLIC	??_C@_0CC@IPHFNLBG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Set?5SelfDefence?5?$FL?$CFs?$FN?$FL?$CF@ ; `string'
PUBLIC	??_C@_0CE@HGMOIFIK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5ReSet?5SelfDefence?5?$FL?$CFs?$FN@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjExpParty@@YAXPAVOBJECTSTRUCT@@0HH@Z@4JA ; `gObjExpParty'::`1'::__LINE__Var
PUBLIC	??_C@_0BP@GEEBCKIA@?$FL?$CFs?$FN?5derroto?5un?5Goblin?5Dorado?4@ ; `string'
PUBLIC	??_C@_0BO@EDKFBDOM@?$FL?$CFs?$FN?5derroto?5un?5Titan?5Dorado?4@ ; `string'
PUBLIC	??_C@_0BP@IAJJAOEN@?$FL?$CFs?$FN?5derroto?5un?5Dragon?5Dorado?4@ ; `string'
PUBLIC	??_C@_0CE@OLGAAMMO@?$FL?$CFs?$FN?5derroto?5un?5Lizard?5King?5Dor@ ; `string'
PUBLIC	??_C@_0CA@HJAGOCKC@?$FL?$CFs?$FN?5derroto?5un?5Tantalo?5Dorado?4@ ; `string'
PUBLIC	??_C@_0DD@JANPNOOL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Termin@ ; `string'
PUBLIC	??_C@_0CL@NGGLKHML@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Termin@ ; `string'
PUBLIC	??_C@_0EG@KMNGALHI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5a?5stone?5sta@ ; `string'
PUBLIC	??_C@_0DN@HEKHJLCJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5a?5stone?5sta@ ; `string'
PUBLIC	??_C@_0EM@OALGHOD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Us@ ; `string'
PUBLIC	??_C@_0CJ@KJGJCOOM@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win?5Duel?0?5Loser@ ; `string'
PUBLIC	??_C@_0FA@KCJNEJFM@UPDATE?5?$FLMuOnline?$FN?4?$FLdbo?$FN?4?$FLCharac@ ; `string'
PUBLIC	??_C@_0FC@PMECEPOA@UPDATE?5?$FLMuOnline?$FN?4?$FLdbo?$FN?4?$FLCharac@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjInventoryTrans@@YAHH@Z@4JA	; `gObjInventoryTrans'::`1'::__LINE__Var
PUBLIC	??_C@_0DI@CKMLLKAG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransactio@ ; `string'
PUBLIC	??_C@_0BH@NHBCKBPB@Trade?5Transaction?5?$CI?$CFs?$CJ@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjInventoryCommit@@YAHH@Z@4JA ; `gObjInventoryCommit'::`1'::__LINE__Var
PUBLIC	??_C@_0DK@NFIOKOGL@error?5?3?5gObjInventoryCommit?$CI?$CJ?5?9@ ; `string'
PUBLIC	??_C@_0CN@FHLLPNOD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransactio@ ; `string'
PUBLIC	??_C@_0BC@PKOGNFCH@Trade?5Commit?5?$CI?$CFs?$CJ@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjInventoryRollback@@YAHH@Z@4JA ; `gObjInventoryRollback'::`1'::__LINE__Var
PUBLIC	??_C@_0BE@GIFOPHN@Trade?5Rollback?5?$CI?$CFs?$CJ@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjInventoryItemSet@@YAXHHE@Z@4JA ; `gObjInventoryItemSet'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjInventoryItemBoxSet@@YAXHHHHE@Z@4JA ; `gObjInventoryItemBoxSet'::`1'::__LINE__Var
PUBLIC	??_C@_0CG@KONHFAKK@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5discon@ ; `string'
PUBLIC	??_C@_0EB@NEEGDNDB@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Transa@ ; `string'
PUBLIC	??_C@_0DB@GPLONBA@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Invent@ ; `string'
PUBLIC	??_C@_0DF@DPJDFIHG@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Invent@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjInventoryItemSet_PShop@@YAXHHE@Z@4JA ; `gObjInventoryItemSet_PShop'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjInventoryItemBoxSet_PShop@@YAXHHHHE@Z@4JA ; `gObjInventoryItemBoxSet_PShop'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjInventoryInsertItem@@YAEHH@Z@4JA ; `gObjInventoryInsertItem'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjInventoryInsertItem@@YAEHVCItem@@@Z@4JA ; `gObjInventoryInsertItem'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z@4JA ; `gObjOnlyInventoryInsertItem'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z@4JA ; `gObjInventoryInsertItem'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjSearchItemMinus@@YAHPAVOBJECTSTRUCT@@HH@Z@4JA ; `gObjSearchItemMinus'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FDAFLGGN@error?9L4?5?3?5?$CFs?5?$CFd@	; `string'
PUBLIC	?__LINE__Var@?0??gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z@4JA ; `gObjShopBuyInventoryInsertItem'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjShopBuyInventoryInsertItemSerial@@YAEHVCItem@@@Z@4JA ; `gObjShopBuyInventoryInsertItemSerial'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjInventoryInsertItemTemp@@YAEPAVOBJECTSTRUCT@@PAVCMapItem@@@Z@4JA ; `gObjInventoryInsertItemTemp'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHH@Z@4JA ; `gObjInventoryInsertItem'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHH@Z@4JA ; `gObjInventoryInsertItem'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjInventoryRectCheck@@YAEHHHHH@Z@4JA ; `gObjInventoryRectCheck'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjOnlyInventoryRectCheck@@YAEHHHHH@Z@4JA ; `gObjOnlyInventoryRectCheck'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjWerehouseRectCheck@@YAEHHHHH@Z@4JA ; `gObjWerehouseRectCheck'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjMapRectCheck@@YAEPAEHHHHHH@Z@4JA ; `gObjMapRectCheck'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjWarehouseItemBoxSet@@YAXHHHHE@Z@4JA ; `gObjWarehouseItemBoxSet'::`1'::__LINE__Var
PUBLIC	??_C@_0BF@PBCPKOJP@error?5?3?5?$CFd?1?$CFd?5?5?$CFs?5?$CFd@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjWarehouseItemSet@@YAXHHE@Z@4JA ; `gObjWarehouseItemSet'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjChaosItemBoxSet@@YAXHHHHE@Z@4JA ; `gObjChaosItemBoxSet'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjChaosItemSet@@YAXHHE@Z@4JA	; `gObjChaosItemSet'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z@4JA ; `gObjInventoryMoveItem'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd@	; `string'
PUBLIC	??_C@_0EL@PCJJPCHK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Mov@ ; `string'
PUBLIC	??_C@_0EA@MOKNMDJN@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLMov@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjTradeRectCheck@@YAEHHHHH@Z@4JA ; `gObjTradeRectCheck'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjTradeItemBoxSet@@YAHHHHHE@Z@4JA ; `gObjTradeItemBoxSet'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjTradeInventoryMove@@YAEPAVOBJECTSTRUCT@@EE@Z@4JA ; `gObjTradeInventoryMove'::`1'::__LINE__Var
PUBLIC	??_C@_0DN@CJKEGDHI@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLTra@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjInventoryTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z@4JA ; `gObjInventoryTradeMove'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjTradeTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z@4JA ; `gObjTradeTradeMove'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjTradeCancel@@YAXH@Z@4JA	; `gObjTradeCancel'::`1'::__LINE__Var
PUBLIC	??_C@_0BK@CICIFNII@error?5?3?5index?5error?5?$CFs?5?$CFd@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjTempInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@VCItem@@PAE@Z@4JA ; `gObjTempInventoryInsertItem'::`1'::__LINE__Var
PUBLIC	??_C@_04BGCMBJDA@Item@				; `string'
PUBLIC	??_C@_0BK@ELKLKHDB@error?5?3?5?$MA?L?$LA?G?5?E?$KL?$MA?O?$LD?$KK?$LE?B?$MA?O?$CB?$CB@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjMakePreviewCharSet@@YAXH@Z@4JA ; `gObjMakePreviewCharSet'::`1'::__LINE__Var
PUBLIC	??_C@_0FD@OILHKKPM@COUNT?3?$CFd?5?5TotalPlayer?5?3?5?$CFd?5?5Pla@ ; `string'
PUBLIC	??_C@_0M@IBFDBMCH@?3StarOfXMas@			; `string'
PUBLIC	??_C@_0N@KDMPKOEE@?3FireCracker@		; `string'
PUBLIC	??_C@_0N@MIHFOCLN@?3HeartOfLove@		; `string'
PUBLIC	??_C@_0M@CNBLPJGM@?3MedalEvent@			; `string'
PUBLIC	??_C@_0EC@MINIMHLG@?$FLPShop?$FN?5ERROR?5?3?5lpObj?9?$DOm_wVpPSh@ ; `string'
PUBLIC	??_C@_0DB@CHPPJFL@?$FLPShop?$FN?5ERROR?5?3?5iVpOpenCount?5is@ ; `string'
PUBLIC	??_C@_0DA@GGNIPOJP@?$FLPShop?$FN?5ERROR?5?3?5iVpAddCount?5is?5@ ; `string'
PUBLIC	??_C@_05LKHEONBC@Sword@				; `string'
PUBLIC	??_C@_08OMHMMHKG@Crossbow@			; `string'
PUBLIC	??_C@_05DEBCIJNP@Staff@				; `string'
PUBLIC	??_C@_0DE@KDNIOEPF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Ultimate?5We@ ; `string'
PUBLIC	??_C@_0BM@KBFDEFAD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CheckSumTime?5Error@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjCurMoveMake@@YAHQAEPAVOBJECTSTRUCT@@@Z@4JA ; `gObjCurMoveMake'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjMovePlayer@@YAHHEEEEE@Z@4JA ; `gObjMovePlayer'::`1'::__LINE__Var
PUBLIC	??_C@_0P@EEJEJBPC@Regen?5OK?5?$CFs?5?$CFd@	; `string'
PUBLIC	??_C@_0FH@OIJJJHHH@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjMoveGate@@YAHHH@Z@4JA	; `gObjMoveGate'::`1'::__LINE__Var
PUBLIC	??_C@_0EG@IKFPGELB@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Used@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjTeleport@@YAXHHHH@Z@4JA	; `gObjTeleport'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd@	; `string'
PUBLIC	?__LINE__Var@?0??gObjGetMagic@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@H@Z@4JA ; `gObjGetMagic'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjPosMagicAttack@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@EE@Z@4JA ; `gObjPosMagicAttack'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EEEAAE@Z@4JA ; `gObjMagicAdd'::`1'::__LINE__Var
PUBLIC	??_C@_0CG@HFCELOAC@error?9L2?3?5Skill?5Leadership?5not?5@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z@4JA ; `gObjMagicAdd'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjWeaponMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z@4JA ; `gObjWeaponMagicAdd'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z@4JA ; `gObjMonsterMagicAdd'::`1'::__LINE__Var
PUBLIC	??_C@_0FO@HEPLMOKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5JewelofLife?5Result?5?$FL?$CFd@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjGuildWarEndSend@@YAXPAVOBJECTSTRUCT@@EE@Z@4JA ; `gObjGuildWarEndSend'::`1'::__LINE__Var
PUBLIC	??_C@_0BH@NCOFCPCB@?$CFs?5?$CI?5?$CFu?5?$CJ?5VS?5?$CFs?5?$CI?5?$CFu?5?$CJ@ ; `string'
PUBLIC	?__LINE__Var@?0??gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z@4JA ; `gObjGuildWarItemGive'::`1'::__LINE__Var
PUBLIC	??_C@_0EL@FIMACGK@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5t@ ; `string'
PUBLIC	??_C@_0DH@LJCMNCCO@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5t@ ; `string'
PUBLIC	??_C@_0GB@CGCBNNKJ@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5t@ ; `string'
PUBLIC	??_C@_0GM@NPKLGGJP@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5t@ ; `string'
PUBLIC	??_C@_0CL@IFDDAPIM@?$FL?$CFd?$FN?9?$FL?$CFd?$FN?5Total?5?$CFd?5?$CFs?5?$CFd?5?$CFs?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0CG@GHIPHJMP@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Ren@ ; `string'
PUBLIC	??_C@_0CJ@FBOHLINL@?$FLDeleteItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5?$CI?$CF@ ; `string'
PUBLIC	??_C@_0DL@GGMAOOIG@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5StatUpIte@ ; `string'
PUBLIC	??_C@_0CG@KNEHLHCP@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5?$FL?$CFd?$FN?$FL@ ; `string'
PUBLIC	??_C@_0BP@DLHDMMOD@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?$FL?$CFd?$FN?5?$CFd@ ; `string'
PUBLIC	??_C@_0HD@NHFJLKNN@?$FLChaos?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Winner?5@ ; `string'
PUBLIC	??_C@_0HC@BKBHDGJF@?$FL?$KB?Z?$KB?YReward?$FN?$FLKUNDUN?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5S@ ; `string'
PUBLIC	??_C@_0GL@CFJINBHJ@?$FLReward?$FN?$FLEtc?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Set?5Item@ ; `string'
PUBLIC	??_C@_0DM@LPHFFNDE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemLevelUp?$FN?5?$FL?$CFs?$FN?5L@ ; `string'
PUBLIC	??_C@_0DF@GBAGDNJH@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$CI?$CFs?$CJ@ ; `string'
PUBLIC	??_C@_0GP@MDNOLJFE@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ ; `string'
PUBLIC	??_R4StaticObject@@6B@				; StaticObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVStaticObject@@@8			; StaticObject `RTTI Type Descriptor'
PUBLIC	??_R3StaticObject@@8				; StaticObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2StaticObject@@8				; StaticObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@StaticObject@@8			; StaticObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3951b717
PUBLIC	__real@3c23d70a
PUBLIC	__real@3ca3d70a
PUBLIC	__real@3d178d50
PUBLIC	__real@3e428f5c
PUBLIC	__real@3f000000
PUBLIC	__real@3f07ae14
PUBLIC	__real@3f800000
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@3fc3333333333333
PUBLIC	__real@3fc999999999999a
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3fd3333333333333
PUBLIC	__real@3fd999999999999a
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fe999999999999a
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff4cccccccccccd
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@4069000000000000
PUBLIC	__real@40c00000
PUBLIC	__real@41000000
PUBLIC	__real@41200000
PUBLIC	__real@41a00000
PUBLIC	__real@42080000
PUBLIC	__real@42340000
PUBLIC	__real@42580000
PUBLIC	__real@42c80000
PUBLIC	__real@437f0000
PUBLIC	__real@44098000
PUBLIC	__real@4494c000
PUBLIC	__real@45160000
PUBLIC	__real@bf800000
PUBLIC	__real@c0c00000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	?__global_array_delete@@YAXPAXI@Z:PROC		; __global_array_delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__invalid_parameter_noinfo:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	__errno:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	__stricmp:PROC
EXTRN	_strlen:PROC
EXTRN	_strncmp:PROC
EXTRN	_strncpy:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__LoadResource@8:PROC
EXTRN	__imp__LockResource@4:PROC
EXTRN	__imp__SizeofResource@8:PROC
EXTRN	__imp__FindResourceW@12:PROC
EXTRN	__imp__TextOutA@20:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_abs:PROC
EXTRN	_rand:PROC
EXTRN	_atof:PROC
EXTRN	_atoi:PROC
EXTRN	__localtime64_s:PROC
EXTRN	_strftime:PROC
EXTRN	__time64:PROC
EXTRN	?AfxThrowMemoryException@@YGXXZ:PROC		; AfxThrowMemoryException
EXTRN	?AfxThrowOleException@@YGXJ@Z:PROC		; AfxThrowOleException
EXTRN	?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z:PROC ; AfxFindStringResourceHandle
EXTRN	_sqrt:PROC
EXTRN	?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ:PROC ; AfxGetStringManager
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	__imp_?Get@CMsg@@QAEPADH@Z:PROC
EXTRN	??0CItem@@QAE@XZ:PROC				; CItem::CItem
EXTRN	?Convert@CItem@@QAEXHEEEEEE@Z:PROC		; CItem::Convert
EXTRN	?GetSize@CItem@@QAEHAAH0@Z:PROC			; CItem::GetSize
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?IsSetItem@CItem@@QAEHXZ:PROC			; CItem::IsSetItem
EXTRN	?SetPetItemInfo@CItem@@QAEXHH@Z:PROC		; CItem::SetPetItemInfo
EXTRN	?AddPetItemExp@CItem@@QAEHH@Z:PROC		; CItem::AddPetItemExp
EXTRN	?DecPetItemExp@CItem@@QAEHH@Z:PROC		; CItem::DecPetItemExp
EXTRN	?PetItemLevelDown@CItem@@QAEHH@Z:PROC		; CItem::PetItemLevelDown
EXTRN	?IsClass@CItem@@QAEHDH@Z:PROC			; CItem::IsClass
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?GetNumber@CItem@@QAEKXZ:PROC			; CItem::GetNumber
EXTRN	?IsExtItem@CItem@@QAEHXZ:PROC			; CItem::IsExtItem
EXTRN	?IsExtLifeAdd@CItem@@QAEHXZ:PROC		; CItem::IsExtLifeAdd
EXTRN	?IsExtManaAdd@CItem@@QAEHXZ:PROC		; CItem::IsExtManaAdd
EXTRN	?IsExtDamageMinus@CItem@@QAEHXZ:PROC		; CItem::IsExtDamageMinus
EXTRN	?IsExtDamageReflect@CItem@@QAEHXZ:PROC		; CItem::IsExtDamageReflect
EXTRN	?IsExtDefenseSuccessfull@CItem@@QAEHXZ:PROC	; CItem::IsExtDefenseSuccessfull
EXTRN	?IsExtMonsterMoney@CItem@@QAEHXZ:PROC		; CItem::IsExtMonsterMoney
EXTRN	?DurabilityDown@CItem@@QAEHHH@Z:PROC		; CItem::DurabilityDown
EXTRN	?DurabilityDown2@CItem@@QAEHHH@Z:PROC		; CItem::DurabilityDown2
EXTRN	?NormalWeaponDurabilityDown@CItem@@QAEHHH@Z:PROC ; CItem::NormalWeaponDurabilityDown
EXTRN	?BowWeaponDurabilityDown@CItem@@QAEHHH@Z:PROC	; CItem::BowWeaponDurabilityDown
EXTRN	?StaffWeaponDurabilityDown@CItem@@QAEHHH@Z:PROC	; CItem::StaffWeaponDurabilityDown
EXTRN	?ArmorDurabilityDown@CItem@@QAEHHH@Z:PROC	; CItem::ArmorDurabilityDown
EXTRN	?CheckExcOption@CItem@@QAEHH@Z:PROC		; CItem::CheckExcOption
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	?ItemByteConvert@@YAXPAEVCItem@@@Z:PROC		; ItemByteConvert
EXTRN	?GetLevelItem@@YAHHHH@Z:PROC			; GetLevelItem
EXTRN	?zzzItemLevel@@YAHHHH@Z:PROC			; zzzItemLevel
EXTRN	?BufferItemtoConvert3@@YAXPAEAAHAAE2222@Z:PROC	; BufferItemtoConvert3
EXTRN	?IsItem@@YAHH@Z:PROC				; IsItem
EXTRN	?ItemGetDurability@@YAHHHHH@Z:PROC		; ItemGetDurability
EXTRN	??0CMagicInf@@QAE@XZ:PROC			; CMagicInf::CMagicInf
EXTRN	??1CMagicInf@@UAE@XZ:PROC			; CMagicInf::~CMagicInf
EXTRN	?IsMagic@CMagicInf@@QAEHXZ:PROC			; CMagicInf::IsMagic
EXTRN	?Clear@CMagicInf@@QAEXXZ:PROC			; CMagicInf::Clear
EXTRN	?Set@CMagicInf@@QAEHEEE@Z:PROC			; CMagicInf::Set
EXTRN	?Set@CMagicInf@@QAEHEE@Z:PROC			; CMagicInf::Set
EXTRN	?GetSkillNumberInex@@YAHHHH@Z:PROC		; GetSkillNumberInex
EXTRN	?CloseClient@@YAXH@Z:PROC			; CloseClient
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?ResponErrorCloseClient@@YAXH@Z:PROC		; ResponErrorCloseClient
EXTRN	?Add@CLoginCount@@QAEXXZ:PROC			; CLoginCount::Add
EXTRN	?Delete@CLoginCount@@QAEXXZ:PROC		; CLoginCount::Delete
EXTRN	?DeleteUser@CEngagePVP@@QAEXH@Z:PROC		; CEngagePVP::DeleteUser
EXTRN	??0CSkillDelay@@QAE@XZ:PROC			; CSkillDelay::CSkillDelay
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	?Init@CSkillDelay@@QAEXXZ:PROC			; CSkillDelay::Init
EXTRN	??0PacketStatistics@@QAE@XZ:PROC		; PacketStatistics::PacketStatistics
EXTRN	??1PacketStatistics@@QAE@XZ:PROC		; PacketStatistics::~PacketStatistics
EXTRN	?Init@PacketStatistics@@QAEXK@Z:PROC		; PacketStatistics::Init
EXTRN	?GCCloseMsgSend@@YAXHE@Z:PROC			; GCCloseMsgSend
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?GCMapEventStateSend@@YAXHEE@Z:PROC		; GCMapEventStateSend
EXTRN	?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z:PROC	; MsgSendV2
EXTRN	?GCCheckMainExeKeySend@@YAXH@Z:PROC		; GCCheckMainExeKeySend
EXTRN	?GCResultSend@@YAXHEE@Z:PROC			; GCResultSend
EXTRN	?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z:PROC ; RecvPositionSetProc
EXTRN	?GCReFillSend@@YAXHGEE@Z:PROC			; GCReFillSend
EXTRN	?CGWeatherSend@@YAXHE@Z:PROC			; CGWeatherSend
EXTRN	?GCLevelUpMsgSend@@YAXHGGGGGFF@Z:PROC		; GCLevelUpMsgSend
EXTRN	?GCManaSend@@YAXHFEEG@Z:PROC			; GCManaSend
EXTRN	?GCDiePlayerSend@@YAXPAVOBJECTSTRUCT@@HEH@Z:PROC ; GCDiePlayerSend
EXTRN	?GCDamageSend@@YAXHHHHH@Z:PROC			; GCDamageSend
EXTRN	?GCDamageSend@@YAXHH@Z:PROC			; GCDamageSend
EXTRN	?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z:PROC ; GCMagicCancelSend
EXTRN	?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z:PROC ; GCTeleportSend
EXTRN	?GCMagicListOneSend@@YAXHDEEE@Z:PROC		; GCMagicListOneSend
EXTRN	?GCMagicListOneDelSend@@YAXHDEEE@Z:PROC		; GCMagicListOneDelSend
EXTRN	?GCMagicListMultiSend@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; GCMagicListMultiSend
EXTRN	?GCKillPlayerExpSend@@YAXHHHHH@Z:PROC		; GCKillPlayerExpSend
EXTRN	?GCMagicAttackNumberSend@@YAXPAVOBJECTSTRUCT@@EHE@Z:PROC ; GCMagicAttackNumberSend
EXTRN	?GCManagerGuildWarEnd@@YAXPAD@Z:PROC		; GCManagerGuildWarEnd
EXTRN	?GCGuildWarEnd@@YAXHEPAD@Z:PROC			; GCGuildWarEnd
EXTRN	?GCGuildWarScore@@YAXH@Z:PROC			; GCGuildWarScore
EXTRN	?GCTradeOtherAdd@@YAHHEEEEEE@Z:PROC		; GCTradeOtherAdd
EXTRN	?GCTradeOtherDel@@YAHHE@Z:PROC			; GCTradeOtherDel
EXTRN	?CGTradeResult@@YAXHE@Z:PROC			; CGTradeResult
EXTRN	?CGTradeCancelButtonRecv@@YAXH@Z:PROC		; CGTradeCancelButtonRecv
EXTRN	?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z:PROC ; CGItemDropRequest
EXTRN	?GCPkLevelSend@@YAXHE@Z:PROC			; GCPkLevelSend
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?GCEquipmentSend@@YAXH@Z:PROC			; GCEquipmentSend
EXTRN	?GCEquipmentChange@@YAXHH@Z:PROC		; GCEquipmentChange
EXTRN	?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z:PROC ; CGPartyDelUser
EXTRN	?GCItemUseSpecialTimeSend@@YAXHEH@Z:PROC	; GCItemUseSpecialTimeSend
EXTRN	?GCItemDurSend@@YAXHEEE@Z:PROC			; GCItemDurSend
EXTRN	?GCItemDurSend2@@YAXHEEE@Z:PROC			; GCItemDurSend2
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?GCJoinSocketResult@@YAXEI@Z:PROC		; GCJoinSocketResult
EXTRN	?CGWarehouseUseEnd@@YAXH@Z:PROC			; CGWarehouseUseEnd
EXTRN	?GCRecallMonLife@@YAXHHH@Z:PROC			; GCRecallMonLife
EXTRN	?GCTimeViewSend@@YAXHH@Z:PROC			; GCTimeViewSend
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
EXTRN	?PHeadSubSetW@@YAXPAEEEH@Z:PROC			; PHeadSubSetW
EXTRN	?GCStateInfoSend@@YAXPAVOBJECTSTRUCT@@EG@Z:PROC	; GCStateInfoSend
EXTRN	?GCItemMoveResultSend@@YAXHEEQAE@Z:PROC		; GCItemMoveResultSend
EXTRN	?GCSendDuelScore@@YAXHH@Z:PROC			; GCSendDuelScore
EXTRN	?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z:PROC	; CGUseItemRecv
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
EXTRN	??0TNotice@@QAE@E@Z:PROC			; TNotice::TNotice
EXTRN	?SendToAllUser@TNotice@@QAAXPADZZ:PROC		; TNotice::SendToAllUser
EXTRN	?ExecFormat@CDataBase@@QAA_NPBDZZ:PROC		; CDataBase::ExecFormat
EXTRN	?KCredits@CManager@@QAEHPAD@Z:PROC		; CManager::KCredits
EXTRN	?_checkCondition@CDynamicExperience@@QAEMPAVOBJECTSTRUCT@@@Z:PROC ; CDynamicExperience::_checkCondition
EXTRN	?_getNewExperience@CDynamicExperience@@QAEKKM@Z:PROC ; CDynamicExperience::_getNewExperience
EXTRN	?AddTimeBonus@@YAXH@Z:PROC			; AddTimeBonus
EXTRN	?MakeItemNumber@@YAHHH@Z:PROC			; MakeItemNumber
EXTRN	?PHeadSetBE@@YAXPAEEH@Z:PROC			; PHeadSetBE
EXTRN	?GetDefPoint@classdef@@QAEHH@Z:PROC		; classdef::GetDefPoint
EXTRN	?GCItemListSend@@YAXH@Z:PROC			; GCItemListSend
EXTRN	?GJPUserClose@@YAXPAVOBJECTSTRUCT@@@Z:PROC	; GJPUserClose
EXTRN	?GetLevelPos@MapClass@@QAEXFAAF0@Z:PROC		; MapClass::GetLevelPos
EXTRN	?GetMapPos@MapClass@@QAEXFAAF0@Z:PROC		; MapClass::GetMapPos
EXTRN	?GetRandomLengthPos@MapClass@@QAEXAAF0H@Z:PROC	; MapClass::GetRandomLengthPos
EXTRN	?GetWeather@MapClass@@QAEEXZ:PROC		; MapClass::GetWeather
EXTRN	?StateSetDestroy@MapClass@@QAEXXZ:PROC		; MapClass::StateSetDestroy
EXTRN	?SetStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::SetStandAttr
EXTRN	?ClearStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::ClearStandAttr
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?MapNumberCheck@@YAHH@Z:PROC			; MapNumberCheck
EXTRN	_AngleMatrix:PROC
EXTRN	_VectorRotate:PROC
EXTRN	?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z:PROC	; CMonsterSetBase::GetPosition
EXTRN	?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z:PROC ; CMonsterAttr::GetAttr
EXTRN	?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z:PROC ; gObjMonsterTopHitDamageUser
EXTRN	?gObjMonsterProcess@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; gObjMonsterProcess
EXTRN	?gObjMonsterStateProc@@YAXPAVOBJECTSTRUCT@@HH@Z:PROC ; gObjMonsterStateProc
EXTRN	?gObjMonsterRegen@@YAHPAVOBJECTSTRUCT@@@Z:PROC	; gObjMonsterRegen
EXTRN	?gObjMonsterSetHitDamage@@YAXPAVOBJECTSTRUCT@@HH@Z:PROC ; gObjMonsterSetHitDamage
EXTRN	?gObjMonsterHitDamageInit@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; gObjMonsterHitDamageInit
EXTRN	?gObjMonsterHitDamageUserDel@@YAHPAVOBJECTSTRUCT@@@Z:PROC ; gObjMonsterHitDamageUserDel
EXTRN	?gObjRefillMonsterHP@@YAXPAVOBJECTSTRUCT@@H@Z:PROC ; gObjRefillMonsterHP
EXTRN	?Run@CQeustNpcTeleport@@QAEXH@Z:PROC		; CQeustNpcTeleport::Run
EXTRN	?GJSetCharacterInfo@@YAXPAVOBJECTSTRUCT@@HH@Z:PROC ; GJSetCharacterInfo
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z:PROC	; ItemSerialCreateSend
EXTRN	?GDSetWarehouseList@@YAXH@Z:PROC		; GDSetWarehouseList
EXTRN	?GDSetWarehouseMoney@@YAXH@Z:PROC		; GDSetWarehouseMoney
EXTRN	?gObjRequestPetItemInfo@@YAXHH@Z:PROC		; gObjRequestPetItemInfo
EXTRN	?GDCharClose@@YAXHPAD0@Z:PROC			; GDCharClose
EXTRN	?DGGuildScoreUpdate@@YAXPADH@Z:PROC		; DGGuildScoreUpdate
EXTRN	?SkillGetMana@CMagicDamage@@QAEHH@Z:PROC	; CMagicDamage::SkillGetMana
EXTRN	?SkillGetRequireEnergy@CMagicDamage@@QAEHH@Z:PROC ; CMagicDamage::SkillGetRequireEnergy
EXTRN	?SkillGetRequireClass@CMagicDamage@@QAEHHHH@Z:PROC ; CMagicDamage::SkillGetRequireClass
EXTRN	?SkillGetBP@CMagicDamage@@QAEHH@Z:PROC		; CMagicDamage::SkillGetBP
EXTRN	?GetskillRequireLeadership@CMagicDamage@@QAEHH@Z:PROC ; CMagicDamage::GetskillRequireLeadership
EXTRN	?GetSkillType@CMagicDamage@@QAEHH@Z:PROC	; CMagicDamage::GetSkillType
EXTRN	?GetSkillDistance@CMagicDamage@@QAEHH@Z:PROC	; CMagicDamage::GetSkillDistance
EXTRN	?IsGate@CGate@@QAEHH@Z:PROC			; CGate::IsGate
EXTRN	?GetGate@CGate@@QAEHHAAF0AAE10@Z:PROC		; CGate::GetGate
EXTRN	?GetIndex@PartyClass@@QAEHHHH@Z:PROC		; PartyClass::GetIndex
EXTRN	?PartyMemberLifeSend@PartyClass@@QAEXH@Z:PROC	; PartyClass::PartyMemberLifeSend
EXTRN	?IsIp@CAcceptIp@@QAEHPAD@Z:PROC			; CAcceptIp::IsIp
EXTRN	?DelIp@CIpCache@@QAEXPAD@Z:PROC			; CIpCache::DelIp
EXTRN	??0CViewportGuild@@QAE@XZ:PROC			; CViewportGuild::CViewportGuild
EXTRN	??1CViewportGuild@@UAE@XZ:PROC			; CViewportGuild::~CViewportGuild
EXTRN	?Init@CViewportGuild@@QAEXXZ:PROC		; CViewportGuild::Init
EXTRN	?Add@CViewportGuild@@QAEHHH@Z:PROC		; CViewportGuild::Add
EXTRN	?ManagementProc@CGMMng@@QAEHPAVOBJECTSTRUCT@@PADH@Z:PROC ; CGMMng::ManagementProc
EXTRN	?ManagerAdd@CGMMng@@QAEHPADH@Z:PROC		; CGMMng::ManagerAdd
EXTRN	?ManagerDel@CGMMng@@QAEXPAD@Z:PROC		; CGMMng::ManagerDel
EXTRN	?BattleInfoSend@CGMMng@@QAEXPADE0E@Z:PROC	; CGMMng::BattleInfoSend
EXTRN	?ChaosBoxInit@CMixSystem@@QAEHPAVOBJECTSTRUCT@@@Z:PROC ; CMixSystem::ChaosBoxInit
EXTRN	?init@NSerialCheck@@QAEXXZ:PROC			; NSerialCheck::init
EXTRN	?gDevilSquareMonsterRegen@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@@Z:PROC ; CDevilSquare::gDevilSquareMonsterRegen
EXTRN	?DieProcDevilSquare@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@@Z:PROC ; CDevilSquare::DieProcDevilSquare
EXTRN	?gObjMonsterExpSingle@CDevilSquare@@QAEHPAVOBJECTSTRUCT@@0HH@Z:PROC ; CDevilSquare::gObjMonsterExpSingle
EXTRN	?gObjExpParty@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@0HH@Z:PROC ; CDevilSquare::gObjExpParty
EXTRN	?gObjMonsterScoreDivision@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@0HH@Z:PROC ; CDevilSquare::gObjMonsterScoreDivision
EXTRN	?gBattleGroundEnable@@YAXHH@Z:PROC		; gBattleGroundEnable
EXTRN	?gCheckBattleGroundTimer@@YAHXZ:PROC		; gCheckBattleGroundTimer
EXTRN	?gBattleGetTeamPosition@@YAXHHAAF0@Z:PROC	; gBattleGetTeamPosition
EXTRN	?GetBattleTeamName@@YAPADHH@Z:PROC		; GetBattleTeamName
EXTRN	?SetBattleTeamScore@@YAXHHH@Z:PROC		; SetBattleTeamScore
EXTRN	?GetBattleTeamScore@@YAHHH@Z:PROC		; GetBattleTeamScore
EXTRN	?BattleSoccerGoalStart@@YAXH@Z:PROC		; BattleSoccerGoalStart
EXTRN	?CheckMainToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@@Z:PROC ; CMoveCommand::CheckMainToMove
EXTRN	?CheckEquipmentToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@H@Z:PROC ; CMoveCommand::CheckEquipmentToMove
EXTRN	?CheckInterfaceToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@@Z:PROC ; CMoveCommand::CheckInterfaceToMove
EXTRN	?Update@cOffExp@@QAE_NHE@Z:PROC			; cOffExp::Update
EXTRN	?TickTimes@cOffExp@@QAEXH@Z:PROC		; cOffExp::TickTimes
EXTRN	?DelCash@CWhisperCash@@QAEXPAD@Z:PROC		; CWhisperCash::DelCash
EXTRN	?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z:PROC ; CBloodCastle::SearchUserDeleteQuestItem
EXTRN	?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z:PROC ; CBloodCastle::SearchUserDropQuestItem
EXTRN	?SetUserState@CBloodCastle@@QAEXHH@Z:PROC	; CBloodCastle::SetUserState
EXTRN	?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z:PROC ; CBloodCastle::SendCastleDoorBlockInfo
EXTRN	?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z:PROC ; CBloodCastle::SendNoticeMessage
EXTRN	?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z:PROC	; CBloodCastle::ReleaseCastleDoor
EXTRN	?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z:PROC ; CBloodCastle::CheckMonsterKillSuccess
EXTRN	?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z:PROC ; CBloodCastle::CheckBossKillSuccess
EXTRN	?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z:PROC ; CBloodCastle::GetCurrentLiveUserCount
EXTRN	?SetBossMonster@CBloodCastle@@QAEXH@Z:PROC	; CBloodCastle::SetBossMonster
EXTRN	?GetCurrentState@CBloodCastle@@QAEHH@Z:PROC	; CBloodCastle::GetCurrentState
EXTRN	?ChangeMonsterState@CBloodCastle@@QAEXHH@Z:PROC	; CBloodCastle::ChangeMonsterState
EXTRN	?SetUserState@CChaosCastle@@QAEXHH@Z:PROC	; CChaosCastle::SetUserState
EXTRN	?DelMonsterList@CChaosCastle@@QAEXHH@Z:PROC	; CChaosCastle::DelMonsterList
EXTRN	?SendFailMessage@CChaosCastle@@QAEXHH@Z:PROC	; CChaosCastle::SendFailMessage
EXTRN	?GetCurrentState@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetCurrentState
EXTRN	?SearchNBlowObjs@CChaosCastle@@QAEXHHH@Z:PROC	; CChaosCastle::SearchNBlowObjs
EXTRN	?Init@CMultiAttackHackCheck@@QAEXXZ:PROC	; CMultiAttackHackCheck::Init
EXTRN	?GetQuestState@CQuestInfo@@QAEHPAVOBJECTSTRUCT@@H@Z:PROC ; CQuestInfo::GetQuestState
EXTRN	?ReSetQuestState@CQuestInfo@@QAEEPAVOBJECTSTRUCT@@H@Z:PROC ; CQuestInfo::ReSetQuestState
EXTRN	?GetMaxStat@CStatMng@@QAEHHH@Z:PROC		; CStatMng::GetMaxStat
EXTRN	?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z:PROC ; CObjUseSkill::RunningSkill
EXTRN	?SkillChangeUse@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SkillChangeUse
EXTRN	?Attack@CObjAttack@@QAEHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z:PROC ; CObjAttack::Attack
EXTRN	?ClearCheckSum@CPacketCheckSum@@QAEXH@Z:PROC	; CPacketCheckSum::ClearCheckSum
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
EXTRN	?CheckGoldDercon@CEledoradoEvent@@QAEXH@Z:PROC	; CEledoradoEvent::CheckGoldDercon
EXTRN	?GetSetOptionName@CSetItemOption@@QAEPADHH@Z:PROC ; CSetItemOption::GetSetOptionName
EXTRN	?GenRandomItemNum@CSetItemOption@@QAEHXZ:PROC	; CSetItemOption::GenRandomItemNum
EXTRN	?GenSetOption@CSetItemOption@@QAEHH@Z:PROC	; CSetItemOption::GenSetOption
EXTRN	?Run@CDarkSpirit@@QAEXXZ:PROC			; CDarkSpirit::Run
EXTRN	?ReSetTarget@CDarkSpirit@@QAEXH@Z:PROC		; CDarkSpirit::ReSetTarget
EXTRN	?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z:PROC ; CDarkSpirit::SetMode
EXTRN	?Attack@CDarkSpirit@@QAEHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HH@Z:PROC ; CDarkSpirit::Attack
EXTRN	?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z:PROC	; CDarkSpirit::SendLevelmsg
EXTRN	?DeleteKalimaGate@CKalimaGate@@QAEHH@Z:PROC	; CKalimaGate::DeleteKalimaGate
EXTRN	??_EStaticObject@@UAEPAXI@Z:PROC		; StaticObject::`vector deleting destructor'
EXTRN	?gCheckBattleGround@@YAHPAVOBJECTSTRUCT@@@Z:PROC ; gCheckBattleGround
EXTRN	?CGPShopAnsBuyList@@YAXHHE_N@Z:PROC		; CGPShopAnsBuyList
EXTRN	?CGPShopAnsDealerClosedShop@@YAXHH@Z:PROC	; CGPShopAnsDealerClosedShop
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	__dtoui3:PROC
EXTRN	__except_handler4:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?LogAddL@@3P6AXPADZZA:DWORD			; LogAddL
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?LogAddTD_TempLog@@3P6AXPADZZA:DWORD		; LogAddTD_TempLog
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?g_PvpEvent@@3VCEngagePVP@@A:BYTE		; g_PvpEvent
EXTRN	?gLCount@@3PAVCLoginCount@@A:BYTE		; gLCount
EXTRN	?Manager@@3VCManager@@A:BYTE			; Manager
EXTRN	?g_GlobalConfig@@3VCGlobalConfig@@A:BYTE	; g_GlobalConfig
EXTRN	?g_TerrainManager@@3VCTerrainManager@@A:BYTE	; g_TerrainManager
EXTRN	?_dynamic_experience@@3VCDynamicExperience@@A:BYTE ; _dynamic_experience
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?gCurPaintMapNumber@@3HA:DWORD			; gCurPaintMapNumber
EXTRN	?gConnectBonus@@3HA:DWORD			; gConnectBonus
EXTRN	?gPkTime@@3HA:DWORD				; gPkTime
EXTRN	?MapC@@3PAVMapClass@@A:DWORD			; MapC
EXTRN	?gLevelExperience@@3PAKA:BYTE			; gLevelExperience
EXTRN	?gItemNumberCount@@3KA:DWORD			; gItemNumberCount
EXTRN	?gPkItemDrop@@3HA:DWORD				; gPkItemDrop
EXTRN	?gGuildCreateLevel@@3HA:DWORD			; gGuildCreateLevel
EXTRN	?gItemSerialCheck@@3HA:DWORD			; gItemSerialCheck
EXTRN	?gAddExperience@@3MA:DWORD			; gAddExperience
EXTRN	?gLanguage@@3HA:DWORD				; gLanguage
EXTRN	?gPkLimitFree@@3HA:DWORD			; gPkLimitFree
EXTRN	?gXMasEvent@@3HA:DWORD				; gXMasEvent
EXTRN	?gFireCrackerEvent@@3HA:DWORD			; gFireCrackerEvent
EXTRN	?gHeartOfLoveEvent@@3HA:DWORD			; gHeartOfLoveEvent
EXTRN	?gMedalEvent@@3HA:DWORD				; gMedalEvent
EXTRN	?gApplyHeroSystem@@3HA:DWORD			; gApplyHeroSystem
EXTRN	?gDoPShopOpen@@3HA:DWORD			; gDoPShopOpen
EXTRN	?giKundunRefillHPSec@@3HA:DWORD			; giKundunRefillHPSec
EXTRN	?gDarkSpiritAddExperience@@3MA:DWORD		; gDarkSpiritAddExperience
EXTRN	?g_iSkillDistanceCheck@@3HA:DWORD		; g_iSkillDistanceCheck
EXTRN	?g_iSkillDistanceCheckTemp@@3HA:DWORD		; g_iSkillDistanceCheckTemp
EXTRN	?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A:BYTE	; gQeustNpcTeleport
EXTRN	?MagicDamageC@@3VCMagicDamage@@A:BYTE		; MagicDamageC
EXTRN	?gGateC@@3VCGate@@A:BYTE			; gGateC
EXTRN	?acceptIP@@3VCAcceptIp@@A:BYTE			; acceptIP
EXTRN	?IpCache@@3VCIpCache@@A:BYTE			; IpCache
EXTRN	?cManager@@3VCGMMng@@A:BYTE			; cManager
EXTRN	?g_MixSystem@@3VCMixSystem@@A:BYTE		; g_MixSystem
EXTRN	?g_DevilSquare@@3VCDevilSquare@@A:BYTE		; g_DevilSquare
EXTRN	?gBSGround@@3PAPAVCBattleSoccer@@A:DWORD	; gBSGround
EXTRN	?gMoveCommand@@3VCMoveCommand@@A:BYTE		; gMoveCommand
EXTRN	?OffExp@@3VcOffExp@@A:BYTE			; OffExp
EXTRN	?WhisperCash@@3VCWhisperCash@@A:BYTE		; WhisperCash
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	?g_ChaosCastle@@3VCChaosCastle@@A:BYTE		; g_ChaosCastle
EXTRN	?gMultiAttackHackCheck@@3PAVCMultiAttackHackCheck@@A:BYTE ; gMultiAttackHackCheck
EXTRN	?g_QuestInfo@@3VCQuestInfo@@A:BYTE		; g_QuestInfo
EXTRN	?gStatMng@@3VCStatMng@@A:BYTE			; gStatMng
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:DWORD		; gObjUseSkill
EXTRN	?gclassObjAttack@@3VCObjAttack@@A:DWORD		; gclassObjAttack
EXTRN	?gPacketCheckSum@@3VCPacketCheckSum@@A:BYTE	; gPacketCheckSum
EXTRN	?gEledoradoEvent@@3VCEledoradoEvent@@A:BYTE	; gEledoradoEvent
EXTRN	?gSetItemOption@@3VCSetItemOption@@A:BYTE	; gSetItemOption
EXTRN	?gDarkSpirit@@3PAVCDarkSpirit@@A:BYTE		; gDarkSpirit
EXTRN	?gMAttr@@3VCMonsterAttr@@A:BYTE			; gMAttr
EXTRN	?gMSetBase@@3VCMonsterSetBase@@A:BYTE		; gMSetBase
EXTRN	?DCInfo@@3Vclassdef@@A:BYTE			; DCInfo
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	?gCurPaintPlayer@@3HA:DWORD			; gCurPaintPlayer
EXTRN	?DragonEvent@@3PAVCDragonEvent@@A:DWORD		; DragonEvent
EXTRN	?gNSerialCheck@@3PAVNSerialCheck@@A:BYTE	; gNSerialCheck
EXTRN	?g_KalimaGate@@3VCKalimaGate@@A:BYTE		; g_KalimaGate
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

?m_ObjBill@@3PAVBILL_CLASS@@A DB 032960H DUP (?)	; m_ObjBill
?SMDFile@@3PAU_iobuf@@A DD 01H DUP (?)			; SMDFile
?TokenNumber@@3MA DD 01H DUP (?)			; TokenNumber
?TokenString@@3PADA DB 064H DUP (?)			; TokenString
?CurrentToken@@3W4SMDToken@@A DD 01H DUP (?)		; CurrentToken
?g_iChaosCastle_MonsterItems@@3PAY111HA DD 018H DUP (?)	; g_iChaosCastle_MonsterItems
?ViewGuildMng@@3VCViewportGuild@@A DB 09cH DUP (?)	; ViewGuildMng
?g_kStaticObject@@3VStaticObject@@A DD 01H DUP (?)	; g_kStaticObject
?OneMsg@?1??gObjAllLogOut@@YAXXZ@4HA DD 01H DUP (?)	; `gObjAllLogOut'::`2'::OneMsg
?FrustrumX@@3PAHA DD 04H DUP (?)			; FrustrumX
?FrustrumY@@3PAHA DD 04H DUP (?)			; FrustrumY
_BSS	ENDS
CRT$XCU	SEGMENT
?g_iChaosCastle_MonsterItems$initializer$@@3P6AXXZA DD FLAT:??__Eg_iChaosCastle_MonsterItems@@YAXXZ ; g_iChaosCastle_MonsterItems$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c0c00000
CONST	SEGMENT
__real@c0c00000 DD 0c0c00000r			; -6
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@45160000
CONST	SEGMENT
__real@45160000 DD 045160000r			; 2400
CONST	ENDS
;	COMDAT __real@4494c000
CONST	SEGMENT
__real@4494c000 DD 04494c000r			; 1190
CONST	ENDS
;	COMDAT __real@44098000
CONST	SEGMENT
__real@44098000 DD 044098000r			; 550
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42580000
CONST	SEGMENT
__real@42580000 DD 042580000r			; 54
CONST	ENDS
;	COMDAT __real@42340000
CONST	SEGMENT
__real@42340000 DD 042340000r			; 45
CONST	ENDS
;	COMDAT __real@42080000
CONST	SEGMENT
__real@42080000 DD 042080000r			; 34
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@4069000000000000
CONST	SEGMENT
__real@4069000000000000 DQ 04069000000000000r	; 200
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff4cccccccccccd
CONST	SEGMENT
__real@3ff4cccccccccccd DQ 03ff4cccccccccccdr	; 1.3
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe999999999999a
CONST	SEGMENT
__real@3fe999999999999a DQ 03fe999999999999ar	; 0.8
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fd999999999999a
CONST	SEGMENT
__real@3fd999999999999a DQ 03fd999999999999ar	; 0.4
CONST	ENDS
;	COMDAT __real@3fd3333333333333
CONST	SEGMENT
__real@3fd3333333333333 DQ 03fd3333333333333r	; 0.3
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3fc999999999999a
CONST	SEGMENT
__real@3fc999999999999a DQ 03fc999999999999ar	; 0.2
CONST	ENDS
;	COMDAT __real@3fc3333333333333
CONST	SEGMENT
__real@3fc3333333333333 DQ 03fc3333333333333r	; 0.15
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f07ae14
CONST	SEGMENT
__real@3f07ae14 DD 03f07ae14r			; 0.53
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e428f5c
CONST	SEGMENT
__real@3e428f5c DD 03e428f5cr			; 0.19
CONST	ENDS
;	COMDAT __real@3d178d50
CONST	SEGMENT
__real@3d178d50 DD 03d178d50r			; 0.037
CONST	ENDS
;	COMDAT __real@3ca3d70a
CONST	SEGMENT
__real@3ca3d70a DD 03ca3d70ar			; 0.02
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3951b717
CONST	SEGMENT
__real@3951b717 DD 03951b717r			; 0.0002
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@StaticObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@StaticObject@@8 DD FLAT:??_R0?AVStaticObject@@@8 ; StaticObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3StaticObject@@8
rdata$r	ENDS
;	COMDAT ??_R2StaticObject@@8
rdata$r	SEGMENT
??_R2StaticObject@@8 DD FLAT:??_R1A@?0A@EA@StaticObject@@8 ; StaticObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3StaticObject@@8
rdata$r	SEGMENT
??_R3StaticObject@@8 DD 00H				; StaticObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2StaticObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVStaticObject@@@8
data$r	SEGMENT
??_R0?AVStaticObject@@@8 DD FLAT:??_7type_info@@6B@	; StaticObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVStaticObject@@', 00H
data$r	ENDS
;	COMDAT ??_R4StaticObject@@6B@
rdata$r	SEGMENT
??_R4StaticObject@@6B@ DD 00H				; StaticObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVStaticObject@@@8
	DD	FLAT:??_R3StaticObject@@8
rdata$r	ENDS
;	COMDAT ??_C@_0GP@MDNOLJFE@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0GP@MDNOLJFE@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@ DB '['
	DB	'SKILL DISTANCE CHECK] [%s][%s] Invalid Skill attacker(%d, %d)'
	DB	', defender(%d, %d), skillnum:%d skilldistance:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GBAGDNJH@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$CI?$CFs?$CJ@
CONST	SEGMENT
??_C@_0DF@GBAGDNJH@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$CI?$CFs?$CJ@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] (%s)(%s) Item(%s) Pos(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@LPHFFNDE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemLevelUp?$FN?5?$FL?$CFs?$FN?5L@
CONST	SEGMENT
??_C@_0DM@LPHFFNDE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemLevelUp?$FN?5?$FL?$CFs?$FN?5L@ DB '['
	DB	'%s][%s][PetItemLevelUp] [%s] Level:[%d]Exp:[%d]AddExp:[%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GL@CFJINBHJ@?$FLReward?$FN?$FLEtc?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Set?5Item@
CONST	SEGMENT
??_C@_0GL@CFJINBHJ@?$FLReward?$FN?$FLEtc?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Set?5Item@ DB '['
	DB	'Reward][Etc] [%s][%s] Set Item itemnum:[%d] skill:[%d] luck:['
	DB	'%d] option:[%d] SetOption:[%d], SetName:[%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HC@BKBHDGJF@?$FL?$KB?Z?$KB?YReward?$FN?$FLKUNDUN?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5S@
CONST	SEGMENT
??_C@_0HC@BKBHDGJF@?$FL?$KB?Z?$KB?YReward?$FN?$FLKUNDUN?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5S@ DB '['
	DB	0a1H, 0daH, 0a1H, 0d9H, 'Reward][KUNDUN] [%s][%s] Set Item ite'
	DB	'mnum:[%d] skill:[%d] luck:[%d] option:[%d] SetOption:[%d], Se'
	DB	'tName:[%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0HD@NHFJLKNN@?$FLChaos?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Winner?5@
CONST	SEGMENT
??_C@_0HD@NHFJLKNN@?$FLChaos?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Winner?5@ DB '['
	DB	'Chaos Castle] [%s][%s] Winner Set Item itemnum:[%d] skill:[%d'
	DB	'] luck:[%d] option:[%d] SetOption:[%d], SetName:[%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DLHDMMOD@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?$FL?$CFd?$FN?5?$CFd@
CONST	SEGMENT
??_C@_0BP@DLHDMMOD@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?$FL?$CFd?$FN?5?$CFd@ DB '['
	DB	'StatUp] [%s][%s] Fail [%d] %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KNEHLHCP@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5?$FL?$CFd?$FN?$FL@
CONST	SEGMENT
??_C@_0CG@KNEHLHCP@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5?$FL?$CFd?$FN?$FL@ DB '['
	DB	'StatUp] [%s][%s] Success [%d][%d] %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GGMAOOIG@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5StatUpIte@
CONST	SEGMENT
??_C@_0DL@GGMAOOIG@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5StatUpIte@ DB '['
	DB	'StatUp] [%s][%s] Use StatUpItem Level:%d Pos:%d serial:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FBOHLINL@?$FLDeleteItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5?$CI?$CF@
CONST	SEGMENT
??_C@_0CJ@FBOHLINL@?$FLDeleteItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5?$CI?$CF@ DB '['
	DB	'DeleteItem] [%s][%s] Delete (%d,%d)(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GHIPHJMP@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Ren@
CONST	SEGMENT
??_C@_0CG@GHIPHJMP@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Ren@ DB '['
	DB	'EventChip] [%s][%s] Delete Rena (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IFDDAPIM@?$FL?$CFd?$FN?9?$FL?$CFd?$FN?5Total?5?$CFd?5?$CFs?5?$CFd?5?$CFs?5?$CFd?5@
CONST	SEGMENT
??_C@_0CL@IFDDAPIM@?$FL?$CFd?$FN?9?$FL?$CFd?$FN?5Total?5?$CFd?5?$CFs?5?$CFd?5?$CFs?5?$CFd?5@ DB '['
	DB	'%d]-[%d] Total %d %s %d %s %d %s %d %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GM@NPKLGGJP@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5t@
CONST	SEGMENT
??_C@_0GM@NPKLGGJP@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5t@ DB '['
	DB	'Summon Monster] [%s][%s] Try to Kill Summoned Monster - Finis'
	DB	'hed to Kill Summoned Monster (SummonIndex:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@CGCBNNKJ@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5t@
CONST	SEGMENT
??_C@_0GB@CGCBNNKJ@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5t@ DB '['
	DB	'Summon Monster] [%s][%s] Try to Kill Summoned Monster - Found'
	DB	' Summoned Monster (SummonIndex:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@LJCMNCCO@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5t@
CONST	SEGMENT
??_C@_0DH@LJCMNCCO@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5t@ DB '['
	DB	'Summon Monster] [%s][%s] Try to Kill Summoned Monster', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@FIMACGK@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5t@
CONST	SEGMENT
??_C@_0EL@FIMACGK@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5t@ DB '['
	DB	'Summon Monster] [%s][%s] Try to Summon Monster - Succeed (Sum'
	DB	'monIndex:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z@4JA DD 07289H ; `gObjGuildWarItemGive'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BH@NCOFCPCB@?$CFs?5?$CI?5?$CFu?5?$CJ?5VS?5?$CFs?5?$CI?5?$CFu?5?$CJ@
CONST	SEGMENT
??_C@_0BH@NCOFCPCB@?$CFs?5?$CI?5?$CFu?5?$CJ?5VS?5?$CFs?5?$CI?5?$CFu?5?$CJ@ DB '%'
	DB	's ( %u ) VS %s ( %u )', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjGuildWarEndSend@@YAXPAVOBJECTSTRUCT@@EE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjGuildWarEndSend@@YAXPAVOBJECTSTRUCT@@EE@Z@4JA DD 07113H ; `gObjGuildWarEndSend'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0FO@HEPLMOKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5JewelofLife?5Result?5?$FL?$CFd@
CONST	SEGMENT
??_C@_0FO@HEPLMOKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5JewelofLife?5Result?5?$FL?$CFd@ DB '['
	DB	'%s][%s] JewelofLife Result [%d,%s,%d,%d,%d,%d]serial:[%d] dur'
	DB	':[%d] Ex:[%d,%d,%d,%d,%d,%d,%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z@4JA DD 06ea8H ; `gObjMonsterMagicAdd'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjWeaponMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjWeaponMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z@4JA DD 06e6cH ; `gObjWeaponMagicAdd'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z@4JA DD 06e15H ; `gObjMagicAdd'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CG@HFCELOAC@error?9L2?3?5Skill?5Leadership?5not?5@
CONST	SEGMENT
??_C@_0CG@HFCELOAC@error?9L2?3?5Skill?5Leadership?5not?5@ DB 'error-L2: S'
	DB	'kill Leadership not enough', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EEEAAE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EEEAAE@Z@4JA DD 06d7dH ; `gObjMagicAdd'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjPosMagicAttack@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@EE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjPosMagicAttack@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@EE@Z@4JA DD 06d18H ; `gObjPosMagicAttack'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjGetMagic@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjGetMagic@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@H@Z@4JA DD 06c9eH ; `gObjGetMagic'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd@ DB 'error-L3 : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjTeleport@@YAXHHHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjTeleport@@YAXHHHH@Z@4JA DD 06c31H	; `gObjTeleport'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EG@IKFPGELB@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Used@
CONST	SEGMENT
??_C@_0EG@IKFPGELB@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Used@ DB '['
	DB	'DevilSquare] [%s][%s] Not Used DevilSquare Invitation In Devi'
	DB	'lSquare', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjMoveGate@@YAHHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjMoveGate@@YAHHH@Z@4JA DD 06890H	; `gObjMoveGate'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0FH@OIJJJHHH@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@
CONST	SEGMENT
??_C@_0FH@OIJJJHHH@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@ DB '['
	DB	'Kalima] [%s][%s] Kalima Gate Vanished - User MoveGate (Summon'
	DB	'Index:%d, EnterCount:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EEJEJBPC@Regen?5OK?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0P@EEJEJBPC@Regen?5OK?5?$CFs?5?$CFd@ DB 'Regen OK %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjMovePlayer@@YAHHEEEEE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjMovePlayer@@YAHHEEEEE@Z@4JA DD 06547H ; `gObjMovePlayer'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjCurMoveMake@@YAHQAEPAVOBJECTSTRUCT@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjCurMoveMake@@YAHQAEPAVOBJECTSTRUCT@@@Z@4JA DD 05c31H ; `gObjCurMoveMake'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BM@KBFDEFAD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CheckSumTime?5Error@
CONST	SEGMENT
??_C@_0BM@KBFDEFAD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CheckSumTime?5Error@ DB '['
	DB	'%s][%s] CheckSumTime Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@KDNIOEPF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Ultimate?5We@
CONST	SEGMENT
??_C@_0DE@KDNIOEPF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Ultimate?5We@ DB '['
	DB	'Blood Castle] (%d) Ultimate Weapon Dropped -> (%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05DEBCIJNP@Staff@
CONST	SEGMENT
??_C@_05DEBCIJNP@Staff@ DB 'Staff', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08OMHMMHKG@Crossbow@
CONST	SEGMENT
??_C@_08OMHMMHKG@Crossbow@ DB 'Crossbow', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LKHEONBC@Sword@
CONST	SEGMENT
??_C@_05LKHEONBC@Sword@ DB 'Sword', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@GGNIPOJP@?$FLPShop?$FN?5ERROR?5?3?5iVpAddCount?5is?5@
CONST	SEGMENT
??_C@_0DA@GGNIPOJP@?$FLPShop?$FN?5ERROR?5?3?5iVpAddCount?5is?5@ DB '[PSho'
	DB	'p] ERROR : iVpAddCount is OUT of BOUND: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CHPPJFL@?$FLPShop?$FN?5ERROR?5?3?5iVpOpenCount?5is@
CONST	SEGMENT
??_C@_0DB@CHPPJFL@?$FLPShop?$FN?5ERROR?5?3?5iVpOpenCount?5is@ DB '[PShop]'
	DB	' ERROR : iVpOpenCount is OUT of BOUND: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@MINIMHLG@?$FLPShop?$FN?5ERROR?5?3?5lpObj?9?$DOm_wVpPSh@
CONST	SEGMENT
??_C@_0EC@MINIMHLG@?$FLPShop?$FN?5ERROR?5?3?5lpObj?9?$DOm_wVpPSh@ DB '[PS'
	DB	'hop] ERROR : lpObj->m_wVpPShopPlayerCount is OUT of BOUND : %'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CNBLPJGM@?3MedalEvent@
CONST	SEGMENT
??_C@_0M@CNBLPJGM@?3MedalEvent@ DB ':MedalEvent', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MIHFOCLN@?3HeartOfLove@
CONST	SEGMENT
??_C@_0N@MIHFOCLN@?3HeartOfLove@ DB ':HeartOfLove', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KDMPKOEE@?3FireCracker@
CONST	SEGMENT
??_C@_0N@KDMPKOEE@?3FireCracker@ DB ':FireCracker', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IBFDBMCH@?3StarOfXMas@
CONST	SEGMENT
??_C@_0M@IBFDBMCH@?3StarOfXMas@ DB ':StarOfXMas', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@OILHKKPM@COUNT?3?$CFd?5?5TotalPlayer?5?3?5?$CFd?5?5Pla@
CONST	SEGMENT
??_C@_0FD@OILHKKPM@COUNT?3?$CFd?5?5TotalPlayer?5?3?5?$CFd?5?5Pla@ DB 'COU'
	DB	'NT:%d  TotalPlayer : %d  Player(%d):%d VpCount:%d(%d/%d) : it'
	DB	'em count:%d max:%d', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjMakePreviewCharSet@@YAXH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjMakePreviewCharSet@@YAXH@Z@4JA DD 04cb2H ; `gObjMakePreviewCharSet'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BK@ELKLKHDB@error?5?3?5?$MA?L?$LA?G?5?E?$KL?$MA?O?$LD?$KK?$LE?B?$MA?O?$CB?$CB@
CONST	SEGMENT
??_C@_0BK@ELKLKHDB@error?5?3?5?$MA?L?$LA?G?5?E?$KL?$MA?O?$LD?$KK?$LE?B?$MA?O?$CB?$CB@ DB 'e'
	DB	'rror : ', 0c0H, 0ccH, 0b0H, 0c7H, ' ', 0c5H, 0abH, 0c0H, 0cfH
	DB	0b3H, 0aaH, 0b4H, 0c2H, 0c0H, 0cfH, '!!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BGCMBJDA@Item@
CONST	SEGMENT
??_C@_04BGCMBJDA@Item@ DB 'Item', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjTempInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@VCItem@@PAE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjTempInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@VCItem@@PAE@Z@4JA DD 04b66H ; `gObjTempInventoryInsertItem'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BK@CICIFNII@error?5?3?5index?5error?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BK@CICIFNII@error?5?3?5index?5error?5?$CFs?5?$CFd@ DB 'error : ind'
	DB	'ex error %s %d', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjTradeCancel@@YAXH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjTradeCancel@@YAXH@Z@4JA DD 04ae5H	; `gObjTradeCancel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjTradeTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjTradeTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z@4JA DD 04a3fH ; `gObjTradeTradeMove'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjInventoryTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjInventoryTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z@4JA DD 04923H ; `gObjInventoryTradeMove'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DN@CJKEGDHI@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLTra@
CONST	SEGMENT
??_C@_0DN@CJKEGDHI@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLTra@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [Trade] (%s)(%s) Item(%s) Pos(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjTradeInventoryMove@@YAEPAVOBJECTSTRUCT@@EE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjTradeInventoryMove@@YAEPAVOBJECTSTRUCT@@EE@Z@4JA DD 048b3H ; `gObjTradeInventoryMove'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjTradeItemBoxSet@@YAHHHHHE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjTradeItemBoxSet@@YAHHHHHE@Z@4JA DD 04895H ; `gObjTradeItemBoxSet'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjTradeRectCheck@@YAEHHHHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjTradeRectCheck@@YAEHHHHH@Z@4JA DD 04869H ; `gObjTradeRectCheck'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EA@MOKNMDJN@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLMov@
CONST	SEGMENT
??_C@_0EA@MOKNMDJN@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLMov@ DB '['
	DB	'ANTI-HACK][Serial 0 Item] [MoveItem] (%s)(%s) Item(%s) Pos(%d'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@PCJJPCHK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Mov@
CONST	SEGMENT
??_C@_0EL@PCJJPCHK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Mov@ DB '['
	DB	'PShop] [%s][%s] PShop Item Move Request Failed : Already Trad'
	DB	'e With Other', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd@ DB 'error-L1 : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z@4JA DD 04188H ; `gObjInventoryMoveItem'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjChaosItemSet@@YAXHHE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjChaosItemSet@@YAXHHE@Z@4JA DD 03fedH ; `gObjChaosItemSet'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjChaosItemBoxSet@@YAXHHHHE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjChaosItemBoxSet@@YAXHHHHE@Z@4JA DD 03fd0H ; `gObjChaosItemBoxSet'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjWarehouseItemSet@@YAXHHE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjWarehouseItemSet@@YAXHHE@Z@4JA DD 03fc0H ; `gObjWarehouseItemSet'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BF@PBCPKOJP@error?5?3?5?$CFd?1?$CFd?5?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BF@PBCPKOJP@error?5?3?5?$CFd?1?$CFd?5?5?$CFs?5?$CFd@ DB 'error : %'
	DB	'd/%d  %s %d', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjWarehouseItemBoxSet@@YAXHHHHE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjWarehouseItemBoxSet@@YAXHHHHE@Z@4JA DD 03fa3H ; `gObjWarehouseItemBoxSet'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjMapRectCheck@@YAEPAEHHHHHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjMapRectCheck@@YAEPAEHHHHHH@Z@4JA DD 03f7cH ; `gObjMapRectCheck'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjWerehouseRectCheck@@YAEHHHHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjWerehouseRectCheck@@YAEHHHHH@Z@4JA DD 03f51H ; `gObjWerehouseRectCheck'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjOnlyInventoryRectCheck@@YAEHHHHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjOnlyInventoryRectCheck@@YAEHHHHH@Z@4JA DD 03d35H ; `gObjOnlyInventoryRectCheck'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjInventoryRectCheck@@YAEHHHHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjInventoryRectCheck@@YAEHHHHH@Z@4JA DD 03d01H ; `gObjInventoryRectCheck'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHH@Z@4JA DD 03c92H ; `gObjInventoryInsertItem'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHH@Z@4JA DD 03c61H ; `gObjInventoryInsertItem'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjInventoryInsertItemTemp@@YAEPAVOBJECTSTRUCT@@PAVCMapItem@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjInventoryInsertItemTemp@@YAEPAVOBJECTSTRUCT@@PAVCMapItem@@@Z@4JA DD 03c3eH ; `gObjInventoryInsertItemTemp'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjShopBuyInventoryInsertItemSerial@@YAEHVCItem@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjShopBuyInventoryInsertItemSerial@@YAEHVCItem@@@Z@4JA DD 03bdcH ; `gObjShopBuyInventoryInsertItemSerial'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z@4JA DD 03ba7H ; `gObjShopBuyInventoryInsertItem'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BB@FDAFLGGN@error?9L4?5?3?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BB@FDAFLGGN@error?9L4?5?3?5?$CFs?5?$CFd@ DB 'error-L4 : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjSearchItemMinus@@YAHPAVOBJECTSTRUCT@@HH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjSearchItemMinus@@YAHPAVOBJECTSTRUCT@@HH@Z@4JA DD 03b87H ; `gObjSearchItemMinus'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z@4JA DD 03b04H ; `gObjInventoryInsertItem'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z@4JA DD 03acbH ; `gObjOnlyInventoryInsertItem'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjInventoryInsertItem@@YAEHVCItem@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjInventoryInsertItem@@YAEHVCItem@@@Z@4JA DD 03a91H ; `gObjInventoryInsertItem'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjInventoryInsertItem@@YAEHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjInventoryInsertItem@@YAEHH@Z@4JA DD 03a52H ; `gObjInventoryInsertItem'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjInventoryItemBoxSet_PShop@@YAXHHHHE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjInventoryItemBoxSet_PShop@@YAXHHHHE@Z@4JA DD 03a01H ; `gObjInventoryItemBoxSet_PShop'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjInventoryItemSet_PShop@@YAXHHE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjInventoryItemSet_PShop@@YAXHHE@Z@4JA DD 039edH ; `gObjInventoryItemSet_PShop'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DF@DPJDFIHG@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Invent@
CONST	SEGMENT
??_C@_0DF@DPJDFIHG@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Invent@ DB '['
	DB	'Fix Inv.Ptr] [%s][%s] - Inventory Pointer was Wrong', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GPLONBA@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Invent@
CONST	SEGMENT
??_C@_0DB@GPLONBA@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Invent@ DB '['
	DB	'Fix Inv.Ptr] [%s][%s] - Inventory Pointer was 2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@NEEGDNDB@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Transa@
CONST	SEGMENT
??_C@_0EB@NEEGDNDB@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Transa@ DB '['
	DB	'Fix Inv.Ptr] [%s][%s] - Transaction == 1, Do not change Point'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KONHFAKK@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5discon@
CONST	SEGMENT
??_C@_0CG@KONHFAKK@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5discon@ DB '['
	DB	'Fix Inv.Ptr] [%s][%s] - disconnected', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjInventoryItemBoxSet@@YAXHHHHE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjInventoryItemBoxSet@@YAXHHHHE@Z@4JA DD 0398bH ; `gObjInventoryItemBoxSet'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjInventoryItemSet@@YAXHHE@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjInventoryItemSet@@YAXHHE@Z@4JA DD 03977H ; `gObjInventoryItemSet'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BE@GIFOPHN@Trade?5Rollback?5?$CI?$CFs?$CJ@
CONST	SEGMENT
??_C@_0BE@GIFOPHN@Trade?5Rollback?5?$CI?$CFs?$CJ@ DB 'Trade Rollback (%s)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjInventoryRollback@@YAHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjInventoryRollback@@YAHH@Z@4JA DD 0393dH ; `gObjInventoryRollback'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BC@PKOGNFCH@Trade?5Commit?5?$CI?$CFs?$CJ@
CONST	SEGMENT
??_C@_0BC@PKOGNFCH@Trade?5Commit?5?$CI?$CFs?$CJ@ DB 'Trade Commit (%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FHLLPNOD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransactio@
CONST	SEGMENT
??_C@_0CN@FHLLPNOD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransactio@ DB '['
	DB	'%s][%s] error-L3 : pTransaction(%d) status2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@NFIOKOGL@error?5?3?5gObjInventoryCommit?$CI?$CJ?5?9@
CONST	SEGMENT
??_C@_0DK@NFIOKOGL@error?5?3?5gObjInventoryCommit?$CI?$CJ?5?9@ DB 'error '
	DB	': gObjInventoryCommit() - aIndex out of bound %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjInventoryCommit@@YAHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjInventoryCommit@@YAHH@Z@4JA DD 0390dH ; `gObjInventoryCommit'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BH@NHBCKBPB@Trade?5Transaction?5?$CI?$CFs?$CJ@
CONST	SEGMENT
??_C@_0BH@NHBCKBPB@Trade?5Transaction?5?$CI?$CFs?$CJ@ DB 'Trade Transacti'
	DB	'on (%s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CKMLLKAG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransactio@
CONST	SEGMENT
??_C@_0DI@CKMLLKAG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransactio@ DB '['
	DB	'%s][%s] error-L3 : pTransaction(%d) status error %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjInventoryTrans@@YAHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjInventoryTrans@@YAHH@Z@4JA DD 038dfH ; `gObjInventoryTrans'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0FC@PMECEPOA@UPDATE?5?$FLMuOnline?$FN?4?$FLdbo?$FN?4?$FLCharac@
CONST	SEGMENT
??_C@_0FC@PMECEPOA@UPDATE?5?$FLMuOnline?$FN?4?$FLdbo?$FN?4?$FLCharac@ DB 'U'
	DB	'PDATE [MuOnline].[dbo].[Character] SET DuelLoser = DuelLoser '
	DB	'+ 1 WHERE Name=''%s''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@KCJNEJFM@UPDATE?5?$FLMuOnline?$FN?4?$FLdbo?$FN?4?$FLCharac@
CONST	SEGMENT
??_C@_0FA@KCJNEJFM@UPDATE?5?$FLMuOnline?$FN?4?$FLdbo?$FN?4?$FLCharac@ DB 'U'
	DB	'PDATE [MuOnline].[dbo].[Character] SET DuelWins = DuelWins + '
	DB	'1 WHERE Name=''%s''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KJGJCOOM@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win?5Duel?0?5Loser@
CONST	SEGMENT
??_C@_0CJ@KJGJCOOM@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win?5Duel?0?5Loser@ DB '['
	DB	'Duel] [%s][%s] Win Duel, Loser [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@OALGHOD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Us@
CONST	SEGMENT
??_C@_0EM@OALGHOD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Us@ DB '['
	DB	'Chaos Castle] (%d) [%s][%s] User Dead In Chaos Castle : Kille'
	DB	'd by [%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@HEKHJLCJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5a?5stone?5sta@
CONST	SEGMENT
??_C@_0DN@HEKHJLCJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5a?5stone?5sta@ DB '['
	DB	'Blood Castle] (%d) a stone statue Of Saint Terminated -> %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@KMNGALHI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5a?5stone?5sta@
CONST	SEGMENT
??_C@_0EG@KMNGALHI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5a?5stone?5sta@ DB '['
	DB	'Blood Castle] (%d) a stone statue Of Saint Terminated -> %d ['
	DB	'%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NGGLKHML@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Termin@
CONST	SEGMENT
??_C@_0CL@NGGLKHML@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Termin@ DB '['
	DB	'Blood Castle] (%d) Door Terminated -> %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JANPNOOL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Termin@
CONST	SEGMENT
??_C@_0DD@JANPNOOL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Termin@ DB '['
	DB	'Blood Castle] (%d) Door Terminated -> %d [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HJAGOCKC@?$FL?$CFs?$FN?5derroto?5un?5Tantalo?5Dorado?4@
CONST	SEGMENT
??_C@_0CA@HJAGOCKC@?$FL?$CFs?$FN?5derroto?5un?5Tantalo?5Dorado?4@ DB '[%s'
	DB	'] derroto un Tantalo Dorado.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OLGAAMMO@?$FL?$CFs?$FN?5derroto?5un?5Lizard?5King?5Dor@
CONST	SEGMENT
??_C@_0CE@OLGAAMMO@?$FL?$CFs?$FN?5derroto?5un?5Lizard?5King?5Dor@ DB '[%s'
	DB	'] derroto un Lizard King Dorado.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IAJJAOEN@?$FL?$CFs?$FN?5derroto?5un?5Dragon?5Dorado?4@
CONST	SEGMENT
??_C@_0BP@IAJJAOEN@?$FL?$CFs?$FN?5derroto?5un?5Dragon?5Dorado?4@ DB '[%s]'
	DB	' derroto un Dragon Dorado.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EDKFBDOM@?$FL?$CFs?$FN?5derroto?5un?5Titan?5Dorado?4@
CONST	SEGMENT
??_C@_0BO@EDKFBDOM@?$FL?$CFs?$FN?5derroto?5un?5Titan?5Dorado?4@ DB '[%s] '
	DB	'derroto un Titan Dorado.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GEEBCKIA@?$FL?$CFs?$FN?5derroto?5un?5Goblin?5Dorado?4@
CONST	SEGMENT
??_C@_0BP@GEEBCKIA@?$FL?$CFs?$FN?5derroto?5un?5Goblin?5Dorado?4@ DB '[%s]'
	DB	' derroto un Goblin Dorado.', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjExpParty@@YAXPAVOBJECTSTRUCT@@0HH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjExpParty@@YAXPAVOBJECTSTRUCT@@0HH@Z@4JA DD 032edH ; `gObjExpParty'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CE@HGMOIFIK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5ReSet?5SelfDefence?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0CE@HGMOIFIK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5ReSet?5SelfDefence?5?$FL?$CFs?$FN@ DB '['
	DB	'%s][%s] ReSet SelfDefence [%s][%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IPHFNLBG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Set?5SelfDefence?5?$FL?$CFs?$FN?$FL?$CF@
CONST	SEGMENT
??_C@_0CC@IPHFNLBG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Set?5SelfDefence?5?$FL?$CFs?$FN?$FL?$CF@ DB '['
	DB	'%s][%s] Set SelfDefence [%s][%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@HDCMLJGF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemExpDown?$FN?5?$FL?$CFs?$FN?5L@
CONST	SEGMENT
??_C@_0DL@HDCMLJGF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemExpDown?$FN?5?$FL?$CFs?$FN?5L@ DB '['
	DB	'%s][%s][PetItemExpDown] [%s] Level:[%d]Exp:[%d]DecExp[%d]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PAJOKIHI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Death?5reduces?5Experien@
CONST	SEGMENT
??_C@_0CK@PAJOKIHI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Death?5reduces?5Experien@ DB '['
	DB	'%s][%s] Death reduces Experience %u - %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CKMJEEKH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5User?5Die?5Item?5Drop?0?5It@
CONST	SEGMENT
??_C@_0CJ@CKMJEEKH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5User?5Die?5Item?5Drop?0?5It@ DB '['
	DB	'%s][%s] User Die Item Drop, ItemName:%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GL@DJDDMNFC@Killed?5by?5User?5State?5Victim?3?$FL?$CFs@
CONST	SEGMENT
??_C@_0GL@DJDDMNFC@Killed?5by?5User?5State?5Victim?3?$FL?$CFs@ DB 'Killed'
	DB	' by User State Victim:[%s][%s], Murderer:[%s][%s], Dead State'
	DB	' (Duel:%d, GuildWar:%d, SeldDefense:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@HIGLADFI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CIPkLevel?5?$DN?5?$CFd?$CJ?5Killed?5@
CONST	SEGMENT
??_C@_0EG@HIGLADFI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CIPkLevel?5?$DN?5?$CFd?$CJ?5Killed?5@ DB '['
	DB	'%s][%s] (PkLevel = %d) Killed [%s][%s] (PkLevel = %d) Pos:(%d'
	DB	',%d,%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JFDMHJOK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Killed?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pos?3?$CI?$CF@
CONST	SEGMENT
??_C@_0CI@JFDMHJOK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Killed?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pos?3?$CI?$CF@ DB '['
	DB	'%s][%s] Killed [%s][%s] Pos:(%d,%d,%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GOHPBKOH@Monster@
CONST	SEGMENT
??_C@_07GOHPBKOH@Monster@ DB 'Monster', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@NNNAIELC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Dead?5In?5Blo@
CONST	SEGMENT
??_C@_0EM@NNNAIELC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Dead?5In?5Blo@ DB '['
	DB	'Blood Castle] (%d) Dead In Blood Castle, Killed by Other User'
	DB	' [%s][%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@EGIDAPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Dead?5In?5Blo@
CONST	SEGMENT
??_C@_0EJ@EGIDAPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Dead?5In?5Blo@ DB '['
	DB	'Blood Castle] (%d) Dead In Blood Castle, Killed by Monster [%'
	DB	's][%s][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@COJKOION@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Try?5to?5dele@
CONST	SEGMENT
??_C@_0DL@COJKOION@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Try?5to?5dele@ DB '['
	DB	'Blood Castle] (%d) Try to delete Ultimate Weapon [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@HJPHEOFL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Try?5to?5drop@
CONST	SEGMENT
??_C@_0DJ@HJPHEOFL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Try?5to?5drop@ DB '['
	DB	'Blood Castle] (%d) Try to drop Ultimate Weapon [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MMNCCLML@?$FLDevilSquare?$FN?5Dead?5In?5DevilSqua@
CONST	SEGMENT
??_C@_0CP@MMNCCLML@?$FLDevilSquare?$FN?5Dead?5In?5DevilSqua@ DB '[DevilSq'
	DB	'uare] Dead In DevilSquare [%s][%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@HFNAODDP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5PK?5Info?5Set?5?$CIKilled?5Pl@
CONST	SEGMENT
??_C@_0GE@HFNAODDP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5PK?5Info?5Set?5?$CIKilled?5Pl@ DB '['
	DB	'%s][%s] PK Info Set (Killed Player) Origin(PkLevel:%d, PkCoun'
	DB	't:%d) Changed(PkLevel:%d, PkCount:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs@
CONST	SEGMENT
??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs@ DB 'file open error %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjLevelUpPointAdd@@YAHEPAVOBJECTSTRUCT@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjLevelUpPointAdd@@YAHEPAVOBJECTSTRUCT@@@Z@4JA DD 01f8aH ; `gObjLevelUpPointAdd'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5@
CONST	SEGMENT
??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5@ DB '['
	DB	'%s][%s] LevelUp PlusStatQuest Clear AddStat %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@OHEIPIHL@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CF@
CONST	SEGMENT
??_C@_0FI@OHEIPIHL@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CF@ DB 'E'
	DB	'xperience : Map[%d]-(%d,%d) [%s][%s](%d) %I64u %I64d MonsterI'
	DB	'ndex : %d, EventType : %d', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjBackSpring2@@YAHPAVOBJECTSTRUCT@@0H@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjBackSpring2@@YAHPAVOBJECTSTRUCT@@0H@Z@4JA DD 01dccH ; `gObjBackSpring2'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjBackSpring@@YAHPAVOBJECTSTRUCT@@0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjBackSpring@@YAHPAVOBJECTSTRUCT@@0@Z@4JA DD 01ce1H ; `gObjBackSpring'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjStateAttackProc@@YAXPAVOBJECTSTRUCT@@HHHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjStateAttackProc@@YAXPAVOBJECTSTRUCT@@HHHH@Z@4JA DD 01ca9H ; `gObjStateAttackProc'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjStateProc@@YAXPAVOBJECTSTRUCT@@HHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjStateProc@@YAXPAVOBJECTSTRUCT@@HHH@Z@4JA DD 01c2eH ; `gObjStateProc'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BN@NCIMKKEA@error?5?3?5index?5error?5?$CB?$CB?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0BN@NCIMKKEA@error?5?3?5index?5error?5?$CB?$CB?5?$CFs?5?$CFd@ DB 'e'
	DB	'rror : index error !! %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjUserIdConnectCheck@@YAHPADH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjUserIdConnectCheck@@YAHPADH@Z@4JA DD 01b42H ; `gObjUserIdConnectCheck'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjGetAccountId@@YAPADH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjGetAccountId@@YAPADH@Z@4JA DD 01b1dH ; `gObjGetAccountId'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjGetNumber@@YAHHAAH0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjGetNumber@@YAHHAAH0@Z@4JA DD 01b0fH ; `gObjGetNumber'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjGetUserNumber@@YAHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjGetUserNumber@@YAHH@Z@4JA DD 01afeH ; `gObjGetUserNumber'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjSetAccountLogin@@YAHHPADHH0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjSetAccountLogin@@YAHHPADHH0@Z@4JA DD 01aa6H ; `gObjSetAccountLogin'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0GB@MEEFOHBG@?$FL?5CHECK?5POSITION?5?$FN?5DbgName?$FL?$CFd?$FN?5@
CONST	SEGMENT
??_C@_0GB@MEEFOHBG@?$FL?5CHECK?5POSITION?5?$FN?5DbgName?$FL?$CFd?$FN?5@ DB '['
	DB	' CHECK POSITION ] DbgName[%d] [%s][%s] Map[%d]-(%d,%d) Invali'
	DB	'd location causes to force to move', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjSometimeClose@@YAFH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjSometimeClose@@YAFH@Z@4JA DD 018faH ; `gObjSometimeClose'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CG@GAOPIMKK@?0?5?$CI?$CFd?$CJlogout?5?3?0?5Account?5?$FL?$CFs?$FN?0?5I@
CONST	SEGMENT
??_C@_0CG@GAOPIMKK@?0?5?$CI?$CFd?$CJlogout?5?3?0?5Account?5?$FL?$CFs?$FN?0?5I@ DB ','
	DB	' (%d)logout :, Account [%s], IP [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FJCKJIOE@?$CI?$CFd?$CJlogout?5?3?5?$CFs?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0BF@FJCKJIOE@?$CI?$CFd?$CJlogout?5?3?5?$CFs?5?$FL?$CFs?$FN@ DB '(%d'
	DB	')logout : %s [%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DMPMEDAE@?0?5?$CI?$CFd?$CJlogout?9send?5?3?0?5Account?5?$FL?$CF@
CONST	SEGMENT
??_C@_0CL@DMPMEDAE@?0?5?$CI?$CFd?$CJlogout?9send?5?3?0?5Account?5?$FL?$CF@ DB ','
	DB	' (%d)logout-send :, Account [%s], IP [%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FHEGNDKC@?$CI?$CFd?$CJlogout?9send?5?3?5?$CFs?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0BK@FHEGNDKC@?$CI?$CFd?$CJlogout?9send?5?3?5?$CFs?5?$FL?$CFs?$FN@ DB '('
	DB	'%d)logout-send : %s [%s]', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjDel@@YAFH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjDel@@YAFH@Z@4JA DD 01896H		; `gObjDel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@
CONST	SEGMENT
??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@ DB '[Fix'
	DB	' Inv.Ptr] False Location - %s, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjGameClose@@YAHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjGameClose@@YAHH@Z@4JA DD 01762H	; `gObjGameClose'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CB@PNMAPJFE@?$CI?$CFs?$CJ?$CI?$CFd?$CJ?5?$DN?5index?5over?5error?5?$CI?$CFd@
CONST	SEGMENT
??_C@_0CB@PNMAPJFE@?$CI?$CFs?$CJ?$CI?$CFd?$CJ?5?$DN?5index?5over?5error?5?$CI?$CFd@ DB '('
	DB	'%s)(%d) = index over error (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjMemFree@@YAFH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjMemFree@@YAFH@Z@4JA DD 0171dH	; `gObjMemFree'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjAddCallMon@@YAFXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjAddCallMon@@YAFXZ@4JA DD 015cdH	; `gObjAddCallMon'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??gObjAddMonster@@YAFH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjAddMonster@@YAFH@Z@4JA DD 01556H	; `gObjAddMonster'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BD@LOIPIKDB@connect?5?3?5?$FL?$CFd?$FN?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0BD@LOIPIKDB@connect?5?3?5?$FL?$CFd?$FN?$FL?$CFs?$FN@ DB 'connect :'
	DB	' [%d][%s]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HDDGJDLK@SkyLand?5Boss?5Shield?5Setting?$CB?$CB@
CONST	SEGMENT
??_C@_0BO@HDDGJDLK@SkyLand?5Boss?5Shield?5Setting?$CB?$CB@ DB 'SkyLand Bo'
	DB	'ss Shield Setting!!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GCONPPCF@SkyLand?5Boss?5Monster?5Setting?$CB?$CB@
CONST	SEGMENT
??_C@_0BP@GCONPPCF@SkyLand?5Boss?5Monster?5Setting?$CB?$CB@ DB 'SkyLand B'
	DB	'oss Monster Setting!!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DGECBEHF@?C?$LF?$LA?x?$LK?$LI?$LN?$LK?$LI?w?5?$LM?$LD?A?$KE?5?$LN?G?F?P@
CONST	SEGMENT
??_C@_0BF@DGECBEHF@?C?$LF?$LA?x?$LK?$LI?$LN?$LK?$LI?w?5?$LM?$LD?A?$KE?5?$LN?G?F?P@ DB 0c3H
	DB	0b5H, 0b0H, 0f8H, 0baH, 0b8H, 0bdH, 0baH, 0b8H, 0f7H, ' ', 0bcH
	DB	0b3H, 0c1H, 0a4H, ' ', 0bdH, 0c7H, 0c6H, 0d0H, 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjSetMonster@@YAHHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjSetMonster@@YAHHH@Z@4JA DD 011f7H	; `gObjSetMonster'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BJ@KEIINKC@error?9L2?5?3?5?$CFd?5class?5?3?5?$CFd@
CONST	SEGMENT
??_C@_0BJ@KEIINKC@error?9L2?5?3?5?$CFd?5class?5?3?5?$CFd@ DB 'error-L2 : '
	DB	'%d class : %d', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjSetPosMonster@@YAHHH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjSetPosMonster@@YAHHH@Z@4JA DD 011b2H ; `gObjSetPosMonster'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0HG@OJODFIFG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CharInfoSave?5?3?5Class?$DN?$CF@
CONST	SEGMENT
??_C@_0HG@OJODFIFG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CharInfoSave?5?3?5Class?$DN?$CF@ DB '['
	DB	'%s][%s] CharInfoSave : Class=%d Level=%d LVPoint=%d Exp=%u St'
	DB	'r=%d Dex=%d Vit=%d Energy=%d Leadership:%d Map=%d Pk=%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EFNGMPBL@Free?5User?5Connected?3?5?$FL?$CFs?$FN@
CONST	SEGMENT
??_C@_0BK@EFNGMPBL@Free?5User?5Connected?3?5?$FL?$CFs?$FN@ DB 'Free User '
	DB	'Connected: [%s]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PBFGMDKK@VIP?5User?5Connected?3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$FL?$CFs@
CONST	SEGMENT
??_C@_0CB@PBFGMDKK@VIP?5User?5Connected?3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$FL?$CFs@ DB 'V'
	DB	'IP User Connected: [%s][%d][%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JJLOFGFB@?$CFd?1?$CFm?1?$CFY?5?$CFH?3?$CFM?3?$CFS@
CONST	SEGMENT
??_C@_0BC@JJLOFGFB@?$CFd?1?$CFm?1?$CFY?5?$CFH?3?$CFM?3?$CFS@ DB '%d/%m/%Y'
	DB	' %H:%M:%S', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EIDBCBFJ@?$FLCASH?5SYSTEM?$FN?5Tienes?5?$CFd?5de?5Cash@
CONST	SEGMENT
??_C@_0CA@EIDBCBFJ@?$FLCASH?5SYSTEM?$FN?5Tienes?5?$CFd?5de?5Cash@ DB '[CA'
	DB	'SH SYSTEM] Tienes %d de Cash', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NKGJGPDF@?1vipinfo@
CONST	SEGMENT
??_C@_08NKGJGPDF@?1vipinfo@ DB '/vipinfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JCIHPMHF@?$LO?x?$LE?B?5?$LO?F?$MA?L?E?$NL?5?$LJ?$NP?$LA?$NP?5?$CB?$CB?$CB@
CONST	SEGMENT
??_C@_0BF@JCIHPMHF@?$LO?x?$LE?B?5?$LO?F?$MA?L?E?$NL?5?$LJ?$NP?$LA?$NP?5?$CB?$CB?$CB@ DB 0beH
	DB	0f8H, 0b4H, 0c2H, ' ', 0beH, 0c6H, 0c0H, 0ccH, 0c5H, 0dbH, ' ', 0b9H
	DB	0dfH, 0b0H, 0dfH, ' !!!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GOGGAFJG@Penalty?5?3?5Item?5Don?8t?5touch?5?5?$CFs?5@
CONST	SEGMENT
??_C@_0CC@GOGGAFJG@Penalty?5?3?5Item?5Don?8t?5touch?5?5?$CFs?5@ DB 'Penal'
	DB	'ty : Item Don''t touch  %s %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DNBFMJJP@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Set?5Event?5GM@
CONST	SEGMENT
??_C@_0BG@DNBFMJJP@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Set?5Event?5GM@ DB '(%s)(%'
	DB	's) Set Event GM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PDDCMPCL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Find?5Invalid?5QuestInfo@
CONST	SEGMENT
??_C@_0CF@PDDCMPCL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Find?5Invalid?5QuestInfo@ DB '['
	DB	'%s][%s] Find Invalid QuestInfo (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DHOELAFE@error?5?3?5?$CFd?5?$CI?$CFs?5?$CFd?$CJ@
CONST	SEGMENT
??_C@_0BD@DHOELAFE@error?5?3?5?$CFd?5?$CI?$CFs?5?$CFd?$CJ@ DB 'error : %d'
	DB	' (%s %d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JILLGNNC@error?5?3?5Map?5Number?5max?5over?4?5?$CFs@
CONST	SEGMENT
??_C@_0CD@JILLGNNC@error?5?3?5Map?5Number?5max?5over?4?5?$CFs@ DB 'error '
	DB	': Map Number max over. %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PGPOOLHE@error?5?3?5?$CFs?5Level?5Zero@
CONST	SEGMENT
??_C@_0BG@PGPOOLHE@error?5?3?5?$CFs?5Level?5Zero@ DB 'error : %s Level Ze'
	DB	'ro', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CDKKBDHM@error?9L1?5?3?5ChaosBox?5Init?5error?5@
CONST	SEGMENT
??_C@_0CF@CDKKBDHM@error?9L1?5?3?5ChaosBox?5Init?5error?5@ DB 'error-L1 :'
	DB	' ChaosBox Init error %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@ DB 'error : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjSetCharacter@@YAHPAEH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjSetCharacter@@YAHPAEH@Z@4JA DD 0b91H ; `gObjSetCharacter'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0GK@NPPGCJHE@error?9L2?5?3?5Unknown?5Item?5found?5?$FL@
CONST	SEGMENT
??_C@_0GK@NPPGCJHE@error?9L2?5?3?5Unknown?5Item?5found?5?$FL@ DB 'error-L'
	DB	'2 : Unknown Item found [%s][%s] (Type:%d, LEV:%d, DUR:%d OP1:'
	DB	'%d, OP2:%d, OP3:%d, NEWOP:%d, SET:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HDKCFMCD@error?9L3?5?3?5map?5number?5not?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0CA@HDKCFMCD@error?9L3?5?3?5map?5number?5not?5?$CFs?5?$CFd@ DB 'err'
	DB	'or-L3 : map number not %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetMapMoveLevel@@YAHPAVOBJECTSTRUCT@@HH@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetMapMoveLevel@@YAHPAVOBJECTSTRUCT@@HH@Z@4JA DD 0909H ; `GetMapMoveLevel'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0GG@GPEABMHM@?$FL?5CHECK?5POSITION?5?$FN?5MoveMosterPr@
CONST	SEGMENT
??_C@_0GG@GPEABMHM@?$FL?5CHECK?5POSITION?5?$FN?5MoveMosterPr@ DB '[ CHECK'
	DB	' POSITION ] MoveMosterProc [%s][%s] Map[%d]-(%d,%d) User(%d,%'
	DB	'd) Can not Move Position Attr[%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@GDMCBCLE@?$KB?Z?$FLCHECK_LOG_INFINITY?$FN?5?$CI?5_count@
CONST	SEGMENT
??_C@_0DE@GDMCBCLE@?$KB?Z?$FLCHECK_LOG_INFINITY?$FN?5?$CI?5_count@ DB 0a1H
	DB	0daH, '[CHECK_LOG_INFINITY] ( _count > 100 ) error %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@NOIKLNAL@?$KB?Z?$FLCHECK_LOG_INFINITY?$FN?5gObjIsCo@
CONST	SEGMENT
??_C@_0DF@NOIKLNAL@?$KB?Z?$FLCHECK_LOG_INFINITY?$FN?5gObjIsCo@ DB 0a1H, 0daH
	DB	'[CHECK_LOG_INFINITY] gObjIsConnected() error %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
CONST	SEGMENT
??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ DB 'C:\Mu Onl'
	DB	'ine\Mu-GS-Webzen-MC-10093\GameServer\user.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??gObjSkillUseProcTime500@@YAXPAVOBJECTSTRUCT@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??gObjSkillUseProcTime500@@YAXPAVOBJECTSTRUCT@@@Z@4JA DD 024bH ; `gObjSkillUseProcTime500'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_7StaticObject@@6B@
CONST	SEGMENT
??_7StaticObject@@6B@ DD FLAT:??_R4StaticObject@@6B@	; StaticObject::`vftable'
	DD	FLAT:??_EStaticObject@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd@
CONST	SEGMENT
??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd@ DB 'QeustNpc RefCo'
	DB	'unt Dec= %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0StaticObject@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0StaticObject@@QAE@XZ$0
__ehfuncinfo$??0StaticObject@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0StaticObject@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z DD 0ffffffe4H
	DD	00H
	DD	0fffffefcH
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN196@gObjInvent
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?gObjSetCharacter@@YAHPAEH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?gObjSetCharacter@@YAHPAEH@Z$0
__ehfuncinfo$?gObjSetCharacter@@YAHPAEH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?gObjSetCharacter@@YAHPAEH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?gObjInit@@YAXXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?gObjInit@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?gObjInit@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?gObjInit@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?gObjInit@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?gObjInit@@YAXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?gObjInit@@YAXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?gObjInit@@YAXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?gObjInit@@YAXXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?gObjInit@@YAXXZ$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0OBJECTSTRUCT@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0OBJECTSTRUCT@@QAE@XZ$0
__ehfuncinfo$??0OBJECTSTRUCT@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0OBJECTSTRUCT@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_ECMagicInf@@UAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z$0
__ehfuncinfo$??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?ViewGuildMng$initializer$@@3P6AXXZA DD FLAT:??__EViewGuildMng@@YAXXZ ; ViewGuildMng$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?g_kStaticObject$initializer$@@3P6AXXZA DD FLAT:??__Eg_kStaticObject@@YAXXZ ; g_kStaticObject$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?m_ObjBill$initializer$@@3P6AXXZA DD FLAT:??__Em_ObjBill@@YAXXZ ; m_ObjBill$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCheckStatPointDown@@YAHH@Z
_TEXT	SEGMENT
_ori_point$ = -12					; size = 4
_total_point$ = -8					; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjCheckStatPointDown@@YAHH@Z PROC			; gObjCheckStatPointDown, COMDAT

; 30298: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 30299: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 30300: 	int total_point = lpObj->Strength+lpObj->Dexterity+lpObj->Vitality+lpObj->Energy+lpObj->LevelUpPoint;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	0f b7 88 b4 00
	00 00		 movzx	 ecx, WORD PTR [eax+180]
  00023	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00026	0f b7 82 b6 00
	00 00		 movzx	 eax, WORD PTR [edx+182]
  0002d	03 c8		 add	 ecx, eax
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00032	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  00039	03 c8		 add	 ecx, eax
  0003b	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0003e	0f b7 82 ba 00
	00 00		 movzx	 eax, WORD PTR [edx+186]
  00045	03 c8		 add	 ecx, eax
  00047	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0004a	03 8a a4 00 00
	00		 add	 ecx, DWORD PTR [edx+164]
  00050	89 4d f8	 mov	 DWORD PTR _total_point$[ebp], ecx

; 30301: 	int ori_point;
; 30302: 	
; 30303: 
; 30304: #ifdef DARKLORD_WORK
; 30305: 	if( lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA )

  00053	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00056	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0005d	83 f9 04	 cmp	 ecx, 4
  00060	74 0f		 je	 SHORT $LN4@gObjCheckS
  00062	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00065	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0006c	83 f9 03	 cmp	 ecx, 3
  0006f	75 2c		 jne	 SHORT $LN2@gObjCheckS
$LN4@gObjCheckS:

; 30306: #else
; 30307: 	if( lpObj->Class == CLASS_MAGUMSA )
; 30308: #endif
; 30309: 	{	//   7
; 30310: 		ori_point   = DCInfo.GetDefPoint(lpObj->Class)+((lpObj->Level-1)*7);

  00071	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00074	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0007b	51		 push	 ecx
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET ?DCInfo@@3Vclassdef@@A ; DCInfo
  00081	e8 00 00 00 00	 call	 ?GetDefPoint@classdef@@QAEHH@Z ; classdef::GetDefPoint
  00086	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00089	0f bf 8a a0 00
	00 00		 movsx	 ecx, WORD PTR [edx+160]
  00090	83 e9 01	 sub	 ecx, 1
  00093	6b d1 07	 imul	 edx, ecx, 7
  00096	03 c2		 add	 eax, edx
  00098	89 45 f4	 mov	 DWORD PTR _ori_point$[ebp], eax

; 30311: 	}

  0009b	eb 2a		 jmp	 SHORT $LN3@gObjCheckS
$LN2@gObjCheckS:

; 30312: 	else
; 30313: 	{
; 30314: 		ori_point   = DCInfo.GetDefPoint(lpObj->Class)+((lpObj->Level-1)*5);

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a0	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000a7	51		 push	 ecx
  000a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?DCInfo@@3Vclassdef@@A ; DCInfo
  000ad	e8 00 00 00 00	 call	 ?GetDefPoint@classdef@@QAEHH@Z ; classdef::GetDefPoint
  000b2	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000b5	0f bf 8a a0 00
	00 00		 movsx	 ecx, WORD PTR [edx+160]
  000bc	83 e9 01	 sub	 ecx, 1
  000bf	6b d1 05	 imul	 edx, ecx, 5
  000c2	03 c2		 add	 eax, edx
  000c4	89 45 f4	 mov	 DWORD PTR _ori_point$[ebp], eax
$LN3@gObjCheckS:

; 30315: 	}
; 30316: 
; 30317: 	// 1    +10 
; 30318: #ifdef NEW_FORSKYLAND2
; 30319: 	if( g_QuestInfo.GetQuestState(lpObj, 0) == QS_CLEAR )

  000c7	6a 00		 push	 0
  000c9	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000cc	50		 push	 eax
  000cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  000d2	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAVOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  000d7	83 f8 02	 cmp	 eax, 2
  000da	75 09		 jne	 SHORT $LN5@gObjCheckS

; 30320: 	{
; 30321: 		ori_point += 10;

  000dc	8b 45 f4	 mov	 eax, DWORD PTR _ori_point$[ebp]
  000df	83 c0 0a	 add	 eax, 10			; 0000000aH
  000e2	89 45 f4	 mov	 DWORD PTR _ori_point$[ebp], eax
$LN5@gObjCheckS:

; 30322: 	}
; 30323: 
; 30324: 	// 2    +10 
; 30325: 	if( g_QuestInfo.GetQuestState(lpObj, 1) == QS_CLEAR )

  000e5	6a 01		 push	 1
  000e7	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ea	50		 push	 eax
  000eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  000f0	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAVOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  000f5	83 f8 02	 cmp	 eax, 2
  000f8	75 09		 jne	 SHORT $LN6@gObjCheckS

; 30326: 	{
; 30327: 		ori_point += 10;

  000fa	8b 45 f4	 mov	 eax, DWORD PTR _ori_point$[ebp]
  000fd	83 c0 0a	 add	 eax, 10			; 0000000aH
  00100	89 45 f4	 mov	 DWORD PTR _ori_point$[ebp], eax
$LN6@gObjCheckS:

; 30328: 	}
; 30329: #endif
; 30330: #ifdef THIRD_CHANGEUP_SYSTEM_20070507	// 3           
; 30331: 	if( g_QuestInfo.GetQuestState(lpObj, 4) == QS_CLEAR )
; 30332: 	{
; 30333: 		ori_point += 20;
; 30334: 	}
; 30335: 	if( g_QuestInfo.GetQuestState(lpObj, 5) == QS_CLEAR )
; 30336: 	{
; 30337: 		ori_point += 20;
; 30338: 	}
; 30339: 	if( g_QuestInfo.GetQuestState(lpObj, 6) == QS_CLEAR )
; 30340: 	{
; 30341: 		ori_point += 30;
; 30342: 	}
; 30343: #endif
; 30344: 
; 30345: 	//     
; 30346: 	ori_point += gStatMng.GetMaxStat(lpObj->Level, lpObj->Class);

  00103	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00106	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0010d	51		 push	 ecx
  0010e	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00111	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  00118	50		 push	 eax
  00119	b9 00 00 00 00	 mov	 ecx, OFFSET ?gStatMng@@3VCStatMng@@A ; gStatMng
  0011e	e8 00 00 00 00	 call	 ?GetMaxStat@CStatMng@@QAEHHH@Z ; CStatMng::GetMaxStat
  00123	03 45 f4	 add	 eax, DWORD PTR _ori_point$[ebp]
  00126	89 45 f4	 mov	 DWORD PTR _ori_point$[ebp], eax

; 30347: 	//ori_point -= ((lpObj->Level*3)/100+1);
; 30348: 	
; 30349: 	if( total_point > ori_point )

  00129	8b 45 f8	 mov	 eax, DWORD PTR _total_point$[ebp]
  0012c	3b 45 f4	 cmp	 eax, DWORD PTR _ori_point$[ebp]
  0012f	7e 07		 jle	 SHORT $LN7@gObjCheckS

; 30350: 	{	
; 30351: 		return TRUE;

  00131	b8 01 00 00 00	 mov	 eax, 1
  00136	eb 02		 jmp	 SHORT $LN1@gObjCheckS
$LN7@gObjCheckS:

; 30352: 	}
; 30353: 
; 30354: 	return FALSE;

  00138	33 c0		 xor	 eax, eax
$LN1@gObjCheckS:

; 30355: }

  0013a	5f		 pop	 edi
  0013b	5e		 pop	 esi
  0013c	5b		 pop	 ebx
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
?gObjCheckStatPointDown@@YAHH@Z ENDP			; gObjCheckStatPointDown
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCheckStatPointUp@@YAHH@Z
_TEXT	SEGMENT
_ori_point$ = -12					; size = 4
_total_point$ = -8					; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjCheckStatPointUp@@YAHH@Z PROC			; gObjCheckStatPointUp, COMDAT

; 30224: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 30225: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 30226: 	
; 30227: #ifdef MODIFY_DARKLORD_ACQUIRING_EXTRA_POINT_20041117
; 30228: 	int total_point = lpObj->Strength+lpObj->Dexterity+lpObj->Vitality+lpObj->Energy+lpObj->Leadership+lpObj->LevelUpPoint;
; 30229: #else
; 30230: 	int total_point = lpObj->Strength+lpObj->Dexterity+lpObj->Vitality+lpObj->Energy+lpObj->LevelUpPoint;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	0f b7 88 b4 00
	00 00		 movzx	 ecx, WORD PTR [eax+180]
  00023	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00026	0f b7 82 b6 00
	00 00		 movzx	 eax, WORD PTR [edx+182]
  0002d	03 c8		 add	 ecx, eax
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00032	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  00039	03 c8		 add	 ecx, eax
  0003b	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0003e	0f b7 82 ba 00
	00 00		 movzx	 eax, WORD PTR [edx+186]
  00045	03 c8		 add	 ecx, eax
  00047	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0004a	03 8a a4 00 00
	00		 add	 ecx, DWORD PTR [edx+164]
  00050	89 4d f8	 mov	 DWORD PTR _total_point$[ebp], ecx

; 30231: #endif
; 30232: 
; 30233: 	int ori_point;
; 30234: 	
; 30235: 
; 30236: #ifdef DARKLORD_WORK
; 30237: 	if( lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA )

  00053	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00056	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0005d	83 f9 04	 cmp	 ecx, 4
  00060	74 0f		 je	 SHORT $LN4@gObjCheckS
  00062	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00065	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0006c	83 f9 03	 cmp	 ecx, 3
  0006f	75 2c		 jne	 SHORT $LN2@gObjCheckS
$LN4@gObjCheckS:

; 30238: #else
; 30239: 	if( lpObj->Class == CLASS_MAGUMSA )
; 30240: #endif
; 30241: 	{	//   7
; 30242: 		ori_point   = DCInfo.GetDefPoint(lpObj->Class)+((lpObj->Level-1)*7);

  00071	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00074	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0007b	51		 push	 ecx
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET ?DCInfo@@3Vclassdef@@A ; DCInfo
  00081	e8 00 00 00 00	 call	 ?GetDefPoint@classdef@@QAEHH@Z ; classdef::GetDefPoint
  00086	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00089	0f bf 8a a0 00
	00 00		 movsx	 ecx, WORD PTR [edx+160]
  00090	83 e9 01	 sub	 ecx, 1
  00093	6b d1 07	 imul	 edx, ecx, 7
  00096	03 c2		 add	 eax, edx
  00098	89 45 f4	 mov	 DWORD PTR _ori_point$[ebp], eax

; 30243: 	}

  0009b	eb 2a		 jmp	 SHORT $LN3@gObjCheckS
$LN2@gObjCheckS:

; 30244: 	else
; 30245: 	{
; 30246: 		ori_point   = DCInfo.GetDefPoint(lpObj->Class)+((lpObj->Level-1)*5);

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a0	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000a7	51		 push	 ecx
  000a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?DCInfo@@3Vclassdef@@A ; DCInfo
  000ad	e8 00 00 00 00	 call	 ?GetDefPoint@classdef@@QAEHH@Z ; classdef::GetDefPoint
  000b2	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000b5	0f bf 8a a0 00
	00 00		 movsx	 ecx, WORD PTR [edx+160]
  000bc	83 e9 01	 sub	 ecx, 1
  000bf	6b d1 05	 imul	 edx, ecx, 5
  000c2	03 c2		 add	 eax, edx
  000c4	89 45 f4	 mov	 DWORD PTR _ori_point$[ebp], eax
$LN3@gObjCheckS:

; 30247: 	}
; 30248: 
; 30249: 	// 1    +10 
; 30250: #ifdef NEW_FORSKYLAND2
; 30251: 	if( g_QuestInfo.GetQuestState(lpObj, 0) == QS_CLEAR )

  000c7	6a 00		 push	 0
  000c9	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000cc	50		 push	 eax
  000cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  000d2	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAVOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  000d7	83 f8 02	 cmp	 eax, 2
  000da	75 09		 jne	 SHORT $LN5@gObjCheckS

; 30252: 	{
; 30253: 		ori_point += 10;

  000dc	8b 45 f4	 mov	 eax, DWORD PTR _ori_point$[ebp]
  000df	83 c0 0a	 add	 eax, 10			; 0000000aH
  000e2	89 45 f4	 mov	 DWORD PTR _ori_point$[ebp], eax
$LN5@gObjCheckS:

; 30254: 	}
; 30255: 
; 30256: 	// 2    +10 
; 30257: 	if( g_QuestInfo.GetQuestState(lpObj, 1) == QS_CLEAR )

  000e5	6a 01		 push	 1
  000e7	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ea	50		 push	 eax
  000eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  000f0	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAVOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  000f5	83 f8 02	 cmp	 eax, 2
  000f8	75 09		 jne	 SHORT $LN6@gObjCheckS

; 30258: 	{
; 30259: 		ori_point += 10;

  000fa	8b 45 f4	 mov	 eax, DWORD PTR _ori_point$[ebp]
  000fd	83 c0 0a	 add	 eax, 10			; 0000000aH
  00100	89 45 f4	 mov	 DWORD PTR _ori_point$[ebp], eax
$LN6@gObjCheckS:

; 30260: 	}
; 30261: #endif
; 30262: 
; 30263: #ifdef SECOND_QUEST
; 30264: 	if( g_QuestInfo.GetQuestState(lpObj, 2) == QS_CLEAR )

  00103	6a 02		 push	 2
  00105	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00108	50		 push	 eax
  00109	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  0010e	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAVOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  00113	83 f8 02	 cmp	 eax, 2
  00116	75 17		 jne	 SHORT $LN7@gObjCheckS

; 30265: 	{
; 30266: 		ori_point += lpObj->Level-220;

  00118	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011b	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00122	8b 55 f4	 mov	 edx, DWORD PTR _ori_point$[ebp]
  00125	8d 84 0a 24 ff
	ff ff		 lea	 eax, DWORD PTR [edx+ecx-220]
  0012c	89 45 f4	 mov	 DWORD PTR _ori_point$[ebp], eax
$LN7@gObjCheckS:

; 30267: 	}
; 30268: #endif
; 30269: #ifdef THIRD_CHANGEUP_SYSTEM_20070507	// 3           
; 30270: 	if( g_QuestInfo.GetQuestState(lpObj, 4) == QS_CLEAR )
; 30271: 	{
; 30272: 		ori_point += 20;
; 30273: 	}
; 30274: 	if( g_QuestInfo.GetQuestState(lpObj, 5) == QS_CLEAR )
; 30275: 	{
; 30276: 		ori_point += 20;
; 30277: 	}
; 30278: 	if( g_QuestInfo.GetQuestState(lpObj, 6) == QS_CLEAR )
; 30279: 	{
; 30280: 		ori_point += 30;
; 30281: 	}
; 30282: #endif	
; 30283: 
; 30284: 	//     
; 30285: 	ori_point += gStatMng.GetMaxStat(lpObj->Level, lpObj->Class);

  0012f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00132	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00139	51		 push	 ecx
  0013a	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0013d	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  00144	50		 push	 eax
  00145	b9 00 00 00 00	 mov	 ecx, OFFSET ?gStatMng@@3VCStatMng@@A ; gStatMng
  0014a	e8 00 00 00 00	 call	 ?GetMaxStat@CStatMng@@QAEHHH@Z ; CStatMng::GetMaxStat
  0014f	03 45 f4	 add	 eax, DWORD PTR _ori_point$[ebp]
  00152	89 45 f4	 mov	 DWORD PTR _ori_point$[ebp], eax

; 30286: 	//ori_point += ((lpObj->Level*3)/100+1);
; 30287: 	
; 30288: 	if( total_point < ori_point )

  00155	8b 45 f8	 mov	 eax, DWORD PTR _total_point$[ebp]
  00158	3b 45 f4	 cmp	 eax, DWORD PTR _ori_point$[ebp]
  0015b	7d 07		 jge	 SHORT $LN8@gObjCheckS

; 30289: 	{	
; 30290: 		return TRUE;

  0015d	b8 01 00 00 00	 mov	 eax, 1
  00162	eb 02		 jmp	 SHORT $LN1@gObjCheckS
$LN8@gObjCheckS:

; 30291: 	}
; 30292: 
; 30293: 	return FALSE;

  00164	33 c0		 xor	 eax, eax
$LN1@gObjCheckS:

; 30294: }

  00166	5f		 pop	 edi
  00167	5e		 pop	 esi
  00168	5b		 pop	 ebx
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
?gObjCheckStatPointUp@@YAHH@Z ENDP			; gObjCheckStatPointUp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCheckattackAreaUsedViewPort@@YAHHH@Z
_TEXT	SEGMENT
_n$1 = -16						; size = 4
_MVL$ = -12						; size = 4
_lpTargetObj$ = -8					; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_TarObjIndex$ = 12					; size = 4
?gObjCheckattackAreaUsedViewPort@@YAHHH@Z PROC		; gObjCheckattackAreaUsedViewPort, COMDAT

; 29660: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29661: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 29662: 	LPOBJECTSTRUCT lpTargetObj = &gObj[TarObjIndex];

  00019	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _TarObjIndex$[ebp], 7072
  00020	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00026	89 45 f8	 mov	 DWORD PTR _lpTargetObj$[ebp], eax

; 29663: 	
; 29664: 
; 29665: 	if( lpTargetObj->m_Index == lpObj->m_Index )

  00029	8b 45 f8	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0002f	8b 10		 mov	 edx, DWORD PTR [eax]
  00031	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00033	75 0a		 jne	 SHORT $LN5@gObjChecka

; 29666: 		return TRUE;

  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	e9 98 00 00 00	 jmp	 $LN1@gObjChecka
$LN5@gObjChecka:

; 29667: 
; 29668: 	int MVL = MAXVIEWPORTOBJECT;

  0003f	c7 45 f4 4b 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 75 ; 0000004bH

; 29669: 	if( lpObj->Type == OBJTYPE_MONSTER ) MVL = MAX_MONVIEWPORTOBJECT;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00049	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0004d	83 f9 02	 cmp	 ecx, 2
  00050	75 07		 jne	 SHORT $LN6@gObjChecka
  00052	c7 45 f4 14 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 20 ; 00000014H
$LN6@gObjChecka:

; 29670: 
; 29671: // 1.      .
; 29672: // 2.    .
; 29673: // 3.    .
; 29674: 	for( int n=0; n<MVL; n++)

  00059	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00060	eb 09		 jmp	 SHORT $LN4@gObjChecka
$LN2@gObjChecka:
  00062	8b 45 f0	 mov	 eax, DWORD PTR _n$1[ebp]
  00065	83 c0 01	 add	 eax, 1
  00068	89 45 f0	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjChecka:
  0006b	8b 45 f0	 mov	 eax, DWORD PTR _n$1[ebp]
  0006e	3b 45 f4	 cmp	 eax, DWORD PTR _MVL$[ebp]
  00071	7d 62		 jge	 SHORT $LN3@gObjChecka

; 29675: 	{
; 29676: 		if( lpObj->VpPlayer[n].state )

  00073	6b 45 f0 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00077	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0007a	0f be 94 01 64
	03 00 00	 movsx	 edx, BYTE PTR [ecx+eax+868]
  00082	85 d2		 test	 edx, edx
  00084	74 1d		 je	 SHORT $LN7@gObjChecka

; 29677: 		{ //  
; 29678: 			if( lpObj->VpPlayer[n].number == lpTargetObj->m_Index ) 

  00086	6b 45 f0 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0008d	0f bf 94 01 66
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax+870]
  00095	8b 45 f8	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00098	3b 10		 cmp	 edx, DWORD PTR [eax]
  0009a	75 07		 jne	 SHORT $LN7@gObjChecka

; 29679: 			{   // 
; 29680: 				//if( lpObj->VpPlayer[n].state == 1 ) lpObj->VpPlayer[n].state = 2;
; 29681: 				return TRUE;

  0009c	b8 01 00 00 00	 mov	 eax, 1
  000a1	eb 34		 jmp	 SHORT $LN1@gObjChecka
$LN7@gObjChecka:

; 29682: 			}
; 29683: 		} 
; 29684: 
; 29685: #ifdef MODIFY_KUNDUN_VIEWPORT_20060523
; 29686: 		//         
; 29687: 		if ( lpObj->VpPlayer2[n].state )

  000a3	6b 45 f0 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000aa	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  000b2	85 d2		 test	 edx, edx
  000b4	74 1d		 je	 SHORT $LN9@gObjChecka

; 29688: 		{
; 29689: 			if ( lpObj->VpPlayer2[n].number == lpTargetObj->m_Index )

  000b6	6b 45 f0 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000bd	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  000c5	8b 45 f8	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000c8	3b 10		 cmp	 edx, DWORD PTR [eax]
  000ca	75 07		 jne	 SHORT $LN9@gObjChecka

; 29690: 			{
; 29691: 				return TRUE;

  000cc	b8 01 00 00 00	 mov	 eax, 1
  000d1	eb 04		 jmp	 SHORT $LN1@gObjChecka
$LN9@gObjChecka:

; 29692: 			}
; 29693: 		}
; 29694: #endif // MODIFY_KUNDUN_VIEWPORT_20060523
; 29695: 
; 29696: 	}

  000d3	eb 8d		 jmp	 SHORT $LN2@gObjChecka
$LN3@gObjChecka:

; 29697: 	return FALSE;

  000d5	33 c0		 xor	 eax, eax
$LN1@gObjChecka:

; 29698: }

  000d7	5f		 pop	 edi
  000d8	5e		 pop	 esi
  000d9	5b		 pop	 ebx
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
?gObjCheckattackAreaUsedViewPort@@YAHHH@Z ENDP		; gObjCheckattackAreaUsedViewPort
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCheckAttackAreaUsedPath@@YAHHH@Z
_TEXT	SEGMENT
_Y$ = -8						; size = 4
_X$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_TarObjIndex$ = 12					; size = 4
?gObjCheckAttackAreaUsedPath@@YAHHH@Z PROC		; gObjCheckAttackAreaUsedPath, COMDAT

; 29637: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29638: 	int X, Y;
; 29639: 
; 29640: 	if( gObj[aIndex].PathCount > 1 )

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	83 bc 01 28 01
	00 00 01	 cmp	 DWORD PTR [ecx+eax+296], 1
  0001e	7e 5a		 jle	 SHORT $LN2@gObjCheckA

; 29641: 	{
; 29642: 		X = gObj[aIndex].PathX[gObj[aIndex].PathCount-1];

  00020	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00027	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002d	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00034	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003a	8b 8c 0a 28 01
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+296]
  00041	0f bf 94 48 4e
	01 00 00	 movsx	 edx, WORD PTR [eax+ecx*2+334]
  00049	89 55 fc	 mov	 DWORD PTR _X$[ebp], edx

; 29643: 		Y = gObj[aIndex].PathY[gObj[aIndex].PathCount-1];

  0004c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00053	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00059	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00060	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00066	8b 8c 0a 28 01
	00 00		 mov	 ecx, DWORD PTR [edx+ecx+296]
  0006d	0f bf 94 48 6c
	01 00 00	 movsx	 edx, WORD PTR [eax+ecx*2+364]
  00075	89 55 f8	 mov	 DWORD PTR _Y$[ebp], edx

; 29644: 	}	

  00078	eb 07		 jmp	 SHORT $LN3@gObjCheckA
$LN2@gObjCheckA:

; 29645: 	else
; 29646: 	{
; 29647: 		return FALSE;

  0007a	33 c0		 xor	 eax, eax
  0007c	e9 85 00 00 00	 jmp	 $LN1@gObjCheckA
$LN3@gObjCheckA:

; 29648: 	}
; 29649: 
; 29650: 	if( (gObj[TarObjIndex].X < (X-10)) || (gObj[TarObjIndex].X > (X+10)) ||
; 29651: 	    (gObj[TarObjIndex].Y < (Y-10)) || (gObj[TarObjIndex].Y > (Y+10)) )

  00081	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _TarObjIndex$[ebp], 7072
  00088	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008e	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  00096	8b 45 fc	 mov	 eax, DWORD PTR _X$[ebp]
  00099	83 e8 0a	 sub	 eax, 10			; 0000000aH
  0009c	3b d0		 cmp	 edx, eax
  0009e	7c 5d		 jl	 SHORT $LN5@gObjCheckA
  000a0	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _TarObjIndex$[ebp], 7072
  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ad	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  000b5	8b 45 fc	 mov	 eax, DWORD PTR _X$[ebp]
  000b8	83 c0 0a	 add	 eax, 10			; 0000000aH
  000bb	3b d0		 cmp	 edx, eax
  000bd	7f 3e		 jg	 SHORT $LN5@gObjCheckA
  000bf	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _TarObjIndex$[ebp], 7072
  000c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cc	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  000d4	8b 45 f8	 mov	 eax, DWORD PTR _Y$[ebp]
  000d7	83 e8 0a	 sub	 eax, 10			; 0000000aH
  000da	3b d0		 cmp	 edx, eax
  000dc	7c 1f		 jl	 SHORT $LN5@gObjCheckA
  000de	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _TarObjIndex$[ebp], 7072
  000e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000eb	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  000f3	8b 45 f8	 mov	 eax, DWORD PTR _Y$[ebp]
  000f6	83 c0 0a	 add	 eax, 10			; 0000000aH
  000f9	3b d0		 cmp	 edx, eax
  000fb	7e 04		 jle	 SHORT $LN4@gObjCheckA
$LN5@gObjCheckA:

; 29652: 	{	//  
; 29653: 		return FALSE;

  000fd	33 c0		 xor	 eax, eax
  000ff	eb 05		 jmp	 SHORT $LN1@gObjCheckA
$LN4@gObjCheckA:

; 29654: 	}
; 29655: 
; 29656: 	return TRUE;

  00101	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjCheckA:

; 29657: }

  00106	5f		 pop	 edi
  00107	5e		 pop	 esi
  00108	5b		 pop	 ebx
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
?gObjCheckAttackAreaUsedPath@@YAHHH@Z ENDP		; gObjCheckAttackAreaUsedPath
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCurMoveMake@@YAHQAEPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_n$2 = -16						; size = 4
_sendbyte$ = -12					; size = 4
_total$ = -8						; size = 4
_cur$ = -4						; size = 4
_path$ = 8						; size = 4
_lpObj$ = 12						; size = 4
?gObjCurMoveMake@@YAHQAEPAVOBJECTSTRUCT@@@Z PROC	; gObjCurMoveMake, COMDAT

; 23601: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 23602: 	int cur      = lpObj->PathCur;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	8b 88 2c 01 00
	00		 mov	 ecx, DWORD PTR [eax+300]
  00012	89 4d fc	 mov	 DWORD PTR _cur$[ebp], ecx

; 23603: 	int total    = lpObj->PathCount;

  00015	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00018	8b 88 28 01 00
	00		 mov	 ecx, DWORD PTR [eax+296]
  0001e	89 4d f8	 mov	 DWORD PTR _total$[ebp], ecx

; 23604: 	int sendbyte = 1;

  00021	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _sendbyte$[ebp], 1

; 23605: 	
; 23606: //	memset(path, 0, 8);
; 23607: 
; 23608: 	path[0] = (lpObj->Dir<<4);			// 

  00028	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002b	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  00032	c1 e1 04	 shl	 ecx, 4
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	6b c2 00	 imul	 eax, edx, 0
  0003d	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  00040	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 23609: 	path[0] |= (BYTE)((total-cur)&0x0f);		//    

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	6b c8 00	 imul	 ecx, eax, 0
  0004b	8b 55 f8	 mov	 edx, DWORD PTR _total$[ebp]
  0004e	2b 55 fc	 sub	 edx, DWORD PTR _cur$[ebp]
  00051	83 e2 0f	 and	 edx, 15			; 0000000fH
  00054	0f b6 c2	 movzx	 eax, dl
  00057	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  0005a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  0005e	0b c8		 or	 ecx, eax
  00060	ba 01 00 00 00	 mov	 edx, 1
  00065	6b c2 00	 imul	 eax, edx, 0
  00068	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  0006b	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 23610: 
; 23611: 	if( (total-cur) < 0 ) {

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _total$[ebp]
  00071	2b 45 fc	 sub	 eax, DWORD PTR _cur$[ebp]
  00074	79 45		 jns	 SHORT $LN5@gObjCurMov

; 23612: 		MsgBox("error : %s %d",__FILE__, __LINE__);

  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjCurMoveMake@@YAHQAEPAVOBJECTSTRUCT@@@Z@4JA
  0007b	83 c0 0b	 add	 eax, 11			; 0000000bH
  0007e	50		 push	 eax
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  00089	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0008e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23613: 		path[0] &= 0xF0;

  00091	b8 01 00 00 00	 mov	 eax, 1
  00096	6b c8 00	 imul	 ecx, eax, 0
  00099	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  0009c	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000a0	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000a5	b9 01 00 00 00	 mov	 ecx, 1
  000aa	6b d1 00	 imul	 edx, ecx, 0
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  000b0	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 23614: 		return sendbyte;

  000b3	8b 45 f4	 mov	 eax, DWORD PTR _sendbyte$[ebp]
  000b6	e9 21 01 00 00	 jmp	 $LN1@gObjCurMov
$LN5@gObjCurMov:

; 23615: 	}
; 23616: 	
; 23617: 	if( total == 0 ) {

  000bb	83 7d f8 00	 cmp	 DWORD PTR _total$[ebp], 0
  000bf	75 2a		 jne	 SHORT $LN6@gObjCurMov

; 23618: 		path[0] &= 0xF0;

  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	6b c8 00	 imul	 ecx, eax, 0
  000c9	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  000cc	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  000d0	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000d5	b9 01 00 00 00	 mov	 ecx, 1
  000da	6b d1 00	 imul	 edx, ecx, 0
  000dd	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  000e0	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 23619: 		return sendbyte;	//  

  000e3	8b 45 f4	 mov	 eax, DWORD PTR _sendbyte$[ebp]
  000e6	e9 f1 00 00 00	 jmp	 $LN1@gObjCurMov
$LN6@gObjCurMov:

; 23620: 	}
; 23621: 	if( total == cur ) {

  000eb	8b 45 f8	 mov	 eax, DWORD PTR _total$[ebp]
  000ee	3b 45 fc	 cmp	 eax, DWORD PTR _cur$[ebp]
  000f1	75 2a		 jne	 SHORT $LN7@gObjCurMov

; 23622: 		path[0] &= 0xF0;

  000f3	b8 01 00 00 00	 mov	 eax, 1
  000f8	6b c8 00	 imul	 ecx, eax, 0
  000fb	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  000fe	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00102	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00107	b9 01 00 00 00	 mov	 ecx, 1
  0010c	6b d1 00	 imul	 edx, ecx, 0
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00112	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 23623: 		return sendbyte;	//  

  00115	8b 45 f4	 mov	 eax, DWORD PTR _sendbyte$[ebp]
  00118	e9 bf 00 00 00	 jmp	 $LN1@gObjCurMov
$LN7@gObjCurMov:

; 23624: 	}
; 23625: 	
; 23626: 	for( int n=cur, i=1; n<total; n++, i++)

  0011d	8b 45 fc	 mov	 eax, DWORD PTR _cur$[ebp]
  00120	89 45 f0	 mov	 DWORD PTR _n$2[ebp], eax
  00123	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 1
  0012a	eb 12		 jmp	 SHORT $LN4@gObjCurMov
$LN2@gObjCurMov:
  0012c	8b 45 f0	 mov	 eax, DWORD PTR _n$2[ebp]
  0012f	83 c0 01	 add	 eax, 1
  00132	89 45 f0	 mov	 DWORD PTR _n$2[ebp], eax
  00135	8b 4d ec	 mov	 ecx, DWORD PTR _i$1[ebp]
  00138	83 c1 01	 add	 ecx, 1
  0013b	89 4d ec	 mov	 DWORD PTR _i$1[ebp], ecx
$LN4@gObjCurMov:
  0013e	8b 45 f0	 mov	 eax, DWORD PTR _n$2[ebp]
  00141	3b 45 f8	 cmp	 eax, DWORD PTR _total$[ebp]
  00144	7d 73		 jge	 SHORT $LN3@gObjCurMov

; 23627: 	{
; 23628: 		if( i%2 == 1 ) {

  00146	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00149	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0014e	79 05		 jns	 SHORT $LN11@gObjCurMov
  00150	48		 dec	 eax
  00151	83 c8 fe	 or	 eax, -2			; fffffffeH
  00154	40		 inc	 eax
$LN11@gObjCurMov:
  00155	83 f8 01	 cmp	 eax, 1
  00158	75 24		 jne	 SHORT $LN8@gObjCurMov

; 23629: 			path[(i+1)/2] = (lpObj->PathOri[n]<<4);

  0015a	8b 45 f0	 mov	 eax, DWORD PTR _n$2[ebp]
  0015d	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00160	0f bf 8c 41 32
	01 00 00	 movsx	 ecx, WORD PTR [ecx+eax*2+306]
  00168	c1 e1 04	 shl	 ecx, 4
  0016b	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  0016e	83 c0 01	 add	 eax, 1
  00171	99		 cdq
  00172	2b c2		 sub	 eax, edx
  00174	d1 f8		 sar	 eax, 1
  00176	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  00179	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 23630: 		}

  0017c	eb 36		 jmp	 SHORT $LN9@gObjCurMov
$LN8@gObjCurMov:

; 23631: 		else { 
; 23632: 			path[(i+1)/2] |= (lpObj->PathOri[n]&0x0f);

  0017e	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00181	83 c0 01	 add	 eax, 1
  00184	99		 cdq
  00185	2b c2		 sub	 eax, edx
  00187	d1 f8		 sar	 eax, 1
  00189	8b 4d f0	 mov	 ecx, DWORD PTR _n$2[ebp]
  0018c	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0018f	0f bf 8c 4a 32
	01 00 00	 movsx	 ecx, WORD PTR [edx+ecx*2+306]
  00197	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0019a	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  0019d	0f b6 1c 02	 movzx	 ebx, BYTE PTR [edx+eax]
  001a1	0b d9		 or	 ebx, ecx
  001a3	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  001a6	83 c0 01	 add	 eax, 1
  001a9	99		 cdq
  001aa	2b c2		 sub	 eax, edx
  001ac	d1 f8		 sar	 eax, 1
  001ae	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  001b1	88 1c 01	 mov	 BYTE PTR [ecx+eax], bl
$LN9@gObjCurMov:

; 23633: 		}
; 23634: 	}

  001b4	e9 73 ff ff ff	 jmp	 $LN2@gObjCurMov
$LN3@gObjCurMov:

; 23635: 
; 23636: 	sendbyte += ((path[0]&0x0f)+1)/2;

  001b9	b8 01 00 00 00	 mov	 eax, 1
  001be	6b c8 00	 imul	 ecx, eax, 0
  001c1	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  001c4	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  001c8	83 e0 0f	 and	 eax, 15			; 0000000fH
  001cb	83 c0 01	 add	 eax, 1
  001ce	99		 cdq
  001cf	2b c2		 sub	 eax, edx
  001d1	d1 f8		 sar	 eax, 1
  001d3	03 45 f4	 add	 eax, DWORD PTR _sendbyte$[ebp]
  001d6	89 45 f4	 mov	 DWORD PTR _sendbyte$[ebp], eax

; 23637: 
; 23638: //	LogAddHeadHex(1,(char*)path, 8);
; 23639: //	LogAdd("path[0] : %x sendbyte:%d ",path[0], sendbyte);	
; 23640: 	return sendbyte;

  001d9	8b 45 f4	 mov	 eax, DWORD PTR _sendbyte$[ebp]
$LN1@gObjCurMov:

; 23641: }

  001dc	5f		 pop	 edi
  001dd	5e		 pop	 esi
  001de	5b		 pop	 ebx
  001df	8b e5		 mov	 esp, ebp
  001e1	5d		 pop	 ebp
  001e2	c3		 ret	 0
?gObjCurMoveMake@@YAHQAEPAVOBJECTSTRUCT@@@Z ENDP	; gObjCurMoveMake
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?TestFrustrum2@@YA_NHHH@Z
_TEXT	SEGMENT
_d$1 = -16						; size = 4
_i$2 = -12						; size = 4
_lpObj$ = -8						; size = 4
_j$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_aIndex$ = 16						; size = 4
?TestFrustrum2@@YA_NHHH@Z PROC				; TestFrustrum2, COMDAT

; 20498: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 20499: 	int j = 3;

  00009	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _j$[ebp], 3

; 20500: 	LPOBJECTSTRUCT lpObj=(LPOBJECTSTRUCT)&gObj[aIndex];

  00010	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00017	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0001d	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 20501: 	for(int i=0;i<4;j=i,i++)

  00020	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00027	eb 0f		 jmp	 SHORT $LN4@TestFrustr
$LN2@TestFrustr:
  00029	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  0002c	89 45 fc	 mov	 DWORD PTR _j$[ebp], eax
  0002f	8b 4d f4	 mov	 ecx, DWORD PTR _i$2[ebp]
  00032	83 c1 01	 add	 ecx, 1
  00035	89 4d f4	 mov	 DWORD PTR _i$2[ebp], ecx
$LN4@TestFrustr:
  00038	83 7d f4 04	 cmp	 DWORD PTR _i$2[ebp], 4
  0003c	7d 5e		 jge	 SHORT $LN3@TestFrustr

; 20502: 	{
; 20503: 		int d = (lpObj->FrustrumX[i]-x) * (lpObj->FrustrumY[j]-y) -

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  00041	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00044	8b 94 81 44 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+836]
  0004b	2b 55 08	 sub	 edx, DWORD PTR _x$[ebp]
  0004e	8b 45 fc	 mov	 eax, DWORD PTR _j$[ebp]
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00054	8b 84 81 54 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+852]
  0005b	2b 45 0c	 sub	 eax, DWORD PTR _y$[ebp]
  0005e	0f af d0	 imul	 edx, eax
  00061	8b 4d fc	 mov	 ecx, DWORD PTR _j$[ebp]
  00064	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00067	8b 8c 88 44 03
	00 00		 mov	 ecx, DWORD PTR [eax+ecx*4+836]
  0006e	2b 4d 08	 sub	 ecx, DWORD PTR _x$[ebp]
  00071	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  00074	8b 75 f8	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00077	8b 84 86 54 03
	00 00		 mov	 eax, DWORD PTR [esi+eax*4+852]
  0007e	2b 45 0c	 sub	 eax, DWORD PTR _y$[ebp]
  00081	0f af c8	 imul	 ecx, eax
  00084	2b d1		 sub	 edx, ecx
  00086	89 55 f0	 mov	 DWORD PTR _d$1[ebp], edx

; 20504: 	      		(lpObj->FrustrumX[j]-x) * (lpObj->FrustrumY[i]-y);
; 20505: 		if(d < 0.f) return false;

  00089	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _d$1[ebp]
  0008e	0f 57 c9	 xorps	 xmm1, xmm1
  00091	0f 2f c8	 comiss	 xmm1, xmm0
  00094	76 04		 jbe	 SHORT $LN5@TestFrustr
  00096	32 c0		 xor	 al, al
  00098	eb 04		 jmp	 SHORT $LN1@TestFrustr
$LN5@TestFrustr:

; 20506: 	}

  0009a	eb 8d		 jmp	 SHORT $LN2@TestFrustr
$LN3@TestFrustr:

; 20507: 	return true;

  0009c	b0 01		 mov	 al, 1
$LN1@TestFrustr:

; 20508: }

  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
?TestFrustrum2@@YA_NHHH@Z ENDP				; TestFrustrum2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjAttackDamageCalc@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjAttackDamageCalc@@YAXH@Z PROC			; gObjAttackDamageCalc, COMDAT

; 19626: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19627: 	
; 19628: }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?gObjAttackDamageCalc@@YAXH@Z ENDP			; gObjAttackDamageCalc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?TradeitemInventoryPut@@YAHH@Z
_TEXT	SEGMENT
_n$1 = -76						; size = 4
_ExOption$ = -72					; size = 8
_szItemName$ = -64					; size = 50
_insert$ = -9						; size = 1
_number$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?TradeitemInventoryPut@@YAHH@Z PROC			; TradeitemInventoryPut, COMDAT

; 19368: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 19369: 	int		number;
; 19370: 	BYTE	insert;
; 19371: 	char    szItemName[50]="Item";

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_04BGCMBJDA@Item@
  0001b	89 45 c0	 mov	 DWORD PTR _szItemName$[ebp], eax
  0001e	8a 0d 04 00 00
	00		 mov	 cl, BYTE PTR ??_C@_04BGCMBJDA@Item@+4
  00024	88 4d c4	 mov	 BYTE PTR _szItemName$[ebp+4], cl
  00027	6a 2d		 push	 45			; 0000002dH
  00029	6a 00		 push	 0
  0002b	8d 45 c5	 lea	 eax, DWORD PTR _szItemName$[ebp+5]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _memset
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19372: 	BYTE	ExOption[8];
; 19373: 	
; 19374: 	number = gObj[aIndex].TargetNumber;

  00037	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00044	0f bf 94 01 ac
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+684]
  0004c	89 55 f8	 mov	 DWORD PTR _number$[ebp], edx

; 19375: 	if( gObjIsConnected(number) == FALSE ) return FALSE;

  0004f	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00058	83 c4 04	 add	 esp, 4
  0005b	85 c0		 test	 eax, eax
  0005d	75 07		 jne	 SHORT $LN5@TradeitemI
  0005f	33 c0		 xor	 eax, eax
  00061	e9 15 03 00 00	 jmp	 $LN1@TradeitemI
$LN5@TradeitemI:

; 19376: 	for( int n=0; n<MAX_TRADEITEM; n++)

  00066	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0006d	eb 09		 jmp	 SHORT $LN4@TradeitemI
$LN2@TradeitemI:
  0006f	8b 45 b4	 mov	 eax, DWORD PTR _n$1[ebp]
  00072	83 c0 01	 add	 eax, 1
  00075	89 45 b4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@TradeitemI:
  00078	83 7d b4 20	 cmp	 DWORD PTR _n$1[ebp], 32	; 00000020H
  0007c	0f 8d f4 02 00
	00		 jge	 $LN3@TradeitemI

; 19377: 	{
; 19378: 		//  ..
; 19379: 		if( gObj[number].Trade[n].IsItem() == TRUE )

  00082	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00089	69 4d b4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00090	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00096	03 8c 02 84 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3204]
  0009d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000a2	83 f8 01	 cmp	 eax, 1
  000a5	0f 85 c6 02 00
	00		 jne	 $LN6@TradeitemI

; 19380: 		{
; 19381: 			insert = gObjInventoryInsertItem(aIndex, gObj[number].Trade[n]);

  000ab	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  000b2	69 4d b4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  000b9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bf	8b b4 02 84 0c
	00 00		 mov	 esi, DWORD PTR [edx+eax+3204]
  000c6	03 f1		 add	 esi, ecx
  000c8	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  000ce	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  000d3	8b fc		 mov	 edi, esp
  000d5	f3 a5		 rep movsd
  000d7	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHVCItem@@@Z ; gObjInventoryInsertItem
  000e0	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  000e6	88 45 f7	 mov	 BYTE PTR _insert$[ebp], al

; 19382: 			if( insert != 0xFF )

  000e9	0f b6 45 f7	 movzx	 eax, BYTE PTR _insert$[ebp]
  000ed	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000f2	0f 84 67 02 00
	00		 je	 $LN7@TradeitemI

; 19383: 			{
; 19384: 				strcpy(szItemName, gObj[number].Trade[n].GetName());

  000f8	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  000ff	69 4d b4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00106	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010c	03 8c 02 84 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3204]
  00113	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00118	50		 push	 eax
  00119	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 _strcpy
  00122	83 c4 08	 add	 esp, 8

; 19385: 
; 19386: 				//[%s][%s] Trade Item  Opposite :[%s][%s] (Item:%s/Serial:%d [%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d]
; 19387: 
; 19388: 				ItemIsBufExOption(ExOption, &gObj[number].Trade[n]);

  00125	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0012c	69 4d b4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00133	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00139	03 8c 02 84 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3204]
  00140	51		 push	 ecx
  00141	8d 45 b8	 lea	 eax, DWORD PTR _ExOption$[ebp]
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  0014a	83 c4 08	 add	 esp, 8

; 19389: 
; 19390: 				LogAddTD(lMsg.Get(538), 

  0014d	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00154	69 4d b4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  0015b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00161	8b 84 02 84 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3204]
  00168	0f b6 8c 08 92
	00 00 00	 movzx	 ecx, BYTE PTR [eax+ecx+146]
  00170	51		 push	 ecx
  00171	ba 01 00 00 00	 mov	 edx, 1
  00176	6b c2 06	 imul	 eax, edx, 6
  00179	0f b6 4c 05 b8	 movzx	 ecx, BYTE PTR _ExOption$[ebp+eax]
  0017e	51		 push	 ecx
  0017f	ba 01 00 00 00	 mov	 edx, 1
  00184	6b c2 05	 imul	 eax, edx, 5
  00187	0f b6 4c 05 b8	 movzx	 ecx, BYTE PTR _ExOption$[ebp+eax]
  0018c	51		 push	 ecx
  0018d	ba 01 00 00 00	 mov	 edx, 1
  00192	c1 e2 02	 shl	 edx, 2
  00195	0f b6 44 15 b8	 movzx	 eax, BYTE PTR _ExOption$[ebp+edx]
  0019a	50		 push	 eax
  0019b	b9 01 00 00 00	 mov	 ecx, 1
  001a0	6b d1 03	 imul	 edx, ecx, 3
  001a3	0f b6 44 15 b8	 movzx	 eax, BYTE PTR _ExOption$[ebp+edx]
  001a8	50		 push	 eax
  001a9	b9 01 00 00 00	 mov	 ecx, 1
  001ae	d1 e1		 shl	 ecx, 1
  001b0	0f b6 54 0d b8	 movzx	 edx, BYTE PTR _ExOption$[ebp+ecx]
  001b5	52		 push	 edx
  001b6	b8 01 00 00 00	 mov	 eax, 1
  001bb	c1 e0 00	 shl	 eax, 0
  001be	0f b6 4c 05 b8	 movzx	 ecx, BYTE PTR _ExOption$[ebp+eax]
  001c3	51		 push	 ecx
  001c4	ba 01 00 00 00	 mov	 edx, 1
  001c9	6b c2 00	 imul	 eax, edx, 0
  001cc	0f b6 4c 05 b8	 movzx	 ecx, BYTE PTR _ExOption$[ebp+eax]
  001d1	51		 push	 ecx
  001d2	69 55 f8 a0 1b
	00 00		 imul	 edx, DWORD PTR _number$[ebp], 7072
  001d9	69 45 b4 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  001e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001e6	8b 94 11 84 0c
	00 00		 mov	 edx, DWORD PTR [ecx+edx+3204]
  001ed	0f b6 44 02 7a	 movzx	 eax, BYTE PTR [edx+eax+122]
  001f2	50		 push	 eax
  001f3	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  001fa	69 55 b4 a8 00
	00 00		 imul	 edx, DWORD PTR _n$1[ebp], 168
  00201	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00206	8b 8c 08 84 0c
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+3204]
  0020d	0f b6 54 11 79	 movzx	 edx, BYTE PTR [ecx+edx+121]
  00212	52		 push	 edx
  00213	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0021a	69 4d b4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00221	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00227	8b 84 02 84 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3204]
  0022e	0f b6 4c 08 78	 movzx	 ecx, BYTE PTR [eax+ecx+120]
  00233	51		 push	 ecx
  00234	69 55 f8 a0 1b
	00 00		 imul	 edx, DWORD PTR _number$[ebp], 7072
  0023b	69 45 b4 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00242	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00248	8b 94 11 84 0c
	00 00		 mov	 edx, DWORD PTR [ecx+edx+3204]
  0024f	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00254	50		 push	 eax
  00255	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  0025c	69 55 b4 a8 00
	00 00		 imul	 edx, DWORD PTR _n$1[ebp], 168
  00263	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00268	8b 8c 08 84 0c
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+3204]
  0026f	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  00272	52		 push	 edx
  00273	8d 45 c0	 lea	 eax, DWORD PTR _szItemName$[ebp]
  00276	50		 push	 eax
  00277	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0027e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00284	0f bf 84 0a 06
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx+262]
  0028c	50		 push	 eax
  0028d	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00294	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0029a	0f bf 84 0a 04
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx+260]
  002a2	50		 push	 eax
  002a3	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  002aa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002b0	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  002b8	50		 push	 eax
  002b9	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  002c0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c6	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  002ca	50		 push	 eax
  002cb	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  002d2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002d8	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  002dc	50		 push	 eax
  002dd	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  002e4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ea	0f bf 84 0a 06
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx+262]
  002f2	50		 push	 eax
  002f3	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  002fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00300	0f bf 84 0a 04
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx+260]
  00308	50		 push	 eax
  00309	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  00310	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00316	0f b6 84 0a 09
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+265]
  0031e	50		 push	 eax
  0031f	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  00326	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0032c	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00330	50		 push	 eax
  00331	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  00338	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0033e	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00342	50		 push	 eax
  00343	68 1a 02 00 00	 push	 538			; 0000021aH
  00348	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0034d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00353	50		 push	 eax
  00354	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0035a	83 c4 64	 add	 esp, 100		; 00000064H

; 19391: 					gObj[number].AccountID, gObj[number].Name, 
; 19392: 					gObj[number].MapNumber, gObj[number].X, gObj[number].Y,
; 19393: 					gObj[aIndex].AccountID, gObj[aIndex].Name,
; 19394: 					gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y,
; 19395: 					szItemName, 
; 19396: 					gObj[number].Trade[n].m_Number, 
; 19397: 					gObj[number].Trade[n].m_Level,
; 19398: 					gObj[number].Trade[n].m_Option1, 
; 19399: 					gObj[number].Trade[n].m_Option2, 
; 19400: 					gObj[number].Trade[n].m_Option3,
; 19401: 					ExOption[0],
; 19402: 					ExOption[1],
; 19403: 					ExOption[2],
; 19404: 					ExOption[3],
; 19405: 					ExOption[4],
; 19406: 					ExOption[5],
; 19407: 					ExOption[6],
; 19408: 					gObj[number].Trade[n].m_SetOption
; 19409: #ifdef ADD_SOCKET_OPTION_LOG_02_20080821
; 19410: 					, gObj[number].Trade[n].m_SocketOption[0],
; 19411: 					gObj[number].Trade[n].m_SocketOption[1],
; 19412: 					gObj[number].Trade[n].m_SocketOption[2],
; 19413: 					gObj[number].Trade[n].m_SocketOption[3],
; 19414: 					gObj[number].Trade[n].m_SocketOption[4]
; 19415: #endif // ADD_SOCKET_OPTION_LOG_02_20080821
; 19416: 					);
; 19417: 			}

  0035d	eb 12		 jmp	 SHORT $LN6@TradeitemI
$LN7@TradeitemI:

; 19418: 			else 
; 19419: 			{
; 19420: 				LogAdd("error :  !!");

  0035f	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@ELKLKHDB@error?5?3?5?$MA?L?$LA?G?5?E?$KL?$MA?O?$LD?$KK?$LE?B?$MA?O?$CB?$CB@
  00364	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0036a	83 c4 04	 add	 esp, 4

; 19421: 				return FALSE;

  0036d	33 c0		 xor	 eax, eax
  0036f	eb 0a		 jmp	 SHORT $LN1@TradeitemI
$LN6@TradeitemI:

; 19422: 			}
; 19423: 		}
; 19424: 	}

  00371	e9 f9 fc ff ff	 jmp	 $LN2@TradeitemI
$LN3@TradeitemI:

; 19425: 	return TRUE;

  00376	b8 01 00 00 00	 mov	 eax, 1
$LN1@TradeitemI:

; 19426: }

  0037b	5f		 pop	 edi
  0037c	5e		 pop	 esi
  0037d	5b		 pop	 ebx
  0037e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00381	33 cd		 xor	 ecx, ebp
  00383	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00388	8b e5		 mov	 esp, ebp
  0038a	5d		 pop	 ebp
  0038b	c3		 ret	 0
?TradeitemInventoryPut@@YAHH@Z ENDP			; TradeitemInventoryPut
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjTempInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@VCItem@@PAE@Z
_TEXT	SEGMENT
_blank$ = -17						; size = 1
_iheight$ = -16						; size = 4
_iwidth$ = -12						; size = 4
_h$ = -8						; size = 4
_w$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_item$ = 12						; size = 168
_TempMap$ = 180						; size = 4
?gObjTempInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@VCItem@@PAE@Z PROC ; gObjTempInventoryInsertItem, COMDAT

; 19302: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19303: 	int w, h;
; 19304: 	int iwidth, iheight;
; 19305: 	BYTE blank=0;

  00009	c6 45 ef 00	 mov	 BYTE PTR _blank$[ebp], 0

; 19306: 
; 19307: 	if( item.GetSize(iwidth, iheight) == FALSE )

  0000d	8d 45 f0	 lea	 eax, DWORD PTR _iheight$[ebp]
  00010	50		 push	 eax
  00011	8d 4d f4	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00014	51		 push	 ecx
  00015	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  00018	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  0001d	85 c0		 test	 eax, eax
  0001f	75 35		 jne	 SHORT $LN8@gObjTempIn

; 19308: 	{
; 19309: 		LogAdd(lMsg.Get(532), __FILE__, __LINE__, item.m_Type);

  00021	0f bf 45 12	 movsx	 eax, WORD PTR _item$[ebp+6]
  00025	50		 push	 eax
  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??gObjTempInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@VCItem@@PAE@Z@4JA
  0002c	83 c1 07	 add	 ecx, 7
  0002f	51		 push	 ecx
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00035	68 14 02 00 00	 push	 532			; 00000214H
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00045	50		 push	 eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0004c	83 c4 10	 add	 esp, 16			; 00000010H

; 19310: 		return 0xFF;

  0004f	0c ff		 or	 al, 255			; 000000ffH
  00051	e9 c1 00 00 00	 jmp	 $LN1@gObjTempIn
$LN8@gObjTempIn:

; 19311: 	}
; 19312: 
; 19313: 	for( h=0; h<8; h++)

  00056	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _h$[ebp], 0
  0005d	eb 09		 jmp	 SHORT $LN4@gObjTempIn
$LN2@gObjTempIn:
  0005f	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  00062	83 c0 01	 add	 eax, 1
  00065	89 45 f8	 mov	 DWORD PTR _h$[ebp], eax
$LN4@gObjTempIn:
  00068	83 7d f8 08	 cmp	 DWORD PTR _h$[ebp], 8
  0006c	0f 8d a3 00 00
	00		 jge	 $GOTO_EndFunc$14

; 19314: 	{
; 19315: 		for( w=0; w<8; w++)

  00072	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _w$[ebp], 0
  00079	eb 09		 jmp	 SHORT $LN7@gObjTempIn
$LN5@gObjTempIn:
  0007b	8b 45 fc	 mov	 eax, DWORD PTR _w$[ebp]
  0007e	83 c0 01	 add	 eax, 1
  00081	89 45 fc	 mov	 DWORD PTR _w$[ebp], eax
$LN7@gObjTempIn:
  00084	83 7d fc 08	 cmp	 DWORD PTR _w$[ebp], 8
  00088	0f 8d 82 00 00
	00		 jge	 $LN6@gObjTempIn

; 19316: 		{
; 19317: 			//  
; 19318: 			if( *(TempMap+(h*8)+(w)) == 0xFF )

  0008e	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  00091	8b 8d b4 00 00
	00		 mov	 ecx, DWORD PTR _TempMap$[ebp]
  00097	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  0009a	8b 45 fc	 mov	 eax, DWORD PTR _w$[ebp]
  0009d	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  000a1	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  000a7	75 62		 jne	 SHORT $LN9@gObjTempIn

; 19319: 			{				
; 19320: 				blank = gObjTempInventoryRectCheck(TempMap, w, h, iwidth,iheight);

  000a9	8b 45 f0	 mov	 eax, DWORD PTR _iheight$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d f4	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  000b0	51		 push	 ecx
  000b1	8b 55 f8	 mov	 edx, DWORD PTR _h$[ebp]
  000b4	52		 push	 edx
  000b5	8b 45 fc	 mov	 eax, DWORD PTR _w$[ebp]
  000b8	50		 push	 eax
  000b9	8b 8d b4 00 00
	00		 mov	 ecx, DWORD PTR _TempMap$[ebp]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ?gObjTempInventoryRectCheck@@YAEPAEHHHH@Z ; gObjTempInventoryRectCheck
  000c5	83 c4 14	 add	 esp, 20			; 00000014H
  000c8	88 45 ef	 mov	 BYTE PTR _blank$[ebp], al

; 19321: 				// 
; 19322: 				if( blank == 0xFE ) goto GOTO_EndFunc;

  000cb	0f b6 45 ef	 movzx	 eax, BYTE PTR _blank$[ebp]
  000cf	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  000d4	75 04		 jne	 SHORT $LN10@gObjTempIn
  000d6	eb 3d		 jmp	 SHORT $GOTO_EndFunc$14
  000d8	eb 3b		 jmp	 SHORT $GOTO_EndFunc$14
$LN10@gObjTempIn:

; 19323: 				if( blank != 0xFF )	{	//   

  000da	0f b6 45 ef	 movzx	 eax, BYTE PTR _blank$[ebp]
  000de	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000e3	74 26		 je	 SHORT $LN9@gObjTempIn

; 19324: 					gObjTempInventoryItemBoxSet(TempMap, blank, iwidth, iheight, (BYTE)item.m_Type);

  000e5	0f b6 45 12	 movzx	 eax, BYTE PTR _item$[ebp+6]
  000e9	50		 push	 eax
  000ea	8b 4d f0	 mov	 ecx, DWORD PTR _iheight$[ebp]
  000ed	51		 push	 ecx
  000ee	8b 55 f4	 mov	 edx, DWORD PTR _iwidth$[ebp]
  000f1	52		 push	 edx
  000f2	0f b6 45 ef	 movzx	 eax, BYTE PTR _blank$[ebp]
  000f6	50		 push	 eax
  000f7	8b 8d b4 00 00
	00		 mov	 ecx, DWORD PTR _TempMap$[ebp]
  000fd	51		 push	 ecx
  000fe	e8 00 00 00 00	 call	 ?gObjTempInventoryItemBoxSet@@YAXPAEHHHE@Z ; gObjTempInventoryItemBoxSet
  00103	83 c4 14	 add	 esp, 20			; 00000014H

; 19325: 					return blank;

  00106	8a 45 ef	 mov	 al, BYTE PTR _blank$[ebp]
  00109	eb 0c		 jmp	 SHORT $LN1@gObjTempIn
$LN9@gObjTempIn:

; 19326: 				}			
; 19327: 			}
; 19328: 		}

  0010b	e9 6b ff ff ff	 jmp	 $LN5@gObjTempIn
$LN6@gObjTempIn:

; 19329: 	}

  00110	e9 4a ff ff ff	 jmp	 $LN2@gObjTempIn
$GOTO_EndFunc$14:

; 19330: 
; 19331: GOTO_EndFunc :
; 19332: 	return 0xFF;

  00115	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjTempIn:

; 19333: }

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
?gObjTempInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@VCItem@@PAE@Z ENDP ; gObjTempInventoryInsertItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjTempInventoryRectCheck@@YAEPAEHHHH@Z
_TEXT	SEGMENT
_blank$ = -12						; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_TempMap$ = 8						; size = 4
_sx$ = 12						; size = 4
_sy$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
?gObjTempInventoryRectCheck@@YAEPAEHHHH@Z PROC		; gObjTempInventoryRectCheck, COMDAT

; 19274: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19275: 	int x, y;
; 19276: 	int blank = 0;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _blank$[ebp], 0

; 19277: 
; 19278: 	//     
; 19279: 	if( (sx+width) > 8 ) return (BYTE)0xFF;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  00013	03 45 14	 add	 eax, DWORD PTR _width$[ebp]
  00016	83 f8 08	 cmp	 eax, 8
  00019	7e 07		 jle	 SHORT $LN8@gObjTempIn
  0001b	0c ff		 or	 al, 255			; 000000ffH
  0001d	e9 86 00 00 00	 jmp	 $LN1@gObjTempIn
$LN8@gObjTempIn:

; 19280: 	if( (sy+height) > 8 ) return (BYTE)0xFE;

  00022	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00025	03 45 18	 add	 eax, DWORD PTR _height$[ebp]
  00028	83 f8 08	 cmp	 eax, 8
  0002b	7e 04		 jle	 SHORT $LN9@gObjTempIn
  0002d	b0 fe		 mov	 al, 254			; 000000feH
  0002f	eb 77		 jmp	 SHORT $LN1@gObjTempIn
$LN9@gObjTempIn:

; 19281: 
; 19282: 	for( y=0; y<height; y++)

  00031	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  00038	eb 09		 jmp	 SHORT $LN4@gObjTempIn
$LN2@gObjTempIn:
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  0003d	83 c0 01	 add	 eax, 1
  00040	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
$LN4@gObjTempIn:
  00043	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00046	3b 45 18	 cmp	 eax, DWORD PTR _height$[ebp]
  00049	7d 49		 jge	 SHORT $LN3@gObjTempIn

; 19283: 	{		
; 19284: 		for(x=0; x<width; x++)

  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00052	eb 09		 jmp	 SHORT $LN7@gObjTempIn
$LN5@gObjTempIn:
  00054	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00057	83 c0 01	 add	 eax, 1
  0005a	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$LN7@gObjTempIn:
  0005d	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00060	3b 45 14	 cmp	 eax, DWORD PTR _width$[ebp]
  00063	7d 2d		 jge	 SHORT $LN6@gObjTempIn

; 19285: 		{
; 19286: 			if( *(TempMap+((sy+y)*8)+(sx+x)) != 0xFF ) 

  00065	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00068	03 45 f8	 add	 eax, DWORD PTR _y$[ebp]
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _TempMap$[ebp]
  0006e	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00071	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  00074	03 45 fc	 add	 eax, DWORD PTR _x$[ebp]
  00077	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  0007b	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00081	74 0d		 je	 SHORT $LN10@gObjTempIn

; 19287: 			{
; 19288: 				blank++;

  00083	8b 45 f4	 mov	 eax, DWORD PTR _blank$[ebp]
  00086	83 c0 01	 add	 eax, 1
  00089	89 45 f4	 mov	 DWORD PTR _blank$[ebp], eax

; 19289: 				return (BYTE)0xFF;

  0008c	0c ff		 or	 al, 255			; 000000ffH
  0008e	eb 18		 jmp	 SHORT $LN1@gObjTempIn
$LN10@gObjTempIn:

; 19290: 			}
; 19291: 		}

  00090	eb c2		 jmp	 SHORT $LN5@gObjTempIn
$LN6@gObjTempIn:

; 19292: 	}

  00092	eb a6		 jmp	 SHORT $LN2@gObjTempIn
$LN3@gObjTempIn:

; 19293: 
; 19294: 	if( blank == 0 ) return (BYTE)(MAX_EQUIPMENT+((sy*8)+sx));

  00094	83 7d f4 00	 cmp	 DWORD PTR _blank$[ebp], 0
  00098	75 0c		 jne	 SHORT $LN11@gObjTempIn
  0009a	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  0009d	8b 4d 0c	 mov	 ecx, DWORD PTR _sx$[ebp]
  000a0	8d 44 c1 0c	 lea	 eax, DWORD PTR [ecx+eax*8+12]
  000a4	eb 02		 jmp	 SHORT $LN1@gObjTempIn
$LN11@gObjTempIn:

; 19295: 
; 19296: 	return (BYTE)0xFF;

  000a6	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjTempIn:

; 19297: }

  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	5b		 pop	 ebx
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
?gObjTempInventoryRectCheck@@YAEPAEHHHH@Z ENDP		; gObjTempInventoryRectCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjTempInventoryItemBoxSet@@YAXPAEHHHE@Z
_TEXT	SEGMENT
_x$1 = -16						; size = 4
_y$2 = -12						; size = 4
_itemposy$ = -8						; size = 4
_itemposx$ = -4						; size = 4
_TempMap$ = 8						; size = 4
_itempos$ = 12						; size = 4
_xl$ = 16						; size = 4
_yl$ = 20						; size = 4
_set_byte$ = 24						; size = 1
?gObjTempInventoryItemBoxSet@@YAXPAEHHHE@Z PROC		; gObjTempInventoryItemBoxSet, COMDAT

; 19256: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19257: 	int itemposx, itemposy;
; 19258: 
; 19259: 	itemposx = (itempos-MAX_EQUIPMENT)%8;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  0000c	83 e8 0c	 sub	 eax, 12			; 0000000cH
  0000f	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00014	79 05		 jns	 SHORT $LN9@gObjTempIn
  00016	48		 dec	 eax
  00017	83 c8 f8	 or	 eax, -8			; fffffff8H
  0001a	40		 inc	 eax
$LN9@gObjTempIn:
  0001b	89 45 fc	 mov	 DWORD PTR _itemposx$[ebp], eax

; 19260: 	itemposy = (itempos-MAX_EQUIPMENT)/8;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  00021	83 e8 0c	 sub	 eax, 12			; 0000000cH
  00024	99		 cdq
  00025	83 e2 07	 and	 edx, 7
  00028	03 c2		 add	 eax, edx
  0002a	c1 f8 03	 sar	 eax, 3
  0002d	89 45 f8	 mov	 DWORD PTR _itemposy$[ebp], eax

; 19261: 
; 19262: 	for( int y=0; y<yl; y++)

  00030	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@gObjTempIn
$LN2@gObjTempIn:
  00039	8b 45 f4	 mov	 eax, DWORD PTR _y$2[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f4	 mov	 DWORD PTR _y$2[ebp], eax
$LN4@gObjTempIn:
  00042	8b 45 f4	 mov	 eax, DWORD PTR _y$2[ebp]
  00045	3b 45 14	 cmp	 eax, DWORD PTR _yl$[ebp]
  00048	7d 36		 jge	 SHORT $LN1@gObjTempIn

; 19263: 	{
; 19264: 		for( int x=0; x<xl; x++)

  0004a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _x$1[ebp], 0
  00051	eb 09		 jmp	 SHORT $LN7@gObjTempIn
$LN5@gObjTempIn:
  00053	8b 45 f0	 mov	 eax, DWORD PTR _x$1[ebp]
  00056	83 c0 01	 add	 eax, 1
  00059	89 45 f0	 mov	 DWORD PTR _x$1[ebp], eax
$LN7@gObjTempIn:
  0005c	8b 45 f0	 mov	 eax, DWORD PTR _x$1[ebp]
  0005f	3b 45 10	 cmp	 eax, DWORD PTR _xl$[ebp]
  00062	7d 1a		 jge	 SHORT $LN6@gObjTempIn

; 19265: 		{
; 19266: 			*(TempMap+((itemposy+y)*8)+(itemposx+x)) = set_byte;

  00064	8b 45 f8	 mov	 eax, DWORD PTR _itemposy$[ebp]
  00067	03 45 f4	 add	 eax, DWORD PTR _y$2[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _TempMap$[ebp]
  0006d	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00070	8b 45 fc	 mov	 eax, DWORD PTR _itemposx$[ebp]
  00073	03 45 f0	 add	 eax, DWORD PTR _x$1[ebp]
  00076	8a 4d 18	 mov	 cl, BYTE PTR _set_byte$[ebp]
  00079	88 0c 02	 mov	 BYTE PTR [edx+eax], cl

; 19267: 		}

  0007c	eb d5		 jmp	 SHORT $LN5@gObjTempIn
$LN6@gObjTempIn:

; 19268: 	}

  0007e	eb b9		 jmp	 SHORT $LN2@gObjTempIn
$LN1@gObjTempIn:

; 19269: }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
?gObjTempInventoryItemBoxSet@@YAXPAEHHHE@Z ENDP		; gObjTempInventoryItemBoxSet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjTradeItemBoxSet@@YAHHHHHE@Z
_TEXT	SEGMENT
_x$1 = -24						; size = 4
_y$2 = -20						; size = 4
_yy$ = -16						; size = 4
_xx$ = -12						; size = 4
_itemposy$ = -8						; size = 4
_itemposx$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_itempos$ = 12						; size = 4
_xl$ = 16						; size = 4
_yl$ = 20						; size = 4
_set_byte$ = 24						; size = 1
?gObjTradeItemBoxSet@@YAHHHHHE@Z PROC			; gObjTradeItemBoxSet, COMDAT

; 18581: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 18582: 	int itemposx, itemposy;
; 18583: 	int xx, yy;
; 18584: 
; 18585: 	itemposx = itempos%8;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  0000c	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00011	79 05		 jns	 SHORT $LN11@gObjTradeI
  00013	48		 dec	 eax
  00014	83 c8 f8	 or	 eax, -8			; fffffff8H
  00017	40		 inc	 eax
$LN11@gObjTradeI:
  00018	89 45 fc	 mov	 DWORD PTR _itemposx$[ebp], eax

; 18586: 	itemposy = itempos/8;

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  0001e	99		 cdq
  0001f	83 e2 07	 and	 edx, 7
  00022	03 c2		 add	 eax, edx
  00024	c1 f8 03	 sar	 eax, 3
  00027	89 45 f8	 mov	 DWORD PTR _itemposy$[ebp], eax

; 18587: 
; 18588: 	for( int y=0; y<yl; y++)

  0002a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  00031	eb 09		 jmp	 SHORT $LN4@gObjTradeI
$LN2@gObjTradeI:
  00033	8b 45 ec	 mov	 eax, DWORD PTR _y$2[ebp]
  00036	83 c0 01	 add	 eax, 1
  00039	89 45 ec	 mov	 DWORD PTR _y$2[ebp], eax
$LN4@gObjTradeI:
  0003c	8b 45 ec	 mov	 eax, DWORD PTR _y$2[ebp]
  0003f	3b 45 14	 cmp	 eax, DWORD PTR _yl$[ebp]
  00042	0f 8d 91 00 00
	00		 jge	 $LN3@gObjTradeI

; 18589: 	{
; 18590: 		yy = itemposy+y;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _itemposy$[ebp]
  0004b	03 45 ec	 add	 eax, DWORD PTR _y$2[ebp]
  0004e	89 45 f0	 mov	 DWORD PTR _yy$[ebp], eax

; 18591: 		for( int x=0; x<xl; x++)

  00051	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _x$1[ebp], 0
  00058	eb 09		 jmp	 SHORT $LN7@gObjTradeI
$LN5@gObjTradeI:
  0005a	8b 45 e8	 mov	 eax, DWORD PTR _x$1[ebp]
  0005d	83 c0 01	 add	 eax, 1
  00060	89 45 e8	 mov	 DWORD PTR _x$1[ebp], eax
$LN7@gObjTradeI:
  00063	8b 45 e8	 mov	 eax, DWORD PTR _x$1[ebp]
  00066	3b 45 10	 cmp	 eax, DWORD PTR _xl$[ebp]
  00069	7d 69		 jge	 SHORT $LN6@gObjTradeI

; 18592: 		{
; 18593: 			xx = itemposx+x;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _itemposx$[ebp]
  0006e	03 45 e8	 add	 eax, DWORD PTR _x$1[ebp]
  00071	89 45 f4	 mov	 DWORD PTR _xx$[ebp], eax

; 18594: 
; 18595: 			if( ExtentCheck(xx, yy, 8, 4) == TRUE )

  00074	6a 04		 push	 4
  00076	6a 08		 push	 8
  00078	8b 45 f0	 mov	 eax, DWORD PTR _yy$[ebp]
  0007b	50		 push	 eax
  0007c	8b 4d f4	 mov	 ecx, DWORD PTR _xx$[ebp]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  00085	83 c4 10	 add	 esp, 16			; 00000010H
  00088	83 f8 01	 cmp	 eax, 1
  0008b	75 25		 jne	 SHORT $LN8@gObjTradeI

; 18596: 			{
; 18597: 				*(gObj[aIndex].TradeMap+(yy*8)+xx) = set_byte;

  0008d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00094	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009a	8b 94 01 88 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3208]
  000a1	8b 45 f0	 mov	 eax, DWORD PTR _yy$[ebp]
  000a4	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  000a7	8b 55 f4	 mov	 edx, DWORD PTR _xx$[ebp]
  000aa	8a 45 18	 mov	 al, BYTE PTR _set_byte$[ebp]
  000ad	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 18598: 			}

  000b0	eb 20		 jmp	 SHORT $LN9@gObjTradeI
$LN8@gObjTradeI:

; 18599: 			else
; 18600: 			{
; 18601: 				LogAdd("error : %s %d",__FILE__, __LINE__);

  000b2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjTradeItemBoxSet@@YAHHHHHE@Z@4JA
  000b7	83 c0 14	 add	 eax, 20			; 00000014H
  000ba	50		 push	 eax
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18602: 				return FALSE;

  000ce	33 c0		 xor	 eax, eax
  000d0	eb 0c		 jmp	 SHORT $LN1@gObjTradeI
$LN9@gObjTradeI:

; 18603: 			}
; 18604: 		}

  000d2	eb 86		 jmp	 SHORT $LN5@gObjTradeI
$LN6@gObjTradeI:

; 18605: 	}

  000d4	e9 5a ff ff ff	 jmp	 $LN2@gObjTradeI
$LN3@gObjTradeI:

; 18606: 	return TRUE;

  000d9	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjTradeI:

; 18607: }

  000de	5f		 pop	 edi
  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c3		 ret	 0
?gObjTradeItemBoxSet@@YAHHHHHE@Z ENDP			; gObjTradeItemBoxSet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjTradeRectCheck@@YAEHHHHH@Z
_TEXT	SEGMENT
_yy$ = -20						; size = 4
_xx$ = -16						; size = 4
_blank$ = -12						; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_sx$ = 12						; size = 4
_sy$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
?gObjTradeRectCheck@@YAEHHHHH@Z PROC			; gObjTradeRectCheck, COMDAT

; 18537: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 18538: 	int x, y;
; 18539: 	int blank = 0;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _blank$[ebp], 0

; 18540: 
; 18541: 	//     
; 18542: 	if( (sx+width) > 8 ) return (BYTE)0xFF;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  00013	03 45 14	 add	 eax, DWORD PTR _width$[ebp]
  00016	83 f8 08	 cmp	 eax, 8
  00019	7e 07		 jle	 SHORT $LN8@gObjTradeR
  0001b	0c ff		 or	 al, 255			; 000000ffH
  0001d	e9 e9 00 00 00	 jmp	 $LN1@gObjTradeR
$LN8@gObjTradeR:

; 18543: 	if( (sy+height) > 4 ) return (BYTE)0xFF;

  00022	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00025	03 45 18	 add	 eax, DWORD PTR _height$[ebp]
  00028	83 f8 04	 cmp	 eax, 4
  0002b	7e 07		 jle	 SHORT $LN9@gObjTradeR
  0002d	0c ff		 or	 al, 255			; 000000ffH
  0002f	e9 d7 00 00 00	 jmp	 $LN1@gObjTradeR
$LN9@gObjTradeR:

; 18544: 	
; 18545: 	int xx, yy;
; 18546: 
; 18547: 	
; 18548: 	for( y=0; y<height; y++)

  00034	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  0003b	eb 09		 jmp	 SHORT $LN4@gObjTradeR
$LN2@gObjTradeR:
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
$LN4@gObjTradeR:
  00046	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00049	3b 45 18	 cmp	 eax, DWORD PTR _height$[ebp]
  0004c	0f 8d a6 00 00
	00		 jge	 $LN3@gObjTradeR

; 18549: 	{		
; 18550: 		yy = sy+y;

  00052	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00055	03 45 f8	 add	 eax, DWORD PTR _y$[ebp]
  00058	89 45 ec	 mov	 DWORD PTR _yy$[ebp], eax

; 18551: 		for(x=0; x<width; x++)

  0005b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00062	eb 09		 jmp	 SHORT $LN7@gObjTradeR
$LN5@gObjTradeR:
  00064	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$LN7@gObjTradeR:
  0006d	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00070	3b 45 14	 cmp	 eax, DWORD PTR _width$[ebp]
  00073	7d 7e		 jge	 SHORT $LN6@gObjTradeR

; 18552: 		{
; 18553: 			xx = sx+x;

  00075	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  00078	03 45 fc	 add	 eax, DWORD PTR _x$[ebp]
  0007b	89 45 f0	 mov	 DWORD PTR _xx$[ebp], eax

; 18554: 			if( ExtentCheck(xx, yy, 8, 4) == TRUE)

  0007e	6a 04		 push	 4
  00080	6a 08		 push	 8
  00082	8b 45 ec	 mov	 eax, DWORD PTR _yy$[ebp]
  00085	50		 push	 eax
  00086	8b 4d f0	 mov	 ecx, DWORD PTR _xx$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  0008f	83 c4 10	 add	 esp, 16			; 00000010H
  00092	83 f8 01	 cmp	 eax, 1
  00095	75 37		 jne	 SHORT $LN10@gObjTradeR

; 18555: 			{
; 18556: 				//*(gObj[aIndex].pWarehouseMap+((itemposy+y)*8)+(itemposx+x)) = set_byte;
; 18557: 
; 18558: 				if( *(gObj[aIndex].TradeMap+(yy*8)+xx) != 0xFF ) 

  00097	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0009e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a4	8b 94 01 88 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3208]
  000ab	8b 45 ec	 mov	 eax, DWORD PTR _yy$[ebp]
  000ae	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  000b1	8b 55 f0	 mov	 edx, DWORD PTR _xx$[ebp]
  000b4	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  000b8	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000bd	74 0d		 je	 SHORT $LN12@gObjTradeR

; 18559: 				{
; 18560: 					blank++;

  000bf	8b 45 f4	 mov	 eax, DWORD PTR _blank$[ebp]
  000c2	83 c0 01	 add	 eax, 1
  000c5	89 45 f4	 mov	 DWORD PTR _blank$[ebp], eax

; 18561: 					return (BYTE)0xFF;

  000c8	0c ff		 or	 al, 255			; 000000ffH
  000ca	eb 3f		 jmp	 SHORT $LN1@gObjTradeR
$LN12@gObjTradeR:

; 18562: 				}
; 18563: 			}

  000cc	eb 20		 jmp	 SHORT $LN11@gObjTradeR
$LN10@gObjTradeR:

; 18564: 			else
; 18565: 			{
; 18566: 				LogAdd("error : %s %d", __FILE__, __LINE__);

  000ce	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjTradeRectCheck@@YAEHHHHH@Z@4JA
  000d3	83 c0 1d	 add	 eax, 29			; 0000001dH
  000d6	50		 push	 eax
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000e7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18567: 				return (BYTE)0xFF;

  000ea	0c ff		 or	 al, 255			; 000000ffH
  000ec	eb 1d		 jmp	 SHORT $LN1@gObjTradeR
$LN11@gObjTradeR:

; 18568: 			}
; 18569: 		}

  000ee	e9 71 ff ff ff	 jmp	 $LN5@gObjTradeR
$LN6@gObjTradeR:

; 18570: 	}

  000f3	e9 45 ff ff ff	 jmp	 $LN2@gObjTradeR
$LN3@gObjTradeR:

; 18571: 
; 18572: 	if( blank == 0 ) return (BYTE)((sy*8)+sx);

  000f8	83 7d f4 00	 cmp	 DWORD PTR _blank$[ebp], 0
  000fc	75 0b		 jne	 SHORT $LN13@gObjTradeR
  000fe	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00101	8b 4d 0c	 mov	 ecx, DWORD PTR _sx$[ebp]
  00104	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00107	eb 02		 jmp	 SHORT $LN1@gObjTradeR
$LN13@gObjTradeR:

; 18573: 	
; 18574: 	return (BYTE)(0xFF);

  00109	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjTradeR:

; 18575: }

  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
?gObjTradeRectCheck@@YAEHHHHH@Z ENDP			; gObjTradeRectCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjWarehouseSearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z
_TEXT	SEGMENT
_n$ = -12						; size = 4
_count$ = -8						; size = 4
_s_num$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_sirial$ = 12						; size = 4
?gObjWarehouseSearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z PROC ; gObjWarehouseSearchSerialNumber, COMDAT

; 16722: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 16723: 	DWORD s_num;
; 16724: 	int   count=0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 16725: 	int   n;
; 16726: 
; 16727: #if (TESTSERVER==1)
; 16728: 	#if (LOCALCONNECT==1)
; 16729: 		return TRUE;
; 16730: 	#endif
; 16731: #endif
; 16732: 
; 16733: 	if(gItemSerialCheck==FALSE) return TRUE;

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gItemSerialCheck@@3HA, 0 ; gItemSerialCheck
  00017	75 0a		 jne	 SHORT $LN8@gObjWareho
  00019	b8 01 00 00 00	 mov	 eax, 1
  0001e	e9 27 01 00 00	 jmp	 $LN1@gObjWareho
$LN8@gObjWareho:

; 16734: 
; 16735: 	if( sirial == 0 ) return TRUE;

  00023	83 7d 0c 00	 cmp	 DWORD PTR _sirial$[ebp], 0
  00027	75 0a		 jne	 SHORT $LN9@gObjWareho
  00029	b8 01 00 00 00	 mov	 eax, 1
  0002e	e9 17 01 00 00	 jmp	 $LN1@gObjWareho
$LN9@gObjWareho:

; 16736: 
; 16737: 	for( n=0; n<MAX_WAREHOUSEITEMS; n++)

  00033	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  0003a	eb 09		 jmp	 SHORT $LN4@gObjWareho
$LN2@gObjWareho:
  0003c	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  0003f	83 c0 01	 add	 eax, 1
  00042	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjWareho:
  00045	83 7d f4 78	 cmp	 DWORD PTR _n$[ebp], 120	; 00000078H
  00049	7d 31		 jge	 SHORT $LN3@gObjWareho

; 16738: 	{
; 16739: 		s_num = lpObj->pWarehouse[n].GetNumber();

  0004b	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 168
  00052	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00055	03 88 94 0c 00
	00		 add	 ecx, DWORD PTR [eax+3220]
  0005b	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  00060	89 45 fc	 mov	 DWORD PTR _s_num$[ebp], eax

; 16740: 
; 16741: 		if( s_num != 0 && s_num == sirial )	// 0      

  00063	83 7d fc 00	 cmp	 DWORD PTR _s_num$[ebp], 0
  00067	74 11		 je	 SHORT $LN10@gObjWareho
  00069	8b 45 fc	 mov	 eax, DWORD PTR _s_num$[ebp]
  0006c	3b 45 0c	 cmp	 eax, DWORD PTR _sirial$[ebp]
  0006f	75 09		 jne	 SHORT $LN10@gObjWareho

; 16742: 		{			
; 16743: 			count++;

  00071	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00074	83 c0 01	 add	 eax, 1
  00077	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN10@gObjWareho:

; 16744: 		}
; 16745: 	}

  0007a	eb c0		 jmp	 SHORT $LN2@gObjWareho
$LN3@gObjWareho:

; 16746: 	
; 16747: 	if( count <= 1 ) return TRUE;

  0007c	83 7d f8 01	 cmp	 DWORD PTR _count$[ebp], 1
  00080	7f 0a		 jg	 SHORT $LN11@gObjWareho
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	e9 be 00 00 00	 jmp	 $LN1@gObjWareho
$LN11@gObjWareho:

; 16748: 	
; 16749: 	for( n=0; n<MAX_WAREHOUSEITEMS; n++)

  0008c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00093	eb 09		 jmp	 SHORT $LN7@gObjWareho
$LN5@gObjWareho:
  00095	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00098	83 c0 01	 add	 eax, 1
  0009b	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
$LN7@gObjWareho:
  0009e	83 7d f4 78	 cmp	 DWORD PTR _n$[ebp], 120	; 00000078H
  000a2	0f 8d a0 00 00
	00		 jge	 $LN6@gObjWareho

; 16750: 	{
; 16751: 		s_num = lpObj->pWarehouse[n].GetNumber();

  000a8	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 168
  000af	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b2	03 88 94 0c 00
	00		 add	 ecx, DWORD PTR [eax+3220]
  000b8	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  000bd	89 45 fc	 mov	 DWORD PTR _s_num$[ebp], eax

; 16752: 		if( s_num != 0 && s_num == sirial )	// 0      

  000c0	83 7d fc 00	 cmp	 DWORD PTR _s_num$[ebp], 0
  000c4	74 7d		 je	 SHORT $LN12@gObjWareho
  000c6	8b 45 fc	 mov	 eax, DWORD PTR _s_num$[ebp]
  000c9	3b 45 0c	 cmp	 eax, DWORD PTR _sirial$[ebp]
  000cc	75 75		 jne	 SHORT $LN12@gObjWareho

; 16753: 		{
; 16754: 			LogAddTD(lMsg.Get(530), lpObj->AccountID, lpObj->Name, lpObj->pWarehouse[n].GetName(), n, s_num);

  000ce	8b 45 fc	 mov	 eax, DWORD PTR _s_num$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  000d5	51		 push	 ecx
  000d6	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 168
  000dd	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e0	03 8a 94 0c 00
	00		 add	 ecx, DWORD PTR [edx+3220]
  000e6	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000eb	50		 push	 eax
  000ec	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ef	83 c0 73	 add	 eax, 115		; 00000073H
  000f2	50		 push	 eax
  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000f6	83 c1 68	 add	 ecx, 104		; 00000068H
  000f9	51		 push	 ecx
  000fa	68 12 02 00 00	 push	 530			; 00000212H
  000ff	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0010a	50		 push	 eax
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00111	83 c4 18	 add	 esp, 24			; 00000018H

; 16755: //			LogAddC(LOGC_RED, lMsg.Get(530), lpObj->AccountID, lpObj->Name, lpObj->pWarehouse[n].GetName(), n, s_num);
; 16756: 			GCServerMsgStringSend(lMsg.Get(1102), lpObj->m_Index, 1);

  00114	6a 01		 push	 1
  00116	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00119	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011b	51		 push	 ecx
  0011c	68 4e 04 00 00	 push	 1102			; 0000044eH
  00121	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16757: 			gObjUserKill(lpObj->m_Index);

  00135	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00138	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013a	51		 push	 ecx
  0013b	e8 00 00 00 00	 call	 ?gObjUserKill@@YAXH@Z	; gObjUserKill
  00140	83 c4 04	 add	 esp, 4
$LN12@gObjWareho:

; 16758: 			//gObjInventoryDeleteItem(lpObj->m_Index, n);
; 16759: 			/*ItemMovePathSave(lpObj->AccountID, lpObj->Name, lpObj->pInventory[n].m_Level, lpObj->MapNumber, 
; 16760: 						lpObj->X, lpObj->Y, lpObj->pInventory[n].GetName(), 
; 16761: 						lpObj->pInventory[n].m_Option1, 
; 16762: 						lpObj->pInventory[n].m_Option2,
; 16763: 						lpObj->pInventory[n].m_Option3, 
; 16764: 						lpObj->pInventory[n].m_sirial);*/
; 16765: 		}
; 16766: 	}

  00143	e9 4d ff ff ff	 jmp	 $LN5@gObjWareho
$LN6@gObjWareho:

; 16767: 	return FALSE;

  00148	33 c0		 xor	 eax, eax
$LN1@gObjWareho:

; 16768: }

  0014a	5f		 pop	 edi
  0014b	5e		 pop	 esi
  0014c	5b		 pop	 ebx
  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c3		 ret	 0
?gObjWarehouseSearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z ENDP ; gObjWarehouseSearchSerialNumber
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjChaosItemBoxSet@@YAXHHHHE@Z
_TEXT	SEGMENT
_x$1 = -24						; size = 4
_y$2 = -20						; size = 4
_yy$ = -16						; size = 4
_xx$ = -12						; size = 4
_itemposy$ = -8						; size = 4
_itemposx$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_itempos$ = 12						; size = 4
_xl$ = 16						; size = 4
_yl$ = 20						; size = 4
_set_byte$ = 24						; size = 1
?gObjChaosItemBoxSet@@YAXHHHHE@Z PROC			; gObjChaosItemBoxSet, COMDAT

; 16336: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 16337: 	int itemposx, itemposy;
; 16338: 	int xx, yy;
; 16339: 
; 16340: 	itemposx = itempos%8;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  0000c	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00011	79 05		 jns	 SHORT $LN11@gObjChaosI
  00013	48		 dec	 eax
  00014	83 c8 f8	 or	 eax, -8			; fffffff8H
  00017	40		 inc	 eax
$LN11@gObjChaosI:
  00018	89 45 fc	 mov	 DWORD PTR _itemposx$[ebp], eax

; 16341: 	itemposy = itempos/8;

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  0001e	99		 cdq
  0001f	83 e2 07	 and	 edx, 7
  00022	03 c2		 add	 eax, edx
  00024	c1 f8 03	 sar	 eax, 3
  00027	89 45 f8	 mov	 DWORD PTR _itemposy$[ebp], eax

; 16342: 
; 16343: 	for( int y=0; y<yl; y++)

  0002a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  00031	eb 09		 jmp	 SHORT $LN4@gObjChaosI
$LN2@gObjChaosI:
  00033	8b 45 ec	 mov	 eax, DWORD PTR _y$2[ebp]
  00036	83 c0 01	 add	 eax, 1
  00039	89 45 ec	 mov	 DWORD PTR _y$2[ebp], eax
$LN4@gObjChaosI:
  0003c	8b 45 ec	 mov	 eax, DWORD PTR _y$2[ebp]
  0003f	3b 45 14	 cmp	 eax, DWORD PTR _yl$[ebp]
  00042	0f 8d a0 00 00
	00		 jge	 $LN1@gObjChaosI

; 16344: 	{
; 16345: 		yy = itemposy+y;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _itemposy$[ebp]
  0004b	03 45 ec	 add	 eax, DWORD PTR _y$2[ebp]
  0004e	89 45 f0	 mov	 DWORD PTR _yy$[ebp], eax

; 16346: 		for( int x=0; x<xl; x++)

  00051	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _x$1[ebp], 0
  00058	eb 09		 jmp	 SHORT $LN7@gObjChaosI
$LN5@gObjChaosI:
  0005a	8b 45 e8	 mov	 eax, DWORD PTR _x$1[ebp]
  0005d	83 c0 01	 add	 eax, 1
  00060	89 45 e8	 mov	 DWORD PTR _x$1[ebp], eax
$LN7@gObjChaosI:
  00063	8b 45 e8	 mov	 eax, DWORD PTR _x$1[ebp]
  00066	3b 45 10	 cmp	 eax, DWORD PTR _xl$[ebp]
  00069	7d 78		 jge	 SHORT $LN6@gObjChaosI

; 16347: 		{
; 16348: 			xx = itemposx+x;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _itemposx$[ebp]
  0006e	03 45 e8	 add	 eax, DWORD PTR _x$1[ebp]
  00071	89 45 f4	 mov	 DWORD PTR _xx$[ebp], eax

; 16349: 			if( ExtentCheck(xx, yy, 8, 4) == TRUE )

  00074	6a 04		 push	 4
  00076	6a 08		 push	 8
  00078	8b 45 f0	 mov	 eax, DWORD PTR _yy$[ebp]
  0007b	50		 push	 eax
  0007c	8b 4d f4	 mov	 ecx, DWORD PTR _xx$[ebp]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  00085	83 c4 10	 add	 esp, 16			; 00000010H
  00088	83 f8 01	 cmp	 eax, 1
  0008b	75 2b		 jne	 SHORT $LN8@gObjChaosI

; 16350: 			{
; 16351: 				*(gObj[aIndex].pChaosBoxMap+((itemposy+y)*8)+(itemposx+x)) = set_byte;

  0008d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00094	8b 4d f8	 mov	 ecx, DWORD PTR _itemposy$[ebp]
  00097	03 4d ec	 add	 ecx, DWORD PTR _y$2[ebp]
  0009a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a0	8b 84 02 b0 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3248]
  000a7	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  000aa	8b 55 fc	 mov	 edx, DWORD PTR _itemposx$[ebp]
  000ad	03 55 e8	 add	 edx, DWORD PTR _x$1[ebp]
  000b0	8a 45 18	 mov	 al, BYTE PTR _set_byte$[ebp]
  000b3	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 16352: 			}

  000b6	eb 26		 jmp	 SHORT $LN9@gObjChaosI
$LN8@gObjChaosI:

; 16353: 			else {
; 16354: 				LogAdd("error : %d/%d  %s %d",xx,yy,__FILE__, __LINE__);

  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjChaosItemBoxSet@@YAXHHHHE@Z@4JA
  000bd	83 c0 12	 add	 eax, 18			; 00000012H
  000c0	50		 push	 eax
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000c6	8b 4d f0	 mov	 ecx, DWORD PTR _yy$[ebp]
  000c9	51		 push	 ecx
  000ca	8b 55 f4	 mov	 edx, DWORD PTR _xx$[ebp]
  000cd	52		 push	 edx
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PBCPKOJP@error?5?3?5?$CFd?1?$CFd?5?5?$CFs?5?$CFd@
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d9	83 c4 14	 add	 esp, 20			; 00000014H

; 16355: 				return;

  000dc	eb 0a		 jmp	 SHORT $LN1@gObjChaosI
$LN9@gObjChaosI:

; 16356: 			}
; 16357: 		}

  000de	e9 77 ff ff ff	 jmp	 $LN5@gObjChaosI
$LN6@gObjChaosI:

; 16358: 	}

  000e3	e9 4b ff ff ff	 jmp	 $LN2@gObjChaosI
$LN1@gObjChaosI:

; 16359: }

  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	5b		 pop	 ebx
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
?gObjChaosItemBoxSet@@YAXHHHHE@Z ENDP			; gObjChaosItemBoxSet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjWarehouseItemBoxSet@@YAXHHHHE@Z
_TEXT	SEGMENT
_x$1 = -24						; size = 4
_y$2 = -20						; size = 4
_yy$ = -16						; size = 4
_xx$ = -12						; size = 4
_itemposy$ = -8						; size = 4
_itemposx$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_itempos$ = 12						; size = 4
_xl$ = 16						; size = 4
_yl$ = 20						; size = 4
_set_byte$ = 24						; size = 1
?gObjWarehouseItemBoxSet@@YAXHHHHE@Z PROC		; gObjWarehouseItemBoxSet, COMDAT

; 16291: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 16292: 	int itemposx, itemposy;
; 16293: 	int xx, yy;
; 16294: 
; 16295: 	itemposx = itempos%8;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  0000c	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00011	79 05		 jns	 SHORT $LN11@gObjWareho
  00013	48		 dec	 eax
  00014	83 c8 f8	 or	 eax, -8			; fffffff8H
  00017	40		 inc	 eax
$LN11@gObjWareho:
  00018	89 45 fc	 mov	 DWORD PTR _itemposx$[ebp], eax

; 16296: 	itemposy = itempos/8;

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  0001e	99		 cdq
  0001f	83 e2 07	 and	 edx, 7
  00022	03 c2		 add	 eax, edx
  00024	c1 f8 03	 sar	 eax, 3
  00027	89 45 f8	 mov	 DWORD PTR _itemposy$[ebp], eax

; 16297: 
; 16298: 	for( int y=0; y<yl; y++)

  0002a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  00031	eb 09		 jmp	 SHORT $LN4@gObjWareho
$LN2@gObjWareho:
  00033	8b 45 ec	 mov	 eax, DWORD PTR _y$2[ebp]
  00036	83 c0 01	 add	 eax, 1
  00039	89 45 ec	 mov	 DWORD PTR _y$2[ebp], eax
$LN4@gObjWareho:
  0003c	8b 45 ec	 mov	 eax, DWORD PTR _y$2[ebp]
  0003f	3b 45 14	 cmp	 eax, DWORD PTR _yl$[ebp]
  00042	0f 8d a0 00 00
	00		 jge	 $LN1@gObjWareho

; 16299: 	{
; 16300: 		yy = itemposy+y;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _itemposy$[ebp]
  0004b	03 45 ec	 add	 eax, DWORD PTR _y$2[ebp]
  0004e	89 45 f0	 mov	 DWORD PTR _yy$[ebp], eax

; 16301: 		for( int x=0; x<xl; x++)

  00051	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _x$1[ebp], 0
  00058	eb 09		 jmp	 SHORT $LN7@gObjWareho
$LN5@gObjWareho:
  0005a	8b 45 e8	 mov	 eax, DWORD PTR _x$1[ebp]
  0005d	83 c0 01	 add	 eax, 1
  00060	89 45 e8	 mov	 DWORD PTR _x$1[ebp], eax
$LN7@gObjWareho:
  00063	8b 45 e8	 mov	 eax, DWORD PTR _x$1[ebp]
  00066	3b 45 10	 cmp	 eax, DWORD PTR _xl$[ebp]
  00069	7d 78		 jge	 SHORT $LN6@gObjWareho

; 16302: 		{
; 16303: 			xx = itemposx+x;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _itemposx$[ebp]
  0006e	03 45 e8	 add	 eax, DWORD PTR _x$1[ebp]
  00071	89 45 f4	 mov	 DWORD PTR _xx$[ebp], eax

; 16304: 			if( ExtentCheck(xx, yy, 8, 15) == TRUE )

  00074	6a 0f		 push	 15			; 0000000fH
  00076	6a 08		 push	 8
  00078	8b 45 f0	 mov	 eax, DWORD PTR _yy$[ebp]
  0007b	50		 push	 eax
  0007c	8b 4d f4	 mov	 ecx, DWORD PTR _xx$[ebp]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  00085	83 c4 10	 add	 esp, 16			; 00000010H
  00088	83 f8 01	 cmp	 eax, 1
  0008b	75 2b		 jne	 SHORT $LN8@gObjWareho

; 16305: 			{
; 16306: 				*(gObj[aIndex].pWarehouseMap+((itemposy+y)*8)+(itemposx+x)) = set_byte;

  0008d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00094	8b 4d f8	 mov	 ecx, DWORD PTR _itemposy$[ebp]
  00097	03 4d ec	 add	 ecx, DWORD PTR _y$2[ebp]
  0009a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a0	8b 84 02 98 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3224]
  000a7	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  000aa	8b 55 fc	 mov	 edx, DWORD PTR _itemposx$[ebp]
  000ad	03 55 e8	 add	 edx, DWORD PTR _x$1[ebp]
  000b0	8a 45 18	 mov	 al, BYTE PTR _set_byte$[ebp]
  000b3	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 16307: 			}

  000b6	eb 26		 jmp	 SHORT $LN9@gObjWareho
$LN8@gObjWareho:

; 16308: 			else {
; 16309: 				LogAdd("error : %d/%d  %s %d",xx,yy,__FILE__, __LINE__);

  000b8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjWarehouseItemBoxSet@@YAXHHHHE@Z@4JA
  000bd	83 c0 12	 add	 eax, 18			; 00000012H
  000c0	50		 push	 eax
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000c6	8b 4d f0	 mov	 ecx, DWORD PTR _yy$[ebp]
  000c9	51		 push	 ecx
  000ca	8b 55 f4	 mov	 edx, DWORD PTR _xx$[ebp]
  000cd	52		 push	 edx
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PBCPKOJP@error?5?3?5?$CFd?1?$CFd?5?5?$CFs?5?$CFd@
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d9	83 c4 14	 add	 esp, 20			; 00000014H

; 16310: 				return;

  000dc	eb 0a		 jmp	 SHORT $LN1@gObjWareho
$LN9@gObjWareho:

; 16311: 			}
; 16312: 		}

  000de	e9 77 ff ff ff	 jmp	 $LN5@gObjWareho
$LN6@gObjWareho:

; 16313: 	}

  000e3	e9 4b ff ff ff	 jmp	 $LN2@gObjWareho
$LN1@gObjWareho:

; 16314: }

  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	5b		 pop	 ebx
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
?gObjWarehouseItemBoxSet@@YAXHHHHE@Z ENDP		; gObjWarehouseItemBoxSet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMapRectCheck@@YAEPAEHHHHHH@Z
_TEXT	SEGMENT
_yy$ = -20						; size = 4
_xx$ = -16						; size = 4
_blank$ = -12						; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_lpMapBuf$ = 8						; size = 4
_sx$ = 12						; size = 4
_sy$ = 16						; size = 4
_ex$ = 20						; size = 4
_ey$ = 24						; size = 4
_width$ = 28						; size = 4
_height$ = 32						; size = 4
?gObjMapRectCheck@@YAEPAEHHHHHH@Z PROC			; gObjMapRectCheck, COMDAT

; 16252: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 16253: 	int x, y;
; 16254: 	int blank = 0;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _blank$[ebp], 0

; 16255: 	
; 16256: 	//     
; 16257: 	if( ((sx+width) > ex) || ((sx+width) < 0)) return (BYTE)0xFF;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  00013	03 45 1c	 add	 eax, DWORD PTR _width$[ebp]
  00016	3b 45 14	 cmp	 eax, DWORD PTR _ex$[ebp]
  00019	7f 08		 jg	 SHORT $LN9@gObjMapRec
  0001b	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  0001e	03 45 1c	 add	 eax, DWORD PTR _width$[ebp]
  00021	79 07		 jns	 SHORT $LN8@gObjMapRec
$LN9@gObjMapRec:
  00023	0c ff		 or	 al, 255			; 000000ffH
  00025	e9 ed 00 00 00	 jmp	 $LN1@gObjMapRec
$LN8@gObjMapRec:

; 16258: 	if( ((sy+height) > ey) || ((sy+height) < 0)) return (BYTE)0xFF;

  0002a	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  0002d	03 45 20	 add	 eax, DWORD PTR _height$[ebp]
  00030	3b 45 18	 cmp	 eax, DWORD PTR _ey$[ebp]
  00033	7f 08		 jg	 SHORT $LN11@gObjMapRec
  00035	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00038	03 45 20	 add	 eax, DWORD PTR _height$[ebp]
  0003b	79 07		 jns	 SHORT $LN10@gObjMapRec
$LN11@gObjMapRec:
  0003d	0c ff		 or	 al, 255			; 000000ffH
  0003f	e9 d3 00 00 00	 jmp	 $LN1@gObjMapRec
$LN10@gObjMapRec:

; 16259: 	
; 16260: 	int xx, yy;
; 16261: 	
; 16262: 	for( y=0; y<height; y++)

  00044	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  0004b	eb 09		 jmp	 SHORT $LN4@gObjMapRec
$LN2@gObjMapRec:
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00050	83 c0 01	 add	 eax, 1
  00053	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
$LN4@gObjMapRec:
  00056	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00059	3b 45 20	 cmp	 eax, DWORD PTR _height$[ebp]
  0005c	0f 8d a1 00 00
	00		 jge	 $LN3@gObjMapRec

; 16263: 	{		
; 16264: 		yy = sy+y;

  00062	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00065	03 45 f8	 add	 eax, DWORD PTR _y$[ebp]
  00068	89 45 ec	 mov	 DWORD PTR _yy$[ebp], eax

; 16265: 		for(x=0; x<width; x++)

  0006b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00072	eb 09		 jmp	 SHORT $LN7@gObjMapRec
$LN5@gObjMapRec:
  00074	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00077	83 c0 01	 add	 eax, 1
  0007a	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$LN7@gObjMapRec:
  0007d	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00080	3b 45 1c	 cmp	 eax, DWORD PTR _width$[ebp]
  00083	7d 79		 jge	 SHORT $LN6@gObjMapRec

; 16266: 		{
; 16267: 			xx = sx+x;

  00085	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  00088	03 45 fc	 add	 eax, DWORD PTR _x$[ebp]
  0008b	89 45 f0	 mov	 DWORD PTR _xx$[ebp], eax

; 16268: 			if( ExtentCheck(xx, yy, ex, ey) == TRUE )

  0008e	8b 45 18	 mov	 eax, DWORD PTR _ey$[ebp]
  00091	50		 push	 eax
  00092	8b 4d 14	 mov	 ecx, DWORD PTR _ex$[ebp]
  00095	51		 push	 ecx
  00096	8b 55 ec	 mov	 edx, DWORD PTR _yy$[ebp]
  00099	52		 push	 edx
  0009a	8b 45 f0	 mov	 eax, DWORD PTR _xx$[ebp]
  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  000a3	83 c4 10	 add	 esp, 16			; 00000010H
  000a6	83 f8 01	 cmp	 eax, 1
  000a9	75 2e		 jne	 SHORT $LN12@gObjMapRec

; 16269: 			{
; 16270: 				if( *(lpMapBuf+((sy+y)*ex)+(sx+x)) != 0xFF ) 

  000ab	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  000ae	03 45 f8	 add	 eax, DWORD PTR _y$[ebp]
  000b1	0f af 45 14	 imul	 eax, DWORD PTR _ex$[ebp]
  000b5	03 45 08	 add	 eax, DWORD PTR _lpMapBuf$[ebp]
  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _sx$[ebp]
  000bb	03 4d fc	 add	 ecx, DWORD PTR _x$[ebp]
  000be	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  000c2	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  000c8	74 0d		 je	 SHORT $LN14@gObjMapRec

; 16271: 				{
; 16272: 					blank++;

  000ca	8b 45 f4	 mov	 eax, DWORD PTR _blank$[ebp]
  000cd	83 c0 01	 add	 eax, 1
  000d0	89 45 f4	 mov	 DWORD PTR _blank$[ebp], eax

; 16273: 					return (BYTE)0xFF;

  000d3	0c ff		 or	 al, 255			; 000000ffH
  000d5	eb 40		 jmp	 SHORT $LN1@gObjMapRec
$LN14@gObjMapRec:

; 16274: 				}
; 16275: 			}

  000d7	eb 20		 jmp	 SHORT $LN13@gObjMapRec
$LN12@gObjMapRec:

; 16276: 			else 
; 16277: 			{
; 16278: 				LogAdd("error : %s %d",__FILE__, __LINE__);

  000d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjMapRectCheck@@YAEPAEHHHHHH@Z@4JA
  000de	83 c0 1a	 add	 eax, 26			; 0000001aH
  000e1	50		 push	 eax
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000e7	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16279: 				return (BYTE)0xFF;

  000f5	0c ff		 or	 al, 255			; 000000ffH
  000f7	eb 1e		 jmp	 SHORT $LN1@gObjMapRec
$LN13@gObjMapRec:

; 16280: 			}
; 16281: 		}

  000f9	e9 76 ff ff ff	 jmp	 $LN5@gObjMapRec
$LN6@gObjMapRec:

; 16282: 	}

  000fe	e9 4a ff ff ff	 jmp	 $LN2@gObjMapRec
$LN3@gObjMapRec:

; 16283: 
; 16284: 	if( blank == 0 ) return (BYTE)(((sy*ex)+sx));

  00103	83 7d f4 00	 cmp	 DWORD PTR _blank$[ebp], 0
  00107	75 0c		 jne	 SHORT $LN15@gObjMapRec
  00109	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  0010c	0f af 45 14	 imul	 eax, DWORD PTR _ex$[ebp]
  00110	03 45 0c	 add	 eax, DWORD PTR _sx$[ebp]
  00113	eb 02		 jmp	 SHORT $LN1@gObjMapRec
$LN15@gObjMapRec:

; 16285: 
; 16286: 	return (BYTE)0xFF;

  00115	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjMapRec:

; 16287: }

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
?gObjMapRectCheck@@YAEPAEHHHHHH@Z ENDP			; gObjMapRectCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjWerehouseRectCheck@@YAEHHHHH@Z
_TEXT	SEGMENT
_lpObj$ = -24						; size = 4
_yy$ = -20						; size = 4
_xx$ = -16						; size = 4
_blank$ = -12						; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_sx$ = 12						; size = 4
_sy$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
?gObjWerehouseRectCheck@@YAEHHHHH@Z PROC		; gObjWerehouseRectCheck, COMDAT

; 16209: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 16210: 	int x, y;
; 16211: 	int blank = 0;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _blank$[ebp], 0

; 16212: 	
; 16213: 	//     
; 16214: 	if( (sx+width) > 8 ) return (BYTE)0xFF;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  00013	03 45 14	 add	 eax, DWORD PTR _width$[ebp]
  00016	83 f8 08	 cmp	 eax, 8
  00019	7e 07		 jle	 SHORT $LN8@gObjWereho
  0001b	0c ff		 or	 al, 255			; 000000ffH
  0001d	e9 21 01 00 00	 jmp	 $LN1@gObjWereho
$LN8@gObjWereho:

; 16215: 	if( (sx+width) < 0 ) return (BYTE)0xFF;

  00022	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  00025	03 45 14	 add	 eax, DWORD PTR _width$[ebp]
  00028	79 07		 jns	 SHORT $LN9@gObjWereho
  0002a	0c ff		 or	 al, 255			; 000000ffH
  0002c	e9 12 01 00 00	 jmp	 $LN1@gObjWereho
$LN9@gObjWereho:

; 16216: 	if( (sy+height) > 15 ) return (BYTE)0xFF;

  00031	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00034	03 45 18	 add	 eax, DWORD PTR _height$[ebp]
  00037	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0003a	7e 07		 jle	 SHORT $LN10@gObjWereho
  0003c	0c ff		 or	 al, 255			; 000000ffH
  0003e	e9 00 01 00 00	 jmp	 $LN1@gObjWereho
$LN10@gObjWereho:

; 16217: 	if( (sy+height) < 0  ) return (BYTE)0xFF;

  00043	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00046	03 45 18	 add	 eax, DWORD PTR _height$[ebp]
  00049	79 07		 jns	 SHORT $LN11@gObjWereho
  0004b	0c ff		 or	 al, 255			; 000000ffH
  0004d	e9 f1 00 00 00	 jmp	 $LN1@gObjWereho
$LN11@gObjWereho:

; 16218: 	int xx, yy;
; 16219: 
; 16220: 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00052	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00059	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005f	89 45 e8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 16221: 
; 16222: 	for( y=0; y<height; y++)

  00062	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  00069	eb 09		 jmp	 SHORT $LN4@gObjWereho
$LN2@gObjWereho:
  0006b	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  0006e	83 c0 01	 add	 eax, 1
  00071	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
$LN4@gObjWereho:
  00074	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00077	3b 45 18	 cmp	 eax, DWORD PTR _height$[ebp]
  0007a	0f 8d b0 00 00
	00		 jge	 $LN3@gObjWereho

; 16223: 	{		
; 16224: 		yy = sy+y;

  00080	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00083	03 45 f8	 add	 eax, DWORD PTR _y$[ebp]
  00086	89 45 ec	 mov	 DWORD PTR _yy$[ebp], eax

; 16225: 		for(x=0; x<width; x++)

  00089	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00090	eb 09		 jmp	 SHORT $LN7@gObjWereho
$LN5@gObjWereho:
  00092	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00095	83 c0 01	 add	 eax, 1
  00098	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$LN7@gObjWereho:
  0009b	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  0009e	3b 45 14	 cmp	 eax, DWORD PTR _width$[ebp]
  000a1	0f 8d 84 00 00
	00		 jge	 $LN6@gObjWereho

; 16226: 		{
; 16227: 			xx = sx+x;

  000a7	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  000aa	03 45 fc	 add	 eax, DWORD PTR _x$[ebp]
  000ad	89 45 f0	 mov	 DWORD PTR _xx$[ebp], eax

; 16228: 			if( ExtentCheck(xx, yy, 8, 15) == TRUE )

  000b0	6a 0f		 push	 15			; 0000000fH
  000b2	6a 08		 push	 8
  000b4	8b 45 ec	 mov	 eax, DWORD PTR _yy$[ebp]
  000b7	50		 push	 eax
  000b8	8b 4d f0	 mov	 ecx, DWORD PTR _xx$[ebp]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  000c1	83 c4 10	 add	 esp, 16			; 00000010H
  000c4	83 f8 01	 cmp	 eax, 1
  000c7	75 3d		 jne	 SHORT $LN12@gObjWereho

; 16229: 			{
; 16230: 				if( *(gObj[aIndex].pWarehouseMap+((sy+y)*8)+(sx+x)) != 0xFF ) 

  000c9	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000d0	8b 4d 10	 mov	 ecx, DWORD PTR _sy$[ebp]
  000d3	03 4d f8	 add	 ecx, DWORD PTR _y$[ebp]
  000d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000dc	8b 84 02 98 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3224]
  000e3	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  000e6	8b 55 0c	 mov	 edx, DWORD PTR _sx$[ebp]
  000e9	03 55 fc	 add	 edx, DWORD PTR _x$[ebp]
  000ec	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  000f0	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000f5	74 0d		 je	 SHORT $LN14@gObjWereho

; 16231: 				{
; 16232: 					blank++;

  000f7	8b 45 f4	 mov	 eax, DWORD PTR _blank$[ebp]
  000fa	83 c0 01	 add	 eax, 1
  000fd	89 45 f4	 mov	 DWORD PTR _blank$[ebp], eax

; 16233: 					return (BYTE)0xFF;

  00100	0c ff		 or	 al, 255			; 000000ffH
  00102	eb 3f		 jmp	 SHORT $LN1@gObjWereho
$LN14@gObjWereho:

; 16234: 				}
; 16235: 			}

  00104	eb 20		 jmp	 SHORT $LN13@gObjWereho
$LN12@gObjWereho:

; 16236: 			else 
; 16237: 			{
; 16238: 				LogAdd("error : %s %d",__FILE__, __LINE__);

  00106	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjWerehouseRectCheck@@YAEHHHHH@Z@4JA
  0010b	83 c0 1d	 add	 eax, 29			; 0000001dH
  0010e	50		 push	 eax
  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00114	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0011f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16239: 				return (BYTE)0xFF;

  00122	0c ff		 or	 al, 255			; 000000ffH
  00124	eb 1d		 jmp	 SHORT $LN1@gObjWereho
$LN13@gObjWereho:

; 16240: 			}
; 16241: 		}

  00126	e9 67 ff ff ff	 jmp	 $LN5@gObjWereho
$LN6@gObjWereho:

; 16242: 	}

  0012b	e9 3b ff ff ff	 jmp	 $LN2@gObjWereho
$LN3@gObjWereho:

; 16243: 
; 16244: 	if( blank == 0 ) return (BYTE)(((sy*8)+sx));

  00130	83 7d f4 00	 cmp	 DWORD PTR _blank$[ebp], 0
  00134	75 0b		 jne	 SHORT $LN15@gObjWereho
  00136	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00139	8b 4d 0c	 mov	 ecx, DWORD PTR _sx$[ebp]
  0013c	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0013f	eb 02		 jmp	 SHORT $LN1@gObjWereho
$LN15@gObjWereho:

; 16245: 
; 16246: 	return (BYTE)0xFF;

  00141	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjWereho:

; 16247: }

  00143	5f		 pop	 edi
  00144	5e		 pop	 esi
  00145	5b		 pop	 ebx
  00146	8b e5		 mov	 esp, ebp
  00148	5d		 pop	 ebp
  00149	c3		 ret	 0
?gObjWerehouseRectCheck@@YAEHHHHH@Z ENDP		; gObjWerehouseRectCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjExpParty@@YAXPAVOBJECTSTRUCT@@0HH@Z
_TEXT	SEGMENT
tv280 = -168						; size = 4
tv129 = -168						; size = 4
tv281 = -164						; size = 4
tv130 = -164						; size = 4
_mymaxexp$1 = -96					; size = 4
_toplevel$ = -92					; size = 4
_lpPartyObj$ = -88					; size = 4
_bCheckSetParty$ = -84					; size = 5
_bApplaySetParty$ = -76					; size = 4
_viewpercent$ = -72					; size = 4
_viewplayer$ = -68					; size = 4
_dis$ = -64						; size = 20
_partycount$ = -44					; size = 4
_partylevel$ = -40					; size = 4
_totallevel$ = -36					; size = 4
_partynum$ = -32					; size = 4
_number$ = -28						; size = 4
_level$ = -24						; size = 4
_totalexp$ = -20					; size = 4
_maxexp$ = -16						; size = 4
_exp$ = -12						; size = 4
_n$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_AttackDamage$ = 16					; size = 4
_MSBFlag$ = 20						; size = 4
?gObjExpParty@@YAXPAVOBJECTSTRUCT@@0HH@Z PROC		; gObjExpParty, COMDAT

; 13037: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 13038: #ifdef DEVILSQUARE_EXTEND_20050221		//    
; 13039: 	if( CHECK_DEVILSQUARE(lpObj->MapNumber) ) 
; 13040: #else
; 13041: 	if( lpObj->MapNumber == 9 ) 

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00019	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00020	83 f9 09	 cmp	 ecx, 9
  00023	75 1f		 jne	 SHORT $LN11@gObjExpPar

; 13042: #endif
; 13043: 	{	//  
; 13044: 		g_DevilSquare.gObjExpParty(lpObj, lpTargetObj, AttackDamage, MSBFlag);

  00025	8b 45 14	 mov	 eax, DWORD PTR _MSBFlag$[ebp]
  00028	50		 push	 eax
  00029	8b 4d 10	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00030	52		 push	 edx
  00031	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00034	50		 push	 eax
  00035	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  0003a	e8 00 00 00 00	 call	 ?gObjExpParty@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@0HH@Z ; CDevilSquare::gObjExpParty

; 13045: 		return;

  0003f	e9 35 06 00 00	 jmp	 $LN1@gObjExpPar
$LN11@gObjExpPar:

; 13046: 	}
; 13047: 
; 13048: 	int n;
; 13049: #ifdef MASTER_LEVEL_UP_SYSTEM_20070912
; 13050: 	INT64 exp, maxexp=0, totalexp;
; 13051: #else
; 13052: 	int exp, maxexp=0, totalexp;

  00044	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _maxexp$[ebp], 0

; 13053: #endif
; 13054: 
; 13055: #ifdef MODIFY_GETTING_EXP_RATE_20060214
; 13056: 	int level = ((lpTargetObj->Level+25)*lpTargetObj->Level)/3;

  0004b	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0004e	0f bf 80 a0 00
	00 00		 movsx	 eax, WORD PTR [eax+160]
  00055	83 c0 19	 add	 eax, 25			; 00000019H
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  0005b	0f bf 91 a0 00
	00 00		 movsx	 edx, WORD PTR [ecx+160]
  00062	0f af c2	 imul	 eax, edx
  00065	99		 cdq
  00066	b9 03 00 00 00	 mov	 ecx, 3
  0006b	f7 f9		 idiv	 ecx
  0006d	89 45 e8	 mov	 DWORD PTR _level$[ebp], eax

; 13057: #else
; 13058: #ifdef MODIFY_GETTING_EXP_RATE_20051116
; 13059: 	int level = ((lpTargetObj->Level+20)*lpTargetObj->Level)/4;
; 13060: #else
; 13061: 	int level = ((lpTargetObj->Level+10)*lpTargetObj->Level)/4;
; 13062: #endif
; 13063: #endif // MODIFY_GETTING_EXP_RATE_20060214
; 13064: 
; 13065: 	int number;
; 13066: 	int partynum=0;

  00070	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _partynum$[ebp], 0

; 13067: 	int totallevel=0;

  00077	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _totallevel$[ebp], 0

; 13068: 	int partylevel;
; 13069: 	int partycount;
; 13070: 	int dis[MAX_PARTYUSER];
; 13071: 	int viewplayer=0;

  0007e	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _viewplayer$[ebp], 0

; 13072: 	int viewpercent=100;

  00085	c7 45 b8 64 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 100 ; 00000064H

; 13073: 
; 13074: 	int bApplaySetParty = FALSE;	//   ?

  0008c	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _bApplaySetParty$[ebp], 0

; 13075: 
; 13076: #ifdef UPDATE_ADD_NEW_PARTY_SET_EXP_20080325
; 13077: 	BYTE bCheckSetParty[6];
; 13078: #else
; 13079: 	#ifdef DARKLORD_WORK
; 13080: 		BYTE bCheckSetParty[5];
; 13081: 	#else
; 13082: 		BYTE bCheckSetParty[4];
; 13083: 	#endif //DARKLORD_WORK
; 13084: #endif //UPDATE_ADD_NEW_PARTY_SET_20080325
; 13085: 	
; 13086: 	LPOBJECTSTRUCT lpPartyObj;
; 13087: 
; 13088: 	partynum = lpObj->PartyNumber;

  00093	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00096	8b 88 88 02 00
	00		 mov	 ecx, DWORD PTR [eax+648]
  0009c	89 4d e0	 mov	 DWORD PTR _partynum$[ebp], ecx

; 13089: 
; 13090: #ifdef MODIFY_PARTY_PLAY_EXPERIENCE_20070208
; 13091: 
; 13092: 	//     
; 13093: 	int toplevel = 0;
; 13094: 	int iTmpDis;
; 13095: 	//    
; 13096: 	for( n=0; n<MAX_PARTYUSER; n++)
; 13097: 	{
; 13098: 		number = gParty.m_PartyS[partynum].Number[n];
; 13099: 		if( number >= 0 )
; 13100: 		{
; 13101: 			lpPartyObj = (LPOBJECTSTRUCT)&gObj[number];
; 13102: 
; 13103: #ifdef MODIFY_PARTY_PLAY_EXPERIENCE_2_20070320
; 13104: 			iTmpDis = gObjCalDistance(lpTargetObj, lpPartyObj);
; 13105: #else
; 13106: 			iTmpDis = gObjCalDistance(lpTargetObj, &lpPartyObj[number]);
; 13107: #endif
; 13108: 			if( iTmpDis < 10 && lpPartyObj->Level > toplevel )
; 13109: 			{
; 13110: 				toplevel = lpPartyObj->Level;
; 13111: 			}
; 13112: 
; 13113: #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	//   -    
; 13114: 			if( iTmpDis < 10 && ( lpPartyObj->Level + lpPartyObj->m_nMasterLevel ) > toplevel )
; 13115: 			{
; 13116: 				toplevel = lpPartyObj->Level + lpPartyObj->m_nMasterLevel;
; 13117: 			}
; 13118: #else
; 13119: 			if( iTmpDis < 10 && lpPartyObj->Level > toplevel )
; 13120: 			{
; 13121: 				toplevel = lpPartyObj->Level;
; 13122: 			}
; 13123: #endif
; 13124: 		}
; 13125: 	}
; 13126: 
; 13127: #else	// MODIFY_PARTY_PLAY_EXPERIENCE_20070208
; 13128: 	
; 13129: #ifdef UPDATE_LOWLEVEL_SUPPORT_1_20051215
; 13130: 	//     
; 13131: 	int toplevel = 0;

  0009f	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _toplevel$[ebp], 0

; 13132: 	//    
; 13133: 	for( n=0; n<MAX_PARTYUSER; n++)

  000a6	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  000ad	eb 09		 jmp	 SHORT $LN4@gObjExpPar
$LN2@gObjExpPar:
  000af	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000b2	83 c0 01	 add	 eax, 1
  000b5	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjExpPar:
  000b8	83 7d f8 05	 cmp	 DWORD PTR _n$[ebp], 5
  000bc	7d 45		 jge	 SHORT $LN3@gObjExpPar

; 13134: 	{
; 13135: 		number = gParty.m_PartyS[partynum].Number[n];

  000be	6b 45 e0 30	 imul	 eax, DWORD PTR _partynum$[ebp], 48
  000c2	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  000c5	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  000cc	89 55 e4	 mov	 DWORD PTR _number$[ebp], edx

; 13136: 		if( number >= 0 )

  000cf	83 7d e4 00	 cmp	 DWORD PTR _number$[ebp], 0
  000d3	7c 2c		 jl	 SHORT $LN13@gObjExpPar

; 13137: 		{
; 13138: 			lpPartyObj = (LPOBJECTSTRUCT)&gObj[number];

  000d5	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  000dc	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e2	89 45 a8	 mov	 DWORD PTR _lpPartyObj$[ebp], eax

; 13139: 
; 13140: 			if( lpPartyObj->Level > toplevel )

  000e5	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  000e8	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  000ef	3b 4d a4	 cmp	 ecx, DWORD PTR _toplevel$[ebp]
  000f2	7e 0d		 jle	 SHORT $LN13@gObjExpPar

; 13141: 			{
; 13142: 				toplevel = lpPartyObj->Level;

  000f4	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  000f7	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  000fe	89 4d a4	 mov	 DWORD PTR _toplevel$[ebp], ecx
$LN13@gObjExpPar:

; 13143: 			}
; 13144: 		}
; 13145: 	}

  00101	eb ac		 jmp	 SHORT $LN2@gObjExpPar
$LN3@gObjExpPar:

; 13146: #endif	// UPDATE_LOWLEVEL_SUPPORT_1_20051215
; 13147: 
; 13148: #endif	// MODIFY_PARTY_PLAY_EXPERIENCE_20070208
; 13149: 
; 13150: 	if( !CHECK_LIMIT(partynum, MAX_PARTY) )

  00103	83 7d e0 00	 cmp	 DWORD PTR _partynum$[ebp], 0
  00107	7d 0c		 jge	 SHORT $LN65@gObjExpPar
  00109	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv130[ebp], 0
  00113	eb 2b		 jmp	 SHORT $LN66@gObjExpPar
$LN65@gObjExpPar:
  00115	81 7d e0 e7 1c
	00 00		 cmp	 DWORD PTR _partynum$[ebp], 7399 ; 00001ce7H
  0011c	7e 0c		 jle	 SHORT $LN63@gObjExpPar
  0011e	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv129[ebp], 0
  00128	eb 0a		 jmp	 SHORT $LN64@gObjExpPar
$LN63@gObjExpPar:
  0012a	c7 85 58 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv129[ebp], 1
$LN64@gObjExpPar:
  00134	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv129[ebp]
  0013a	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv130[ebp], eax
$LN66@gObjExpPar:
  00140	83 bd 5c ff ff
	ff 00		 cmp	 DWORD PTR tv130[ebp], 0
  00147	75 21		 jne	 SHORT $LN14@gObjExpPar

; 13151: 	{
; 13152: 		LogAdd("error : %s %d",__FILE__, __LINE__);

  00149	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjExpParty@@YAXPAVOBJECTSTRUCT@@0HH@Z@4JA
  0014e	83 c0 73	 add	 eax, 115		; 00000073H
  00151	50		 push	 eax
  00152	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00157	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13153: 		return;

  00165	e9 0f 05 00 00	 jmp	 $LN1@gObjExpPar
$LN14@gObjExpPar:

; 13154: 	}
; 13155: 
; 13156: 	memset(bCheckSetParty, 0, sizeof(bCheckSetParty));

  0016a	6a 05		 push	 5
  0016c	6a 00		 push	 0
  0016e	8d 45 ac	 lea	 eax, DWORD PTR _bCheckSetParty$[ebp]
  00171	50		 push	 eax
  00172	e8 00 00 00 00	 call	 _memset
  00177	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13157: 
; 13158: 	partycount = gParty.m_PartyS[partynum].Count;

  0017a	6b 45 e0 30	 imul	 eax, DWORD PTR _partynum$[ebp], 48
  0017e	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+8]
  00184	89 4d d4	 mov	 DWORD PTR _partycount$[ebp], ecx

; 13159: 	for( n=0; n<MAX_PARTYUSER; n++)

  00187	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  0018e	eb 09		 jmp	 SHORT $LN7@gObjExpPar
$LN5@gObjExpPar:
  00190	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00193	83 c0 01	 add	 eax, 1
  00196	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN7@gObjExpPar:
  00199	83 7d f8 05	 cmp	 DWORD PTR _n$[ebp], 5
  0019d	0f 8d dd 00 00
	00		 jge	 $LN6@gObjExpPar

; 13160: 	{
; 13161: 		number = gParty.m_PartyS[partynum].Number[n];

  001a3	6b 45 e0 30	 imul	 eax, DWORD PTR _partynum$[ebp], 48
  001a7	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  001aa	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  001b1	89 55 e4	 mov	 DWORD PTR _number$[ebp], edx

; 13162: 		if( number >= 0 )

  001b4	83 7d e4 00	 cmp	 DWORD PTR _number$[ebp], 0
  001b8	0f 8c bd 00 00
	00		 jl	 $LN17@gObjExpPar

; 13163: 		{
; 13164: 			lpPartyObj = (LPOBJECTSTRUCT)&gObj[number];

  001be	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  001c5	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001cb	89 45 a8	 mov	 DWORD PTR _lpPartyObj$[ebp], eax

; 13165: 			
; 13166: 			//   ..
; 13167: 			if( lpTargetObj->MapNumber == lpPartyObj->MapNumber) 

  001ce	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001d1	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  001d8	8b 55 a8	 mov	 edx, DWORD PTR _lpPartyObj$[ebp]
  001db	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  001e2	3b c8		 cmp	 ecx, eax
  001e4	0f 85 91 00 00
	00		 jne	 $LN17@gObjExpPar

; 13168: 			{
; 13169: 				dis[n] = gObjCalDistance(lpTargetObj, &gObj[number]);

  001ea	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  001f1	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f7	50		 push	 eax
  001f8	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  001fb	51		 push	 ecx
  001fc	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjCalDistance
  00201	83 c4 08	 add	 esp, 8
  00204	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  00207	89 44 95 c0	 mov	 DWORD PTR _dis$[ebp+edx*4], eax

; 13170: 				if( dis[n] < 10 )

  0020b	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0020e	83 7c 85 c0 0a	 cmp	 DWORD PTR _dis$[ebp+eax*4], 10 ; 0000000aH
  00213	7d 66		 jge	 SHORT $LN17@gObjExpPar

; 13171: 				{
; 13172: 					lpPartyObj = (LPOBJECTSTRUCT)&gObj[number];

  00215	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0021c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00222	89 45 a8	 mov	 DWORD PTR _lpPartyObj$[ebp], eax

; 13173: #ifdef MASTER_LEVEL_UP_SYSTEM_20070912		//   -   :  200   
; 13174: 					//       200    200 
; 13175: 					if( toplevel >= ( lpPartyObj->Level + lpPartyObj->m_nMasterLevel + 200 ) )
; 13176: 					{
; 13177: 						totallevel += lpPartyObj->Level + lpPartyObj->m_nMasterLevel + 200;
; 13178: 					}
; 13179: 					else
; 13180: 					{
; 13181: 						totallevel += lpPartyObj->Level + lpPartyObj->m_nMasterLevel;
; 13182: 					}
; 13183: #else
; 13184: #ifdef UPDATE_LOWLEVEL_SUPPORT_1_20051215
; 13185: 					//       200    200  - hnine
; 13186: 					if( toplevel >= (lpPartyObj->Level + 200) )

  00225	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  00228	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0022f	81 c1 c8 00 00
	00		 add	 ecx, 200		; 000000c8H
  00235	39 4d a4	 cmp	 DWORD PTR _toplevel$[ebp], ecx
  00238	7c 19		 jl	 SHORT $LN18@gObjExpPar

; 13187: 					{
; 13188: 						totallevel += lpPartyObj->Level + 200;

  0023a	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  0023d	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00244	8b 55 dc	 mov	 edx, DWORD PTR _totallevel$[ebp]
  00247	8d 84 0a c8 00
	00 00		 lea	 eax, DWORD PTR [edx+ecx+200]
  0024e	89 45 dc	 mov	 DWORD PTR _totallevel$[ebp], eax

; 13189: 					}

  00251	eb 10		 jmp	 SHORT $LN19@gObjExpPar
$LN18@gObjExpPar:

; 13190: 					else
; 13191: 					{
; 13192: 						totallevel += lpPartyObj->Level;

  00253	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  00256	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0025d	03 4d dc	 add	 ecx, DWORD PTR _totallevel$[ebp]
  00260	89 4d dc	 mov	 DWORD PTR _totallevel$[ebp], ecx
$LN19@gObjExpPar:

; 13193: 					}
; 13194: #else
; 13195: 					totallevel += lpPartyObj->Level;
; 13196: #endif	// UPDATE_LOWLEVEL_SUPPORT_1_20051215
; 13197: #endif	// MASTER_LEVEL_UP_SYSTEM_20070912
; 13198: 					viewplayer++;

  00263	8b 45 bc	 mov	 eax, DWORD PTR _viewplayer$[ebp]
  00266	83 c0 01	 add	 eax, 1
  00269	89 45 bc	 mov	 DWORD PTR _viewplayer$[ebp], eax

; 13199: 
; 13200: 					bCheckSetParty[lpPartyObj->Class] = 1;

  0026c	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  0026f	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00276	c6 44 0d ac 01	 mov	 BYTE PTR _bCheckSetParty$[ebp+ecx], 1
$LN17@gObjExpPar:

; 13201: 				}
; 13202: 			}
; 13203: 		}
; 13204: 	}

  0027b	e9 10 ff ff ff	 jmp	 $LN5@gObjExpPar
$LN6@gObjExpPar:

; 13205: 
; 13206: #ifdef UPDATE_ADD_NEW_PARTY_SET_EXP_20080325
; 13207: 	if( bCheckSetParty[0] && bCheckSetParty[1] && bCheckSetParty[2]			// , ,  
; 13208: 		|| bCheckSetParty[3] && bCheckSetParty[4] && bCheckSetParty[5] )	// , ,  
; 13209: #else
; 13210: 	if( bCheckSetParty[0] && bCheckSetParty[1] && bCheckSetParty[2] )		// , ,  

  00280	b8 01 00 00 00	 mov	 eax, 1
  00285	6b c8 00	 imul	 ecx, eax, 0
  00288	0f b6 54 0d ac	 movzx	 edx, BYTE PTR _bCheckSetParty$[ebp+ecx]
  0028d	85 d2		 test	 edx, edx
  0028f	74 28		 je	 SHORT $LN20@gObjExpPar
  00291	b8 01 00 00 00	 mov	 eax, 1
  00296	c1 e0 00	 shl	 eax, 0
  00299	0f b6 4c 05 ac	 movzx	 ecx, BYTE PTR _bCheckSetParty$[ebp+eax]
  0029e	85 c9		 test	 ecx, ecx
  002a0	74 17		 je	 SHORT $LN20@gObjExpPar
  002a2	b8 01 00 00 00	 mov	 eax, 1
  002a7	d1 e0		 shl	 eax, 1
  002a9	0f b6 4c 05 ac	 movzx	 ecx, BYTE PTR _bCheckSetParty$[ebp+eax]
  002ae	85 c9		 test	 ecx, ecx
  002b0	74 07		 je	 SHORT $LN20@gObjExpPar

; 13211: #endif //UPDATE_ADD_NEW_PARTY_SET_EXP_20080325
; 13212: 	{	
; 13213: 		//   (, ,   )		
; 13214: 		bApplaySetParty = TRUE;

  002b2	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _bApplaySetParty$[ebp], 1
$LN20@gObjExpPar:

; 13215: 	}
; 13216: 
; 13217: 	if( viewplayer > 1 )

  002b9	83 7d bc 01	 cmp	 DWORD PTR _viewplayer$[ebp], 1
  002bd	0f 8e 8b 00 00
	00		 jle	 $LN21@gObjExpPar

; 13218: 	{
; 13219: 
; 13220: #ifdef MODIFY_GETTING_EXP_RATE_20060214
; 13221: 		if( bApplaySetParty )

  002c3	83 7d b4 00	 cmp	 DWORD PTR _bApplaySetParty$[ebp], 0
  002c7	74 36		 je	 SHORT $LN23@gObjExpPar

; 13222: 		{	
; 13223: 			//   
; 13224: 			if( viewplayer == 3 )		

  002c9	83 7d bc 03	 cmp	 DWORD PTR _viewplayer$[ebp], 3
  002cd	75 09		 jne	 SHORT $LN25@gObjExpPar

; 13225: 			{
; 13226: 				viewpercent = 230;

  002cf	c7 45 b8 e6 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 230 ; 000000e6H

; 13227: 			}

  002d6	eb 25		 jmp	 SHORT $LN30@gObjExpPar
$LN25@gObjExpPar:

; 13228: 			else if( viewplayer == 4 )

  002d8	83 7d bc 04	 cmp	 DWORD PTR _viewplayer$[ebp], 4
  002dc	75 09		 jne	 SHORT $LN27@gObjExpPar

; 13229: 			{
; 13230: 				viewpercent = 270;

  002de	c7 45 b8 0e 01
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 270 ; 0000010eH

; 13231: 			}

  002e5	eb 16		 jmp	 SHORT $LN30@gObjExpPar
$LN27@gObjExpPar:

; 13232: 			else if( viewplayer >= 5 )	

  002e7	83 7d bc 05	 cmp	 DWORD PTR _viewplayer$[ebp], 5
  002eb	7c 09		 jl	 SHORT $LN29@gObjExpPar

; 13233: 			{
; 13234: 				viewpercent = 300;

  002ed	c7 45 b8 2c 01
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 300 ; 0000012cH

; 13235: 			}

  002f4	eb 07		 jmp	 SHORT $LN30@gObjExpPar
$LN29@gObjExpPar:

; 13236: 			else
; 13237: 			{
; 13238: 				viewpercent = 120;

  002f6	c7 45 b8 78 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 120 ; 00000078H
$LN30@gObjExpPar:

; 13239: 			}
; 13240: 		}

  002fd	eb 43		 jmp	 SHORT $LN38@gObjExpPar
$LN23@gObjExpPar:

; 13241: 		else
; 13242: 		{
; 13243: 			if( viewplayer == 2 )

  002ff	83 7d bc 02	 cmp	 DWORD PTR _viewplayer$[ebp], 2
  00303	75 09		 jne	 SHORT $LN31@gObjExpPar

; 13244: 			{
; 13245: 				viewpercent = 160;

  00305	c7 45 b8 a0 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 160 ; 000000a0H

; 13246: 			}

  0030c	eb 34		 jmp	 SHORT $LN38@gObjExpPar
$LN31@gObjExpPar:

; 13247: 			else if( viewplayer == 3 )

  0030e	83 7d bc 03	 cmp	 DWORD PTR _viewplayer$[ebp], 3
  00312	75 09		 jne	 SHORT $LN33@gObjExpPar

; 13248: 			{
; 13249: 				viewpercent = 180;

  00314	c7 45 b8 b4 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 180 ; 000000b4H

; 13250: 			}

  0031b	eb 25		 jmp	 SHORT $LN38@gObjExpPar
$LN33@gObjExpPar:

; 13251: 			else if( viewplayer == 4 )	

  0031d	83 7d bc 04	 cmp	 DWORD PTR _viewplayer$[ebp], 4
  00321	75 09		 jne	 SHORT $LN35@gObjExpPar

; 13252: 			{
; 13253: 				viewpercent = 200;

  00323	c7 45 b8 c8 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 200 ; 000000c8H

; 13254: 			}

  0032a	eb 16		 jmp	 SHORT $LN38@gObjExpPar
$LN35@gObjExpPar:

; 13255: 			else if( viewplayer >= 5 )	

  0032c	83 7d bc 05	 cmp	 DWORD PTR _viewplayer$[ebp], 5
  00330	7c 09		 jl	 SHORT $LN37@gObjExpPar

; 13256: 			{
; 13257: 				viewpercent = 220;

  00332	c7 45 b8 dc 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 220 ; 000000dcH

; 13258: 			}

  00339	eb 07		 jmp	 SHORT $LN38@gObjExpPar
$LN37@gObjExpPar:

; 13259: 			else
; 13260: 			{
; 13261: 				viewpercent = 150;

  0033b	c7 45 b8 96 00
	00 00		 mov	 DWORD PTR _viewpercent$[ebp], 150 ; 00000096H
$LN38@gObjExpPar:

; 13262: 			}
; 13263: 			
; 13264: 		}
; 13265: #else
; 13266: 	#ifdef MODIFY_GETTING_EXP_RATE_20051116
; 13267: 		if( bApplaySetParty )
; 13268: 		{	
; 13269: 			//   
; 13270: 			if( viewplayer == 3 )		
; 13271: 			{
; 13272: 				viewpercent = 220;
; 13273: 			}
; 13274: 			else if( viewplayer == 4 )
; 13275: 			{
; 13276: 				viewpercent = 260;
; 13277: 			}
; 13278: 			else if( viewplayer >= 5 )	
; 13279: 			{
; 13280: 				viewpercent = 280;
; 13281: 			}
; 13282: 			else
; 13283: 			{
; 13284: 				viewpercent = 120;
; 13285: 			}
; 13286: 
; 13287: 		}
; 13288: 		else
; 13289: 		{
; 13290: 			if( viewplayer == 3 )
; 13291: 			{
; 13292: 				viewpercent = 170;
; 13293: 			}
; 13294: 			else if( viewplayer == 4 )	
; 13295: 			{
; 13296: 				viewpercent = 190;
; 13297: 			}
; 13298: 			else if( viewplayer >= 5 )	
; 13299: 			{
; 13300: 				viewpercent = 210;
; 13301: 			}
; 13302: 			else
; 13303: 			{
; 13304: 				viewpercent = 150;
; 13305: 			}
; 13306: 			
; 13307: 		}
; 13308: 
; 13309: 	#else
; 13310: 
; 13311: 	#ifdef NEW_FORSKYLAND3
; 13312: 			if( bApplaySetParty )
; 13313: 			{	//   
; 13314: 				if( viewplayer == 3 )	viewpercent = 200;
; 13315: 				else if( viewplayer == 4 )	viewpercent = 230;
; 13316: 				else if( viewplayer >= 5 )	viewpercent = 260;
; 13317: 				else viewpercent = 120;
; 13318: 			}	
; 13319: 	#else
; 13320: 			if( bApplaySetParty )
; 13321: 			{	//   
; 13322: 				if( viewplayer == 3 )	viewpercent = 170;
; 13323: 				else if( viewplayer == 4 )	viewpercent = 190;
; 13324: 				else if( viewplayer >= 5 )	viewpercent = 220;
; 13325: 				else viewpercent = 120;
; 13326: 			}
; 13327: 	#endif
; 13328: 			else
; 13329: 			{
; 13330: 				if( viewplayer == 3 )	viewpercent = 150;
; 13331: 				else if( viewplayer == 4 )	viewpercent = 170;
; 13332: 				else if( viewplayer >= 5 )	viewpercent = 190;
; 13333: 				else viewpercent = 120;
; 13334: 			}
; 13335: 
; 13336: 	#endif // MODIFY_GETTING_EXP_RATE_20051116
; 13337: #endif // MODIFY_GETTING_EXP_RATE_20060214
; 13338: 
; 13339: 	
; 13340: 		partylevel = totallevel/viewplayer;

  00342	8b 45 dc	 mov	 eax, DWORD PTR _totallevel$[ebp]
  00345	99		 cdq
  00346	f7 7d bc	 idiv	 DWORD PTR _viewplayer$[ebp]
  00349	89 45 d8	 mov	 DWORD PTR _partylevel$[ebp], eax

; 13341: 		
; 13342: 	}

  0034c	eb 06		 jmp	 SHORT $LN22@gObjExpPar
$LN21@gObjExpPar:

; 13343: 	else
; 13344: 	{
; 13345: 		partylevel = totallevel;

  0034e	8b 45 dc	 mov	 eax, DWORD PTR _totallevel$[ebp]
  00351	89 45 d8	 mov	 DWORD PTR _partylevel$[ebp], eax
$LN22@gObjExpPar:

; 13346: 	}
; 13347: 
; 13348: 	if((lpTargetObj->Level+10) < partylevel)

  00354	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00357	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0035e	83 c1 0a	 add	 ecx, 10			; 0000000aH
  00361	3b 4d d8	 cmp	 ecx, DWORD PTR _partylevel$[ebp]
  00364	7d 1a		 jge	 SHORT $LN39@gObjExpPar

; 13349: 	{
; 13350: 		level =  level * (lpTargetObj->Level+10) / partylevel;

  00366	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00369	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00370	83 c1 0a	 add	 ecx, 10			; 0000000aH
  00373	8b c1		 mov	 eax, ecx
  00375	0f af 45 e8	 imul	 eax, DWORD PTR _level$[ebp]
  00379	99		 cdq
  0037a	f7 7d d8	 idiv	 DWORD PTR _partylevel$[ebp]
  0037d	89 45 e8	 mov	 DWORD PTR _level$[ebp], eax
$LN39@gObjExpPar:

; 13351: 	}
; 13352: 
; 13353: #ifdef EXP_CAL_CHANGE
; 13354: 	if( lpTargetObj->Level >= 65 )	

  00380	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00383	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0038a	83 f9 41	 cmp	 ecx, 65			; 00000041H
  0038d	7c 63		 jl	 SHORT $LN42@gObjExpPar

; 13355: 	{	//   50
; 13356: 		if( viewplayer == 1 )

  0038f	83 7d bc 01	 cmp	 DWORD PTR _viewplayer$[ebp], 1
  00393	75 2b		 jne	 SHORT $LN41@gObjExpPar

; 13357: 		{
; 13358: 	#ifdef MODIFY_GETTING_EXP_RATE_20051116
; 13359: 			level += (lpTargetObj->Level-64)*(lpTargetObj->Level/3);
; 13360: 	#else
; 13361: 			level += (lpTargetObj->Level-64)*(lpTargetObj->Level/4);

  00395	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00398	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0039f	83 e9 40	 sub	 ecx, 64			; 00000040H
  003a2	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  003a5	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  003ac	99		 cdq
  003ad	83 e2 03	 and	 edx, 3
  003b0	03 c2		 add	 eax, edx
  003b2	c1 f8 02	 sar	 eax, 2
  003b5	0f af c8	 imul	 ecx, eax
  003b8	03 4d e8	 add	 ecx, DWORD PTR _level$[ebp]
  003bb	89 4d e8	 mov	 DWORD PTR _level$[ebp], ecx

; 13362: 	#endif
; 13363: 		}

  003be	eb 32		 jmp	 SHORT $LN42@gObjExpPar
$LN41@gObjExpPar:

; 13364: 		else
; 13365: 		{
; 13366: #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	//  -   64  
; 13367: 			level += 200 - ( ( lpObj->Level + lpObj->m_nMasterLevel ) * 0.2 );
; 13368: #else			
; 13369: 			level += 200 - (lpObj->Level*0.2);

  003c0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003c3	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  003ca	f2 0f 2a c1	 cvtsi2sd xmm0, ecx
  003ce	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fc999999999999a
  003d6	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@4069000000000000
  003de	f2 0f 5c c8	 subsd	 xmm1, xmm0
  003e2	f2 0f 2a 45 e8	 cvtsi2sd xmm0, DWORD PTR _level$[ebp]
  003e7	f2 0f 58 c1	 addsd	 xmm0, xmm1
  003eb	f2 0f 2c d0	 cvttsd2si edx, xmm0
  003ef	89 55 e8	 mov	 DWORD PTR _level$[ebp], edx
$LN42@gObjExpPar:

; 13370: #endif
; 13371: 		}
; 13372: 	}
; 13373: #endif
; 13374: 
; 13375: 	if( level > 0 ) 

  003f2	83 7d e8 00	 cmp	 DWORD PTR _level$[ebp], 0
  003f6	7e 0d		 jle	 SHORT $LN43@gObjExpPar

; 13376: 	{
; 13377: 		maxexp = level/2;

  003f8	8b 45 e8	 mov	 eax, DWORD PTR _level$[ebp]
  003fb	99		 cdq
  003fc	2b c2		 sub	 eax, edx
  003fe	d1 f8		 sar	 eax, 1
  00400	89 45 f0	 mov	 DWORD PTR _maxexp$[ebp], eax

; 13378: 	}

  00403	eb 07		 jmp	 SHORT $LN44@gObjExpPar
$LN43@gObjExpPar:

; 13379: 	else level = 0;

  00405	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN44@gObjExpPar:

; 13380: 	if( maxexp < 1 ) {

  0040c	83 7d f0 01	 cmp	 DWORD PTR _maxexp$[ebp], 1
  00410	7d 08		 jge	 SHORT $LN45@gObjExpPar

; 13381: 		totalexp = level;

  00412	8b 45 e8	 mov	 eax, DWORD PTR _level$[ebp]
  00415	89 45 ec	 mov	 DWORD PTR _totalexp$[ebp], eax

; 13382: 	}

  00418	eb 0f		 jmp	 SHORT $LN46@gObjExpPar
$LN45@gObjExpPar:

; 13383: 	else totalexp = level+(rand()%maxexp);

  0041a	e8 00 00 00 00	 call	 _rand
  0041f	99		 cdq
  00420	f7 7d f0	 idiv	 DWORD PTR _maxexp$[ebp]
  00423	03 55 e8	 add	 edx, DWORD PTR _level$[ebp]
  00426	89 55 ec	 mov	 DWORD PTR _totalexp$[ebp], edx
$LN46@gObjExpPar:

; 13384: 	
; 13385: 	if( lpTargetObj->Type == OBJTYPE_MONSTER )

  00429	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0042c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00430	83 f9 02	 cmp	 ecx, 2
  00433	75 0c		 jne	 SHORT $LN47@gObjExpPar

; 13386: 	{
; 13387: 		lpTargetObj->Money = totalexp;

  00435	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00438	8b 4d ec	 mov	 ecx, DWORD PTR _totalexp$[ebp]
  0043b	89 88 b0 00 00
	00		 mov	 DWORD PTR [eax+176], ecx
$LN47@gObjExpPar:

; 13388: 	}
; 13389: 
; 13390: 	for( n=0; n<MAX_PARTYUSER; n++)

  00441	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00448	eb 09		 jmp	 SHORT $LN10@gObjExpPar
$LN8@gObjExpPar:
  0044a	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0044d	83 c0 01	 add	 eax, 1
  00450	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN10@gObjExpPar:
  00453	83 7d f8 05	 cmp	 DWORD PTR _n$[ebp], 5
  00457	0f 8d 1c 02 00
	00		 jge	 $LN9@gObjExpPar

; 13391: 	{
; 13392: 		number = gParty.m_PartyS[partynum].Number[n];

  0045d	6b 45 e0 30	 imul	 eax, DWORD PTR _partynum$[ebp], 48
  00461	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00464	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  0046b	89 55 e4	 mov	 DWORD PTR _number$[ebp], edx

; 13393: 		if( number >= 0 )

  0046e	83 7d e4 00	 cmp	 DWORD PTR _number$[ebp], 0
  00472	0f 8c fc 01 00
	00		 jl	 $LN61@gObjExpPar

; 13394: 		{
; 13395: 			lpPartyObj = (LPOBJECTSTRUCT)&gObj[number];

  00478	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0047f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00485	89 45 a8	 mov	 DWORD PTR _lpPartyObj$[ebp], eax

; 13396: 			
; 13397: 			//   ..
; 13398: 			if( lpTargetObj->MapNumber == lpPartyObj->MapNumber) 

  00488	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0048b	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00492	8b 55 a8	 mov	 edx, DWORD PTR _lpPartyObj$[ebp]
  00495	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0049c	3b c8		 cmp	 ecx, eax
  0049e	0f 85 d0 01 00
	00		 jne	 $LN61@gObjExpPar

; 13399: 			{
; 13400: 				//    ..
; 13401: 				if( dis[n] < 10 )

  004a4	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  004a7	83 7c 85 c0 0a	 cmp	 DWORD PTR _dis$[ebp+eax*4], 10 ; 0000000aH
  004ac	0f 8d c2 01 00
	00		 jge	 $LN61@gObjExpPar

; 13402: 				{
; 13403: #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	//   -       
; 13404: 					INT64 mymaxexp = 0;
; 13405: 					if( !g_MasterLevelSystem.CheckMLGetExp( lpPartyObj, lpTargetObj ) )
; 13406: 					{	
; 13407: 						//         .
; 13408: 						exp = 0;
; 13409: 					}
; 13410: 					else
; 13411: 					{
; 13412: 						if( g_MasterLevelSystem.IsMasterLevelUser( lpPartyObj ) )
; 13413: 						{
; 13414: 							mymaxexp = lpPartyObj->m_i64NextMasterLevelExp;
; 13415: 						}
; 13416: 						else
; 13417: 						{
; 13418: 							mymaxexp = gLevelExperience[lpPartyObj->Level];
; 13419: 						}				
; 13420: 						
; 13421: 						exp = ( totalexp * viewpercent ) * ( lpPartyObj->Level + lpPartyObj->m_nMasterLevel ) / totallevel / 100;
; 13422: 					}
; 13423: #else
; 13424: 					DWORD mymaxexp = gLevelExperience[lpPartyObj->Level];

  004b2	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  004b5	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  004bc	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?gLevelExperience@@3PAKA[ecx*4]
  004c3	89 55 a0	 mov	 DWORD PTR _mymaxexp$1[ebp], edx

; 13425: 					
; 13426: 					exp = (totalexp*viewpercent)*lpPartyObj->Level/totallevel/100;

  004c6	8b 45 ec	 mov	 eax, DWORD PTR _totalexp$[ebp]
  004c9	0f af 45 b8	 imul	 eax, DWORD PTR _viewpercent$[ebp]
  004cd	8b 4d a8	 mov	 ecx, DWORD PTR _lpPartyObj$[ebp]
  004d0	0f bf 91 a0 00
	00 00		 movsx	 edx, WORD PTR [ecx+160]
  004d7	0f af c2	 imul	 eax, edx
  004da	99		 cdq
  004db	f7 7d dc	 idiv	 DWORD PTR _totallevel$[ebp]
  004de	99		 cdq
  004df	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  004e4	f7 f9		 idiv	 ecx
  004e6	89 45 f4	 mov	 DWORD PTR _exp$[ebp], eax

; 13427: #endif
; 13428: 
; 13429: #ifdef FOR_BLOODCASTLE2
; 13430: 					if( CHECK_BLOODCASTLE(lpPartyObj->MapNumber) )		

  004e9	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  004ec	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  004f3	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  004f6	7d 0c		 jge	 SHORT $LN69@gObjExpPar
  004f8	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv281[ebp], 0
  00502	eb 31		 jmp	 SHORT $LN70@gObjExpPar
$LN69@gObjExpPar:
  00504	8b 55 a8	 mov	 edx, DWORD PTR _lpPartyObj$[ebp]
  00507	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0050e	83 f8 11	 cmp	 eax, 17			; 00000011H
  00511	7e 0c		 jle	 SHORT $LN67@gObjExpPar
  00513	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv280[ebp], 0
  0051d	eb 0a		 jmp	 SHORT $LN68@gObjExpPar
$LN67@gObjExpPar:
  0051f	c7 85 58 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv280[ebp], 1
$LN68@gObjExpPar:
  00529	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR tv280[ebp]
  0052f	89 8d 5c ff ff
	ff		 mov	 DWORD PTR tv281[ebp], ecx
$LN70@gObjExpPar:
  00535	83 bd 5c ff ff
	ff 00		 cmp	 DWORD PTR tv281[ebp], 0
  0053c	74 0f		 je	 SHORT $LN51@gObjExpPar

; 13431: 					{	//      50%
; 13432: 						exp = exp*BC_MONSTER_KILL_EXP_PERCENT/100;

  0053e	6b 45 f4 32	 imul	 eax, DWORD PTR _exp$[ebp], 50
  00542	99		 cdq
  00543	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00548	f7 f9		 idiv	 ecx
  0054a	89 45 f4	 mov	 DWORD PTR _exp$[ebp], eax
$LN51@gObjExpPar:

; 13433: 					}
; 13434: #endif
; 13435: 					
; 13436: 					//    ..
; 13437: 					if( exp > mymaxexp ) exp = mymaxexp;

  0054d	8b 45 f4	 mov	 eax, DWORD PTR _exp$[ebp]
  00550	3b 45 a0	 cmp	 eax, DWORD PTR _mymaxexp$1[ebp]
  00553	76 06		 jbe	 SHORT $LN52@gObjExpPar
  00555	8b 45 a0	 mov	 eax, DWORD PTR _mymaxexp$1[ebp]
  00558	89 45 f4	 mov	 DWORD PTR _exp$[ebp], eax
$LN52@gObjExpPar:

; 13438: 					
; 13439: 					// PK  .
; 13440: 					if( lpPartyObj->Type == OBJTYPE_CHARACTER && lpTargetObj->Type == OBJTYPE_CHARACTER )

  0055b	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  0055e	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00562	83 f9 01	 cmp	 ecx, 1
  00565	75 13		 jne	 SHORT $LN53@gObjExpPar
  00567	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0056a	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0056e	83 f9 01	 cmp	 ecx, 1
  00571	75 07		 jne	 SHORT $LN53@gObjExpPar

; 13441: 					{
; 13442: 						exp = 0;

  00573	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _exp$[ebp], 0
$LN53@gObjExpPar:

; 13443: 					}
; 13444: 	#ifdef MASTER_LEVEL_UP_SYSTEM_20070912	//   -   	
; 13445: 					if( !g_MasterLevelSystem.IsMasterLevelUser( lpPartyObj ) )
; 13446: 						exp = (int)((float)exp*gAddExperience);
; 13447: 	#else
; 13448: 					exp = (int)((float)exp*gAddExperience);

  0057a	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _exp$[ebp]
  0057f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR ?gAddExperience@@3MA
  00587	f3 0f 2c c0	 cvttss2si eax, xmm0
  0058b	89 45 f4	 mov	 DWORD PTR _exp$[ebp], eax

; 13449: 	#endif
; 13450: 
; 13451: #if defined(PCBANG_POINT_SYSTEM_20070206) && defined(ADD_PCBANG_EXPRATE)
; 13452: 					if( !g_MasterLevelSystem.IsMasterLevelUser( lpPartyObj ) )
; 13453: 						g_PCBangPointSystem.CheckPCBangAddExperience(lpPartyObj, exp);
; 13454: #endif // ADD_PCBANG_EXPRATE
; 13455: 
; 13456: #ifdef ADD_PCS_MARK_OF_EXP_20070205
; 13457: 	#ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004					// !! NOT
; 13458: 					if( lpPartyObj->m_wExprienceRate > 0 )

  0058e	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  00591	0f b7 88 2c 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6700]
  00598	85 c9		 test	 ecx, ecx
  0059a	7e 26		 jle	 SHORT $LN54@gObjExpPar

; 13459: 					{
; 13460: 						exp = (int)(exp * ((float)lpPartyObj->m_wExprienceRate / 100 ));

  0059c	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _exp$[ebp]
  005a1	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  005a4	0f b7 88 2c 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6700]
  005ab	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  005af	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@42c80000
  005b7	f3 0f 59 c1	 mulss	 xmm0, xmm1
  005bb	f3 0f 2c d0	 cvttss2si edx, xmm0
  005bf	89 55 f4	 mov	 DWORD PTR _exp$[ebp], edx
$LN54@gObjExpPar:

; 13461: 					}
; 13462: 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 13463: #endif // ADD_PCS_MARK_OF_EXP_20070205
; 13464: 
; 13465: #ifdef MU_CRYWOLF_PENALTY_20051215
; 13466: 					// MVP  :    
; 13467: 					if( g_CrywolfSync.GetOccupationState() == CRYWOLF_OCCUPATION_STATE_OCCUPIED 
; 13468: 						&& g_iCrywolfApplyMvpPenalty	
; 13469: 					  )
; 13470: 					{
; 13471: 						exp = exp * g_CrywolfSync.GetGettingExpPenaltyRate() / 100;
; 13472: 					}
; 13473: #endif
; 13474: 					
; 13475: 					if( exp > 0 ) {

  005c2	83 7d f4 00	 cmp	 DWORD PTR _exp$[ebp], 0
  005c6	7e 72		 jle	 SHORT $LN59@gObjExpPar

; 13476: 						if( lpPartyObj->Type == OBJTYPE_CHARACTER ) 

  005c8	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  005cb	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  005cf	83 f9 01	 cmp	 ecx, 1
  005d2	75 66		 jne	 SHORT $LN59@gObjExpPar

; 13477: 						{
; 13478: #ifdef CHN_PLAYTIME_LIMIT_SYSTEM_20050818	// > .      .
; 13479: 							if (g_bChnPlayTimeLimitOn)
; 13480: 							{
; 13481: 	#ifdef MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_01_20070509
; 13482: 								if( lpPartyObj->m_iVerifyType != PLAYTIME_LIMIT_VERIFY_ADULT )
; 13483: 								{
; 13484: 									if (lpPartyObj->m_iPlayTimeLimit >= 5*60*60)
; 13485: 									{
; 13486: 										exp = exp * g_iChnPlayTimeLimitLevel2Exp / 100;
; 13487: 									}
; 13488: 									else if (lpPartyObj->m_iPlayTimeLimit >= 3*60*60)
; 13489: 									{
; 13490: 										exp = exp * g_iChnPlayTimeLimitLevel1Exp / 100;
; 13491: 									}
; 13492: 								}
; 13493: 	#else
; 13494: 								if (lpPartyObj->m_iPlayTimeLimit >= 5*60*60)
; 13495: 								{
; 13496: 									exp = exp * g_iChnPlayTimeLimitLevel2Exp / 100;
; 13497: 								}
; 13498: 								else if (lpPartyObj->m_iPlayTimeLimit >= 3*60*60)
; 13499: 								{
; 13500: 									exp = exp * g_iChnPlayTimeLimitLevel1Exp / 100;
; 13501: 								}
; 13502: 	#endif // MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_01_20070509
; 13503: 							}
; 13504: #endif
; 13505: 
; 13506: #ifdef VTM_PLAYTIME_LIMIT_SYSTEM_20060626	//  :   
; 13507: 							if (g_bVtmPlayTimeLimitOn) 
; 13508: 							{
; 13509: 								if (lpPartyObj->m_iPlayTimeLimit >= g_iVtmPlayTimeLimitLevel2Time*60) 
; 13510: 								{
; 13511: 									exp = exp * g_iVtmPlayTimeLimitLevel2Exp / 100;
; 13512: 								}
; 13513: 								else if (lpPartyObj->m_iPlayTimeLimit >= g_iVtmPlayTimeLimitLevel1Time*60) 
; 13514: 								{
; 13515: 									exp = exp * g_iVtmPlayTimeLimitLevel1Exp / 100;
; 13516: 								}
; 13517: 							}
; 13518: #endif
; 13519: 
; 13520: #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 13521: 	#ifdef MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 13522: 								CheckItemOptForGetExpEx( lpPartyObj, exp );
; 13523: 	#else
; 13524: 	//--> MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC     
; 13525: 	#ifdef BUGFIX_BUFF_EFFECT_SYSTEM_FOR_PCBANG_ITEM_20071205
; 13526: 
; 13527: 		#ifdef ADD_NEWPVP_PKFIELD
; 13528: 							//  PC ( )  
; 13529: 							if (g_NewPVP.IsVulcanusMap(lpPartyObj->MapNumber)) {
; 13530: 								g_NewPVP.CheckItemOptForGetExp(lpPartyObj, exp);
; 13531: 							} else {
; 13532: 								g_PCBangPointSystem.CheckItemOptForGetExp( lpPartyObj, exp );
; 13533: 							}
; 13534: 		#else
; 13535: 							g_PCBangPointSystem.CheckItemOptForGetExp( lpPartyObj, exp );
; 13536: 		#endif // ADD_NEWPVP_PKFIELD
; 13537: 	#else
; 13538: 		#ifdef MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 13539: 							CheckItemOptForGetExp(lpPartyObj, exp);
; 13540: 		#else
; 13541: 							int iExpRate = 0;
; 13542: 							iExpRate = gObjGetTotalValueOfEffect( lpPartyObj, EFFECTTYPE_EXPERIENCE );
; 13543: 							if( gObjCheckUsedBuffEffect( lpPartyObj, BUFFTYPE_PCBANG_POINT_MARK3 ) == false
; 13544: 								&& iExpRate == 0
; 13545: 								)
; 13546: 							{
; 13547: 								iExpRate = 100;
; 13548: 							}
; 13549: 							exp = ( exp * iExpRate ) / 100;
; 13550: 		#endif // MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 13551: 
; 13552: 	#endif	// BUGFIX_BUFF_EFFECT_SYSTEM_FOR_PCBANG_ITEM_20071205
; 13553: 	//<--
; 13554: 	#endif // MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 13555: 
; 13556: 							lpPartyObj->Experience += exp;
; 13557: #else
; 13558: 	#ifdef ADD_PCS_MARK_OF_EXP_20070205
; 13559: 							if( lpPartyObj->m_wExprienceRate > 0 )

  005d4	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  005d7	0f b7 88 2c 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6700]
  005de	85 c9		 test	 ecx, ecx
  005e0	7e 15		 jle	 SHORT $LN57@gObjExpPar

; 13560: 							{
; 13561: 								lpPartyObj->Experience += exp;

  005e2	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  005e5	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  005eb	03 4d f4	 add	 ecx, DWORD PTR _exp$[ebp]
  005ee	8b 55 a8	 mov	 edx, DWORD PTR _lpPartyObj$[ebp]
  005f1	89 8a a8 00 00
	00		 mov	 DWORD PTR [edx+168], ecx
$LN57@gObjExpPar:

; 13562: 							}
; 13563: 	#else
; 13564: 							lpPartyObj->Experience += exp;
; 13565: 	#endif // ADD_PCS_MARK_OF_EXP_20070205
; 13566: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 13567: 
; 13568: 							if(lpTargetObj->Money < exp)

  005f7	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  005fa	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00600	3b 4d f4	 cmp	 ecx, DWORD PTR _exp$[ebp]
  00603	7d 0c		 jge	 SHORT $LN58@gObjExpPar

; 13569: 							{
; 13570: 								lpTargetObj->Money = exp;

  00605	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00608	8b 4d f4	 mov	 ecx, DWORD PTR _exp$[ebp]
  0060b	89 88 b0 00 00
	00		 mov	 DWORD PTR [eax+176], ecx
$LN58@gObjExpPar:

; 13571: 							}
; 13572: 
; 13573: 							/*if( exp > 1200 )
; 13574: 							{
; 13575: 								LogAddC(LOGC_RED, lMsg.Get(526), lpPartyObj->AccountID, lpPartyObj->Name, lpPartyObj->Level, exp, lpTargetObj->Name);
; 13576: 							}*/
; 13577: 							//LogAdd(" : [%s][%s] [%s] %d (%d / %d:%d)", lpPartyObj->AccountID, lpPartyObj->Name, lpTargetObj->Name, exp, lpPartyObj->MapNumber, lpPartyObj->X, lpPartyObj->Y);
; 13578: 
; 13579: #ifdef MODIFY_EXP_LOG_MONSTER_EVENT_INDEX_20060906
; 13580: 							if (gObjLevelUp(lpPartyObj, exp, lpTargetObj->Class, EVENT_TYPE_PARTY) == false)

  00611	6a 01		 push	 1
  00613	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00616	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0061d	51		 push	 ecx
  0061e	8b 55 f4	 mov	 edx, DWORD PTR _exp$[ebp]
  00621	52		 push	 edx
  00622	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  00625	50		 push	 eax
  00626	e8 00 00 00 00	 call	 ?gObjLevelUp@@YA_NPAVOBJECTSTRUCT@@HHH@Z ; gObjLevelUp
  0062b	83 c4 10	 add	 esp, 16			; 00000010H
  0062e	0f b6 c8	 movzx	 ecx, al
  00631	85 c9		 test	 ecx, ecx
  00633	75 05		 jne	 SHORT $LN59@gObjExpPar

; 13581: 								continue;

  00635	e9 10 fe ff ff	 jmp	 $LN8@gObjExpPar
$LN59@gObjExpPar:

; 13582: #else
; 13583: 	#ifdef MAX_LEVEL_BLOCK_GAIN_EXPERIENCE_20050613
; 13584: 							if (gObjLevelUp(lpPartyObj, exp) == false)
; 13585: 								continue;
; 13586: 	#endif
; 13587: #endif // MODIFY_EXP_LOG_MONSTER_EVENT_INDEX_20060906
; 13588: 
; 13589: 						}
; 13590: 					}
; 13591: 					if( lpPartyObj->Type == OBJTYPE_CHARACTER )

  0063a	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  0063d	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00641	83 f9 01	 cmp	 ecx, 1
  00644	75 2e		 jne	 SHORT $LN61@gObjExpPar

; 13592: 					{
; 13593: #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 13594: 			#ifdef BUGFIX_GAIN_EXP_20071210
; 13595: 					// *    .
; 13596: 						if( !g_MasterLevelSystem.IsMasterLevelUser( lpPartyObj ) )
; 13597: 						{
; 13598: 							GCKillPlayerExpSend(lpPartyObj->m_Index, lpTargetObj->m_Index, exp, AttackDamage, MSBFlag);
; 13599: 						}
; 13600: 			#else
; 13601: 						GCKillPlayerExpSend(lpPartyObj->m_Index, lpTargetObj->m_Index, exp, AttackDamage, MSBFlag);
; 13602: 			#endif
; 13603: #else
; 13604: 	#ifdef ADD_PCS_MARK_OF_EXP_20070205
; 13605: 						if( lpPartyObj->m_wExprienceRate > 0 )

  00646	8b 45 a8	 mov	 eax, DWORD PTR _lpPartyObj$[ebp]
  00649	0f b7 88 2c 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6700]
  00650	85 c9		 test	 ecx, ecx
  00652	7e 20		 jle	 SHORT $LN61@gObjExpPar

; 13606: 						{
; 13607: 							GCKillPlayerExpSend(lpPartyObj->m_Index, lpTargetObj->m_Index, exp, AttackDamage, MSBFlag);

  00654	8b 45 14	 mov	 eax, DWORD PTR _MSBFlag$[ebp]
  00657	50		 push	 eax
  00658	8b 4d 10	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  0065b	51		 push	 ecx
  0065c	8b 55 f4	 mov	 edx, DWORD PTR _exp$[ebp]
  0065f	52		 push	 edx
  00660	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00663	8b 08		 mov	 ecx, DWORD PTR [eax]
  00665	51		 push	 ecx
  00666	8b 55 a8	 mov	 edx, DWORD PTR _lpPartyObj$[ebp]
  00669	8b 02		 mov	 eax, DWORD PTR [edx]
  0066b	50		 push	 eax
  0066c	e8 00 00 00 00	 call	 ?GCKillPlayerExpSend@@YAXHHHHH@Z ; GCKillPlayerExpSend
  00671	83 c4 14	 add	 esp, 20			; 00000014H
$LN61@gObjExpPar:

; 13608: 						}
; 13609: 	#else
; 13610: 						GCKillPlayerExpSend(lpPartyObj->m_Index, lpTargetObj->m_Index, exp, AttackDamage, MSBFlag);
; 13611: 	#endif // ADD_PCS_MARK_OF_EXP_20070205
; 13612: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 13613: 					}
; 13614: 				}
; 13615: 			}
; 13616: 		}
; 13617: 	}

  00674	e9 d1 fd ff ff	 jmp	 $LN8@gObjExpPar
$LN9@gObjExpPar:
$LN1@gObjExpPar:

; 13618: }

  00679	5f		 pop	 edi
  0067a	5e		 pop	 esi
  0067b	5b		 pop	 ebx
  0067c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0067f	33 cd		 xor	 ecx, ebp
  00681	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00686	8b e5		 mov	 esp, ebp
  00688	5d		 pop	 ebp
  00689	c3		 ret	 0
?gObjExpParty@@YAXPAVOBJECTSTRUCT@@0HH@Z ENDP		; gObjExpParty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSecondDurDown@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_attr$ = -9						; size = 1
_reCalCharacter$ = -8					; size = 4
_ret$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjSecondDurDown@@YAXPAVOBJECTSTRUCT@@@Z PROC		; gObjSecondDurDown, COMDAT

; 10827: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 10828: 	lpObj->m_TimeCount++;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	8a 48 54	 mov	 cl, BYTE PTR [eax+84]
  0000f	80 c1 01	 add	 cl, 1
  00012	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00015	88 4a 54	 mov	 BYTE PTR [edx+84], cl

; 10829: 	int ret = 0, reCalCharacter = FALSE;

  00018	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
  0001f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 0

; 10830: 	if (gConnectBonus == 1)

  00026	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gConnectBonus@@3HA, 1 ; gConnectBonus
  0002d	75 23		 jne	 SHORT $LN2@gObjSecond

; 10831: 	{
; 10832: 		lpObj->m_ConnectBonusTime++;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00032	8b 88 a4 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6820]
  00038	83 c1 01	 add	 ecx, 1
  0003b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0003e	89 8a a4 1a 00
	00		 mov	 DWORD PTR [edx+6820], ecx

; 10833: 		AddTimeBonus(lpObj->m_Index);

  00044	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?AddTimeBonus@@YAXH@Z	; AddTimeBonus
  0004f	83 c4 04	 add	 esp, 4
$LN2@gObjSecond:

; 10834: 	}
; 10835: 	//    
; 10836: #ifdef MODIFY_CHANGE_RING_DURABILITY_BUGFIX_20080820
; 10837: 	if( lpObj->m_Change >= 0 ) gObjChangeDurProc2(lpObj);
; 10838: #else
; 10839: 	if( lpObj->m_Change >= 0 ) gObjChangeDurProc(lpObj);

  00052	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00055	83 b8 a8 02 00
	00 00		 cmp	 DWORD PTR [eax+680], 0
  0005c	7c 0c		 jl	 SHORT $LN3@gObjSecond
  0005e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?gObjChangeDurProc@@YAXPAVOBJECTSTRUCT@@@Z ; gObjChangeDurProc
  00067	83 c4 04	 add	 esp, 4
$LN3@gObjSecond:

; 10840: #endif // MODIFY_CHANGE_RING_DURABILITY_BUGFIX_20080820
; 10841: 
; 10842: 	BYTE attr = MapC[lpObj->MapNumber].GetAttr(lpObj->X, lpObj->Y);

  0006a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006d	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00074	51		 push	 ecx
  00075	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00078	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  0007f	50		 push	 eax
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00083	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0008a	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00090	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00096	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0009b	88 45 f7	 mov	 BYTE PTR _attr$[ebp], al

; 10843: 
; 10844: 	if( (lpObj->m_TimeCount%10) != 0 )

  0009e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a1	0f b6 40 54	 movzx	 eax, BYTE PTR [eax+84]
  000a5	99		 cdq
  000a6	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  000ab	f7 f9		 idiv	 ecx
  000ad	85 d2		 test	 edx, edx
  000af	74 05		 je	 SHORT $LN4@gObjSecond

; 10845: 	{
; 10846: 		return;

  000b1	e9 e3 03 00 00	 jmp	 $LN1@gObjSecond
$LN4@gObjSecond:

; 10847: 	}
; 10848: 
; 10849: 	if( lpObj->pInventory[EQUIPMENT_WING].IsItem() == TRUE )

  000b6	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000bb	6b c8 07	 imul	 ecx, eax, 7
  000be	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000c1	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  000c7	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000cc	83 f8 01	 cmp	 eax, 1
  000cf	75 61		 jne	 SHORT $LN7@gObjSecond

; 10850: 	{	//   
; 10851: 
; 10852: #ifdef DURABILITY_DOWN_CHANGE
; 10853: 		ret = lpObj->pInventory[EQUIPMENT_WING].DurabilityDown(7, lpObj->m_Index);
; 10854: #else
; 10855: 
; 10856: //#if TESTSERVER == 1
; 10857: //		ret = lpObj->pInventory[EQUIPMENT_WING].DurabilityDown(100, lpObj->m_Index);
; 10858: //#else
; 10859: 		ret = lpObj->pInventory[EQUIPMENT_WING].DurabilityDown(1, lpObj->m_Index);

  000d1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d6	51		 push	 ecx
  000d7	6a 01		 push	 1
  000d9	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  000de	6b ca 07	 imul	 ecx, edx, 7
  000e1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e4	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  000ea	e8 00 00 00 00	 call	 ?DurabilityDown@CItem@@QAEHHH@Z ; CItem::DurabilityDown
  000ef	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 10860: //#endif
; 10861: #endif
; 10862: 		if( ret )

  000f2	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000f6	74 2d		 je	 SHORT $LN6@gObjSecond

; 10863: 		{
; 10864: 			GCItemDurSend2(lpObj->m_Index, EQUIPMENT_WING, lpObj->pInventory[EQUIPMENT_WING].m_Durability, 0);			

  000f8	6a 00		 push	 0
  000fa	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000ff	6b c8 07	 imul	 ecx, eax, 7
  00102	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00105	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0010b	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  00111	0f b6 d1	 movzx	 edx, cl
  00114	52		 push	 edx
  00115	6a 07		 push	 7
  00117	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011c	51		 push	 ecx
  0011d	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  00122	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@gObjSecond:

; 10865: 		}
; 10866: 		if( ret == 2 )

  00125	83 7d fc 02	 cmp	 DWORD PTR _ret$[ebp], 2
  00129	75 07		 jne	 SHORT $LN7@gObjSecond

; 10867: 		{	
; 10868: 			reCalCharacter = TRUE;

  0012b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 1
$LN7@gObjSecond:

; 10869: 		}		
; 10870: 		//gObjWingDurProc(lpObj);
; 10871: 	}	
; 10872: 	
; 10873: 	if( !(attr & 0x01) )

  00132	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  00136	83 e0 01	 and	 eax, 1
  00139	0f 85 46 03 00
	00		 jne	 $LN28@gObjSecond

; 10874: 	{	//      
; 10875: 		if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].IsItem() == TRUE )

  0013f	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00144	6b c8 0a	 imul	 ecx, eax, 10
  00147	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0014a	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00150	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00155	83 f8 01	 cmp	 eax, 1
  00158	0f 85 31 01 00
	00		 jne	 $LN16@gObjSecond

; 10876: 		{
; 10877: #ifdef ADD_CRITICAL_WIZARD_RING_20090915		//    -   ()
; 10878: 			if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM(13, 107)
; 10879: 				)
; 10880: 			{				
; 10881: #ifdef PCBANG_ADVANTAGE // apple20050203
; 10882: 				
; 10883: #ifdef PCBANG_ADVANTAGE_EXPAND_20060919
; 10884: 				if( IsOKPCBangBenefitAll(lpObj) )
; 10885: #else
; 10886: 					if (lpObj->m_bPCBangUser)
; 10887: #endif //PCBANG_ADVANTAGE_EXPAND_20060919
; 10888: 					{
; 10889: 						ret = lpObj->pInventory[EQUIPMENT_RING_RIGHT].DurabilityDown(35, lpObj->m_Index);
; 10890: 					}
; 10891: 					else
; 10892: #endif
; 10893: 					{
; 10894: 						ret = lpObj->pInventory[EQUIPMENT_RING_RIGHT].DurabilityDown(70, lpObj->m_Index);	//  1 1  
; 10895: 					}
; 10896: 					
; 10897: 					if( ret )
; 10898: 					{
; 10899: 						GCItemDurSend2(lpObj->m_Index, EQUIPMENT_RING_RIGHT, lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability, 0);			
; 10900: 					}
; 10901: 					if( ret == 2 )
; 10902: 					{	
; 10903: 						reCalCharacter = TRUE;
; 10904: 					}
; 10905: 					
; 10906: 			} else
; 10907: 				
; 10908: #endif // ADD_CRITICAL_WIZARD_RING_20090915
; 10909: #ifdef RING_EVENT_ITEMBOX_20031124		//  -   ()
; 10910: 			if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM(13,20) &&

  0015e	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00163	6b c8 0a	 imul	 ecx, eax, 10
  00166	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00169	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0016f	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00174	6a 14		 push	 20			; 00000014H
  00176	6a 0d		 push	 13			; 0000000dH
  00178	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0017d	83 c4 08	 add	 esp, 8
  00180	3b f0		 cmp	 esi, eax
  00182	0f 85 80 00 00
	00		 jne	 $LN10@gObjSecond
  00188	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0018d	6b c8 0a	 imul	 ecx, eax, 10
  00190	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00193	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00199	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  0019e	85 c9		 test	 ecx, ecx
  001a0	75 66		 jne	 SHORT $LN10@gObjSecond

; 10911: 				lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Level == 0	//  
; 10912: 				)
; 10913: 			{
; 10914: 
; 10915: 	#ifdef PCBANG_ADVANTAGE // apple20050203
; 10916: 				
; 10917: 		#ifdef PCBANG_ADVANTAGE_EXPAND_20060919
; 10918: 				if( IsOKPCBangBenefitAll(lpObj) )
; 10919: 		#else
; 10920: 				if (lpObj->m_bPCBangUser)
; 10921: 		#endif //PCBANG_ADVANTAGE_EXPAND_20060919
; 10922: 				{
; 10923: 					ret = lpObj->pInventory[EQUIPMENT_RING_RIGHT].DurabilityDown(35, lpObj->m_Index);
; 10924: 				}
; 10925: 				else
; 10926: 	#endif
; 10927: 				{
; 10928: 					ret = lpObj->pInventory[EQUIPMENT_RING_RIGHT].DurabilityDown(70, lpObj->m_Index);	//  1 1  

  001a2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a7	51		 push	 ecx
  001a8	6a 46		 push	 70			; 00000046H
  001aa	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  001af	6b ca 0a	 imul	 ecx, edx, 10
  001b2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b5	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  001bb	e8 00 00 00 00	 call	 ?DurabilityDown@CItem@@QAEHHH@Z ; CItem::DurabilityDown
  001c0	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 10929: 				}
; 10930: 				
; 10931: 				if( ret )

  001c3	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  001c7	74 2d		 je	 SHORT $LN12@gObjSecond

; 10932: 				{
; 10933: 					GCItemDurSend2(lpObj->m_Index, EQUIPMENT_RING_RIGHT, lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability, 0);			

  001c9	6a 00		 push	 0
  001cb	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  001d0	6b c8 0a	 imul	 ecx, eax, 10
  001d3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001d6	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  001dc	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  001e2	0f b6 d1	 movzx	 edx, cl
  001e5	52		 push	 edx
  001e6	6a 0a		 push	 10			; 0000000aH
  001e8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ed	51		 push	 ecx
  001ee	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  001f3	83 c4 10	 add	 esp, 16			; 00000010H
$LN12@gObjSecond:

; 10934: 				}
; 10935: 				if( ret == 2 )

  001f6	83 7d fc 02	 cmp	 DWORD PTR _ret$[ebp], 2
  001fa	75 07		 jne	 SHORT $LN13@gObjSecond

; 10936: 				{	
; 10937: 					reCalCharacter = TRUE;

  001fc	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 1
$LN13@gObjSecond:

; 10938: 				}
; 10939: 
; 10940: 			} else

  00203	e9 87 00 00 00	 jmp	 $LN16@gObjSecond
$LN10@gObjSecond:

; 10941: 
; 10942: #endif
; 10943: #ifdef MU_CHN_THANKS_RING_EVENT_20040908	//   -   
; 10944: 			if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM(13,20) &&
; 10945: 				lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Level == 3	//  
; 10946: 				)
; 10947: 			{
; 10948: 				ret = lpObj->pInventory[EQUIPMENT_RING_RIGHT].DurabilityDown(70, lpObj->m_Index);	//  1 1  
; 10949: 				
; 10950: 				if( ret )
; 10951: 				{
; 10952: 					GCItemDurSend2(lpObj->m_Index, EQUIPMENT_RING_RIGHT, lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability, 0);			
; 10953: 				}
; 10954: 				if( ret == 2 )
; 10955: 				{	
; 10956: 					reCalCharacter = TRUE;
; 10957: 				}
; 10958: 
; 10959: 			} else
; 10960: 
; 10961: #endif
; 10962: #ifdef KANTURU_MOONSTONEPENDANT_20060804	//  .
; 10963: 			if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13 , 38 ) )
; 10964: 			{
; 10965: 				//  90 1  
; 10966: 				ret = lpObj->pInventory[EQUIPMENT_RING_RIGHT].DurabilityDown( 63, lpObj->m_Index );	
; 10967: 
; 10968: 				if( ret )
; 10969: 				{
; 10970: 					GCItemDurSend2( lpObj->m_Index, EQUIPMENT_RING_RIGHT, lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability, 0 );			
; 10971: 				}
; 10972: 			}
; 10973: 			else
; 10974: #endif				
; 10975: #ifdef MODIFY_CHANGE_RING_DURABILITY_BUGFIX_20080820	//     
; 10976: 			if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type != MAKE_ITEMNUM(13,10)
; 10977: 				&& lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type != MAKE_ITEMNUM(13, 39)
; 10978: 				&& lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type != MAKE_ITEMNUM(13, 40)
; 10979: 				&& lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type != MAKE_ITEMNUM(13, 41)
; 10980: 				&& lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type != MAKE_ITEMNUM(13, 42)
; 10981: 				)
; 10982: #else
; 10983: 			if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type != MAKE_ITEMNUM(13,10) )

  00208	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0020d	6b c8 0a	 imul	 ecx, eax, 10
  00210	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00213	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00219	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0021e	6a 0a		 push	 10			; 0000000aH
  00220	6a 0d		 push	 13			; 0000000dH
  00222	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00227	83 c4 08	 add	 esp, 8
  0022a	3b f0		 cmp	 esi, eax
  0022c	74 61		 je	 SHORT $LN16@gObjSecond

; 10984: #endif // MODIFY_CHANGE_RING_DURABILITY_BUGFIX_20080820
; 10985: 			{
; 10986: #ifdef DURABILITY_DOWN_CHANGE
; 10987: 				ret = lpObj->pInventory[EQUIPMENT_RING_RIGHT].DurabilityDown(7, lpObj->m_Index);
; 10988: #else
; 10989: //#if TESTSERVER == 1
; 10990: //				ret = lpObj->pInventory[EQUIPMENT_RING_RIGHT].DurabilityDown(100, lpObj->m_Index);
; 10991: //#else
; 10992: 				ret = lpObj->pInventory[EQUIPMENT_RING_RIGHT].DurabilityDown(1, lpObj->m_Index);

  0022e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00231	8b 08		 mov	 ecx, DWORD PTR [eax]
  00233	51		 push	 ecx
  00234	6a 01		 push	 1
  00236	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  0023b	6b ca 0a	 imul	 ecx, edx, 10
  0023e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00241	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00247	e8 00 00 00 00	 call	 ?DurabilityDown@CItem@@QAEHHH@Z ; CItem::DurabilityDown
  0024c	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 10993: //#endif
; 10994: #endif
; 10995: 				if( ret )

  0024f	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00253	74 2d		 je	 SHORT $LN15@gObjSecond

; 10996: 				{
; 10997: 					GCItemDurSend2(lpObj->m_Index, EQUIPMENT_RING_RIGHT, lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability, 0);			

  00255	6a 00		 push	 0
  00257	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0025c	6b c8 0a	 imul	 ecx, eax, 10
  0025f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00262	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00268	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  0026e	0f b6 d1	 movzx	 edx, cl
  00271	52		 push	 edx
  00272	6a 0a		 push	 10			; 0000000aH
  00274	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00277	8b 08		 mov	 ecx, DWORD PTR [eax]
  00279	51		 push	 ecx
  0027a	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  0027f	83 c4 10	 add	 esp, 16			; 00000010H
$LN15@gObjSecond:

; 10998: 				}
; 10999: 				if( ret == 2 )

  00282	83 7d fc 02	 cmp	 DWORD PTR _ret$[ebp], 2
  00286	75 07		 jne	 SHORT $LN16@gObjSecond

; 11000: 				{	
; 11001: 					reCalCharacter = TRUE;

  00288	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 1
$LN16@gObjSecond:

; 11002: 				}
; 11003: 			}
; 11004: 		}
; 11005: 		if( lpObj->pInventory[EQUIPMENT_RING_LEFT].IsItem() == TRUE )

  0028f	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00294	6b c8 0b	 imul	 ecx, eax, 11
  00297	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0029a	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  002a0	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  002a5	83 f8 01	 cmp	 eax, 1
  002a8	0f 85 31 01 00
	00		 jne	 $LN24@gObjSecond

; 11006: 		{
; 11007: #ifdef ADD_CRITICAL_WIZARD_RING_20090915		//    -   ()
; 11008: 			if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM(13, 107)
; 11009: 				)
; 11010: 			{
; 11011: #ifdef PCBANG_ADVANTAGE // apple20050203
; 11012: 				
; 11013: #ifdef PCBANG_ADVANTAGE_EXPAND_20060919
; 11014: 				if( IsOKPCBangBenefitAll(lpObj) )
; 11015: #else
; 11016: 					if (lpObj->m_bPCBangUser)
; 11017: #endif //PCBANG_ADVANTAGE_EXPAND_20060919
; 11018: 					{
; 11019: 						ret = lpObj->pInventory[EQUIPMENT_RING_LEFT].DurabilityDown(35, lpObj->m_Index);
; 11020: 					}
; 11021: 					else
; 11022: #endif
; 11023: 					{
; 11024: 						ret = lpObj->pInventory[EQUIPMENT_RING_LEFT].DurabilityDown(70, lpObj->m_Index);	//  1 1  
; 11025: 					}
; 11026: 					
; 11027: 					if( ret )
; 11028: 					{
; 11029: 						GCItemDurSend2(lpObj->m_Index, EQUIPMENT_RING_LEFT, lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability, 0);			
; 11030: 					}
; 11031: 					if( ret == 2 )
; 11032: 					{	
; 11033: 						reCalCharacter = TRUE;
; 11034: 					}					
; 11035: 			} else				
; 11036: #endif // ADD_CRITICAL_WIZARD_RING_20090915
; 11037: #ifdef RING_EVENT_ITEMBOX_20031124		//  -   ()
; 11038: 			if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM(13,20) &&

  002ae	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  002b3	6b c8 0b	 imul	 ecx, eax, 11
  002b6	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002b9	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  002bf	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  002c4	6a 14		 push	 20			; 00000014H
  002c6	6a 0d		 push	 13			; 0000000dH
  002c8	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002cd	83 c4 08	 add	 esp, 8
  002d0	3b f0		 cmp	 esi, eax
  002d2	0f 85 80 00 00
	00		 jne	 $LN18@gObjSecond
  002d8	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  002dd	6b c8 0b	 imul	 ecx, eax, 11
  002e0	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002e3	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  002e9	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  002ee	85 c9		 test	 ecx, ecx
  002f0	75 66		 jne	 SHORT $LN18@gObjSecond

; 11039: 				lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Level == 0	//  
; 11040: 				)
; 11041: 			{
; 11042: 		#ifdef PCBANG_ADVANTAGE // apple20050203
; 11043: 				
; 11044: 			#ifdef PCBANG_ADVANTAGE_EXPAND_20060919
; 11045: 				if( IsOKPCBangBenefitAll(lpObj) )
; 11046: 			#else
; 11047: 				if (lpObj->m_bPCBangUser)
; 11048: 			#endif //PCBANG_ADVANTAGE_EXPAND_20060919
; 11049: 				{
; 11050: 					ret = lpObj->pInventory[EQUIPMENT_RING_LEFT].DurabilityDown(35, lpObj->m_Index);
; 11051: 				}
; 11052: 				else
; 11053: 		#endif
; 11054: 				{
; 11055: 					ret = lpObj->pInventory[EQUIPMENT_RING_LEFT].DurabilityDown(70, lpObj->m_Index);	//  1 1  

  002f2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002f5	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f7	51		 push	 ecx
  002f8	6a 46		 push	 70			; 00000046H
  002fa	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  002ff	6b ca 0b	 imul	 ecx, edx, 11
  00302	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00305	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0030b	e8 00 00 00 00	 call	 ?DurabilityDown@CItem@@QAEHHH@Z ; CItem::DurabilityDown
  00310	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 11056: 				}
; 11057: 				
; 11058: 				if( ret )

  00313	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00317	74 2d		 je	 SHORT $LN20@gObjSecond

; 11059: 				{
; 11060: 					GCItemDurSend2(lpObj->m_Index, EQUIPMENT_RING_LEFT, lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability, 0);			

  00319	6a 00		 push	 0
  0031b	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00320	6b c8 0b	 imul	 ecx, eax, 11
  00323	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00326	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0032c	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  00332	0f b6 d1	 movzx	 edx, cl
  00335	52		 push	 edx
  00336	6a 0b		 push	 11			; 0000000bH
  00338	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0033b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0033d	51		 push	 ecx
  0033e	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  00343	83 c4 10	 add	 esp, 16			; 00000010H
$LN20@gObjSecond:

; 11061: 				}
; 11062: 				if( ret == 2 )

  00346	83 7d fc 02	 cmp	 DWORD PTR _ret$[ebp], 2
  0034a	75 07		 jne	 SHORT $LN21@gObjSecond

; 11063: 				{	
; 11064: 					reCalCharacter = TRUE;

  0034c	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 1
$LN21@gObjSecond:

; 11065: 				}
; 11066: 
; 11067: 			} else

  00353	e9 87 00 00 00	 jmp	 $LN24@gObjSecond
$LN18@gObjSecond:

; 11068: 
; 11069: #endif
; 11070: #ifdef MU_CHN_THANKS_RING_EVENT_20040908	//   -   
; 11071: 			if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM(13,20) &&
; 11072: 				lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Level == 3	//  
; 11073: 				)
; 11074: 			{
; 11075: 				ret = lpObj->pInventory[EQUIPMENT_RING_LEFT].DurabilityDown(70, lpObj->m_Index);	//  1 1  
; 11076: 				
; 11077: 				if( ret )
; 11078: 				{
; 11079: 					GCItemDurSend2(lpObj->m_Index, EQUIPMENT_RING_LEFT, lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability, 0);			
; 11080: 				}
; 11081: 				if( ret == 2 )
; 11082: 				{	
; 11083: 					reCalCharacter = TRUE;
; 11084: 				}
; 11085: 
; 11086: 			} else
; 11087: #endif
; 11088: #ifdef KANTURU_MOONSTONEPENDANT_20060804	//  .
; 11089: 			if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13 , 38 ) )
; 11090: 			{
; 11091: 				//  90 1  
; 11092: 				ret = lpObj->pInventory[EQUIPMENT_RING_LEFT].DurabilityDown( 63, lpObj->m_Index );	
; 11093: 				
; 11094: 				if( ret )
; 11095: 				{
; 11096: 					GCItemDurSend2( lpObj->m_Index, EQUIPMENT_RING_LEFT, lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability, 0 );			
; 11097: 				}
; 11098: 			}
; 11099: 			else
; 11100: #endif
; 11101: #ifdef MODIFY_CHANGE_RING_DURABILITY_BUGFIX_20080820	//     
; 11102: 			if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type != MAKE_ITEMNUM(13,10)
; 11103: 				&& lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type != MAKE_ITEMNUM(13, 39)
; 11104: 				&& lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type != MAKE_ITEMNUM(13, 40)
; 11105: 				&& lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type != MAKE_ITEMNUM(13, 41)
; 11106: 				&& lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type != MAKE_ITEMNUM(13, 42)
; 11107: 				)
; 11108: #else
; 11109: 			if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type != MAKE_ITEMNUM(13,10) )

  00358	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0035d	6b c8 0b	 imul	 ecx, eax, 11
  00360	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00363	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00369	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0036e	6a 0a		 push	 10			; 0000000aH
  00370	6a 0d		 push	 13			; 0000000dH
  00372	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00377	83 c4 08	 add	 esp, 8
  0037a	3b f0		 cmp	 esi, eax
  0037c	74 61		 je	 SHORT $LN24@gObjSecond

; 11110: #endif // MODIFY_CHANGE_RING_DURABILITY_BUGFIX_20080820
; 11111: 			{
; 11112: #ifdef DURABILITY_DOWN_CHANGE
; 11113: 				ret = lpObj->pInventory[EQUIPMENT_RING_LEFT].DurabilityDown(7, lpObj->m_Index);
; 11114: #else
; 11115: //#if TESTSERVER == 1
; 11116: //				ret = lpObj->pInventory[EQUIPMENT_RING_LEFT].DurabilityDown(100, lpObj->m_Index);
; 11117: //#else
; 11118: 				ret = lpObj->pInventory[EQUIPMENT_RING_LEFT].DurabilityDown(1, lpObj->m_Index);

  0037e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00381	8b 08		 mov	 ecx, DWORD PTR [eax]
  00383	51		 push	 ecx
  00384	6a 01		 push	 1
  00386	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  0038b	6b ca 0b	 imul	 ecx, edx, 11
  0038e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00391	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00397	e8 00 00 00 00	 call	 ?DurabilityDown@CItem@@QAEHHH@Z ; CItem::DurabilityDown
  0039c	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 11119: //#endif
; 11120: #endif
; 11121: 				if( ret )

  0039f	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  003a3	74 2d		 je	 SHORT $LN23@gObjSecond

; 11122: 				{
; 11123: 					GCItemDurSend2(lpObj->m_Index, EQUIPMENT_RING_LEFT, lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability, 0);			

  003a5	6a 00		 push	 0
  003a7	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  003ac	6b c8 0b	 imul	 ecx, eax, 11
  003af	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003b2	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  003b8	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  003be	0f b6 d1	 movzx	 edx, cl
  003c1	52		 push	 edx
  003c2	6a 0b		 push	 11			; 0000000bH
  003c4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c9	51		 push	 ecx
  003ca	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  003cf	83 c4 10	 add	 esp, 16			; 00000010H
$LN23@gObjSecond:

; 11124: 				}
; 11125: 				if( ret == 2 )

  003d2	83 7d fc 02	 cmp	 DWORD PTR _ret$[ebp], 2
  003d6	75 07		 jne	 SHORT $LN24@gObjSecond

; 11126: 				{	
; 11127: 					reCalCharacter = TRUE;

  003d8	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 1
$LN24@gObjSecond:

; 11128: 				}
; 11129: 			}
; 11130: 		}
; 11131: 
; 11132: 		if( lpObj->pInventory[EQUIPMENT_AMULET].IsItem() == TRUE )

  003df	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  003e4	6b c8 09	 imul	 ecx, eax, 9
  003e7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003ea	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  003f0	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  003f5	83 f8 01	 cmp	 eax, 1
  003f8	0f 85 87 00 00
	00		 jne	 $LN28@gObjSecond

; 11133: 		{	// 
; 11134: 			if( lpObj->pInventory[EQUIPMENT_AMULET].m_Type != MAKE_ITEMNUM(13,10) )

  003fe	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00403	6b c8 09	 imul	 ecx, eax, 9
  00406	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00409	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0040f	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00414	6a 0a		 push	 10			; 0000000aH
  00416	6a 0d		 push	 13			; 0000000dH
  00418	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0041d	83 c4 08	 add	 esp, 8
  00420	3b f0		 cmp	 esi, eax
  00422	74 61		 je	 SHORT $LN28@gObjSecond

; 11135: 			{
; 11136: #ifdef DURABILITY_DOWN_CHANGE
; 11137: 				ret = lpObj->pInventory[EQUIPMENT_AMULET].DurabilityDown(7, lpObj->m_Index);
; 11138: #else
; 11139: //#if TESTSERVER == 1
; 11140: //				ret = lpObj->pInventory[EQUIPMENT_AMULET].DurabilityDown(100, lpObj->m_Index);
; 11141: //#else
; 11142: 				ret = lpObj->pInventory[EQUIPMENT_AMULET].DurabilityDown(1, lpObj->m_Index);

  00424	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00427	8b 08		 mov	 ecx, DWORD PTR [eax]
  00429	51		 push	 ecx
  0042a	6a 01		 push	 1
  0042c	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  00431	6b ca 09	 imul	 ecx, edx, 9
  00434	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00437	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0043d	e8 00 00 00 00	 call	 ?DurabilityDown@CItem@@QAEHHH@Z ; CItem::DurabilityDown
  00442	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 11143: //#endif
; 11144: #endif
; 11145: 				if( ret )

  00445	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00449	74 2d		 je	 SHORT $LN27@gObjSecond

; 11146: 				{
; 11147: 					GCItemDurSend2(lpObj->m_Index, EQUIPMENT_AMULET, lpObj->pInventory[EQUIPMENT_AMULET].m_Durability, 0);			

  0044b	6a 00		 push	 0
  0044d	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00452	6b c8 09	 imul	 ecx, eax, 9
  00455	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00458	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0045e	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  00464	0f b6 d1	 movzx	 edx, cl
  00467	52		 push	 edx
  00468	6a 09		 push	 9
  0046a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0046d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0046f	51		 push	 ecx
  00470	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  00475	83 c4 10	 add	 esp, 16			; 00000010H
$LN27@gObjSecond:

; 11148: 				}
; 11149: 				if( ret == 2 )

  00478	83 7d fc 02	 cmp	 DWORD PTR _ret$[ebp], 2
  0047c	75 07		 jne	 SHORT $LN28@gObjSecond

; 11150: 				{	
; 11151: 					reCalCharacter = TRUE;

  0047e	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 1
$LN28@gObjSecond:

; 11152: 				}
; 11153: 			}
; 11154: 		}
; 11155: 
; 11156: 	}
; 11157: 
; 11158: #ifdef DURABILITY_DOWN_CHANGE	//    ( , )
; 11159: 	if( !(attr & 0x01) )
; 11160: 	{
; 11161: 		//   
; 11162: 		int irand = rand()%2;
; 11163: 		CItem	*Weapon = &lpObj->pInventory[irand];
; 11164: 		ret = 0;
; 11165: 		int decdur = 50;	// 1 0.3
; 11166: 
; 11167: 		if( Weapon->m_Type != MAKE_ITEMNUM(4,7) && Weapon->m_Type != MAKE_ITEMNUM(4,15) )
; 11168: 		{	//;   		
; 11169: 			if( (Weapon->m_Type < ITEM_SHIELD && Weapon->m_Type >= ITEM_HELM) )
; 11170: 			{	//  
; 11171: 				if( Weapon->IsItem() )
; 11172: 				{
; 11173: 					ret = Weapon->DurabilityDown2(decdur, lpObj->m_Index);
; 11174: 				}
; 11175: 			}
; 11176: 			else
; 11177: 			{			
; 11178: 				CItem	*Weapon = &lpObj->pInventory[irand];
; 11179: 				if( Weapon->IsItem() )
; 11180: 				{
; 11181: 					ret = Weapon->DurabilityDown2(decdur, lpObj->m_Index);
; 11182: 				}
; 11183: 			}		
; 11184: 		}
; 11185: 		
; 11186: 		decdur = 50;	// 1 0.2
; 11187: 		if( ret )
; 11188: 		{
; 11189: 			GCItemDurSend2(lpObj->m_Index, irand, lpObj->pInventory[irand].m_Durability, 0);			
; 11190: 		}
; 11191: 		if( ret == 2 )
; 11192: 		{	
; 11193: 			reCalCharacter = TRUE;
; 11194: 		}
; 11195: 
; 11196: 		//   
; 11197: 		int item_num[7] = {EQUIPMENT_WEAPON_RIGHT, EQUIPMENT_WEAPON_LEFT, EQUIPMENT_HELM, EQUIPMENT_ARMOR,EQUIPMENT_PANTS, EQUIPMENT_GLOVES, EQUIPMENT_BOOTS};
; 11198: 		int item_pos = rand()%7;
; 11199: 
; 11200: 		CItem	*DurItem = &lpObj->pInventory[item_num[item_pos]];
; 11201: 
; 11202: 		//     .
; 11203: 		if( item_pos < 2 )
; 11204: 		{
; 11205: 			if( (DurItem->m_Type >= ITEM_SHIELD && DurItem->m_Type < ITEM_HELM) )
; 11206: 			{	// 
; 11207: 				ret = DurItem->DurabilityDown2(decdur, lpObj->m_Index);
; 11208: 				if( ret )
; 11209: 				{	//    
; 11210: 					GCItemDurSend2(lpObj->m_Index, item_num[item_pos], DurItem->m_Durability, 0);
; 11211: 					if( ret == 2 )
; 11212: 					{	//    
; 11213: 						reCalCharacter = TRUE;
; 11214: 					}
; 11215: 				}				
; 11216: 			}		
; 11217: 		}
; 11218: 		else
; 11219: 		{
; 11220: 			ret = DurItem->DurabilityDown2(decdur, lpObj->m_Index);
; 11221: 			if( ret )
; 11222: 			{	//    
; 11223: 				GCItemDurSend2(lpObj->m_Index, item_num[item_pos], DurItem->m_Durability, 0);
; 11224: 				if( ret == 2 )
; 11225: 				{	//    
; 11226: 					reCalCharacter = TRUE;
; 11227: 				}
; 11228: 			}
; 11229: 		}
; 11230: 
; 11231: 		if( reCalCharacter )
; 11232: 		{	//         
; 11233: 			gObjCalCharacter(lpObj->m_Index);
; 11234: 		}
; 11235: 	}
; 11236: #endif
; 11237: 
; 11238: 
; 11239: 	if( reCalCharacter )

  00485	83 7d f8 00	 cmp	 DWORD PTR _reCalCharacter$[ebp], 0
  00489	74 0e		 je	 SHORT $LN29@gObjSecond

; 11240: 	{	//         
; 11241: 		gObjCalCharacter(lpObj->m_Index);

  0048b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0048e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00490	51		 push	 ecx
  00491	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00496	83 c4 04	 add	 esp, 4
$LN29@gObjSecond:
$LN1@gObjSecond:

; 11242: 	}
; 11243: }

  00499	5f		 pop	 edi
  0049a	5e		 pop	 esi
  0049b	5b		 pop	 ebx
  0049c	8b e5		 mov	 esp, ebp
  0049e	5d		 pop	 ebp
  0049f	c3		 ret	 0
?gObjSecondDurDown@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; gObjSecondDurDown
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjPkDownTimeCheck@@YAXPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_dwtime$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_TargetLevel$ = 12					; size = 4
?gObjPkDownTimeCheck@@YAXPAVOBJECTSTRUCT@@H@Z PROC	; gObjPkDownTimeCheck, COMDAT

; 10130: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 10131: 	if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT ) return;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  00013	83 f9 03	 cmp	 ecx, 3
  00016	75 05		 jne	 SHORT $LN2@gObjPkDown
  00018	e9 fa 02 00 00	 jmp	 $LN1@gObjPkDown
$LN2@gObjPkDown:

; 10132: 	
; 10133: 
; 10134: 	DWORD dwtime = ((GetTickCount()-lpObj->m_dwPKTimer)/1000)*gPkTime;

  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00026	2b 41 58	 sub	 eax, DWORD PTR [ecx+88]
  00029	33 d2		 xor	 edx, edx
  0002b	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00030	f7 f1		 div	 ecx
  00032	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?gPkTime@@3HA ; gPkTime
  00039	89 45 fc	 mov	 DWORD PTR _dwtime$[ebp], eax

; 10135: 	if( dwtime > 5 )

  0003c	83 7d fc 05	 cmp	 DWORD PTR _dwtime$[ebp], 5
  00040	76 15		 jbe	 SHORT $LN3@gObjPkDown

; 10136: 	{
; 10137: 		dwtime = 2;

  00042	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _dwtime$[ebp], 2

; 10138: 		lpObj->m_dwPKTimer = GetTickCount();

  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00052	89 41 58	 mov	 DWORD PTR [ecx+88], eax

; 10139: 	}

  00055	eb 0d		 jmp	 SHORT $LN4@gObjPkDown
$LN3@gObjPkDown:

; 10140: 	else
; 10141: 	{
; 10142: 		lpObj->m_dwPKTimer = + dwtime*1000;

  00057	69 45 fc e8 03
	00 00		 imul	 eax, DWORD PTR _dwtime$[ebp], 1000
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00061	89 41 58	 mov	 DWORD PTR [ecx+88], eax
$LN4@gObjPkDown:

; 10143: 	}
; 10144: 
; 10145: 	//LogAdd("PK Time = %d", dwtime);
; 10146: 
; 10147: 	if( TargetLevel < 2 ) lpObj->m_PK_Time+=dwtime;

  00064	83 7d 0c 02	 cmp	 DWORD PTR _TargetLevel$[ebp], 2
  00068	7d 17		 jge	 SHORT $LN5@gObjPkDown
  0006a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006d	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [eax+256]
  00073	03 4d fc	 add	 ecx, DWORD PTR _dwtime$[ebp]
  00076	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00079	89 8a 00 01 00
	00		 mov	 DWORD PTR [edx+256], ecx
  0007f	eb 15		 jmp	 SHORT $LN6@gObjPkDown
$LN5@gObjPkDown:

; 10148: 	//if( TargetLevel < 2 ) lpObj->m_PK_Time+=0;
; 10149: #ifdef UPDATE_PK_SYSTEM_20070302	//    
; 10150: 	else lpObj->m_PK_Time += (int)(TargetLevel / 2);
; 10151: #else
; 10152: 	else lpObj->m_PK_Time += TargetLevel;

  00081	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00084	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [eax+256]
  0008a	03 4d 0c	 add	 ecx, DWORD PTR _TargetLevel$[ebp]
  0008d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00090	89 8a 00 01 00
	00		 mov	 DWORD PTR [edx+256], ecx
$LN6@gObjPkDown:

; 10153: #endif
; 10154: 
; 10155: 	if( lpObj->m_PK_Level < PK_LEVEL_DEFAULT )	// 

  00096	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00099	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  000a0	83 f9 03	 cmp	 ecx, 3
  000a3	7d 7d		 jge	 SHORT $LN7@gObjPkDown

; 10156: 	{
; 10157: 		if( lpObj->m_PK_Time > PK_LEVEL_UP_TIME )

  000a5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a8	81 b8 00 01 00
	00 10 0e 00 00	 cmp	 DWORD PTR [eax+256], 3600 ; 00000e10H
  000b2	7e 69		 jle	 SHORT $LN9@gObjPkDown

; 10158: 		{
; 10159: 			lpObj->m_PK_Time  = 0;

  000b4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b7	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0

; 10160: 			lpObj->m_PK_Count++;

  000c1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c4	8a 88 fc 00 00
	00		 mov	 cl, BYTE PTR [eax+252]
  000ca	80 c1 01	 add	 cl, 1
  000cd	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000d0	88 8a fc 00 00
	00		 mov	 BYTE PTR [edx+252], cl

; 10161: 			if( lpObj->m_PK_Count > 100 ) lpObj->m_PK_Count = 100;

  000d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d9	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  000e0	83 f9 64	 cmp	 ecx, 100		; 00000064H
  000e3	7e 0a		 jle	 SHORT $LN10@gObjPkDown
  000e5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e8	c6 80 fc 00 00
	00 64		 mov	 BYTE PTR [eax+252], 100	; 00000064H
$LN10@gObjPkDown:

; 10162: 			lpObj->m_PK_Level++;

  000ef	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f2	8a 88 fd 00 00
	00		 mov	 cl, BYTE PTR [eax+253]
  000f8	80 c1 01	 add	 cl, 1
  000fb	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000fe	88 8a fd 00 00
	00		 mov	 BYTE PTR [edx+253], cl

; 10163: 			GCPkLevelSend(lpObj->m_Index, lpObj->m_PK_Level);

  00104	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00107	0f b6 88 fd 00
	00 00		 movzx	 ecx, BYTE PTR [eax+253]
  0010e	51		 push	 ecx
  0010f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00112	8b 02		 mov	 eax, DWORD PTR [edx]
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 ?GCPkLevelSend@@YAXHE@Z	; GCPkLevelSend
  0011a	83 c4 08	 add	 esp, 8
$LN9@gObjPkDown:

; 10164: 		}
; 10165: 	}

  0011d	e9 f5 01 00 00	 jmp	 $LN1@gObjPkDown
$LN7@gObjPkDown:

; 10166: 	else if( lpObj->m_PK_Level > PK_LEVEL_DEFAULT )	//   

  00122	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00125	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  0012c	83 f9 03	 cmp	 ecx, 3
  0012f	0f 8e e2 01 00
	00		 jle	 $LN1@gObjPkDown

; 10167: 	{
; 10168: 		if( lpObj->m_PK_Count > 3 )	//  3    ..

  00135	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00138	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  0013f	83 f9 03	 cmp	 ecx, 3
  00142	0f 8e ea 00 00
	00		 jle	 $LN12@gObjPkDown

; 10169: 		{
; 10170: 			if( lpObj->m_PK_Time > PK_LEVEL_DOWN_TIME1 )

  00148	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014b	81 b8 00 01 00
	00 10 0e 00 00	 cmp	 DWORD PTR [eax+256], 3600 ; 00000e10H
  00155	0f 8e d2 00 00
	00		 jle	 $LN14@gObjPkDown

; 10171: 			{
; 10172: 				lpObj->m_PK_Time  = 0;

  0015b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0015e	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0

; 10173: 				lpObj->m_PK_Count--;

  00168	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016b	8a 88 fc 00 00
	00		 mov	 cl, BYTE PTR [eax+252]
  00171	80 e9 01	 sub	 cl, 1
  00174	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00177	88 8a fc 00 00
	00		 mov	 BYTE PTR [edx+252], cl

; 10174: 				if( lpObj->m_PK_Count <=0 ) {

  0017d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00180	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  00187	85 c9		 test	 ecx, ecx
  00189	7f 16		 jg	 SHORT $LN15@gObjPkDown

; 10175: 					lpObj->m_PK_Count = 0;

  0018b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0018e	c6 80 fc 00 00
	00 00		 mov	 BYTE PTR [eax+252], 0

; 10176: 					lpObj->m_PK_Level = PK_LEVEL_DEFAULT;

  00195	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00198	c6 80 fd 00 00
	00 03		 mov	 BYTE PTR [eax+253], 3

; 10177: 				}

  0019f	eb 34		 jmp	 SHORT $LN16@gObjPkDown
$LN15@gObjPkDown:

; 10178: 				else if( lpObj->m_PK_Count == 2 )

  001a1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a4	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  001ab	83 f9 02	 cmp	 ecx, 2
  001ae	75 0c		 jne	 SHORT $LN17@gObjPkDown

; 10179: 				{
; 10180: 					lpObj->m_PK_Level = PK_LEVEL_DEFAULT+2;

  001b0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b3	c6 80 fd 00 00
	00 05		 mov	 BYTE PTR [eax+253], 5

; 10181: 				}

  001ba	eb 19		 jmp	 SHORT $LN16@gObjPkDown
$LN17@gObjPkDown:

; 10182: 				else if( lpObj->m_PK_Count == 1 )

  001bc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001bf	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  001c6	83 f9 01	 cmp	 ecx, 1
  001c9	75 0a		 jne	 SHORT $LN16@gObjPkDown

; 10183: 				{
; 10184: 					lpObj->m_PK_Level = PK_LEVEL_DEFAULT+1;

  001cb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ce	c6 80 fd 00 00
	00 04		 mov	 BYTE PTR [eax+253], 4
$LN16@gObjPkDown:

; 10185: 				}
; 10186: 				//   2   .
; 10187: 				if( lpObj->m_PK_Level <= PK_LEVEL_DEFAULT+2 )

  001d5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d8	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  001df	83 f9 05	 cmp	 ecx, 5
  001e2	7f 19		 jg	 SHORT $LN20@gObjPkDown

; 10188: 				{
; 10189: 					GCPkLevelSend(lpObj->m_Index, lpObj->m_PK_Level);

  001e4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e7	0f b6 88 fd 00
	00 00		 movzx	 ecx, BYTE PTR [eax+253]
  001ee	51		 push	 ecx
  001ef	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001f2	8b 02		 mov	 eax, DWORD PTR [edx]
  001f4	50		 push	 eax
  001f5	e8 00 00 00 00	 call	 ?GCPkLevelSend@@YAXHE@Z	; GCPkLevelSend
  001fa	83 c4 08	 add	 esp, 8
$LN20@gObjPkDown:

; 10190: 				}			
; 10191: 				if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT+1 )

  001fd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00200	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  00207	83 f9 04	 cmp	 ecx, 4
  0020a	75 21		 jne	 SHORT $LN14@gObjPkDown

; 10192: 				{	
; 10193: 					GCServerMsgStringSend(lMsg.Get(1137), lpObj->m_Index, 1);

  0020c	6a 01		 push	 1
  0020e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00211	8b 08		 mov	 ecx, DWORD PTR [eax]
  00213	51		 push	 ecx
  00214	68 71 04 00 00	 push	 1137			; 00000471H
  00219	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0021e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00224	50		 push	 eax
  00225	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0022a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@gObjPkDown:

; 10194: 
; 10195: #ifdef UPDATE_PK_SYSTEM_20070302	//     
; 10196: 					if(lpObj->PartyNumber >= 0)	//    
; 10197: 					{
; 10198: 						gParty.UpdatePKUserInfo(lpObj->PartyNumber, lpObj->m_Index, lpObj->DBNumber, lpObj->m_PK_Level);
; 10199: 						gParty.UpdatePKPartyPanalty(lpObj->PartyNumber);
; 10200: 					}
; 10201: #endif
; 10202: 				}
; 10203: 			}
; 10204: 		}

  0022d	e9 e5 00 00 00	 jmp	 $LN1@gObjPkDown
$LN12@gObjPkDown:

; 10205: 		else 
; 10206: 		{
; 10207: #ifdef HERO_SYSTEM_MODIFY
; 10208: 			switch(lpObj->m_PK_Count) {
; 10209: 			case 3 :	// PK 3 - 15  
; 10210: 				{
; 10211: 					if( lpObj->m_PK_Time > PK_COUNT_3_TIME - PK_COUNT_2_TIME)
; 10212: 					{
; 10213: 						lpObj->m_PK_Time  = 0;
; 10214: 						lpObj->m_PK_Count--;
; 10215: 						lpObj->m_PK_Level = PK_LEVEL_DEFAULT+2;
; 10216: 
; 10217: 						GCPkLevelSend(lpObj->m_Index, lpObj->m_PK_Level);
; 10218: 					}
; 10219: 				}
; 10220: 				break;
; 10221: 			case 2 :	// PK 2 - 8  
; 10222: 				{
; 10223: 					if( lpObj->m_PK_Time > PK_COUNT_2_TIME - PK_COUNT_1_TIME)
; 10224: 					{
; 10225: 						lpObj->m_PK_Time  = 0;
; 10226: 						lpObj->m_PK_Count--;
; 10227: 						lpObj->m_PK_Level = PK_LEVEL_DEFAULT+1;
; 10228: 						
; 10229: 						GCPkLevelSend(lpObj->m_Index, lpObj->m_PK_Level);
; 10230: 						GCServerMsgStringSend(lMsg.Get(1137), lpObj->m_Index, 1);
; 10231: 					}
; 10232: 				}
; 10233: 				break;
; 10234: 			case 1 :	// PK 1 - 3  
; 10235: 				{
; 10236: 					if( lpObj->m_PK_Time > PK_COUNT_1_TIME )
; 10237: 					{
; 10238: 						lpObj->m_PK_Time  = 0;
; 10239: 						lpObj->m_PK_Count--;
; 10240: 						lpObj->m_PK_Level = PK_LEVEL_DEFAULT;
; 10241: 
; 10242: 						GCPkLevelSend(lpObj->m_Index, lpObj->m_PK_Level);
; 10243: 					}
; 10244: 				}
; 10245: 				break;
; 10246: 			default:	// PK 1  ???
; 10247: 				{
; 10248: 					lpObj->m_PK_Count = 0;
; 10249: 					lpObj->m_PK_Level = PK_LEVEL_DEFAULT;
; 10250: 
; 10251: 					LogAddTD("[PK_Timer] Error : PK Count < 0 = %d  [%s][%s]",
; 10252: 							lpObj->m_PK_Count,
; 10253: 							lpObj->AccountID,
; 10254: 							lpObj->Name
; 10255: 						);
; 10256: 				}
; 10257: 				break;
; 10258: 			}
; 10259: 
; 10260: #else
; 10261: 			if( lpObj->m_PK_Time > PK_LEVEL_DOWN_TIME )

  00232	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00235	81 b8 00 01 00
	00 30 2a 00 00	 cmp	 DWORD PTR [eax+256], 10800 ; 00002a30H
  0023f	0f 8e d2 00 00
	00		 jle	 $LN1@gObjPkDown

; 10262: 			{
; 10263: 				lpObj->m_PK_Time  = 0;

  00245	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00248	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0

; 10264: 				lpObj->m_PK_Count--;

  00252	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00255	8a 88 fc 00 00
	00		 mov	 cl, BYTE PTR [eax+252]
  0025b	80 e9 01	 sub	 cl, 1
  0025e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00261	88 8a fc 00 00
	00		 mov	 BYTE PTR [edx+252], cl

; 10265: 				if( lpObj->m_PK_Count <=0 ) {

  00267	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0026a	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  00271	85 c9		 test	 ecx, ecx
  00273	7f 16		 jg	 SHORT $LN23@gObjPkDown

; 10266: 					lpObj->m_PK_Count = 0;

  00275	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00278	c6 80 fc 00 00
	00 00		 mov	 BYTE PTR [eax+252], 0

; 10267: 					lpObj->m_PK_Level = PK_LEVEL_DEFAULT;

  0027f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00282	c6 80 fd 00 00
	00 03		 mov	 BYTE PTR [eax+253], 3

; 10268: 				}

  00289	eb 34		 jmp	 SHORT $LN24@gObjPkDown
$LN23@gObjPkDown:

; 10269: 				else if( lpObj->m_PK_Count == 2 )

  0028b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028e	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  00295	83 f9 02	 cmp	 ecx, 2
  00298	75 0c		 jne	 SHORT $LN25@gObjPkDown

; 10270: 				{
; 10271: 					lpObj->m_PK_Level = PK_LEVEL_DEFAULT+2;

  0029a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0029d	c6 80 fd 00 00
	00 05		 mov	 BYTE PTR [eax+253], 5

; 10272: 				}

  002a4	eb 19		 jmp	 SHORT $LN24@gObjPkDown
$LN25@gObjPkDown:

; 10273: 				else if( lpObj->m_PK_Count == 1 )

  002a6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a9	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  002b0	83 f9 01	 cmp	 ecx, 1
  002b3	75 0a		 jne	 SHORT $LN24@gObjPkDown

; 10274: 				{
; 10275: 					lpObj->m_PK_Level = PK_LEVEL_DEFAULT+1;

  002b5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002b8	c6 80 fd 00 00
	00 04		 mov	 BYTE PTR [eax+253], 4
$LN24@gObjPkDown:

; 10276: 				}
; 10277: 				//   2   .
; 10278: 				if( lpObj->m_PK_Level <= PK_LEVEL_DEFAULT+2 )

  002bf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c2	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  002c9	83 f9 05	 cmp	 ecx, 5
  002cc	7f 19		 jg	 SHORT $LN28@gObjPkDown

; 10279: 				{
; 10280: 					GCPkLevelSend(lpObj->m_Index, lpObj->m_PK_Level);

  002ce	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d1	0f b6 88 fd 00
	00 00		 movzx	 ecx, BYTE PTR [eax+253]
  002d8	51		 push	 ecx
  002d9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002dc	8b 02		 mov	 eax, DWORD PTR [edx]
  002de	50		 push	 eax
  002df	e8 00 00 00 00	 call	 ?GCPkLevelSend@@YAXHE@Z	; GCPkLevelSend
  002e4	83 c4 08	 add	 esp, 8
$LN28@gObjPkDown:

; 10281: 				}			
; 10282: 				if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT+1 )

  002e7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ea	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  002f1	83 f9 04	 cmp	 ecx, 4
  002f4	75 21		 jne	 SHORT $LN1@gObjPkDown

; 10283: 				{	
; 10284: 					GCServerMsgStringSend(lMsg.Get(1137), lpObj->m_Index, 1);

  002f6	6a 01		 push	 1
  002f8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002fb	8b 08		 mov	 ecx, DWORD PTR [eax]
  002fd	51		 push	 ecx
  002fe	68 71 04 00 00	 push	 1137			; 00000471H
  00303	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00308	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0030e	50		 push	 eax
  0030f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00314	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjPkDown:

; 10285: 
; 10286: #ifdef UPDATE_PK_SYSTEM_20070302	//     
; 10287: 					if(lpObj->PartyNumber >= 0)	//    
; 10288: 					{
; 10289: 						gParty.UpdatePKUserInfo(lpObj->PartyNumber, lpObj->m_Index, lpObj->DBNumber, lpObj->m_PK_Level);
; 10290: 						gParty.UpdatePKPartyPanalty(lpObj->PartyNumber);
; 10291: 					}
; 10292: #endif
; 10293: 				}
; 10294: 			}
; 10295: #endif			
; 10296: 		}
; 10297: 	}	
; 10298: }

  00317	5f		 pop	 edi
  00318	5e		 pop	 esi
  00319	5b		 pop	 ebx
  0031a	8b e5		 mov	 esp, ebp
  0031c	5d		 pop	 ebp
  0031d	c3		 ret	 0
?gObjPkDownTimeCheck@@YAXPAVOBJECTSTRUCT@@H@Z ENDP	; gObjPkDownTimeCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInterfaceTimeCheck@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_TimeCheck$ = -8					; size = 4
_tObjNum$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjInterfaceTimeCheck@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjInterfaceTimeCheck, COMDAT

; 10077: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 10078: 	int tObjNum;
; 10079: 	int TimeCheck=0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _TimeCheck$[ebp], 0

; 10080: 	if( !lpObj->m_IfState.use ) return;

  00010	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00013	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00019	80 e1 03	 and	 cl, 3
  0001c	0f b6 d1	 movzx	 edx, cl
  0001f	85 d2		 test	 edx, edx
  00021	75 05		 jne	 SHORT $LN2@gObjInterf
  00023	e9 6a 01 00 00	 jmp	 $LN1@gObjInterf
$LN2@gObjInterf:

; 10081: 	
; 10082: 	if( (GetTickCount()-lpObj->m_InterfaceTime) < 5000  ) return;

  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00031	2b 81 58 0c 00
	00		 sub	 eax, DWORD PTR [ecx+3160]
  00037	3d 88 13 00 00	 cmp	 eax, 5000		; 00001388H
  0003c	73 05		 jae	 SHORT $LN3@gObjInterf
  0003e	e9 4f 01 00 00	 jmp	 $LN1@gObjInterf
$LN3@gObjInterf:

; 10083: 
; 10084: 	//  
; 10085: 	if( lpObj->m_IfState.state == 1 ) return;

  00043	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00046	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0004c	c0 e9 02	 shr	 cl, 2
  0004f	80 e1 03	 and	 cl, 3
  00052	0f b6 d1	 movzx	 edx, cl
  00055	83 fa 01	 cmp	 edx, 1
  00058	75 05		 jne	 SHORT $LN4@gObjInterf
  0005a	e9 33 01 00 00	 jmp	 $LN1@gObjInterf
$LN4@gObjInterf:

; 10086: 	
; 10087: 	tObjNum =lpObj->TargetNumber;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00062	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00069	89 4d fc	 mov	 DWORD PTR _tObjNum$[ebp], ecx

; 10088: 	if( tObjNum < 0 ) return;

  0006c	83 7d fc 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  00070	7d 05		 jge	 SHORT $LN5@gObjInterf
  00072	e9 1b 01 00 00	 jmp	 $LN1@gObjInterf
$LN5@gObjInterf:

; 10089: 
; 10090: 	if( lpObj->m_IfState.type == I_TRADE )

  00077	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007a	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00080	c0 e9 04	 shr	 cl, 4
  00083	80 e1 0f	 and	 cl, 15			; 0000000fH
  00086	0f b6 d1	 movzx	 edx, cl
  00089	83 fa 01	 cmp	 edx, 1
  0008c	75 46		 jne	 SHORT $LN6@gObjInterf

; 10091: 	{
; 10092: 		CGTradeResult(lpObj->m_Index, 0x03);

  0008e	6a 03		 push	 3
  00090	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00093	8b 08		 mov	 ecx, DWORD PTR [eax]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  0009b	83 c4 08	 add	 esp, 8

; 10093: 		CGTradeResult(tObjNum, 0x03);

  0009e	6a 03		 push	 3
  000a0	8b 45 fc	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  000a9	83 c4 08	 add	 esp, 8

; 10094: 		GCServerMsgStringSend(lMsg.Get(1138), tObjNum, 1);

  000ac	6a 01		 push	 1
  000ae	8b 45 fc	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  000b1	50		 push	 eax
  000b2	68 72 04 00 00	 push	 1138			; 00000472H
  000b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10095: 		TimeCheck = 1;

  000cb	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _TimeCheck$[ebp], 1

; 10096: 	}

  000d2	eb 53		 jmp	 SHORT $LN7@gObjInterf
$LN6@gObjInterf:

; 10097: 	else if( lpObj->m_IfState.type == I_PARTY )

  000d4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d7	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000dd	c0 e9 04	 shr	 cl, 4
  000e0	80 e1 0f	 and	 cl, 15			; 0000000fH
  000e3	0f b6 d1	 movzx	 edx, cl
  000e6	83 fa 02	 cmp	 edx, 2
  000e9	75 3c		 jne	 SHORT $LN7@gObjInterf

; 10098: 	{
; 10099: 		lpObj->PartyTargetUser	= -1;

  000eb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ee	c7 80 8c 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+652], -1

; 10100: 		gObj[tObjNum].PartyTargetUser  = -1;

  000f8	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00105	c7 84 01 8c 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+652], -1

; 10101: 		GCResultSend(tObjNum, 0x41, 0x00);	//  .

  00110	6a 00		 push	 0
  00112	6a 41		 push	 65			; 00000041H
  00114	8b 45 fc	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 ?GCResultSend@@YAXHEE@Z	; GCResultSend
  0011d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10102: 		TimeCheck = 1;

  00120	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _TimeCheck$[ebp], 1
$LN7@gObjInterf:

; 10103: 	}
; 10104: 	//else if( lpObj->m_IfState.type == I_GUILD)
; 10105: 	//{
; 10106: 	//}
; 10107: 	// 2002/10/15     
; 10108: 	if(TimeCheck)

  00127	83 7d f8 00	 cmp	 DWORD PTR _TimeCheck$[ebp], 0
  0012b	74 65		 je	 SHORT $LN1@gObjInterf

; 10109: 	{
; 10110: 		lpObj->m_IfState.use			=  0;

  0012d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00130	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00136	80 e1 fc	 and	 cl, 252			; 000000fcH
  00139	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0013c	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 10111: 		lpObj->TargetNumber				= -1;

  00142	83 c8 ff	 or	 eax, -1
  00145	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00148	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 10112: 		gObj[tObjNum].m_IfState.use		=  0;

  0014f	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00156	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0015c	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00163	80 e2 fc	 and	 dl, 252			; 000000fcH
  00166	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  0016d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00173	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 10113: 		gObj[tObjNum].TargetNumber		= -1;

  0017a	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00181	83 c9 ff	 or	 ecx, -1
  00184	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018a	66 89 8c 02 ac
	02 00 00	 mov	 WORD PTR [edx+eax+684], cx
$LN1@gObjInterf:

; 10114: 	}
; 10115: }

  00192	5f		 pop	 edi
  00193	5e		 pop	 esi
  00194	5b		 pop	 ebx
  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c3		 ret	 0
?gObjInterfaceTimeCheck@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjInterfaceTimeCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjUserDie@@YAXPAVOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
tv286 = -144						; size = 4
tv277 = -140						; size = 4
tv218 = -140						; size = 4
tv130 = -140						; size = 4
tv407 = -136						; size = 4
tv387 = -136						; size = 4
tv271 = -136						; size = 4
tv219 = -136						; size = 4
tv131 = -136						; size = 4
_submoney$ = -68					; size = 4
_tmpPKLevel$ = -61					; size = 1
_decexprate$ = -60					; size = 4
_decexp$ = -56						; size = 4
_subexp$ = -52						; size = 4
_maxexp$ = -48						; size = 4
_minexp$ = -44						; size = 4
_pDropItem$1 = -40					; size = 6
_pDropItem$2 = -32					; size = 6
_lpattr$3 = -24						; size = 4
_lpattr$4 = -20						; size = 4
_dropresult$ = -16					; size = 4
_number$ = -12						; size = 4
_itemdrop$ = -8						; size = 4
_count$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjUserDie@@YAXPAVOBJECTSTRUCT@@0@Z PROC		; gObjUserDie, COMDAT

; 9180 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 9181 : 	int count=MAX_INVENTORY;

  0000c	c7 45 fc 4c 00
	00 00		 mov	 DWORD PTR _count$[ebp], 76 ; 0000004cH

; 9182 : 	int itemdrop=1;

  00013	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _itemdrop$[ebp], 1

; 9183 : #ifdef HERO_SYSTEM_MODIFY
; 9184 : 	int itemvanish=1;
; 9185 : #endif
; 9186 : 	int number=0;

  0001a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _number$[ebp], 0

; 9187 : 	int dropresult=0;

  00021	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dropresult$[ebp], 0

; 9188 : 	
; 9189 : 	if( lpObj->Type != OBJTYPE_CHARACTER ) return;

  00028	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002b	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0002f	83 f9 01	 cmp	 ecx, 1
  00032	74 05		 je	 SHORT $LN6@gObjUserDi
  00034	e9 bc 0b 00 00	 jmp	 $LN1@gObjUserDi
$LN6@gObjUserDi:

; 9190 : 
; 9191 : #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 9192 : 	gObjClearBuffEffect( lpObj, CLEAR_TYPE_NON_PCS_ITEM_EFFECT );
; 9193 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 9194 : 
; 9195 : #ifdef ADD_NEW_SKILL_FOR_CASTLE_01_20041116
; 9196 : 	gObjSetKillCount( lpObj->m_Index, KILLCOUNT_RESET );
; 9197 : 	gObjUseSkill.RemoveAllCharacterInvalidMagicAndSkillState( lpObj );
; 9198 : #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004					// !! NOT
; 9199 : 	lpObj->m_iPotionBlessTime = 0;
; 9200 : 	lpObj->m_iPotionSoulTime  = 0;
; 9201 : 	DEL_VIEWSKILLSTATE( lpObj->m_ViewSkillState, STATE_BLESS_POTION );
; 9202 : 	DEL_VIEWSKILLSTATE( lpObj->m_ViewSkillState, STATE_SOUL_POTION );
; 9203 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 9204 : #endif
; 9205 : 	
; 9206 : #ifdef CHINA_GM_EVENT
; 9207 : 	if( lpObj->Authority&AUTHORITY_EVENT_GM )
; 9208 : 	{
; 9209 : 		char tempMsg[255];
; 9210 : 		wsprintf(tempMsg, "[GMEvent] (%s)(%s) EventGM Dead, Killed by (%s)(%s) MapInfo(%d)(%d/%d)", 
; 9211 : 				lpObj->AccountID, lpObj->Name,				
; 9212 : 				lpTargetObj->AccountID, lpTargetObj->Name,
; 9213 : 				lpObj->MapNumber, lpObj->X, lpObj->Y);
; 9214 : 
; 9215 : 		LogAddTD(tempMsg);
; 9216 : 		//fix mensaje 100 - 200
; 9217 : 		/*wsprintf(tempMsg, lMsg.Get(1302),	//"(%s) (%s) "
; 9218 : 				lpTargetObj->Name,
; 9219 : 				lpObj->Name);
; 9220 : 		AllSendServerMsg(tempMsg);	*/	
; 9221 : 
; 9222 : 		gGMEventRunning = FALSE;
; 9223 : 		return;
; 9224 : 	}
; 9225 : #endif
; 9226 : 
; 9227 : #ifdef MODIFY_CHN_GMEVENT_TO_TAIWAN_GM_EVENT_20070906
; 9228 : 	if( lpObj->Authority&AUTHORITY_EVENT_GM )
; 9229 : 	{
; 9230 : 		char tempMsg[255];
; 9231 : 		wsprintf(tempMsg, "[GMEvent] (%s)(%s) EventGM Dead, Killed by (%s)(%s) MapInfo(%d)(%d/%d)", 
; 9232 : 			lpObj->AccountID, lpObj->Name,				
; 9233 : 			lpTargetObj->AccountID, lpTargetObj->Name,
; 9234 : 			lpObj->MapNumber, lpObj->X, lpObj->Y);
; 9235 : 		
; 9236 : 		LogAddTD(tempMsg);
; 9237 : 		
; 9238 : 		wsprintf(tempMsg, lMsg.Get(1302),	//"(%s) (%s) "
; 9239 : 			lpTargetObj->Name,
; 9240 : 			lpObj->Name);
; 9241 : 		AllSendServerMsg(tempMsg);
; 9242 : 		
; 9243 : #ifdef EVENT_SERVER_OPEN_COMMEMORATION_20050510
; 9244 : 		gObjMakeGMEventItem( lpTargetObj->m_Index );
; 9245 : #endif // EVENT_SERVER_OPEN_COMMEMORATION_20050510
; 9246 : 		
; 9247 : 		gGMEventRunning = FALSE;
; 9248 : 		return;
; 9249 : 	}
; 9250 : #endif // MODIFY_CHN_GMEVENT_TO_TAIWAN_GM_EVENT_20070906
; 9251 : 
; 9252 : #ifdef _NEW_EXDB_
; 9253 : 	//          ..
; 9254 : 	if( gObjTargetGuildWarCheck(lpObj, lpTargetObj) == TRUE ) return;

  00039	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00046	83 c4 08	 add	 esp, 8
  00049	83 f8 01	 cmp	 eax, 1
  0004c	75 05		 jne	 SHORT $LN7@gObjUserDi
  0004e	e9 a2 0b 00 00	 jmp	 $LN1@gObjUserDi
$LN7@gObjUserDi:

; 9255 : #endif
; 9256 : 
; 9257 : 	if( lpObj->m_stateEngagePVP == PVP_USER_PLAYING)

  00053	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00056	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  0005d	75 05		 jne	 SHORT $LN8@gObjUserDi

; 9258 : 	{
; 9259 : 		return;

  0005f	e9 91 0b 00 00	 jmp	 $LN1@gObjUserDi
$LN8@gObjUserDi:

; 9260 : 	}
; 9261 : 
; 9262 : 	//    
; 9263 : #ifdef DEVILSQUARE_EXTEND_20050221		//    
; 9264 : 	if( CHECK_DEVILSQUARE(lpObj->MapNumber) ) 
; 9265 : #else
; 9266 : 	if( lpObj->MapNumber == 9 ) 

  00064	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00067	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0006e	83 f9 09	 cmp	 ecx, 9
  00071	75 52		 jne	 SHORT $LN9@gObjUserDi

; 9267 : #endif
; 9268 : 	{
; 9269 : 		if( lpTargetObj->Type	== OBJTYPE_MONSTER )

  00073	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00076	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0007a	83 f9 02	 cmp	 ecx, 2
  0007d	75 41		 jne	 SHORT $LN10@gObjUserDi

; 9270 : 		{	//    			
; 9271 : 			LPMONSTER_ATTRIBUTE lpattr = gMAttr.GetAttr(lpTargetObj->Class);

  0007f	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00082	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00089	51		 push	 ecx
  0008a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  0008f	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  00094	89 45 ec	 mov	 DWORD PTR _lpattr$4[ebp], eax

; 9272 : 			if( lpattr )

  00097	83 7d ec 00	 cmp	 DWORD PTR _lpattr$4[ebp], 0
  0009b	74 23		 je	 SHORT $LN10@gObjUserDi

; 9273 : 			{
; 9274 : 				LogAddTD("[DevilSquare] Dead In DevilSquare [%s][%s][%s]", lpObj->AccountID, lpObj->Name, lpattr->m_Name);

  0009d	8b 45 ec	 mov	 eax, DWORD PTR _lpattr$4[ebp]
  000a0	83 c0 08	 add	 eax, 8
  000a3	50		 push	 eax
  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a7	83 c1 73	 add	 ecx, 115		; 00000073H
  000aa	51		 push	 ecx
  000ab	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ae	83 c2 68	 add	 edx, 104		; 00000068H
  000b1	52		 push	 edx
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@MMNCCLML@?$FLDevilSquare?$FN?5Dead?5In?5DevilSqua@
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000bd	83 c4 10	 add	 esp, 16			; 00000010H
$LN10@gObjUserDi:

; 9275 : 			}
; 9276 : 		}
; 9277 : 		return;

  000c0	e9 30 0b 00 00	 jmp	 $LN1@gObjUserDi
$LN9@gObjUserDi:

; 9278 : 	}
; 9279 : 
; 9280 : #ifdef FOR_BLOODCASTLE
; 9281 : 	if(CHECK_BLOODCASTLE(lpObj->MapNumber)) {

  000c5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c8	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000cf	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  000d2	7d 0c		 jge	 SHORT $LN82@gObjUserDi
  000d4	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv131[ebp], 0
  000de	eb 31		 jmp	 SHORT $LN83@gObjUserDi
$LN82@gObjUserDi:
  000e0	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e3	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  000ea	83 f8 11	 cmp	 eax, 17			; 00000011H
  000ed	7e 0c		 jle	 SHORT $LN80@gObjUserDi
  000ef	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv130[ebp], 0
  000f9	eb 0a		 jmp	 SHORT $LN81@gObjUserDi
$LN80@gObjUserDi:
  000fb	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv130[ebp], 1
$LN81@gObjUserDi:
  00105	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv130[ebp]
  0010b	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv131[ebp], ecx
$LN83@gObjUserDi:
  00111	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv131[ebp], 0
  00118	0f 84 64 01 00
	00		 je	 $LN12@gObjUserDi

; 9282 : 		//    .
; 9283 : 		g_BloodCastle.SetUserState(lpObj->m_Index, BC_USER_DEAD);

  0011e	6a 01		 push	 1
  00120	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00123	8b 08		 mov	 ecx, DWORD PTR [eax]
  00125	51		 push	 ecx
  00126	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0012b	e8 00 00 00 00	 call	 ?SetUserState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetUserState

; 9284 : 		//       .
; 9285 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010		//    
; 9286 : 		int iBridgeIndex = g_BloodCastle.GetBridgeIndexByMapNum( lpObj->MapNumber );
; 9287 : 		if (g_BloodCastle.GetCurrentState(iBridgeIndex) == BLOODCASTLE_STATE_PLAYING) {
; 9288 : #else
; 9289 : 		if (g_BloodCastle.GetCurrentState(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1) == BLOODCASTLE_STATE_PLAYING) {

  00130	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00133	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0013a	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  0013d	51		 push	 ecx
  0013e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00143	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  00148	83 f8 02	 cmp	 eax, 2
  0014b	75 3c		 jne	 SHORT $LN13@gObjUserDi

; 9290 : #endif
; 9291 : 			LogAddTD("[Blood Castle] (%d) Try to drop Ultimate Weapon [%s][%s]",

  0014d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00150	83 c0 73	 add	 eax, 115		; 00000073H
  00153	50		 push	 eax
  00154	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00157	83 c1 68	 add	 ecx, 104		; 00000068H
  0015a	51		 push	 ecx
  0015b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0015e	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00165	83 e8 0a	 sub	 eax, 10			; 0000000aH
  00168	50		 push	 eax
  00169	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@HJPHEOFL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Try?5to?5drop@
  0016e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00174	83 c4 10	 add	 esp, 16			; 00000010H

; 9292 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010		//    
; 9293 : 					iBridgeIndex + 1,
; 9294 : #else
; 9295 : 					lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1 + 1,
; 9296 : #endif
; 9297 : 					lpObj->AccountID, 
; 9298 : 					lpObj->Name
; 9299 : 					);
; 9300 : 			g_BloodCastle.SearchUserDropQuestItem (lpObj->m_Index);

  00177	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017c	51		 push	 ecx
  0017d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00182	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem

; 9301 : 		}

  00187	eb 3a		 jmp	 SHORT $LN14@gObjUserDi
$LN13@gObjUserDi:

; 9302 : 		else {
; 9303 : 			LogAddTD("[Blood Castle] (%d) Try to delete Ultimate Weapon [%s][%s]",

  00189	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0018c	83 c0 73	 add	 eax, 115		; 00000073H
  0018f	50		 push	 eax
  00190	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00193	83 c1 68	 add	 ecx, 104		; 00000068H
  00196	51		 push	 ecx
  00197	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0019a	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  001a1	83 e8 0a	 sub	 eax, 10			; 0000000aH
  001a4	50		 push	 eax
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@COJKOION@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Try?5to?5dele@
  001aa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001b0	83 c4 10	 add	 esp, 16			; 00000010H

; 9304 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010		//    
; 9305 : 					iBridgeIndex + 1,
; 9306 : #else
; 9307 : 					lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1 + 1,
; 9308 : #endif
; 9309 : 					lpObj->AccountID, 
; 9310 : 					lpObj->Name
; 9311 : 					);
; 9312 : 			g_BloodCastle.SearchUserDeleteQuestItem (lpObj->m_Index);

  001b3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b8	51		 push	 ecx
  001b9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  001be	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN14@gObjUserDi:

; 9313 : 		}
; 9314 : 
; 9315 : 		if( lpTargetObj->Type == OBJTYPE_MONSTER )

  001c3	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001c6	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  001ca	83 f9 02	 cmp	 ecx, 2
  001cd	75 61		 jne	 SHORT $LN15@gObjUserDi

; 9316 : 		{	//    
; 9317 : 			LPMONSTER_ATTRIBUTE lpattr = gMAttr.GetAttr(lpTargetObj->Class);

  001cf	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001d2	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  001d9	51		 push	 ecx
  001da	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  001df	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  001e4	89 45 e8	 mov	 DWORD PTR _lpattr$3[ebp], eax

; 9318 : 			if( lpattr )

  001e7	83 7d e8 00	 cmp	 DWORD PTR _lpattr$3[ebp], 0
  001eb	74 41		 je	 SHORT $LN17@gObjUserDi

; 9319 : 			{
; 9320 : 				LogAddTD("[Blood Castle] (%d) Dead In Blood Castle, Killed by Monster [%s][%s][%s]",

  001ed	8b 45 e8	 mov	 eax, DWORD PTR _lpattr$3[ebp]
  001f0	83 c0 08	 add	 eax, 8
  001f3	50		 push	 eax
  001f4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001f7	83 c1 73	 add	 ecx, 115		; 00000073H
  001fa	51		 push	 ecx
  001fb	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001fe	83 c2 68	 add	 edx, 104		; 00000068H
  00201	52		 push	 edx
  00202	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00205	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0020c	83 e9 0a	 sub	 ecx, 10			; 0000000aH
  0020f	51		 push	 ecx
  00210	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@EGIDAPD@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Dead?5In?5Blo@
  00215	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0021b	83 c4 14	 add	 esp, 20			; 00000014H

; 9321 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010		//    
; 9322 : 				iBridgeIndex + 1,
; 9323 : #else
; 9324 : 				lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1 + 1,
; 9325 : #endif
; 9326 : 					lpObj->AccountID, 
; 9327 : 					lpObj->Name, 
; 9328 : 					lpattr->m_Name
; 9329 : 					);
; 9330 : 				g_BloodCastle.SearchUserDropQuestItem (lpObj->m_Index);

  0021e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00221	8b 08		 mov	 ecx, DWORD PTR [eax]
  00223	51		 push	 ecx
  00224	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00229	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem
$LN17@gObjUserDi:

; 9331 : 			}
; 9332 : 		}

  0022e	eb 4d		 jmp	 SHORT $LN16@gObjUserDi
$LN15@gObjUserDi:

; 9333 : 		else if (lpTargetObj->Type == OBJTYPE_CHARACTER) {

  00230	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00233	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00237	83 f9 01	 cmp	 ecx, 1
  0023a	75 41		 jne	 SHORT $LN16@gObjUserDi

; 9334 : 			LogAddTD("[Blood Castle] (%d) Dead In Blood Castle, Killed by Other User [%s][%s][%s]",

  0023c	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0023f	83 c0 73	 add	 eax, 115		; 00000073H
  00242	50		 push	 eax
  00243	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00246	83 c1 73	 add	 ecx, 115		; 00000073H
  00249	51		 push	 ecx
  0024a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0024d	83 c2 68	 add	 edx, 104		; 00000068H
  00250	52		 push	 edx
  00251	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00254	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0025b	83 e9 0a	 sub	 ecx, 10			; 0000000aH
  0025e	51		 push	 ecx
  0025f	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@NNNAIELC@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Dead?5In?5Blo@
  00264	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0026a	83 c4 14	 add	 esp, 20			; 00000014H

; 9335 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010		//    
; 9336 : 				iBridgeIndex + 1,
; 9337 : #else
; 9338 : 				lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1 + 1,
; 9339 : #endif
; 9340 : 				lpObj->AccountID, 
; 9341 : 				lpObj->Name, 
; 9342 : 				lpTargetObj->Name
; 9343 : 				);
; 9344 : 			g_BloodCastle.SearchUserDropQuestItem (lpObj->m_Index);

  0026d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00270	8b 08		 mov	 ecx, DWORD PTR [eax]
  00272	51		 push	 ecx
  00273	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00278	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem
$LN16@gObjUserDi:

; 9345 : 		}
; 9346 : 
; 9347 : 		return;

  0027d	e9 73 09 00 00	 jmp	 $LN1@gObjUserDi
$LN12@gObjUserDi:

; 9348 : 	}
; 9349 : #endif
; 9350 : 
; 9351 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328		//      
; 9352 : 	if(CHECK_ILLUSION_TEMPLE(lpObj->MapNumber))
; 9353 : 	{
; 9354 : 		//  
; 9355 : 		g_IllusionTempleEvent.IllusionTempleUserDie(lpObj);
; 9356 : 		return;
; 9357 : 	}
; 9358 : #endif
; 9359 : 
; 9360 : #ifdef CHAOSCASTLE_SYSTEM_20040408			//     .
; 9361 : 	#ifndef WORLD_TOURNAMENT_EVENT_SETTING
; 9362 : 		if(CHECK_CHAOSCASTLE(lpObj->MapNumber)) {

  00282	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00285	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0028c	83 f9 12	 cmp	 ecx, 18			; 00000012H
  0028f	7d 0c		 jge	 SHORT $LN86@gObjUserDi
  00291	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv219[ebp], 0
  0029b	eb 31		 jmp	 SHORT $LN87@gObjUserDi
$LN86@gObjUserDi:
  0029d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002a0	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  002a7	83 f8 17	 cmp	 eax, 23			; 00000017H
  002aa	7e 0c		 jle	 SHORT $LN84@gObjUserDi
  002ac	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv218[ebp], 0
  002b6	eb 0a		 jmp	 SHORT $LN85@gObjUserDi
$LN84@gObjUserDi:
  002b8	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv218[ebp], 1
$LN85@gObjUserDi:
  002c2	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv218[ebp]
  002c8	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv219[ebp], ecx
$LN87@gObjUserDi:
  002ce	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv219[ebp], 0
  002d5	74 05		 je	 SHORT $LN19@gObjUserDi

; 9363 : 			return;

  002d7	e9 19 09 00 00	 jmp	 $LN1@gObjUserDi
$LN19@gObjUserDi:

; 9364 : 		}
; 9365 : 	#endif
; 9366 : #endif
; 9367 : 
; 9368 : #ifdef CASTLE_MAIN_SCHEDULER_20041111		//         .
; 9369 : 	if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE &&
; 9370 : 		lpObj->MapNumber == MAP_INDEX_CASTLESIEGE
; 9371 : 		) 
; 9372 : 	{
; 9373 : 		// MODIFY_ACCUMULATED_BUG_DEAD_BY_CANNONTOWER_01_20050531 ???
; 9374 : 		return;
; 9375 : 	}
; 9376 : #endif
; 9377 : 
; 9378 : #ifdef JAPAN_DESTROYKING_EVENT_20040625		//     GM ()    .
; 9379 : 	if( lpObj->Authority&CTLCODE_EVENT_GM || lpTargetObj->Authority&CTLCODE_EVENT_GM)
; 9380 : 	{
; 9381 : 		return;
; 9382 : 	}
; 9383 : #endif
; 9384 : 
; 9385 : #ifdef ADD_PARTIALY_CHARGE_SYSTEM_06_20090129
; 9386 : 	if( gObjCheckUsedBuffEffect(lpObj, BUFFTYPE_CHARM_GUARDIAN))
; 9387 : 	{
; 9388 : #ifdef MODIFY_DUAL_AFFECT_BUFFTYPE_CHARM_GUARDIAN_20091007
; 9389 : 		if( FALSE == IsOnDuel(lpObj->m_Index, lpTargetObj->m_Index) )
; 9390 : #endif //#ifdef MODIFY_DUAL_AFFECT_BUFFTYPE_CHARM_GUARDIAN_20091007
; 9391 : 			return;
; 9392 : 	}
; 9393 : #endif
; 9394 : 
; 9395 : 	if( lpTargetObj->Type == OBJTYPE_MONSTER )

  002dc	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  002df	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  002e3	83 f9 02	 cmp	 ecx, 2
  002e6	75 4e		 jne	 SHORT $LN20@gObjUserDi

; 9396 : 	{	//   
; 9397 : 		LogAddTD("[%s][%s] Killed [%s][%s] Pos:(%d,%d,%d)",

  002e8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002eb	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  002f2	51		 push	 ecx
  002f3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002f6	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  002fd	50		 push	 eax
  002fe	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00301	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00308	52		 push	 edx
  00309	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030c	83 c0 73	 add	 eax, 115		; 00000073H
  0030f	50		 push	 eax
  00310	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00313	83 c1 68	 add	 ecx, 104		; 00000068H
  00316	51		 push	 ecx
  00317	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  0031a	83 c2 73	 add	 edx, 115		; 00000073H
  0031d	52		 push	 edx
  0031e	68 00 00 00 00	 push	 OFFSET ??_C@_07GOHPBKOH@Monster@
  00323	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@JFDMHJOK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Killed?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Pos?3?$CI?$CF@
  00328	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0032e	83 c4 20	 add	 esp, 32			; 00000020H

; 9398 : 				 "Monster", lpTargetObj->Name, 
; 9399 : 				 lpObj->AccountID, lpObj->Name,
; 9400 : 				 lpObj->MapNumber, lpObj->X, lpObj->Y);
; 9401 : 	}

  00331	e9 2a 01 00 00	 jmp	 $LN21@gObjUserDi
$LN20@gObjUserDi:

; 9402 : 	else
; 9403 : 	{	//   
; 9404 : 		LogAddTD("[%s][%s] (PkLevel = %d) Killed [%s][%s] (PkLevel = %d) Pos:(%d,%d,%d)",

  00336	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00339	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00340	51		 push	 ecx
  00341	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00344	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  0034b	50		 push	 eax
  0034c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0034f	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00356	52		 push	 edx
  00357	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0035a	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  00361	51		 push	 ecx
  00362	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00365	83 c2 73	 add	 edx, 115		; 00000073H
  00368	52		 push	 edx
  00369	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0036c	83 c0 68	 add	 eax, 104		; 00000068H
  0036f	50		 push	 eax
  00370	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00373	0f be 91 fd 00
	00 00		 movsx	 edx, BYTE PTR [ecx+253]
  0037a	52		 push	 edx
  0037b	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0037e	83 c0 73	 add	 eax, 115		; 00000073H
  00381	50		 push	 eax
  00382	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00385	83 c1 68	 add	 ecx, 104		; 00000068H
  00388	51		 push	 ecx
  00389	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@HIGLADFI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5?$CIPkLevel?5?$DN?5?$CFd?$CJ?5Killed?5@
  0038e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00394	83 c4 28	 add	 esp, 40			; 00000028H

; 9405 : 				 lpTargetObj->AccountID, lpTargetObj->Name, 
; 9406 : 				 lpTargetObj->m_PK_Level,
; 9407 : 				 lpObj->AccountID, lpObj->Name,
; 9408 : 				 lpObj->m_PK_Level,
; 9409 : 				 lpObj->MapNumber, lpObj->X, lpObj->Y);
; 9410 : 
; 9411 : #ifdef DUEL_SYSTEM_20031028
; 9412 : 				LogAddTD("Killed by User State Victim:[%s][%s], Murderer:[%s][%s], Dead State (Duel:%d, GuildWar:%d, SeldDefense:%d)",

  00397	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0039c	51		 push	 ecx
  0039d	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  003a0	52		 push	 edx
  003a1	e8 00 00 00 00	 call	 ?gObjIsSelfDefense@@YA_NPAVOBJECTSTRUCT@@H@Z ; gObjIsSelfDefense
  003a6	83 c4 08	 add	 esp, 8
  003a9	0f b6 c0	 movzx	 eax, al
  003ac	85 c0		 test	 eax, eax
  003ae	74 0c		 je	 SHORT $LN88@gObjUserDi
  003b0	c7 85 78 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv271[ebp], 1
  003ba	eb 0a		 jmp	 SHORT $LN89@gObjUserDi
$LN88@gObjUserDi:
  003bc	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv271[ebp], 0
$LN89@gObjUserDi:
  003c6	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  003c9	51		 push	 ecx
  003ca	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003cd	52		 push	 edx
  003ce	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  003d3	83 c4 08	 add	 esp, 8
  003d6	85 c0		 test	 eax, eax
  003d8	74 0c		 je	 SHORT $LN90@gObjUserDi
  003da	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv277[ebp], 1
  003e4	eb 0a		 jmp	 SHORT $LN91@gObjUserDi
$LN90@gObjUserDi:
  003e6	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv277[ebp], 0
$LN91@gObjUserDi:
  003f0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f5	51		 push	 ecx
  003f6	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  003f9	8b 02		 mov	 eax, DWORD PTR [edx]
  003fb	50		 push	 eax
  003fc	e8 00 00 00 00	 call	 ?IsOnDuel@@YA_NHH@Z	; IsOnDuel
  00401	83 c4 08	 add	 esp, 8
  00404	0f b6 c8	 movzx	 ecx, al
  00407	85 c9		 test	 ecx, ecx
  00409	74 0c		 je	 SHORT $LN92@gObjUserDi
  0040b	c7 85 70 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv286[ebp], 1
  00415	eb 0a		 jmp	 SHORT $LN93@gObjUserDi
$LN92@gObjUserDi:
  00417	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv286[ebp], 0
$LN93@gObjUserDi:
  00421	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR tv271[ebp]
  00427	52		 push	 edx
  00428	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv277[ebp]
  0042e	50		 push	 eax
  0042f	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv286[ebp]
  00435	51		 push	 ecx
  00436	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00439	83 c2 73	 add	 edx, 115		; 00000073H
  0043c	52		 push	 edx
  0043d	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00440	83 c0 68	 add	 eax, 104		; 00000068H
  00443	50		 push	 eax
  00444	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00447	83 c1 73	 add	 ecx, 115		; 00000073H
  0044a	51		 push	 ecx
  0044b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0044e	83 c2 68	 add	 edx, 104		; 00000068H
  00451	52		 push	 edx
  00452	68 00 00 00 00	 push	 OFFSET ??_C@_0GL@DJDDMNFC@Killed?5by?5User?5State?5Victim?3?$FL?$CFs@
  00457	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0045d	83 c4 20	 add	 esp, 32			; 00000020H
$LN21@gObjUserDi:

; 9413 : 						 lpObj->AccountID, lpObj->Name,
; 9414 : 						 lpTargetObj->AccountID, lpTargetObj->Name, 							
; 9415 : 						 IsOnDuel (lpTargetObj->m_Index, lpObj->m_Index)?1:0,
; 9416 : 						 gObjTargetGuildWarCheck(lpObj, lpTargetObj)?1:0,
; 9417 : 						 gObjIsSelfDefense(lpTargetObj, lpObj->m_Index)?1:0		// lpObj:, lpTargetObj:
; 9418 : 						 );
; 9419 : #endif
; 9420 : 
; 9421 : 	}
; 9422 : 	
; 9423 : 	//------------------------------------------------------------------------
; 9424 : 	//  .
; 9425 : 	//------------------------------------------------------------------------
; 9426 : 	//if( *(lpObj->pInventoryCount) < 1 ) return;
; 9427 : 
; 9428 : 
; 9429 : #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 9430 : 	if (!gPkLimitFree) {

  00460	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00467	0f 85 d8 00 00
	00		 jne	 $LN22@gObjUserDi

; 9431 : 			// if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT-2 ) itemdrop = (rand()%64);
; 9432 : 			 if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT-1 ) itemdrop = (rand()%32);

  0046d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00470	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  00477	83 f9 02	 cmp	 ecx, 2
  0047a	75 19		 jne	 SHORT $LN24@gObjUserDi
  0047c	e8 00 00 00 00	 call	 _rand
  00481	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  00486	79 05		 jns	 SHORT $LN95@gObjUserDi
  00488	48		 dec	 eax
  00489	83 c8 e0	 or	 eax, -32		; ffffffe0H
  0048c	40		 inc	 eax
$LN95@gObjUserDi:
  0048d	89 45 f8	 mov	 DWORD PTR _itemdrop$[ebp], eax
  00490	e9 ab 00 00 00	 jmp	 $LN25@gObjUserDi
$LN24@gObjUserDi:

; 9433 : 		else if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT   ) itemdrop = (rand()%16);

  00495	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00498	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  0049f	83 f9 03	 cmp	 ecx, 3
  004a2	75 19		 jne	 SHORT $LN26@gObjUserDi
  004a4	e8 00 00 00 00	 call	 _rand
  004a9	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  004ae	79 05		 jns	 SHORT $LN96@gObjUserDi
  004b0	48		 dec	 eax
  004b1	83 c8 f0	 or	 eax, -16		; fffffff0H
  004b4	40		 inc	 eax
$LN96@gObjUserDi:
  004b5	89 45 f8	 mov	 DWORD PTR _itemdrop$[ebp], eax
  004b8	e9 83 00 00 00	 jmp	 $LN25@gObjUserDi
$LN26@gObjUserDi:

; 9434 : 		else if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT+1 ) itemdrop = (rand()%8);

  004bd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004c0	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  004c7	83 f9 04	 cmp	 ecx, 4
  004ca	75 16		 jne	 SHORT $LN28@gObjUserDi
  004cc	e8 00 00 00 00	 call	 _rand
  004d1	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  004d6	79 05		 jns	 SHORT $LN97@gObjUserDi
  004d8	48		 dec	 eax
  004d9	83 c8 f8	 or	 eax, -8			; fffffff8H
  004dc	40		 inc	 eax
$LN97@gObjUserDi:
  004dd	89 45 f8	 mov	 DWORD PTR _itemdrop$[ebp], eax
  004e0	eb 5e		 jmp	 SHORT $LN25@gObjUserDi
$LN28@gObjUserDi:

; 9435 : 		else if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT+2 ) itemdrop = (rand()%4);

  004e2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004e5	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  004ec	83 f9 05	 cmp	 ecx, 5
  004ef	75 16		 jne	 SHORT $LN30@gObjUserDi
  004f1	e8 00 00 00 00	 call	 _rand
  004f6	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  004fb	79 05		 jns	 SHORT $LN98@gObjUserDi
  004fd	48		 dec	 eax
  004fe	83 c8 fc	 or	 eax, -4			; fffffffcH
  00501	40		 inc	 eax
$LN98@gObjUserDi:
  00502	89 45 f8	 mov	 DWORD PTR _itemdrop$[ebp], eax
  00505	eb 39		 jmp	 SHORT $LN25@gObjUserDi
$LN30@gObjUserDi:

; 9436 : 		else if( lpObj->m_PK_Level >= PK_LEVEL_DEFAULT+3 ) itemdrop = (rand()%2);

  00507	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0050a	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  00511	83 f9 06	 cmp	 ecx, 6
  00514	7c 16		 jl	 SHORT $LN32@gObjUserDi
  00516	e8 00 00 00 00	 call	 _rand
  0051b	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00520	79 05		 jns	 SHORT $LN99@gObjUserDi
  00522	48		 dec	 eax
  00523	83 c8 fe	 or	 eax, -2			; fffffffeH
  00526	40		 inc	 eax
$LN99@gObjUserDi:
  00527	89 45 f8	 mov	 DWORD PTR _itemdrop$[ebp], eax
  0052a	eb 14		 jmp	 SHORT $LN25@gObjUserDi
$LN32@gObjUserDi:

; 9437 : 		else itemdrop = (rand()%64);

  0052c	e8 00 00 00 00	 call	 _rand
  00531	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  00536	79 05		 jns	 SHORT $LN100@gObjUserDi
  00538	48		 dec	 eax
  00539	83 c8 c0	 or	 eax, -64		; ffffffc0H
  0053c	40		 inc	 eax
$LN100@gObjUserDi:
  0053d	89 45 f8	 mov	 DWORD PTR _itemdrop$[ebp], eax
$LN25@gObjUserDi:

; 9438 : 	}

  00540	e9 d5 00 00 00	 jmp	 $LN23@gObjUserDi
$LN22@gObjUserDi:

; 9439 : 	else {
; 9440 : 	#ifdef MODIFY_TAIWAN_FREE_SERVER_SETTING_20080214
; 9441 : 			// if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT-2 ) itemdrop = (rand()%256);
; 9442 : 			 if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT-1 ) itemdrop = (rand()%128);
; 9443 : 		else if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT   ) itemdrop = (rand()%64);
; 9444 : 		else if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT+1 ) itemdrop = (rand()%4);
; 9445 : 		else if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT+2 ) itemdrop = (rand()%3);
; 9446 : 		else if( lpObj->m_PK_Level >= PK_LEVEL_DEFAULT+3 )
; 9447 : 		{
; 9448 : 			// 66.6%
; 9449 : 			itemdrop = rand() % 100;
; 9450 : 			if( itemdrop > 66 )
; 9451 : 			{
; 9452 : 				itemdrop = 1;
; 9453 : 			}
; 9454 : 			else
; 9455 : 			{
; 9456 : 				itemdrop = 0;
; 9457 : 			}
; 9458 : 			//itemdrop = rand() % 3;
; 9459 : 			//itemdrop = ( ( rand() % 100 ) 66 ) );
; 9460 : 		}
; 9461 : 		else itemdrop = (rand()%256);
; 9462 : 	#else
; 9463 : 		// if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT-2 ) itemdrop = (rand()%256);
; 9464 : 		if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT-1 ) itemdrop = (rand()%128);

  00545	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00548	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  0054f	83 f9 02	 cmp	 ecx, 2
  00552	75 19		 jne	 SHORT $LN34@gObjUserDi
  00554	e8 00 00 00 00	 call	 _rand
  00559	25 7f 00 00 80	 and	 eax, -2147483521	; 8000007fH
  0055e	79 05		 jns	 SHORT $LN101@gObjUserDi
  00560	48		 dec	 eax
  00561	83 c8 80	 or	 eax, -128		; ffffff80H
  00564	40		 inc	 eax
$LN101@gObjUserDi:
  00565	89 45 f8	 mov	 DWORD PTR _itemdrop$[ebp], eax
  00568	e9 ad 00 00 00	 jmp	 $LN23@gObjUserDi
$LN34@gObjUserDi:

; 9465 : 		else if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT   ) itemdrop = (rand()%64);

  0056d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00570	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  00577	83 f9 03	 cmp	 ecx, 3
  0057a	75 19		 jne	 SHORT $LN36@gObjUserDi
  0057c	e8 00 00 00 00	 call	 _rand
  00581	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  00586	79 05		 jns	 SHORT $LN102@gObjUserDi
  00588	48		 dec	 eax
  00589	83 c8 c0	 or	 eax, -64		; ffffffc0H
  0058c	40		 inc	 eax
$LN102@gObjUserDi:
  0058d	89 45 f8	 mov	 DWORD PTR _itemdrop$[ebp], eax
  00590	e9 85 00 00 00	 jmp	 $LN23@gObjUserDi
$LN36@gObjUserDi:

; 9466 : 		else if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT+1 ) itemdrop = (rand()%16);

  00595	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00598	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  0059f	83 f9 04	 cmp	 ecx, 4
  005a2	75 16		 jne	 SHORT $LN38@gObjUserDi
  005a4	e8 00 00 00 00	 call	 _rand
  005a9	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  005ae	79 05		 jns	 SHORT $LN103@gObjUserDi
  005b0	48		 dec	 eax
  005b1	83 c8 f0	 or	 eax, -16		; fffffff0H
  005b4	40		 inc	 eax
$LN103@gObjUserDi:
  005b5	89 45 f8	 mov	 DWORD PTR _itemdrop$[ebp], eax
  005b8	eb 60		 jmp	 SHORT $LN23@gObjUserDi
$LN38@gObjUserDi:

; 9467 : 		else if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT+2 ) itemdrop = (rand()%4);

  005ba	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005bd	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  005c4	83 f9 05	 cmp	 ecx, 5
  005c7	75 16		 jne	 SHORT $LN40@gObjUserDi
  005c9	e8 00 00 00 00	 call	 _rand
  005ce	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  005d3	79 05		 jns	 SHORT $LN104@gObjUserDi
  005d5	48		 dec	 eax
  005d6	83 c8 fc	 or	 eax, -4			; fffffffcH
  005d9	40		 inc	 eax
$LN104@gObjUserDi:
  005da	89 45 f8	 mov	 DWORD PTR _itemdrop$[ebp], eax
  005dd	eb 3b		 jmp	 SHORT $LN23@gObjUserDi
$LN40@gObjUserDi:

; 9468 : 		else if( lpObj->m_PK_Level >= PK_LEVEL_DEFAULT+3 ) itemdrop = (rand()%2);

  005df	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005e2	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  005e9	83 f9 06	 cmp	 ecx, 6
  005ec	7c 16		 jl	 SHORT $LN42@gObjUserDi
  005ee	e8 00 00 00 00	 call	 _rand
  005f3	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  005f8	79 05		 jns	 SHORT $LN105@gObjUserDi
  005fa	48		 dec	 eax
  005fb	83 c8 fe	 or	 eax, -2			; fffffffeH
  005fe	40		 inc	 eax
$LN105@gObjUserDi:
  005ff	89 45 f8	 mov	 DWORD PTR _itemdrop$[ebp], eax
  00602	eb 16		 jmp	 SHORT $LN23@gObjUserDi
$LN42@gObjUserDi:

; 9469 : 		else itemdrop = (rand()%256);

  00604	e8 00 00 00 00	 call	 _rand
  00609	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  0060e	79 07		 jns	 SHORT $LN106@gObjUserDi
  00610	48		 dec	 eax
  00611	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00616	40		 inc	 eax
$LN106@gObjUserDi:
  00617	89 45 f8	 mov	 DWORD PTR _itemdrop$[ebp], eax
$LN23@gObjUserDi:

; 9470 : 	#endif // MODIFY_TAIWAN_FREE_SERVER_SETTING_20080214
; 9471 : 	}
; 9472 : #else
; 9473 : 		// if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT-2 ) itemdrop = (rand()%64);
; 9474 : 	if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT-1 ) itemdrop = (rand()%32);
; 9475 : 	else if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT   ) itemdrop = (rand()%16);
; 9476 : 	else if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT+1 ) itemdrop = (rand()%8);
; 9477 : 	else if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT+2 ) itemdrop = (rand()%4);
; 9478 : 	else if( lpObj->m_PK_Level >= PK_LEVEL_DEFAULT+3 ) itemdrop = (rand()%2);
; 9479 : 	else itemdrop = (rand()%64);
; 9480 : #endif	// ADD_PK_LIMIT_FREE_OPTION_20050324
; 9481 : 
; 9482 : 	
; 9483 : 	//         ...
; 9484 : 	if( gPkItemDrop == 0 )

  0061a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkItemDrop@@3HA, 0 ; gPkItemDrop
  00621	75 16		 jne	 SHORT $LN44@gObjUserDi

; 9485 : 	{
; 9486 : 		if( lpTargetObj->m_PK_Level >= PK_LEVEL_DEFAULT+1 )

  00623	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00626	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  0062d	83 f9 04	 cmp	 ecx, 4
  00630	7c 07		 jl	 SHORT $LN44@gObjUserDi

; 9487 : 		{
; 9488 : #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 9489 : 			//if (!gPkLimitFree)
; 9490 : #endif
; 9491 : 			itemdrop = 1;	//  1 .

  00632	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _itemdrop$[ebp], 1
$LN44@gObjUserDi:

; 9492 : 		}
; 9493 : 	}
; 9494 : 
; 9495 : 	if( gLanguage == 0 )

  00639	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gLanguage@@3HA, 0 ; gLanguage
  00640	75 13		 jne	 SHORT $LN46@gObjUserDi

; 9496 : 	{
; 9497 : #ifdef HERO_SYSTEM_MODIFY
; 9498 : 		
; 9499 :  
; 9500 : 		//          . (PK )
; 9501 : 		if( lpTargetObj->Type == OBJTYPE_CHARACTER ) 
; 9502 : 		{
; 9503 : #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 9504 : 			//if (!gPkLimitFree)
; 9505 : #endif
; 9506 : 
; 9507 : 			if ( lpObj->m_PK_Level <= PK_LEVEL_DEFAULT ) {
; 9508 : 				itemvanish = 1;	//  1 .
; 9509 : 			}
; 9510 : 			else if ( lpObj->m_PK_Level >= PK_LEVEL_DEFAULT + 3) {		//  
; 9511 : 				// PK 3  PK 
; 9512 : 				if (rand()%PK_LEVEL_3_ITEMERASE == 0)
; 9513 : 					itemvanish = 0;
; 9514 : 				else
; 9515 : 					itemvanish = 1;
; 9516 : 			}
; 9517 : 			else if ( lpObj->m_PK_Level == PK_LEVEL_DEFAULT + 2) {		//  
; 9518 : 				// PK 2  PK 
; 9519 : 				if (rand()%PK_LEVEL_2_ITEMERASE == 0)
; 9520 : 					itemvanish = 0;
; 9521 : 				else
; 9522 : 					itemvanish = 1;
; 9523 : 			}
; 9524 : 			else if ( lpObj->m_PK_Level == PK_LEVEL_DEFAULT + 1) {		//  
; 9525 : 				// PK 1  PK 
; 9526 : 				if (rand()%PK_LEVEL_1_ITEMERASE == 0)
; 9527 : 					itemvanish = 0;
; 9528 : 				else
; 9529 : 					itemvanish = 1;
; 9530 : 			}
; 9531 : 		}
; 9532 : 		else {
; 9533 : 			//     PK   .
; 9534 : 
; 9535 : 			itemvanish = 1;		//  1 .
; 9536 : 
; 9537 : 			if ( lpObj->m_PK_Level <= PK_LEVEL_DEFAULT ) {
; 9538 : 				itemdrop = 1;	//  1 .
; 9539 : 			}
; 9540 : 			else if ( lpObj->m_PK_Level >= PK_LEVEL_DEFAULT + 3) {
; 9541 : 				if (rand()%PK_LEVEL_3_ITEMDROP == 0)
; 9542 : 					itemdrop = 0;
; 9543 : 				else
; 9544 : 					itemdrop = 1;
; 9545 : 			}
; 9546 : 			else if ( lpObj->m_PK_Level == PK_LEVEL_DEFAULT + 2) {
; 9547 : 				if (rand()%PK_LEVEL_2_ITEMDROP == 0)
; 9548 : 					itemdrop = 0;
; 9549 : 				else
; 9550 : 					itemdrop = 1;
; 9551 : 			}
; 9552 : 			else if ( lpObj->m_PK_Level == PK_LEVEL_DEFAULT + 1) {
; 9553 : 				if (rand()%PK_LEVEL_1_ITEMDROP == 0)
; 9554 : 					itemdrop = 0;
; 9555 : 				else
; 9556 : 					itemdrop = 1;
; 9557 : 			}
; 9558 : 		}
; 9559 : 
; 9560 : 		
; 9561 : #else
; 9562 : 		//          .
; 9563 : 		if( lpTargetObj->Type == OBJTYPE_CHARACTER ) 

  00642	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00645	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00649	83 f9 01	 cmp	 ecx, 1
  0064c	75 07		 jne	 SHORT $LN46@gObjUserDi

; 9564 : 		{
; 9565 : #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 9566 : 			//if (!gPkLimitFree)
; 9567 : #endif
; 9568 : 			itemdrop = 1;	//  1 .

  0064e	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _itemdrop$[ebp], 1
$LN46@gObjUserDi:

; 9569 : 		}
; 9570 : #endif
; 9571 : 	}
; 9572 : 
; 9573 : 	if( gObjCanItemTouch(lpObj, 0) == FALSE )	//    

  00655	6a 00		 push	 0
  00657	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0065a	50		 push	 eax
  0065b	e8 00 00 00 00	 call	 ?gObjCanItemTouch@@YAHPAVOBJECTSTRUCT@@H@Z ; gObjCanItemTouch
  00660	83 c4 08	 add	 esp, 8
  00663	85 c0		 test	 eax, eax
  00665	75 07		 jne	 SHORT $LN48@gObjUserDi

; 9574 : 	{
; 9575 : 		itemdrop = 1;

  00667	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _itemdrop$[ebp], 1
$LN48@gObjUserDi:

; 9576 : 	}
; 9577 : 
; 9578 : #ifdef FOR_ONAIR	//      ( .)
; 9579 : 	itemdrop = 1;
; 9580 : 	#ifdef HERO_SYSTEM_MODIFY
; 9581 : 		itemvanish = 1;
; 9582 : 	#endif
; 9583 : #endif
; 9584 : 
; 9585 : #ifdef DUEL_SYSTEM_20031028
; 9586 : 	if( lpObj->Type == OBJTYPE_CHARACTER && lpTargetObj->Type == OBJTYPE_CHARACTER ) {

  0066e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00671	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00675	83 f9 01	 cmp	 ecx, 1
  00678	75 2e		 jne	 SHORT $LN49@gObjUserDi
  0067a	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0067d	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00681	83 f9 01	 cmp	 ecx, 1
  00684	75 22		 jne	 SHORT $LN49@gObjUserDi

; 9587 : 		if (IsOnDuel(lpObj->m_Index, lpTargetObj->m_Index)) {	//        .

  00686	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00689	8b 08		 mov	 ecx, DWORD PTR [eax]
  0068b	51		 push	 ecx
  0068c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0068f	8b 02		 mov	 eax, DWORD PTR [edx]
  00691	50		 push	 eax
  00692	e8 00 00 00 00	 call	 ?IsOnDuel@@YA_NHH@Z	; IsOnDuel
  00697	83 c4 08	 add	 esp, 8
  0069a	0f b6 c8	 movzx	 ecx, al
  0069d	85 c9		 test	 ecx, ecx
  0069f	74 07		 je	 SHORT $LN49@gObjUserDi

; 9588 : 			
; 9589 : #ifndef ADD_PK_LIMIT_FREE_OPTION_20050324
; 9590 : 			if( lpObj->m_PK_Level < PK_LEVEL_DEFAULT+1 && gPkItemDrop == 0 ) {		//  .
; 9591 : #endif
; 9592 : 				itemdrop = 1;

  006a1	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _itemdrop$[ebp], 1
$LN49@gObjUserDi:

; 9593 : #ifdef HERO_SYSTEM_MODIFY				
; 9594 : 				itemvanish = 1;
; 9595 : #endif
; 9596 : #ifndef ADD_PK_LIMIT_FREE_OPTION_20050324
; 9597 : 			}
; 9598 : #endif
; 9599 : 		}
; 9600 : 	}
; 9601 : #endif
; 9602 : 
; 9603 : #ifdef CRYWOLF_MVP_DISABLE_USER_ITEMDROP_20051217
; 9604 : 	//  MVP     .
; 9605 : 	if( g_Crywolf.GetCrywolfState() == CRYWOLF_STATE_START
; 9606 : 		&& CHECK_CRYWOLF_FIRSTZONE(lpObj->MapNumber) )
; 9607 : 	{
; 9608 : 		itemdrop	= 1;
; 9609 : 	}
; 9610 : #endif
; 9611 : 
; 9612 : 	if(lpObj->Type == OBJTYPE_CHARACTER && gPkItemDrop == 0)

  006a8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006ab	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  006af	83 f9 01	 cmp	 ecx, 1
  006b2	75 10		 jne	 SHORT $LN51@gObjUserDi
  006b4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkItemDrop@@3HA, 0 ; gPkItemDrop
  006bb	75 07		 jne	 SHORT $LN51@gObjUserDi

; 9613 : 	{
; 9614 : 		itemdrop = 1;

  006bd	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _itemdrop$[ebp], 1
$LN51@gObjUserDi:

; 9615 : #ifdef HERO_SYSTEM_MODIFY				
; 9616 : 		itemvanish = 1;
; 9617 : #endif
; 9618 : 	}
; 9619 : 
; 9620 : 	if( itemdrop == 0 )

  006c4	83 7d f8 00	 cmp	 DWORD PTR _itemdrop$[ebp], 0
  006c8	0f 85 d1 01 00
	00		 jne	 $LN52@gObjUserDi

; 9621 : 	{		
; 9622 : 		if( lpObj->m_PK_Level >= PK_LEVEL_DEFAULT+1 )

  006ce	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006d1	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  006d8	83 f9 04	 cmp	 ecx, 4
  006db	0f 8c 91 00 00
	00		 jl	 $LN53@gObjUserDi

; 9623 : 		{
; 9624 : 			count=MAX_EQUIPMENT*2;

  006e1	c7 45 fc 18 00
	00 00		 mov	 DWORD PTR _count$[ebp], 24 ; 00000018H
$LN2@gObjUserDi:

; 9625 : 			while(count--)	

  006e8	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  006eb	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv387[ebp], eax
  006f1	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  006f4	83 e9 01	 sub	 ecx, 1
  006f7	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  006fa	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv387[ebp], 0
  00701	74 6f		 je	 SHORT $LN53@gObjUserDi

; 9626 : 			{
; 9627 : 				number = (rand()%MAX_EQUIPMENT);

  00703	e8 00 00 00 00	 call	 _rand
  00708	99		 cdq
  00709	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0070e	f7 f9		 idiv	 ecx
  00710	89 55 f4	 mov	 DWORD PTR _number$[ebp], edx

; 9628 : 				
; 9629 : 				//    .
; 9630 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 9631 : 				//       .
; 9632 : 				if( lpObj->pInventory[number].IsItem() == TRUE
; 9633 : 					&& g_kJewelOfHarmonySystem.IsStrengthenByJewelOfHarmony( &lpObj->pInventory[number] ) == FALSE )
; 9634 : #else
; 9635 : 				if( lpObj->pInventory[number].IsItem() == TRUE )

  00713	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 168
  0071a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0071d	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00723	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00728	83 f8 01	 cmp	 eax, 1
  0072b	75 40		 jne	 SHORT $LN54@gObjUserDi

; 9636 : #endif //ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 9637 : 				{
; 9638 : 					PMSG_ITEMTHROW	pDropItem;
; 9639 : 					pDropItem.Ipos  = number;

  0072d	8a 45 f4	 mov	 al, BYTE PTR _number$[ebp]
  00730	88 45 e5	 mov	 BYTE PTR _pDropItem$2[ebp+5], al

; 9640 : 					pDropItem.px    = (BYTE)lpObj->X;

  00733	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00736	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  0073c	88 4d e3	 mov	 BYTE PTR _pDropItem$2[ebp+3], cl

; 9641 : 					pDropItem.py	= (BYTE)lpObj->Y;

  0073f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00742	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  00748	88 4d e4	 mov	 BYTE PTR _pDropItem$2[ebp+4], cl

; 9642 : 					if( CGItemDropRequest((LPPMSG_ITEMTHROW)&pDropItem, lpObj->m_Index, 1) == 0x01 ) 

  0074b	6a 01		 push	 1
  0074d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00750	8b 08		 mov	 ecx, DWORD PTR [eax]
  00752	51		 push	 ecx
  00753	8d 55 e0	 lea	 edx, DWORD PTR _pDropItem$2[ebp]
  00756	52		 push	 edx
  00757	e8 00 00 00 00	 call	 ?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z ; CGItemDropRequest
  0075c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0075f	83 f8 01	 cmp	 eax, 1
  00762	75 09		 jne	 SHORT $LN54@gObjUserDi

; 9643 : 					{
; 9644 : 						dropresult = 1;

  00764	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _dropresult$[ebp], 1

; 9645 : 						break;

  0076b	eb 05		 jmp	 SHORT $LN53@gObjUserDi
$LN54@gObjUserDi:

; 9646 : 					}
; 9647 : 				}
; 9648 : 			}

  0076d	e9 76 ff ff ff	 jmp	 $LN2@gObjUserDi
$LN53@gObjUserDi:

; 9649 : 		}
; 9650 : 		
; 9651 : 		//    ..
; 9652 : 		if( dropresult == 0 )

  00772	83 7d f0 00	 cmp	 DWORD PTR _dropresult$[ebp], 0
  00776	0f 85 23 01 00
	00		 jne	 $LN52@gObjUserDi

; 9653 : 		{
; 9654 : 			//   .
; 9655 : #ifdef PERSONAL_SHOP_20040113		
; 9656 : 			count=MAX_INVENTORY_EXTEND-MAX_EQUIPMENT;

  0077c	c7 45 fc 60 00
	00 00		 mov	 DWORD PTR _count$[ebp], 96 ; 00000060H
$LN4@gObjUserDi:

; 9657 : 			while(count--)	

  00783	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00786	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv407[ebp], eax
  0078c	8b 4d fc	 mov	 ecx, DWORD PTR _count$[ebp]
  0078f	83 e9 01	 sub	 ecx, 1
  00792	89 4d fc	 mov	 DWORD PTR _count$[ebp], ecx
  00795	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv407[ebp], 0
  0079c	0f 84 fd 00 00
	00		 je	 $LN52@gObjUserDi

; 9658 : 			{
; 9659 : 				number = MAX_EQUIPMENT+(rand()%(MAX_INVENTORY_EXTEND-MAX_EQUIPMENT));

  007a2	e8 00 00 00 00	 call	 _rand
  007a7	99		 cdq
  007a8	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  007ad	f7 f9		 idiv	 ecx
  007af	83 c2 0c	 add	 edx, 12			; 0000000cH
  007b2	89 55 f4	 mov	 DWORD PTR _number$[ebp], edx

; 9660 : #else
; 9661 : 			count=MAX_INVENTORY-MAX_EQUIPMENT;
; 9662 : 			while(count--)	
; 9663 : 			{
; 9664 : 				number = MAX_EQUIPMENT+(rand()%(MAX_INVENTORY-MAX_EQUIPMENT));
; 9665 : #endif
; 9666 : 
; 9667 : 				//   .
; 9668 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 9669 : 				//       .
; 9670 : 				if( lpObj->pInventory[number].IsItem() == TRUE
; 9671 : 					&& g_kJewelOfHarmonySystem.IsStrengthenByJewelOfHarmony( &lpObj->pInventory[number] ) == FALSE )
; 9672 : #else
; 9673 : 				if( lpObj->pInventory[number].IsItem() == TRUE )

  007b5	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 168
  007bc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007bf	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  007c5	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  007ca	83 f8 01	 cmp	 eax, 1
  007cd	0f 85 c7 00 00
	00		 jne	 $LN57@gObjUserDi

; 9674 : #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 9675 : 				{
; 9676 : #ifdef USER_DIE_NOT_DROP_HERORING_20040330		// ,    .
; 9677 : 					if( lpObj->pInventory[number].m_Type>=ITEM_HELPER+20 &&

  007d3	69 45 f4 a8 00
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 168
  007da	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  007dd	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  007e3	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  007e8	3d b4 01 00 00	 cmp	 eax, 436		; 000001b4H
  007ed	7c 39		 jl	 SHORT $LN58@gObjUserDi
  007ef	69 45 f4 a8 00
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 168
  007f6	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  007f9	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  007ff	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00804	83 f8 01	 cmp	 eax, 1
  00807	7c 1f		 jl	 SHORT $LN58@gObjUserDi
  00809	69 45 f4 a8 00
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 168
  00810	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00813	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00819	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  0081e	83 f8 02	 cmp	 eax, 2
  00821	7f 05		 jg	 SHORT $LN58@gObjUserDi

; 9678 : 						(	lpObj->pInventory[number].m_Level >= 1 &&		// 
; 9679 : 							lpObj->pInventory[number].m_Level <= 2			// 
; 9680 : 						))
; 9681 : 					{
; 9682 : 						continue;

  00823	e9 5b ff ff ff	 jmp	 $LN4@gObjUserDi
$LN58@gObjUserDi:

; 9683 : 					}
; 9684 : #endif
; 9685 : 					
; 9686 : 					PMSG_ITEMTHROW	pDropItem;
; 9687 : 					pDropItem.Ipos  = number;

  00828	8a 45 f4	 mov	 al, BYTE PTR _number$[ebp]
  0082b	88 45 dd	 mov	 BYTE PTR _pDropItem$1[ebp+5], al

; 9688 : 					pDropItem.px    = (BYTE)lpObj->X;

  0082e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00831	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  00837	88 4d db	 mov	 BYTE PTR _pDropItem$1[ebp+3], cl

; 9689 : 					pDropItem.py	= (BYTE)lpObj->Y;

  0083a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0083d	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  00843	88 4d dc	 mov	 BYTE PTR _pDropItem$1[ebp+4], cl

; 9690 : 					if( CGItemDropRequest((LPPMSG_ITEMTHROW)&pDropItem, lpObj->m_Index, 1) == 0x01 ) 

  00846	6a 01		 push	 1
  00848	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0084b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0084d	51		 push	 ecx
  0084e	8d 55 d8	 lea	 edx, DWORD PTR _pDropItem$1[ebp]
  00851	52		 push	 edx
  00852	e8 00 00 00 00	 call	 ?CGItemDropRequest@@YAHPAUPMSG_ITEMTHROW@@HH@Z ; CGItemDropRequest
  00857	83 c4 0c	 add	 esp, 12			; 0000000cH
  0085a	83 f8 01	 cmp	 eax, 1
  0085d	75 3b		 jne	 SHORT $LN57@gObjUserDi

; 9691 : 					{
; 9692 : 						dropresult = 1;

  0085f	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _dropresult$[ebp], 1

; 9693 : 						LogAddTD("[%s][%s] User Die Item Drop, ItemName:%s", lpObj->AccountID, lpObj->Name, lpObj->pInventory[number].GetName());

  00866	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 168
  0086d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00870	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00876	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0087b	50		 push	 eax
  0087c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0087f	83 c1 73	 add	 ecx, 115		; 00000073H
  00882	51		 push	 ecx
  00883	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00886	83 c2 68	 add	 edx, 104		; 00000068H
  00889	52		 push	 edx
  0088a	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@CKMJEEKH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5User?5Die?5Item?5Drop?0?5It@
  0088f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00895	83 c4 10	 add	 esp, 16			; 00000010H

; 9694 : 						break;

  00898	eb 05		 jmp	 SHORT $LN52@gObjUserDi
$LN57@gObjUserDi:

; 9695 : 					}
; 9696 : 				}
; 9697 : 			}

  0089a	e9 e4 fe ff ff	 jmp	 $LN4@gObjUserDi
$LN52@gObjUserDi:

; 9698 : 		}
; 9699 : 	}
; 9700 : 
; 9701 : 
; 9702 : #ifdef HERO_SYSTEM_MODIFY
; 9703 : 
; 9704 : 	if( itemvanish == 0 )
; 9705 : 	{		
; 9706 : 		if( lpObj->m_PK_Level >= PK_LEVEL_DEFAULT+1 )
; 9707 : 		{
; 9708 : 			count=MAX_EQUIPMENT*2;
; 9709 : 			while(count--)	
; 9710 : 			{
; 9711 : 				number = (rand()%MAX_EQUIPMENT);
; 9712 : 				
; 9713 : 				//    .
; 9714 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 9715 : 				//      .
; 9716 : 				if( lpObj->pInventory[number].IsItem() == TRUE
; 9717 : 					&& g_kJewelOfHarmonySystem.IsStrengthenByJewelOfHarmony( &lpObj->pInventory[number] ) == FALSE )
; 9718 : #else
; 9719 : 				if( lpObj->pInventory[number].IsItem() == TRUE )
; 9720 : #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 9721 : 				{
; 9722 : #ifdef USER_DIE_NOT_DROP_HERORING_20040330		// ,    .
; 9723 : 					if( lpObj->pInventory[number].m_Type>=ITEM_HELPER+20 &&
; 9724 : 						(	lpObj->pInventory[number].m_Level >= 1 &&		// 
; 9725 : 							lpObj->pInventory[number].m_Level <= 2			// 
; 9726 : 						))
; 9727 : 					{
; 9728 : 						continue;
; 9729 : 					}
; 9730 : #endif
; 9731 : 
; 9732 : 					//   .
; 9733 : 					gObjInventoryItemSet(lpObj->m_Index, number, 0xFF);
; 9734 : 					lpObj->pInventory[number].Clear();
; 9735 : 					GCInventoryItemDeleteSend(lpObj->m_Index, number, 1);
; 9736 : 					dropresult = 1;
; 9737 : 
; 9738 : 					LogAddTD("[%s][%s] User Die Item Vanish, ItemName:%s", lpObj->AccountID, lpObj->Name, lpObj->pInventory[number].GetName());
; 9739 : 					break;
; 9740 : 				}
; 9741 : 			}
; 9742 : 		}
; 9743 : 
; 9744 : 		//    ..
; 9745 : 		if( dropresult == 0 )
; 9746 : 		{
; 9747 : 			//    .
; 9748 : #ifdef PERSONAL_SHOP_20040113		
; 9749 : 			count=MAX_INVENTORY_EXTEND-MAX_EQUIPMENT;
; 9750 : 			while(count--)	
; 9751 : 			{
; 9752 : 				number = MAX_EQUIPMENT+(rand()%(MAX_INVENTORY_EXTEND-MAX_EQUIPMENT));
; 9753 : #else
; 9754 : 			count=MAX_INVENTORY-MAX_EQUIPMENT;
; 9755 : 			while(count--)	
; 9756 : 			{
; 9757 : 				number = MAX_EQUIPMENT+(rand()%(MAX_INVENTORY-MAX_EQUIPMENT));
; 9758 : #endif
; 9759 : 
; 9760 : 				//    .
; 9761 : 				if( lpObj->pInventory[number].IsItem() == TRUE )
; 9762 : 				{
; 9763 : #ifdef USER_DIE_NOT_DROP_HERORING_20040330		// ,    .
; 9764 : 					if( lpObj->pInventory[number].m_Type>=ITEM_HELPER+20 &&
; 9765 : 						(	lpObj->pInventory[number].m_Level >= 1 &&		// 
; 9766 : 							lpObj->pInventory[number].m_Level <= 2			// 
; 9767 : 						))
; 9768 : 					{
; 9769 : 						continue;
; 9770 : 					}
; 9771 : #endif
; 9772 : 
; 9773 : 					//   .
; 9774 : 					gObjInventoryItemSet(lpObj->m_Index, number, 0xFF);
; 9775 : 					lpObj->pInventory[number].Clear();
; 9776 : 					GCInventoryItemDeleteSend(lpObj->m_Index, number, 1);
; 9777 : 					dropresult = 1;
; 9778 : 
; 9779 : 					LogAddTD("[%s][%s] User Die Item Vanish, ItemName:%s", lpObj->AccountID, lpObj->Name, lpObj->pInventory[number].GetName());
; 9780 : 					break;
; 9781 : 				}
; 9782 : 			}
; 9783 : 		}
; 9784 : 	}
; 9785 : 
; 9786 : #endif
; 9787 : 
; 9788 : 
; 9789 : #ifdef DUEL_SYSTEM_20031028
; 9790 : 	//   ..
; 9791 : 	if( lpObj->Type == OBJTYPE_CHARACTER && lpTargetObj->Type == OBJTYPE_CHARACTER ) 

  0089f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008a2	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  008a6	83 f9 01	 cmp	 ecx, 1
  008a9	75 55		 jne	 SHORT $LN60@gObjUserDi
  008ab	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  008ae	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  008b2	83 f9 01	 cmp	 ecx, 1
  008b5	75 49		 jne	 SHORT $LN60@gObjUserDi

; 9792 : 	{
; 9793 : 		if (IsOnDuel(lpObj->m_Index, lpTargetObj->m_Index)) 

  008b7	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  008ba	8b 08		 mov	 ecx, DWORD PTR [eax]
  008bc	51		 push	 ecx
  008bd	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008c0	8b 02		 mov	 eax, DWORD PTR [edx]
  008c2	50		 push	 eax
  008c3	e8 00 00 00 00	 call	 ?IsOnDuel@@YA_NHH@Z	; IsOnDuel
  008c8	83 c4 08	 add	 esp, 8
  008cb	0f b6 c8	 movzx	 ecx, al
  008ce	85 c9		 test	 ecx, ecx
  008d0	74 29		 je	 SHORT $LN61@gObjUserDi

; 9794 : 		{
; 9795 : #ifdef ADD_NEWPVP_PKFIELD
; 9796 : 			g_NewPVP.SetScore(*lpTargetObj);
; 9797 : #else
; 9798 : 			lpTargetObj->m_btDuelScore++;

  008d2	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  008d5	8a 88 f0 0c 00
	00		 mov	 cl, BYTE PTR [eax+3312]
  008db	80 c1 01	 add	 cl, 1
  008de	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  008e1	88 8a f0 0c 00
	00		 mov	 BYTE PTR [edx+3312], cl

; 9799 : 			GCSendDuelScore(lpObj->m_Index, lpTargetObj->m_Index);

  008e7	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  008ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  008ec	51		 push	 ecx
  008ed	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008f0	8b 02		 mov	 eax, DWORD PTR [edx]
  008f2	50		 push	 eax
  008f3	e8 00 00 00 00	 call	 ?GCSendDuelScore@@YAXHH@Z ; GCSendDuelScore
  008f8	83 c4 08	 add	 esp, 8
$LN61@gObjUserDi:

; 9800 : #endif // ADD_NEWPVP_PKFIELD
; 9801 : 		}
; 9802 : 
; 9803 : 
; 9804 : 		return;	

  008fb	e9 f5 02 00 00	 jmp	 $LN1@gObjUserDi
$LN60@gObjUserDi:

; 9805 : 	}
; 9806 : #else
; 9807 : 	//   ..
; 9808 : 	if( lpObj->Type == OBJTYPE_CHARACTER && lpTargetObj->Type == OBJTYPE_CHARACTER ) return;
; 9809 : #endif	
; 9810 : 	
; 9811 : 	//------------------------------------------------------------------------
; 9812 : 	//   .
; 9813 : 	//------------------------------------------------------------------------
; 9814 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	
; 9815 : 	INT64 minexp = gLevelExperience[lpObj->Level-1];
; 9816 : 	INT64 maxexp = gLevelExperience[lpObj->Level];
; 9817 : 	INT64 subexp = 0;
; 9818 : 	INT64 decexp = 0;
; 9819 : #else
; 9820 : 	DWORD minexp = gLevelExperience[lpObj->Level-1];

  00900	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00903	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0090a	8b 14 8d fc ff
	ff ff		 mov	 edx, DWORD PTR ?gLevelExperience@@3PAKA[ecx*4-4]
  00911	89 55 d4	 mov	 DWORD PTR _minexp$[ebp], edx

; 9821 : 	DWORD maxexp = gLevelExperience[lpObj->Level];

  00914	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00917	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0091e	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?gLevelExperience@@3PAKA[ecx*4]
  00925	89 55 d0	 mov	 DWORD PTR _maxexp$[ebp], edx

; 9822 : 	DWORD subexp = 0;

  00928	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _subexp$[ebp], 0

; 9823 : 	DWORD decexp = 0;

  0092f	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _decexp$[ebp], 0

; 9824 : #endif
; 9825 : 
; 9826 : 	int	decexprate = 0;		//  

  00936	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _decexprate$[ebp], 0

; 9827 : 
; 9828 : 	//     
; 9829 : 	char tmpPKLevel = PK_LEVEL_DEFAULT;	//  PK 

  0093d	c6 45 c3 03	 mov	 BYTE PTR _tmpPKLevel$[ebp], 3

; 9830 : 
; 9831 : 	if(lpObj->PartyNumber >= 0)

  00941	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00944	83 b8 88 02 00
	00 00		 cmp	 DWORD PTR [eax+648], 0
  0094b	7c 0e		 jl	 SHORT $LN62@gObjUserDi

; 9832 : 	{
; 9833 : #ifdef UPDATE_PK_SYSTEM_20070302
; 9834 : 		//  
; 9835 : 		if(gParty.GetPKPartyPenalty(lpObj->PartyNumber) >= PK_LEVEL_DEFAULT+2)
; 9836 : 		{
; 9837 : 			tmpPKLevel = gParty.GetPKPartyPenalty(lpObj->PartyNumber);
; 9838 : 		}
; 9839 : 		else
; 9840 : #endif
; 9841 : 		{
; 9842 : 			tmpPKLevel = lpObj->m_PK_Level;

  0094d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00950	8a 88 fd 00 00
	00		 mov	 cl, BYTE PTR [eax+253]
  00956	88 4d c3	 mov	 BYTE PTR _tmpPKLevel$[ebp], cl

; 9843 : 		}
; 9844 : 	}

  00959	eb 0c		 jmp	 SHORT $LN63@gObjUserDi
$LN62@gObjUserDi:

; 9845 : 	else
; 9846 : 	{
; 9847 : 		tmpPKLevel = lpObj->m_PK_Level;

  0095b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0095e	8a 88 fd 00 00
	00		 mov	 cl, BYTE PTR [eax+253]
  00964	88 4d c3	 mov	 BYTE PTR _tmpPKLevel$[ebp], cl
$LN63@gObjUserDi:

; 9848 : 	}
; 9849 : 
; 9850 : 
; 9851 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912		//   
; 9852 : 	// decexprate 1/1000  .
; 9853 : 	if( g_MasterLevelSystem.IsMasterLevelUser( lpObj ) )
; 9854 : 	{
; 9855 : 		 // 1. min/max  
; 9856 : 		minexp = g_MasterLevelSystem.GetMasterLevelExpTlbInfo( lpObj->m_nMasterLevel );
; 9857 : 		maxexp = g_MasterLevelSystem.GetMasterLevelExpTlbInfo( lpObj->m_nMasterLevel + 1 );	
; 9858 : 		
; 9859 : 		// 2.  
; 9860 : 		decexprate = g_MasterLevelSystem.GetDieDecExpRate( lpObj );
; 9861 : 	}	
; 9862 : 	else	//  .
; 9863 : 	{
; 9864 : 		if( lpObj->Level <= 10  )
; 9865 : 		{	// 5   
; 9866 : 			decexprate = 0;
; 9867 : 		}
; 9868 : 		else if( lpObj->Level <= 150  )
; 9869 : 		{
; 9870 : 			if( tmpPKLevel == PK_LEVEL_DEFAULT-1 ) decexprate = 20;		// 1
; 9871 : 			else if( tmpPKLevel == PK_LEVEL_DEFAULT   ) decexprate = 10;	// 
; 9872 : 			else if( tmpPKLevel == PK_LEVEL_DEFAULT+1 ) decexprate = 50;	//  1
; 9873 : 			else if( tmpPKLevel == PK_LEVEL_DEFAULT+2 ) decexprate = 60;	//  2
; 9874 : 			else if( tmpPKLevel >= PK_LEVEL_DEFAULT+3 ) decexprate = 70;	//  3
; 9875 : 			else decexprate = 20;					//  2
; 9876 : 		}
; 9877 : 		else if( lpObj->Level <= 220 )
; 9878 : 		{
; 9879 : 			if( tmpPKLevel == PK_LEVEL_DEFAULT-1 ) decexprate = 10;
; 9880 : 			else if( tmpPKLevel == PK_LEVEL_DEFAULT   ) decexprate = 10;
; 9881 : 			else if( tmpPKLevel == PK_LEVEL_DEFAULT+1 ) decexprate = 40;
; 9882 : 			else if( tmpPKLevel == PK_LEVEL_DEFAULT+2 ) decexprate = 50;
; 9883 : 			else if( tmpPKLevel >= PK_LEVEL_DEFAULT+3 ) decexprate = 60;
; 9884 : 			else decexprate = 10;
; 9885 : 		}
; 9886 : 		else 
; 9887 : 		{
; 9888 : 			if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT-1 ) decexprate = 10;
; 9889 : 			else if( tmpPKLevel == PK_LEVEL_DEFAULT   ) decexprate = 10;
; 9890 : 			else if( tmpPKLevel == PK_LEVEL_DEFAULT+1 ) decexprate = 30;
; 9891 : 			else if( tmpPKLevel == PK_LEVEL_DEFAULT+2 ) decexprate = 40;
; 9892 : 			else if( tmpPKLevel >= PK_LEVEL_DEFAULT+3 ) decexprate = 50;
; 9893 : 			else decexprate = 10;
; 9894 : 		}
; 9895 : 	}
; 9896 : 
; 9897 : #ifdef MODIFY_MINLEVEL_EXPRATE_20080630
; 9898 : 	decexp = 0;
; 9899 : 	if (decexprate > 0) {
; 9900 : 		decexp = ( ( maxexp - minexp ) * decexprate ) / 1000;
; 9901 : 	}
; 9902 : #else
; 9903 : 	if( decexprate <= 0)
; 9904 : 		decexprate = 1;
; 9905 : 	
; 9906 : 	decexp = ( ( maxexp - minexp ) * decexprate ) / 1000;
; 9907 : #endif // MODIFY_MINLEVEL_EXPRATE_20080630
; 9908 : 
; 9909 : #else	//MASTER_LEVEL_UP_SYSTEM_20070912
; 9910 : #ifdef UPDATE_PK_SYSTEM_20070302		//     
; 9911 : 	if(lpObj->PartyNumber >= 0)
; 9912 : 	{
; 9913 : 		//  
; 9914 : 		if(gParty.GetPKPartyPenalty(lpObj->PartyNumber) >= PK_LEVEL_DEFAULT+2)
; 9915 : 		{
; 9916 : 			tmpPKLevel = gParty.GetPKPartyPenalty(lpObj->PartyNumber);
; 9917 : 		}
; 9918 : 		else
; 9919 : 		{
; 9920 : 			tmpPKLevel = lpObj->m_PK_Level;
; 9921 : 		}
; 9922 : 	}
; 9923 : 	else
; 9924 : 	{
; 9925 : 		tmpPKLevel = lpObj->m_PK_Level;
; 9926 : 	}
; 9927 : 
; 9928 : 	if( lpObj->Level <= 10  )
; 9929 : 	{	// 5   
; 9930 : 		decexprate = 0;
; 9931 : 	}
; 9932 : 	else if( lpObj->Level <= 150  )
; 9933 : 	{
; 9934 : 		if( tmpPKLevel == PK_LEVEL_DEFAULT-1 ) decexprate = 2;		// 1
; 9935 : 		else if( tmpPKLevel == PK_LEVEL_DEFAULT   ) decexprate = 1;	// 
; 9936 : 		else if( tmpPKLevel == PK_LEVEL_DEFAULT+1 ) decexprate = 5;	//  1
; 9937 : 		else if( tmpPKLevel == PK_LEVEL_DEFAULT+2 ) decexprate = 6;	//  2
; 9938 : 		else if( tmpPKLevel >= PK_LEVEL_DEFAULT+3 ) decexprate = 7;	//  3
; 9939 : 		else decexprate = 2;					//  2
; 9940 : 	}
; 9941 : 	else if( lpObj->Level <= 220 )
; 9942 : 	{
; 9943 : 		if( tmpPKLevel == PK_LEVEL_DEFAULT-1 ) decexprate = 1;
; 9944 : 		else if( tmpPKLevel == PK_LEVEL_DEFAULT   ) decexprate = 1;
; 9945 : 		else if( tmpPKLevel == PK_LEVEL_DEFAULT+1 ) decexprate = 4;
; 9946 : 		else if( tmpPKLevel == PK_LEVEL_DEFAULT+2 ) decexprate = 5;
; 9947 : 		else if( tmpPKLevel >= PK_LEVEL_DEFAULT+3 ) decexprate = 6;
; 9948 : 		else decexprate = 1;
; 9949 : 	}
; 9950 : 	else 
; 9951 : 	{
; 9952 : 		if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT-1 ) decexprate = 1;
; 9953 : 		else if( tmpPKLevel == PK_LEVEL_DEFAULT   ) decexprate = 1;
; 9954 : 		else if( tmpPKLevel == PK_LEVEL_DEFAULT+1 ) decexprate = 3;
; 9955 : 		else if( tmpPKLevel == PK_LEVEL_DEFAULT+2 ) decexprate = 4;
; 9956 : 		else if( tmpPKLevel >= PK_LEVEL_DEFAULT+3 ) decexprate = 5;
; 9957 : 		else decexprate = 1;
; 9958 : 	}
; 9959 : #endif	// UPDATE_PK_SYSTEM_20070302
; 9960 : 
; 9961 : 	decexp = (((maxexp-minexp)*decexprate)/100);

  00967	8b 45 d0	 mov	 eax, DWORD PTR _maxexp$[ebp]
  0096a	2b 45 d4	 sub	 eax, DWORD PTR _minexp$[ebp]
  0096d	0f af 45 c4	 imul	 eax, DWORD PTR _decexprate$[ebp]
  00971	33 d2		 xor	 edx, edx
  00973	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00978	f7 f1		 div	 ecx
  0097a	89 45 c8	 mov	 DWORD PTR _decexp$[ebp], eax

; 9962 : #endif //MASTER_LEVEL_UP_SYSTEM_20070912
; 9963 : 	
; 9964 : 
; 9965 : #ifdef CRYWOLF_MAIN_SCHEDULER_20050505
; 9966 : 	if( g_Crywolf.GetCrywolfState() == CRYWOLF_STATE_START 
; 9967 : 		&& lpObj->MapNumber == MAP_INDEX_CRYWOLF_FIRSTZONE )
; 9968 : 	{
; 9969 : 		// MVP    0% .
; 9970 : 		decexp = decexp * 0;
; 9971 : 	}
; 9972 : #endif
; 9973 : 
; 9974 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912
; 9975 : 	//        .
; 9976 : 	if( g_MasterLevelSystem.IsMasterLevelUser( lpObj ) )
; 9977 : 	{
; 9978 : 		subexp = lpObj->m_i64MasterLevelExp - decexp;
; 9979 : 	}
; 9980 : 	else
; 9981 : 	{
; 9982 : 		subexp = lpObj->Experience-decexp;
; 9983 : 	}
; 9984 : #else
; 9985 : 	subexp = lpObj->Experience-decexp;

  0097d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00980	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00986	2b 4d c8	 sub	 ecx, DWORD PTR _decexp$[ebp]
  00989	89 4d cc	 mov	 DWORD PTR _subexp$[ebp], ecx

; 9986 : #endif
; 9987 : 	if( subexp < minexp ) subexp = minexp;

  0098c	8b 45 cc	 mov	 eax, DWORD PTR _subexp$[ebp]
  0098f	3b 45 d4	 cmp	 eax, DWORD PTR _minexp$[ebp]
  00992	73 06		 jae	 SHORT $LN64@gObjUserDi
  00994	8b 45 d4	 mov	 eax, DWORD PTR _minexp$[ebp]
  00997	89 45 cc	 mov	 DWORD PTR _subexp$[ebp], eax
$LN64@gObjUserDi:

; 9988 : 
; 9989 : //#BUGFIX_20040602_ExpLog (apple)
; 9990 : 	LogAddTD("[%s][%s] Death reduces Experience %u - %d", lpObj->AccountID, lpObj->Name, subexp, decexp);

  0099a	8b 45 c8	 mov	 eax, DWORD PTR _decexp$[ebp]
  0099d	50		 push	 eax
  0099e	8b 4d cc	 mov	 ecx, DWORD PTR _subexp$[ebp]
  009a1	51		 push	 ecx
  009a2	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  009a5	83 c2 73	 add	 edx, 115		; 00000073H
  009a8	52		 push	 edx
  009a9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009ac	83 c0 68	 add	 eax, 104		; 00000068H
  009af	50		 push	 eax
  009b0	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PAJOKIHI@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Death?5reduces?5Experien@
  009b5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  009bb	83 c4 14	 add	 esp, 20			; 00000014H

; 9991 : 	//------------------------------------------------------------------------
; 9992 : 	//   .
; 9993 : 	//------------------------------------------------------------------------
; 9994 : #ifdef USER_DIE_ZEN_BUG_PATCH_20040319
; 9995 : 	DWORD submoney = 0;

  009be	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _submoney$[ebp], 0

; 9996 : #else
; 9997 : 	int submoney = 0;
; 9998 : #endif	
; 9999 : 
; 10000: #ifdef MASTER_LEVEL_UP_SYSTEM_20070912
; 10001: 	//      
; 10002: 	int iDownMoneyRate = 0;
; 10003: #endif
; 10004: 	
; 10005: 	//   A
; 10006: 	if( lpObj->Money > 0 )

  009c5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009c8	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [eax+176], 0
  009cf	0f 8e fb 00 00
	00		 jle	 $LN65@gObjUserDi

; 10007: 	{
; 10008: #ifdef MASTER_LEVEL_UP_SYSTEM_20070912			//   
; 10009: 		iDownMoneyRate = g_MasterLevelSystem.GetDieDecZenRate( lpObj );
; 10010: 		if( iDownMoneyRate < 0 )	//  
; 10011: 		{
; 10012: 			if(	lpObj->Level >    10 && lpObj->Level <=  99 )		iDownMoneyRate = 1;
; 10013: 			else if( lpObj->Level >= 100 && lpObj->Level <= 199 )	iDownMoneyRate = 2;
; 10014: 			else if( lpObj->Level >  200 )							iDownMoneyRate = 3;
; 10015: 		}
; 10016: 
; 10017: 		if( iDownMoneyRate > 0 )
; 10018: 		{
; 10019: 			submoney = ( (DWORD)lpObj->Money * iDownMoneyRate ) / 100;
; 10020: 		}
; 10021: #else
; 10022: 		if(		 lpObj->Level >    10 && lpObj->Level <=  99 ) submoney = ((DWORD)lpObj->Money*1)/100;

  009d5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009d8	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  009df	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  009e2	7e 26		 jle	 SHORT $LN66@gObjUserDi
  009e4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009e7	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  009ee	83 f9 63	 cmp	 ecx, 99			; 00000063H
  009f1	7f 17		 jg	 SHORT $LN66@gObjUserDi
  009f3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009f6	8b 80 b0 00 00
	00		 mov	 eax, DWORD PTR [eax+176]
  009fc	33 d2		 xor	 edx, edx
  009fe	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00a03	f7 f1		 div	 ecx
  00a05	89 45 bc	 mov	 DWORD PTR _submoney$[ebp], eax
  00a08	eb 62		 jmp	 SHORT $LN67@gObjUserDi
$LN66@gObjUserDi:

; 10023: 		else if( lpObj->Level >= 100 && lpObj->Level <= 199 ) submoney = ((DWORD)lpObj->Money*2)/100;

  00a0a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a0d	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00a14	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00a17	7c 2b		 jl	 SHORT $LN68@gObjUserDi
  00a19	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a1c	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00a23	81 f9 c7 00 00
	00		 cmp	 ecx, 199		; 000000c7H
  00a29	7f 19		 jg	 SHORT $LN68@gObjUserDi
  00a2b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a2e	8b 80 b0 00 00
	00		 mov	 eax, DWORD PTR [eax+176]
  00a34	d1 e0		 shl	 eax, 1
  00a36	33 d2		 xor	 edx, edx
  00a38	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00a3d	f7 f1		 div	 ecx
  00a3f	89 45 bc	 mov	 DWORD PTR _submoney$[ebp], eax
  00a42	eb 28		 jmp	 SHORT $LN67@gObjUserDi
$LN68@gObjUserDi:

; 10024: 		else if( lpObj->Level >  200 )						  submoney = ((DWORD)lpObj->Money*3)/100;

  00a44	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a47	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00a4e	81 f9 c8 00 00
	00		 cmp	 ecx, 200		; 000000c8H
  00a54	7e 16		 jle	 SHORT $LN67@gObjUserDi
  00a56	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a59	6b 80 b0 00 00
	00 03		 imul	 eax, DWORD PTR [eax+176], 3
  00a60	33 d2		 xor	 edx, edx
  00a62	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00a67	f7 f1		 div	 ecx
  00a69	89 45 bc	 mov	 DWORD PTR _submoney$[ebp], eax
$LN67@gObjUserDi:

; 10025: #endif	// MASTER_LEVEL_UP_SYSTEM_20070912
; 10026: 
; 10027: 		lpObj->Money -= submoney;

  00a6c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a6f	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00a75	2b 4d bc	 sub	 ecx, DWORD PTR _submoney$[ebp]
  00a78	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a7b	89 8a b0 00 00
	00		 mov	 DWORD PTR [edx+176], ecx

; 10028: 		if( lpObj->Money < 0 ) lpObj->Money = 0;

  00a81	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a84	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [eax+176], 0
  00a8b	7d 0d		 jge	 SHORT $LN71@gObjUserDi
  00a8d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a90	c7 80 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+176], 0
$LN71@gObjUserDi:

; 10029: 		LogAddTD(lMsg.Get(574), lpObj->AccountID, lpObj->Name, lpObj->Money, submoney);

  00a9a	8b 45 bc	 mov	 eax, DWORD PTR _submoney$[ebp]
  00a9d	50		 push	 eax
  00a9e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00aa1	8b 91 b0 00 00
	00		 mov	 edx, DWORD PTR [ecx+176]
  00aa7	52		 push	 edx
  00aa8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00aab	83 c0 73	 add	 eax, 115		; 00000073H
  00aae	50		 push	 eax
  00aaf	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00ab2	83 c1 68	 add	 ecx, 104		; 00000068H
  00ab5	51		 push	 ecx
  00ab6	68 3e 02 00 00	 push	 574			; 0000023eH
  00abb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00ac0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00ac6	50		 push	 eax
  00ac7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00acd	83 c4 14	 add	 esp, 20			; 00000014H
$LN65@gObjUserDi:

; 10030: 	}
; 10031: 	//   ..
; 10032: 	if( lpObj->WarehouseMoney > 0 )

  00ad0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ad3	83 b8 a4 0c 00
	00 00		 cmp	 DWORD PTR [eax+3236], 0
  00ada	0f 8e 09 01 00
	00		 jle	 $LN72@gObjUserDi

; 10033: 	{
; 10034: #ifdef MASTER_LEVEL_UP_SYSTEM_20070912			//   
; 10035: 		submoney = 0;
; 10036: 
; 10037: 		iDownMoneyRate = g_MasterLevelSystem.GetDieDecZenRate( lpObj );
; 10038: 		if( iDownMoneyRate < 0 )
; 10039: 		{
; 10040: 			if(		 lpObj->Level >    10 && lpObj->Level <=  99 ) iDownMoneyRate = 1;
; 10041: 			else if( lpObj->Level >= 100 && lpObj->Level <= 199 ) iDownMoneyRate = 2;
; 10042: 			else if( lpObj->Level >  200 )						  iDownMoneyRate = 3;
; 10043: 		}
; 10044: 
; 10045: 		if( iDownMoneyRate > 0 )
; 10046: 		{
; 10047: 			submoney = ( (DWORD)lpObj->Money * iDownMoneyRate ) / 100;
; 10048: 		}
; 10049: #else
; 10050: 		if(		 lpObj->Level >    10 && lpObj->Level <=  99 ) submoney = ((DWORD)lpObj->WarehouseMoney*1)/100;

  00ae0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ae3	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00aea	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00aed	7e 26		 jle	 SHORT $LN73@gObjUserDi
  00aef	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00af2	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00af9	83 f9 63	 cmp	 ecx, 99			; 00000063H
  00afc	7f 17		 jg	 SHORT $LN73@gObjUserDi
  00afe	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b01	8b 80 a4 0c 00
	00		 mov	 eax, DWORD PTR [eax+3236]
  00b07	33 d2		 xor	 edx, edx
  00b09	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00b0e	f7 f1		 div	 ecx
  00b10	89 45 bc	 mov	 DWORD PTR _submoney$[ebp], eax
  00b13	eb 62		 jmp	 SHORT $LN74@gObjUserDi
$LN73@gObjUserDi:

; 10051: 		else if( lpObj->Level >= 100 && lpObj->Level <= 199 ) submoney = ((DWORD)lpObj->WarehouseMoney*2)/100;

  00b15	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b18	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00b1f	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00b22	7c 2b		 jl	 SHORT $LN75@gObjUserDi
  00b24	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b27	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00b2e	81 f9 c7 00 00
	00		 cmp	 ecx, 199		; 000000c7H
  00b34	7f 19		 jg	 SHORT $LN75@gObjUserDi
  00b36	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b39	8b 80 a4 0c 00
	00		 mov	 eax, DWORD PTR [eax+3236]
  00b3f	d1 e0		 shl	 eax, 1
  00b41	33 d2		 xor	 edx, edx
  00b43	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00b48	f7 f1		 div	 ecx
  00b4a	89 45 bc	 mov	 DWORD PTR _submoney$[ebp], eax
  00b4d	eb 28		 jmp	 SHORT $LN74@gObjUserDi
$LN75@gObjUserDi:

; 10052: 		else if( lpObj->Level >  200 )						  submoney = ((DWORD)lpObj->WarehouseMoney*3)/100;

  00b4f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b52	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00b59	81 f9 c8 00 00
	00		 cmp	 ecx, 200		; 000000c8H
  00b5f	7e 16		 jle	 SHORT $LN74@gObjUserDi
  00b61	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b64	6b 80 a4 0c 00
	00 03		 imul	 eax, DWORD PTR [eax+3236], 3
  00b6b	33 d2		 xor	 edx, edx
  00b6d	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00b72	f7 f1		 div	 ecx
  00b74	89 45 bc	 mov	 DWORD PTR _submoney$[ebp], eax
$LN74@gObjUserDi:

; 10053: #endif	// MASTER_LEVEL_UP_SYSTEM_20070912
; 10054: 		
; 10055: 		lpObj->WarehouseMoney -= submoney;

  00b77	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b7a	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  00b80	2b 4d bc	 sub	 ecx, DWORD PTR _submoney$[ebp]
  00b83	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b86	89 8a a4 0c 00
	00		 mov	 DWORD PTR [edx+3236], ecx

; 10056: 		if( lpObj->WarehouseMoney < 0 ) lpObj->WarehouseMoney = 0;

  00b8c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b8f	83 b8 a4 0c 00
	00 00		 cmp	 DWORD PTR [eax+3236], 0
  00b96	7d 0d		 jge	 SHORT $LN78@gObjUserDi
  00b98	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b9b	c7 80 a4 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3236], 0
$LN78@gObjUserDi:

; 10057: 		GDSetWarehouseMoney(lpObj->m_Index);

  00ba5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ba8	8b 08		 mov	 ecx, DWORD PTR [eax]
  00baa	51		 push	 ecx
  00bab	e8 00 00 00 00	 call	 ?GDSetWarehouseMoney@@YAXH@Z ; GDSetWarehouseMoney
  00bb0	83 c4 04	 add	 esp, 4

; 10058: 		LogAddTD(lMsg.Get(575), lpObj->AccountID, lpObj->Name, lpObj->WarehouseMoney, submoney);

  00bb3	8b 45 bc	 mov	 eax, DWORD PTR _submoney$[ebp]
  00bb6	50		 push	 eax
  00bb7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bba	8b 91 a4 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3236]
  00bc0	52		 push	 edx
  00bc1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bc4	83 c0 73	 add	 eax, 115		; 00000073H
  00bc7	50		 push	 eax
  00bc8	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bcb	83 c1 68	 add	 ecx, 104		; 00000068H
  00bce	51		 push	 ecx
  00bcf	68 3f 02 00 00	 push	 575			; 0000023fH
  00bd4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00bd9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00bdf	50		 push	 eax
  00be0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00be6	83 c4 14	 add	 esp, 20			; 00000014H
$LN72@gObjUserDi:

; 10059: 	}
; 10060: 
; 10061: #ifdef MASTER_LEVEL_UP_SYSTEM_20070912
; 10062: 	//        .
; 10063: 	if( g_MasterLevelSystem.IsMasterLevelUser( lpObj ) )
; 10064: 	{
; 10065: 		lpObj->m_i64MasterLevelExp = subexp;
; 10066: 	}
; 10067: 	else
; 10068: 	{
; 10069: 		lpObj->Experience = subexp;
; 10070: 	}
; 10071: #else	
; 10072: 	lpObj->Experience = subexp;

  00be9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bec	8b 4d cc	 mov	 ecx, DWORD PTR _subexp$[ebp]
  00bef	89 88 a8 00 00
	00		 mov	 DWORD PTR [eax+168], ecx
$LN1@gObjUserDi:

; 10073: #endif
; 10074: }

  00bf5	5f		 pop	 edi
  00bf6	5e		 pop	 esi
  00bf7	5b		 pop	 ebx
  00bf8	8b e5		 mov	 esp, ebp
  00bfa	5d		 pop	 ebp
  00bfb	c3		 ret	 0
?gObjUserDie@@YAXPAVOBJECTSTRUCT@@0@Z ENDP		; gObjUserDie
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjPlayerKiller@@YAXPAVOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
tv73 = -96						; size = 4
tv74 = -92						; size = 4
_TargetTmpPKLevel$ = -21				; size = 1
_iOriginPkCount$ = -20					; size = 4
_iOriginPkLevel$ = -16					; size = 4
_n$1 = -12						; size = 4
_nSelfDefenseUser$ = -8					; size = 4
_partynum$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjPlayerKiller@@YAXPAVOBJECTSTRUCT@@0@Z PROC		; gObjPlayerKiller, COMDAT

; 8777 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 8778 : 	
; 8779 : 	if( lpObj->Type != OBJTYPE_CHARACTER ) return;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00010	83 f9 01	 cmp	 ecx, 1
  00013	74 05		 je	 SHORT $LN5@gObjPlayer
  00015	e9 1f 04 00 00	 jmp	 $LN1@gObjPlayer
$LN5@gObjPlayer:

; 8780 : 
; 8781 : #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 8782 : 	return;		//    
; 8783 : #endif
; 8784 : 
; 8785 : #ifdef ADD_NEW_UNION_01_20041006
; 8786 : 	//     .
; 8787 : 	if( gObjGetRelationShip(lpObj, lpTargetObj) == G_RELATIONSHIP_RIVAL )
; 8788 : 	{
; 8789 : 		if( lpObj->lpGuild && lpTargetObj->lpGuild )
; 8790 : 		{
; 8791 : 			//    ?
; 8792 : 
; 8793 : 			LogAddTD("[U.System][Rival][Player Kill] ( Killer [%s][%s] / %s / U:%d / R:%d ) vs ( Victim [%s][%s] / %s / U:%d / R:%d )",
; 8794 : 				lpObj->AccountID, lpObj->Name, lpObj->lpGuild->Name, lpObj->lpGuild->iGuildUnion, lpObj->lpGuild->iGuildRival,
; 8795 : 				lpTargetObj->AccountID, lpTargetObj->Name, lpTargetObj->lpGuild->Name, lpTargetObj->lpGuild->iGuildUnion, lpTargetObj->lpGuild->iGuildRival );
; 8796 : 		}
; 8797 : 		else
; 8798 : 		{
; 8799 : 			LogAddTD("[U.System][Rival][Player Kill][ERROR : Can't find GuildInfo] (  [%s][%s] ) vs ( [%s][%s] )", lpObj->AccountID, lpObj->Name, lpTargetObj->AccountID, lpTargetObj->Name );
; 8800 : 		}
; 8801 : 		
; 8802 : 		return;
; 8803 : 	}
; 8804 : #endif
; 8805 : 
; 8806 : #ifdef CHAOSCASTLE_SYSTEM_20040408			//       PK .
; 8807 : 	if (CHECK_CHAOSCASTLE(lpTargetObj->MapNumber) && 

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0001d	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00024	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00027	7d 09		 jge	 SHORT $LN52@gObjPlayer
  00029	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  00030	eb 25		 jmp	 SHORT $LN53@gObjPlayer
$LN52@gObjPlayer:
  00032	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00035	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0003c	83 f8 17	 cmp	 eax, 23			; 00000017H
  0003f	7e 09		 jle	 SHORT $LN50@gObjPlayer
  00041	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00048	eb 07		 jmp	 SHORT $LN51@gObjPlayer
$LN50@gObjPlayer:
  0004a	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
$LN51@gObjPlayer:
  00051	8b 4d a0	 mov	 ecx, DWORD PTR tv73[ebp]
  00054	89 4d a4	 mov	 DWORD PTR tv74[ebp], ecx
$LN53@gObjPlayer:
  00057	83 7d a4 00	 cmp	 DWORD PTR tv74[ebp], 0
  0005b	74 22		 je	 SHORT $LN6@gObjPlayer
  0005d	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00060	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00067	83 e9 12	 sub	 ecx, 18			; 00000012H
  0006a	51		 push	 ecx
  0006b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00070	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState
  00075	83 f8 02	 cmp	 eax, 2
  00078	75 05		 jne	 SHORT $LN6@gObjPlayer

; 8808 : #ifdef ADD_CHAOSCASTLE_FOR_MASTER_LEVEL_20071010	//   
; 8809 : 		(g_ChaosCastle.GetCurrentState( g_ChaosCastle.GetChaosCastleByMapNum( lpTargetObj->MapNumber ) ) == CHAOSCASTLE_STATE_PLAYING)
; 8810 : #else
; 8811 : 		(g_ChaosCastle.GetCurrentState(lpTargetObj->MapNumber - MAP_INDEX_CHAOSCASTLE1) == CHAOSCASTLE_STATE_PLAYING)
; 8812 : #endif
; 8813 : 		)
; 8814 : 	{
; 8815 : 		return;

  0007a	e9 ba 03 00 00	 jmp	 $LN1@gObjPlayer
$LN6@gObjPlayer:

; 8816 : 	}
; 8817 : #endif
; 8818 : 
; 8819 : #ifdef CASTLE_MAIN_SCHEDULER_20041111		//       PK .
; 8820 : 	if (lpTargetObj->MapNumber == MAP_INDEX_CASTLESIEGE)
; 8821 : 	{
; 8822 : 		if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE) {
; 8823 : 			if (lpObj->m_btCsJoinSide != CS_SIEGESIDE_NONE) {
; 8824 : 				return;
; 8825 : 			}
; 8826 : 		}
; 8827 : 		else 
; 8828 : 		{
; 8829 : 
; 8830 : 
; 8831 : #ifdef MODIFY_CASTLE_PK_01_20050309
; 8832 : 			//      PK     PK  .
; 8833 : 			if ( lpObj->Y > CASTLE_PK_BORDER 
; 8834 : 				&& g_CastleSiege.CheckCastleOwnerUnionMember(lpObj->m_Index) == TRUE) 
; 8835 : 			{
; 8836 : 				return;
; 8837 : 			}
; 8838 : #else
; 8839 : 			if (g_CastleSiege.GetCastleState()!=CASTLESIEGE_STATE_READYSIEGE 
; 8840 : 				&& g_CastleSiege.CheckCastleOwnerUnionMember(lpObj->m_Index) == TRUE) 
; 8841 : 			{
; 8842 : 				return;
; 8843 : 			}
; 8844 : 			else if( g_CastleSiege.GetCastleState()==CASTLESIEGE_STATE_READYSIEGE 
; 8845 : 					&& lpObj->Y > CASTLE_PK_BORDER 
; 8846 : 					&& g_CastleSiege.CheckCastleOwnerUnionMember(lpObj->m_Index) == TRUE )
; 8847 : 			{
; 8848 : 				return;
; 8849 : 			}
; 8850 : #endif
; 8851 : 
; 8852 : 
; 8853 : 		}
; 8854 : 		
; 8855 : 		//         . (apple)
; 8856 : 		if( lpTargetObj->m_PK_Level >= PK_LEVEL_DEFAULT+3 )
; 8857 : 		{
; 8858 : 			return;
; 8859 : 		}
; 8860 : 	}
; 8861 : #endif
; 8862 : 
; 8863 : #ifdef JAPAN_DESTROYKING_EVENT_20040625		//     GM ()  PK .
; 8864 : 	if( lpObj->Authority&CTLCODE_EVENT_GM || lpTargetObj->Authority&CTLCODE_EVENT_GM)
; 8865 : 	{
; 8866 : 		return;
; 8867 : 	}
; 8868 : #endif
; 8869 : 
; 8870 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//   pk 
; 8871 : 	if( CHECK_ILLUSION_TEMPLE(lpObj->MapNumber) || CHECK_ILLUSION_TEMPLE(lpTargetObj->MapNumber) )
; 8872 : 	{
; 8873 : 		return;
; 8874 : 	}
; 8875 : #endif 
; 8876 : 
; 8877 : 	if( lpTargetObj->m_stateEngagePVP == PVP_USER_PLAYING )

  0007f	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00082	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  00089	75 15		 jne	 SHORT $LN7@gObjPlayer

; 8878 : 	{
; 8879 : 		g_PvpEvent.DeleteUser(lpTargetObj->m_Index);

  0008b	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0008e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00090	51		 push	 ecx
  00091	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PvpEvent@@3VCEngagePVP@@A ; g_PvpEvent
  00096	e8 00 00 00 00	 call	 ?DeleteUser@CEngagePVP@@QAEXH@Z ; CEngagePVP::DeleteUser

; 8880 : 		return;

  0009b	e9 99 03 00 00	 jmp	 $LN1@gObjPlayer
$LN7@gObjPlayer:

; 8881 : 	}
; 8882 : 
; 8883 : #ifdef ADD_NEWPVP_PKFIELD
; 8884 : 	if (g_NewPVP.IsVulcanusMap(lpObj->MapNumber) && g_NewPVP.IsVulcanusMap(lpTargetObj->MapNumber)) {
; 8885 : 		return;
; 8886 : 	}
; 8887 : #endif // ADD_NEWPVP_PKFIELD
; 8888 : 
; 8889 : 	//    ..	
; 8890 : #ifdef MODIFY_PARTY_SELFDEFENSE_BUG_FIX_20071022	//     .
; 8891 : 	int partynum			= lpObj->PartyNumber;	//  

  000a0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a3	8b 88 88 02 00
	00		 mov	 ecx, DWORD PTR [eax+648]
  000a9	89 4d fc	 mov	 DWORD PTR _partynum$[ebp], ecx

; 8892 : 	int	nSelfDefenseUser	= -1;					//   

  000ac	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _nSelfDefenseUser$[ebp], -1

; 8893 : 
; 8894 : 	for( int n=0; n<MAXSELFDEFENSE; n++)

  000b3	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  000ba	eb 09		 jmp	 SHORT $LN4@gObjPlayer
$LN2@gObjPlayer:
  000bc	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  000bf	83 c0 01	 add	 eax, 1
  000c2	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjPlayer:
  000c5	83 7d f4 07	 cmp	 DWORD PTR _n$1[ebp], 7
  000c9	7d 58		 jge	 SHORT $LN3@gObjPlayer

; 8895 : 	{
; 8896 : 		//    ..  
; 8897 : 		if( lpTargetObj->SelfDefense[n] >= 0)

  000cb	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  000ce	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  000d1	83 bc 81 40 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax*4+576], 0
  000d9	7c 46		 jl	 SHORT $LN8@gObjPlayer

; 8898 : 		{
; 8899 : 			if( lpTargetObj->SelfDefense[n] == lpObj->m_Index ) return;		

  000db	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  000de	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  000e1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e4	8b 84 81 40 02
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+576]
  000eb	3b 02		 cmp	 eax, DWORD PTR [edx]
  000ed	75 05		 jne	 SHORT $LN9@gObjPlayer
  000ef	e9 45 03 00 00	 jmp	 $LN1@gObjPlayer
$LN9@gObjPlayer:

; 8900 : 
; 8901 : 			//        
; 8902 : 			if( partynum >= 0 
; 8903 : 				&& gObj[lpTargetObj->SelfDefense[n]].PartyNumber == partynum )

  000f4	83 7d fc 00	 cmp	 DWORD PTR _partynum$[ebp], 0
  000f8	7c 27		 jl	 SHORT $LN8@gObjPlayer
  000fa	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  000fd	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00100	69 94 81 40 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax*4+576], 7072
  0010b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00110	8b 8c 10 88 02
	00 00		 mov	 ecx, DWORD PTR [eax+edx+648]
  00117	3b 4d fc	 cmp	 ecx, DWORD PTR _partynum$[ebp]
  0011a	75 05		 jne	 SHORT $LN8@gObjPlayer

; 8904 : 			{
; 8905 : 				return;

  0011c	e9 18 03 00 00	 jmp	 $LN1@gObjPlayer
$LN8@gObjPlayer:

; 8906 : 			}	
; 8907 : 		}
; 8908 : 	}

  00121	eb 99		 jmp	 SHORT $LN2@gObjPlayer
$LN3@gObjPlayer:

; 8909 : 
; 8910 : #else	// MODIFY_PARTY_SELFDEFENSE_BUG_FIX_20071022
; 8911 : 
; 8912 : 	for( int n=0; n<MAXSELFDEFENSE; n++)
; 8913 : 	{
; 8914 : 		if( lpTargetObj->SelfDefense[n] >= 0 )
; 8915 : 		{
; 8916 : 			if( lpTargetObj->SelfDefense[n] == lpObj->m_Index )
; 8917 : 			{
; 8918 : 				//  .
; 8919 : 				return;
; 8920 : 			}
; 8921 : 		}
; 8922 : 	}
; 8923 : #endif	// MODIFY_PARTY_SELFDEFENSE_BUG_FIX_20071022
; 8924 : 
; 8925 : 	INT iOriginPkLevel = lpObj->m_PK_Level;		//     PK  (2003.11.28 H.J.I.)

  00123	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00126	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  0012d	89 4d f0	 mov	 DWORD PTR _iOriginPkLevel$[ebp], ecx

; 8926 : 	INT iOriginPkCount = lpObj->m_PK_Count;		//     PK  (2003.11.28 H.J.I.)

  00130	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00133	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  0013a	89 4d ec	 mov	 DWORD PTR _iOriginPkCount$[ebp], ecx

; 8927 : 
; 8928 : #ifdef MOIDFY_PK_DAMAGE_REFLECT_NOPK_BUGFIX_20081202	//       
; 8929 : 	if( MSBDamage == DT_MIRROR)
; 8930 : 	{
; 8931 : 		return;
; 8932 : 	}
; 8933 : #endif	// MOIDFY_PK_DAMAGE_REFLECT_NOPK_BUGFIX_20081202
; 8934 : 
; 8935 : // PK PK   
; 8936 : #ifdef ADD_SHIELD_POINT_01_20060403
; 8937 : 	if( g_PKLevelIncreaseOff == TRUE )
; 8938 : 	{
; 8939 : 		return;
; 8940 : 	}
; 8941 : #endif
; 8942 : 	
; 8943 : #ifdef MODIFY_PK_SYSTEM_BUGFIX_20070323
; 8944 : 	char TargetTmpPKLevel = PK_LEVEL_DEFAULT;	//  PK 

  0013d	c6 45 eb 03	 mov	 BYTE PTR _TargetTmpPKLevel$[ebp], 3

; 8945 : 	
; 8946 : 	if(lpTargetObj->PartyNumber >= 0)

  00141	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00144	83 b8 88 02 00
	00 00		 cmp	 DWORD PTR [eax+648], 0
  0014b	7c 0e		 jl	 SHORT $LN11@gObjPlayer

; 8947 : 	{
; 8948 : #ifdef UPDATE_PK_SYSTEM_20070302
; 8949 : 		//     
; 8950 : 		if(gParty.GetPKPartyPenalty(lpTargetObj->PartyNumber) >= PK_LEVEL_DEFAULT+2)
; 8951 : 		{
; 8952 : 			TargetTmpPKLevel = gParty.GetPKPartyPenalty(lpTargetObj->PartyNumber);
; 8953 : 		}
; 8954 : 		else
; 8955 : #endif
; 8956 : 		{
; 8957 : 			TargetTmpPKLevel = lpTargetObj->m_PK_Level;

  0014d	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00150	8a 88 fd 00 00
	00		 mov	 cl, BYTE PTR [eax+253]
  00156	88 4d eb	 mov	 BYTE PTR _TargetTmpPKLevel$[ebp], cl

; 8958 : 		}
; 8959 : 	}

  00159	eb 0c		 jmp	 SHORT $LN12@gObjPlayer
$LN11@gObjPlayer:

; 8960 : 	else
; 8961 : 	{
; 8962 : 		TargetTmpPKLevel = lpTargetObj->m_PK_Level;

  0015b	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0015e	8a 88 fd 00 00
	00		 mov	 cl, BYTE PTR [eax+253]
  00164	88 4d eb	 mov	 BYTE PTR _TargetTmpPKLevel$[ebp], cl
$LN12@gObjPlayer:

; 8963 : 	}
; 8964 : 
; 8965 : 	// 
; 8966 : 	if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT )

  00167	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016a	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  00171	83 f9 03	 cmp	 ecx, 3
  00174	0f 85 96 00 00
	00		 jne	 $LN13@gObjPlayer

; 8967 : 	{
; 8968 : 		//  ..
; 8969 : 		if( TargetTmpPKLevel == PK_LEVEL_DEFAULT )

  0017a	0f be 45 eb	 movsx	 eax, BYTE PTR _TargetTmpPKLevel$[ebp]
  0017e	83 f8 03	 cmp	 eax, 3
  00181	75 0c		 jne	 SHORT $LN15@gObjPlayer

; 8970 : 		{			
; 8971 : 			lpObj->m_PK_Count = 1; //  ..

  00183	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00186	c6 80 fc 00 00
	00 01		 mov	 BYTE PTR [eax+252], 1

; 8972 : 		}	

  0018d	eb 7c		 jmp	 SHORT $LN16@gObjPlayer
$LN15@gObjPlayer:

; 8973 : 		//  ..
; 8974 : 		else if( TargetTmpPKLevel < PK_LEVEL_DEFAULT )

  0018f	0f be 45 eb	 movsx	 eax, BYTE PTR _TargetTmpPKLevel$[ebp]
  00193	83 f8 03	 cmp	 eax, 3
  00196	7d 0c		 jge	 SHORT $LN17@gObjPlayer

; 8975 : 		{			
; 8976 : 			lpObj->m_PK_Count = 1; //    .

  00198	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019b	c6 80 fc 00 00
	00 01		 mov	 BYTE PTR [eax+252], 1

; 8977 : 		}

  001a2	eb 67		 jmp	 SHORT $LN16@gObjPlayer
$LN17@gObjPlayer:

; 8978 : 		//  .
; 8979 : 		else if( TargetTmpPKLevel == PK_LEVEL_DEFAULT+1 )

  001a4	0f be 45 eb	 movsx	 eax, BYTE PTR _TargetTmpPKLevel$[ebp]
  001a8	83 f8 04	 cmp	 eax, 4
  001ab	75 0c		 jne	 SHORT $LN19@gObjPlayer

; 8980 : 		{			
; 8981 : 			lpObj->m_PK_Count = 1; //    .

  001ad	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b0	c6 80 fc 00 00
	00 01		 mov	 BYTE PTR [eax+252], 1

; 8982 : 		}

  001b7	eb 52		 jmp	 SHORT $LN16@gObjPlayer
$LN19@gObjPlayer:

; 8983 : 		//  ..
; 8984 : 		else if( (TargetTmpPKLevel >= PK_LEVEL_DEFAULT+3) &&

  001b9	0f be 45 eb	 movsx	 eax, BYTE PTR _TargetTmpPKLevel$[ebp]
  001bd	83 f8 06	 cmp	 eax, 6
  001c0	7c 44		 jl	 SHORT $LN21@gObjPlayer
  001c2	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001c5	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  001cc	83 f9 14	 cmp	 ecx, 20			; 00000014H
  001cf	7e 35		 jle	 SHORT $LN21@gObjPlayer

; 8985 : 				 (lpTargetObj->Level > 20) )
; 8986 : 		{
; 8987 : 			lpObj->m_PK_Count--;

  001d1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d4	8a 88 fc 00 00
	00		 mov	 cl, BYTE PTR [eax+252]
  001da	80 e9 01	 sub	 cl, 1
  001dd	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001e0	88 8a fc 00 00
	00		 mov	 BYTE PTR [edx+252], cl

; 8988 : 			if( lpObj->m_PK_Count < -3 ) 

  001e6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e9	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  001f0	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  001f3	7d 0f		 jge	 SHORT $LN23@gObjPlayer

; 8989 : 			{
; 8990 : 				lpObj->m_PK_Count = -3;

  001f5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f8	c6 80 fc 00 00
	00 fd		 mov	 BYTE PTR [eax+252], -3	; fffffffdH

; 8991 : 				return;

  001ff	e9 35 02 00 00	 jmp	 $LN1@gObjPlayer
$LN23@gObjPlayer:

; 8992 : 			}
; 8993 : 		}

  00204	eb 05		 jmp	 SHORT $LN16@gObjPlayer
$LN21@gObjPlayer:

; 8994 : 		else return;	//   

  00206	e9 2e 02 00 00	 jmp	 $LN1@gObjPlayer
$LN16@gObjPlayer:

; 8995 : 	}

  0020b	e9 de 00 00 00	 jmp	 $LN14@gObjPlayer
$LN13@gObjPlayer:

; 8996 : 	//  ..
; 8997 : 	else if( lpObj->m_PK_Level > PK_LEVEL_DEFAULT )

  00210	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00213	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  0021a	83 f9 03	 cmp	 ecx, 3
  0021d	7e 43		 jle	 SHORT $LN24@gObjPlayer

; 8998 : 	{
; 8999 : 		//   ..
; 9000 : 		if( TargetTmpPKLevel <= PK_LEVEL_DEFAULT+1 )

  0021f	0f be 45 eb	 movsx	 eax, BYTE PTR _TargetTmpPKLevel$[ebp]
  00223	83 f8 04	 cmp	 eax, 4
  00226	7f 30		 jg	 SHORT $LN26@gObjPlayer

; 9001 : 		{
; 9002 : 			lpObj->m_PK_Count++;

  00228	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0022b	8a 88 fc 00 00
	00		 mov	 cl, BYTE PTR [eax+252]
  00231	80 c1 01	 add	 cl, 1
  00234	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00237	88 8a fc 00 00
	00		 mov	 BYTE PTR [edx+252], cl

; 9003 : 			if( lpObj->m_PK_Count > MAX_PKCOUNT ) 

  0023d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00240	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  00247	83 f9 64	 cmp	 ecx, 100		; 00000064H
  0024a	7e 0a		 jle	 SHORT $LN28@gObjPlayer

; 9004 : 				lpObj->m_PK_Count = MAX_PKCOUNT;

  0024c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0024f	c6 80 fc 00 00
	00 64		 mov	 BYTE PTR [eax+252], 100	; 00000064H
$LN28@gObjPlayer:

; 9005 : 		}

  00256	eb 05		 jmp	 SHORT $LN27@gObjPlayer
$LN26@gObjPlayer:

; 9006 : 		else return;

  00258	e9 dc 01 00 00	 jmp	 $LN1@gObjPlayer
$LN27@gObjPlayer:

; 9007 : 	}

  0025d	e9 8c 00 00 00	 jmp	 $LN14@gObjPlayer
$LN24@gObjPlayer:

; 9008 : 	//  ..
; 9009 : 	else if( lpObj->m_PK_Level < PK_LEVEL_DEFAULT )

  00262	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00265	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  0026c	83 f9 03	 cmp	 ecx, 3
  0026f	7d 7d		 jge	 SHORT $LN14@gObjPlayer

; 9010 : 	{
; 9011 : 		//  
; 9012 : 		if( TargetTmpPKLevel == PK_LEVEL_DEFAULT )

  00271	0f be 45 eb	 movsx	 eax, BYTE PTR _TargetTmpPKLevel$[ebp]
  00275	83 f8 03	 cmp	 eax, 3
  00278	75 0c		 jne	 SHORT $LN30@gObjPlayer

; 9013 : 		{			
; 9014 : 			lpObj->m_PK_Count = 1; //   1 ()

  0027a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0027d	c6 80 fc 00 00
	00 01		 mov	 BYTE PTR [eax+252], 1

; 9015 : 		}	

  00284	eb 68		 jmp	 SHORT $LN14@gObjPlayer
$LN30@gObjPlayer:

; 9016 : 		//  ..
; 9017 : 		else if( TargetTmpPKLevel < PK_LEVEL_DEFAULT )

  00286	0f be 45 eb	 movsx	 eax, BYTE PTR _TargetTmpPKLevel$[ebp]
  0028a	83 f8 03	 cmp	 eax, 3
  0028d	7d 0c		 jge	 SHORT $LN32@gObjPlayer

; 9018 : 		{			
; 9019 : 			lpObj->m_PK_Count = 1; //   1 ()

  0028f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00292	c6 80 fc 00 00
	00 01		 mov	 BYTE PTR [eax+252], 1

; 9020 : 		}

  00299	eb 53		 jmp	 SHORT $LN14@gObjPlayer
$LN32@gObjPlayer:

; 9021 : 		else if( TargetTmpPKLevel == PK_LEVEL_DEFAULT+1 )

  0029b	0f be 45 eb	 movsx	 eax, BYTE PTR _TargetTmpPKLevel$[ebp]
  0029f	83 f8 04	 cmp	 eax, 4
  002a2	75 0c		 jne	 SHORT $LN34@gObjPlayer

; 9022 : 		{
; 9023 : 			lpObj->m_PK_Count = 1; //   1 ()

  002a4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a7	c6 80 fc 00 00
	00 01		 mov	 BYTE PTR [eax+252], 1

; 9024 : 		}

  002ae	eb 3e		 jmp	 SHORT $LN14@gObjPlayer
$LN34@gObjPlayer:

; 9025 : 		//  ..
; 9026 : 		else if( (TargetTmpPKLevel >= PK_LEVEL_DEFAULT+3) )//&& FIX PKBUG

  002b0	0f be 45 eb	 movsx	 eax, BYTE PTR _TargetTmpPKLevel$[ebp]
  002b4	83 f8 06	 cmp	 eax, 6
  002b7	7c 30		 jl	 SHORT $LN36@gObjPlayer

; 9027 : 				 //(lpTargetObj->Level > 20) )
; 9028 : 		{
; 9029 : 			lpObj->m_PK_Count--;

  002b9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002bc	8a 88 fc 00 00
	00		 mov	 cl, BYTE PTR [eax+252]
  002c2	80 e9 01	 sub	 cl, 1
  002c5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002c8	88 8a fc 00 00
	00		 mov	 BYTE PTR [edx+252], cl

; 9030 : 			if( lpObj->m_PK_Count < -3 ) 

  002ce	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d1	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  002d8	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  002db	7d 0a		 jge	 SHORT $LN38@gObjPlayer

; 9031 : 			{
; 9032 : 				lpObj->m_PK_Count = -3;

  002dd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002e0	c6 80 fc 00 00
	00 fd		 mov	 BYTE PTR [eax+252], -3	; fffffffdH
$LN38@gObjPlayer:

; 9033 : 			}
; 9034 : 		}

  002e7	eb 05		 jmp	 SHORT $LN14@gObjPlayer
$LN36@gObjPlayer:

; 9035 : 		else return;

  002e9	e9 4b 01 00 00	 jmp	 $LN1@gObjPlayer
$LN14@gObjPlayer:

; 9036 : 	}
; 9037 : #else	// MODIFY_PK_SYSTEM_BUGFIX_20070323
; 9038 : 	// 
; 9039 : 	if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT )
; 9040 : 	{
; 9041 : 		//  ..
; 9042 : 		if( lpTargetObj->m_PK_Level == PK_LEVEL_DEFAULT )
; 9043 : 		{			
; 9044 : 			lpObj->m_PK_Count = 1; //  ..
; 9045 : 		}	
; 9046 : 		//  ..
; 9047 : 		else if( lpTargetObj->m_PK_Level < PK_LEVEL_DEFAULT )
; 9048 : 		{			
; 9049 : 			lpObj->m_PK_Count = 1; //    .
; 9050 : 		}
; 9051 : 		//  .
; 9052 : 		else if( lpTargetObj->m_PK_Level == PK_LEVEL_DEFAULT+1 )
; 9053 : 		{			
; 9054 : 			lpObj->m_PK_Count = 1; //    .
; 9055 : 		}
; 9056 : 		//  ..
; 9057 : 		else if( (lpTargetObj->m_PK_Level >= PK_LEVEL_DEFAULT+3) &&
; 9058 : 				 (lpTargetObj->Level > 20) )
; 9059 : 		{
; 9060 : 			lpObj->m_PK_Count--;
; 9061 : 			if( lpObj->m_PK_Count < -3 ) 
; 9062 : 			{
; 9063 : 				lpObj->m_PK_Count = -3;
; 9064 : 				return;
; 9065 : 			}
; 9066 : 		}
; 9067 : 		else return;	//   
; 9068 : 	}
; 9069 : 	//  ..
; 9070 : 	else if( lpObj->m_PK_Level > PK_LEVEL_DEFAULT )
; 9071 : 	{
; 9072 : 		//   ..
; 9073 : 		if( lpTargetObj->m_PK_Level <= PK_LEVEL_DEFAULT+1 )
; 9074 : 		{
; 9075 : 			lpObj->m_PK_Count++;
; 9076 : 			if( lpObj->m_PK_Count > MAX_PKCOUNT ) 
; 9077 : 				lpObj->m_PK_Count = MAX_PKCOUNT;
; 9078 : 		}
; 9079 : 		else return;
; 9080 : 	}
; 9081 : 	//  ..
; 9082 : 	else if( lpObj->m_PK_Level < PK_LEVEL_DEFAULT )
; 9083 : 	{
; 9084 : 		//  
; 9085 : 		if( lpTargetObj->m_PK_Level == PK_LEVEL_DEFAULT )
; 9086 : 		{			
; 9087 : 			lpObj->m_PK_Count = 1; //   1 ()
; 9088 : 		}	
; 9089 : 		//  ..
; 9090 : 		else if( lpTargetObj->m_PK_Level < PK_LEVEL_DEFAULT )
; 9091 : 		{			
; 9092 : 			lpObj->m_PK_Count = 1; //   1 ()
; 9093 : 		}
; 9094 : 		else if( lpTargetObj->m_PK_Level == PK_LEVEL_DEFAULT+1 )
; 9095 : 		{
; 9096 : 			lpObj->m_PK_Count = 1; //   1 ()
; 9097 : 		}
; 9098 : 		//  ..
; 9099 : 		else if( (lpTargetObj->m_PK_Level >= PK_LEVEL_DEFAULT+3) )//&& FIX PKBUG
; 9100 : 				 //(lpTargetObj->Level > 20) )
; 9101 : 		{
; 9102 : 			lpObj->m_PK_Count--;
; 9103 : 			if( lpObj->m_PK_Count < -3 ) 
; 9104 : 			{
; 9105 : 				lpObj->m_PK_Count = -3;
; 9106 : 			}
; 9107 : 		}
; 9108 : 		else return;
; 9109 : 	}
; 9110 : #endif	// MODIFY_PK_SYSTEM_BUGFIX_20070323
; 9111 : 
; 9112 : 	if( lpObj->m_PK_Count == 0 )

  002ee	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002f1	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  002f8	85 c9		 test	 ecx, ecx
  002fa	75 1c		 jne	 SHORT $LN39@gObjPlayer

; 9113 : 	{
; 9114 : 		lpObj->m_PK_Level = PK_LEVEL_DEFAULT;

  002fc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ff	c6 80 fd 00 00
	00 03		 mov	 BYTE PTR [eax+253], 3

; 9115 : 		lpObj->m_PK_Time = 0;

  00306	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00309	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0

; 9116 : 	}

  00313	e9 9e 00 00 00	 jmp	 $LN40@gObjPlayer
$LN39@gObjPlayer:

; 9117 : 	else if( lpObj->m_PK_Count == 1 )

  00318	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0031b	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  00322	83 f9 01	 cmp	 ecx, 1
  00325	75 19		 jne	 SHORT $LN41@gObjPlayer

; 9118 : 	{
; 9119 : 		lpObj->m_PK_Level = PK_LEVEL_DEFAULT+1;

  00327	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0032a	c6 80 fd 00 00
	00 04		 mov	 BYTE PTR [eax+253], 4

; 9120 : 		lpObj->m_PK_Time = 0;

  00331	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00334	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0

; 9121 : 	}

  0033e	eb 76		 jmp	 SHORT $LN40@gObjPlayer
$LN41@gObjPlayer:

; 9122 : 	else if( lpObj->m_PK_Count == 2 )

  00340	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00343	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  0034a	83 f9 02	 cmp	 ecx, 2
  0034d	75 19		 jne	 SHORT $LN43@gObjPlayer

; 9123 : 	{
; 9124 : 		lpObj->m_PK_Level = PK_LEVEL_DEFAULT+2;

  0034f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00352	c6 80 fd 00 00
	00 05		 mov	 BYTE PTR [eax+253], 5

; 9125 : 		lpObj->m_PK_Time = 0;

  00359	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0035c	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0

; 9126 : 
; 9127 : #ifdef UPDATE_PK_SYSTEM_20070302		//      
; 9128 : 		if(lpObj->PartyNumber >= 0)
; 9129 : 		{
; 9130 : 			gParty.UpdatePKUserInfo(lpObj->PartyNumber, lpObj->m_Index, lpObj->DBNumber, lpObj->m_PK_Level);
; 9131 : 			gParty.UpdatePKPartyPanalty(lpObj->PartyNumber);
; 9132 : 		}
; 9133 : #endif
; 9134 : 	}

  00366	eb 4e		 jmp	 SHORT $LN40@gObjPlayer
$LN43@gObjPlayer:

; 9135 : 	else if( lpObj->m_PK_Count >= 3 )

  00368	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0036b	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  00372	83 f9 03	 cmp	 ecx, 3
  00375	7c 19		 jl	 SHORT $LN45@gObjPlayer

; 9136 : 	{
; 9137 : 		lpObj->m_PK_Level = PK_LEVEL_DEFAULT+3;

  00377	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0037a	c6 80 fd 00 00
	00 06		 mov	 BYTE PTR [eax+253], 6

; 9138 : 		lpObj->m_PK_Time = 0;

  00381	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00384	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0

; 9139 : 
; 9140 : #ifdef UPDATE_PK_SYSTEM_20070302		//      
; 9141 : 		if(lpObj->PartyNumber >= 0)
; 9142 : 		{
; 9143 : 			gParty.UpdatePKUserInfo(lpObj->PartyNumber, lpObj->m_Index, lpObj->DBNumber, lpObj->m_PK_Level);
; 9144 : 			gParty.UpdatePKPartyPanalty(lpObj->PartyNumber);
; 9145 : 		}
; 9146 : #endif
; 9147 : 	}

  0038e	eb 26		 jmp	 SHORT $LN40@gObjPlayer
$LN45@gObjPlayer:

; 9148 : 	else if( lpObj->m_PK_Count <= -3)

  00390	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00393	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  0039a	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  0039d	7f 17		 jg	 SHORT $LN40@gObjPlayer

; 9149 : 	{
; 9150 : 		lpObj->m_PK_Level = PK_LEVEL_DEFAULT-2;

  0039f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003a2	c6 80 fd 00 00
	00 01		 mov	 BYTE PTR [eax+253], 1

; 9151 : 		lpObj->m_PK_Time = 0;

  003a9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003ac	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0
$LN40@gObjPlayer:

; 9152 : 	}	
; 9153 : 	/*else if( lpObj->m_PK_Count < -3)
; 9154 : 	{
; 9155 : 		lpObj->m_PK_Level = PK_LEVEL_DEFAULT-2;
; 9156 : 		lpObj->m_PK_Time = 0;
; 9157 : 	}
; 9158 : 	*/
; 9159 : 	GCPkLevelSend(lpObj->m_Index, lpObj->m_PK_Level);

  003b6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003b9	0f b6 88 fd 00
	00 00		 movzx	 ecx, BYTE PTR [eax+253]
  003c0	51		 push	 ecx
  003c1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003c4	8b 02		 mov	 eax, DWORD PTR [edx]
  003c6	50		 push	 eax
  003c7	e8 00 00 00 00	 call	 ?GCPkLevelSend@@YAXHE@Z	; GCPkLevelSend
  003cc	83 c4 08	 add	 esp, 8

; 9160 : 	if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT+1 )

  003cf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003d2	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  003d9	83 f9 04	 cmp	 ecx, 4
  003dc	75 21		 jne	 SHORT $LN48@gObjPlayer

; 9161 : 	{		
; 9162 : 		GCServerMsgStringSend(lMsg.Get(1137), lpObj->m_Index, 1);

  003de	6a 01		 push	 1
  003e0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e5	51		 push	 ecx
  003e6	68 71 04 00 00	 push	 1137			; 00000471H
  003eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  003f6	50		 push	 eax
  003f7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  003fc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN48@gObjPlayer:

; 9163 : 	}
; 9164 : 
; 9165 : 	LogAddTD("[%s][%s] PK Info Set (Killed Player) Origin(PkLevel:%d, PkCount:%d) Changed(PkLevel:%d, PkCount:%d)", 

  003ff	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00402	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  00409	51		 push	 ecx
  0040a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0040d	0f be 82 fd 00
	00 00		 movsx	 eax, BYTE PTR [edx+253]
  00414	50		 push	 eax
  00415	8b 4d ec	 mov	 ecx, DWORD PTR _iOriginPkCount$[ebp]
  00418	51		 push	 ecx
  00419	8b 55 f0	 mov	 edx, DWORD PTR _iOriginPkLevel$[ebp]
  0041c	52		 push	 edx
  0041d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00420	83 c0 73	 add	 eax, 115		; 00000073H
  00423	50		 push	 eax
  00424	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00427	83 c1 68	 add	 ecx, 104		; 00000068H
  0042a	51		 push	 ecx
  0042b	68 00 00 00 00	 push	 OFFSET ??_C@_0GE@HFNAODDP@?$FL?$CFs?$FN?$FL?$CFs?$FN?5PK?5Info?5Set?5?$CIKilled?5Pl@
  00430	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00436	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@gObjPlayer:

; 9166 : 		lpObj->AccountID, 
; 9167 : 		lpObj->Name,
; 9168 : 		iOriginPkLevel,
; 9169 : 		iOriginPkCount,
; 9170 : 		lpObj->m_PK_Level,
; 9171 : 		lpObj->m_PK_Count
; 9172 : 		);
; 9173 : }

  00439	5f		 pop	 edi
  0043a	5e		 pop	 esi
  0043b	5b		 pop	 ebx
  0043c	8b e5		 mov	 esp, ebp
  0043e	5d		 pop	 ebp
  0043f	c3		 ret	 0
?gObjPlayerKiller@@YAXPAVOBJECTSTRUCT@@0@Z ENDP		; gObjPlayerKiller
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?BackSpringCheck@@YAHAAH00E@Z
_TEXT	SEGMENT
_tdir$ = -16						; size = 4
_ty$ = -12						; size = 4
_tx$ = -8						; size = 4
_attr$ = -1						; size = 1
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_dir$ = 16						; size = 4
_map$ = 20						; size = 1
?BackSpringCheck@@YAHAAH00E@Z PROC			; BackSpringCheck, COMDAT

; 7598 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7599 : 	BYTE attr;
; 7600 : 	int tx, ty;
; 7601 : 	int tdir;
; 7602 : 
; 7603 : 	tx = x;

  00009	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d f8	 mov	 DWORD PTR _tx$[ebp], ecx

; 7604 : 	ty = y;

  00011	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	89 4d f4	 mov	 DWORD PTR _ty$[ebp], ecx

; 7605 : 	tdir = dir/2;

  00019	8b 45 10	 mov	 eax, DWORD PTR _dir$[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	99		 cdq
  0001f	2b c2		 sub	 eax, edx
  00021	d1 f8		 sar	 eax, 1
  00023	89 45 f0	 mov	 DWORD PTR _tdir$[ebp], eax

; 7606 : 
; 7607 : 	tx += RoadPathTable[dir];

  00026	8b 45 10	 mov	 eax, DWORD PTR _dir$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	0f bf 14 4d 00
	00 00 00	 movsx	 edx, WORD PTR ?RoadPathTable@@3PAFA[ecx*2]
  00033	03 55 f8	 add	 edx, DWORD PTR _tx$[ebp]
  00036	89 55 f8	 mov	 DWORD PTR _tx$[ebp], edx

; 7608 : 	ty += RoadPathTable[dir+1];

  00039	8b 45 10	 mov	 eax, DWORD PTR _dir$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	0f bf 14 4d 02
	00 00 00	 movsx	 edx, WORD PTR ?RoadPathTable@@3PAFA[ecx*2+2]
  00046	03 55 f4	 add	 edx, DWORD PTR _ty$[ebp]
  00049	89 55 f4	 mov	 DWORD PTR _ty$[ebp], edx

; 7609 : 	attr = MapC[map].GetAttr(tx,ty);

  0004c	8b 45 f4	 mov	 eax, DWORD PTR _ty$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _tx$[ebp]
  00053	51		 push	 ecx
  00054	0f b6 55 14	 movzx	 edx, BYTE PTR _map$[ebp]
  00058	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  0005e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00064	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00069	88 45 ff	 mov	 BYTE PTR _attr$[ebp], al

; 7610 : 	if( ((attr&MAP_ATTR_SAFTYZONE) == MAP_ATTR_SAFTYZONE) || ((attr&MAP_ATTR_BLOCK) == MAP_ATTR_BLOCK) ||((attr&MAP_ATTR_HOLLOW) == MAP_ATTR_HOLLOW) 

  0006c	0f b6 45 ff	 movzx	 eax, BYTE PTR _attr$[ebp]
  00070	83 e0 01	 and	 eax, 1
  00073	75 12		 jne	 SHORT $LN3@BackSpring
  00075	0f b6 45 ff	 movzx	 eax, BYTE PTR _attr$[ebp]
  00079	83 e0 04	 and	 eax, 4
  0007c	75 09		 jne	 SHORT $LN3@BackSpring
  0007e	0f b6 45 ff	 movzx	 eax, BYTE PTR _attr$[ebp]
  00082	83 e0 08	 and	 eax, 8
  00085	74 26		 je	 SHORT $LN2@BackSpring
$LN3@BackSpring:

; 7611 : #ifdef CASTLE_NPC_GATE_WORK_20041206	//     
; 7612 : 		||((attr&MAP_ATTR_WATER) == MAP_ATTR_WATER) 
; 7613 : #endif
; 7614 : 		)
; 7615 : 	{
; 7616 : 		tdir += 4;

  00087	8b 45 f0	 mov	 eax, DWORD PTR _tdir$[ebp]
  0008a	83 c0 04	 add	 eax, 4
  0008d	89 45 f0	 mov	 DWORD PTR _tdir$[ebp], eax

; 7617 : 		if( tdir > 7 ) tdir -= 8;

  00090	83 7d f0 07	 cmp	 DWORD PTR _tdir$[ebp], 7
  00094	7e 09		 jle	 SHORT $LN4@BackSpring
  00096	8b 45 f0	 mov	 eax, DWORD PTR _tdir$[ebp]
  00099	83 e8 08	 sub	 eax, 8
  0009c	89 45 f0	 mov	 DWORD PTR _tdir$[ebp], eax
$LN4@BackSpring:

; 7618 : 		dir = tdir*2;

  0009f	8b 45 f0	 mov	 eax, DWORD PTR _tdir$[ebp]
  000a2	d1 e0		 shl	 eax, 1
  000a4	8b 4d 10	 mov	 ecx, DWORD PTR _dir$[ebp]
  000a7	89 01		 mov	 DWORD PTR [ecx], eax

; 7619 : 		return FALSE;

  000a9	33 c0		 xor	 eax, eax
  000ab	eb 15		 jmp	 SHORT $LN1@BackSpring
$LN2@BackSpring:

; 7620 : 	}
; 7621 : 	x = tx;

  000ad	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  000b0	8b 4d f8	 mov	 ecx, DWORD PTR _tx$[ebp]
  000b3	89 08		 mov	 DWORD PTR [eax], ecx

; 7622 : 	y = ty;

  000b5	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR _ty$[ebp]
  000bb	89 08		 mov	 DWORD PTR [eax], ecx

; 7623 : 	return TRUE;

  000bd	b8 01 00 00 00	 mov	 eax, 1
$LN1@BackSpring:

; 7624 : }

  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
?BackSpringCheck@@YAHAAH00E@Z ENDP			; BackSpringCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSetInventory2Pointer@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjSetInventory2Pointer@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjSetInventory2Pointer, COMDAT

; 7071 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7072 : 	lpObj->pInventory		= (CItem*)lpObj->Inventory2;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0000f	8b 91 78 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3192]
  00015	89 90 5c 0c 00
	00		 mov	 DWORD PTR [eax+3164], edx

; 7073 : 	lpObj->pInventoryMap	= lpObj->InventoryMap2;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00021	8b 91 7c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3196]
  00027	89 90 60 0c 00
	00		 mov	 DWORD PTR [eax+3168], edx

; 7074 : 	lpObj->pInventoryCount	= (char*)&lpObj->InventoryCount2;

  0002d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00030	05 80 0c 00 00	 add	 eax, 3200		; 00000c80H
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00038	89 81 64 0c 00
	00		 mov	 DWORD PTR [ecx+3172], eax

; 7075 : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?gObjSetInventory2Pointer@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjSetInventory2Pointer
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?ExtentCheck@@YAHHHHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
?ExtentCheck@@YAHHHHH@Z PROC				; ExtentCheck, COMDAT

; 7054 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7055 : 	if( x >= 0 && x < w &&
; 7056 : 		y >= 0 && y < h )

  00009	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  0000d	7c 1d		 jl	 SHORT $LN2@ExtentChec
  0000f	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00012	3b 45 10	 cmp	 eax, DWORD PTR _w$[ebp]
  00015	7d 15		 jge	 SHORT $LN2@ExtentChec
  00017	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  0001b	7c 0f		 jl	 SHORT $LN2@ExtentChec
  0001d	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00020	3b 45 14	 cmp	 eax, DWORD PTR _h$[ebp]
  00023	7d 07		 jge	 SHORT $LN2@ExtentChec

; 7057 : 	{
; 7058 : 		return TRUE;

  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	eb 02		 jmp	 SHORT $LN1@ExtentChec
$LN2@ExtentChec:

; 7059 : 	}
; 7060 : 	return FALSE;

  0002c	33 c0		 xor	 eax, eax
$LN1@ExtentChec:

; 7061 : }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?ExtentCheck@@YAHHHHH@Z ENDP				; ExtentCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjTaiwanJoominCheck@@YAHHPAD@Z
_TEXT	SEGMENT
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_szInJN$ = 12						; size = 4
?gObjTaiwanJoominCheck@@YAHHPAD@Z PROC			; gObjTaiwanJoominCheck, COMDAT

; 6617 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6618 : 	LPOBJECTSTRUCT lpObj;
; 6619 : 
; 6620 : 	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 6621 : 
; 6622 : 	
; 6623 : 	if( strlen( szInJN ) < 2 )

  00019	8b 45 0c	 mov	 eax, DWORD PTR _szInJN$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _strlen
  00022	83 c4 04	 add	 esp, 4
  00025	83 f8 02	 cmp	 eax, 2
  00028	73 04		 jae	 SHORT $LN2@gObjTaiwan

; 6624 : 	{
; 6625 : 		return FALSE;

  0002a	33 c0		 xor	 eax, eax
  0002c	eb 22		 jmp	 SHORT $LN1@gObjTaiwan
$LN2@gObjTaiwan:

; 6626 : 	}	
; 6627 : 	//   
; 6628 : 	if( strncmp(lpObj->LastJoominNumber+1, szInJN, 9) == 0 )

  0002e	6a 09		 push	 9
  00030	8b 45 0c	 mov	 eax, DWORD PTR _szInJN$[ebp]
  00033	50		 push	 eax
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00037	83 c1 7f	 add	 ecx, 127		; 0000007fH
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _strncmp
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH
  00043	85 c0		 test	 eax, eax
  00045	75 07		 jne	 SHORT $LN3@gObjTaiwan

; 6629 : 	{
; 6630 : 		return TRUE;

  00047	b8 01 00 00 00	 mov	 eax, 1
  0004c	eb 02		 jmp	 SHORT $LN1@gObjTaiwan
$LN3@gObjTaiwan:

; 6631 : 	}	
; 6632 : 	return FALSE;

  0004e	33 c0		 xor	 eax, eax
$LN1@gObjTaiwan:

; 6633 : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?gObjTaiwanJoominCheck@@YAHHPAD@Z ENDP			; gObjTaiwanJoominCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjIsConnectedGP@@YAHHPAD@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_CharName$ = 12						; size = 4
?gObjIsConnectedGP@@YAHHPAD@Z PROC			; gObjIsConnectedGP, COMDAT

; 6457 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6458 : 	if( aIndex < 0 || aIndex > MAX_OBJECT-1 )	 return FALSE;

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@gObjIsConn
  0000f	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00016	7e 04		 jle	 SHORT $LN2@gObjIsConn
$LN3@gObjIsConn:
  00018	33 c0		 xor	 eax, eax
  0001a	eb 78		 jmp	 SHORT $LN1@gObjIsConn
$LN2@gObjIsConn:

; 6459 : 	if( gObj[aIndex].Type != OBJTYPE_CHARACTER ) return FALSE;

  0001c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00023	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00029	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0002e	83 fa 01	 cmp	 edx, 1
  00031	74 04		 je	 SHORT $LN4@gObjIsConn
  00033	33 c0		 xor	 eax, eax
  00035	eb 5d		 jmp	 SHORT $LN1@gObjIsConn
$LN4@gObjIsConn:

; 6460 : 	if( gObj[aIndex].Connected < CSS_GAMEPLAYING ) return FALSE;

  00037	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00044	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00049	7d 04		 jge	 SHORT $LN5@gObjIsConn
  0004b	33 c0		 xor	 eax, eax
  0004d	eb 45		 jmp	 SHORT $LN1@gObjIsConn
$LN5@gObjIsConn:

; 6461 : 	if( gObj[aIndex].CloseCount > 0 ) return FALSE;

  0004f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005c	0f be 54 01 0a	 movsx	 edx, BYTE PTR [ecx+eax+10]
  00061	85 d2		 test	 edx, edx
  00063	7e 04		 jle	 SHORT $LN6@gObjIsConn
  00065	33 c0		 xor	 eax, eax
  00067	eb 2b		 jmp	 SHORT $LN1@gObjIsConn
$LN6@gObjIsConn:

; 6462 : 	if( strcmp(gObj[aIndex].Name, CharName) != 0 ) return FALSE;

  00069	8b 45 0c	 mov	 eax, DWORD PTR _CharName$[ebp]
  0006c	50		 push	 eax
  0006d	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00074	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007a	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _strcmp
  00084	83 c4 08	 add	 esp, 8
  00087	85 c0		 test	 eax, eax
  00089	74 04		 je	 SHORT $LN7@gObjIsConn
  0008b	33 c0		 xor	 eax, eax
  0008d	eb 05		 jmp	 SHORT $LN1@gObjIsConn
$LN7@gObjIsConn:

; 6463 : 	return TRUE;

  0008f	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjIsConn:

; 6464 : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?gObjIsConnectedGP@@YAHHPAD@Z ENDP			; gObjIsConnectedGP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMonsterRecall@@YAFH@Z
_TEXT	SEGMENT
_number$ = -4						; size = 4
_iMapNumber$ = 8					; size = 4
?gObjMonsterRecall@@YAFH@Z PROC				; gObjMonsterRecall, COMDAT

; 5454 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5455 : 	int number = gObjAddMonster(iMapNumber);

  00009	8b 45 08	 mov	 eax, DWORD PTR _iMapNumber$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00012	83 c4 04	 add	 esp, 4
  00015	0f bf c8	 movsx	 ecx, ax
  00018	89 4d fc	 mov	 DWORD PTR _number$[ebp], ecx

; 5456 : 	if( number < 0 ) return -1;

  0001b	83 7d fc 00	 cmp	 DWORD PTR _number$[ebp], 0
  0001f	7d 05		 jge	 SHORT $LN2@gObjMonste
  00021	83 c8 ff	 or	 eax, -1
  00024	eb 03		 jmp	 SHORT $LN1@gObjMonste
$LN2@gObjMonste:

; 5457 : 	//gObjSetMonster( number, );
; 5458 : 	return -1;

  00026	83 c8 ff	 or	 eax, -1
$LN1@gObjMonste:

; 5459 : }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?gObjMonsterRecall@@YAFH@Z ENDP				; gObjMonsterRecall
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?DbItemSetInByte@@YAXPAVOBJECTSTRUCT@@PAUSDHP_DBCHAR_INFORESULT@@HPA_N@Z
_TEXT	SEGMENT
_bIsItemExist$ = -197					; size = 1
_loWord$ = -196						; size = 2
_hiWord$ = -192						; size = 2
_OptionData$ = -185					; size = 1
_item$ = -184						; size = 168
__type$ = -16						; size = 4
_itype$ = -12						; size = 4
_n$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
_ItemDbByte$ = 16					; size = 4
_bAllItemExist$ = 20					; size = 4
?DbItemSetInByte@@YAXPAVOBJECTSTRUCT@@PAUSDHP_DBCHAR_INFORESULT@@HPA_N@Z PROC ; DbItemSetInByte, COMDAT

; 2359 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 2360 : 	int		n;
; 2361 : 	int		itype, _type;
; 2362 : 	CItem	item;

  00016	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 2363 : 	BYTE	OptionData;
; 2364 : 	WORD	hiWord, loWord;
; 2365 : 
; 2366 : #ifdef ITEMDELETE_MODIFY_20040604
; 2367 : 	bool	bIsItemExist = true;

  00021	c6 85 3b ff ff
	ff 01		 mov	 BYTE PTR _bIsItemExist$[ebp], 1

; 2368 : #endif
; 2369 : 	
; 2370 : 	//  .
; 2371 : #ifdef PERSONAL_SHOP_20040113
; 2372 : 	for( n=0; n<MAX_INVENTORY_EXTEND; n++)

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  0002f	eb 09		 jmp	 SHORT $LN4@DbItemSetI
$LN2@DbItemSetI:
  00031	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@DbItemSetI:
  0003a	83 7d f8 6c	 cmp	 DWORD PTR _n$[ebp], 108	; 0000006cH
  0003e	0f 8d 7d 05 00
	00		 jge	 $LN3@DbItemSetI

; 2373 : #else
; 2374 : 	for( n=0; n<MAX_INVENTORY; n++)
; 2375 : #endif
; 2376 : 	{
; 2377 : #ifdef ITEMDELETE_MODIFY_20040604
; 2378 : 		bIsItemExist = true;

  00044	c6 85 3b ff ff
	ff 01		 mov	 BYTE PTR _bIsItemExist$[ebp], 1

; 2379 : #endif
; 2380 : 
; 2381 : #ifdef ITEM_INDEX_EXTEND_20050706
; 2382 : 		lpObj->pInventory[n].Clear();
; 2383 : #endif
; 2384 : 
; 2385 : 		itype = lpMsg->dbInventory[n*ItemDbByte];

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0004e	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00055	0f b6 54 01 40	 movzx	 edx, BYTE PTR [ecx+eax+64]
  0005a	89 55 f4	 mov	 DWORD PTR _itype$[ebp], edx

; 2386 : #ifdef ITEM_INDEX_EXTEND_20050706
; 2387 : 		if( ItemDbByte >= MAX_ITEMDBBYTE ) {
; 2388 : 			if( (lpMsg->dbInventory[n*ItemDbByte] == 0xFF)
; 2389 : 				&& (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x80) == 0x80
; 2390 : 				&& (lpMsg->dbInventory[(n*ItemDbByte)+9]&0xF0) == 0xF0
; 2391 : 				) 
; 2392 : 			{
; 2393 : 				//       1 set    
; 2394 : 				continue;
; 2395 : 			}
; 2396 : 		}
; 2397 : 		else if (ItemDbByte > MAX_ITEMDBBYTE_V00) {
; 2398 : 			if( (lpMsg->dbInventory[n*ItemDbByte] == 0xFF) && (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x80) == 0x80) 
; 2399 : 			{
; 2400 : 				continue;
; 2401 : 			}
; 2402 : 		}
; 2403 : 		else {
; 2404 : 			if(lpMsg->dbInventory[n*ItemDbByte] == 0xFF) 
; 2405 : 			{
; 2406 : 				continue;
; 2407 : 			}
; 2408 : 		}
; 2409 : #else
; 2410 : #ifdef ITEMDELETE_MODIFY_20040604		// 0xFF - 
; 2411 : #ifdef INVENTORY_EMPTYSLOT_CHECK_20050217
; 2412 : 		if( (lpMsg->dbInventory[n*ItemDbByte] == 0xFF) && (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x80) == 0x80) {

  0005d	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00060	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00067	0f b6 54 01 40	 movzx	 edx, BYTE PTR [ecx+eax+64]
  0006c	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00072	75 19		 jne	 SHORT $LN5@DbItemSetI
  00074	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00077	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  0007b	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0007e	0f b6 54 01 47	 movzx	 edx, BYTE PTR [ecx+eax+71]
  00083	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00089	74 02		 je	 SHORT $LN5@DbItemSetI

; 2413 : #else
; 2414 : 		if (itype == 0xFF) {
; 2415 : #endif
; 2416 : 			continue;

  0008b	eb a4		 jmp	 SHORT $LN2@DbItemSetI
$LN5@DbItemSetI:

; 2417 : 		}
; 2418 : #endif
; 2419 : #endif
; 2420 : 		
; 2421 : #ifdef ITEM_DBSIZE_EXTEND_20050706
; 2422 : 		if( ItemDbByte == MAX_ITEMDBBYTE ) {
; 2423 : #ifdef ITEM_INDEX_EXTEND_20050706
; 2424 : //			itype |= (BYTE)lpMsg->dbInventory[n*ItemDbByte];
; 2425 : 			itype |= (lpMsg->dbInventory[(n*ItemDbByte)+9]&0xF0)<<5;
; 2426 : 			itype |= (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x80)<<1;
; 2427 : 			_type = itype;
; 2428 : #endif			
; 2429 : 		}
; 2430 : 		else if (ItemDbByte == MAX_ITEMDBBYTE_V02)
; 2431 : #else
; 2432 : 		if( ItemDbByte == 10 )

  0008d	83 7d 10 0a	 cmp	 DWORD PTR _ItemDbByte$[ebp], 10 ; 0000000aH
  00091	75 2a		 jne	 SHORT $LN6@DbItemSetI

; 2433 : #endif
; 2434 : 		{
; 2435 : 			if( (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x80) == 0x80 ) itype += 256;

  00093	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00096	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0009d	0f b6 54 01 47	 movzx	 edx, BYTE PTR [ecx+eax+71]
  000a2	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  000a8	74 0b		 je	 SHORT $LN8@DbItemSetI
  000aa	8b 45 f4	 mov	 eax, DWORD PTR _itype$[ebp]
  000ad	05 00 01 00 00	 add	 eax, 256		; 00000100H
  000b2	89 45 f4	 mov	 DWORD PTR _itype$[ebp], eax
$LN8@DbItemSetI:

; 2436 : #ifdef ITEM_INDEX_EXTEND_20050706
; 2437 : 			_type = ((itype/32)*MAX_ITEM_INDEX)+(itype%32);
; 2438 : #else
; 2439 : 			_type = itype;

  000b5	8b 45 f4	 mov	 eax, DWORD PTR _itype$[ebp]
  000b8	89 45 f0	 mov	 DWORD PTR __type$[ebp], eax

; 2440 : #endif
; 2441 : 		}

  000bb	eb 24		 jmp	 SHORT $LN7@DbItemSetI
$LN6@DbItemSetI:

; 2442 : 		else
; 2443 : 		{
; 2444 : 			_type = ((itype/16)*MAX_ITEM_INDEX)+(itype%16);

  000bd	8b 45 f4	 mov	 eax, DWORD PTR _itype$[ebp]
  000c0	99		 cdq
  000c1	83 e2 0f	 and	 edx, 15			; 0000000fH
  000c4	03 c2		 add	 eax, edx
  000c6	c1 f8 04	 sar	 eax, 4
  000c9	c1 e0 05	 shl	 eax, 5
  000cc	8b 4d f4	 mov	 ecx, DWORD PTR _itype$[ebp]
  000cf	81 e1 0f 00 00
	80		 and	 ecx, -2147483633	; 8000000fH
  000d5	79 05		 jns	 SHORT $LN32@DbItemSetI
  000d7	49		 dec	 ecx
  000d8	83 c9 f0	 or	 ecx, -16		; fffffff0H
  000db	41		 inc	 ecx
$LN32@DbItemSetI:
  000dc	03 c1		 add	 eax, ecx
  000de	89 45 f0	 mov	 DWORD PTR __type$[ebp], eax
$LN7@DbItemSetI:

; 2445 : 		}
; 2446 : 
; 2447 : #ifndef ITEM_INDEX_EXTEND_20050706
; 2448 : 		lpObj->pInventory[n].Clear();

  000e1	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 168
  000e8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000eb	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  000f1	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 2449 : #endif
; 2450 : 		
; 2451 : #ifdef ITEM_INDEX_EXTEND_20050706
; 2452 : 		if( ItemDbByte >= MAX_ITEMDBBYTE ) {
; 2453 : 			if( (lpMsg->dbInventory[n*ItemDbByte] == 0xFF)
; 2454 : 				&& (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x80) == 0x80
; 2455 : 				&& (lpMsg->dbInventory[(n*ItemDbByte)+9]&0xF0) == 0xF0
; 2456 : 				) 
; 2457 : 			{
; 2458 : 				//       1 set    
; 2459 : 				itype = -1;
; 2460 : 			}
; 2461 : 		}
; 2462 : 		else if (ItemDbByte >= MAX_ITEMDBBYTE_V02) {
; 2463 : 			if( (lpMsg->dbInventory[n*ItemDbByte] == 0xFF) && (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x80) == 0x80) 
; 2464 : 			{
; 2465 : 				itype = -1;
; 2466 : 			}
; 2467 : 		}
; 2468 : 		else {
; 2469 : 			if(lpMsg->dbInventory[n*ItemDbByte] == 0xFF) 
; 2470 : 			{
; 2471 : 				itype = -1;
; 2472 : 			}
; 2473 : 		}
; 2474 : #else
; 2475 : 		if( (lpMsg->dbInventory[n*ItemDbByte] == 0xFF) && (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x80) == 0x80) 

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000f9	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  000fd	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00100	0f b6 54 01 40	 movzx	 edx, BYTE PTR [ecx+eax+64]
  00105	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  0010b	75 1e		 jne	 SHORT $LN9@DbItemSetI
  0010d	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00110	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  00114	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00117	0f b6 54 01 47	 movzx	 edx, BYTE PTR [ecx+eax+71]
  0011c	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00122	74 07		 je	 SHORT $LN9@DbItemSetI

; 2476 : 		{
; 2477 : 			itype = -1;

  00124	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _itype$[ebp], -1
$LN9@DbItemSetI:

; 2478 : 		}
; 2479 : #endif
; 2480 : 
; 2481 : 		if( !IsItem(_type) )

  0012b	8b 45 f0	 mov	 eax, DWORD PTR __type$[ebp]
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ?IsItem@@YAHH@Z		; IsItem
  00134	83 c4 04	 add	 esp, 4
  00137	85 c0		 test	 eax, eax
  00139	75 13		 jne	 SHORT $LN11@DbItemSetI

; 2482 : 		{
; 2483 : #ifdef ITEMDELETE_MODIFY_20040604		//        .
; 2484 : 			bIsItemExist		= false;

  0013b	c6 85 3b ff ff
	ff 00		 mov	 BYTE PTR _bIsItemExist$[ebp], 0

; 2485 : 			if(bAllItemExist)	(*bAllItemExist) = false;

  00142	83 7d 14 00	 cmp	 DWORD PTR _bAllItemExist$[ebp], 0
  00146	74 06		 je	 SHORT $LN11@DbItemSetI
  00148	8b 45 14	 mov	 eax, DWORD PTR _bAllItemExist$[ebp]
  0014b	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN11@DbItemSetI:

; 2486 : #else
; 2487 : 			itype = -1;
; 2488 : #endif
; 2489 : 		}		
; 2490 : 
; 2491 : 		if( _type == MAKE_ITEMNUM(14,17) || _type == MAKE_ITEMNUM(14,18) )

  0014e	6a 11		 push	 17			; 00000011H
  00150	6a 0e		 push	 14			; 0000000eH
  00152	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00157	83 c4 08	 add	 esp, 8
  0015a	39 45 f0	 cmp	 DWORD PTR __type$[ebp], eax
  0015d	74 11		 je	 SHORT $LN13@DbItemSetI
  0015f	6a 12		 push	 18			; 00000012H
  00161	6a 0e		 push	 14			; 0000000eH
  00163	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00168	83 c4 08	 add	 esp, 8
  0016b	39 45 f0	 cmp	 DWORD PTR __type$[ebp], eax
  0016e	75 1a		 jne	 SHORT $LN14@DbItemSetI
$LN13@DbItemSetI:

; 2492 : 		{	//  ,    0  			
; 2493 : 			if( lpMsg->dbInventory[(n*ItemDbByte)+2] == 0 )

  00170	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00173	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  00177	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0017a	0f b6 54 01 42	 movzx	 edx, BYTE PTR [ecx+eax+66]
  0017f	85 d2		 test	 edx, edx
  00181	75 07		 jne	 SHORT $LN14@DbItemSetI

; 2494 : 			{
; 2495 : 				itype = -1;

  00183	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _itype$[ebp], -1
$LN14@DbItemSetI:

; 2496 : 			}
; 2497 : 		}
; 2498 : 
; 2499 : 		if( _type == MAKE_ITEMNUM(14,19) )

  0018a	6a 13		 push	 19			; 00000013H
  0018c	6a 0e		 push	 14			; 0000000eH
  0018e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00193	83 c4 08	 add	 esp, 8
  00196	39 45 f0	 cmp	 DWORD PTR __type$[ebp], eax
  00199	75 1e		 jne	 SHORT $LN16@DbItemSetI

; 2500 : 		{	//     255  			
; 2501 : 			if( lpMsg->dbInventory[(n*ItemDbByte)+2] == 255 )

  0019b	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0019e	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  001a2	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  001a5	0f b6 54 01 42	 movzx	 edx, BYTE PTR [ecx+eax+66]
  001aa	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  001b0	75 07		 jne	 SHORT $LN16@DbItemSetI

; 2502 : 			{
; 2503 : 				itype = -1;

  001b2	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _itype$[ebp], -1
$LN16@DbItemSetI:

; 2504 : 			}
; 2505 : 		}
; 2506 : 
; 2507 : #ifdef UPDATE_LUCKY_COIN_EVENT_20081029
; 2508 : 		//      0 
; 2509 : 		if( _type == MAKE_ITEMNUM(14, 100) )
; 2510 : 		{
; 2511 : 			if( lpMsg->dbInventory[(n*ItemDbByte)+2] == 0 )
; 2512 : 			{
; 2513 : 				itype = -1;
; 2514 : 			}
; 2515 : 		}
; 2516 : #endif	// UPDATE_LUCKY_COIN_EVENT_20081029
; 2517 : 
; 2518 : #ifndef FOR_BLOODCASTLE_TEST
; 2519 : /*		if ( 
; 2520 : 			_type == MAKE_ITEMNUM(13, 16) ||	// 
; 2521 : 			_type == MAKE_ITEMNUM(13, 17)		// 
; 2522 : //			_type == MAKE_ITEMNUM(13, 18)		// 
; 2523 : 			)	
; 2524 : 		{
; 2525 : 			if( lpMsg->dbInventory[(n*ItemDbByte)+2] != 128 )
; 2526 : 			{
; 2527 : 				itype = -1;
; 2528 : 			}
; 2529 : 		}
; 2530 : 
; 2531 : 		if (_type == MAKE_ITEMNUM(14, 21))
; 2532 : 		{
; 2533 : 			int _level = ((lpMsg->dbInventory[(n*ItemDbByte)+1]>>3)&0xF);
; 2534 : 			if (_level == 1) {	// 
; 2535 : 				if( lpMsg->dbInventory[(n*ItemDbByte)+2] != 128 )
; 2536 : 				{
; 2537 : 					itype = -1;
; 2538 : 				}
; 2539 : 			}
; 2540 : 		}
; 2541 : */
; 2542 : #endif
; 2543 : 		
; 2544 : 		if( itype != -1 )

  001b9	83 7d f4 ff	 cmp	 DWORD PTR _itype$[ebp], -1
  001bd	0f 84 f9 03 00
	00		 je	 $LN30@DbItemSetI

; 2545 : 		{
; 2546 : 			item.m_Level = ((lpMsg->dbInventory[(n*ItemDbByte)+1]>>3)&0xF);

  001c3	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  001c6	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  001ca	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  001cd	0f b6 54 01 41	 movzx	 edx, BYTE PTR [ecx+eax+65]
  001d2	c1 fa 03	 sar	 edx, 3
  001d5	83 e2 0f	 and	 edx, 15			; 0000000fH
  001d8	66 89 95 50 ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], dx

; 2547 : 
; 2548 : #ifdef SETITEM_BUFFER_CLEAR
; 2549 : 			if( lpMsg->DbVersion < 2 )

  001df	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001e2	0f b6 88 3d 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1341]
  001e9	83 f9 02	 cmp	 ecx, 2
  001ec	7d 1e		 jge	 SHORT $LN18@DbItemSetI

; 2550 : 			{	//          
; 2551 : 				lpMsg->dbInventory[(n*ItemDbByte)+8] = 0xFF;

  001ee	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  001f1	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  001f5	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  001f8	c6 44 01 48 ff	 mov	 BYTE PTR [ecx+eax+72], 255 ; 000000ffH

; 2552 : 				lpMsg->dbInventory[(n*ItemDbByte)+9] = 0xFF;

  001fd	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00200	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  00204	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00207	c6 44 01 49 ff	 mov	 BYTE PTR [ecx+eax+73], 255 ; 000000ffH
$LN18@DbItemSetI:

; 2553 : 			}
; 2554 : #endif
; 2555 : 
; 2556 : #ifdef TEST_SETITEM_CLEAR			
; 2557 : 			if( !(lpObj->ClearInfoForSetItem&0x01) )
; 2558 : 			{	//          
; 2559 : 				lpMsg->dbInventory[(n*ItemDbByte)+8] = 0xFF;
; 2560 : 				lpMsg->dbInventory[(n*ItemDbByte)+9] = 0xFF;
; 2561 : 			}
; 2562 : #endif
; 2563 : 			
; 2564 : 			//     .. 0 .			
; 2565 : 			if( _type != MAKE_ITEMNUM(14,11) )	//     

  0020c	6a 0b		 push	 11			; 0000000bH
  0020e	6a 0e		 push	 14			; 0000000eH
  00210	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00215	83 c4 08	 add	 esp, 8
  00218	39 45 f0	 cmp	 DWORD PTR __type$[ebp], eax
  0021b	74 15		 je	 SHORT $LN20@DbItemSetI

; 2566 : 				if( item.m_Level > MAX_ITEMLEVEL ) item.m_Level = 0;

  0021d	0f bf 85 50 ff
	ff ff		 movsx	 eax, WORD PTR _item$[ebp+8]
  00224	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00227	7e 09		 jle	 SHORT $LN20@DbItemSetI
  00229	33 c0		 xor	 eax, eax
  0022b	66 89 85 50 ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], ax
$LN20@DbItemSetI:

; 2567 : 			
; 2568 : 			OptionData     = lpMsg->dbInventory[(n*ItemDbByte)+1];

  00232	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00235	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  00239	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0023c	8a 54 01 41	 mov	 dl, BYTE PTR [ecx+eax+65]
  00240	88 95 47 ff ff
	ff		 mov	 BYTE PTR _OptionData$[ebp], dl

; 2569 : 			item.m_Option1 = (OptionData>>7)&0x01;

  00246	0f b6 85 47 ff
	ff ff		 movzx	 eax, BYTE PTR _OptionData$[ebp]
  0024d	c1 f8 07	 sar	 eax, 7
  00250	83 e0 01	 and	 eax, 1
  00253	88 45 c0	 mov	 BYTE PTR _item$[ebp+120], al

; 2570 : 			item.m_Option2 = (OptionData>>2)&0x01;

  00256	0f b6 85 47 ff
	ff ff		 movzx	 eax, BYTE PTR _OptionData$[ebp]
  0025d	c1 f8 02	 sar	 eax, 2
  00260	83 e0 01	 and	 eax, 1
  00263	88 45 c1	 mov	 BYTE PTR _item$[ebp+121], al

; 2571 : 			item.m_Option3 = OptionData&0x3;

  00266	0f b6 85 47 ff
	ff ff		 movzx	 eax, BYTE PTR _OptionData$[ebp]
  0026d	83 e0 03	 and	 eax, 3
  00270	88 45 c2	 mov	 BYTE PTR _item$[ebp+122], al

; 2572 : 
; 2573 : #ifdef ITEM_DBSIZE_EXTEND_20050706
; 2574 : 			if( ItemDbByte >= 10 )
; 2575 : #else		
; 2576 : 			if( ItemDbByte == 10 )

  00273	83 7d 10 0a	 cmp	 DWORD PTR _ItemDbByte$[ebp], 10 ; 0000000aH
  00277	75 4f		 jne	 SHORT $LN24@DbItemSetI

; 2577 : #endif
; 2578 : 			{
; 2579 : 				if( _type == MAKE_ITEMNUM(13,3) )

  00279	6a 03		 push	 3
  0027b	6a 0d		 push	 13			; 0000000dH
  0027d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00282	83 c4 08	 add	 esp, 8
  00285	39 45 f0	 cmp	 DWORD PTR __type$[ebp], eax
  00288	75 20		 jne	 SHORT $LN22@DbItemSetI

; 2580 : 				{	//   3Bit  
; 2581 : 					item.m_Option3 |= (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x40)>>4;

  0028a	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0028d	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  00291	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00294	0f b6 54 01 47	 movzx	 edx, BYTE PTR [ecx+eax+71]
  00299	83 e2 40	 and	 edx, 64			; 00000040H
  0029c	c1 fa 04	 sar	 edx, 4
  0029f	0f b6 45 c2	 movzx	 eax, BYTE PTR _item$[ebp+122]
  002a3	0b c2		 or	 eax, edx
  002a5	88 45 c2	 mov	 BYTE PTR _item$[ebp+122], al

; 2582 : 				}

  002a8	eb 1e		 jmp	 SHORT $LN24@DbItemSetI
$LN22@DbItemSetI:

; 2583 : 				else
; 2584 : 				{
; 2585 : 					if( (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x40) == 0x40 )

  002aa	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  002ad	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  002b1	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  002b4	0f b6 54 01 47	 movzx	 edx, BYTE PTR [ecx+eax+71]
  002b9	83 e2 40	 and	 edx, 64			; 00000040H
  002bc	74 0a		 je	 SHORT $LN24@DbItemSetI

; 2586 : 						item.m_Option3 += 4;

  002be	0f b6 45 c2	 movzx	 eax, BYTE PTR _item$[ebp+122]
  002c2	83 c0 04	 add	 eax, 4
  002c5	88 45 c2	 mov	 BYTE PTR _item$[ebp+122], al
$LN24@DbItemSetI:

; 2587 : 				}
; 2588 : 			}
; 2589 : 
; 2590 : 			item.m_Durability = lpMsg->dbInventory[(n*ItemDbByte)+2];

  002c8	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  002cb	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  002cf	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  002d2	0f b6 54 01 42	 movzx	 edx, BYTE PTR [ecx+eax+66]
  002d7	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  002db	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _item$[ebp+36], xmm0

; 2591 : 			
; 2592 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 2593 : 	#ifdef MODIFY_JEWELOFHARMONY_380OPTION_DBVERSION_BUGFIX_20060727 // ITEM_DBSIZE_EXTEND_20050706 define  On
; 2594 : 			if ( ItemDbByte >= MAX_ITEMDBBYTE )
; 2595 : 			{
; 2596 : 				item.m_JewelOfHarmonyOption = lpMsg->dbInventory[(n*ItemDbByte)+10];	// 10  :   
; 2597 : 			}
; 2598 : 	#else
; 2599 : 			item.m_JewelOfHarmonyOption = lpMsg->dbInventory[(n*ItemDbByte)+10];	// 10  :   
; 2600 : 	#endif // MODIFY_JEWELOFHARMONY_380OPTION_DBVERSION_BUGFIX_20060727
; 2601 : #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 2602 : 
; 2603 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 2604 : 	#ifdef MODIFY_JEWELOFHARMONY_380OPTION_DBVERSION_BUGFIX_20060727 // ITEM_DBSIZE_EXTEND_20050706 define  On
; 2605 : 			if ( ItemDbByte >= MAX_ITEMDBBYTE )
; 2606 : 			{
; 2607 : 				item.m_ItemOptionEx = (lpMsg->dbInventory[(n*ItemDbByte)+9]&0x08)<<4;	// 9 .  5 1  m_ItemOptionEx  1 
; 2608 : 				// 2006.8.2 
; 2609 : 				if ( item.m_ItemOptionEx != 0 )
; 2610 : 				{
; 2611 : 					// 380     
; 2612 : 					item.m_Type = itype;	// DBVersion3  itype  
; 2613 : 					if ( g_kItemSystemFor380.Is380Item( &item ) == FALSE )
; 2614 : 					{
; 2615 : 						item.m_ItemOptionEx = 0;
; 2616 : 						LogAddTD("[380Item][%s][%s] Invalid 380 Item Option in Inventory pos[%d]", lpObj->AccountID, lpObj->Name, n);
; 2617 : 					}
; 2618 : 				}
; 2619 : 			}
; 2620 : 	#else
; 2621 : 			item.m_ItemOptionEx = (lpMsg->dbInventory[(n*ItemDbByte)+9]&0x08)<<4;	// 9 .  5 1  m_ItemOptionEx  1 
; 2622 : 	#endif // MODIFY_JEWELOFHARMONY_380OPTION_DBVERSION_BUGFIX_20060727
; 2623 : #endif // ADD_380ITEM_NEWOPTION_20060711
; 2624 : 
; 2625 : #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 2626 : 			BYTE SocketOption[MAX_SOCKET_SLOT];
; 2627 : 			BYTE SocketBonusOption = SOCKETSLOT_NONE;
; 2628 : 
; 2629 : 			memset( SocketOption, SOCKETSLOT_NONE, MAX_SOCKET_SLOT );
; 2630 : 
; 2631 : 			if( g_SocketOptionSystem.IsEnableSocketItem( _type ) == true )
; 2632 : 			{
; 2633 : 				for( int i = 0 ; i < MAX_SOCKET_SLOT ; i++ )
; 2634 : 				{
; 2635 : 					SocketOption[i] = lpMsg->dbInventory[(n*ItemDbByte)+11+i];
; 2636 : 				}
; 2637 : 
; 2638 : 				SocketBonusOption = lpMsg->dbInventory[(n*ItemDbByte)+10];
; 2639 : 			}
; 2640 : 			else
; 2641 : 			{
; 2642 : 				for( int i = 0 ; i < MAX_SOCKET_SLOT ; i++ )
; 2643 : 				{
; 2644 : 					SocketOption[i] = SOCKETSLOT_NONE;
; 2645 : 				}
; 2646 : 				
; 2647 : 				SocketBonusOption = 0;
; 2648 : 			}
; 2649 : #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 2650 : 
; 2651 : 
; 2652 : 			if( ItemDbByte == MAX_ITEMDBBYTE_V00 )

  002e3	83 7d 10 07	 cmp	 DWORD PTR _ItemDbByte$[ebp], 7
  002e7	75 26		 jne	 SHORT $LN25@DbItemSetI

; 2653 : 			#ifdef ADD_380ITEM_NEWOPTION_20060711
; 2654 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, 0, 0, 0, 0);
; 2655 : 			#else
; 2656 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, 0, 0, 0);

  002e9	6a 00		 push	 0
  002eb	6a 00		 push	 0
  002ed	6a 00		 push	 0
  002ef	0f b6 45 c2	 movzx	 eax, BYTE PTR _item$[ebp+122]
  002f3	50		 push	 eax
  002f4	0f b6 4d c1	 movzx	 ecx, BYTE PTR _item$[ebp+121]
  002f8	51		 push	 ecx
  002f9	0f b6 55 c0	 movzx	 edx, BYTE PTR _item$[ebp+120]
  002fd	52		 push	 edx
  002fe	8b 45 f4	 mov	 eax, DWORD PTR _itype$[ebp]
  00301	50		 push	 eax
  00302	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  00308	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert
  0030d	eb 43		 jmp	 SHORT $LN26@DbItemSetI
$LN25@DbItemSetI:

; 2657 : 			#endif // ADD_380ITEM_NEWOPTION_20060711
; 2658 : #ifdef ITEM_INDEX_EXTEND_20050706
; 2659 : 			else if(ItemDbByte <= MAX_ITEMDBBYTE_V02) 
; 2660 : 			{
; 2661 : 		#ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 2662 : 			#ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_02_20080630
; 2663 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x3F), lpMsg->dbInventory[(n*ItemDbByte)+8], item.m_ItemOptionEx, SocketOption, SocketBonusOption, 1);
; 2664 : 			#else
; 2665 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x3F), lpMsg->dbInventory[(n*ItemDbByte)+8], item.m_ItemOptionEx, NULL, SOCKETSLOT_NONE, 1);
; 2666 : 			#endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_02_20080630
; 2667 : 		#else
; 2668 : 			#ifdef ADD_380ITEM_NEWOPTION_20060711
; 2669 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x3F), lpMsg->dbInventory[(n*ItemDbByte)+8], item.m_ItemOptionEx, 1);
; 2670 : 			#else
; 2671 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x3F), lpMsg->dbInventory[(n*ItemDbByte)+8], 1);
; 2672 : 			#endif // ADD_380ITEM_NEWOPTION_20060711
; 2673 : 		#endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 2674 : 			}
; 2675 : 			else 
; 2676 : 			{
; 2677 : 		#ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 2678 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x3F), lpMsg->dbInventory[(n*ItemDbByte)+8], item.m_ItemOptionEx, SocketOption, SocketBonusOption, 3);
; 2679 : 		#else
; 2680 : 			#ifdef ADD_380ITEM_NEWOPTION_20060711
; 2681 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x3F), lpMsg->dbInventory[(n*ItemDbByte)+8], item.m_ItemOptionEx, 3);
; 2682 : 			#else
; 2683 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x3F), lpMsg->dbInventory[(n*ItemDbByte)+8], 3);
; 2684 : 			#endif // ADD_380ITEM_NEWOPTION_20060711
; 2685 : 		#endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 2686 : 			}
; 2687 : #else
; 2688 : 			else
; 2689 : 				item.Convert(itype, item.m_Option1, item.m_Option2, item.m_Option3, (lpMsg->dbInventory[(n*ItemDbByte)+7]&0x3F), lpMsg->dbInventory[(n*ItemDbByte)+8], 1);

  0030f	6a 01		 push	 1
  00311	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00314	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  00318	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0031b	0f b6 54 01 48	 movzx	 edx, BYTE PTR [ecx+eax+72]
  00320	52		 push	 edx
  00321	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00324	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  00328	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0032b	0f b6 54 01 47	 movzx	 edx, BYTE PTR [ecx+eax+71]
  00330	83 e2 3f	 and	 edx, 63			; 0000003fH
  00333	52		 push	 edx
  00334	0f b6 45 c2	 movzx	 eax, BYTE PTR _item$[ebp+122]
  00338	50		 push	 eax
  00339	0f b6 4d c1	 movzx	 ecx, BYTE PTR _item$[ebp+121]
  0033d	51		 push	 ecx
  0033e	0f b6 55 c0	 movzx	 edx, BYTE PTR _item$[ebp+120]
  00342	52		 push	 edx
  00343	8b 45 f4	 mov	 eax, DWORD PTR _itype$[ebp]
  00346	50		 push	 eax
  00347	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0034d	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert
$LN26@DbItemSetI:

; 2690 : 
; 2691 : #endif
; 2692 : 
; 2693 : 			//    0 1..
; 2694 : #ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116
; 2695 : 			if( _type == ITEM_POTION + 7 )
; 2696 : 			{
; 2697 : 				//  
; 2698 : 			}
; 2699 : 			else
; 2700 : #endif
; 2701 : 			if( _type >= ITEM_POTION && _type <= ITEM_POTION+8

  00352	81 7d f0 c0 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 448 ; 000001c0H
  00359	7c 53		 jl	 SHORT $LN29@DbItemSetI
  0035b	81 7d f0 c8 01
	00 00		 cmp	 DWORD PTR __type$[ebp], 456 ; 000001c8H
  00362	7f 4a		 jg	 SHORT $LN29@DbItemSetI

; 2702 : #ifdef ADD_SHIELD_POINT_01_20060403
; 2703 : 				|| ( _type >= ITEM_POTION+38 && _type <= ITEM_POTION+40 ) //  
; 2704 : #endif
; 2705 : 				) 
; 2706 : 			{
; 2707 : 				if( item.m_Durability == 0 ) item.m_Durability = 1;

  00364	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR _item$[ebp+36]
  0036c	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00373	9f		 lahf
  00374	f6 c4 44	 test	 ah, 68			; 00000044H
  00377	7a 10		 jp	 SHORT $LN28@DbItemSetI
  00379	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00381	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _item$[ebp+36], xmm0
$LN28@DbItemSetI:

; 2708 : 				if( item.m_Durability > g_GlobalConfig.m_iMaxPotionDurability  ) item.m_Durability = g_GlobalConfig.m_iMaxPotionDurability;

  00389	f3 0f 2a 05 b8
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+184
  00391	f3 0f 10 8d 6c
	ff ff ff	 movss	 xmm1, DWORD PTR _item$[ebp+36]
  00399	0f 2f c8	 comiss	 xmm1, xmm0
  0039c	76 10		 jbe	 SHORT $LN29@DbItemSetI
  0039e	f3 0f 2a 05 b8
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+184
  003a6	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _item$[ebp+36], xmm0
$LN29@DbItemSetI:

; 2709 : 			}
; 2710 : 
; 2711 : #ifdef ADD_FULL_RECOVERY_POTION_20070719
; 2712 : 			if( _type == MAKE_ITEMNUM( 14, 70 )			//   
; 2713 : 				|| _type == MAKE_ITEMNUM( 14, 71 )		//   
; 2714 : 			  )
; 2715 : 			{
; 2716 : 				if( item.m_Durability == 0 )
; 2717 : 				{
; 2718 : 					item.m_Durability = 1;
; 2719 : 				}
; 2720 : 				if( item.m_Durability > MAX_OVERLAP_ELITE_POTION )
; 2721 : 				{
; 2722 : 					item.m_Durability =  MAX_OVERLAP_ELITE_POTION;
; 2723 : 				}
; 2724 : 			}
; 2725 : #endif // ADD_FULL_RECOVERY_POTION_20070719
; 2726 : 
; 2727 : #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 2728 : 			if( _type == MAKE_ITEMNUM( 14, 94 )			//    
; 2729 : 				)
; 2730 : 			{
; 2731 : 				if( item.m_Durability == 0 )
; 2732 : 				{
; 2733 : 					item.m_Durability = 1;
; 2734 : 				}
; 2735 : 				if( item.m_Durability > MAX_OVERLAP_ELITE_POTION )
; 2736 : 				{
; 2737 : 					item.m_Durability =  MAX_OVERLAP_ELITE_POTION;
; 2738 : 				}
; 2739 : 			}
; 2740 : #endif // MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 2741 : 			/*
; 2742 : #ifdef ADD_ELITE_SD_POTION_20090918
; 2743 : 			if( _type == MAKE_ITEMNUM( 14, 133 )		//  SD  
; 2744 : 				)
; 2745 : 			{
; 2746 : 				if( item.m_Durability == 0 )
; 2747 : 				{
; 2748 : 					item.m_Durability = 1;
; 2749 : 				}
; 2750 : 				if( item.m_Durability > 255 ) // MAX_OVERLAP_ELITE_POTION
; 2751 : 				{
; 2752 : 					item.m_Durability =  255;
; 2753 : 				}
; 2754 : 			}
; 2755 : #endif // ADD_ELITE_SD_POTION_20090918
; 2756 : 			*/
; 2757 : #ifdef ADD_PCS_IMPROVE_POTION_20070718
; 2758 : 			if( _type == MAKE_ITEMNUM( 14, 78 )
; 2759 : 				|| _type == MAKE_ITEMNUM( 14, 79 )
; 2760 : 				|| _type == MAKE_ITEMNUM( 14, 80 )
; 2761 : 				|| _type == MAKE_ITEMNUM( 14, 81 )
; 2762 : 				|| _type == MAKE_ITEMNUM( 14, 82 )
; 2763 : 			  )
; 2764 : 			{
; 2765 : 				if( item.m_Durability == 0 )
; 2766 : 				{
; 2767 : 					item.m_Durability = 1;
; 2768 : 				}
; 2769 : 				if( item.m_Durability > MAX_OVERLAP_IMPROVE_POTION )
; 2770 : 				{
; 2771 : 					item.m_Durability = MAX_OVERLAP_IMPROVE_POTION;
; 2772 : 				}
; 2773 : 			}
; 2774 : #endif // ADD_PCS_IMPROVE_POTION_20070718
; 2775 : 
; 2776 : #ifdef ITEM_ADD_OPTION_20061019
; 2777 : 			else if( _type >= ITEM_POTION+46 && _type <= ITEM_POTION+50 )
; 2778 : 			{
; 2779 : 				if( item.m_Durability == 0 )
; 2780 : 				{
; 2781 : 					item.m_Durability = 1;
; 2782 : 				}
; 2783 : 				if( item.m_Durability > g_GlobalConfig.m_iMaxPotionDurability )
; 2784 : 				{
; 2785 : 					item.m_Durability = g_GlobalConfig.m_iMaxPotionDurability;
; 2786 : 				}
; 2787 : 			}
; 2788 : #endif 
; 2789 : 
; 2790 : #ifdef ADD_SHIELD_POINT_01_20060403
; 2791 : 			else if ( _type >= ITEM_POTION+35 && _type <= ITEM_POTION+37 ) // SD ~  SD 
; 2792 : 			{
; 2793 : 				//  1
; 2794 : 				if( item.m_Durability == 0 ) 
; 2795 : 					item.m_Durability = 1;
; 2796 : 				if( item.m_Durability > 1  ) 
; 2797 : 					item.m_Durability = 1;
; 2798 : 			}
; 2799 : #endif // ADD_SHIELD_POINT_01_20060403
; 2800 : 			/*
; 2801 : 			else if( _type != MAKE_ITEMNUM(13,10)
; 2802 : #ifdef ADD_NEW_MAP_KALIMA_20040518
; 2803 : 				 && _type != MAKE_ITEMNUM(14,29)
; 2804 : #endif
; 2805 : #ifdef MU_CASTLESIEGE_CS_MARKS_20041214				//       .
; 2806 : 				 && (_type != MAKE_ITEMNUM(14,21) && item.m_Level == 3)
; 2807 : #endif
; 2808 : #ifdef UPDATE_LUCKY_COIN_EVENT_20081029				//       .
; 2809 : 				 && _type != MAKE_ITEMNUM(14, 100)
; 2810 : #endif	// UPDATE_LUCKY_COIN_EVENT_20081029
; 2811 : 				)
; 2812 : 			{
; 2813 : 				if( item.m_Durability > item.m_BaseDurability 
; 2814 : #ifdef ITEMDELETE_MODIFY_20040604					//      .
; 2815 : 					&& bIsItemExist == true
; 2816 : #endif
; 2817 : 					)
; 2818 : 				{
; 2819 : 					item.m_Durability = item.m_BaseDurability;
; 2820 : 				}
; 2821 : 			}*/
; 2822 : 			//------------->
; 2823 : 			//20080930  5  ,   (grooving)
; 2824 : 			#ifdef ADD_TELEPORT_CHARM_ITEM_20080930
; 2825 : 			else if( _type == MAKE_ITEMNUM(13, 70) )
; 2826 : 			{
; 2827 : 				if( item.m_Durability == 1 )
; 2828 : 					item.m_Durability = item.m_BaseDurability;
; 2829 : 			}
; 2830 : 			#endif //ADD_TELEPORT_CHARM_ITEM_20080930
; 2831 : 			//<-------------
; 2832 : 
; 2833 : #ifndef FOR_BLOODCASTLE_TEST
; 2834 : /*			if (_type == MAKE_ITEMNUM(14,21)) {		//    128  ->   (  )
; 2835 : 				if (item.m_Level == 1)		
; 2836 : 					item.m_Durability = 128;				
; 2837 : 			}
; 2838 : */
; 2839 : #endif			
; 2840 : 
; 2841 : 			/*
; 2842 : 			//    255  ()
; 2843 : 			if( itype >= MAKE_ITEMNUM(12,0) && itype <= MAKE_ITEMNUM(12,2) ) 
; 2844 : 			{
; 2845 : 				item.m_Durability = 255;
; 2846 : 			}
; 2847 : 			if( ItemGetDurability(itype) )
; 2848 : 			{
; 2849 : 				item.m_Durability = ItemGetDurability(itype, item.m_Level, item.IsExtItem());
; 2850 : 			}
; 2851 : 			*/
; 2852 : 			
; 2853 : 
; 2854 : 			lpObj->pInventory[n].m_Option1 = item.m_Option1;

  003ae	69 45 f8 a8 00
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 168
  003b5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003b8	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  003be	8a 4d c0	 mov	 cl, BYTE PTR _item$[ebp+120]
  003c1	88 4c 02 78	 mov	 BYTE PTR [edx+eax+120], cl

; 2855 : 			lpObj->pInventory[n].m_Option2 = item.m_Option2;

  003c5	69 45 f8 a8 00
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 168
  003cc	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003cf	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  003d5	8a 4d c1	 mov	 cl, BYTE PTR _item$[ebp+121]
  003d8	88 4c 02 79	 mov	 BYTE PTR [edx+eax+121], cl

; 2856 : 			lpObj->pInventory[n].m_Option3 = item.m_Option3;

  003dc	69 45 f8 a8 00
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 168
  003e3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003e6	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  003ec	8a 4d c2	 mov	 cl, BYTE PTR _item$[ebp+122]
  003ef	88 4c 02 7a	 mov	 BYTE PTR [edx+eax+122], cl

; 2857 : 
; 2858 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 2859 : 			lpObj->pInventory[n].m_JewelOfHarmonyOption = item.m_JewelOfHarmonyOption;
; 2860 : #endif //	ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 2861 : 
; 2862 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 2863 : 			lpObj->pInventory[n].m_ItemOptionEx = item.m_ItemOptionEx;
; 2864 : #endif // ADD_380ITEM_NEWOPTION_20060711
; 2865 : 
; 2866 : #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 2867 : 			lpObj->pInventory[n].m_BonusSocketOption = item.m_BonusSocketOption;
; 2868 : 			for( int iSlotIndex = 0 ; iSlotIndex < MAX_SOCKET_SLOT ; iSlotIndex++ )
; 2869 : 			{
; 2870 : 				lpObj->pInventory[n].m_SocketOption[iSlotIndex] = item.m_SocketOption[iSlotIndex];
; 2871 : 			}
; 2872 : #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 2873 : 
; 2874 : 			hiWord = MAKEWORD(lpMsg->dbInventory[(n*ItemDbByte)+4], lpMsg->dbInventory[(n*ItemDbByte)+3]);

  003f3	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  003f6	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  003fa	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  003fd	0f b6 54 01 44	 movzx	 edx, BYTE PTR [ecx+eax+68]
  00402	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00408	0f b6 c2	 movzx	 eax, dl
  0040b	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  0040e	0f af 4d 10	 imul	 ecx, DWORD PTR _ItemDbByte$[ebp]
  00412	8b 55 0c	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00415	0f b6 4c 0a 43	 movzx	 ecx, BYTE PTR [edx+ecx+67]
  0041a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00420	0f b6 d1	 movzx	 edx, cl
  00423	c1 e2 08	 shl	 edx, 8
  00426	0b c2		 or	 eax, edx
  00428	66 89 85 40 ff
	ff ff		 mov	 WORD PTR _hiWord$[ebp], ax

; 2875 : 			loWord = MAKEWORD(lpMsg->dbInventory[(n*ItemDbByte)+6], lpMsg->dbInventory[(n*ItemDbByte)+5]);

  0042f	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00432	0f af 45 10	 imul	 eax, DWORD PTR _ItemDbByte$[ebp]
  00436	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00439	0f b6 54 01 46	 movzx	 edx, BYTE PTR [ecx+eax+70]
  0043e	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00444	0f b6 c2	 movzx	 eax, dl
  00447	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  0044a	0f af 4d 10	 imul	 ecx, DWORD PTR _ItemDbByte$[ebp]
  0044e	8b 55 0c	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00451	0f b6 4c 0a 45	 movzx	 ecx, BYTE PTR [edx+ecx+69]
  00456	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0045c	0f b6 d1	 movzx	 edx, cl
  0045f	c1 e2 08	 shl	 edx, 8
  00462	0b c2		 or	 eax, edx
  00464	66 89 85 3c ff
	ff ff		 mov	 WORD PTR _loWord$[ebp], ax

; 2876 : 
; 2877 : 			item.m_Number		= MAKELONG(loWord, hiWord);

  0046b	0f b7 85 3c ff
	ff ff		 movzx	 eax, WORD PTR _loWord$[ebp]
  00472	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00477	0f b7 c8	 movzx	 ecx, ax
  0047a	0f b7 95 40 ff
	ff ff		 movzx	 edx, WORD PTR _hiWord$[ebp]
  00481	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00487	0f b7 c2	 movzx	 eax, dx
  0048a	c1 e0 10	 shl	 eax, 16			; 00000010H
  0048d	0b c8		 or	 ecx, eax
  0048f	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _item$[ebp], ecx

; 2878 : 
; 2879 : 			gObjInventoryInsertItemPos(lpObj->m_Index, item, n, 0);

  00495	6a 00		 push	 0
  00497	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0049a	50		 push	 eax
  0049b	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  004a1	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  004a6	8d b5 48 ff ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  004ac	8b fc		 mov	 edi, esp
  004ae	f3 a5		 rep movsd
  004b0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004b3	8b 11		 mov	 edx, DWORD PTR [ecx]
  004b5	52		 push	 edx
  004b6	e8 00 00 00 00	 call	 ?gObjInventoryInsertItemPos@@YAEHVCItem@@HH@Z ; gObjInventoryInsertItemPos
  004bb	81 c4 b4 00 00
	00		 add	 esp, 180		; 000000b4H

; 2880 : 
; 2881 : #ifdef ITEMDELETE_MODIFY_20040604
; 2882 : 			if (bIsItemExist == false) 

  004c1	0f b6 85 3b ff
	ff ff		 movzx	 eax, BYTE PTR _bIsItemExist$[ebp]
  004c8	85 c0		 test	 eax, eax
  004ca	0f 85 ec 00 00
	00		 jne	 $LN30@DbItemSetI

; 2883 : 			{
; 2884 : 				lpObj->pInventory[n].m_bItemExist = false;

  004d0	69 45 f8 a8 00
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 168
  004d7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004da	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  004e0	c6 44 02 6c 00	 mov	 BYTE PTR [edx+eax+108], 0

; 2885 : 
; 2886 : 				LogAddTD("error-L2 : Unknown Item found [%s][%s] (Type:%d, LEV:%d, DUR:%d OP1:%d, OP2:%d, OP3:%d, NEWOP:%d, SET:%d)",

  004e5	69 45 f8 a8 00
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 168
  004ec	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004ef	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  004f5	0f b6 84 02 92
	00 00 00	 movzx	 eax, BYTE PTR [edx+eax+146]
  004fd	50		 push	 eax
  004fe	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 168
  00505	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00508	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0050e	0f b6 4c 08 7b	 movzx	 ecx, BYTE PTR [eax+ecx+123]
  00513	51		 push	 ecx
  00514	69 55 f8 a8 00
	00 00		 imul	 edx, DWORD PTR _n$[ebp], 168
  0051b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0051e	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00524	0f b6 54 11 7a	 movzx	 edx, BYTE PTR [ecx+edx+122]
  00529	52		 push	 edx
  0052a	69 45 f8 a8 00
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 168
  00531	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00534	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0053a	0f b6 44 02 79	 movzx	 eax, BYTE PTR [edx+eax+121]
  0053f	50		 push	 eax
  00540	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 168
  00547	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0054a	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00550	0f b6 4c 08 78	 movzx	 ecx, BYTE PTR [eax+ecx+120]
  00555	51		 push	 ecx
  00556	69 55 f8 a8 00
	00 00		 imul	 edx, DWORD PTR _n$[ebp], 168
  0055d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00560	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00566	f3 0f 5a 44 11
	24		 cvtss2sd xmm0, DWORD PTR [ecx+edx+36]
  0056c	83 ec 08	 sub	 esp, 8
  0056f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00574	69 55 f8 a8 00
	00 00		 imul	 edx, DWORD PTR _n$[ebp], 168
  0057b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0057e	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00584	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  00589	52		 push	 edx
  0058a	69 45 f8 a8 00
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 168
  00591	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00594	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0059a	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  0059f	50		 push	 eax
  005a0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005a3	83 c1 73	 add	 ecx, 115		; 00000073H
  005a6	51		 push	 ecx
  005a7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005aa	83 c2 68	 add	 edx, 104		; 00000068H
  005ad	52		 push	 edx
  005ae	68 00 00 00 00	 push	 OFFSET ??_C@_0GK@NPPGCJHE@error?9L2?5?3?5Unknown?5Item?5found?5?$FL@
  005b3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005b9	83 c4 30	 add	 esp, 48			; 00000030H
$LN30@DbItemSetI:

; 2887 : 					lpObj->AccountID,
; 2888 : 					lpObj->Name,
; 2889 : 					lpObj->pInventory[n].m_Type,
; 2890 : 					lpObj->pInventory[n].m_Level,
; 2891 : 					lpObj->pInventory[n].m_Durability,
; 2892 : 					lpObj->pInventory[n].m_Option1,
; 2893 : 					lpObj->pInventory[n].m_Option2,
; 2894 : 					lpObj->pInventory[n].m_Option3,
; 2895 : 					lpObj->pInventory[n].m_NewOption,
; 2896 : 					lpObj->pInventory[n].m_SetOption
; 2897 : 					);
; 2898 : 			}
; 2899 : #endif
; 2900 : 		}
; 2901 : 	}

  005bc	e9 70 fa ff ff	 jmp	 $LN2@DbItemSetI
$LN3@DbItemSetI:

; 2902 : 
; 2903 : #ifdef TEST_SETITEM_CLEAR	//     
; 2904 : 	lpObj->ClearInfoForSetItem |= 0x01;
; 2905 : #endif	
; 2906 : 
; 2907 : #ifdef DARKLORD_WORK
; 2908 : 	gObjRequestPetItemInfo(lpObj->m_Index, 0);

  005c1	6a 00		 push	 0
  005c3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  005c8	51		 push	 ecx
  005c9	e8 00 00 00 00	 call	 ?gObjRequestPetItemInfo@@YAXHH@Z ; gObjRequestPetItemInfo
  005ce	83 c4 08	 add	 esp, 8

; 2909 : #endif	
; 2910 : }

  005d1	5f		 pop	 edi
  005d2	5e		 pop	 esi
  005d3	5b		 pop	 ebx
  005d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005d7	33 cd		 xor	 ecx, ebp
  005d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005de	8b e5		 mov	 esp, ebp
  005e0	5d		 pop	 ebp
  005e1	c3		 ret	 0
?DbItemSetInByte@@YAXPAVOBJECTSTRUCT@@PAUSDHP_DBCHAR_INFORESULT@@HPA_N@Z ENDP ; DbItemSetInByte
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCharZeroSet@@YAXH@Z
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_lpObj$ = -8						; size = 4
_i$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjCharZeroSet@@YAXH@Z PROC				; gObjCharZeroSet, COMDAT

; 1430 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1431 : 	int i;
; 1432 : 	LPOBJECTSTRUCT	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 1433 : 	
; 1434 : 	memset(lpObj->Name,      0, MAX_IDSTRING);

  00019	6a 0a		 push	 10			; 0000000aH
  0001b	6a 00		 push	 0
  0001d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00020	83 c0 73	 add	 eax, 115		; 00000073H
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _memset
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1435 : 
; 1436 : #ifdef GUILDNAME_MEMSET_20050410
; 1437 : 	memset(lpObj->GuildName, 0, sizeof(lpObj->GuildName));

  0002c	6a 0b		 push	 11			; 0000000bH
  0002e	6a 00		 push	 0
  00030	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00033	05 98 02 00 00	 add	 eax, 664		; 00000298H
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _memset
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1438 : #endif
; 1439 : 
; 1440 : #ifdef DUEL_SYSTEM_20031028
; 1441 : 	lpObj->m_Option		= OPTION_TRADE | OPTION_DUEL;

  00041	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00044	c7 80 c0 0c 00
	00 03 00 00 00	 mov	 DWORD PTR [eax+3264], 3

; 1442 : #else
; 1443 : 	lpObj->m_Option		= OPTION_TRADE;
; 1444 : #endif
; 1445 : 	
; 1446 : #ifdef MODIFY_CRYWOLF_BENEFIT_01_20060315
; 1447 : 	lpObj->m_iScriptMaxLife = 0;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00051	c7 80 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+196], 0

; 1448 : #endif // MODIFY_CRYWOLF_BENEFIT_01_20060315
; 1449 : 
; 1450 : #ifdef MODIFY_MATCHDB_STRANGE_UPDATING_20060822
; 1451 : 	lpObj->Level		= 0;
; 1452 : 	
; 1453 : 	#ifdef LOGINSERVER_MULOG
; 1454 : 	ZeroMemory( lpObj->BackName, MAX_IDSTRING + 1 );
; 1455 : 	#endif
; 1456 : 
; 1457 : #endif
; 1458 : 
; 1459 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912		//   
; 1460 : 	lpObj->m_nMasterLevel			= 0;	
; 1461 : 
; 1462 : 	lpObj->m_i64MasterLevelExp		= 0;
; 1463 : 	lpObj->m_i64NextMasterLevelExp	= 0;
; 1464 : 
; 1465 : 	lpObj->m_iMasterLevelPoint		= 0;
; 1466 : 
; 1467 : 	lpObj->m_bMasterLevelDBLoad		= FALSE;
; 1468 : #endif
; 1469 : 	
; 1470 : 	lpObj->Life			= 0.f;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005e	0f 57 c0	 xorps	 xmm0, xmm0
  00061	f3 0f 11 80 bc
	00 00 00	 movss	 DWORD PTR [eax+188], xmm0

; 1471 : 	lpObj->MaxLife		= 0.f;

  00069	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006c	0f 57 c0	 xorps	 xmm0, xmm0
  0006f	f3 0f 11 80 c0
	00 00 00	 movss	 DWORD PTR [eax+192], xmm0

; 1472 : 	lpObj->AddLife		= 0;

  00077	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007a	c7 80 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+268], 0

; 1473 : 	lpObj->AddMana		= 0;

  00084	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00087	c7 80 10 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+272], 0

; 1474 : 	lpObj->Live			= 0;

  00091	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00094	c6 40 66 00	 mov	 BYTE PTR [eax+102], 0

; 1475 : 	lpObj->Dir			= 0;

  00098	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009b	c6 80 08 01 00
	00 00		 mov	 BYTE PTR [eax+264], 0

; 1476 : 	lpObj->X			= 0;

  000a2	33 c0		 xor	 eax, eax
  000a4	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a7	66 89 81 04 01
	00 00		 mov	 WORD PTR [ecx+260], ax

; 1477 : 	lpObj->Y			= 0;

  000ae	33 c0		 xor	 eax, eax
  000b0	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000b3	66 89 81 06 01
	00 00		 mov	 WORD PTR [ecx+262], ax

; 1478 : 	lpObj->TX			= 0;

  000ba	33 c0		 xor	 eax, eax
  000bc	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000bf	66 89 81 20 01
	00 00		 mov	 WORD PTR [ecx+288], ax

; 1479 : 	lpObj->TY			= 0;

  000c6	33 c0		 xor	 eax, eax
  000c8	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000cb	66 89 81 22 01
	00 00		 mov	 WORD PTR [ecx+290], ax

; 1480 : 	lpObj->MTX			= 0;

  000d2	33 c0		 xor	 eax, eax
  000d4	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000d7	66 89 81 24 01
	00 00		 mov	 WORD PTR [ecx+292], ax

; 1481 : 	lpObj->MTY			= 0;

  000de	33 c0		 xor	 eax, eax
  000e0	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000e3	66 89 81 26 01
	00 00		 mov	 WORD PTR [ecx+294], ax

; 1482 : 	lpObj->MapNumber	= 0;

  000ea	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ed	c6 80 09 01 00
	00 00		 mov	 BYTE PTR [eax+265], 0

; 1483 : 	lpObj->RegenTime	= 0;

  000f4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f7	c7 80 04 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+516], 0

; 1484 : 	lpObj->m_State		= OBJST_NONE;

  00101	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00104	c7 80 b8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+440], 0

; 1485 : 	lpObj->RegenOk		= 0;

  0010e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00111	c6 80 ff 01 00
	00 00		 mov	 BYTE PTR [eax+511], 0

; 1486 : 	lpObj->lpAttackObj	= NULL;

  00118	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011b	c7 80 30 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+560], 0

; 1487 : //	lpObj->PartyNumber	= -1;
; 1488 : 	lpObj->PartyTargetUser	= -1;

  00125	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00128	c7 80 8c 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+652], -1

; 1489 : 	lpObj->m_MoveGateNumber	= -1;

  00132	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00135	c6 80 a0 01 00
	00 ff		 mov	 BYTE PTR [eax+416], -1

; 1490 : 	lpObj->CloseCount   = -1;

  0013c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013f	c6 40 0a ff	 mov	 BYTE PTR [eax+10], -1

; 1491 : 	lpObj->CloseType    = -1;

  00143	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00146	c6 40 0b ff	 mov	 BYTE PTR [eax+11], -1

; 1492 : 	lpObj->m_IfState.state = -1;

  0014a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014d	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00153	80 c9 0c	 or	 cl, 12			; 0000000cH
  00156	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00159	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 1493 : 	lpObj->m_IfState.type  = -1;

  0015f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00162	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00168	80 c9 f0	 or	 cl, 240			; 000000f0H
  0016b	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0016e	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 1494 : 	lpObj->m_IfState.use   = 0;

  00174	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00177	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0017d	80 e1 fc	 and	 cl, 252			; 000000fcH
  00180	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00183	88 8a 56 0c 00
	00		 mov	 BYTE PTR [edx+3158], cl

; 1495 : 	lpObj->m_InterfaceTime = 0;

  00189	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0018c	c7 80 58 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3160], 0

; 1496 : 	lpObj->m_ActionNumber = 0;

  00196	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00199	c6 80 b4 01 00
	00 00		 mov	 BYTE PTR [eax+436], 0

; 1497 : 	lpObj->m_State = 0;

  001a0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a3	c7 80 b8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+440], 0

; 1498 : 	lpObj->m_StateSub =0;

  001ad	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b0	c6 80 bc 01 00
	00 00		 mov	 BYTE PTR [eax+444], 0

; 1499 : 	lpObj->m_ViewState = 0;

  001b7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ba	c6 80 be 01 00
	00 00		 mov	 BYTE PTR [eax+446], 0

; 1500 : 	lpObj->m_Rest = 0;

  001c1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c4	c6 80 bd 01 00
	00 00		 mov	 BYTE PTR [eax+445], 0

; 1501 : 
; 1502 : 	//------------->
; 1503 : 	//20080930  5  ,   (grooving)
; 1504 : #ifdef ADD_TELEPORT_CHARM_ITEM_20080930
; 1505 : 	lpObj->m_siDieRegenX		=	0;			//   X
; 1506 : 	lpObj->m_siDieRegenY		=	0;			//   Y
; 1507 : 	lpObj->m_siDieRegenMapIndex	=	0;			//   Map
; 1508 : 	
; 1509 : 	lpObj->m_siMoveX			=	0;			//   X
; 1510 : 	lpObj->m_siMoveY			=	0;			//   Y
; 1511 : 	lpObj->m_siMoveMapIndex		=	0;			//   Map
; 1512 : #endif
; 1513 : 	//<-------------
; 1514 : 
; 1515 : #ifdef ADD_SHIELD_POINT_01_20060403
; 1516 : 	lpObj->iMaxShield = 0;
; 1517 : 	lpObj->iShield = 0;
; 1518 : 	lpObj->iAddShield = 0;
; 1519 : 
; 1520 : 	lpObj->iFillShield = 0;
; 1521 : 	lpObj->iFillShieldMax = 0;
; 1522 : 	lpObj->iFillShieldCount = 0;
; 1523 : 
; 1524 : 	lpObj->dwShieldAutoRefillTimer = 0;
; 1525 : #endif
; 1526 : 
; 1527 : #ifdef ITEM_ADD_OPTION_20061019
; 1528 : 	lpObj->m_wItemEffectType = 0;
; 1529 : 	lpObj->m_iItemEffectValidTime = 0;
; 1530 : #endif // ITEM_ADD_OPTION_20061019
; 1531 : 
; 1532 : #ifdef ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 1533 : 	lpObj->m_wCashPoint = 0;
; 1534 : #endif // ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 1535 : 
; 1536 : #ifdef ADD_PARTIALY_CHARGE_PERIOD_SYSTEM_20070205
; 1537 : 	lpObj->m_iPeriodItemEffectIndex	= -1;
; 1538 : #endif // ADD_PARTIALY_CHARGE_PERIOD_SYSTEM_20070205
; 1539 : 
; 1540 : #ifdef MODIFY_DENY_USER_DISCONNNECT_HACK_20080323
; 1541 : 	lpObj->m_UserKillRecvCount = 0;
; 1542 : #endif // MODIFY_DENY_USER_DISCONNNECT_HACK_20080323
; 1543 : 	
; 1544 : #ifdef ADD_PCS_MARK_OF_EXP_20070205
; 1545 : 	#ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004					// !! NOT
; 1546 : 	lpObj->m_wExprienceRate = 100;

  001cb	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  001d0	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001d3	66 89 81 2c 1a
	00 00		 mov	 WORD PTR [ecx+6700], ax

; 1547 : 	lpObj->m_wItemDropRate	= 100;

  001da	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  001df	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001e2	66 89 81 2e 1a
	00 00		 mov	 WORD PTR [ecx+6702], ax

; 1548 : 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1549 : #endif // ADD_PCS_MARK_OF_EXP_20070205
; 1550 : 
; 1551 : 	lpObj->m_wExcellentDropRate = 2000;

  001e9	b8 d0 07 00 00	 mov	 eax, 2000		; 000007d0H
  001ee	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001f1	66 89 81 32 1a
	00 00		 mov	 WORD PTR [ecx+6706], ax

; 1552 : #ifdef ADD_REWARD_ABOUT_KALIMA_BOSS_01_20040907
; 1553 : 	lpObj->m_wAncientDropRate = 100;

  001f8	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  001fd	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00200	66 89 81 34 1a
	00 00		 mov	 WORD PTR [ecx+6708], ax

; 1554 : #endif
; 1555 : 
; 1556 : #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 1557 : 	gObjClearBuffEffect( lpObj, CLEAR_TYPE_LOGOUT );
; 1558 : #else
; 1559 : 	#ifdef EXPAND_VIEWSKILLSTATE_WORD_TO_INT_20041122
; 1560 : 	lpObj->m_ViewSkillState = STATE_NONE;
; 1561 : 	#else
; 1562 : 	lpObj->m_ViewSkillState = 0;

  00207	33 c0		 xor	 eax, eax
  00209	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0020c	66 89 81 c0 01
	00 00		 mov	 WORD PTR [ecx+448], ax

; 1563 : 	#endif
; 1564 : #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 1565 : 
; 1566 : #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1567 : 	lpObj->m_PoisonBeattackCount = 0;

  00213	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00216	c6 80 18 1a 00
	00 00		 mov	 BYTE PTR [eax+6680], 0

; 1568 : 	lpObj->m_ColdBeattackCount = 0;

  0021d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00220	c6 80 19 1a 00
	00 00		 mov	 BYTE PTR [eax+6681], 0

; 1569 : 
; 1570 : 	lpObj->m_SkillDefense		= 0;

  00227	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0022a	c7 80 1c 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6684], 0

; 1571 : 	lpObj->m_SkillDefenseTime	= 0;

  00234	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00237	c7 80 20 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6688], 0

; 1572 : 	lpObj->m_SkillAttack		= 0;

  00241	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00244	c7 80 24 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6692], 0

; 1573 : 	lpObj->m_SkillAttackTime	= 0;

  0024e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00251	c7 80 28 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6696], 0

; 1574 : 
; 1575 : 	#ifdef NEW_SKILL_FORSKYLAND
; 1576 : 	lpObj->m_SkillAddLife		= 0;

  0025b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0025e	c7 80 f4 19 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6644], 0

; 1577 : 	lpObj->m_SkillAddLifeTime	= 0;

  00268	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0026b	c7 80 f8 19 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6648], 0

; 1578 : 
; 1579 : 	lpObj->m_SkillHarden		= 0;

  00275	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00278	c7 80 fc 19 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6652], 0

; 1580 : 	lpObj->m_SkillHardenTime	= 0;	

  00282	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00285	c7 80 00 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6656], 0

; 1581 : 
; 1582 : 	lpObj->m_SkillMagumReduceDefense		= 0;

  0028f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00292	c7 80 04 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6660], 0

; 1583 : 	lpObj->m_SkillMagumReduceDefenseTime	= 0;	

  0029c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0029f	c7 80 08 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6664], 0

; 1584 : 	#endif
; 1585 : 
; 1586 : 	#ifdef NEW_SKILL_FORSKYLAND
; 1587 : 	lpObj->m_WizardSkillDefense	= 0;

  002a9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ac	c7 80 0c 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6668], 0

; 1588 : 	lpObj->m_WizardSkillDefenseTime = 0;

  002b6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002b9	c7 80 10 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6672], 0

; 1589 : 	#endif // NEW_SKILL_FORSKYLAND
; 1590 : 
; 1591 : 	#ifdef DARKLORD_WORK
; 1592 : 	lpObj->SkillAddCriticalDamageTime = 0;

  002c3	33 c0		 xor	 eax, eax
  002c5	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002c8	66 89 81 14 1a
	00 00		 mov	 WORD PTR [ecx+6676], ax

; 1593 : 	lpObj->SkillAddCriticalDamage = 0;

  002cf	33 c0		 xor	 eax, eax
  002d1	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002d4	66 89 81 16 1a
	00 00		 mov	 WORD PTR [ecx+6678], ax

; 1594 : 	#endif 
; 1595 : 
; 1596 : 	#ifdef ADD_NEW_SKILL_FOR_CASTLE_01_20041116
; 1597 : 	lpObj->m_iSkillStunTime				= 0;		//   
; 1598 : 	lpObj->m_iSkillBrandOfSkillTime		= 0;		//  
; 1599 : 	lpObj->m_iSkillInvisibleTime		= 0;		//  
; 1600 : 	lpObj->m_iSkillManaSwellTime		= 0;		//  
; 1601 : 	lpObj->m_iSkillManaSwell			= 0;		// 
; 1602 : 	#endif 
; 1603 : 
; 1604 : 	#ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116
; 1605 : 	lpObj->m_iPotionBlessTime			= 0;		//    
; 1606 : 	lpObj->m_iPotionSoulTime			= 0;		//     
; 1607 : 	#endif
; 1608 : 
; 1609 : 	#ifdef ADD_NPC_SHADOW_PHANTOM_20050616
; 1610 : 	lpObj->m_iSkillNPCHelpTime = 0;
; 1611 : 	lpObj->m_iSkillNPCDefense = 0;
; 1612 : 	lpObj->m_iSkillNPCAttack = 0;
; 1613 : 	#endif
; 1614 : 
; 1615 : 	#ifdef ADD_SKILL_MUSE_ELF_INFINITYARROW_20060406
; 1616 : 	lpObj->m_iMuseElfInfinityArrowSkillTime	= 0;
; 1617 : 	#endif
; 1618 : 
; 1619 : 	#ifdef PCBANG_POINT_SYSTEM_20070206		// 
; 1620 : 	lpObj->m_iPCBangPointItemTime		= 0;
; 1621 : 	lpObj->m_iPCBangPointItemAddExpPer	= 0;
; 1622 : 	lpObj->m_bPCBangPointNoMoreExp		= 0;
; 1623 : 	lpObj->m_iPCBangPointItemGiveItemPer	= 0;	
; 1624 : 	#endif
; 1625 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1626 : 	
; 1627 : 	lpObj->m_Attribute	= 0;

  002db	33 c0		 xor	 eax, eax
  002dd	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002e0	66 89 81 fe 02
	00 00		 mov	 WORD PTR [ecx+766], ax

; 1628 : 
; 1629 : #ifdef ADD_NEW_MAP_KALIMA_20040518					//   
; 1630 : 	lpObj->m_ImmuneToMagicCount			= 0;		//   

  002e7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ea	c6 80 23 02 00
	00 00		 mov	 BYTE PTR [eax+547], 0

; 1631 : 	lpObj->m_ImmuneToHarmCount			= 0;		//   

  002f1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002f4	c6 80 24 02 00
	00 00		 mov	 BYTE PTR [eax+548], 0

; 1632 : 	lpObj->m_iMonsterBattleDelay		= 0;		//         (  )

  002fb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002fe	c6 80 25 02 00
	00 00		 mov	 BYTE PTR [eax+549], 0

; 1633 : 	
; 1634 : 	lpObj->m_cKalimaGateExist			= false;	//     

  00305	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00308	c6 80 26 02 00
	00 00		 mov	 BYTE PTR [eax+550], 0

; 1635 : 	lpObj->m_iKalimaGateIndex			= -1;		//    

  0030f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00312	c7 80 28 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+552], -1

; 1636 : 
; 1637 : 	lpObj->m_cKalimaGateEnterCount		= 0;		//   

  0031c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0031f	c6 80 2c 02 00
	00 00		 mov	 BYTE PTR [eax+556], 0

; 1638 : #endif
; 1639 : 
; 1640 : 	lpObj->TradeOk = 0;

  00326	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00329	c6 80 90 0c 00
	00 00		 mov	 BYTE PTR [eax+3216], 0

; 1641 : 	lpObj->sHDCount = 0;

  00330	33 c0		 xor	 eax, eax
  00332	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00335	66 89 81 54 0c
	00 00		 mov	 WORD PTR [ecx+3156], ax

; 1642 : 	lpObj->PathCount = 0;

  0033c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0033f	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0

; 1643 : 	lpObj->PathCur =0 ;

  00349	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0034c	c7 80 2c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+300], 0

; 1644 : 	lpObj->PathStartEnd = 0;

  00356	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00359	c6 80 30 01 00
	00 00		 mov	 BYTE PTR [eax+304], 0

; 1645 : 	lpObj->VPCount = 0;

  00360	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00363	c7 80 6c 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2668], 0

; 1646 : 	lpObj->VPCount2 = 0;

  0036d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00370	c7 80 70 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2672], 0

; 1647 : 	lpObj->m_ShopTime = 0;

  0037a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0037d	c6 80 ec 01 00
	00 00		 mov	 BYTE PTR [eax+492], 0

; 1648 : 	lpObj->m_ManaFillCount = 0;

  00384	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00387	c6 80 3d 02 00
	00 00		 mov	 BYTE PTR [eax+573], 0

; 1649 : 
; 1650 : 	lpObj->FillLife = 0.f;

  0038e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00391	0f 57 c0	 xorps	 xmm0, xmm0
  00394	f3 0f 11 80 c8
	00 00 00	 movss	 DWORD PTR [eax+200], xmm0

; 1651 : 
; 1652 : #ifdef ADD_KUNDUN_CONTROL_20040923
; 1653 : 	//     
; 1654 : 	lpObj->iObjectSecTimer = 0;

  0039c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039f	c7 80 e8 19 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6632], 0

; 1655 : #endif
; 1656 : 
; 1657 : 	// 
; 1658 : #ifdef __FRIEND_WORK__
; 1659 : 	lpObj->m_FriendServerOnline = FRIENDSERVER_ONLINE;

  003a9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003ac	c6 80 cc 01 00
	00 00		 mov	 BYTE PTR [eax+460], 0

; 1660 : #endif
; 1661 : 
; 1662 : #ifdef CHINA_HACKUSER_KICK_SYSTEM	
; 1663 : 	lpObj->bWaitBlockState = FALSE;
; 1664 : 	ChinaHackUserKick.InitUserInfo(lpObj->m_Index);
; 1665 : #endif
; 1666 : 		
; 1667 : 	lpObj->SetOpAddMaxAttackDamage	= 0;

  003b3	33 c0		 xor	 eax, eax
  003b5	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003b8	66 89 81 3c 0f
	00 00		 mov	 WORD PTR [ecx+3900], ax

; 1668 : 	lpObj->SetOpAddMinAttackDamage	= 0;

  003bf	33 c0		 xor	 eax, eax
  003c1	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003c4	66 89 81 3a 0f
	00 00		 mov	 WORD PTR [ecx+3898], ax

; 1669 : 	lpObj->SetOpAddDamage	= 0;	

  003cb	33 c0		 xor	 eax, eax
  003cd	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003d0	66 89 81 38 0f
	00 00		 mov	 WORD PTR [ecx+3896], ax

; 1670 : 	lpObj->SetOpIncAGValue	= 0;

  003d7	33 c0		 xor	 eax, eax
  003d9	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003dc	66 89 81 36 0f
	00 00		 mov	 WORD PTR [ecx+3894], ax

; 1671 : 	lpObj->SetOpAddCriticalDamageSuccessRate	= 0;

  003e3	33 c0		 xor	 eax, eax
  003e5	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003e8	66 89 81 34 0f
	00 00		 mov	 WORD PTR [ecx+3892], ax

; 1672 : 	lpObj->SetOpAddCriticalDamage	= 0;

  003ef	33 c0		 xor	 eax, eax
  003f1	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003f4	66 89 81 32 0f
	00 00		 mov	 WORD PTR [ecx+3890], ax

; 1673 : 	lpObj->SetOpAddExDamageSuccessRate	= 0;

  003fb	33 c0		 xor	 eax, eax
  003fd	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00400	66 89 81 30 0f
	00 00		 mov	 WORD PTR [ecx+3888], ax

; 1674 : 	lpObj->SetOpAddExDamage	= 0;

  00407	33 c0		 xor	 eax, eax
  00409	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0040c	66 89 81 2e 0f
	00 00		 mov	 WORD PTR [ecx+3886], ax

; 1675 : 	lpObj->SetOpAddSkillAttack	= 0;

  00413	33 c0		 xor	 eax, eax
  00415	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00418	66 89 81 2c 0f
	00 00		 mov	 WORD PTR [ecx+3884], ax

; 1676 : 	
; 1677 : 	lpObj->AddStrength	= 0;

  0041f	33 c0		 xor	 eax, eax
  00421	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00424	66 89 81 e0 00
	00 00		 mov	 WORD PTR [ecx+224], ax

; 1678 : 	lpObj->AddDexterity = 0;

  0042b	33 c0		 xor	 eax, eax
  0042d	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00430	66 89 81 e2 00
	00 00		 mov	 WORD PTR [ecx+226], ax

; 1679 : 	lpObj->AddVitality	= 0;

  00437	33 c0		 xor	 eax, eax
  00439	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0043c	66 89 81 e4 00
	00 00		 mov	 WORD PTR [ecx+228], ax

; 1680 : 	lpObj->AddEnergy	= 0;

  00443	33 c0		 xor	 eax, eax
  00445	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00448	66 89 81 e6 00
	00 00		 mov	 WORD PTR [ecx+230], ax

; 1681 : 
; 1682 : 	lpObj->SetOpAddAttackDamage	= 0;

  0044f	33 c0		 xor	 eax, eax
  00451	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00454	66 89 81 3e 0f
	00 00		 mov	 WORD PTR [ecx+3902], ax

; 1683 : 	lpObj->SetOpAddDefence		= 0;

  0045b	33 c0		 xor	 eax, eax
  0045d	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00460	66 89 81 40 0f
	00 00		 mov	 WORD PTR [ecx+3904], ax

; 1684 : 	lpObj->SetOpAddMagicPower	= 0;

  00467	33 c0		 xor	 eax, eax
  00469	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0046c	66 89 81 44 0f
	00 00		 mov	 WORD PTR [ecx+3908], ax

; 1685 : 	lpObj->SetOpAddDefenceRate	= 0;

  00473	33 c0		 xor	 eax, eax
  00475	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00478	66 89 81 42 0f
	00 00		 mov	 WORD PTR [ecx+3906], ax

; 1686 : 
; 1687 : 	lpObj->SetOpIgnoreDefense				= 0;

  0047f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00482	c6 80 46 0f 00
	00 00		 mov	 BYTE PTR [eax+3910], 0

; 1688 : 	lpObj->SetOpDoubleDamage				= 0;

  00489	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0048c	c6 80 47 0f 00
	00 00		 mov	 BYTE PTR [eax+3911], 0

; 1689 : 	lpObj->SetOpTwoHandSwordImproveDamage	= 0;

  00493	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00496	c6 80 48 0f 00
	00 00		 mov	 BYTE PTR [eax+3912], 0

; 1690 : 	lpObj->SetOpImproveSuccessAttackRate	= 0;

  0049d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004a0	c6 80 49 0f 00
	00 00		 mov	 BYTE PTR [eax+3913], 0

; 1691 : 	lpObj->SetOpReflectionDamage			= 0;

  004a7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004aa	c6 80 4a 0f 00
	00 00		 mov	 BYTE PTR [eax+3914], 0

; 1692 : 	lpObj->SetOpImproveSheldDefence			= 0;

  004b1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004b4	c6 80 4b 0f 00
	00 00		 mov	 BYTE PTR [eax+3915], 0

; 1693 : 	lpObj->SetOpDecreaseAG					= 0;

  004bb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004be	c6 80 4c 0f 00
	00 00		 mov	 BYTE PTR [eax+3916], 0

; 1694 : 	lpObj->SetOpImproveItemDropRate			= 0;

  004c5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004c8	c6 80 4d 0f 00
	00 00		 mov	 BYTE PTR [eax+3917], 0

; 1695 : 
; 1696 : 	memset(lpObj->m_AddResistance,	0, MAX_RESISTANCE);

  004cf	6a 07		 push	 7
  004d1	6a 00		 push	 0
  004d3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004d6	05 3c 03 00 00	 add	 eax, 828		; 0000033cH
  004db	50		 push	 eax
  004dc	e8 00 00 00 00	 call	 _memset
  004e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1697 : 
; 1698 : 	lpObj->IsFullSetItem					= 0;

  004e4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004e7	c6 80 4e 0f 00
	00 00		 mov	 BYTE PTR [eax+3918], 0

; 1699 : 
; 1700 : 	lpObj->DamageMinus	      = 0;

  004ee	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004f1	c6 80 14 01 00
	00 00		 mov	 BYTE PTR [eax+276], 0

; 1701 : 	lpObj->DamageReflect      = 0;

  004f8	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004fb	c6 80 15 01 00
	00 00		 mov	 BYTE PTR [eax+277], 0

; 1702 : 	lpObj->MonsterDieGetMoney = 0;

  00502	33 c0		 xor	 eax, eax
  00504	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00507	66 89 81 16 01
	00 00		 mov	 WORD PTR [ecx+278], ax

; 1703 : 	lpObj->MonsterDieGetLife  = 0;

  0050e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00511	c6 80 18 01 00
	00 00		 mov	 BYTE PTR [eax+280], 0

; 1704 : 	lpObj->MonsterDieGetMana  = 0;

  00518	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0051b	c6 80 19 01 00
	00 00		 mov	 BYTE PTR [eax+281], 0

; 1705 : 
; 1706 : 	lpObj->m_CriticalDamage = 0;

  00522	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00525	c7 80 04 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+772], 0

; 1707 : 	lpObj->m_ExcelentDamage = 0;

  0052f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00532	c7 80 08 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+776], 0

; 1708 : 
; 1709 : 	lpObj->UseMagicNumber = 0;

  0053c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0053f	c6 80 15 03 00
	00 00		 mov	 BYTE PTR [eax+789], 0

; 1710 : 	lpObj->UseMagicTime   = 0;

  00546	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00549	c7 80 18 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+792], 0

; 1711 : 	lpObj->UseMagicCount  = 0;

  00553	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00556	c6 80 1c 03 00
	00 00		 mov	 BYTE PTR [eax+796], 0

; 1712 : 
; 1713 : 	lpObj->OSAttackSerial = -1;

  0055d	83 c8 ff	 or	 eax, -1
  00560	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00563	66 89 81 1e 03
	00 00		 mov	 WORD PTR [ecx+798], ax

; 1714 : 	lpObj->SASCount       = 0;

  0056a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0056d	c6 80 20 03 00
	00 00		 mov	 BYTE PTR [eax+800], 0

; 1715 : 	lpObj->SkillAttackTime= GetTickCount();

  00574	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0057a	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0057d	89 81 24 03 00
	00		 mov	 DWORD PTR [ecx+804], eax

; 1716 : 	
; 1717 : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107
; 1718 : 	lpObj->m_nSoulBarrierDefence	= 0;
; 1719 : 	lpObj->m_nSoulBarrierManaRate	= 0;
; 1720 : #endif
; 1721 : 
; 1722 : 	lpObj->m_AttackSpeed = 0;

  00583	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00586	c7 80 e0 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+736], 0

; 1723 : 	lpObj->m_MagicSpeed = 0;

  00590	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00593	c7 80 e4 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+740], 0

; 1724 : 
; 1725 : 	lpObj->m_TotalAttackTime = GetTickCount();

  0059d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  005a3	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005a6	89 81 f0 01 00
	00		 mov	 DWORD PTR [ecx+496], eax

; 1726 : 	lpObj->m_TotalAttackCount=0;

  005ac	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005af	c7 80 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+500], 0

; 1727 : 	lpObj->CheckSumTime		 = GetTickCount()+(1000*10);

  005b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  005bf	05 10 27 00 00	 add	 eax, 10000		; 00002710H
  005c4	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005c7	89 41 60	 mov	 DWORD PTR [ecx+96], eax

; 1728 : 	lpObj->CheckSumTableNum  = -1;

  005ca	83 c8 ff	 or	 eax, -1
  005cd	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005d0	66 89 41 5c	 mov	 WORD PTR [ecx+92], ax

; 1729 : 	
; 1730 : 	lpObj->m_SumLastAttackTime = 0;

  005d4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005d7	c7 80 d4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+468], 0

; 1731 : 	lpObj->m_DetectCount = 0;

  005e1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005e4	c7 80 d8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+472], 0

; 1732 : 	lpObj->m_DetectSpeedHackTime = 0;

  005ee	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005f1	c7 80 d0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+464], 0

; 1733 : 	lpObj->m_SpeedHackPenalty = 0;

  005fb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005fe	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+480], 0

; 1734 : 	lpObj->m_DetectedHackKickCount = 0;

  00608	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0060b	c7 80 dc 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+476], 0

; 1735 : 
; 1736 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 1737 : 	lpObj->m_Curse				= 0;
; 1738 : #endif
; 1739 : 
; 1740 : #if defined ( MODIFY_HACKLOG_OF_ATTACK_20050518 ) || defined ( MU_CHN_HACKLOG3_MODIFY_20041117 )
; 1741 : 	lpObj->dwPlayTime = GetTickCount();
; 1742 : #endif	
; 1743 : 
; 1744 : 	lpObj->IsInBattleGround = 0;

  00615	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00618	c6 80 7a 0e 00
	00 00		 mov	 BYTE PTR [eax+3706], 0

; 1745 : 	
; 1746 : 
; 1747 : 	lpObj->m_dwPKTimer = GetTickCount();

  0061f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00625	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00628	89 41 58	 mov	 DWORD PTR [ecx+88], eax

; 1748 : 	lpObj->CheckTickCount = 0;

  0062b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0062e	c6 40 48 00	 mov	 BYTE PTR [eax+72], 0

; 1749 : 
; 1750 : 	lpObj->m_AttackSpeedHackDetectedCount = 0;

  00632	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00635	c6 80 e4 01 00
	00 00		 mov	 BYTE PTR [eax+484], 0

; 1751 : 	
; 1752 : 	for( int n=0; n<MAXVIEWPORTOBJECT; n++)

  0063c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00643	eb 09		 jmp	 SHORT $LN4@gObjCharZe
$LN2@gObjCharZe:
  00645	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  00648	83 c0 01	 add	 eax, 1
  0064b	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjCharZe:
  0064e	83 7d f4 4b	 cmp	 DWORD PTR _n$1[ebp], 75	; 0000004bH
  00652	7d 44		 jge	 SHORT $LN3@gObjCharZe

; 1753 : 	{
; 1754 : 		lpObj->VpPlayer[n].state  = 0;

  00654	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00658	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0065b	c6 84 01 64 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+868], 0

; 1755 : 		lpObj->VpPlayer2[n].state = 0;

  00663	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00667	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0066a	c6 84 01 e8 06
	00 00 00	 mov	 BYTE PTR [ecx+eax+1768], 0

; 1756 : 		lpObj->VpPlayer[n].number = -1;

  00672	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00676	83 c9 ff	 or	 ecx, -1
  00679	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0067c	66 89 8c 02 66
	03 00 00	 mov	 WORD PTR [edx+eax+870], cx

; 1757 : 		lpObj->VpPlayer2[n].number = -1;

  00684	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00688	83 c9 ff	 or	 ecx, -1
  0068b	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0068e	66 89 8c 02 ea
	06 00 00	 mov	 WORD PTR [edx+eax+1770], cx

; 1758 : 	}

  00696	eb ad		 jmp	 SHORT $LN2@gObjCharZe
$LN3@gObjCharZe:

; 1759 : 	lpObj->GuildNumber = 0;

  00698	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0069b	c7 80 90 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+656], 0

; 1760 : 	lpObj->lpGuild     = NULL;

  006a5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006a8	c7 80 94 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+660], 0

; 1761 : 	lpObj->PartyNumber	= -1;

  006b2	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006b5	c7 80 88 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+648], -1

; 1762 : 	lpObj->PartyTargetUser = -1;

  006bf	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006c2	c7 80 8c 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+652], -1

; 1763 : 	lpObj->m_Drink		= 0;

  006cc	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006cf	c6 80 7c 02 00
	00 00		 mov	 BYTE PTR [eax+636], 0

; 1764 : 	lpObj->Authority    = 0;

  006d6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006d9	c7 80 a4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+420], 0

; 1765 : //	lpObj->AuthorityCode= 0;
; 1766 : 	lpObj->Penalty      = 0;

  006e3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006e6	c7 80 a8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+424], 0

; 1767 : 	lpObj->m_RecallMon  = -1;

  006f0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006f3	c7 80 a4 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+676], -1

; 1768 : 	lpObj->m_Change		= -1;

  006fd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00700	c7 80 a8 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+680], -1

; 1769 : 
; 1770 : #ifdef ADD_NEW_GUILD_01_20040913
; 1771 : 	lpObj->GuildStatus  = G_NONE;
; 1772 : #endif
; 1773 : 
; 1774 : #ifdef CHECK_ATTACK_AREA
; 1775 : 	lpObj->m_NotAttackAreaCount = 0;
; 1776 : #endif
; 1777 : 
; 1778 : #ifdef MODIFY_HACKLOG_OF_ATTACK_20050518
; 1779 : 	lpObj->m_NotAttackAreaCountFor10Min = 0;
; 1780 : #endif // MODIFY_HACKLOG_OF_ATTACK_20050518
; 1781 : 	
; 1782 : #ifdef FOR_BLOODCASTLE
; 1783 : 	lpObj->LastAttackerID = -1;

  0070a	83 c8 ff	 or	 eax, -1
  0070d	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00710	66 89 81 b2 02
	00 00		 mov	 WORD PTR [ecx+690], ax

; 1784 : #endif
; 1785 : 
; 1786 : #ifdef CHAOSCASTLE_SYSTEM_20040408
; 1787 : 	lpObj->m_cChaosCastleIndex = -1;

  00717	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0071a	c6 80 d9 0c 00
	00 ff		 mov	 BYTE PTR [eax+3289], -1

; 1788 : 	lpObj->m_cChaosCastleSubIndex = -1;

  00721	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00724	c6 80 da 0c 00
	00 ff		 mov	 BYTE PTR [eax+3290], -1

; 1789 : 	lpObj->m_iChaosCastleBlowTime = 0;

  0072b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0072e	c7 80 dc 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3292], 0

; 1790 : 	lpObj->m_cKillUserCount = 0;

  00738	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0073b	c6 80 e0 0c 00
	00 00		 mov	 BYTE PTR [eax+3296], 0

; 1791 : 	lpObj->m_cKillMonsterCount = 0;

  00742	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00745	c6 80 e1 0c 00
	00 00		 mov	 BYTE PTR [eax+3297], 0

; 1792 : #endif
; 1793 : 
; 1794 : 	lpObj->m_InWebzen	= 0;

  0074c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0074f	c6 80 e8 0e 00
	00 00		 mov	 BYTE PTR [eax+3816], 0

; 1795 : 
; 1796 : #ifdef ITEM_INDEX_EXTEND_20050706
; 1797 : 	memset(lpObj->CharSet, 0,MAX_PREVIEWCHARSET+9);
; 1798 : #else
; 1799 : #ifdef DARKLORD_WORK
; 1800 : 	memset(lpObj->CharSet, 0,MAX_PREVIEWCHARSET+4);

  00756	6a 0d		 push	 13			; 0000000dH
  00758	6a 00		 push	 0
  0075a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0075d	05 28 03 00 00	 add	 eax, 808		; 00000328H
  00762	50		 push	 eax
  00763	e8 00 00 00 00	 call	 _memset
  00768	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1801 : #else
; 1802 : 	memset(lpObj->CharSet, 0,MAX_PREVIEWCHARSET+3);
; 1803 : #endif
; 1804 : #endif
; 1805 : 	
; 1806 : 	for( i=0; i<MAXSELFDEFENSE; i++)

  0076b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00772	eb 09		 jmp	 SHORT $LN7@gObjCharZe
$LN5@gObjCharZe:
  00774	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00777	83 c0 01	 add	 eax, 1
  0077a	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@gObjCharZe:
  0077d	83 7d fc 07	 cmp	 DWORD PTR _i$[ebp], 7
  00781	7d 24		 jge	 SHORT $LN6@gObjCharZe

; 1807 : 	{
; 1808 : 		lpObj->SelfDefense[i]		= -1;

  00783	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00786	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00789	c7 84 81 40 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax*4+576], -1

; 1809 : 		lpObj->SelfDefenseTime[i]	= 0;

  00794	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00797	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0079a	c7 84 81 5c 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+604], 0

; 1810 : 	}

  007a5	eb cd		 jmp	 SHORT $LN5@gObjCharZe
$LN6@gObjCharZe:

; 1811 : 	lpObj->MySelfDefenseTime	= 0;

  007a7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007aa	c7 80 78 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+632], 0

; 1812 : 
; 1813 : 	lpObj->m_MagicDefense		= 0;

  007b4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007b7	c7 80 ec 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+748], 0

; 1814 : 
; 1815 : 	lpObj->m_SkillAttack2		= 0;

  007c1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007c4	c7 80 80 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+640], 0

; 1816 : 	lpObj->m_SkillAttackTime2	= 0;

  007ce	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007d1	c6 80 84 02 00
	00 00		 mov	 BYTE PTR [eax+644], 0

; 1817 : 
; 1818 : 	lpObj->LoadWareHouseInfo	= FALSE;

  007d8	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007db	c6 80 88 0e 00
	00 00		 mov	 BYTE PTR [eax+3720], 0

; 1819 : 
; 1820 : #ifdef NEW_SKILL_FORSKYLAND
; 1821 : 	lpObj->m_SkyBossMonSheildLinkIndex		= -1;

  007e2	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007e5	c7 80 c4 0e 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+3780], -1

; 1822 : 	lpObj->m_SkyBossMonSheild				= 0;

  007ef	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007f2	c7 80 c8 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3784], 0

; 1823 : 	lpObj->m_SkyBossMonSheildTime			= 0;

  007fc	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007ff	c7 80 cc 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3788], 0

; 1824 : #endif
; 1825 : 
; 1826 : #ifdef USER_DIE_MAKE_OPPOSIT_PK_20040329
; 1827 : 	lpObj->m_bAttackerKilled				= false;		//       

  00809	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0080c	c6 80 3c 02 00
	00 00		 mov	 BYTE PTR [eax+572], 0

; 1828 : #endif
; 1829 : 
; 1830 : 
; 1831 : #ifdef GAMESERVER_DIVISION	
; 1832 : 	lpObj->m_MoveOtherServer	 = 0;
; 1833 : #endif
; 1834 : 
; 1835 : 	lpObj->m_BossGoldDerconMapNumber = -1;

  00813	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00816	c6 80 e7 0e 00
	00 ff		 mov	 BYTE PTR [eax+3815], -1

; 1836 : 	
; 1837 : 	lpObj->TargetNumber			= 0;

  0081d	33 c0		 xor	 eax, eax
  0081f	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00822	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 1838 : 	lpObj->TargetShopNumber		= 0;

  00829	33 c0		 xor	 eax, eax
  0082b	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0082e	66 89 81 ae 02
	00 00		 mov	 WORD PTR [ecx+686], ax

; 1839 : 	lpObj->WarehouseMoney		= 0;

  00835	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00838	c7 80 a4 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3236], 0

; 1840 : 	lpObj->WarehouseSave	    = FALSE;

  00842	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00845	c7 80 a8 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3240], 0

; 1841 : 	lpObj->WarehouseLock        = 255;

  0084f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00852	c6 80 a0 0c 00
	00 ff		 mov	 BYTE PTR [eax+3232], 255 ; 000000ffH

; 1842 : 	lpObj->WarehouseCount		= 0;

  00859	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0085c	c6 80 9c 0c 00
	00 00		 mov	 BYTE PTR [eax+3228], 0

; 1843 : 	lpObj->WarehousePW			= 0;

  00863	33 c0		 xor	 eax, eax
  00865	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00868	66 89 81 9e 0c
	00 00		 mov	 WORD PTR [ecx+3230], ax

; 1844 : 
; 1845 : 	lpObj->WarehouseUnfailLock	= 0;

  0086f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00872	c6 80 a1 0c 00
	00 00		 mov	 BYTE PTR [eax+3233], 0

; 1846 : 
; 1847 : 	lpObj->m_bDevilSquareAuth	= FALSE;

  00879	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0087c	c6 80 d1 0c 00
	00 00		 mov	 BYTE PTR [eax+3281], 0

; 1848 : 
; 1849 : 	lpObj->m_TimeCount			 = 0;

  00883	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00886	c6 40 54 00	 mov	 BYTE PTR [eax+84], 0

; 1850 : 
; 1851 : 	lpObj->EventChipCount = 0;

  0088a	33 c0		 xor	 eax, eax
  0088c	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0088f	66 89 81 7c 0e
	00 00		 mov	 WORD PTR [ecx+3708], ax

; 1852 : 	lpObj->MutoNumber = 0;

  00896	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00899	c7 80 80 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3712], 0

; 1853 : 
; 1854 : 	lpObj->HaveWeaponInHand = 0;

  008a3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008a6	c6 80 7b 0e 00
	00 00		 mov	 BYTE PTR [eax+3707], 0

; 1855 : 
; 1856 : #ifdef WAREHOUSE_ITEMCOPY_BUG_FIX	
; 1857 : 	lpObj->m_ReqWarehouseOpen = 0;

  008ad	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008b0	c6 80 24 0f 00
	00 00		 mov	 BYTE PTR [eax+3876], 0

; 1858 : #endif
; 1859 : 
; 1860 : #ifdef FOR_STONE_EXCHANGE
; 1861 : 	lpObj->iStoneCount = 0;

  008b7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008ba	c7 80 8c 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3724], 0

; 1862 : #endif
; 1863 : 
; 1864 : #ifdef DUEL_SYSTEM_20031028
; 1865 : 	lpObj->m_iDuelUserReserved = -1;

  008c4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008c7	c7 80 e4 0c 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+3300], -1

; 1866 : 	lpObj->m_iDuelUserRequested = -1;

  008d1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008d4	c7 80 e8 0c 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+3304], -1

; 1867 : 	lpObj->m_iDuelUser = -1;

  008de	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008e1	c7 80 ec 0c 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+3308], -1

; 1868 : 	lpObj->m_btDuelScore = 0;

  008eb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008ee	c6 80 f0 0c 00
	00 00		 mov	 BYTE PTR [eax+3312], 0

; 1869 : #endif
; 1870 : 
; 1871 : #ifdef DUEL_SYSTEM_FIX_20031224
; 1872 : 	lpObj->m_iDuelTickCount = 0;

  008f5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008f8	c7 80 f4 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3316], 0

; 1873 : #endif
; 1874 : 
; 1875 : #ifdef NEW_FORSKYLAND2	
; 1876 : 	lpObj->m_MaxLifePower  = 0;

  00902	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00905	c7 80 d0 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3792], 0

; 1877 : 
; 1878 : 	lpObj->m_PacketChecksumTime = 0;

  0090f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00912	c7 80 d4 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3796], 0

; 1879 : 	lpObj->AddBP	=  0;	

  0091c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0091f	c7 80 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+240], 0

; 1880 : 	lpObj->m_CheckLifeTime = 0;

  00929	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0092c	c7 80 d8 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3800], 0

; 1881 : #endif
; 1882 : 
; 1883 : #ifdef NEW_SKILL_FORSKYLAND
; 1884 : 	memset(lpObj->m_Quest, 0xff, MAX_DBQUEST);

  00936	6a 32		 push	 50			; 00000032H
  00938	68 ff 00 00 00	 push	 255			; 000000ffH
  0093d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00940	05 90 0e 00 00	 add	 eax, 3728		; 00000e90H
  00945	50		 push	 eax
  00946	e8 00 00 00 00	 call	 _memset
  0094b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1885 : 	lpObj->m_SendQuestInfo = FALSE;

  0094e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00951	c6 80 c2 0e 00
	00 00		 mov	 BYTE PTR [eax+3778], 0

; 1886 : #endif
; 1887 : 
; 1888 : #ifdef APPLY_PACKETCHECKSUM
; 1889 : 	gPacketCheckSum.ClearCheckSum(lpObj->m_Index);

  00958	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0095b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0095d	51		 push	 ecx
  0095e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gPacketCheckSum@@3VCPacketCheckSum@@A ; gPacketCheckSum
  00963	e8 00 00 00 00	 call	 ?ClearCheckSum@CPacketCheckSum@@QAEXH@Z ; CPacketCheckSum::ClearCheckSum

; 1890 : #endif
; 1891 : 	
; 1892 : #ifdef NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_25_20060123
; 1893 : 	lpObj->NPggCSAuth.Init();
; 1894 : 	lpObj->m_bSentGGAuth = false;
; 1895 : 	lpObj->m_bSentGGAuthAgain = false;
; 1896 : #else
; 1897 : 	#ifdef NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_10_20050411
; 1898 : 		lpObj->NPggCSAuth.Init();
; 1899 : 		lpObj->m_NPggCheckSum = 0;	
; 1900 : 
; 1901 : 	#elif defined NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_20_20050411
; 1902 : 		lpObj->NPggCSAuth.Init();
; 1903 : 		lpObj->m_bSentGGAuth = false;
; 1904 : 
; 1905 : 	#endif // NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_10_20050411 || NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_20_20050411
; 1906 : #endif // NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_25_20060123
; 1907 : 
; 1908 : 	lpObj->m_NPggCheckSumSendTime = 0;

  00968	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0096b	c7 80 f8 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3832], 0

; 1909 : 
; 1910 : #ifdef SECOND_QUEST
; 1911 : 	lpObj->PlusStatQuestClear = 0;

  00975	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00978	c6 80 8c 00 00
	00 00		 mov	 BYTE PTR [eax+140], 0

; 1912 : 	lpObj->ComboSkillquestClear = 0;

  0097f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00982	c6 80 8d 00 00
	00 00		 mov	 BYTE PTR [eax+141], 0

; 1913 : #endif
; 1914 : 
; 1915 : 
; 1916 : 	lpObj->m_LastTeleportTime = 0;

  00989	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0098c	c6 80 e9 0e 00
	00 00		 mov	 BYTE PTR [eax+3817], 0

; 1917 : 	lpObj->m_ClientHackLogCount = 0;

  00993	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00996	c6 80 ea 0e 00
	00 00		 mov	 BYTE PTR [eax+3818], 0

; 1918 : 
; 1919 : 	lpObj->UseEventServer = 0;

  0099d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009a0	c7 80 84 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3716], 0

; 1920 : 
; 1921 : #ifdef UPGRADE_GAMESERVER_01_20041006
; 1922 : 	//    .
; 1923 : 	if( lpObj->Type == OBJTYPE_CHARACTER )

  009aa	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009ad	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  009b1	83 f9 01	 cmp	 ecx, 1
  009b4	75 32		 jne	 SHORT $LN35@gObjCharZe

; 1924 : 	{
; 1925 : 		memset(lpObj->pWarehouseMap, 0xFF, MAX_WAREHOUSEITEMS);

  009b6	6a 78		 push	 120			; 00000078H
  009b8	68 ff 00 00 00	 push	 255			; 000000ffH
  009bd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009c0	8b 88 98 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3224]
  009c6	51		 push	 ecx
  009c7	e8 00 00 00 00	 call	 _memset
  009cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1926 : 		memset(lpObj->TradeMap, 0xFF, MAX_TRADEITEM);

  009cf	6a 20		 push	 32			; 00000020H
  009d1	68 ff 00 00 00	 push	 255			; 000000ffH
  009d6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009d9	8b 88 88 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3208]
  009df	51		 push	 ecx
  009e0	e8 00 00 00 00	 call	 _memset
  009e5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN35@gObjCharZe:

; 1927 : 	}
; 1928 : #else
; 1929 : 	memset(lpObj->pWarehouseMap, 0xFF, MAX_WAREHOUSEITEMS);
; 1930 : 	memset(lpObj->TradeMap, 0xFF, MAX_TRADEITEM);
; 1931 : #endif
; 1932 : 
; 1933 : 	for( i=0; i<MAX_MAGIC; i++) lpObj->Magic[i].Clear();

  009e8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  009ef	eb 09		 jmp	 SHORT $LN10@gObjCharZe
$LN8@gObjCharZe:
  009f1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  009f4	83 c0 01	 add	 eax, 1
  009f7	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN10@gObjCharZe:
  009fa	83 7d fc 3c	 cmp	 DWORD PTR _i$[ebp], 60	; 0000003cH
  009fe	7d 16		 jge	 SHORT $LN9@gObjCharZe
  00a00	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00a03	c1 e1 04	 shl	 ecx, 4
  00a06	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a09	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  00a0f	e8 00 00 00 00	 call	 ?Clear@CMagicInf@@QAEXXZ ; CMagicInf::Clear
  00a14	eb db		 jmp	 SHORT $LN8@gObjCharZe
$LN9@gObjCharZe:

; 1934 : 
; 1935 : 	lpObj->MagicCount   = 0;

  00a16	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a19	c6 80 14 03 00
	00 00		 mov	 BYTE PTR [eax+788], 0

; 1936 : 	
; 1937 : 	for( i=0; i<MAXMESSAGE; i++)

  00a20	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00a27	eb 09		 jmp	 SHORT $LN13@gObjCharZe
$LN11@gObjCharZe:
  00a29	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00a2c	83 c0 01	 add	 eax, 1
  00a2f	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN13@gObjCharZe:
  00a32	83 7d fc 0a	 cmp	 DWORD PTR _i$[ebp], 10	; 0000000aH
  00a36	7d 1a		 jge	 SHORT $LN12@gObjCharZe

; 1938 : 	{
; 1939 : 		gSMMsg[aIndex][i].MsgCode = -1;

  00a38	69 45 08 a0 00
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 160
  00a3f	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00a42	c1 e1 04	 shl	 ecx, 4
  00a45	c7 84 08 00 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+ecx], -1

; 1940 : 	}

  00a50	eb d7		 jmp	 SHORT $LN11@gObjCharZe
$LN12@gObjCharZe:

; 1941 : 
; 1942 : #ifdef MONSTER_HERD_SYSTEM_20031120
; 1943 : 	lpObj->m_bIsInMonsterHerd = false;

  00a52	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a55	c7 80 ec 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3820], 0

; 1944 : 	lpObj->m_bIsMonsterAttackFirst = true;

  00a5f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a62	c7 80 f0 0e 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+3824], 1

; 1945 : 	lpObj->m_lpMonsterHerd = NULL;

  00a6c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a6f	c7 80 f4 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3828], 0

; 1946 : #endif
; 1947 : 
; 1948 : #ifdef ADD_SKILL_WITH_COMBO	
; 1949 : 	if( aIndex-ALLOC_USEROBJECTSTART >= 0 )

  00a79	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a7c	2d 00 19 00 00	 sub	 eax, 6400		; 00001900H
  00a81	78 37		 js	 SHORT $LN15@gObjCharZe

; 1950 : 	{
; 1951 : 		for( i=0; i<MAXATTACKMESSAGE; i++)

  00a83	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00a8a	eb 09		 jmp	 SHORT $LN16@gObjCharZe
$LN14@gObjCharZe:
  00a8c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00a8f	83 c0 01	 add	 eax, 1
  00a92	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN16@gObjCharZe:
  00a95	83 7d fc 32	 cmp	 DWORD PTR _i$[ebp], 50	; 00000032H
  00a99	7d 1f		 jge	 SHORT $LN15@gObjCharZe

; 1952 : 		{
; 1953 : 			gSMAttackProcMsg[aIndex-ALLOC_USEROBJECTSTART][i].MsgCode = -1;

  00a9b	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a9e	2d 00 19 00 00	 sub	 eax, 6400		; 00001900H
  00aa3	69 c8 e8 03 00
	00		 imul	 ecx, eax, 1000
  00aa9	6b 55 fc 14	 imul	 edx, DWORD PTR _i$[ebp], 20
  00aad	c7 84 11 00 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[ecx+edx], -1

; 1954 : 		}

  00ab8	eb d2		 jmp	 SHORT $LN14@gObjCharZe
$LN15@gObjCharZe:

; 1955 : 	}
; 1956 : 
; 1957 : 	lpObj->SkillHellFire2State = FALSE;

  00aba	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00abd	c6 80 1c 0f 00
	00 00		 mov	 BYTE PTR [eax+3868], 0

; 1958 : 	lpObj->SkillHellFire2Count = 0;

  00ac4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ac7	c6 80 1d 0f 00
	00 00		 mov	 BYTE PTR [eax+3869], 0

; 1959 : 	
; 1960 : 	lpObj->m_PoisonType	= 0;

  00ace	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ad1	c6 80 21 02 00
	00 00		 mov	 BYTE PTR [eax+545], 0

; 1961 : 	lpObj->m_IceType	= 0;

  00ad8	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00adb	c6 80 22 02 00
	00 00		 mov	 BYTE PTR [eax+546], 0

; 1962 : #endif	
; 1963 : 
; 1964 : #ifdef DARKLORD_WORK		
; 1965 : 	lpObj->Leadership = 0;

  00ae2	33 c0		 xor	 eax, eax
  00ae4	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00ae7	66 89 81 d8 00
	00 00		 mov	 WORD PTR [ecx+216], ax

; 1966 : 	lpObj->AddLeadership = 0;

  00aee	33 c0		 xor	 eax, eax
  00af0	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00af3	66 89 81 da 00
	00 00		 mov	 WORD PTR [ecx+218], ax

; 1967 : 	lpObj->ChatLitmitTime = 0;

  00afa	33 c0		 xor	 eax, eax
  00afc	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00aff	66 89 81 dc 00
	00 00		 mov	 WORD PTR [ecx+220], ax

; 1968 : 	lpObj->ChatLimitTimeSec = 0;

  00b06	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b09	c6 80 de 00 00
	00 00		 mov	 BYTE PTR [eax+222], 0

; 1969 : 
; 1970 : 	lpObj->SkillRecallParty_Time = 0;

  00b10	33 c0		 xor	 eax, eax
  00b12	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b15	66 89 81 7c 10
	00 00		 mov	 WORD PTR [ecx+4220], ax

; 1971 : 	lpObj->SkillLongSpearChange = FALSE;

  00b1c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b1f	c6 80 82 10 00
	00 00		 mov	 BYTE PTR [eax+4226], 0

; 1972 : 	lpObj->SkillDelay.Init();

  00b26	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b29	81 c1 84 10 00
	00		 add	 ecx, 4228		; 00001084H
  00b2f	e8 00 00 00 00	 call	 ?Init@CSkillDelay@@QAEXXZ ; CSkillDelay::Init

; 1973 : #endif
; 1974 : 
; 1975 : #ifdef HAPPY_POUCH	// apple20050203
; 1976 : 	lpObj->m_btLifeInc	= 0;
; 1977 : 	lpObj->m_lLifeIncTime	= 0;
; 1978 : 	lpObj->m_dwLastCheckTick = 0;
; 1979 : 	lpObj->m_lFreeKalimaTime = 0;
; 1980 : #endif
; 1981 : 
; 1982 : #ifdef BLOCK_INVALID_CHARACTER_DELETE_01_20060327
; 1983 : 	lpObj->bEnableDelCharacter = TRUE;

  00b34	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b37	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1

; 1984 : #endif
; 1985 : 	
; 1986 : #ifdef UPGRADE_GAMESERVER_01_20041006
; 1987 : 	//    .
; 1988 : 	if( lpObj->Type == OBJTYPE_CHARACTER )

  00b3e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b41	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00b45	83 f9 01	 cmp	 ecx, 1
  00b48	75 2f		 jne	 SHORT $LN18@gObjCharZe

; 1989 : #endif
; 1990 : 	for( i=0; i<MAX_WAREHOUSEITEMS; i++)	lpObj->pWarehouse[i].Clear();

  00b4a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00b51	eb 09		 jmp	 SHORT $LN19@gObjCharZe
$LN17@gObjCharZe:
  00b53	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00b56	83 c0 01	 add	 eax, 1
  00b59	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN19@gObjCharZe:
  00b5c	83 7d fc 78	 cmp	 DWORD PTR _i$[ebp], 120	; 00000078H
  00b60	7d 17		 jge	 SHORT $LN18@gObjCharZe
  00b62	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 168
  00b69	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b6c	03 88 94 0c 00
	00		 add	 ecx, DWORD PTR [eax+3220]
  00b72	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  00b77	eb da		 jmp	 SHORT $LN17@gObjCharZe
$LN18@gObjCharZe:

; 1991 : 
; 1992 : #ifdef CHECK_PENETRATION_SKILL	
; 1993 : 	gMultiAttackHackCheck[aIndex].Init();

  00b79	69 4d 08 58 28
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 10328
  00b80	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gMultiAttackHackCheck@@3PAVCMultiAttackHackCheck@@A ; gMultiAttackHackCheck
  00b86	e8 00 00 00 00	 call	 ?Init@CMultiAttackHackCheck@@QAEXXZ ; CMultiAttackHackCheck::Init

; 1994 : #endif
; 1995 : 	
; 1996 : 	lpObj->pTransaction = FALSE;

  00b8b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b8e	c6 80 68 0c 00
	00 00		 mov	 BYTE PTR [eax+3176], 0

; 1997 : 	gObjMonsterHitDamageInit(lpObj);

  00b95	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b98	50		 push	 eax
  00b99	e8 00 00 00 00	 call	 ?gObjMonsterHitDamageInit@@YAXPAVOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageInit
  00b9e	83 c4 04	 add	 esp, 4

; 1998 : 	gObjSetInventory1Pointer(&gObj[aIndex]);

  00ba1	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00ba8	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bae	50		 push	 eax
  00baf	e8 00 00 00 00	 call	 ?gObjSetInventory1Pointer@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer
  00bb4	83 c4 04	 add	 esp, 4

; 1999 : #ifdef PERSONAL_SHOP_20040113
; 2000 : 	
; 2001 : #ifdef UPGRADE_GAMESERVER_01_20041006
; 2002 : 	//     .
; 2003 : 	if( lpObj->Type == OBJTYPE_CHARACTER )

  00bb7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bba	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00bbe	83 f9 01	 cmp	 ecx, 1
  00bc1	75 19		 jne	 SHORT $LN38@gObjCharZe

; 2004 : #endif
; 2005 : 	#ifdef PERSONAL_SHOP_BUG_FIX
; 2006 : 		memset(lpObj->pInventoryMap, 0xFF, MAX_INVENTORYMAP + MAX_PSHOPITEM);

  00bc3	6a 60		 push	 96			; 00000060H
  00bc5	68 ff 00 00 00	 push	 255			; 000000ffH
  00bca	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bcd	8b 88 60 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3168]
  00bd3	51		 push	 ecx
  00bd4	e8 00 00 00 00	 call	 _memset
  00bd9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN38@gObjCharZe:

; 2007 : 	#else
; 2008 : 		memset(lpObj->pInventoryMap, 0xFF, MAX_INVENTORY + MAX_PSHOPITEM);
; 2009 : 	#endif
; 2010 : 
; 2011 : 	lpObj->m_bPShopOpen = false;											//   

  00bdc	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bdf	c6 80 f8 0c 00
	00 00		 mov	 BYTE PTR [eax+3320], 0

; 2012 : 	lpObj->m_bPShopTransaction = false;										//  

  00be6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00be9	c6 80 f9 0c 00
	00 00		 mov	 BYTE PTR [eax+3321], 0

; 2013 : 	lpObj->m_bPShopItemChange = false;										//        (  )

  00bf0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bf3	c6 80 fa 0c 00
	00 00		 mov	 BYTE PTR [eax+3322], 0

; 2014 : 	lpObj->m_bPShopRedrawAbs = false;										//      

  00bfa	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bfd	c6 80 fb 0c 00
	00 00		 mov	 BYTE PTR [eax+3323], 0

; 2015 : 	memset(lpObj->m_szPShopText, 0, MAX_PSHOP_TEXT);						//  

  00c04	6a 24		 push	 36			; 00000024H
  00c06	6a 00		 push	 0
  00c08	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c0b	05 fc 0c 00 00	 add	 eax, 3324		; 00000cfcH
  00c10	50		 push	 eax
  00c11	e8 00 00 00 00	 call	 _memset
  00c16	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2016 : 	
; 2017 : 	lpObj->m_bPShopWantDeal = false;										//       

  00c19	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c1c	c6 80 20 0d 00
	00 00		 mov	 BYTE PTR [eax+3360], 0

; 2018 : 	lpObj->m_iPShopDealerIndex = -1;										//      

  00c23	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c26	c7 80 24 0d 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+3364], -1

; 2019 : 	memset(lpObj->m_szPShopDealerName, 0x00, MAX_IDSTRING);					//      

  00c30	6a 0a		 push	 10			; 0000000aH
  00c32	6a 00		 push	 0
  00c34	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c37	05 28 0d 00 00	 add	 eax, 3368		; 00000d28H
  00c3c	50		 push	 eax
  00c3d	e8 00 00 00 00	 call	 _memset
  00c42	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2020 : 
; 2021 : 	memset(lpObj->m_iVpPShopPlayer, 0, sizeof(lpObj->m_iVpPShopPlayer));	//   

  00c45	68 2c 01 00 00	 push	 300			; 0000012cH
  00c4a	6a 00		 push	 0
  00c4c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c4f	05 4c 0d 00 00	 add	 eax, 3404		; 00000d4cH
  00c54	50		 push	 eax
  00c55	e8 00 00 00 00	 call	 _memset
  00c5a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2022 : 	lpObj->m_wVpPShopPlayerCount = 0;										//  

  00c5d	33 c0		 xor	 eax, eax
  00c5f	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c62	66 89 81 78 0e
	00 00		 mov	 WORD PTR [ecx+3704], ax

; 2023 : #else
; 2024 : 	memset(lpObj->pInventoryMap, 0xFF, 8*8);
; 2025 : #endif
; 2026 : 
; 2027 : #ifdef ADD_NEW_UNION_01_20041006
; 2028 : 	lpObj->iGuildUnionTimeStamp = 0;
; 2029 : #endif
; 2030 : 
; 2031 : 	gObjCharTradeClear(lpObj);

  00c69	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c6c	50		 push	 eax
  00c6d	e8 00 00 00 00	 call	 ?gObjCharTradeClear@@YAXPAVOBJECTSTRUCT@@@Z ; gObjCharTradeClear
  00c72	83 c4 04	 add	 esp, 4

; 2032 : 
; 2033 : #ifdef UPGRADE_GAMESERVER_01_20041006
; 2034 : 	//  , ,    . 
; 2035 : 	if( lpObj->Type == OBJTYPE_CHARACTER )

  00c75	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c78	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00c7c	83 f9 01	 cmp	 ecx, 1
  00c7f	0f 85 bc 00 00
	00		 jne	 $LN30@gObjCharZe

; 2036 : 	{
; 2037 : #endif //UPGRADE_GAMESERVER_01_20041006
; 2038 : 
; 2039 : 	for( i=0; i<MAX_WAREHOUSEITEMS; i++)	lpObj->pWarehouse[i].Clear();	

  00c85	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00c8c	eb 09		 jmp	 SHORT $LN22@gObjCharZe
$LN20@gObjCharZe:
  00c8e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00c91	83 c0 01	 add	 eax, 1
  00c94	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN22@gObjCharZe:
  00c97	83 7d fc 78	 cmp	 DWORD PTR _i$[ebp], 120	; 00000078H
  00c9b	7d 17		 jge	 SHORT $LN21@gObjCharZe
  00c9d	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 168
  00ca4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ca7	03 88 94 0c 00
	00		 add	 ecx, DWORD PTR [eax+3220]
  00cad	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  00cb2	eb da		 jmp	 SHORT $LN20@gObjCharZe
$LN21@gObjCharZe:

; 2040 : #ifdef PERSONAL_SHOP_20040113
; 2041 : 	for( i=0; i<MAX_INVENTORY_EXTEND; i++ )	lpObj->Inventory1[i].Clear();

  00cb4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00cbb	eb 09		 jmp	 SHORT $LN25@gObjCharZe
$LN23@gObjCharZe:
  00cbd	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00cc0	83 c0 01	 add	 eax, 1
  00cc3	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN25@gObjCharZe:
  00cc6	83 7d fc 6c	 cmp	 DWORD PTR _i$[ebp], 108	; 0000006cH
  00cca	7d 17		 jge	 SHORT $LN24@gObjCharZe
  00ccc	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 168
  00cd3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cd6	03 88 6c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3180]
  00cdc	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  00ce1	eb da		 jmp	 SHORT $LN23@gObjCharZe
$LN24@gObjCharZe:

; 2042 : 	for( i=0; i<MAX_INVENTORY_EXTEND; i++ )	lpObj->Inventory2[i].Clear();

  00ce3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00cea	eb 09		 jmp	 SHORT $LN28@gObjCharZe
$LN26@gObjCharZe:
  00cec	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00cef	83 c0 01	 add	 eax, 1
  00cf2	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN28@gObjCharZe:
  00cf5	83 7d fc 6c	 cmp	 DWORD PTR _i$[ebp], 108	; 0000006cH
  00cf9	7d 17		 jge	 SHORT $LN27@gObjCharZe
  00cfb	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 168
  00d02	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d05	03 88 78 0c 00
	00		 add	 ecx, DWORD PTR [eax+3192]
  00d0b	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  00d10	eb da		 jmp	 SHORT $LN26@gObjCharZe
$LN27@gObjCharZe:

; 2043 : #else
; 2044 : 	for( i=0; i<MAX_INVENTORY;		i++ )	lpObj->Inventory1[i].Clear();
; 2045 : 	for( i=0; i<MAX_INVENTORY;		i++ )	lpObj->Inventory2[i].Clear();
; 2046 : #endif	
; 2047 : 	for( i=0; i<MAX_TRADEITEM;	    i++)    lpObj->Trade[i].Clear();

  00d12	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00d19	eb 09		 jmp	 SHORT $LN31@gObjCharZe
$LN29@gObjCharZe:
  00d1b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00d1e	83 c0 01	 add	 eax, 1
  00d21	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN31@gObjCharZe:
  00d24	83 7d fc 20	 cmp	 DWORD PTR _i$[ebp], 32	; 00000020H
  00d28	7d 17		 jge	 SHORT $LN30@gObjCharZe
  00d2a	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _i$[ebp], 168
  00d31	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d34	03 88 84 0c 00
	00		 add	 ecx, DWORD PTR [eax+3204]
  00d3a	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  00d3f	eb da		 jmp	 SHORT $LN29@gObjCharZe
$LN30@gObjCharZe:

; 2048 : 	//for( i=0; i<MAX_CHAOSBOXSIZE;	i++ )	lpObj->pChaosBox[i].Clear();
; 2049 : 
; 2050 : #ifdef UPGRADE_GAMESERVER_01_20041006
; 2051 : 	}
; 2052 : #endif //UPGRADE_GAMESERVER_01_20041006
; 2053 : 
; 2054 : 
; 2055 : #ifdef CHAOS_MIX_TRANSACTION_BUXFIX_20040610
; 2056 : 	lpObj->bIsChaosMixCompleted			= false;	//      (1) /   (0)  

  00d41	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d44	c6 80 81 10 00
	00 00		 mov	 BYTE PTR [eax+4225], 0

; 2057 : #endif
; 2058 : 	
; 2059 : #ifdef MAP_SERVER_WORK_20041030						//     
; 2060 : 	lpObj->m_bMapSvrMoveQuit			= false;
; 2061 : #endif
; 2062 : #ifdef	CASTLE_MAIN_SCHEDULER_20041111
; 2063 : 	//  NPC  
; 2064 : 	lpObj->m_iCsNpcExistVal				= 0;
; 2065 : 	lpObj->m_btCsNpcType				= 0;		// CS_NPC_TYPE_NONE
; 2066 : 	lpObj->m_btCsGateOpen				= 0;		// CS_GATE_STATE_CLOSED
; 2067 : 	lpObj->m_iCsGateLeverLinkIndex		= -1;
; 2068 : 	
; 2069 : 	lpObj->m_btCsNpcDfLevel				= 0;
; 2070 : 	lpObj->m_btCsNpcRgLevel				= 0;
; 2071 : 	//    
; 2072 : 	lpObj->m_btCsJoinSide				= 0;		// CS_SIEGESIDE_NONE
; 2073 : 	lpObj->m_bCsGuildInvolved			= 0;
; 2074 : #endif
; 2075 : 
; 2076 : #ifdef MODIFY_CASTLE_NPC_UPGRADE_PROCESS_20060619
; 2077 : 	lpObj->m_bIsCastleNPCUpgradeCompleted	= false;	//  NPC  .
; 2078 : #endif
; 2079 : 
; 2080 : #ifdef ADD_NEW_WEAPON_FOR_CASTLE_01_20041116
; 2081 : 	//   
; 2082 : 	lpObj->m_btWeaponState				= WEAPON_STATE_NORMAL;
; 2083 : #endif
; 2084 : #ifdef ADD_NEW_SKILL_FOR_CASTLE_01_20041116
; 2085 : 	//      
; 2086 : 	lpObj->m_btKillCount				= 0;
; 2087 : #endif
; 2088 : #ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116
; 2089 : 	lpObj->m_iAccumulatedDamage			= 0;		//  
; 2090 : #endif
; 2091 : #ifdef CASTLE_NPC_LIFESTONE_WORK_20041208
; 2092 : 	lpObj->m_iCreatedActivationTime		= 0;		//     
; 2093 : 	lpObj->m_btLifeStoneCount			= 0;		//     
; 2094 : #endif
; 2095 : 	
; 2096 : #ifdef MODIFY_CASTLESIEGE_CALC_CROWN_ACCESSTIME_20051014
; 2097 : 	lpObj->m_iAccumulatedCrownAccessTime = 0;

  00d4b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d4e	c7 80 ec 19 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6636], 0

; 2098 : #endif
; 2099 : 
; 2100 : #ifdef ADD_NEW_MONSTER_SYSTEM_01_20050714
; 2101 : 	lpObj->m_MonsterSkillElementInfo.Reset();		//      
; 2102 : #endif
; 2103 : 	
; 2104 : #ifdef ADD_ANTI_HACK_01_20051027
; 2105 : 	// PACKET_ATTACKET    
; 2106 : 	lpObj->m_dwLastPacketAttackTime = 0;
; 2107 : #endif
; 2108 : 
; 2109 : #ifdef CRYWOLF_MVP_REWARD_RANK_20051215
; 2110 : 	lpObj->m_iCrywolfMVPScore = 0;
; 2111 : #endif
; 2112 : 	
; 2113 : #ifdef MODIFY_SKILL_CHECK_DISTANCE_UPDATE_20060417
; 2114 : 	lpObj->m_iSkillDistanceErrorCount = 0;

  00d58	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d5b	c7 80 38 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6712], 0

; 2115 : #endif	//MODIFY_SKILL_CHECK_DISTANCE_UPDATE_20060417
; 2116 : 	
; 2117 : #ifdef MODIFY_SKILL_CHECK_DISTANCE_UPDATE_02_20060421
; 2118 : 	lpObj->m_dwSkillDistanceErrorTick = 0;

  00d65	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d68	c7 80 3c 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6716], 0

; 2119 : #endif // MODIFY_SKILL_CHECK_DISTANCE_UPDATE_02_20060421
; 2120 : 
; 2121 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 2122 : 	g_kJewelOfHarmonySystem.InitEffectValue( &lpObj->m_JewelOfHarmonyEffect );		//        
; 2123 : #endif	// ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 2124 : 
; 2125 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 2126 : 	g_kItemSystemFor380.InitEffectValue( &lpObj->m_ItemOptionExFor380 );			// 380    
; 2127 : #endif // ADD_380ITEM_NEWOPTION_20060711
; 2128 : 
; 2129 : #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 2130 : 	g_SocketOptionSystem.ClearUserData( lpObj );
; 2131 : #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 2132 : 
; 2133 : #ifdef ADD_NEW_NPC_KANTURU_20060612
; 2134 : 	lpObj->m_bKanturuEntranceByNPC		= 0;
; 2135 : #endif
; 2136 : 	
; 2137 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//     
; 2138 : 	lpObj->m_iIllusionTempleIndex	= -1;
; 2139 : #endif
; 2140 : 
; 2141 : #ifdef MODIFY_QUEST_SYSTEM_20070525	// 3    
; 2142 : 	lpObj->m_bQuestMonKillDBLoad	= FALSE;
; 2143 : 	lpObj->m_iQuestMonKillDBIndex	= -1;		//  -1 (0   )
; 2144 : 	
; 2145 : 	for( i = 0; i < MAX_QUEST_MONSTER_KILL_INFO; i++ )
; 2146 : 	{
; 2147 : 		lpObj->m_QuestMonKillInfo[i].iQuestMonIndex	= -1;
; 2148 : 		lpObj->m_QuestMonKillInfo[i].iKillCount		= -1;
; 2149 : 	}
; 2150 : #endif
; 2151 : 
; 2152 : #ifdef MODIFY_0708_BUFFIX_20070820
; 2153 : 	lpObj->m_bSkillKeyRecv			= FALSE;

  00d72	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d75	c7 80 40 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6720], 0

; 2154 : #endif
; 2155 : 	
; 2156 : #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122	//    
; 2157 : 	g_MasterSkillSystem.InitPassiveSkillData( lpObj );
; 2158 : #endif
; 2159 : 	
; 2160 : #ifdef MODIFY_SEASON4_UPDATE_BUGFIX_02_20080804
; 2161 : 	lpObj->m_btRefillHPSocketOption = 0;
; 2162 : 	lpObj->m_btRefillMPSocketOption = 0;
; 2163 : 	lpObj->m_wSocketOptionMonsterDieGetHp		= 0;
; 2164 : 	lpObj->m_wSocketOptionMonsterDieGetMana		= 0;
; 2165 : #endif // MODIFY_SEASON4_UPDATE_BUGFIX_02_20080804
; 2166 : 
; 2167 : #ifdef MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 2168 : 	lpObj->m_btAGReduceRate = 0;
; 2169 : #endif // MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 2170 : 
; 2171 : #ifdef ADD_MAPMOVE_PROTOCOL_20090327
; 2172 : 	lpObj->m_dwMapMoveKeyValue = 0;
; 2173 : #endif // ADD_MAPMOVE_PROTOCOL_20090327
; 2174 : 
; 2175 : #ifdef GMCOMMAND_EX
; 2176 : 	lpObj->m_bGMSummon = FALSE;

  00d7f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d82	c6 80 5c 1a 00
	00 00		 mov	 BYTE PTR [eax+6748], 0

; 2177 : #endif // GMCOMMAND_EX
; 2178 : 
; 2179 : #ifdef ADD_HACKING_TOOL_BLOCK_20090311
; 2180 : 	for( i = 0 ; i < MAX_HACKTOOL_LIST ; i++ )
; 2181 : 	{
; 2182 : 		lpObj->m_dwUseHacktoolList[i] = KEY_VALUE_NOT_USE;
; 2183 : 	}
; 2184 : #endif // ADD_HACKING_TOOL_BLOCK_20090311
; 2185 : 
; 2186 : 	lpObj->m_AccountType = 0;

  00d89	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d8c	c6 80 5d 1a 00
	00 00		 mov	 BYTE PTR [eax+6749], 0

; 2187 : 	lpObj->m_EndTime = 0;

  00d93	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d96	c7 80 60 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6752], 0
  00da0	c7 80 64 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6756], 0

; 2188 : 	lpObj->m_bVIPReload = false;

  00daa	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dad	c6 80 75 1a 00
	00 00		 mov	 BYTE PTR [eax+6773], 0

; 2189 : 
; 2190 : 	lpObj->m_bResetState = false;

  00db4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00db7	c6 80 76 1a 00
	00 00		 mov	 BYTE PTR [eax+6774], 0

; 2191 : 	lpObj->m_iResetNumber = -1;

  00dbe	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dc1	c7 80 78 1a 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+6776], -1

; 2192 : 	lpObj->m_bReqUpdateReset = false;

  00dcb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dce	c6 80 7c 1a 00
	00 00		 mov	 BYTE PTR [eax+6780], 0

; 2193 : 
; 2194 : 	lpObj->m_bShell = false;

  00dd5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dd8	c6 80 7d 1a 00
	00 00		 mov	 BYTE PTR [eax+6781], 0

; 2195 : 	lpObj->m_stateEngagePVP = PVP_USER_NONE;

  00ddf	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00de2	c7 80 80 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6784], 0

; 2196 : 	lpObj->m_bBuffHelper = false;

  00dec	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00def	c6 80 84 1a 00
	00 00		 mov	 BYTE PTR [eax+6788], 0

; 2197 : 
; 2198 : 	//DevGamesX 01/05/2018 - OffExp
; 2199 : 	lpObj->DbOffExp = 0;

  00df6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00df9	c7 80 88 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6792], 0

; 2200 : 	lpObj->OffExp = false;

  00e03	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e06	c6 80 8c 1a 00
	00 00		 mov	 BYTE PTR [eax+6796], 0

; 2201 : 	lpObj->OffExpTick = 0;

  00e0d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e10	c7 80 90 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6800], 0

; 2202 : 	lpObj->OffExpSpeed = 0;

  00e1a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e1d	c7 80 94 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6804], 0

; 2203 : 
; 2204 : 	lpObj->OffAfk = false;

  00e27	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e2a	c6 80 85 1a 00
	00 00		 mov	 BYTE PTR [eax+6789], 0

; 2205 : 	lpObj->Offtrade = false;

  00e31	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e34	c6 80 86 1a 00
	00 00		 mov	 BYTE PTR [eax+6790], 0

; 2206 : 
; 2207 : 	lpObj->OffTradeZen = 0;

  00e3b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e3e	c7 80 98 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6808], 0

; 2208 : 	lpObj->OffTradeCredits = 0;

  00e48	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e4b	c7 80 9c 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6812], 0

; 2209 : 	lpObj->BotStore = 0;

  00e55	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e58	c7 80 a0 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6816], 0

; 2210 : 
; 2211 : 	//lpObj-> PickUpZen = 0;
; 2212 : 
; 2213 : 	#ifdef PICKUP_SYSTEM
; 2214 : 	///pick up system
; 2215 : 	for (i = 0; i < MAX_PICKUP_ITEMS; i++)

  00e62	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00e69	eb 09		 jmp	 SHORT $LN34@gObjCharZe
$LN32@gObjCharZe:
  00e6b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00e6e	83 c0 01	 add	 eax, 1
  00e71	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN34@gObjCharZe:
  00e74	83 7d fc 14	 cmp	 DWORD PTR _i$[ebp], 20	; 00000014H
  00e78	7d 38		 jge	 SHORT $LN33@gObjCharZe

; 2216 : 	{
; 2217 : 		lpObj->m_pickup[i].Item = -1;

  00e7a	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00e7e	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00e81	c7 84 01 b0 1a
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+6832], -1

; 2218 : 		lpObj->m_pickup[i].Type = -1;

  00e8c	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00e90	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00e93	c7 84 01 a8 1a
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+6824], -1

; 2219 : 		lpObj->m_pickup[i].Index = -1;

  00e9e	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00ea2	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00ea5	c7 84 01 ac 1a
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+6828], -1

; 2220 : 	}

  00eb0	eb b9		 jmp	 SHORT $LN32@gObjCharZe
$LN33@gObjCharZe:

; 2221 : #endif
; 2222 : 
; 2223 : 	gObjClearViewport(&gObj[aIndex]);

  00eb2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00eb9	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ebf	50		 push	 eax
  00ec0	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  00ec5	83 c4 04	 add	 esp, 4

; 2224 : }

  00ec8	5f		 pop	 edi
  00ec9	5e		 pop	 esi
  00eca	5b		 pop	 ebx
  00ecb	8b e5		 mov	 esp, ebp
  00ecd	5d		 pop	 ebp
  00ece	c3		 ret	 0
?gObjCharZeroSet@@YAXH@Z ENDP				; gObjCharZeroSet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCharTradeClear@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjCharTradeClear@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjCharTradeClear, COMDAT

; 1416 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1417 : #ifdef UPGRADE_GAMESERVER_01_20041006
; 1418 : 	//     .
; 1419 : 	if( lpObj->Type != OBJTYPE_CHARACTER )

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00010	83 f9 01	 cmp	 ecx, 1
  00013	74 02		 je	 SHORT $LN5@gObjCharTr

; 1420 : 		return;

  00015	eb 5f		 jmp	 SHORT $LN1@gObjCharTr
$LN5@gObjCharTr:

; 1421 : #endif
; 1422 : 
; 1423 : 	memset(lpObj->TradeMap, 0xFF, 4*8);

  00017	6a 20		 push	 32			; 00000020H
  00019	68 ff 00 00 00	 push	 255			; 000000ffH
  0001e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00021	8b 88 88 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3208]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _memset
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1424 : 	for( int i=0; i<MAX_TRADEITEM; i++ ) lpObj->Trade[i].Clear();

  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@gObjCharTr
$LN2@gObjCharTr:
  00039	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@gObjCharTr:
  00042	83 7d fc 20	 cmp	 DWORD PTR _i$1[ebp], 32	; 00000020H
  00046	7d 17		 jge	 SHORT $LN3@gObjCharTr
  00048	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _i$1[ebp], 168
  0004f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00052	03 88 84 0c 00
	00		 add	 ecx, DWORD PTR [eax+3204]
  00058	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
  0005d	eb da		 jmp	 SHORT $LN2@gObjCharTr
$LN3@gObjCharTr:

; 1425 : 	lpObj->TradeMoney = 0;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00062	c7 80 8c 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3212], 0

; 1426 : 	lpObj->TradeOk    = 0;

  0006c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006f	c6 80 90 0c 00
	00 00		 mov	 BYTE PTR [eax+3216], 0
$LN1@gObjCharTr:

; 1427 : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
?gObjCharTradeClear@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjCharTradeClear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSkillUseProcTime500@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pMsg$1 = -44						; size = 7
_lpMagic$2 = -36					; size = 4
_pMsg$3 = -32						; size = 5
_itempos$4 = -24					; size = 4
__count$5 = -20						; size = 4
_manacheck$6 = -16					; size = 4
_reqmana$7 = -12					; size = 4
_lpMagic$8 = -8						; size = 4
_dwCurrentTick$9 = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjSkillUseProcTime500@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjSkillUseProcTime500, COMDAT

; 587  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 588  : 	if( lpObj->SkillHellFire2State )

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b6 88 1c 0f
	00 00		 movzx	 ecx, BYTE PTR [eax+3868]
  00013	85 c9		 test	 ecx, ecx
  00015	0f 84 a5 02 00
	00		 je	 $LN15@gObjSkillU

; 589  : 	{
; 590  : #ifdef MODIFY_HELLBURST_SKILL_TIME_20060522
; 591  : 		DWORD dwCurrentTick = GetTickCount();

  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00021	89 45 fc	 mov	 DWORD PTR _dwCurrentTick$9[ebp], eax

; 592  : 
; 593  : 		lpObj->SkillHellFire2Count = ( dwCurrentTick - lpObj->SkillHellFire2Time ) / 500;

  00024	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _dwCurrentTick$9[ebp]
  0002a	2b 88 20 0f 00
	00		 sub	 ecx, DWORD PTR [eax+3872]
  00030	8b c1		 mov	 eax, ecx
  00032	33 d2		 xor	 edx, edx
  00034	b9 f4 01 00 00	 mov	 ecx, 500		; 000001f4H
  00039	f7 f1		 div	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0003e	88 82 1d 0f 00
	00		 mov	 BYTE PTR [edx+3869], al

; 594  : 		if( lpObj->SkillHellFire2Count > 12 )

  00044	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00047	0f b6 88 1d 0f
	00 00		 movzx	 ecx, BYTE PTR [eax+3869]
  0004e	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  00051	7e 0a		 jle	 SHORT $LN5@gObjSkillU

; 595  : 		{
; 596  : 			lpObj->SkillHellFire2Count = 12;

  00053	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00056	c6 80 1d 0f 00
	00 0c		 mov	 BYTE PTR [eax+3869], 12	; 0000000cH
$LN5@gObjSkillU:

; 597  : 		}
; 598  : 
; 599  : 		if( dwCurrentTick >= ( lpObj->SkillHellFire2Time + ( 6 * 1000 ) ) )

  0005d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00060	8b 88 20 0f 00
	00		 mov	 ecx, DWORD PTR [eax+3872]
  00066	81 c1 70 17 00
	00		 add	 ecx, 6000		; 00001770H
  0006c	39 4d fc	 cmp	 DWORD PTR _dwCurrentTick$9[ebp], ecx
  0006f	72 34		 jb	 SHORT $LN6@gObjSkillU

; 600  : 		{
; 601  : 			CMagicInf *		lpMagic;
; 602  : 			lpMagic = gObjGetMagicSearch(lpObj, AT_SKILL_EXPHELL);

  00071	6a 28		 push	 40			; 00000028H
  00073	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@E@Z ; gObjGetMagicSearch
  0007c	83 c4 08	 add	 esp, 8
  0007f	89 45 f8	 mov	 DWORD PTR _lpMagic$8[ebp], eax

; 603  : 
; 604  : 			if( lpMagic )

  00082	83 7d f8 00	 cmp	 DWORD PTR _lpMagic$8[ebp], 0
  00086	74 18		 je	 SHORT $LN8@gObjSkillU

; 605  : 			{
; 606  : 				gObjUseSkill.RunningSkill(lpObj->m_Index, 0, lpMagic);

  00088	6a 00		 push	 0
  0008a	8b 45 f8	 mov	 eax, DWORD PTR _lpMagic$8[ebp]
  0008d	50		 push	 eax
  0008e	6a 00		 push	 0
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00093	8b 11		 mov	 edx, DWORD PTR [ecx]
  00095	52		 push	 edx
  00096	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0009b	e8 00 00 00 00	 call	 ?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::RunningSkill
$LN8@gObjSkillU:

; 607  : 			}
; 608  : 		}

  000a0	e9 1b 02 00 00	 jmp	 $LN15@gObjSkillU
$LN6@gObjSkillU:

; 609  : #else
; 610  : 		lpObj->SkillHellFire2Count++;
; 611  : 		if( lpObj->SkillHellFire2Count >= 12 )
; 612  : 		{	//    
; 613  : 			CMagicInf *		lpMagic;
; 614  : 			lpMagic = gObjGetMagicSearch(lpObj, AT_SKILL_EXPHELL);
; 615  : 
; 616  : 			if( lpMagic )
; 617  : 			{
; 618  : 				gObjUseSkill.RunningSkill(lpObj->m_Index, 0, lpMagic);	
; 619  : 			}
; 620  : 		}
; 621  : #endif
; 622  : 		else
; 623  : 		{
; 624  : 			int reqmana = MagicDamageC.SkillGetMana(AT_SKILL_EXPHELL);

  000a5	6a 28		 push	 40			; 00000028H
  000a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  000ac	e8 00 00 00 00	 call	 ?SkillGetMana@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetMana
  000b1	89 45 f4	 mov	 DWORD PTR _reqmana$7[ebp], eax

; 625  : 			reqmana = reqmana*20/100;

  000b4	6b 45 f4 14	 imul	 eax, DWORD PTR _reqmana$7[ebp], 20
  000b8	99		 cdq
  000b9	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000be	f7 f9		 idiv	 ecx
  000c0	89 45 f4	 mov	 DWORD PTR _reqmana$7[ebp], eax

; 626  : 
; 627  : #ifdef UPDATE_MASTER_LEVEL_4RANK_20080428	//   
; 628  : 			reqmana -= (reqmana * lpObj->m_MPSkillOpt.iMpsDecreaseMana) / 100;
; 629  : 
; 630  : 			if(reqmana < 1)	reqmana = 1;
; 631  : #endif	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 632  : 			
; 633  : 			int manacheck = TRUE;

  000c3	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _manacheck$6[ebp], 1

; 634  : 			if( lpObj->Mana < reqmana )

  000ca	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _reqmana$7[ebp]
  000cf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d2	0f 2f 80 d0 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+208]
  000d9	0f 86 ce 00 00
	00		 jbe	 $LN3@gObjSkillU

; 635  : 			{
; 636  : 				manacheck = FALSE;

  000df	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _manacheck$6[ebp], 0

; 637  : 
; 638  : #ifdef CHECK_LOG_INFINITE_20040426 
; 639  : 				int _count = 0;

  000e6	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __count$5[ebp], 0
$LN2@gObjSkillU:

; 640  : #endif
; 641  : 
; 642  : 				while(1)

  000ed	b8 01 00 00 00	 mov	 eax, 1
  000f2	85 c0		 test	 eax, eax
  000f4	0f 84 b3 00 00
	00		 je	 $LN3@gObjSkillU

; 643  : 				{
; 644  : 
; 645  : #ifdef CHECK_LOG_INFINITE_20040426 
; 646  : 					_count++;

  000fa	8b 45 ec	 mov	 eax, DWORD PTR __count$5[ebp]
  000fd	83 c0 01	 add	 eax, 1
  00100	89 45 ec	 mov	 DWORD PTR __count$5[ebp], eax

; 647  : 					if( gObjIsConnected(lpObj) == FALSE ) 

  00103	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@@Z ; gObjIsConnected
  0010c	83 c4 04	 add	 esp, 4
  0010f	85 c0		 test	 eax, eax
  00111	75 1e		 jne	 SHORT $LN10@gObjSkillU

; 648  : 					{
; 649  : 						LogAdd("[CHECK_LOG_INFINITY] gObjIsConnected() error %s %d", __FILE__, __LINE__);

  00113	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjSkillUseProcTime500@@YAXPAVOBJECTSTRUCT@@@Z@4JA
  00118	83 c0 3e	 add	 eax, 62			; 0000003eH
  0011b	50		 push	 eax
  0011c	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00121	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@NOIKLNAL@?$KB?Z?$FLCHECK_LOG_INFINITY?$FN?5gObjIsCo@
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0012c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 650  : 						break;

  0012f	eb 7c		 jmp	 SHORT $LN3@gObjSkillU
$LN10@gObjSkillU:

; 651  : 					}
; 652  : 
; 653  : 					if( _count > 100 )

  00131	83 7d ec 64	 cmp	 DWORD PTR __count$5[ebp], 100 ; 00000064H
  00135	7e 1e		 jle	 SHORT $LN11@gObjSkillU

; 654  : 					{
; 655  : 						LogAdd("[CHECK_LOG_INFINITY] ( _count > 100 ) error %s %d", __FILE__, __LINE__);

  00137	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjSkillUseProcTime500@@YAXPAVOBJECTSTRUCT@@@Z@4JA
  0013c	83 c0 44	 add	 eax, 68			; 00000044H
  0013f	50		 push	 eax
  00140	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00145	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@GDMCBCLE@?$KB?Z?$FLCHECK_LOG_INFINITY?$FN?5?$CI?5_count@
  0014a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00150	83 c4 0c	 add	 esp, 12			; 0000000cH

; 656  : 						break;

  00153	eb 58		 jmp	 SHORT $LN3@gObjSkillU
$LN11@gObjSkillU:

; 657  : 					}
; 658  : #endif
; 659  : 
; 660  : 					int itempos = gObjGetManaItemPos(lpObj->m_Index);		//    

  00155	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00158	8b 08		 mov	 ecx, DWORD PTR [eax]
  0015a	51		 push	 ecx
  0015b	e8 00 00 00 00	 call	 ?gObjGetManaItemPos@@YAHH@Z ; gObjGetManaItemPos
  00160	83 c4 04	 add	 esp, 4
  00163	89 45 e8	 mov	 DWORD PTR _itempos$4[ebp], eax

; 661  : 
; 662  : 					if( itempos == -1 )

  00166	83 7d e8 ff	 cmp	 DWORD PTR _itempos$4[ebp], -1
  0016a	75 02		 jne	 SHORT $LN12@gObjSkillU

; 663  : 						break;

  0016c	eb 3f		 jmp	 SHORT $LN3@gObjSkillU
$LN12@gObjSkillU:

; 664  : 
; 665  : 					PMSG_USEITEM pMsg;
; 666  : 					pMsg.inventoryPos = itempos;

  0016e	8a 45 e8	 mov	 al, BYTE PTR _itempos$4[ebp]
  00171	88 45 e3	 mov	 BYTE PTR _pMsg$3[ebp+3], al

; 667  : 					pMsg.invenrotyTarget = 0;

  00174	c6 45 e4 00	 mov	 BYTE PTR _pMsg$3[ebp+4], 0

; 668  : 					
; 669  : 					CGUseItemRecv(&pMsg, lpObj->m_Index);

  00178	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017d	51		 push	 ecx
  0017e	8d 55 e0	 lea	 edx, DWORD PTR _pMsg$3[ebp]
  00181	52		 push	 edx
  00182	e8 00 00 00 00	 call	 ?CGUseItemRecv@@YAXPAUPMSG_USEITEM@@H@Z ; CGUseItemRecv
  00187	83 c4 08	 add	 esp, 8

; 670  : 
; 671  : 					if( lpObj->Mana >= reqmana )

  0018a	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _reqmana$7[ebp]
  0018f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00192	f3 0f 10 88 d0
	00 00 00	 movss	 xmm1, DWORD PTR [eax+208]
  0019a	0f 2f c8	 comiss	 xmm1, xmm0
  0019d	72 09		 jb	 SHORT $LN13@gObjSkillU

; 672  : 					{	// 
; 673  : 						manacheck = TRUE;

  0019f	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _manacheck$6[ebp], 1

; 674  : 						break;

  001a6	eb 05		 jmp	 SHORT $LN3@gObjSkillU
$LN13@gObjSkillU:

; 675  : 					}
; 676  : 				}

  001a8	e9 40 ff ff ff	 jmp	 $LN2@gObjSkillU
$LN3@gObjSkillU:

; 677  : 			}
; 678  : 
; 679  : 			if( !manacheck )

  001ad	83 7d f0 00	 cmp	 DWORD PTR _manacheck$6[ebp], 0
  001b1	75 34		 jne	 SHORT $LN14@gObjSkillU

; 680  : 			{	//   skill 
; 681  : 				CMagicInf *		lpMagic;
; 682  : 				lpMagic = gObjGetMagicSearch(lpObj, AT_SKILL_EXPHELL);

  001b3	6a 28		 push	 40			; 00000028H
  001b5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@E@Z ; gObjGetMagicSearch
  001be	83 c4 08	 add	 esp, 8
  001c1	89 45 dc	 mov	 DWORD PTR _lpMagic$2[ebp], eax

; 683  : 
; 684  : 				if( lpMagic )

  001c4	83 7d dc 00	 cmp	 DWORD PTR _lpMagic$2[ebp], 0
  001c8	74 18		 je	 SHORT $LN16@gObjSkillU

; 685  : 				{
; 686  : 					gObjUseSkill.RunningSkill(lpObj->m_Index, 0, lpMagic);	

  001ca	6a 00		 push	 0
  001cc	8b 45 dc	 mov	 eax, DWORD PTR _lpMagic$2[ebp]
  001cf	50		 push	 eax
  001d0	6a 00		 push	 0
  001d2	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001d5	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d7	52		 push	 edx
  001d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  001dd	e8 00 00 00 00	 call	 ?RunningSkill@CObjUseSkill@@QAEHHHPAVCMagicInf@@H@Z ; CObjUseSkill::RunningSkill
$LN16@gObjSkillU:

; 687  : 				}
; 688  : 			}

  001e2	e9 d9 00 00 00	 jmp	 $LN15@gObjSkillU
$LN14@gObjSkillU:

; 689  : 			else
; 690  : 			{
; 691  : 				//  
; 692  : 				lpObj->Mana -= (float)reqmana;

  001e7	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _reqmana$7[ebp]
  001ec	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ef	f3 0f 10 88 d0
	00 00 00	 movss	 xmm1, DWORD PTR [eax+208]
  001f7	f3 0f 5c c8	 subss	 xmm1, xmm0
  001fb	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001fe	f3 0f 11 89 d0
	00 00 00	 movss	 DWORD PTR [ecx+208], xmm1

; 693  : 				if( lpObj->Mana < 0.f )

  00206	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00209	0f 57 c0	 xorps	 xmm0, xmm0
  0020c	0f 2f 80 d0 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+208]
  00213	76 0e		 jbe	 SHORT $LN17@gObjSkillU

; 694  : 				{
; 695  : 					lpObj->Mana = 0.f;

  00215	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00218	0f 57 c0	 xorps	 xmm0, xmm0
  0021b	f3 0f 11 80 d0
	00 00 00	 movss	 DWORD PTR [eax+208], xmm0
$LN17@gObjSkillU:

; 696  : 				}
; 697  : 				GCManaSend(lpObj->m_Index, (short)lpObj->Mana, 0xFF, 0, lpObj->BP);		

  00223	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00226	0f b7 88 e8 00
	00 00		 movzx	 ecx, WORD PTR [eax+232]
  0022d	51		 push	 ecx
  0022e	6a 00		 push	 0
  00230	68 ff 00 00 00	 push	 255			; 000000ffH
  00235	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00238	f3 0f 2c 82 d0
	00 00 00	 cvttss2si eax, DWORD PTR [edx+208]
  00240	0f b7 c8	 movzx	 ecx, ax
  00243	51		 push	 ecx
  00244	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00247	8b 02		 mov	 eax, DWORD PTR [edx]
  00249	50		 push	 eax
  0024a	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  0024f	83 c4 14	 add	 esp, 20			; 00000014H

; 698  : 
; 699  : 				PMSG_EX_SKILL_COUNT	pMsg;		
; 700  : 
; 701  : 				PHeadSetB((LPBYTE)&pMsg, 0xBA, sizeof( pMsg ));

  00252	6a 07		 push	 7
  00254	68 ba 00 00 00	 push	 186			; 000000baH
  00259	8d 45 d4	 lea	 eax, DWORD PTR _pMsg$1[ebp]
  0025c	50		 push	 eax
  0025d	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00262	83 c4 0c	 add	 esp, 12			; 0000000cH

; 702  : 				pMsg.Type = AT_SKILL_EXPHELL;

  00265	c6 45 d9 28	 mov	 BYTE PTR _pMsg$1[ebp+5], 40 ; 00000028H

; 703  : 				pMsg.Count = lpObj->SkillHellFire2Count;

  00269	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0026c	8a 88 1d 0f 00
	00		 mov	 cl, BYTE PTR [eax+3869]
  00272	88 4d da	 mov	 BYTE PTR _pMsg$1[ebp+6], cl

; 704  : 				pMsg.NumberH		= HIBYTE(lpObj->m_Index);

  00275	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00278	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027a	c1 e9 08	 shr	 ecx, 8
  0027d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00283	88 4d d7	 mov	 BYTE PTR _pMsg$1[ebp+3], cl

; 705  : 				pMsg.NumberL		= LOBYTE(lpObj->m_Index);

  00286	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00289	8b 08		 mov	 ecx, DWORD PTR [eax]
  0028b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00291	88 4d d8	 mov	 BYTE PTR _pMsg$1[ebp+4], cl

; 706  : 
; 707  : 				DataSend( lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00294	0f b6 45 d5	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  00298	50		 push	 eax
  00299	8d 4d d4	 lea	 ecx, DWORD PTR _pMsg$1[ebp]
  0029c	51		 push	 ecx
  0029d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002a0	8b 02		 mov	 eax, DWORD PTR [edx]
  002a2	50		 push	 eax
  002a3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002a8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 708  : 				MsgSendV2(lpObj, (LPBYTE)&pMsg, pMsg.h.size);

  002ab	0f b6 45 d5	 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  002af	50		 push	 eax
  002b0	8d 4d d4	 lea	 ecx, DWORD PTR _pMsg$1[ebp]
  002b3	51		 push	 ecx
  002b4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002b7	52		 push	 edx
  002b8	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  002bd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@gObjSkillU:

; 709  : 			}
; 710  : 		}
; 711  : 	}
; 712  : }

  002c0	5f		 pop	 edi
  002c1	5e		 pop	 esi
  002c2	5b		 pop	 ebx
  002c3	8b e5		 mov	 esp, ebp
  002c5	5d		 pop	 ebp
  002c6	c3		 ret	 0
?gObjSkillUseProcTime500@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjSkillUseProcTime500
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryRollback@@YAHH@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv67 = -72						; size = 4
_n$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjInventoryRollback@@YAHH@Z PROC			; gObjInventoryRollback, COMDAT

; 14653: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14654: 	int n;
; 14655: 
; 14656: 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT) )

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN13@gObjInvent
  0000f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN14@gObjInvent
$LN13@gObjInvent:
  00018	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN11@gObjInvent
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN12@gObjInvent
$LN11@gObjInvent:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN12@gObjInvent:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN14@gObjInvent:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 23		 jne	 SHORT $LN8@gObjInvent

; 14657: 	{
; 14658: 		LogAdd("error : %s %d",__FILE__, __LINE__);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryRollback@@YAHH@Z@4JA
  00042	83 c0 05	 add	 eax, 5
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14659: 		return FALSE;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 47 01 00 00	 jmp	 $LN1@gObjInvent
$LN8@gObjInvent:

; 14660: 	}
; 14661: 	
; 14662: #ifdef INVENTORY_CLEAR_BUGFIX_20050226
; 14663: 	if( gObj[aIndex].pTransaction != 1 )	//      

  00060	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006d	0f be 94 01 68
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3176]
  00075	83 fa 01	 cmp	 edx, 1
  00078	74 4f		 je	 SHORT $LN9@gObjInvent

; 14664: 	{
; 14665: 		LogAddTD("[%s][%s] error-L3 : pTransaction(%d) status2", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].pTransaction);

  0007a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00087	0f be 94 01 68
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3176]
  0008f	52		 push	 edx
  00090	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009d	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000a1	52		 push	 edx
  000a2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000af	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000b3	52		 push	 edx
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@FHLLPNOD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransactio@
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000bf	83 c4 10	 add	 esp, 16			; 00000010H

; 14666: 		return FALSE;

  000c2	33 c0		 xor	 eax, eax
  000c4	e9 de 00 00 00	 jmp	 $LN1@gObjInvent
$LN9@gObjInvent:

; 14667: 	}
; 14668: #else
; 14669: 	if( gObj[aIndex].pTransaction == 0 )
; 14670: 	{
; 14671: 		LogAddTD("[%s][%s] error-L3 : pTransaction(%d) status error %s %d", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].pTransaction, __FILE__, __LINE__);
; 14672: 		return FALSE;
; 14673: 	}
; 14674: 	//   ..
; 14675: 	if( gObj[aIndex].pTransaction == 3 ) 
; 14676: 	{
; 14677: 		LogAddTD("[%s][%s] error-L3 : pTransaction(%d) status2", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].pTransaction);
; 14678: 		return TRUE;
; 14679: 	}
; 14680: #endif
; 14681: 
; 14682: 	for( n=0; n<MAX_MAGIC; n++)

  000c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN4@gObjInvent
$LN2@gObjInvent:
  000d2	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjInvent:
  000db	83 7d fc 3c	 cmp	 DWORD PTR _n$[ebp], 60	; 0000003cH
  000df	7d 3c		 jge	 SHORT $LN3@gObjInvent

; 14683: 	{
; 14684: 		gObj[aIndex].Magic[n] = gObj[aIndex].m_lpMagicBack[n];

  000e1	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  000eb	c1 e1 04	 shl	 ecx, 4
  000ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f4	03 8c 02 0c 03
	00 00		 add	 ecx, DWORD PTR [edx+eax+780]
  000fb	51		 push	 ecx
  000fc	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00103	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  00106	c1 e1 04	 shl	 ecx, 4
  00109	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010f	03 8c 02 10 03
	00 00		 add	 ecx, DWORD PTR [edx+eax+784]
  00116	e8 00 00 00 00	 call	 ??4CMagicInf@@QAEAAV0@ABV0@@Z

; 14685: 	}

  0011b	eb b5		 jmp	 SHORT $LN2@gObjInvent
$LN3@gObjInvent:

; 14686: 	
; 14687: #ifdef PERSONAL_SHOP_20040113		//       
; 14688: 	for( n=0; n<MAX_INVENTORY_EXTEND; n++)

  0011d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00124	eb 09		 jmp	 SHORT $LN7@gObjInvent
$LN5@gObjInvent:
  00126	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00129	83 c0 01	 add	 eax, 1
  0012c	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN7@gObjInvent:
  0012f	83 7d fc 6c	 cmp	 DWORD PTR _n$[ebp], 108	; 0000006cH
  00133	7d 22		 jge	 SHORT $LN6@gObjInvent

; 14689: //	for( n=0; n<MAX_INVENTORY; n++)
; 14690: #else
; 14691: 	for( n=0; n<MAX_INVENTORY; n++)
; 14692: #endif
; 14693: 	{
; 14694: 		gObj[aIndex].Inventory2[n].Clear();

  00135	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0013c	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 168
  00143	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00149	03 8c 02 78 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3192]
  00150	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14695: 	}

  00155	eb cf		 jmp	 SHORT $LN5@gObjInvent
$LN6@gObjInvent:

; 14696: 	//memcpy(gObj[aIndex].InventoryMap1, gObj[aIndex].InventoryMap2, MAX_INVENTORYMAP);
; 14697: 	//gObj[aIndex].InventoryCount1 = gObj[aIndex].InventoryCount2;
; 14698: 	
; 14699: 	//memcpy(gObj[aIndex].InventoryMap1, gObj[aIndex].InventoryMap2, MAX_INVENTORYMAP);
; 14700: 	//gObj[aIndex].InventoryCount1 = gObj[aIndex].InventoryCount2;
; 14701: 	gObjSetInventory1Pointer(&gObj[aIndex]);

  00157	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0015e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00164	50		 push	 eax
  00165	e8 00 00 00 00	 call	 ?gObjSetInventory1Pointer@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer
  0016a	83 c4 04	 add	 esp, 4

; 14702: 	gObj[aIndex].pTransaction = 3;

  0016d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00174	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017a	c6 84 01 68 0c
	00 00 03	 mov	 BYTE PTR [ecx+eax+3176], 3

; 14703: 
; 14704: 	LogAddL("Trade Rollback (%s)", gObj[aIndex].Name );

  00182	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00189	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018f	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00193	52		 push	 edx
  00194	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GIFOPHN@Trade?5Rollback?5?$CI?$CFs?$CJ@
  00199	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  0019f	83 c4 08	 add	 esp, 8

; 14705: 	return TRUE;

  001a2	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjInvent:

; 14706: }

  001a7	5f		 pop	 edi
  001a8	5e		 pop	 esi
  001a9	5b		 pop	 ebx
  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c3		 ret	 0
?gObjInventoryRollback@@YAHH@Z ENDP			; gObjInventoryRollback
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjWingDurProc@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_dur$1 = -8						; size = 4
_send_dur$ = -1						; size = 1
_lpObj$ = 8						; size = 4
?gObjWingDurProc@@YAXPAVOBJECTSTRUCT@@@Z PROC		; gObjWingDurProc, COMDAT

; 11915: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 11916: 	BYTE send_dur=0;

  00009	c6 45 ff 00	 mov	 BYTE PTR _send_dur$[ebp], 0

; 11917: 
; 11918: 	//     ..
; 11919: 	return;

  0000d	e9 89 01 00 00	 jmp	 $LN1@gObjWingDu

; 11920: 
; 11921: 	if( lpObj->pInventory[EQUIPMENT_WING].IsItem() == TRUE )

  00012	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00017	6b c8 07	 imul	 ecx, eax, 7
  0001a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0001d	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00023	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00028	83 f8 01	 cmp	 eax, 1
  0002b	0f 85 6a 01 00
	00		 jne	 $LN2@gObjWingDu

; 11922: 	{	
; 11923: 		int dur = (int)lpObj->pInventory[EQUIPMENT_WING].m_Durability;

  00031	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00036	6b c8 07	 imul	 ecx, eax, 7
  00039	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0003c	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00042	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  00048	89 4d f8	 mov	 DWORD PTR _dur$1[ebp], ecx

; 11924: 			lpObj->pInventory[EQUIPMENT_WING].m_Durability -= (float)0.0002;

  0004b	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00050	6b c8 07	 imul	 ecx, eax, 7
  00053	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00056	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0005c	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  00062	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3951b717
  0006a	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  0006f	6b d1 07	 imul	 edx, ecx, 7
  00072	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00075	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  0007b	f3 0f 11 44 11
	24		 movss	 DWORD PTR [ecx+edx+36], xmm0

; 11925: 			
; 11926: 			if( dur > (int)lpObj->pInventory[EQUIPMENT_WING].m_Durability ) 

  00081	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00086	6b c8 07	 imul	 ecx, eax, 7
  00089	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0008c	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00092	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  00098	39 4d f8	 cmp	 DWORD PTR _dur$1[ebp], ecx
  0009b	0f 8e fa 00 00
	00		 jle	 $LN5@gObjWingDu

; 11927: 			{
; 11928: 				if( lpObj->pInventory[EQUIPMENT_WING].m_Durability < 1 ) 

  000a1	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000a6	6b c8 07	 imul	 ecx, eax, 7
  000a9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ac	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  000b2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000ba	0f 2f 44 08 24	 comiss	 xmm0, DWORD PTR [eax+ecx+36]
  000bf	76 1a		 jbe	 SHORT $LN4@gObjWingDu

; 11929: 					lpObj->pInventory[EQUIPMENT_WING].m_Durability = 0;

  000c1	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000c6	6b c8 07	 imul	 ecx, eax, 7
  000c9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000cc	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  000d2	0f 57 c0	 xorps	 xmm0, xmm0
  000d5	f3 0f 11 44 08
	24		 movss	 DWORD PTR [eax+ecx+36], xmm0
$LN4@gObjWingDu:

; 11930: 
; 11931: 				send_dur = (BYTE)lpObj->pInventory[EQUIPMENT_WING].m_Durability;

  000db	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000e0	6b c8 07	 imul	 ecx, eax, 7
  000e3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e6	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  000ec	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  000f2	88 4d ff	 mov	 BYTE PTR _send_dur$[ebp], cl

; 11932: 				GCItemDurSend(lpObj->m_Index, EQUIPMENT_WING, send_dur, 0);

  000f5	6a 00		 push	 0
  000f7	0f b6 45 ff	 movzx	 eax, BYTE PTR _send_dur$[ebp]
  000fb	50		 push	 eax
  000fc	6a 07		 push	 7
  000fe	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00101	8b 11		 mov	 edx, DWORD PTR [ecx]
  00103	52		 push	 edx
  00104	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00109	83 c4 10	 add	 esp, 16			; 00000010H

; 11933: 				if( send_dur == 0 ) 

  0010c	0f b6 45 ff	 movzx	 eax, BYTE PTR _send_dur$[ebp]
  00110	85 c0		 test	 eax, eax
  00112	0f 85 83 00 00
	00		 jne	 $LN5@gObjWingDu

; 11934: 				{
; 11935: 					LogAddTD(lMsg.Get(544), lpObj->AccountID, lpObj->Name, lpObj->pInventory[EQUIPMENT_WING].GetName(), lpObj->pInventory[EQUIPMENT_WING].m_Level, send_dur);

  00118	0f b6 45 ff	 movzx	 eax, BYTE PTR _send_dur$[ebp]
  0011c	50		 push	 eax
  0011d	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00122	6b d1 07	 imul	 edx, ecx, 7
  00125	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00128	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  0012e	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  00133	52		 push	 edx
  00134	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00139	6b c8 07	 imul	 ecx, eax, 7
  0013c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0013f	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00145	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0014a	50		 push	 eax
  0014b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014e	83 c0 73	 add	 eax, 115		; 00000073H
  00151	50		 push	 eax
  00152	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00155	83 c1 68	 add	 ecx, 104		; 00000068H
  00158	51		 push	 ecx
  00159	68 20 02 00 00	 push	 544			; 00000220H
  0015e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00169	50		 push	 eax
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00170	83 c4 18	 add	 esp, 24			; 00000018H

; 11936: 					lpObj->pInventory[EQUIPMENT_WING].Clear();

  00173	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00178	6b c8 07	 imul	 ecx, eax, 7
  0017b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0017e	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00184	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 11937: 					GCInventoryItemDeleteSend(lpObj->m_Index, EQUIPMENT_WING, 0);

  00189	6a 00		 push	 0
  0018b	6a 07		 push	 7
  0018d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00190	8b 08		 mov	 ecx, DWORD PTR [eax]
  00192	51		 push	 ecx
  00193	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00198	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@gObjWingDu:
$LN2@gObjWingDu:
$LN1@gObjWingDu:

; 11938: 				}
; 11939: 			}
; 11940: 			//LogAdd("  %f",lpObj->pInventory[EQUIPMENT_WING].m_Durability);
; 11941: 			return;
; 11942: 	}
; 11943: }

  0019b	5f		 pop	 edi
  0019c	5e		 pop	 esi
  0019d	5b		 pop	 ebx
  0019e	8b e5		 mov	 esp, ebp
  001a0	5d		 pop	 ebp
  001a1	c3		 ret	 0
?gObjWingDurProc@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; gObjWingDurProc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjChangeDurProc@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_send_dur$1 = -13					; size = 1
_dur$2 = -12						; size = 4
_send_dur$3 = -5					; size = 1
_dur$4 = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjChangeDurProc@@YAXPAVOBJECTSTRUCT@@@Z PROC		; gObjChangeDurProc, COMDAT

; 11248: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 11249: 	if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].IsItem() == TRUE )

  00009	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0000e	6b c8 0a	 imul	 ecx, eax, 10
  00011	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00014	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0001a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0001f	83 f8 01	 cmp	 eax, 1
  00022	0f 85 a9 01 00
	00		 jne	 $LN3@gObjChange

; 11250: 	{
; 11251: 		if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM(13,10) )

  00028	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0002d	6b c8 0a	 imul	 ecx, eax, 10
  00030	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00033	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00039	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0003e	6a 0a		 push	 10			; 0000000aH
  00040	6a 0d		 push	 13			; 0000000dH
  00042	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00047	83 c4 08	 add	 esp, 8
  0004a	3b f0		 cmp	 esi, eax
  0004c	0f 85 7f 01 00
	00		 jne	 $LN3@gObjChange

; 11252: 		{
; 11253: 			int dur = (int)lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability;

  00052	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00057	6b c8 0a	 imul	 ecx, eax, 10
  0005a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0005d	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00063	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  00069	89 4d fc	 mov	 DWORD PTR _dur$4[ebp], ecx

; 11254: 			lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability -= (float)0.02;

  0006c	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00071	6b c8 0a	 imul	 ecx, eax, 10
  00074	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00077	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0007d	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  00083	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3ca3d70a
  0008b	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00090	6b d1 0a	 imul	 edx, ecx, 10
  00093	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00096	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  0009c	f3 0f 11 44 11
	24		 movss	 DWORD PTR [ecx+edx+36], xmm0

; 11255: 			
; 11256: 			if( dur > (int)lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability ) 

  000a2	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000a7	6b c8 0a	 imul	 ecx, eax, 10
  000aa	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ad	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  000b3	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  000b9	39 4d fc	 cmp	 DWORD PTR _dur$4[ebp], ecx
  000bc	0f 8e 0a 01 00
	00		 jle	 $LN6@gObjChange

; 11257: 			{
; 11258: 				if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability < 1 ) 

  000c2	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000c7	6b c8 0a	 imul	 ecx, eax, 10
  000ca	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000cd	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  000d3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000db	0f 2f 44 08 24	 comiss	 xmm0, DWORD PTR [eax+ecx+36]
  000e0	76 1a		 jbe	 SHORT $LN5@gObjChange

; 11259: 					lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability = 0;

  000e2	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000e7	6b c8 0a	 imul	 ecx, eax, 10
  000ea	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ed	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  000f3	0f 57 c0	 xorps	 xmm0, xmm0
  000f6	f3 0f 11 44 08
	24		 movss	 DWORD PTR [eax+ecx+36], xmm0
$LN5@gObjChange:

; 11260: 
; 11261: 				BYTE send_dur = (BYTE)lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability;

  000fc	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00101	6b c8 0a	 imul	 ecx, eax, 10
  00104	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00107	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0010d	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  00113	88 4d fb	 mov	 BYTE PTR _send_dur$3[ebp], cl

; 11262: 				GCItemDurSend(lpObj->m_Index, EQUIPMENT_RING_RIGHT, send_dur, 0);

  00116	6a 00		 push	 0
  00118	0f b6 45 fb	 movzx	 eax, BYTE PTR _send_dur$3[ebp]
  0011c	50		 push	 eax
  0011d	6a 0a		 push	 10			; 0000000aH
  0011f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00122	8b 11		 mov	 edx, DWORD PTR [ecx]
  00124	52		 push	 edx
  00125	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  0012a	83 c4 10	 add	 esp, 16			; 00000010H

; 11263: 				if( send_dur == 0 ) 

  0012d	0f b6 45 fb	 movzx	 eax, BYTE PTR _send_dur$3[ebp]
  00131	85 c0		 test	 eax, eax
  00133	0f 85 93 00 00
	00		 jne	 $LN6@gObjChange

; 11264: 				{
; 11265: 					gObjUseSkill.SkillChangeUse(lpObj->m_Index);

  00139	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013e	51		 push	 ecx
  0013f	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  00144	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 11266: 					LogAddTD(lMsg.Get(544), lpObj->AccountID, lpObj->Name, lpObj->pInventory[EQUIPMENT_RING_RIGHT].GetName(), lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Level, send_dur);

  00149	0f b6 45 fb	 movzx	 eax, BYTE PTR _send_dur$3[ebp]
  0014d	50		 push	 eax
  0014e	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00153	6b d1 0a	 imul	 edx, ecx, 10
  00156	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00159	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  0015f	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  00164	52		 push	 edx
  00165	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0016a	6b c8 0a	 imul	 ecx, eax, 10
  0016d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00170	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00176	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0017b	50		 push	 eax
  0017c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017f	83 c0 73	 add	 eax, 115		; 00000073H
  00182	50		 push	 eax
  00183	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00186	83 c1 68	 add	 ecx, 104		; 00000068H
  00189	51		 push	 ecx
  0018a	68 20 02 00 00	 push	 544			; 00000220H
  0018f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00194	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0019a	50		 push	 eax
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001a1	83 c4 18	 add	 esp, 24			; 00000018H

; 11267: 					lpObj->pInventory[EQUIPMENT_RING_RIGHT].Clear();

  001a4	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  001a9	6b c8 0a	 imul	 ecx, eax, 10
  001ac	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001af	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  001b5	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 11268: 					GCInventoryItemDeleteSend(lpObj->m_Index, EQUIPMENT_RING_RIGHT, 0);					

  001ba	6a 00		 push	 0
  001bc	6a 0a		 push	 10			; 0000000aH
  001be	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c3	51		 push	 ecx
  001c4	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  001c9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@gObjChange:

; 11269: 				}
; 11270: 			}
; 11271: 			return;

  001cc	e9 c3 01 00 00	 jmp	 $LN1@gObjChange
$LN3@gObjChange:

; 11272: 		}
; 11273: 	}
; 11274: 	if( lpObj->pInventory[EQUIPMENT_RING_LEFT].IsItem() == TRUE )

  001d1	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  001d6	6b c8 0b	 imul	 ecx, eax, 11
  001d9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001dc	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  001e2	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  001e7	83 f8 01	 cmp	 eax, 1
  001ea	0f 85 a4 01 00
	00		 jne	 $LN8@gObjChange

; 11275: 	{
; 11276: 		if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM(13,10) )

  001f0	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  001f5	6b c8 0b	 imul	 ecx, eax, 11
  001f8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001fb	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00201	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00206	6a 0a		 push	 10			; 0000000aH
  00208	6a 0d		 push	 13			; 0000000dH
  0020a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0020f	83 c4 08	 add	 esp, 8
  00212	3b f0		 cmp	 esi, eax
  00214	0f 85 7a 01 00
	00		 jne	 $LN8@gObjChange

; 11277: 		{
; 11278: 			int dur = (int)lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability;

  0021a	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0021f	6b c8 0b	 imul	 ecx, eax, 11
  00222	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00225	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0022b	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  00231	89 4d f4	 mov	 DWORD PTR _dur$2[ebp], ecx

; 11279: 			lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability -= (float)0.02;

  00234	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00239	6b c8 0b	 imul	 ecx, eax, 11
  0023c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0023f	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00245	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  0024b	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3ca3d70a
  00253	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00258	6b d1 0b	 imul	 edx, ecx, 11
  0025b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0025e	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00264	f3 0f 11 44 11
	24		 movss	 DWORD PTR [ecx+edx+36], xmm0

; 11280: 			if( dur > (int)lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability ) 

  0026a	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0026f	6b c8 0b	 imul	 ecx, eax, 11
  00272	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00275	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0027b	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  00281	39 4d f4	 cmp	 DWORD PTR _dur$2[ebp], ecx
  00284	0f 8e 0a 01 00
	00		 jle	 $LN11@gObjChange

; 11281: 			{
; 11282: 				if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability < 1 )

  0028a	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0028f	6b c8 0b	 imul	 ecx, eax, 11
  00292	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00295	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0029b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002a3	0f 2f 44 08 24	 comiss	 xmm0, DWORD PTR [eax+ecx+36]
  002a8	76 1a		 jbe	 SHORT $LN10@gObjChange

; 11283: 					lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability = 0;

  002aa	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  002af	6b c8 0b	 imul	 ecx, eax, 11
  002b2	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002b5	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  002bb	0f 57 c0	 xorps	 xmm0, xmm0
  002be	f3 0f 11 44 08
	24		 movss	 DWORD PTR [eax+ecx+36], xmm0
$LN10@gObjChange:

; 11284: 
; 11285: 				BYTE send_dur = (BYTE)lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability;

  002c4	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  002c9	6b c8 0b	 imul	 ecx, eax, 11
  002cc	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002cf	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  002d5	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  002db	88 4d f3	 mov	 BYTE PTR _send_dur$1[ebp], cl

; 11286: 				GCItemDurSend(lpObj->m_Index, EQUIPMENT_RING_LEFT, (BYTE)send_dur, 0);

  002de	6a 00		 push	 0
  002e0	0f b6 45 f3	 movzx	 eax, BYTE PTR _send_dur$1[ebp]
  002e4	50		 push	 eax
  002e5	6a 0b		 push	 11			; 0000000bH
  002e7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002ea	8b 11		 mov	 edx, DWORD PTR [ecx]
  002ec	52		 push	 edx
  002ed	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  002f2	83 c4 10	 add	 esp, 16			; 00000010H

; 11287: 				if( send_dur == 0 ) 

  002f5	0f b6 45 f3	 movzx	 eax, BYTE PTR _send_dur$1[ebp]
  002f9	85 c0		 test	 eax, eax
  002fb	0f 85 93 00 00
	00		 jne	 $LN11@gObjChange

; 11288: 				{	
; 11289: 					gObjUseSkill.SkillChangeUse(lpObj->m_Index);

  00301	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00304	8b 08		 mov	 ecx, DWORD PTR [eax]
  00306	51		 push	 ecx
  00307	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0030c	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 11290: 					LogAddTD(lMsg.Get(544), lpObj->AccountID, lpObj->Name, lpObj->pInventory[EQUIPMENT_RING_RIGHT].GetName(), lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Level, send_dur);

  00311	0f b6 45 f3	 movzx	 eax, BYTE PTR _send_dur$1[ebp]
  00315	50		 push	 eax
  00316	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  0031b	6b d1 0b	 imul	 edx, ecx, 11
  0031e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00321	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00327	0f bf 54 11 08	 movsx	 edx, WORD PTR [ecx+edx+8]
  0032c	52		 push	 edx
  0032d	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00332	6b c8 0a	 imul	 ecx, eax, 10
  00335	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00338	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0033e	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00343	50		 push	 eax
  00344	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00347	83 c0 73	 add	 eax, 115		; 00000073H
  0034a	50		 push	 eax
  0034b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0034e	83 c1 68	 add	 ecx, 104		; 00000068H
  00351	51		 push	 ecx
  00352	68 20 02 00 00	 push	 544			; 00000220H
  00357	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0035c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00362	50		 push	 eax
  00363	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00369	83 c4 18	 add	 esp, 24			; 00000018H

; 11291: 					lpObj->pInventory[EQUIPMENT_RING_LEFT].Clear();

  0036c	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00371	6b c8 0b	 imul	 ecx, eax, 11
  00374	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00377	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0037d	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 11292: 					GCInventoryItemDeleteSend(lpObj->m_Index, EQUIPMENT_RING_LEFT, 0);					

  00382	6a 00		 push	 0
  00384	6a 0b		 push	 11			; 0000000bH
  00386	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00389	8b 08		 mov	 ecx, DWORD PTR [eax]
  0038b	51		 push	 ecx
  0038c	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00391	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@gObjChange:
$LN8@gObjChange:
$LN1@gObjChange:

; 11293: 				}
; 11294: 			}
; 11295: 			return;
; 11296: 		}
; 11297: 	}
; 11298: #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830		//  
; 11299: 	if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].IsItem() == TRUE )
; 11300: 	{
; 11301: 		if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 39 ) )
; 11302: 		{
; 11303: 			int dur = ( int )lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability;
; 11304: 			lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability -= (float)0.02;
; 11305: 			
; 11306: 			if( dur > ( int )lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability ) 
; 11307: 			{
; 11308: 				if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability < 1 ) 
; 11309: 					lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability = 0;
; 11310: 
; 11311: 				BYTE send_dur = ( BYTE )lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability;
; 11312: 				GCItemDurSend( lpObj->m_Index, EQUIPMENT_RING_RIGHT, send_dur, 0 );
; 11313: 				if( send_dur == 0 ) 
; 11314: 				{
; 11315: 					gObjUseSkill.SkillChangeUse( lpObj->m_Index );
; 11316: 					LogAddTD( lMsg.Get( 544 ), lpObj->AccountID, lpObj->Name, lpObj->pInventory[EQUIPMENT_RING_RIGHT].GetName(), lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Level, send_dur );
; 11317: 					lpObj->pInventory[EQUIPMENT_RING_RIGHT].Clear();
; 11318: 					GCInventoryItemDeleteSend( lpObj->m_Index, EQUIPMENT_RING_RIGHT, 0 );
; 11319: 				}
; 11320: 			}
; 11321: 			return;
; 11322: 		}
; 11323: 	}
; 11324: 	if( lpObj->pInventory[EQUIPMENT_RING_LEFT].IsItem() == TRUE )
; 11325: 	{
; 11326: 		if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 39 ) )
; 11327: 		{
; 11328: 			int dur = ( int )lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability;
; 11329: 			lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability -= ( float )0.02;
; 11330: 			if( dur > ( int )lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability ) 
; 11331: 			{
; 11332: 				if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability < 1 )
; 11333: 					lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability = 0;
; 11334: 
; 11335: 				BYTE send_dur = ( BYTE )lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability;
; 11336: 				GCItemDurSend( lpObj->m_Index, EQUIPMENT_RING_LEFT, (BYTE)send_dur, 0 );
; 11337: 				if( send_dur == 0 ) 
; 11338: 				{	
; 11339: 					gObjUseSkill.SkillChangeUse( lpObj->m_Index );
; 11340: 					LogAddTD(lMsg.Get( 544 ), lpObj->AccountID, lpObj->Name, lpObj->pInventory[EQUIPMENT_RING_RIGHT].GetName(), lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Level, send_dur );
; 11341: 					lpObj->pInventory[EQUIPMENT_RING_LEFT].Clear();
; 11342: 					GCInventoryItemDeleteSend( lpObj->m_Index, EQUIPMENT_RING_LEFT, 0 );					
; 11343: 				}
; 11344: 			}
; 11345: 			return;
; 11346: 		}
; 11347: 	}
; 11348: #endif	// ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	
; 11349: 	
; 11350: #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 11351: 	if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].IsItem() == TRUE )
; 11352: 	{
; 11353: 		if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 40 ) )
; 11354: 		{
; 11355: 			int iDuration = (int)lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability;
; 11356: 			lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability -= (float)0.02;
; 11357: 			if( iDuration > (int)lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability )
; 11358: 			{
; 11359: 				if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability < 1 )
; 11360: 				{
; 11361: 					lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability = 0;
; 11362: 				}
; 11363: 
; 11364: 				BYTE btSendDuration = (BYTE)lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability;
; 11365: 				GCItemDurSend( lpObj->m_Index, EQUIPMENT_RING_RIGHT, (BYTE)btSendDuration, 0 );
; 11366: 				if( btSendDuration == 0 )
; 11367: 				{
; 11368: 					gObjUseSkill.SkillChangeUse( lpObj->m_Index );
; 11369: 					LogAddTD( lMsg.Get( 544 ), lpObj->AccountID, lpObj->Name, lpObj->pInventory[EQUIPMENT_RING_RIGHT].GetName(), lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Level, btSendDuration );
; 11370: 					lpObj->pInventory[EQUIPMENT_RING_RIGHT].Clear();
; 11371: 					GCInventoryItemDeleteSend( lpObj->m_Index, EQUIPMENT_RING_RIGHT, 0 );
; 11372: 				}
; 11373: 			}
; 11374: 
; 11375: 			return;
; 11376: 		}
; 11377: 	}
; 11378: 
; 11379: 	if( lpObj->pInventory[EQUIPMENT_RING_LEFT].IsItem() == TRUE )
; 11380: 	{
; 11381: 		if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 40 ) )
; 11382: 		{
; 11383: 			int iDuration = (int)lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability;
; 11384: 			lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability -= (float)0.02;
; 11385: 			if( iDuration > (int)lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability )
; 11386: 			{
; 11387: 				if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability < 1 )
; 11388: 				{
; 11389: 					lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability = 0;
; 11390: 				}
; 11391: 
; 11392: 				BYTE btSendDuration = (BYTE)lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability;
; 11393: 				GCItemDurSend( lpObj->m_Index, EQUIPMENT_RING_LEFT, (BYTE)btSendDuration, 0 );
; 11394: 				if( btSendDuration == 0 )
; 11395: 				{
; 11396: 					gObjUseSkill.SkillChangeUse( lpObj->m_Index );
; 11397: 					LogAddTD( lMsg.Get( 544 ), lpObj->AccountID, lpObj->Name, lpObj->pInventory[EQUIPMENT_RING_LEFT].GetName(), lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Level, btSendDuration );
; 11398: 					lpObj->pInventory[EQUIPMENT_RING_LEFT].Clear();
; 11399: 					GCInventoryItemDeleteSend( lpObj->m_Index, EQUIPMENT_RING_LEFT, 0 );
; 11400: 				}
; 11401: 			}
; 11402: 
; 11403: 			return;
; 11404: 		}
; 11405: 	}
; 11406: #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 11407: 	
; 11408: #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 11409: 	if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].IsItem() == TRUE )
; 11410: 	{
; 11411: 		if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 41 ) )
; 11412: 		{
; 11413: 			int iDuration = (int)lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability;
; 11414: 			lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability -= (float)0.02;
; 11415: 			if( iDuration > (int)lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability )
; 11416: 			{
; 11417: 				if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability < 1 )
; 11418: 				{
; 11419: 					lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability = 0;
; 11420: 				}
; 11421: 				
; 11422: 				BYTE btSendDuration = (BYTE)lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability;
; 11423: 				GCItemDurSend( lpObj->m_Index, EQUIPMENT_RING_RIGHT, (BYTE)btSendDuration, 0 );
; 11424: 				if( btSendDuration == 0 )
; 11425: 				{
; 11426: 					gObjUseSkill.SkillChangeUse( lpObj->m_Index );
; 11427: 					LogAddTD( lMsg.Get( 544 ), lpObj->AccountID, lpObj->Name, lpObj->pInventory[EQUIPMENT_RING_RIGHT].GetName(), lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Level, btSendDuration );
; 11428: 					lpObj->pInventory[EQUIPMENT_RING_RIGHT].Clear();
; 11429: 					GCInventoryItemDeleteSend( lpObj->m_Index, EQUIPMENT_RING_RIGHT, 0 );
; 11430: 				}
; 11431: 			}
; 11432: 			
; 11433: 			return;
; 11434: 		}
; 11435: 	}
; 11436: 	
; 11437: 	if( lpObj->pInventory[EQUIPMENT_RING_LEFT].IsItem() == TRUE )
; 11438: 	{
; 11439: 		if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 41 ) )
; 11440: 		{
; 11441: 			int iDuration = (int)lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability;
; 11442: 			lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability -= (float)0.02;
; 11443: 			if( iDuration > (int)lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability )
; 11444: 			{
; 11445: 				if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability < 1 )
; 11446: 				{
; 11447: 					lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability = 0;
; 11448: 				}
; 11449: 				
; 11450: 				BYTE btSendDuration = (BYTE)lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability;
; 11451: 				GCItemDurSend( lpObj->m_Index, EQUIPMENT_RING_LEFT, (BYTE)btSendDuration, 0 );
; 11452: 				if( btSendDuration == 0 )
; 11453: 				{
; 11454: 					gObjUseSkill.SkillChangeUse( lpObj->m_Index );
; 11455: 					LogAddTD( lMsg.Get( 544 ), lpObj->AccountID, lpObj->Name, lpObj->pInventory[EQUIPMENT_RING_LEFT].GetName(), lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Level, btSendDuration );
; 11456: 					lpObj->pInventory[EQUIPMENT_RING_LEFT].Clear();
; 11457: 					GCInventoryItemDeleteSend( lpObj->m_Index, EQUIPMENT_RING_LEFT, 0 );
; 11458: 				}
; 11459: 			}
; 11460: 			
; 11461: 			return;
; 11462: 		}
; 11463: 	}
; 11464: #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117	
; 11465: 
; 11466: #ifdef UPDATE_GM_FUNCTION_20070228
; 11467: 	if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].IsItem() == TRUE )
; 11468: 	{
; 11469: 		if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 42 ) )
; 11470: 		{
; 11471: 			return;
; 11472: 		}
; 11473: 	}
; 11474: 
; 11475: 	if( lpObj->pInventory[EQUIPMENT_RING_LEFT].IsItem() == TRUE )
; 11476: 	{
; 11477: 		if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 42 ) )
; 11478: 		{
; 11479: 			return;
; 11480: 		}
; 11481: 	}
; 11482: #endif
; 11483: 
; 11484: //------------->
; 11485: //20081013    - (grooving)
; 11486: #ifdef ADD_XMASEVENT_POLYMORPH_RING_20080930
; 11487: 	if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].IsItem() == TRUE )
; 11488: 	{
; 11489: 		if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 68 ) )
; 11490: 		{
; 11491: 			int iDuration = (int)lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability;
; 11492: 			lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability -= (float)0.02;
; 11493: 			if( iDuration > (int)lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability )
; 11494: 			{
; 11495: 				if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability < 1 )
; 11496: 				{
; 11497: 					lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability = 0;
; 11498: 				}
; 11499: 				
; 11500: 				BYTE btSendDuration = (BYTE)lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability;
; 11501: 				GCItemDurSend( lpObj->m_Index, EQUIPMENT_RING_RIGHT, (BYTE)btSendDuration, 0 );
; 11502: 				if( btSendDuration == 0 )
; 11503: 				{
; 11504: 					gObjUseSkill.SkillChangeUse( lpObj->m_Index );
; 11505: 					LogAddTD( lMsg.Get( 544 ), lpObj->AccountID, lpObj->Name, lpObj->pInventory[EQUIPMENT_RING_RIGHT].GetName(), lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Level, btSendDuration );
; 11506: 					lpObj->pInventory[EQUIPMENT_RING_RIGHT].Clear();
; 11507: 					GCInventoryItemDeleteSend( lpObj->m_Index, EQUIPMENT_RING_RIGHT, 0 );
; 11508: 				}
; 11509: 			}
; 11510: 			
; 11511: 			return;
; 11512: 		}
; 11513: 	}
; 11514: 	
; 11515: 	if( lpObj->pInventory[EQUIPMENT_RING_LEFT].IsItem() == TRUE )
; 11516: 	{
; 11517: 		if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 68 ) )
; 11518: 		{
; 11519: 			int iDuration = (int)lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability;
; 11520: 			lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability -= (float)0.02;
; 11521: 			if( iDuration > (int)lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability )
; 11522: 			{
; 11523: 				if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability < 1 )
; 11524: 				{
; 11525: 					lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability = 0;
; 11526: 				}
; 11527: 				
; 11528: 				BYTE btSendDuration = (BYTE)lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability;
; 11529: 				GCItemDurSend( lpObj->m_Index, EQUIPMENT_RING_LEFT, (BYTE)btSendDuration, 0 );
; 11530: 				if( btSendDuration == 0 )
; 11531: 				{
; 11532: 					gObjUseSkill.SkillChangeUse( lpObj->m_Index );
; 11533: 					LogAddTD( lMsg.Get( 544 ), lpObj->AccountID, lpObj->Name, lpObj->pInventory[EQUIPMENT_RING_LEFT].GetName(), lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Level, btSendDuration );
; 11534: 					lpObj->pInventory[EQUIPMENT_RING_LEFT].Clear();
; 11535: 					GCInventoryItemDeleteSend( lpObj->m_Index, EQUIPMENT_RING_LEFT, 0 );
; 11536: 				}
; 11537: 			}
; 11538: 			
; 11539: 			return;
; 11540: 		}
; 11541: 	}
; 11542: #endif //ADD_XMASEVENT_POLYMORPH_RING_20080930
; 11543: //<-------------
; 11544: 
; 11545: #ifdef ADD_PREMIUMITEM_PANDA
; 11546: 	if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].IsItem() == TRUE && lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 76 ) )
; 11547: 	{
; 11548: 		int iDuration = (int)lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability;
; 11549: 		lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability -= (float)0.01;
; 11550: 		if( iDuration > (int)lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability )
; 11551: 		{
; 11552: 			if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability < 1 )
; 11553: 			{
; 11554: 				lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability = 0;
; 11555: 			}
; 11556: 			
; 11557: 			BYTE btSendDuration = (BYTE)lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability;
; 11558: 			GCItemDurSend( lpObj->m_Index, EQUIPMENT_RING_RIGHT, (BYTE)btSendDuration, 0 );
; 11559: 			if( btSendDuration == 0 )
; 11560: 			{
; 11561: 				gObjUseSkill.SkillChangeUse( lpObj->m_Index );
; 11562: 				LogAddTD( lMsg.Get( 544 ), lpObj->AccountID, lpObj->Name, lpObj->pInventory[EQUIPMENT_RING_RIGHT].GetName(), lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Level, btSendDuration );
; 11563: 				lpObj->pInventory[EQUIPMENT_RING_RIGHT].Clear();
; 11564: 				GCInventoryItemDeleteSend( lpObj->m_Index, EQUIPMENT_RING_RIGHT, 0 );
; 11565: 			}
; 11566: 		}
; 11567: 			
; 11568: 		return;
; 11569: 	}
; 11570: 	
; 11571: 	if( lpObj->pInventory[EQUIPMENT_RING_LEFT].IsItem() == TRUE && lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 76 ) )
; 11572: 	{
; 11573: 		int iDuration = (int)lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability;
; 11574: 		lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability -= (float)0.01;
; 11575: 		if( iDuration > (int)lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability )
; 11576: 		{
; 11577: 			if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability < 1 )
; 11578: 			{
; 11579: 				lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability = 0;
; 11580: 			}
; 11581: 			
; 11582: 			BYTE btSendDuration = (BYTE)lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability;
; 11583: 			GCItemDurSend( lpObj->m_Index, EQUIPMENT_RING_LEFT, (BYTE)btSendDuration, 0 );
; 11584: 			if( btSendDuration == 0 )
; 11585: 			{
; 11586: 				gObjUseSkill.SkillChangeUse( lpObj->m_Index );
; 11587: 				LogAddTD( lMsg.Get( 544 ), lpObj->AccountID, lpObj->Name, lpObj->pInventory[EQUIPMENT_RING_LEFT].GetName(), lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Level, btSendDuration );
; 11588: 				lpObj->pInventory[EQUIPMENT_RING_LEFT].Clear();
; 11589: 				GCInventoryItemDeleteSend( lpObj->m_Index, EQUIPMENT_RING_LEFT, 0 );
; 11590: 			}
; 11591: 		}
; 11592: 		
; 11593: 		return;
; 11594: 	}
; 11595: #endif // ADD_PREMIUMITEM_PANDA
; 11596: }

  00394	5f		 pop	 edi
  00395	5e		 pop	 esi
  00396	5b		 pop	 ebx
  00397	8b e5		 mov	 esp, ebp
  00399	5d		 pop	 ebp
  0039a	c3		 ret	 0
?gObjChangeDurProc@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; gObjChangeDurProc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjChaosBoxDeleteItem@@YAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_itempos$ = 12						; size = 4
?gObjChaosBoxDeleteItem@@YAEHH@Z PROC			; gObjChaosBoxDeleteItem, COMDAT

; 14919: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14920: 	//    .
; 14921: 	gObjChaosItemSet(aIndex, itempos, 0xFF);

  00009	68 ff 00 00 00	 push	 255			; 000000ffH
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ?gObjChaosItemSet@@YAXHHE@Z ; gObjChaosItemSet
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14922: 	gObj[aIndex].pChaosBox[itempos].Clear();

  0001e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00025	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _itempos$[ebp], 168
  0002c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00032	03 8c 02 ac 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3244]
  00039	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14923: 	return TRUE;

  0003e	b0 01		 mov	 al, 1

; 14924: }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?gObjChaosBoxDeleteItem@@YAEHH@Z ENDP			; gObjChaosBoxDeleteItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjWarehouseDeleteItem@@YAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_itempos$ = 12						; size = 4
?gObjWarehouseDeleteItem@@YAEHH@Z PROC			; gObjWarehouseDeleteItem, COMDAT

; 14910: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14911: 	//    .
; 14912: 	gObjWarehouseItemSet(aIndex, itempos, 0xFF);

  00009	68 ff 00 00 00	 push	 255			; 000000ffH
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ?gObjWarehouseItemSet@@YAXHHE@Z ; gObjWarehouseItemSet
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14913: 	gObj[aIndex].pWarehouse[itempos].Clear();

  0001e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00025	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _itempos$[ebp], 168
  0002c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00032	03 8c 02 94 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3220]
  00039	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14914: 	return TRUE;

  0003e	b0 01		 mov	 al, 1

; 14915: }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?gObjWarehouseDeleteItem@@YAEHH@Z ENDP			; gObjWarehouseDeleteItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z
_TEXT	SEGMENT
tv200 = -420						; size = 4
tv181 = -420						; size = 4
_number$ = -352						; size = 4
_count$ = -348						; size = 4
_lpObj$ = -344						; size = 4
_win_user$ = -340					; size = 4
_lose_user$ = -336					; size = 4
_r_usercount$ = -332					; size = 4
_r_userindex$ = -328					; size = 320
_n$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpWinGuild$ = 8					; size = 4
_lpLoseGuild$ = 12					; size = 4
?gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z PROC ; gObjGuildWarItemGive, COMDAT

; 29321: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 01 00
	00		 sub	 esp, 420		; 000001a4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 29322: 	return TRUE;

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	e9 d7 03 00 00	 jmp	 $LN1@gObjGuildW

; 29323: 	int n;
; 29324: 	int r_userindex[MAX_GUILD];	//
; 29325: 	int r_usercount=0;

  00020	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _r_usercount$[ebp], 0

; 29326: 	int lose_user=-1;

  0002a	c7 85 b0 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _lose_user$[ebp], -1

; 29327: 	int win_user=-1;

  00034	c7 85 ac fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _win_user$[ebp], -1

; 29328: 
; 29329: 	for( n=0; n<MAX_GUILD; n++)

  0003e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00045	eb 09		 jmp	 SHORT $LN4@gObjGuildW
$LN2@gObjGuildW:
  00047	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0004a	83 c0 01	 add	 eax, 1
  0004d	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjGuildW:
  00050	83 7d f8 50	 cmp	 DWORD PTR _n$[ebp], 80	; 00000050H
  00054	7d 3d		 jge	 SHORT $LN3@gObjGuildW

; 29330: 	{
; 29331: 		if( lpLoseGuild->Use[n] > 0 )	//  

  00056	8b 45 0c	 mov	 eax, DWORD PTR _lpLoseGuild$[ebp]
  00059	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  0005c	0f b6 88 40 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1088]
  00063	85 c9		 test	 ecx, ecx
  00065	7e 2a		 jle	 SHORT $LN12@gObjGuildW

; 29332: 		{
; 29333: 			r_userindex[r_usercount] = lpLoseGuild->Index[n];

  00067	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _lpLoseGuild$[ebp]
  0006d	0f bf 94 41 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+928]
  00075	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _r_usercount$[ebp]
  0007b	89 94 85 b8 fe
	ff ff		 mov	 DWORD PTR _r_userindex$[ebp+eax*4], edx

; 29334: 			r_usercount++;

  00082	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _r_usercount$[ebp]
  00088	83 c0 01	 add	 eax, 1
  0008b	89 85 b4 fe ff
	ff		 mov	 DWORD PTR _r_usercount$[ebp], eax
$LN12@gObjGuildW:

; 29335: 		}
; 29336: 	}

  00091	eb b4		 jmp	 SHORT $LN2@gObjGuildW
$LN3@gObjGuildW:

; 29337: 	if( r_usercount < 1 ) 

  00093	83 bd b4 fe ff
	ff 01		 cmp	 DWORD PTR _r_usercount$[ebp], 1
  0009a	7d 2f		 jge	 SHORT $LN13@gObjGuildW

; 29338: 	{
; 29339: 		LogAdd(lMsg.Get(560), __FILE__, __LINE__);

  0009c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z@4JA
  000a1	83 c0 12	 add	 eax, 18			; 00000012H
  000a4	50		 push	 eax
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000aa	68 30 02 00 00	 push	 560			; 00000230H
  000af	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000ba	50		 push	 eax
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 29340: 		return FALSE;

  000c4	33 c0		 xor	 eax, eax
  000c6	e9 2c 03 00 00	 jmp	 $LN1@gObjGuildW
$LN13@gObjGuildW:

; 29341: 	}
; 29342: 	lose_user = r_userindex[rand()%r_usercount];

  000cb	e8 00 00 00 00	 call	 _rand
  000d0	99		 cdq
  000d1	f7 bd b4 fe ff
	ff		 idiv	 DWORD PTR _r_usercount$[ebp]
  000d7	8b 84 95 b8 fe
	ff ff		 mov	 eax, DWORD PTR _r_userindex$[ebp+edx*4]
  000de	89 85 b0 fe ff
	ff		 mov	 DWORD PTR _lose_user$[ebp], eax

; 29343: 	if( lose_user < 0 )

  000e4	83 bd b0 fe ff
	ff 00		 cmp	 DWORD PTR _lose_user$[ebp], 0
  000eb	7d 2f		 jge	 SHORT $LN14@gObjGuildW

; 29344: 	{
; 29345: 		LogAdd(lMsg.Get(560),__FILE__, __LINE__);

  000ed	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z@4JA
  000f2	83 c0 18	 add	 eax, 24			; 00000018H
  000f5	50		 push	 eax
  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000fb	68 30 02 00 00	 push	 560			; 00000230H
  00100	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0010b	50		 push	 eax
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00112	83 c4 0c	 add	 esp, 12			; 0000000cH

; 29346: 		return FALSE;

  00115	33 c0		 xor	 eax, eax
  00117	e9 db 02 00 00	 jmp	 $LN1@gObjGuildW
$LN14@gObjGuildW:

; 29347: 	}
; 29348: 	if( gObj[lose_user].Connected < 3 ) 

  0011c	69 85 b0 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _lose_user$[ebp], 7072
  00126	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0012c	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00131	7d 2f		 jge	 SHORT $LN15@gObjGuildW

; 29349: 	{
; 29350: 		LogAdd(lMsg.Get(560),__FILE__, __LINE__);

  00133	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z@4JA
  00138	83 c0 1d	 add	 eax, 29			; 0000001dH
  0013b	50		 push	 eax
  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00141	68 30 02 00 00	 push	 560			; 00000230H
  00146	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00151	50		 push	 eax
  00152	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00158	83 c4 0c	 add	 esp, 12			; 0000000cH

; 29351: 		return FALSE;

  0015b	33 c0		 xor	 eax, eax
  0015d	e9 95 02 00 00	 jmp	 $LN1@gObjGuildW
$LN15@gObjGuildW:

; 29352: 	}
; 29353: 	r_usercount = 0;

  00162	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _r_usercount$[ebp], 0

; 29354: 	for( n=0; n<MAX_GUILD; n++)

  0016c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00173	eb 09		 jmp	 SHORT $LN7@gObjGuildW
$LN5@gObjGuildW:
  00175	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00178	83 c0 01	 add	 eax, 1
  0017b	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN7@gObjGuildW:
  0017e	83 7d f8 50	 cmp	 DWORD PTR _n$[ebp], 80	; 00000050H
  00182	7d 3d		 jge	 SHORT $LN6@gObjGuildW

; 29355: 	{
; 29356: 		if( lpWinGuild->Use[n] > 0 )	//  

  00184	8b 45 08	 mov	 eax, DWORD PTR _lpWinGuild$[ebp]
  00187	03 45 f8	 add	 eax, DWORD PTR _n$[ebp]
  0018a	0f b6 88 40 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1088]
  00191	85 c9		 test	 ecx, ecx
  00193	7e 2a		 jle	 SHORT $LN16@gObjGuildW

; 29357: 		{
; 29358: 			r_userindex[r_usercount] = lpWinGuild->Index[n];

  00195	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00198	8b 4d 08	 mov	 ecx, DWORD PTR _lpWinGuild$[ebp]
  0019b	0f bf 94 41 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+928]
  001a3	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _r_usercount$[ebp]
  001a9	89 94 85 b8 fe
	ff ff		 mov	 DWORD PTR _r_userindex$[ebp+eax*4], edx

; 29359: 			r_usercount++;

  001b0	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _r_usercount$[ebp]
  001b6	83 c0 01	 add	 eax, 1
  001b9	89 85 b4 fe ff
	ff		 mov	 DWORD PTR _r_usercount$[ebp], eax
$LN16@gObjGuildW:

; 29360: 		}
; 29361: 	}

  001bf	eb b4		 jmp	 SHORT $LN5@gObjGuildW
$LN6@gObjGuildW:

; 29362: 	if( r_usercount < 1 ) 

  001c1	83 bd b4 fe ff
	ff 01		 cmp	 DWORD PTR _r_usercount$[ebp], 1
  001c8	7d 21		 jge	 SHORT $LN17@gObjGuildW

; 29363: 	{
; 29364: 		LogAdd(lMsg.Get(561));

  001ca	68 31 02 00 00	 push	 561			; 00000231H
  001cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001da	50		 push	 eax
  001db	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001e1	83 c4 04	 add	 esp, 4

; 29365: 		return FALSE;

  001e4	33 c0		 xor	 eax, eax
  001e6	e9 0c 02 00 00	 jmp	 $LN1@gObjGuildW
$LN17@gObjGuildW:

; 29366: 	}
; 29367: 	win_user = r_userindex[rand()%r_usercount];

  001eb	e8 00 00 00 00	 call	 _rand
  001f0	99		 cdq
  001f1	f7 bd b4 fe ff
	ff		 idiv	 DWORD PTR _r_usercount$[ebp]
  001f7	8b 84 95 b8 fe
	ff ff		 mov	 eax, DWORD PTR _r_userindex$[ebp+edx*4]
  001fe	89 85 ac fe ff
	ff		 mov	 DWORD PTR _win_user$[ebp], eax

; 29368: 	if( win_user  < 0 )

  00204	83 bd ac fe ff
	ff 00		 cmp	 DWORD PTR _win_user$[ebp], 0
  0020b	7d 21		 jge	 SHORT $LN18@gObjGuildW

; 29369: 	{
; 29370: 		LogAdd(lMsg.Get(561));

  0020d	68 31 02 00 00	 push	 561			; 00000231H
  00212	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00217	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0021d	50		 push	 eax
  0021e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00224	83 c4 04	 add	 esp, 4

; 29371: 		return FALSE;

  00227	33 c0		 xor	 eax, eax
  00229	e9 c9 01 00 00	 jmp	 $LN1@gObjGuildW
$LN18@gObjGuildW:

; 29372: 	}
; 29373: 	if( gObj[win_user].Connected < 3 ) 

  0022e	69 85 ac fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _win_user$[ebp], 7072
  00238	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0023e	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00243	7d 21		 jge	 SHORT $LN19@gObjGuildW

; 29374: 	{
; 29375: 		LogAdd(lMsg.Get(561));

  00245	68 31 02 00 00	 push	 561			; 00000231H
  0024a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0024f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00255	50		 push	 eax
  00256	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0025c	83 c4 04	 add	 esp, 4

; 29376: 		return FALSE;

  0025f	33 c0		 xor	 eax, eax
  00261	e9 91 01 00 00	 jmp	 $LN1@gObjGuildW
$LN19@gObjGuildW:

; 29377: 	}
; 29378: 
; 29379: 	LPOBJECTSTRUCT	lpObj;
; 29380: 	lpObj = &gObj[lose_user];

  00266	69 85 b0 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _lose_user$[ebp], 7072
  00270	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00276	89 85 a8 fe ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], eax

; 29381: 
; 29382: 	int count = MAX_EQUIPMENT*2;

  0027c	c7 85 a4 fe ff
	ff 18 00 00 00	 mov	 DWORD PTR _count$[ebp], 24 ; 00000018H
$LN8@gObjGuildW:

; 29383: 	int number;
; 29384: 	
; 29385: 	while( count-- )

  00286	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  0028c	89 85 5c fe ff
	ff		 mov	 DWORD PTR tv181[ebp], eax
  00292	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR _count$[ebp]
  00298	83 e9 01	 sub	 ecx, 1
  0029b	89 8d a4 fe ff
	ff		 mov	 DWORD PTR _count$[ebp], ecx
  002a1	83 bd 5c fe ff
	ff 00		 cmp	 DWORD PTR tv181[ebp], 0
  002a8	0f 84 87 00 00
	00		 je	 $LN9@gObjGuildW

; 29386: 	{
; 29387: 		number = (rand()%MAX_EQUIPMENT);

  002ae	e8 00 00 00 00	 call	 _rand
  002b3	99		 cdq
  002b4	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  002b9	f7 f9		 idiv	 ecx
  002bb	89 95 a0 fe ff
	ff		 mov	 DWORD PTR _number$[ebp], edx

; 29388: 		
; 29389: 		//    .
; 29390: 		if( lpObj->pInventory[number].IsItem() == TRUE )

  002c1	69 8d a0 fe ff
	ff a8 00 00 00	 imul	 ecx, DWORD PTR _number$[ebp], 168
  002cb	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d1	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  002d7	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  002dc	83 f8 01	 cmp	 eax, 1
  002df	75 4f		 jne	 SHORT $LN20@gObjGuildW

; 29391: 		{			
; 29392: 			if( gObjInventoryInsertItem(win_user, lpObj->pInventory[number]) != 0xFF )

  002e1	69 85 a0 fe ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _number$[ebp], 168
  002eb	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002f1	8b b1 5c 0c 00
	00		 mov	 esi, DWORD PTR [ecx+3164]
  002f7	03 f0		 add	 esi, eax
  002f9	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  002ff	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00304	8b fc		 mov	 edi, esp
  00306	f3 a5		 rep movsd
  00308	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR _win_user$[ebp]
  0030e	52		 push	 edx
  0030f	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHVCItem@@@Z ; gObjInventoryInsertItem
  00314	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  0031a	0f b6 c0	 movzx	 eax, al
  0031d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00322	74 0a		 je	 SHORT $LN21@gObjGuildW

; 29393: 			{
; 29394: 				/*
; 29395: 				LogAdd("%s  ", lpObj->pInventory[number].GetName());
; 29396: 				char szTemp[256];
; 29397: 				wsprintf(szTemp, "  %s   .", lpObj->pInventory[number].GetName());
; 29398: 				GCServerMsgStringSend(szTemp, lose_user, 1);
; 29399: 				
; 29400: 				wsprintf(szTemp, "  %s   .", lpObj->pInventory[number].GetName());
; 29401: 				GCServerMsgStringSend(szTemp, win_user, 1);
; 29402: 
; 29403: 				gObjInventoryDeleteItem(lose_user, number);
; 29404: 				GCInventoryItemDeleteSend(lose_user, number, 0);
; 29405: 
; 29406: 				GCEquipmentSend(lose_user);
; 29407: 				GCItemListSend(win_user);
; 29408: 				*/
; 29409: 				return TRUE;

  00324	b8 01 00 00 00	 mov	 eax, 1
  00329	e9 c9 00 00 00	 jmp	 $LN1@gObjGuildW
$LN21@gObjGuildW:

; 29410: 			}
; 29411: 			break;

  0032e	eb 05		 jmp	 SHORT $LN9@gObjGuildW
$LN20@gObjGuildW:

; 29412: 		}
; 29413: 	}

  00330	e9 51 ff ff ff	 jmp	 $LN8@gObjGuildW
$LN9@gObjGuildW:

; 29414: 	
; 29415: 	//   .
; 29416: 	count=MAX_INVENTORY-MAX_EQUIPMENT;

  00335	c7 85 a4 fe ff
	ff 40 00 00 00	 mov	 DWORD PTR _count$[ebp], 64 ; 00000040H
$LN10@gObjGuildW:

; 29417: 	while(count--)	

  0033f	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  00345	89 85 5c fe ff
	ff		 mov	 DWORD PTR tv200[ebp], eax
  0034b	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR _count$[ebp]
  00351	83 e9 01	 sub	 ecx, 1
  00354	89 8d a4 fe ff
	ff		 mov	 DWORD PTR _count$[ebp], ecx
  0035a	83 bd 5c fe ff
	ff 00		 cmp	 DWORD PTR tv200[ebp], 0
  00361	0f 84 8b 00 00
	00		 je	 $LN11@gObjGuildW

; 29418: 	{
; 29419: 		number = MAX_EQUIPMENT+(rand()%(MAX_INVENTORY-MAX_EQUIPMENT));

  00367	e8 00 00 00 00	 call	 _rand
  0036c	25 3f 00 00 80	 and	 eax, -2147483585	; 8000003fH
  00371	79 05		 jns	 SHORT $LN25@gObjGuildW
  00373	48		 dec	 eax
  00374	83 c8 c0	 or	 eax, -64		; ffffffc0H
  00377	40		 inc	 eax
$LN25@gObjGuildW:
  00378	83 c0 0c	 add	 eax, 12			; 0000000cH
  0037b	89 85 a0 fe ff
	ff		 mov	 DWORD PTR _number$[ebp], eax

; 29420: 		
; 29421: 		//   .
; 29422: 		if( lpObj->pInventory[number].IsItem() == TRUE )

  00381	69 8d a0 fe ff
	ff a8 00 00 00	 imul	 ecx, DWORD PTR _number$[ebp], 168
  0038b	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00391	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00397	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0039c	83 f8 01	 cmp	 eax, 1
  0039f	75 4c		 jne	 SHORT $LN22@gObjGuildW

; 29423: 		{			
; 29424: 			if( gObjInventoryInsertItem(win_user, lpObj->pInventory[number]) != 0xFF )

  003a1	69 85 a0 fe ff
	ff a8 00 00 00	 imul	 eax, DWORD PTR _number$[ebp], 168
  003ab	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003b1	8b b1 5c 0c 00
	00		 mov	 esi, DWORD PTR [ecx+3164]
  003b7	03 f0		 add	 esi, eax
  003b9	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  003bf	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  003c4	8b fc		 mov	 edi, esp
  003c6	f3 a5		 rep movsd
  003c8	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR _win_user$[ebp]
  003ce	52		 push	 edx
  003cf	e8 00 00 00 00	 call	 ?gObjInventoryInsertItem@@YAEHVCItem@@@Z ; gObjInventoryInsertItem
  003d4	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  003da	0f b6 c0	 movzx	 eax, al
  003dd	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  003e2	74 07		 je	 SHORT $LN23@gObjGuildW

; 29425: 			{
; 29426: 				/*LogAdd("%s  ", lpObj->pInventory[number].GetName());
; 29427: 				char szTemp[256];
; 29428: 				wsprintf(szTemp, "  %s   .", lpObj->pInventory[number].GetName());
; 29429: 				GCServerMsgStringSend(szTemp, lose_user, 1);
; 29430: 				
; 29431: 				wsprintf(szTemp, "  %s   .", lpObj->pInventory[number].GetName());
; 29432: 				GCServerMsgStringSend(szTemp, win_user, 1);
; 29433: 
; 29434: 				gObjInventoryDeleteItem(lose_user, number);
; 29435: 				GCInventoryItemDeleteSend(lose_user, number, 0);
; 29436: 
; 29437: 				GCEquipmentSend(lose_user);
; 29438: 				GCItemListSend(win_user);
; 29439: 				*/
; 29440: 				return TRUE;

  003e4	b8 01 00 00 00	 mov	 eax, 1
  003e9	eb 0c		 jmp	 SHORT $LN1@gObjGuildW
$LN23@gObjGuildW:

; 29441: 			}
; 29442: 			break;

  003eb	eb 05		 jmp	 SHORT $LN11@gObjGuildW
$LN22@gObjGuildW:

; 29443: 		}
; 29444: 	}

  003ed	e9 4d ff ff ff	 jmp	 $LN10@gObjGuildW
$LN11@gObjGuildW:

; 29445: 
; 29446: 	return TRUE;

  003f2	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjGuildW:

; 29447: }

  003f7	5f		 pop	 edi
  003f8	5e		 pop	 esi
  003f9	5b		 pop	 ebx
  003fa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003fd	33 cd		 xor	 ecx, ebp
  003ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00404	8b e5		 mov	 esp, ebp
  00406	5d		 pop	 ebp
  00407	c3		 ret	 0
?gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z ENDP ; gObjGuildWarItemGive
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGuildWarMasterClose@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjGuildWarMasterClose@@YAHPAVOBJECTSTRUCT@@@Z PROC	; gObjGuildWarMasterClose, COMDAT

; 29294: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29295: 	if( lpObj->GuildNumber < 1 ) return FALSE;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	83 b8 90 02 00
	00 01		 cmp	 DWORD PTR [eax+656], 1
  00013	7d 07		 jge	 SHORT $LN2@gObjGuildW
  00015	33 c0		 xor	 eax, eax
  00017	e9 c5 00 00 00	 jmp	 $LN1@gObjGuildW
$LN2@gObjGuildW:

; 29296: 	
; 29297: 	// ..
; 29298: 	if( strcmp(lpObj->lpGuild->Names[0], lpObj->Name) != 0 ) return FALSE;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001f	83 c0 73	 add	 eax, 115		; 00000073H
  00022	50		 push	 eax
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00026	8b 91 94 02 00
	00		 mov	 edx, DWORD PTR [ecx+660]
  0002c	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  00031	6b c8 00	 imul	 ecx, eax, 0
  00034	8d 54 0a 2f	 lea	 edx, DWORD PTR [edx+ecx+47]
  00038	52		 push	 edx
  00039	e8 00 00 00 00	 call	 _strcmp
  0003e	83 c4 08	 add	 esp, 8
  00041	85 c0		 test	 eax, eax
  00043	74 07		 je	 SHORT $LN3@gObjGuildW
  00045	33 c0		 xor	 eax, eax
  00047	e9 95 00 00 00	 jmp	 $LN1@gObjGuildW
$LN3@gObjGuildW:

; 29299: 	
; 29300: 	//   ..
; 29301: 	gObjGuildWarEndSend(lpObj, 0x03, 0x2);

  0004c	6a 02		 push	 2
  0004e	6a 03		 push	 3
  00050	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?gObjGuildWarEndSend@@YAXPAVOBJECTSTRUCT@@EE@Z ; gObjGuildWarEndSend
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 29302: 	if( lpObj->lpGuild->WarType == BTT_SOCCER )

  0005c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005f	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00065	0f b6 91 92 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1426]
  0006c	83 fa 01	 cmp	 edx, 1
  0006f	75 49		 jne	 SHORT $LN4@gObjGuildW

; 29303: 	{
; 29304: #ifdef MODIFY_GUILDWAR_REQUEST_PROCESS_20050704
; 29305: 		if( lpObj->lpGuild->BattleGroundIndex < MAX_BATTLESOCCERGROUND )
; 29306: 		{
; 29307: 			gBattleGroundEnable(lpObj->lpGuild->BattleGroundIndex, 0);
; 29308: 			cManager.BattleInfoSend(GetBattleTeamName(0, 0), 255, GetBattleTeamName(0, 1), 255);
; 29309: 		}
; 29310: #else
; 29311: 		gBattleGroundEnable(lpObj->lpGuild->BattleGroundIndex, 0);

  00071	6a 00		 push	 0
  00073	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00076	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  0007c	0f b6 91 93 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1427]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 ?gBattleGroundEnable@@YAXHH@Z ; gBattleGroundEnable
  00089	83 c4 08	 add	 esp, 8

; 29312: 		cManager.BattleInfoSend(GetBattleTeamName(0, 0), 255, GetBattleTeamName(0, 1), 255);

  0008c	68 ff 00 00 00	 push	 255			; 000000ffH
  00091	6a 01		 push	 1
  00093	6a 00		 push	 0
  00095	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  0009a	83 c4 08	 add	 esp, 8
  0009d	50		 push	 eax
  0009e	68 ff 00 00 00	 push	 255			; 000000ffH
  000a3	6a 00		 push	 0
  000a5	6a 00		 push	 0
  000a7	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  000ac	83 c4 08	 add	 esp, 8
  000af	50		 push	 eax
  000b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  000b5	e8 00 00 00 00	 call	 ?BattleInfoSend@CGMMng@@QAEXPADE0E@Z ; CGMMng::BattleInfoSend
$LN4@gObjGuildW:

; 29313: #endif
; 29314: 	}
; 29315: 	gObjGuildWarEnd(lpObj->lpGuild, lpObj->lpGuild->lpTargetGuildNode);

  000ba	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bd	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  000c3	8b 91 8c 05 00
	00		 mov	 edx, DWORD PTR [ecx+1420]
  000c9	52		 push	 edx
  000ca	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000cd	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarEnd
  000d9	83 c4 08	 add	 esp, 8

; 29316: 	return TRUE;

  000dc	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjGuildW:

; 29317: }

  000e1	5f		 pop	 edi
  000e2	5e		 pop	 esi
  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
?gObjGuildWarMasterClose@@YAHPAVOBJECTSTRUCT@@@Z ENDP	; gObjGuildWarMasterClose
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_lpTargetGuild$ = -12					; size = 4
_lpGuild$ = -8						; size = 4
_score$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z PROC	; gObjGuildWarCheck, COMDAT

; 29166: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29167: 	int score=1;

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _score$[ebp], 1

; 29168: 	LPGUILD_INFO lpGuild;
; 29169: 	LPGUILD_INFO lpTargetGuild;
; 29170: 
; 29171: 
; 29172: 	if( gObjTargetGuildWarCheck(lpObj, lpTargetObj) == FALSE ) return FALSE;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  0001d	83 c4 08	 add	 esp, 8
  00020	85 c0		 test	 eax, eax
  00022	75 07		 jne	 SHORT $LN2@gObjGuildW
  00024	33 c0		 xor	 eax, eax
  00026	e9 0d 01 00 00	 jmp	 $LN1@gObjGuildW
$LN2@gObjGuildW:

; 29173: 
; 29174: 	//   2,   1
; 29175: 	if( strcmp(lpTargetObj->Name, lpTargetObj->lpGuild->Names[0]) == 0 )

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0002e	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00034	ba 0b 00 00 00	 mov	 edx, 11			; 0000000bH
  00039	6b c2 00	 imul	 eax, edx, 0
  0003c	8d 4c 01 2f	 lea	 ecx, DWORD PTR [ecx+eax+47]
  00040	51		 push	 ecx
  00041	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00044	83 c2 73	 add	 edx, 115		; 00000073H
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 _strcmp
  0004d	83 c4 08	 add	 esp, 8
  00050	85 c0		 test	 eax, eax
  00052	75 07		 jne	 SHORT $LN3@gObjGuildW

; 29176: 	{
; 29177: 		score = 2;

  00054	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _score$[ebp], 2
$LN3@gObjGuildW:

; 29178: 	}
; 29179: 	lpGuild = lpObj->lpGuild;

  0005b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005e	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00064	89 4d f8	 mov	 DWORD PTR _lpGuild$[ebp], ecx

; 29180: 	lpTargetGuild = lpTargetObj->lpGuild;

  00067	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0006a	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00070	89 4d f4	 mov	 DWORD PTR _lpTargetGuild$[ebp], ecx

; 29181: 	
; 29182: 	
; 29183: 	if( gObjGuildWarProc(lpGuild, lpTargetGuild, score) == 1 )

  00073	8b 45 fc	 mov	 eax, DWORD PTR _score$[ebp]
  00076	50		 push	 eax
  00077	8b 4d f4	 mov	 ecx, DWORD PTR _lpTargetGuild$[ebp]
  0007a	51		 push	 ecx
  0007b	8b 55 f8	 mov	 edx, DWORD PTR _lpGuild$[ebp]
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 ?gObjGuildWarProc@@YAHPAU_GUILD_INFO_STRUCT@@0H@Z ; gObjGuildWarProc
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH
  00087	83 f8 01	 cmp	 eax, 1
  0008a	0f 85 a3 00 00
	00		 jne	 $LN4@gObjGuildW

; 29184: 	{
; 29185: 		//   ..
; 29186: 		if( lpGuild->WarType == BTT_SOCCER )

  00090	8b 45 f8	 mov	 eax, DWORD PTR _lpGuild$[ebp]
  00093	0f b6 88 92 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1426]
  0009a	83 f9 01	 cmp	 ecx, 1
  0009d	75 69		 jne	 SHORT $LN5@gObjGuildW

; 29187: 		{
; 29188: 			gObjGuildWarEndSend(lpGuild, lpTargetGuild, 0x01, 0x00);

  0009f	6a 00		 push	 0
  000a1	6a 01		 push	 1
  000a3	8b 45 f4	 mov	 eax, DWORD PTR _lpTargetGuild$[ebp]
  000a6	50		 push	 eax
  000a7	8b 4d f8	 mov	 ecx, DWORD PTR _lpGuild$[ebp]
  000aa	51		 push	 ecx
  000ab	e8 00 00 00 00	 call	 ?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z ; gObjGuildWarEndSend
  000b0	83 c4 10	 add	 esp, 16			; 00000010H

; 29189: 			gBattleGroundEnable(lpGuild->BattleGroundIndex, 0);

  000b3	6a 00		 push	 0
  000b5	8b 45 f8	 mov	 eax, DWORD PTR _lpGuild$[ebp]
  000b8	0f b6 88 93 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1427]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ?gBattleGroundEnable@@YAXHH@Z ; gBattleGroundEnable
  000c5	83 c4 08	 add	 esp, 8

; 29190: 			gObjGuildWarEnd(lpGuild, lpTargetGuild);

  000c8	8b 45 f4	 mov	 eax, DWORD PTR _lpTargetGuild$[ebp]
  000cb	50		 push	 eax
  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _lpGuild$[ebp]
  000cf	51		 push	 ecx
  000d0	e8 00 00 00 00	 call	 ?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarEnd
  000d5	83 c4 08	 add	 esp, 8

; 29191: 			cManager.BattleInfoSend(GetBattleTeamName(0, 0), 255, GetBattleTeamName(0, 1), 255);

  000d8	68 ff 00 00 00	 push	 255			; 000000ffH
  000dd	6a 01		 push	 1
  000df	6a 00		 push	 0
  000e1	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  000e6	83 c4 08	 add	 esp, 8
  000e9	50		 push	 eax
  000ea	68 ff 00 00 00	 push	 255			; 000000ffH
  000ef	6a 00		 push	 0
  000f1	6a 00		 push	 0
  000f3	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  000f8	83 c4 08	 add	 esp, 8
  000fb	50		 push	 eax
  000fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  00101	e8 00 00 00 00	 call	 ?BattleInfoSend@CGMMng@@QAEXPADE0E@Z ; CGMMng::BattleInfoSend

; 29192: 
; 29193: #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 29194: 			PMSG_MATCH_RESULT	pMsg;
; 29195: 			PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x24, sizeof( pMsg) );
; 29196: 			pMsg.MatchType	= eMatchType_BattleSoccer;
; 29197: 
; 29198: 			memcpy(pMsg.MatchTeamName1, lpGuild->Name, MAX_IDSTRING);							
; 29199: 			pMsg.Score1 = lpGuild->PlayScore;
; 29200: 
; 29201: 			memcpy(pMsg.MatchTeamName2, lpTargetGuild->Name, MAX_IDSTRING);
; 29202: 			pMsg.Score2 = lpTargetGuild->PlayScore;
; 29203: 
; 29204: 			for( int UserIndex=0; UserIndex<MAX_GUILD; UserIndex++)
; 29205: 			{
; 29206: 				if( lpGuild->Use[UserIndex] )
; 29207: 				{
; 29208: 					int number = lpGuild->Index[UserIndex];
; 29209: 					if( number >= 0 )
; 29210: 					{
; 29211: 						DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);
; 29212: 					}
; 29213: 				}
; 29214: 			}
; 29215: 
; 29216: 			for( UserIndex=0; UserIndex<MAX_GUILD; UserIndex++)
; 29217: 			{
; 29218: 				if( lpTargetGuild->Use[UserIndex] )
; 29219: 				{
; 29220: 					int number = lpTargetGuild->Index[UserIndex];
; 29221: 					if( number >= 0 )
; 29222: 					{
; 29223: 						DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);
; 29224: 					}
; 29225: 				}
; 29226: 			}
; 29227: 
; 29228: 			LogAddTD("[WTEvent] BattleSoccer Result Send = %s-%d %s-%d", 
; 29229: 					 lpGuild->Name , lpGuild->PlayScore, 
; 29230: 					 lpTargetGuild->Name , lpTargetGuild->PlayScore);
; 29231: 
; 29232: #endif
; 29233: 		}

  00106	eb 2b		 jmp	 SHORT $LN4@gObjGuildW
$LN5@gObjGuildW:

; 29234: 		else
; 29235: 		{
; 29236: 			gObjGuildWarEndSend(lpObj, 0x01, 0x00);

  00108	6a 00		 push	 0
  0010a	6a 01		 push	 1
  0010c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 ?gObjGuildWarEndSend@@YAXPAVOBJECTSTRUCT@@EE@Z ; gObjGuildWarEndSend
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH

; 29237: #ifdef CHANGE_GUILD_WAR_END_DELAYTIME
; 29238: 			gObjAddMsgSendDelay(lpObj, MSG_GUILDWAREND, lpObj->m_Index, 1000*2);

  00118	6a 00		 push	 0
  0011a	68 d0 07 00 00	 push	 2000			; 000007d0H
  0011f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00122	8b 08		 mov	 ecx, DWORD PTR [eax]
  00124	51		 push	 ecx
  00125	6a 04		 push	 4
  00127	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  00130	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@gObjGuildW:

; 29239: #else
; 29240: 			gObjAddMsgSendDelay(lpObj, MSG_GUILDWAREND, lpObj->m_Index, 1000*50);
; 29241: #endif
; 29242: 
; 29243: #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 29244: 			PMSG_MATCH_RESULT	pMsg;
; 29245: 			PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x24, sizeof( pMsg) );
; 29246: 			pMsg.MatchType	= eMatchType_GuildWar;
; 29247: 
; 29248: 			memcpy(pMsg.MatchTeamName1, lpGuild->Name, MAX_IDSTRING);							
; 29249: 			pMsg.Score1 = lpGuild->PlayScore;
; 29250: 
; 29251: 			memcpy(pMsg.MatchTeamName2, lpTargetGuild->Name, MAX_IDSTRING);
; 29252: 			pMsg.Score2 = lpTargetGuild->PlayScore;
; 29253: 
; 29254: 			for( int UserIndex=0; UserIndex<MAX_GUILD; UserIndex++)
; 29255: 			{
; 29256: 				if( lpGuild->Use[UserIndex] )
; 29257: 				{
; 29258: 					int number = lpGuild->Index[UserIndex];
; 29259: 					if( number >= 0 )
; 29260: 					{
; 29261: 						DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);
; 29262: 					}
; 29263: 				}
; 29264: 			}
; 29265: 
; 29266: 			for( UserIndex=0; UserIndex<MAX_GUILD; UserIndex++)
; 29267: 			{
; 29268: 				if( lpTargetGuild->Use[UserIndex] )
; 29269: 				{
; 29270: 					int number = lpTargetGuild->Index[UserIndex];
; 29271: 					if( number >= 0 )
; 29272: 					{
; 29273: 						DataSend(number, (LPBYTE)&pMsg, pMsg.h.size);
; 29274: 					}
; 29275: 				}
; 29276: 			}
; 29277: 
; 29278: 			LogAddTD("[WTEvent] GuildWar Result Send = %s-%d %s-%d", 
; 29279: 					 lpGuild->Name , lpGuild->PlayScore, 
; 29280: 					 lpTargetGuild->Name , lpTargetGuild->PlayScore);
; 29281: 
; 29282: #endif
; 29283: 
; 29284: 
; 29285: 		}
; 29286: 	}
; 29287: 	return TRUE;

  00133	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjGuildW:

; 29288: }

  00138	5f		 pop	 edi
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
?gObjGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z ENDP	; gObjGuildWarCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjAuthorityCodeSet@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjAuthorityCodeSet@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjAuthorityCodeSet, COMDAT

; 4486 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4487 : #if 0
; 4488 : 	if( (lpObj->Authority&AUTHORITY_USER) == AUTHORITY_USER )
; 4489 : 	{		
; 4490 : 	}
; 4491 : 	else if( (lpObj->Authority&AUTHORITY_ADMIN) == AUTHORITY_ADMIN)
; 4492 : 	{
; 4493 : 		lpObj->AuthorityCode = AUTHORITY_CODE_FULLCONTROL;
; 4494 : 	}
; 4495 : /*
; 4496 : 	else if( (lpObj->Authority&AUTHORITY_SERVERADMIN) == AUTHORITY_SERVERADMIN)
; 4497 : 	{
; 4498 : 	}
; 4499 : */
; 4500 : 	else if( (lpObj->Authority&AUTHORITY_GM) == AUTHORITY_GM)
; 4501 : 	{
; 4502 : 		lpObj->AuthorityCode |= AUTHORITY_CODE_NOTICE;
; 4503 : 		lpObj->AuthorityCode |= AUTHORITY_CODE_ACCOUNTBLOCK;
; 4504 : 		lpObj->AuthorityCode |= AUTHORITY_CODE_DISCONNECT;
; 4505 : 		lpObj->AuthorityCode |= AUTHORITY_CODE_SETPOSITION;
; 4506 : 		lpObj->AuthorityCode |= AUTHORITY_CODE_COPYCHAR;
; 4507 : 		lpObj->AuthorityCode |= AUTHORITY_CODE_CHATBAN;
; 4508 : 	}
; 4509 : /*
; 4510 : 	else if( (lpObj->Authority&AUTHORITY_SUBGM) == AUTHORITY_SUBGM)
; 4511 : 	{
; 4512 : 	}
; 4513 : */
; 4514 : #ifdef ADD_AUTHORITY_CODE_OF_EVENT_GM_20050602
; 4515 : 	else if( (lpObj->Authority&AUTHORITY_EVENT_GM) == AUTHORITY_EVENT_GM)
; 4516 : 	{
; 4517 : 		lpObj->AuthorityCode |= AUTHORITY_CODE_NOTICE;
; 4518 : 		lpObj->AuthorityCode |= AUTHORITY_CODE_ACCOUNTBLOCK;
; 4519 : 		lpObj->AuthorityCode |= AUTHORITY_CODE_DISCONNECT;
; 4520 : 		lpObj->AuthorityCode |= AUTHORITY_CODE_SETPOSITION;
; 4521 : 		lpObj->AuthorityCode |= AUTHORITY_CODE_COPYCHAR;
; 4522 : 		lpObj->AuthorityCode |= AUTHORITY_CODE_CHATBAN;
; 4523 : 	}
; 4524 : #endif
; 4525 : 	else {}
; 4526 : #endif
; 4527 : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?gObjAuthorityCodeSet@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjAuthorityCodeSet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_n$ = -8						; size = 4
_skill$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_aSkill$ = 12						; size = 1
_Level$ = 16						; size = 1
?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z PROC	; gObjMonsterMagicAdd, COMDAT

; 28328: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 28329: 	int skill=-1;

  00009	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _skill$[ebp], -1

; 28330: 	int n;
; 28331: 
; 28332: 	for( n=0; n<MAX_MAGIC; n++)

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@gObjMonste
$LN2@gObjMonste:
  00019	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjMonste:
  00022	83 7d f8 3c	 cmp	 DWORD PTR _n$[ebp], 60	; 0000003cH
  00026	0f 8d 8b 00 00
	00		 jge	 $LN3@gObjMonste

; 28333: 	{
; 28334: 		if( lpObj->Magic[n].IsMagic() == FALSE )

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  0002f	c1 e1 04	 shl	 ecx, 4
  00032	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00035	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  0003b	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  00040	85 c0		 test	 eax, eax
  00042	75 6e		 jne	 SHORT $LN5@gObjMonste

; 28335: 		{
; 28336: 			skill = lpObj->Magic[n].Set(aSkill, Level);

  00044	0f b6 45 10	 movzx	 eax, BYTE PTR _Level$[ebp]
  00048	50		 push	 eax
  00049	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _aSkill$[ebp]
  0004d	51		 push	 ecx
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00051	c1 e1 04	 shl	 ecx, 4
  00054	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00057	03 8a 10 03 00
	00		 add	 ecx, DWORD PTR [edx+784]
  0005d	e8 00 00 00 00	 call	 ?Set@CMagicInf@@QAEHEE@Z ; CMagicInf::Set
  00062	89 45 fc	 mov	 DWORD PTR _skill$[ebp], eax

; 28337: 			if( skill < 0 ) 

  00065	83 7d fc 00	 cmp	 DWORD PTR _skill$[ebp], 0
  00069	7d 2d		 jge	 SHORT $LN6@gObjMonste

; 28338: 			{
; 28339: 				LogAdd(lMsg.Get(553),__FILE__, __LINE__);

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z@4JA
  00070	83 c0 0b	 add	 eax, 11			; 0000000bH
  00073	50		 push	 eax
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00079	68 29 02 00 00	 push	 553			; 00000229H
  0007e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00089	50		 push	 eax
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28340: 				return -1;

  00093	83 c8 ff	 or	 eax, -1
  00096	eb 4a		 jmp	 SHORT $LN1@gObjMonste
$LN6@gObjMonste:

; 28341: 			}			
; 28342: 			lpObj->MagicCount++;

  00098	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009b	8a 88 14 03 00
	00		 mov	 cl, BYTE PTR [eax+788]
  000a1	80 c1 01	 add	 cl, 1
  000a4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000a7	88 8a 14 03 00
	00		 mov	 BYTE PTR [edx+788], cl

; 28343: 			return n;

  000ad	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000b0	eb 30		 jmp	 SHORT $LN1@gObjMonste
$LN5@gObjMonste:

; 28344: 		}
; 28345: 	}

  000b2	e9 62 ff ff ff	 jmp	 $LN2@gObjMonste
$LN3@gObjMonste:

; 28346: 	LogAdd(lMsg.Get(554),__FILE__, __LINE__);

  000b7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z@4JA
  000bc	83 c0 12	 add	 eax, 18			; 00000012H
  000bf	50		 push	 eax
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000c5	68 2a 02 00 00	 push	 554			; 0000022aH
  000ca	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000d5	50		 push	 eax
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28347: 	return -1;

  000df	83 c8 ff	 or	 eax, -1
$LN1@gObjMonste:

; 28348: }

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ENDP	; gObjMonsterMagicAdd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjTradeSave@@YAXPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_szTemp$1 = -264					; size = 256
_tObjNum$2 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_index$ = 12						; size = 4
?gObjTradeSave@@YAXPAVOBJECTSTRUCT@@H@Z PROC		; gObjTradeSave, COMDAT

; 5675 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 5676 : 	//   ..
; 5677 : 	if( lpObj->m_IfState.use && lpObj->m_IfState.type == I_TRADE )

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00019	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0001f	80 e1 03	 and	 cl, 3
  00022	0f b6 d1	 movzx	 edx, cl
  00025	85 d2		 test	 edx, edx
  00027	0f 84 fb 00 00
	00		 je	 $LN1@gObjTradeS
  0002d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00030	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00036	c0 e9 04	 shr	 cl, 4
  00039	80 e1 0f	 and	 cl, 15			; 0000000fH
  0003c	0f b6 d1	 movzx	 edx, cl
  0003f	83 fa 01	 cmp	 edx, 1
  00042	0f 85 e0 00 00
	00		 jne	 $LN1@gObjTradeS

; 5678 : 	{
; 5679 : 		int tObjNum = lpObj->TargetNumber;

  00048	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004b	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00052	89 4d f8	 mov	 DWORD PTR _tObjNum$2[ebp], ecx

; 5680 : 		if( tObjNum > 0 )

  00055	83 7d f8 00	 cmp	 DWORD PTR _tObjNum$2[ebp], 0
  00059	0f 8e 95 00 00
	00		 jle	 $LN3@gObjTradeS

; 5681 : 		{
; 5682 : 			CGTradeResult(tObjNum, 0x00);

  0005f	6a 00		 push	 0
  00061	8b 45 f8	 mov	 eax, DWORD PTR _tObjNum$2[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  0006a	83 c4 08	 add	 esp, 8

; 5683 : 			char szTemp[256];
; 5684 : 			wsprintf(szTemp, lMsg.Get(1101), lpObj->Name);

  0006d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00070	83 c0 73	 add	 eax, 115		; 00000073H
  00073	50		 push	 eax
  00074	68 4d 04 00 00	 push	 1101			; 0000044dH
  00079	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00084	50		 push	 eax
  00085	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$1[ebp]
  0008b	51		 push	 ecx
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5685 : 			GCServerMsgStringSend(szTemp, tObjNum, 1);

  00095	6a 01		 push	 1
  00097	8b 45 f8	 mov	 eax, DWORD PTR _tObjNum$2[ebp]
  0009a	50		 push	 eax
  0009b	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$1[ebp]
  000a1	51		 push	 ecx
  000a2	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5686 : 			gObjTradeCancel(tObjNum);

  000aa	8b 45 f8	 mov	 eax, DWORD PTR _tObjNum$2[ebp]
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel
  000b3	83 c4 04	 add	 esp, 4

; 5687 : 			LogAdd(lMsg.Get(513), gObj[tObjNum].AccountID, gObj[tObjNum].Name);

  000b6	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$2[ebp], 7072
  000bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c3	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000c7	52		 push	 edx
  000c8	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$2[ebp], 7072
  000cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d5	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000d9	52		 push	 edx
  000da	68 01 02 00 00	 push	 513			; 00000201H
  000df	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000ea	50		 push	 eax
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@gObjTradeS:

; 5688 : 		}
; 5689 : 		gObjTradeCancel(index);

  000f4	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel
  000fd	83 c4 04	 add	 esp, 4

; 5690 : 		LogAdd(lMsg.Get(514), lpObj->AccountID, lpObj->Name);

  00100	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00103	83 c0 73	 add	 eax, 115		; 00000073H
  00106	50		 push	 eax
  00107	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0010a	83 c1 68	 add	 ecx, 104		; 00000068H
  0010d	51		 push	 ecx
  0010e	68 02 02 00 00	 push	 514			; 00000202H
  00113	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0011e	50		 push	 eax
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjTradeS:

; 5691 : 	}
; 5692 : }

  00128	5f		 pop	 edi
  00129	5e		 pop	 esi
  0012a	5b		 pop	 ebx
  0012b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012e	33 cd		 xor	 ecx, ebp
  00130	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
?gObjTradeSave@@YAXPAVOBJECTSTRUCT@@H@Z ENDP		; gObjTradeSave
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryInsertItemPos@@YAEHVCItem@@HH@Z
_TEXT	SEGMENT
_addskill$1 = -136					; size = 4
_lpItem$2 = -132					; size = 4
_useClass$ = -128					; size = 4
_blank$ = -124						; size = 4
_iheight$ = -120					; size = 4
_iwidth$ = -116						; size = 4
_h$ = -112						; size = 4
_w$ = -108						; size = 4
_TempInventoryMap$ = -104				; size = 96
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_item$ = 12						; size = 168
_pos$ = 180						; size = 4
_RequestCheck$ = 184					; size = 4
?gObjInventoryInsertItemPos@@YAEHVCItem@@HH@Z PROC	; gObjInventoryInsertItemPos, COMDAT

; 16500: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 16501: #ifdef PERSONAL_SHOP_20040113	//     -> DbItemSetInByte()   
; 16502: 	if( pos < 0 || pos > MAX_INVENTORY_EXTEND )

  00016	83 bd b4 00 00
	00 00		 cmp	 DWORD PTR _pos$[ebp], 0
  0001d	7c 09		 jl	 SHORT $LN3@gObjInvent
  0001f	83 bd b4 00 00
	00 6c		 cmp	 DWORD PTR _pos$[ebp], 108 ; 0000006cH
  00026	7e 07		 jle	 SHORT $LN2@gObjInvent
$LN3@gObjInvent:

; 16503: #else
; 16504: 	if( pos < 0 || pos > MAX_INVENTORY )
; 16505: #endif
; 16506: 	{
; 16507: 		return 0xFF;

  00028	0c ff		 or	 al, 255			; 000000ffH
  0002a	e9 b4 02 00 00	 jmp	 $LN1@gObjInvent
$LN2@gObjInvent:

; 16508: 	}
; 16509: 	LPOBJECTSTRUCT	lpObj;
; 16510: 
; 16511: #ifdef PERSONAL_SHOP_20040113
; 16512: 	#ifdef PERSONAL_SHOP_BUG_FIX
; 16513: 		BYTE			TempInventoryMap[MAX_INVENTORYMAP + MAX_PSHOPITEM];		//   
; 16514: 	#else
; 16515: 		BYTE			TempInventoryMap[MAX_INVENTORY + MAX_PSHOPITEM];		//   
; 16516: 	#endif
; 16517: #else
; 16518: 	BYTE			TempInventoryMap[8*8];				//   
; 16519: #endif
; 16520: 
; 16521: 	int				w, h, iwidth, iheight;
; 16522: 	int				blank;
; 16523: 	BOOL			useClass=FALSE;

  0002f	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _useClass$[ebp], 0

; 16524: 
; 16525: 	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  00036	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00043	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 16526: 
; 16527: 	//    ?
; 16528: 	if( lpObj->pInventory[pos].IsItem() == TRUE ) return 0xFF;

  00046	69 8d b4 00 00
	00 a8 00 00 00	 imul	 ecx, DWORD PTR _pos$[ebp], 168
  00050	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00053	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00059	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005e	83 f8 01	 cmp	 eax, 1
  00061	75 07		 jne	 SHORT $LN4@gObjInvent
  00063	0c ff		 or	 al, 255			; 000000ffH
  00065	e9 79 02 00 00	 jmp	 $LN1@gObjInvent
$LN4@gObjInvent:

; 16529: 
; 16530: 	//   ?
; 16531: 	if( item.IsItem() == FALSE ) return 0xFF;

  0006a	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  0006d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00072	85 c0		 test	 eax, eax
  00074	75 07		 jne	 SHORT $LN5@gObjInvent
  00076	0c ff		 or	 al, 255			; 000000ffH
  00078	e9 66 02 00 00	 jmp	 $LN1@gObjInvent
$LN5@gObjInvent:

; 16532: 
; 16533: 	//    
; 16534: 	if( pos < MAX_EQUIPMENT )

  0007d	83 bd b4 00 00
	00 0c		 cmp	 DWORD PTR _pos$[ebp], 12 ; 0000000cH
  00084	7d 78		 jge	 SHORT $LN6@gObjInvent

; 16535: 	{
; 16536: #ifdef ADD_THIRD_WING_20070525	// IsClass 
; 16537: 		useClass = item.IsClass( lpObj->Class, lpObj->ChangeUP, lpObj->ThirdChangeUp );	
; 16538: #else
; 16539: #ifdef NEW_SKILL_FORSKYLAND
; 16540: 		useClass = item.IsClass(lpObj->Class, lpObj->ChangeUP);	

  00086	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00089	0f b6 88 9f 00
	00 00		 movzx	 ecx, BYTE PTR [eax+159]
  00090	51		 push	 ecx
  00091	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00094	0f b6 82 9c 00
	00 00		 movzx	 eax, BYTE PTR [edx+156]
  0009b	50		 push	 eax
  0009c	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  0009f	e8 00 00 00 00	 call	 ?IsClass@CItem@@QAEHDH@Z ; CItem::IsClass
  000a4	89 45 80	 mov	 DWORD PTR _useClass$[ebp], eax

; 16541: #else
; 16542: 		useClass = item.IsClass(lpObj->Class);	
; 16543: #endif
; 16544: #endif	// ADD_THIRD_WING_20070525
; 16545: 
; 16546: 		
; 16547: 		//     		
; 16548: 		if( useClass == FALSE )	

  000a7	83 7d 80 00	 cmp	 DWORD PTR _useClass$[ebp], 0
  000ab	75 21		 jne	 SHORT $LN8@gObjInvent

; 16549: 		{
; 16550: 			LogAdd(lMsg.Get(528));

  000ad	68 10 02 00 00	 push	 528			; 00000210H
  000b2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000bd	50		 push	 eax
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000c4	83 c4 04	 add	 esp, 4

; 16551: 			return 0xFF;

  000c7	0c ff		 or	 al, 255			; 000000ffH
  000c9	e9 15 02 00 00	 jmp	 $LN1@gObjInvent
$LN8@gObjInvent:

; 16552: 		}
; 16553: 
; 16554: 		if( RequestCheck )

  000ce	83 bd b8 00 00
	00 00		 cmp	 DWORD PTR _RequestCheck$[ebp], 0
  000d5	74 22		 je	 SHORT $LN9@gObjInvent

; 16555: 		{
; 16556: 			if( gObjIsItemPut(lpObj, &item, pos) == FALSE ) return 0xFF;

  000d7	8b 85 b4 00 00
	00		 mov	 eax, DWORD PTR _pos$[ebp]
  000dd	50		 push	 eax
  000de	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  000e1	51		 push	 ecx
  000e2	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e5	52		 push	 edx
  000e6	e8 00 00 00 00	 call	 ?gObjIsItemPut@@YAHPAVOBJECTSTRUCT@@PAVCItem@@H@Z ; gObjIsItemPut
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ee	85 c0		 test	 eax, eax
  000f0	75 07		 jne	 SHORT $LN9@gObjInvent
  000f2	0c ff		 or	 al, 255			; 000000ffH
  000f4	e9 ea 01 00 00	 jmp	 $LN1@gObjInvent
$LN9@gObjInvent:

; 16557: 		}		
; 16558: 	}

  000f9	e9 fd 00 00 00	 jmp	 $LN7@gObjInvent
$LN6@gObjInvent:

; 16559: #ifdef PERSONAL_SHOP_20040113
; 16560: 	else
; 16561: 	{
; 16562: 		w = (pos-MAX_EQUIPMENT)%8;

  000fe	8b 85 b4 00 00
	00		 mov	 eax, DWORD PTR _pos$[ebp]
  00104	83 e8 0c	 sub	 eax, 12			; 0000000cH
  00107	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0010c	79 05		 jns	 SHORT $LN19@gObjInvent
  0010e	48		 dec	 eax
  0010f	83 c8 f8	 or	 eax, -8			; fffffff8H
  00112	40		 inc	 eax
$LN19@gObjInvent:
  00113	89 45 94	 mov	 DWORD PTR _w$[ebp], eax

; 16563: 		h = (pos-MAX_EQUIPMENT)/8;

  00116	8b 85 b4 00 00
	00		 mov	 eax, DWORD PTR _pos$[ebp]
  0011c	83 e8 0c	 sub	 eax, 12			; 0000000cH
  0011f	99		 cdq
  00120	83 e2 07	 and	 edx, 7
  00123	03 c2		 add	 eax, edx
  00125	c1 f8 03	 sar	 eax, 3
  00128	89 45 90	 mov	 DWORD PTR _h$[ebp], eax

; 16564: 		
; 16565: 		if( ExtentCheck(w, h, 8, 12) == FALSE) return 0xFF;

  0012b	6a 0c		 push	 12			; 0000000cH
  0012d	6a 08		 push	 8
  0012f	8b 45 90	 mov	 eax, DWORD PTR _h$[ebp]
  00132	50		 push	 eax
  00133	8b 4d 94	 mov	 ecx, DWORD PTR _w$[ebp]
  00136	51		 push	 ecx
  00137	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  0013c	83 c4 10	 add	 esp, 16			; 00000010H
  0013f	85 c0		 test	 eax, eax
  00141	75 07		 jne	 SHORT $LN11@gObjInvent
  00143	0c ff		 or	 al, 255			; 000000ffH
  00145	e9 99 01 00 00	 jmp	 $LN1@gObjInvent
$LN11@gObjInvent:

; 16566: 
; 16567: #ifdef PERSONAL_SHOP_BUG_FIX
; 16568: 		memcpy(TempInventoryMap, lpObj->pInventoryMap, MAX_INVENTORYMAP + MAX_PSHOPITEM);

  0014a	6a 60		 push	 96			; 00000060H
  0014c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014f	8b 88 60 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3168]
  00155	51		 push	 ecx
  00156	8d 55 98	 lea	 edx, DWORD PTR _TempInventoryMap$[ebp]
  00159	52		 push	 edx
  0015a	e8 00 00 00 00	 call	 _memcpy
  0015f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16569: #else
; 16570: 		memcpy(TempInventoryMap, lpObj->pInventoryMap, MAX_INVENTORY + MAX_PSHOPITEM);
; 16571: #endif
; 16572: 		
; 16573: 		item.GetSize(iwidth, iheight);

  00162	8d 45 88	 lea	 eax, DWORD PTR _iheight$[ebp]
  00165	50		 push	 eax
  00166	8d 4d 8c	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00169	51		 push	 ecx
  0016a	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  0016d	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 16574: 		//gObjInventoryItemBoxSet(lpObj->m_Index, source, iwidth, iheight, 0xFF);	
; 16575: 		
; 16576: 		// .. ..
; 16577: 		if( *(lpObj->pInventoryMap+(h*8)+w) != 0xFF ) {

  00172	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00175	8b 88 60 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3168]
  0017b	8b 55 90	 mov	 edx, DWORD PTR _h$[ebp]
  0017e	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00181	8b 4d 94	 mov	 ecx, DWORD PTR _w$[ebp]
  00184	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  00188	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  0018e	74 1f		 je	 SHORT $LN12@gObjInvent

; 16578: #ifdef PERSONAL_SHOP_BUG_FIX
; 16579: 			memcpy(lpObj->pInventoryMap, TempInventoryMap, MAX_INVENTORYMAP + MAX_PSHOPITEM);

  00190	6a 60		 push	 96			; 00000060H
  00192	8d 45 98	 lea	 eax, DWORD PTR _TempInventoryMap$[ebp]
  00195	50		 push	 eax
  00196	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00199	8b 91 60 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3168]
  0019f	52		 push	 edx
  001a0	e8 00 00 00 00	 call	 _memcpy
  001a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16580: #else
; 16581: 			memcpy(lpObj->pInventoryMap, TempInventoryMap, MAX_INVENTORY + MAX_PSHOPITEM);
; 16582: #endif
; 16583: 			return 0xFF;

  001a8	0c ff		 or	 al, 255			; 000000ffH
  001aa	e9 34 01 00 00	 jmp	 $LN1@gObjInvent
$LN12@gObjInvent:

; 16584: 		}
; 16585: 		
; 16586: 		blank = gObjInventoryRectCheck(lpObj->m_Index, w, h, iwidth,iheight);

  001af	8b 45 88	 mov	 eax, DWORD PTR _iheight$[ebp]
  001b2	50		 push	 eax
  001b3	8b 4d 8c	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  001b6	51		 push	 ecx
  001b7	8b 55 90	 mov	 edx, DWORD PTR _h$[ebp]
  001ba	52		 push	 edx
  001bb	8b 45 94	 mov	 eax, DWORD PTR _w$[ebp]
  001be	50		 push	 eax
  001bf	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001c2	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c4	52		 push	 edx
  001c5	e8 00 00 00 00	 call	 ?gObjInventoryRectCheck@@YAEHHHHH@Z ; gObjInventoryRectCheck
  001ca	83 c4 14	 add	 esp, 20			; 00000014H
  001cd	0f b6 c0	 movzx	 eax, al
  001d0	89 45 84	 mov	 DWORD PTR _blank$[ebp], eax

; 16587: 		
; 16588: 		if( blank >= 0xFE )

  001d3	81 7d 84 fe 00
	00 00		 cmp	 DWORD PTR _blank$[ebp], 254 ; 000000feH
  001da	7c 1f		 jl	 SHORT $LN7@gObjInvent

; 16589: 		{
; 16590: #ifdef PERSONAL_SHOP_BUG_FIX
; 16591: 			memcpy(lpObj->pInventoryMap, TempInventoryMap, MAX_INVENTORYMAP + MAX_PSHOPITEM);

  001dc	6a 60		 push	 96			; 00000060H
  001de	8d 45 98	 lea	 eax, DWORD PTR _TempInventoryMap$[ebp]
  001e1	50		 push	 eax
  001e2	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001e5	8b 91 60 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3168]
  001eb	52		 push	 edx
  001ec	e8 00 00 00 00	 call	 _memcpy
  001f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16592: #else
; 16593: 			memcpy(lpObj->pInventoryMap, TempInventoryMap, MAX_INVENTORY + MAX_PSHOPITEM);
; 16594: #endif
; 16595: 			return 0x00;

  001f4	32 c0		 xor	 al, al
  001f6	e9 e8 00 00 00	 jmp	 $LN1@gObjInvent
$LN7@gObjInvent:

; 16596: 		}
; 16597: 	}
; 16598: #else
; 16599: 	else
; 16600: 	{
; 16601: 		w = (pos-MAX_EQUIPMENT)%8;
; 16602: 		h = (pos-MAX_EQUIPMENT)/8;
; 16603: 		
; 16604: 		if( ExtentCheck(w, h, 8, 8) == FALSE) return 0xFF;
; 16605: 
; 16606: 		memcpy(TempInventoryMap, lpObj->pInventoryMap, 8*8);
; 16607: 		
; 16608: 		item.GetSize(iwidth, iheight);
; 16609: 		//gObjInventoryItemBoxSet(lpObj->m_Index, source, iwidth, iheight, 0xFF);	
; 16610: 		
; 16611: 		// .. ..
; 16612: 		if( *(lpObj->pInventoryMap+(h*8)+w) != 0xFF ) {
; 16613: 			memcpy(lpObj->pInventoryMap, TempInventoryMap, 8*8);
; 16614: 			return 0xFF;
; 16615: 		}
; 16616: 		
; 16617: 		blank = gObjInventoryRectCheck(lpObj->m_Index, w, h, iwidth,iheight);
; 16618: 		
; 16619: 		if( blank >= 0xFE )
; 16620: 		{
; 16621: 			memcpy(lpObj->pInventoryMap, TempInventoryMap, 8*8);
; 16622: 			return 0x00;
; 16623: 		}
; 16624: 	}
; 16625: #endif
; 16626: 		
; 16627: 	//  
; 16628: 	lpObj->pInventory[pos] = item;

  001fb	69 85 b4 00 00
	00 a8 00 00 00	 imul	 eax, DWORD PTR _pos$[ebp], 168
  00205	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00208	8b b9 5c 0c 00
	00		 mov	 edi, DWORD PTR [ecx+3164]
  0020e	03 f8		 add	 edi, eax
  00210	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00215	8d 75 0c	 lea	 esi, DWORD PTR _item$[ebp]
  00218	f3 a5		 rep movsd

; 16629: 
; 16630: 	//     .
; 16631: 	if( pos > MAX_EQUIPMENT-1 )

  0021a	83 bd b4 00 00
	00 0b		 cmp	 DWORD PTR _pos$[ebp], 11 ; 0000000bH
  00221	7e 15		 jle	 SHORT $LN14@gObjInvent

; 16632: 	{
; 16633: 		gObjInventoryItemSet(aIndex, pos, 1);

  00223	6a 01		 push	 1
  00225	8b 85 b4 00 00
	00		 mov	 eax, DWORD PTR _pos$[ebp]
  0022b	50		 push	 eax
  0022c	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0022f	51		 push	 ecx
  00230	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00235	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@gObjInvent:

; 16634: 	}		
; 16635: 	
; 16636: 	//      .
; 16637: 	if( pos < MAX_EQUIPMENT )

  00238	83 bd b4 00 00
	00 0c		 cmp	 DWORD PTR _pos$[ebp], 12 ; 0000000cH
  0023f	0f 8d 98 00 00
	00		 jge	 $LN15@gObjInvent

; 16638: 	{
; 16639: 		CItem *lpItem;	
; 16640: 		lpItem = (CItem*)&lpObj->pInventory[pos];

  00245	69 85 b4 00 00
	00 a8 00 00 00	 imul	 eax, DWORD PTR _pos$[ebp], 168
  0024f	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00252	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  00258	89 85 7c ff ff
	ff		 mov	 DWORD PTR _lpItem$2[ebp], eax

; 16641: 		if( lpItem->m_Option1 )

  0025e	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _lpItem$2[ebp]
  00264	0f b6 48 78	 movzx	 ecx, BYTE PTR [eax+120]
  00268	85 c9		 test	 ecx, ecx
  0026a	74 71		 je	 SHORT $LN15@gObjInvent

; 16642: 		{
; 16643: 			int addskill = gObjWeaponMagicAdd(lpObj, lpItem->m_Special[0], (BYTE)lpItem->m_Level);

  0026c	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _lpItem$2[ebp]
  00272	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00276	51		 push	 ecx
  00277	ba 01 00 00 00	 mov	 edx, 1
  0027c	6b c2 00	 imul	 eax, edx, 0
  0027f	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _lpItem$2[ebp]
  00285	0f b6 54 01 31	 movzx	 edx, BYTE PTR [ecx+eax+49]
  0028a	52		 push	 edx
  0028b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028e	50		 push	 eax
  0028f	e8 00 00 00 00	 call	 ?gObjWeaponMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjWeaponMagicAdd
  00294	83 c4 0c	 add	 esp, 12			; 0000000cH
  00297	89 85 78 ff ff
	ff		 mov	 DWORD PTR _addskill$1[ebp], eax

; 16644: 			if( addskill >= 0 ) {

  0029d	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR _addskill$1[ebp], 0
  002a4	7c 37		 jl	 SHORT $LN15@gObjInvent

; 16645: 				GCMagicListOneSend(lpObj->m_Index, addskill,lpItem->m_Special[0], (BYTE)lpItem->m_Level, 0);

  002a6	6a 00		 push	 0
  002a8	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _lpItem$2[ebp]
  002ae	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  002b2	51		 push	 ecx
  002b3	ba 01 00 00 00	 mov	 edx, 1
  002b8	6b c2 00	 imul	 eax, edx, 0
  002bb	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _lpItem$2[ebp]
  002c1	0f b6 54 01 31	 movzx	 edx, BYTE PTR [ecx+eax+49]
  002c6	52		 push	 edx
  002c7	0f b6 85 78 ff
	ff ff		 movzx	 eax, BYTE PTR _addskill$1[ebp]
  002ce	50		 push	 eax
  002cf	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002d2	8b 11		 mov	 edx, DWORD PTR [ecx]
  002d4	52		 push	 edx
  002d5	e8 00 00 00 00	 call	 ?GCMagicListOneSend@@YAXHDEEE@Z ; GCMagicListOneSend
  002da	83 c4 14	 add	 esp, 20			; 00000014H
$LN15@gObjInvent:

; 16646: 			}
; 16647: 		}
; 16648: 	}
; 16649: 
; 16650: 	/*
; 16651: 	//   CharSet  .
; 16652: 	if( pos < MAX_EQUIPMENT)
; 16653: 	{
; 16654: 		gObjMakePreviewCharSet(lpObj->m_Index);
; 16655: 	}
; 16656: 	
; 16657: 	if( pos < MAX_EQUIPMENT ) GCEquipmentChange(lpObj->m_Index, pos);
; 16658: 	*/
; 16659: 	return pos;

  002dd	8a 85 b4 00 00
	00		 mov	 al, BYTE PTR _pos$[ebp]
$LN1@gObjInvent:

; 16660: }

  002e3	5f		 pop	 edi
  002e4	5e		 pop	 esi
  002e5	5b		 pop	 ebx
  002e6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002e9	33 cd		 xor	 ecx, ebp
  002eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f0	8b e5		 mov	 esp, ebp
  002f2	5d		 pop	 ebp
  002f3	c3		 ret	 0
?gObjInventoryInsertItemPos@@YAEHVCItem@@HH@Z ENDP	; gObjInventoryInsertItemPos
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMonsterDieLifePlus@@YAXPAVOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTartObj$ = 12					; size = 4
?gObjMonsterDieLifePlus@@YAXPAVOBJECTSTRUCT@@0@Z PROC	; gObjMonsterDieLifePlus, COMDAT

; 13622: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 13623: 	if( lpTartObj->Level < 0 || lpTartObj->Level > 255 ) return;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _lpTartObj$[ebp]
  0000c	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00013	85 c9		 test	 ecx, ecx
  00015	7c 12		 jl	 SHORT $LN3@gObjMonste
  00017	8b 45 0c	 mov	 eax, DWORD PTR _lpTartObj$[ebp]
  0001a	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00021	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00027	7e 05		 jle	 SHORT $LN2@gObjMonste
$LN3@gObjMonste:
  00029	e9 bb 01 00 00	 jmp	 $LN1@gObjMonste
$LN2@gObjMonste:

; 13624: 
; 13625: 	lpObj->Life += lpTartObj->Level;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _lpTartObj$[ebp]
  00031	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00038	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0003c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0003f	f3 0f 58 82 bc
	00 00 00	 addss	 xmm0, DWORD PTR [edx+188]
  00047	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004a	f3 0f 11 80 bc
	00 00 00	 movss	 DWORD PTR [eax+188], xmm0

; 13626: 
; 13627: 	if(lpObj->MonsterDieGetLife)

  00052	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00055	0f b6 88 18 01
	00 00		 movzx	 ecx, BYTE PTR [eax+280]
  0005c	85 c9		 test	 ecx, ecx
  0005e	74 46		 je	 SHORT $LN4@gObjMonste

; 13628: 	{
; 13629: 		lpObj->Life += ((lpObj->MaxLife+lpObj->AddLife)/8)*lpObj->MonsterDieGetLife;

  00060	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00063	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0006e	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  00076	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41000000
  0007e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00081	0f b6 82 18 01
	00 00		 movzx	 eax, BYTE PTR [edx+280]
  00088	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  0008c	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00093	f3 0f 58 81 bc
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+188]
  0009b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0009e	f3 0f 11 82 bc
	00 00 00	 movss	 DWORD PTR [edx+188], xmm0
$LN4@gObjMonste:

; 13630: 		//LogAddL("Life   : %d %d", (int)lpObj->Life, (lpObj->MaxLife/8)*lpObj->MonsterDieGetLife);
; 13631: 	}
; 13632: 	if(lpObj->MonsterDieGetMana)

  000a6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a9	0f b6 88 19 01
	00 00		 movzx	 ecx, BYTE PTR [eax+281]
  000b0	85 c9		 test	 ecx, ecx
  000b2	74 46		 je	 SHORT $LN5@gObjMonste

; 13633: 	{
; 13634: 		lpObj->Mana += ((lpObj->MaxMana+lpObj->AddMana)/8)*lpObj->MonsterDieGetMana;

  000b4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b7	f3 0f 2a 80 10
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+272]
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000c2	f3 0f 58 81 d4
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+212]
  000ca	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41000000
  000d2	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000d5	0f b6 82 19 01
	00 00		 movzx	 eax, BYTE PTR [edx+281]
  000dc	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  000e0	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000e4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000e7	f3 0f 58 81 d0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+208]
  000ef	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000f2	f3 0f 11 82 d0
	00 00 00	 movss	 DWORD PTR [edx+208], xmm0
$LN5@gObjMonste:

; 13635: 	}	
; 13636: 
; 13637: #ifdef MODIFY_SEASON4_UPDATE_BUGFIX_02_20080804
; 13638: 	if( lpObj->m_wSocketOptionMonsterDieGetHp > 0 )
; 13639: 	{
; 13640: 		lpObj->Life += lpObj->m_wSocketOptionMonsterDieGetHp;
; 13641: 	}
; 13642: 
; 13643: 	if( lpObj->m_wSocketOptionMonsterDieGetMana > 0 )
; 13644: 	{
; 13645: 		lpObj->Mana += lpObj->m_wSocketOptionMonsterDieGetMana;
; 13646: 	}
; 13647: #endif // MODIFY_SEASON4_UPDATE_BUGFIX_02_20080804
; 13648: 
; 13649: #ifdef ADD_MASTER_LEVEL_SKILL_PASSIVE_20080107	// 2 -     
; 13650: 	if( lpObj->m_MPSkillOpt.iMpsMonsterDieGetMana > 0 )
; 13651: 	{
; 13652: 		lpObj->Mana	+= (float)( ( lpObj->MaxMana + lpObj->AddMana ) / lpObj->m_MPSkillOpt.iMpsMonsterDieGetMana );
; 13653: 	}
; 13654: #endif
; 13655: 
; 13656: #ifdef ADD_MASTER_LEVEL_SKILL_PASSIVE_20080107	// 2 -     
; 13657: 	if( lpObj->m_MPSkillOpt.iMpsMonsterDieGetLife > 0 )
; 13658: 	{
; 13659: 		lpObj->Life	+= (float)( ( lpObj->MaxLife + lpObj->AddLife ) / lpObj->m_MPSkillOpt.iMpsMonsterDieGetLife );
; 13660: 	}
; 13661: #endif
; 13662: 
; 13663: #ifdef ADD_MASTER_LEVEL_SKILL_PASSIVE_20080107	// 2 -    SD 
; 13664: 	if( lpObj->m_MPSkillOpt.iMpsMonsterDieGetSD > 0 )
; 13665: 	{
; 13666: 		lpObj->iShield	+= (float)( ( lpObj->iMaxShield + lpObj->iAddShield ) / lpObj->m_MPSkillOpt.iMpsMonsterDieGetSD );
; 13667: 	}
; 13668: #endif	
; 13669: 
; 13670: #ifdef MODIFY_SKILL_ML_MONSTER_KILL_SD_BUGFIX_20080514	//    SD   
; 13671: 	if( lpObj->m_MPSkillOpt.iMpsMonsterDieGetSD > 0 )
; 13672: 	{
; 13673: 		if( lpObj->iShield > (lpObj->iMaxShield+lpObj->iAddShield)) 
; 13674: 		lpObj->iShield = (lpObj->iMaxShield+lpObj->iAddShield);
; 13675: 	}
; 13676: #endif	// MODIFY_SKILL_ML_MONSTER_KILL_SD_BUGFIX_20080514
; 13677: 	
; 13678: 	if( lpObj->Life > (lpObj->MaxLife+lpObj->AddLife)) 

  000fa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000fd	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  00105	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00108	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  00110	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00113	f3 0f 10 8a bc
	00 00 00	 movss	 xmm1, DWORD PTR [edx+188]
  0011b	0f 2f c8	 comiss	 xmm1, xmm0
  0011e	76 21		 jbe	 SHORT $LN6@gObjMonste

; 13679: 		lpObj->Life = (lpObj->MaxLife+lpObj->AddLife);

  00120	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00123	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  0012b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0012e	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  00136	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00139	f3 0f 11 82 bc
	00 00 00	 movss	 DWORD PTR [edx+188], xmm0
$LN6@gObjMonste:

; 13680: 
; 13681: #ifdef ADD_SHIELD_POINT_01_20060403
; 13682: 	GCReFillSend(lpObj->m_Index, (WORD)lpObj->Life, 0xFF, 0, (WORD)lpObj->iShield);
; 13683: #else
; 13684: 	GCReFillSend(lpObj->m_Index, (WORD)lpObj->Life, 0xFF, 0);

  00141	6a 00		 push	 0
  00143	68 ff 00 00 00	 push	 255			; 000000ffH
  00148	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014b	f3 0f 2c 88 bc
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+188]
  00153	0f b7 d1	 movzx	 edx, cx
  00156	52		 push	 edx
  00157	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0015a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  00162	83 c4 10	 add	 esp, 16			; 00000010H

; 13685: #endif
; 13686: 
; 13687: #ifdef MODIFY_SEASON4_UPDATE_BUGFIX_02_20080804
; 13688: 	if(lpObj->MonsterDieGetMana || lpObj->m_MPSkillOpt.iMpsMonsterDieGetMana > 0 || lpObj->m_wSocketOptionMonsterDieGetMana > 0 )
; 13689: #else
; 13690: 	#ifdef MODIFY_SKILL_ML_MONSTER_KILL_SD_BUGFIX_20080514	//      
; 13691: 	if(lpObj->MonsterDieGetMana || lpObj->m_MPSkillOpt.iMpsMonsterDieGetMana > 0)
; 13692: 	#else	// MODIFY_SKILL_ML_MONSTER_KILL_SD_BUGFIX_20080514
; 13693: 	if(lpObj->MonsterDieGetMana)

  00165	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00168	0f b6 88 19 01
	00 00		 movzx	 ecx, BYTE PTR [eax+281]
  0016f	85 c9		 test	 ecx, ecx
  00171	74 76		 je	 SHORT $LN7@gObjMonste

; 13694: 	#endif	// MODIFY_SKILL_ML_MONSTER_KILL_SD_BUGFIX_20080514
; 13695: #endif // MODIFY_SEASON4_UPDATE_BUGFIX_02_20080804
; 13696: 	{
; 13697: 		if( lpObj->Mana > (lpObj->MaxMana+lpObj->AddMana)) 

  00173	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00176	f3 0f 2a 80 10
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+272]
  0017e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00181	f3 0f 58 81 d4
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+212]
  00189	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0018c	f3 0f 10 8a d0
	00 00 00	 movss	 xmm1, DWORD PTR [edx+208]
  00194	0f 2f c8	 comiss	 xmm1, xmm0
  00197	76 21		 jbe	 SHORT $LN8@gObjMonste

; 13698: 			lpObj->Mana = (lpObj->MaxMana+lpObj->AddMana);

  00199	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019c	f3 0f 2a 80 10
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+272]
  001a4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001a7	f3 0f 58 81 d4
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+212]
  001af	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001b2	f3 0f 11 82 d0
	00 00 00	 movss	 DWORD PTR [edx+208], xmm0
$LN8@gObjMonste:

; 13699: 
; 13700: #ifdef NEW_FORSKYLAND2
; 13701: 		GCManaSend(lpObj->m_Index, (short)lpObj->Mana, 0xFF, 0, lpObj->BP);

  001ba	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001bd	0f b7 88 e8 00
	00 00		 movzx	 ecx, WORD PTR [eax+232]
  001c4	51		 push	 ecx
  001c5	6a 00		 push	 0
  001c7	68 ff 00 00 00	 push	 255			; 000000ffH
  001cc	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001cf	f3 0f 2c 82 d0
	00 00 00	 cvttss2si eax, DWORD PTR [edx+208]
  001d7	0f b7 c8	 movzx	 ecx, ax
  001da	51		 push	 ecx
  001db	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001de	8b 02		 mov	 eax, DWORD PTR [edx]
  001e0	50		 push	 eax
  001e1	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  001e6	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@gObjMonste:
$LN1@gObjMonste:

; 13702: #else
; 13703: 		GCManaSend(lpObj->m_Index, (short)lpObj->Mana, 0xFF, 0, 0);
; 13704: #endif
; 13705: 	}
; 13706: 	
; 13707: 
; 13708: #ifdef TEST_MSG_MLS_ACTIVE_20080131
; 13709: #if TESTSERVER == 1
; 13710: 	#ifdef ADD_MASTER_LEVEL_SKILL_PASSIVE_20080107
; 13711: 	PMSG_NOTICE	pNotice;
; 13712: 	CHAR szNotice[256] = {0,};
; 13713: 	float	fAddValueForMsg = 0.0;
; 13714: 	TNotice::SetNoticeProperty( &pNotice, TNOTICE_TYPE_BOTTOM, TNOTICE_COLOR_RED );
; 13715: 	if( lpObj->m_MPSkillOpt.iMpsMonsterDieGetMana > 0 )
; 13716: 	{
; 13717: 		fAddValueForMsg	= (float)( ( lpObj->MaxMana + lpObj->AddMana ) / lpObj->m_MPSkillOpt.iMpsMonsterDieGetMana );
; 13718: 		sprintf( szNotice, "[MLS_MANA][%s:%.2f]", lpObj->Name, fAddValueForMsg );
; 13719: 		TNotice::MakeNoticeMsg( &pNotice, TNOTICE_TYPE_BOTTOM, szNotice);
; 13720: 		TNotice::SendNoticeToUser( lpObj->m_Index, &pNotice );		
; 13721: 	}
; 13722: 	if( lpObj->m_MPSkillOpt.iMpsMonsterDieGetLife > 0 )
; 13723: 	{
; 13724: 		fAddValueForMsg	= (float)( ( lpObj->MaxLife + lpObj->AddLife ) / lpObj->m_MPSkillOpt.iMpsMonsterDieGetLife );		
; 13725: 		sprintf( szNotice, "[MLS_LIFE][%s:%.2f]", lpObj->Name, fAddValueForMsg );
; 13726: 		TNotice::MakeNoticeMsg( &pNotice, TNOTICE_TYPE_BOTTOM, szNotice);
; 13727: 		TNotice::SendNoticeToUser( lpObj->m_Index, &pNotice );		
; 13728: 	}
; 13729: 	if( lpObj->m_MPSkillOpt.iMpsMonsterDieGetSD > 0 )
; 13730: 	{
; 13731: 		fAddValueForMsg	= (int)( ( lpObj->iMaxShield + lpObj->iAddShield ) / lpObj->m_MPSkillOpt.iMpsMonsterDieGetSD );		
; 13732: 		sprintf( szNotice, "[MLS_SD][%s:%.0f]", lpObj->Name, fAddValueForMsg );
; 13733: 		TNotice::MakeNoticeMsg( &pNotice, TNOTICE_TYPE_BOTTOM, szNotice);
; 13734: 		TNotice::SendNoticeToUser( lpObj->m_Index, &pNotice );		
; 13735: 	}
; 13736: 	#endif
; 13737: #endif	// TESTSERVER == 1
; 13738: #endif	// TEST_MSG_MLS_ACTIVE_20080131
; 13739: 
; 13740: }

  001e9	5f		 pop	 edi
  001ea	5e		 pop	 esi
  001eb	5b		 pop	 ebx
  001ec	8b e5		 mov	 esp, ebp
  001ee	5d		 pop	 ebp
  001ef	c3		 ret	 0
?gObjMonsterDieLifePlus@@YAXPAVOBJECTSTRUCT@@0@Z ENDP	; gObjMonsterDieLifePlus
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?TradeItemInventoryPutTest@@YAHH@Z
_TEXT	SEGMENT
_n$1 = -80						; size = 4
_result$ = -76						; size = 4
_number$ = -72						; size = 4
_TempInventoryMap$ = -68				; size = 64
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?TradeItemInventoryPutTest@@YAHH@Z PROC			; TradeItemInventoryPutTest, COMDAT

; 19338: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 19339: 	BYTE	TempInventoryMap[8][8];			//    
; 19340: 	int		number;
; 19341: 	int		result=TRUE;

  00016	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _result$[ebp], 1

; 19342: 	
; 19343: 	number = gObj[aIndex].TargetNumber;

  0001d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002a	0f bf 94 01 ac
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+684]
  00032	89 55 b8	 mov	 DWORD PTR _number$[ebp], edx

; 19344: 
; 19345: 	if( gObjIsConnected(number) == FALSE ) return FALSE;

  00035	8b 45 b8	 mov	 eax, DWORD PTR _number$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0003e	83 c4 04	 add	 esp, 4
  00041	85 c0		 test	 eax, eax
  00043	75 07		 jne	 SHORT $LN5@TradeItemI
  00045	33 c0		 xor	 eax, eax
  00047	e9 d8 00 00 00	 jmp	 $LN1@TradeItemI
$LN5@TradeItemI:

; 19346: 
; 19347: 	memcpy( TempInventoryMap, gObj[aIndex].pInventoryMap, 8*8);

  0004c	6a 40		 push	 64			; 00000040H
  0004e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005b	8b 94 01 60 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3168]
  00062	52		 push	 edx
  00063	8d 45 bc	 lea	 eax, DWORD PTR _TempInventoryMap$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _memcpy
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19348: 	
; 19349: 	for( int n=0; n<MAX_TRADEITEM; n++)

  0006f	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00076	eb 09		 jmp	 SHORT $LN4@TradeItemI
$LN2@TradeItemI:
  00078	8b 45 b0	 mov	 eax, DWORD PTR _n$1[ebp]
  0007b	83 c0 01	 add	 eax, 1
  0007e	89 45 b0	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@TradeItemI:
  00081	83 7d b0 20	 cmp	 DWORD PTR _n$1[ebp], 32	; 00000020H
  00085	0f 8d 8a 00 00
	00		 jge	 $LN3@TradeItemI

; 19350: 	{
; 19351: 		//  ..
; 19352: 		if( gObj[number].Trade[n].IsItem() == TRUE )

  0008b	69 45 b8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00092	69 4d b0 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00099	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009f	03 8c 02 84 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3204]
  000a6	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000ab	83 f8 01	 cmp	 eax, 1
  000ae	75 60		 jne	 SHORT $LN6@TradeItemI

; 19353: 		{
; 19354: 			if( gObjTempInventoryInsertItem(&gObj[aIndex], gObj[number].Trade[n], (LPBYTE)TempInventoryMap) == 0xFF )

  000b0	8d 45 bc	 lea	 eax, DWORD PTR _TempInventoryMap$[ebp]
  000b3	50		 push	 eax
  000b4	69 4d b8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  000bb	69 55 b0 a8 00
	00 00		 imul	 edx, DWORD PTR _n$1[ebp], 168
  000c2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c7	8b b4 08 84 0c
	00 00		 mov	 esi, DWORD PTR [eax+ecx+3204]
  000ce	03 f2		 add	 esi, edx
  000d0	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  000d6	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  000db	8b fc		 mov	 edi, esp
  000dd	f3 a5		 rep movsd
  000df	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  000e6	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ?gObjTempInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@VCItem@@PAE@Z ; gObjTempInventoryInsertItem
  000f2	81 c4 b0 00 00
	00		 add	 esp, 176		; 000000b0H
  000f8	0f b6 d0	 movzx	 edx, al
  000fb	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00101	75 06		 jne	 SHORT $LN7@TradeItemI

; 19355: 			{
; 19356: 				return FALSE;

  00103	33 c0		 xor	 eax, eax
  00105	eb 1d		 jmp	 SHORT $LN1@TradeItemI

; 19357: 			}

  00107	eb 07		 jmp	 SHORT $LN6@TradeItemI
$LN7@TradeItemI:

; 19358: 			else {
; 19359: 				result = TRUE;

  00109	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _result$[ebp], 1
$LN6@TradeItemI:

; 19360: 			}
; 19361: 		}
; 19362: 	}

  00110	e9 63 ff ff ff	 jmp	 $LN2@TradeItemI
$LN3@TradeItemI:

; 19363: 	if( result == TRUE ) return TRUE;

  00115	83 7d b4 01	 cmp	 DWORD PTR _result$[ebp], 1
  00119	75 07		 jne	 SHORT $LN9@TradeItemI
  0011b	b8 01 00 00 00	 mov	 eax, 1
  00120	eb 02		 jmp	 SHORT $LN1@TradeItemI
$LN9@TradeItemI:

; 19364: 	return FALSE;

  00122	33 c0		 xor	 eax, eax
$LN1@TradeItemI:

; 19365: }

  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	5b		 pop	 ebx
  00127	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012a	33 cd		 xor	 ecx, ebp
  0012c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00131	8b e5		 mov	 esp, ebp
  00133	5d		 pop	 ebp
  00134	c3		 ret	 0
?TradeItemInventoryPutTest@@YAHH@Z ENDP			; TradeItemInventoryPutTest
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjRestPotionFill@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_cur$1 = -24						; size = 4
_tlife$2 = -20						; size = 4
_percent$3 = -16					; size = 4
_percent$4 = -12					; size = 4
_tmana$5 = -8						; size = 4
_tlife$6 = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjRestPotionFill@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjRestPotionFill, COMDAT

; 23196: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 23197: 	//   
; 23198: 	//if( (lpObj->MaxLife+lpObj->AddLife) == lpObj->Life ) return;
; 23199: 
; 23200: 	if( lpObj->m_Rest )

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b6 88 bd 01
	00 00		 movzx	 ecx, BYTE PTR [eax+445]
  00013	85 c9		 test	 ecx, ecx
  00015	0f 84 1f 03 00
	00		 je	 $LN2@gObjRestPo

; 23201: 	{
; 23202: 		float tlife;
; 23203: 		float tmana;
; 23204: 		int   percent=3;

  0001b	c7 45 f4 03 00
	00 00		 mov	 DWORD PTR _percent$4[ebp], 3

; 23205: 
; 23206: 		lpObj->m_LifeFillCount++;

  00022	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00025	8a 88 3e 02 00
	00		 mov	 cl, BYTE PTR [eax+574]
  0002b	80 c1 01	 add	 cl, 1
  0002e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00031	88 8a 3e 02 00
	00		 mov	 BYTE PTR [edx+574], cl

; 23207: 		
; 23208: 		if( lpObj->m_LifeFillCount > 4 )

  00037	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003a	0f be 88 3e 02
	00 00		 movsx	 ecx, BYTE PTR [eax+574]
  00041	83 f9 04	 cmp	 ecx, 4
  00044	0f 8e eb 02 00
	00		 jle	 $LN4@gObjRestPo

; 23209: 		{
; 23210: 			lpObj->m_LifeFillCount = 0;

  0004a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004d	c6 80 3e 02 00
	00 00		 mov	 BYTE PTR [eax+574], 0

; 23211: 			tlife  = lpObj->Life;

  00054	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00057	f3 0f 10 80 bc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+188]
  0005f	f3 0f 11 45 fc	 movss	 DWORD PTR _tlife$6[ebp], xmm0

; 23212: 			if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].IsItem() == TRUE )

  00064	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00069	6b c8 0a	 imul	 ecx, eax, 10
  0006c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0006f	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00075	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0007a	83 f8 01	 cmp	 eax, 1
  0007d	75 61		 jne	 SHORT $LN5@gObjRestPo

; 23213: 			{
; 23214: 				if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Option3 )

  0007f	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00084	6b c8 0a	 imul	 ecx, eax, 10
  00087	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0008a	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00090	0f b6 4c 08 7a	 movzx	 ecx, BYTE PTR [eax+ecx+122]
  00095	85 c9		 test	 ecx, ecx
  00097	74 42		 je	 SHORT $LN8@gObjRestPo

; 23215: 				{
; 23216: #ifdef MODIFY_ACCUMULATED_BUG_AMULETRING_WRONG_OPTION_01_20050531
; 23217: 					//     .
; 23218: 					if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type != MAKE_ITEMNUM(13,24) )

  00099	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0009e	6b c8 0a	 imul	 ecx, eax, 10
  000a1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000a4	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  000aa	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  000af	6a 18		 push	 24			; 00000018H
  000b1	6a 0d		 push	 13			; 0000000dH
  000b3	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b8	83 c4 08	 add	 esp, 8
  000bb	3b f0		 cmp	 esi, eax
  000bd	74 1c		 je	 SHORT $LN8@gObjRestPo

; 23219: 					{
; 23220: 						percent+=lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Option3;

  000bf	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000c4	6b c8 0a	 imul	 ecx, eax, 10
  000c7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ca	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  000d0	0f b6 4c 08 7a	 movzx	 ecx, BYTE PTR [eax+ecx+122]
  000d5	03 4d f4	 add	 ecx, DWORD PTR _percent$4[ebp]
  000d8	89 4d f4	 mov	 DWORD PTR _percent$4[ebp], ecx
$LN8@gObjRestPo:

; 23221: 					}
; 23222: #else
; 23223: 					percent+=lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Option3;
; 23224: #endif
; 23225: 
; 23226: 				}
; 23227: 			}

  000db	e9 f0 00 00 00	 jmp	 $LN15@gObjRestPo
$LN5@gObjRestPo:

; 23228: 			else if( lpObj->pInventory[EQUIPMENT_RING_LEFT].IsItem() == TRUE )

  000e0	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000e5	6b c8 0b	 imul	 ecx, eax, 11
  000e8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000eb	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  000f1	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000f6	83 f8 01	 cmp	 eax, 1
  000f9	75 5e		 jne	 SHORT $LN9@gObjRestPo

; 23229: 			{
; 23230: 				if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Option3 )

  000fb	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00100	6b c8 0b	 imul	 ecx, eax, 11
  00103	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00106	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0010c	0f b6 4c 08 7a	 movzx	 ecx, BYTE PTR [eax+ecx+122]
  00111	85 c9		 test	 ecx, ecx
  00113	74 42		 je	 SHORT $LN12@gObjRestPo

; 23231: 				{
; 23232: #ifdef MODIFY_ACCUMULATED_BUG_AMULETRING_WRONG_OPTION_01_20050531
; 23233: 					//     .
; 23234: 					if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type != MAKE_ITEMNUM(13,24) )

  00115	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0011a	6b c8 0b	 imul	 ecx, eax, 11
  0011d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00120	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00126	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0012b	6a 18		 push	 24			; 00000018H
  0012d	6a 0d		 push	 13			; 0000000dH
  0012f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00134	83 c4 08	 add	 esp, 8
  00137	3b f0		 cmp	 esi, eax
  00139	74 1c		 je	 SHORT $LN12@gObjRestPo

; 23235: 					{
; 23236: 						percent+=lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Option3;

  0013b	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00140	6b c8 0b	 imul	 ecx, eax, 11
  00143	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00146	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0014c	0f b6 4c 08 7a	 movzx	 ecx, BYTE PTR [eax+ecx+122]
  00151	03 4d f4	 add	 ecx, DWORD PTR _percent$4[ebp]
  00154	89 4d f4	 mov	 DWORD PTR _percent$4[ebp], ecx
$LN12@gObjRestPo:

; 23237: 					}
; 23238: #else
; 23239: 					percent+=lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Option3;
; 23240: #endif
; 23241: 				}
; 23242: 			}

  00157	eb 77		 jmp	 SHORT $LN15@gObjRestPo
$LN9@gObjRestPo:

; 23243: 			else if( lpObj->pInventory[EQUIPMENT_AMULET].IsItem() == TRUE )

  00159	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0015e	6b c8 09	 imul	 ecx, eax, 9
  00161	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00164	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0016a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0016f	83 f8 01	 cmp	 eax, 1
  00172	75 5c		 jne	 SHORT $LN15@gObjRestPo

; 23244: 			{
; 23245: 				if( lpObj->pInventory[EQUIPMENT_AMULET].m_Option3 )

  00174	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00179	6b c8 09	 imul	 ecx, eax, 9
  0017c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0017f	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00185	0f b6 4c 08 7a	 movzx	 ecx, BYTE PTR [eax+ecx+122]
  0018a	85 c9		 test	 ecx, ecx
  0018c	74 42		 je	 SHORT $LN15@gObjRestPo

; 23246: 				{
; 23247: #ifdef MODIFY_ACCUMULATED_BUG_AMULETRING_WRONG_OPTION_01_20050531
; 23248: 					//     .
; 23249: 					if( lpObj->pInventory[EQUIPMENT_AMULET].m_Type != MAKE_ITEMNUM(13,28) )

  0018e	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00193	6b c8 09	 imul	 ecx, eax, 9
  00196	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00199	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0019f	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  001a4	6a 1c		 push	 28			; 0000001cH
  001a6	6a 0d		 push	 13			; 0000000dH
  001a8	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001ad	83 c4 08	 add	 esp, 8
  001b0	3b f0		 cmp	 esi, eax
  001b2	74 1c		 je	 SHORT $LN15@gObjRestPo

; 23250: 					{
; 23251: 						percent+=lpObj->pInventory[EQUIPMENT_AMULET].m_Option3;

  001b4	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  001b9	6b c8 09	 imul	 ecx, eax, 9
  001bc	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001bf	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  001c5	0f b6 4c 08 7a	 movzx	 ecx, BYTE PTR [eax+ecx+122]
  001ca	03 4d f4	 add	 ecx, DWORD PTR _percent$4[ebp]
  001cd	89 4d f4	 mov	 DWORD PTR _percent$4[ebp], ecx
$LN15@gObjRestPo:

; 23252: 					}
; 23253: #else
; 23254: 					percent+=lpObj->pInventory[EQUIPMENT_AMULET].m_Option3;
; 23255: #endif
; 23256: 				}
; 23257: 			}
; 23258: #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122	//  1 -    ()
; 23259: 			if( percent > 0 && lpObj->m_MPSkillOpt.iMpsAutoRecoverLife > 0 )
; 23260: 			{	//     .
; 23261: 				percent += lpObj->m_MPSkillOpt.iMpsAutoRecoverLife;
; 23262: 			}		
; 23263: #endif
; 23264: 
; 23265: #ifdef ADD_CASHITEM_4RD_MARK_20080723
; 23266: 			// 
; 23267: 			{
; 23268: 				int nPercent = gObjGetTotalValueOfEffect( lpObj, EFFECTTYPE_RECOVERY_HP );
; 23269: 				if( nPercent > 0 )
; 23270: 				{
; 23271: 					percent += nPercent;
; 23272: 				}
; 23273: 			}
; 23274: #endif // ADD_CASHITEM_4RD_MARK_20080723
; 23275: 
; 23276: #ifndef MODIFY_SOCKET_ITEM_NEW_OPTION_20080818					// !! NOT
; 23277: 	#ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_04_20080710
; 23278: 			if( lpObj->m_btRefillHPSocketOption > 0 )
; 23279: 			{
; 23280: 				percent += lpObj->m_btRefillHPSocketOption;
; 23281: 			}
; 23282: 	#endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_04_20080710
; 23283: #endif // MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 23284: 			
; 23285: 			tlife += ((((lpObj->MaxLife+lpObj->AddLife))*percent)/100);

  001d0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d3	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  001db	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001de	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  001e6	f3 0f 2a 4d f4	 cvtsi2ss xmm1, DWORD PTR _percent$4[ebp]
  001eb	f3 0f 59 c1	 mulss	 xmm0, xmm1
  001ef	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  001f7	f3 0f 58 45 fc	 addss	 xmm0, DWORD PTR _tlife$6[ebp]
  001fc	f3 0f 11 45 fc	 movss	 DWORD PTR _tlife$6[ebp], xmm0

; 23286: #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 23287: 			//      :    
; 23288: 			tlife += lpObj->m_JewelOfHarmonyEffect.HJOpAddRefillHP;
; 23289: #endif	// ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 23290: 
; 23291: #ifdef MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 23292: 			if( lpObj->m_btRefillHPSocketOption > 0 )
; 23293: 			{
; 23294: 				tlife += lpObj->m_btRefillHPSocketOption;
; 23295: 			}
; 23296: #endif // MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 23297: 
; 23298: 			if( tlife > (lpObj->MaxLife+lpObj->AddLife) ) tlife = (lpObj->MaxLife+lpObj->AddLife);

  00201	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00204	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  0020c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0020f	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  00217	f3 0f 10 4d fc	 movss	 xmm1, DWORD PTR _tlife$6[ebp]
  0021c	0f 2f c8	 comiss	 xmm1, xmm0
  0021f	76 1b		 jbe	 SHORT $LN16@gObjRestPo
  00221	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00224	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  0022c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0022f	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  00237	f3 0f 11 45 fc	 movss	 DWORD PTR _tlife$6[ebp], xmm0
$LN16@gObjRestPo:

; 23299: 			lpObj->Life = tlife;

  0023c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0023f	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _tlife$6[ebp]
  00244	f3 0f 11 80 bc
	00 00 00	 movss	 DWORD PTR [eax+188], xmm0

; 23300: 
; 23301: #ifdef ADD_SHIELD_POINT_01_20060403
; 23302: 			GCReFillSend(lpObj->m_Index, (WORD)lpObj->Life, 0xFF, 0, (WORD)lpObj->iShield);
; 23303: #else
; 23304: 			GCReFillSend(lpObj->m_Index, (WORD)lpObj->Life, 0xFF, 0);

  0024c	6a 00		 push	 0
  0024e	68 ff 00 00 00	 push	 255			; 000000ffH
  00253	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00256	f3 0f 2c 88 bc
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+188]
  0025e	0f b7 d1	 movzx	 edx, cx
  00261	52		 push	 edx
  00262	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00265	8b 08		 mov	 ecx, DWORD PTR [eax]
  00267	51		 push	 ecx
  00268	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  0026d	83 c4 10	 add	 esp, 16			; 00000010H

; 23305: #endif
; 23306: 
; 23307: #ifdef ADD_CASHITEM_4RD_MARK_20080723
; 23308: 			{
; 23309: 				int nPercentMana = 3;
; 23310: 				int nPercent = gObjGetTotalValueOfEffect( lpObj, EFFECTTYPE_RECOVERY_MANA );
; 23311: 				if (nPercent > 0)
; 23312: 					nPercentMana += nPercent;
; 23313: 				
; 23314: 				tmana = (lpObj->Mana+lpObj->AddMana);
; 23315: 				tmana += (((lpObj->MaxMana+lpObj->AddMana)*nPercentMana)/100);
; 23316: 			}
; 23317: #else
; 23318: 			tmana = (lpObj->Mana+lpObj->AddMana);

  00270	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00273	f3 0f 2a 80 10
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+272]
  0027b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0027e	f3 0f 58 81 d0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+208]
  00286	f3 0f 11 45 f8	 movss	 DWORD PTR _tmana$5[ebp], xmm0

; 23319: 			tmana += (((lpObj->MaxMana+lpObj->AddMana)*3)/100);

  0028b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028e	f3 0f 2a 80 10
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+272]
  00296	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00299	f3 0f 58 81 d4
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+212]
  002a1	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40400000
  002a9	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  002b1	f3 0f 58 45 f8	 addss	 xmm0, DWORD PTR _tmana$5[ebp]
  002b6	f3 0f 11 45 f8	 movss	 DWORD PTR _tmana$5[ebp], xmm0

; 23320: #endif // ADD_CASHITEM_4RD_MARK_20080723
; 23321: 
; 23322: #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 23323: 			//      :    
; 23324: 			tmana += lpObj->m_JewelOfHarmonyEffect.HJOpAddRefillMP;
; 23325: #endif	// ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 23326: 			if( tmana > (lpObj->MaxMana+lpObj->AddMana) ) tmana = lpObj->MaxMana+lpObj->AddMana;

  002bb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002be	f3 0f 2a 80 10
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+272]
  002c6	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002c9	f3 0f 58 81 d4
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+212]
  002d1	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _tmana$5[ebp]
  002d6	0f 2f c8	 comiss	 xmm1, xmm0
  002d9	76 1b		 jbe	 SHORT $LN17@gObjRestPo
  002db	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002de	f3 0f 2a 80 10
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+272]
  002e6	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002e9	f3 0f 58 81 d4
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+212]
  002f1	f3 0f 11 45 f8	 movss	 DWORD PTR _tmana$5[ebp], xmm0
$LN17@gObjRestPo:

; 23327: 			lpObj->Mana = tmana;

  002f6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002f9	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _tmana$5[ebp]
  002fe	f3 0f 11 80 d0
	00 00 00	 movss	 DWORD PTR [eax+208], xmm0

; 23328: 
; 23329: #ifdef NEW_FORSKYLAND2
; 23330: 			GCManaSend(lpObj->m_Index, (short)lpObj->Mana, 0xFF, 0, lpObj->BP);

  00306	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00309	0f b7 88 e8 00
	00 00		 movzx	 ecx, WORD PTR [eax+232]
  00310	51		 push	 ecx
  00311	6a 00		 push	 0
  00313	68 ff 00 00 00	 push	 255			; 000000ffH
  00318	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0031b	f3 0f 2c 82 d0
	00 00 00	 cvttss2si eax, DWORD PTR [edx+208]
  00323	0f b7 c8	 movzx	 ecx, ax
  00326	51		 push	 ecx
  00327	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0032a	8b 02		 mov	 eax, DWORD PTR [edx]
  0032c	50		 push	 eax
  0032d	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  00332	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@gObjRestPo:

; 23331: #else
; 23332: 			GCManaSend(lpObj->m_Index, (short)lpObj->Mana, 0xFF, 0, 0);
; 23333: #endif
; 23334: 		}
; 23335: 
; 23336: 	}

  00335	e9 69 03 00 00	 jmp	 $LN35@gObjRestPo
$LN2@gObjRestPo:

; 23337: 	else	//        ..
; 23338: 	{
; 23339: 		int  percent=0;

  0033a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _percent$3[ebp], 0

; 23340: 
; 23341: 		if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].IsItem() == TRUE )

  00341	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00346	6b c8 0a	 imul	 ecx, eax, 10
  00349	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0034c	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00352	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00357	83 f8 01	 cmp	 eax, 1
  0035a	0f 85 80 00 00
	00		 jne	 $LN21@gObjRestPo

; 23342: 		{
; 23343: 			if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Option3 )

  00360	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00365	6b c8 0a	 imul	 ecx, eax, 10
  00368	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0036b	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00371	0f b6 4c 08 7a	 movzx	 ecx, BYTE PTR [eax+ecx+122]
  00376	85 c9		 test	 ecx, ecx
  00378	74 66		 je	 SHORT $LN21@gObjRestPo

; 23344: 			{
; 23345: 				if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability != 0.f )

  0037a	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0037f	6b c8 0a	 imul	 ecx, eax, 10
  00382	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00385	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0038b	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  00391	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00398	9f		 lahf
  00399	f6 c4 44	 test	 ah, 68			; 00000044H
  0039c	7b 42		 jnp	 SHORT $LN21@gObjRestPo

; 23346: 				{
; 23347: #ifdef MODIFY_ACCUMULATED_BUG_AMULETRING_WRONG_OPTION_01_20050531
; 23348: 					//     .
; 23349: 					if( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type != MAKE_ITEMNUM(13,24) )

  0039e	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  003a3	6b c8 0a	 imul	 ecx, eax, 10
  003a6	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003a9	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  003af	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  003b4	6a 18		 push	 24			; 00000018H
  003b6	6a 0d		 push	 13			; 0000000dH
  003b8	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  003bd	83 c4 08	 add	 esp, 8
  003c0	3b f0		 cmp	 esi, eax
  003c2	74 1c		 je	 SHORT $LN21@gObjRestPo

; 23350: 					{
; 23351: 						percent+=lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Option3;

  003c4	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  003c9	6b c8 0a	 imul	 ecx, eax, 10
  003cc	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003cf	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  003d5	0f b6 4c 08 7a	 movzx	 ecx, BYTE PTR [eax+ecx+122]
  003da	03 4d f0	 add	 ecx, DWORD PTR _percent$3[ebp]
  003dd	89 4d f0	 mov	 DWORD PTR _percent$3[ebp], ecx
$LN21@gObjRestPo:

; 23352: 					}
; 23353: #else
; 23354: 					percent+=lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Option3;
; 23355: #endif
; 23356: 				}
; 23357: 			}
; 23358: 		}
; 23359: 		if( lpObj->pInventory[EQUIPMENT_RING_LEFT].IsItem() == TRUE )

  003e0	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  003e5	6b c8 0b	 imul	 ecx, eax, 11
  003e8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003eb	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  003f1	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  003f6	83 f8 01	 cmp	 eax, 1
  003f9	0f 85 80 00 00
	00		 jne	 $LN25@gObjRestPo

; 23360: 		{
; 23361: 			if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Option3 )

  003ff	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00404	6b c8 0b	 imul	 ecx, eax, 11
  00407	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0040a	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00410	0f b6 4c 08 7a	 movzx	 ecx, BYTE PTR [eax+ecx+122]
  00415	85 c9		 test	 ecx, ecx
  00417	74 66		 je	 SHORT $LN25@gObjRestPo

; 23362: 			{
; 23363: 				if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability != 0.f )

  00419	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0041e	6b c8 0b	 imul	 ecx, eax, 11
  00421	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00424	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0042a	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  00430	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00437	9f		 lahf
  00438	f6 c4 44	 test	 ah, 68			; 00000044H
  0043b	7b 42		 jnp	 SHORT $LN25@gObjRestPo

; 23364: 				{
; 23365: #ifdef MODIFY_ACCUMULATED_BUG_AMULETRING_WRONG_OPTION_01_20050531
; 23366: 					//     .
; 23367: 					if( lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type != MAKE_ITEMNUM(13,24) )

  0043d	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00442	6b c8 0b	 imul	 ecx, eax, 11
  00445	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00448	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0044e	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00453	6a 18		 push	 24			; 00000018H
  00455	6a 0d		 push	 13			; 0000000dH
  00457	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0045c	83 c4 08	 add	 esp, 8
  0045f	3b f0		 cmp	 esi, eax
  00461	74 1c		 je	 SHORT $LN25@gObjRestPo

; 23368: 					{
; 23369: 						percent+=lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Option3;

  00463	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00468	6b c8 0b	 imul	 ecx, eax, 11
  0046b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0046e	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00474	0f b6 4c 08 7a	 movzx	 ecx, BYTE PTR [eax+ecx+122]
  00479	03 4d f0	 add	 ecx, DWORD PTR _percent$3[ebp]
  0047c	89 4d f0	 mov	 DWORD PTR _percent$3[ebp], ecx
$LN25@gObjRestPo:

; 23370: 					}
; 23371: #else
; 23372: 					percent+=lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Option3;
; 23373: #endif
; 23374: 				}
; 23375: 			}
; 23376: 		}
; 23377: 		if( lpObj->pInventory[EQUIPMENT_AMULET].IsItem() == TRUE )

  0047f	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00484	6b c8 09	 imul	 ecx, eax, 9
  00487	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0048a	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00490	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00495	83 f8 01	 cmp	 eax, 1
  00498	0f 85 80 00 00
	00		 jne	 $LN29@gObjRestPo

; 23378: 		{
; 23379: 			if( lpObj->pInventory[EQUIPMENT_AMULET].m_Option3 )

  0049e	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  004a3	6b c8 09	 imul	 ecx, eax, 9
  004a6	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004a9	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  004af	0f b6 4c 08 7a	 movzx	 ecx, BYTE PTR [eax+ecx+122]
  004b4	85 c9		 test	 ecx, ecx
  004b6	74 66		 je	 SHORT $LN29@gObjRestPo

; 23380: 			{
; 23381: 				if( lpObj->pInventory[EQUIPMENT_AMULET].m_Durability != 0.f )

  004b8	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  004bd	6b c8 09	 imul	 ecx, eax, 9
  004c0	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004c3	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  004c9	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  004cf	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  004d6	9f		 lahf
  004d7	f6 c4 44	 test	 ah, 68			; 00000044H
  004da	7b 42		 jnp	 SHORT $LN29@gObjRestPo

; 23382: 				{
; 23383: #ifdef MODIFY_ACCUMULATED_BUG_AMULETRING_WRONG_OPTION_01_20050531
; 23384: 					//     .
; 23385: 					if( lpObj->pInventory[EQUIPMENT_AMULET].m_Type != MAKE_ITEMNUM(13,28) )

  004dc	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  004e1	6b c8 09	 imul	 ecx, eax, 9
  004e4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004e7	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  004ed	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  004f2	6a 1c		 push	 28			; 0000001cH
  004f4	6a 0d		 push	 13			; 0000000dH
  004f6	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  004fb	83 c4 08	 add	 esp, 8
  004fe	3b f0		 cmp	 esi, eax
  00500	74 1c		 je	 SHORT $LN29@gObjRestPo

; 23386: 					{
; 23387: 						percent+=lpObj->pInventory[EQUIPMENT_AMULET].m_Option3;

  00502	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00507	6b c8 09	 imul	 ecx, eax, 9
  0050a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0050d	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00513	0f b6 4c 08 7a	 movzx	 ecx, BYTE PTR [eax+ecx+122]
  00518	03 4d f0	 add	 ecx, DWORD PTR _percent$3[ebp]
  0051b	89 4d f0	 mov	 DWORD PTR _percent$3[ebp], ecx
$LN29@gObjRestPo:

; 23388: 					}
; 23389: #else
; 23390: 					percent+=lpObj->pInventory[EQUIPMENT_AMULET].m_Option3;
; 23391: #endif;
; 23392: 				}
; 23393: 			}
; 23394: 		}
; 23395: 		if( lpObj->pInventory[EQUIPMENT_WING].IsItem() == TRUE )

  0051e	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00523	6b c8 07	 imul	 ecx, eax, 7
  00526	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00529	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0052f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00534	83 f8 01	 cmp	 eax, 1
  00537	75 7e		 jne	 SHORT $LN33@gObjRestPo

; 23396: 		{
; 23397: 			if( lpObj->pInventory[EQUIPMENT_WING].m_Option3 )

  00539	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0053e	6b c8 07	 imul	 ecx, eax, 7
  00541	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00544	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0054a	0f b6 4c 08 7a	 movzx	 ecx, BYTE PTR [eax+ecx+122]
  0054f	85 c9		 test	 ecx, ecx
  00551	74 64		 je	 SHORT $LN33@gObjRestPo

; 23398: 			{
; 23399: 				if( lpObj->pInventory[EQUIPMENT_WING].m_Special[2] == AT_LIFE_REGENERATION)

  00553	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00558	6b c8 07	 imul	 ecx, eax, 7
  0055b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0055e	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00564	03 c1		 add	 eax, ecx
  00566	b9 01 00 00 00	 mov	 ecx, 1
  0056b	d1 e1		 shl	 ecx, 1
  0056d	0f b6 54 08 31	 movzx	 edx, BYTE PTR [eax+ecx+49]
  00572	83 fa 55	 cmp	 edx, 85			; 00000055H
  00575	75 40		 jne	 SHORT $LN33@gObjRestPo

; 23400: 				{
; 23401: 					if( lpObj->pInventory[EQUIPMENT_WING].m_Durability != 0.f )

  00577	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0057c	6b c8 07	 imul	 ecx, eax, 7
  0057f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00582	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00588	f3 0f 10 44 08
	24		 movss	 xmm0, DWORD PTR [eax+ecx+36]
  0058e	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00595	9f		 lahf
  00596	f6 c4 44	 test	 ah, 68			; 00000044H
  00599	7b 1c		 jnp	 SHORT $LN33@gObjRestPo

; 23402: 					{
; 23403: 						percent+=lpObj->pInventory[EQUIPMENT_WING].m_Option3;

  0059b	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  005a0	6b c8 07	 imul	 ecx, eax, 7
  005a3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005a6	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  005ac	0f b6 4c 08 7a	 movzx	 ecx, BYTE PTR [eax+ecx+122]
  005b1	03 4d f0	 add	 ecx, DWORD PTR _percent$3[ebp]
  005b4	89 4d f0	 mov	 DWORD PTR _percent$3[ebp], ecx
$LN33@gObjRestPo:

; 23404: 					}
; 23405: 				}
; 23406: 			}
; 23407: 		}
; 23408: 
; 23409: #ifdef ADD_CASHITEM_4RD_MARK_20080723
; 23410: 		{
; 23411: 			if ( !CHECK_BLOODCASTLE(lpObj->MapNumber) && !CHECK_CHAOSCASTLE(lpObj->MapNumber) 
; 23412: 				&& !CHECK_KALIMAMAP(lpObj->MapNumber) && !CHECK_DEVILSQUARE(lpObj->MapNumber)
; 23413: 				&& !CHECK_ILLUSION_TEMPLE(lpObj->MapNumber) 
; 23414: 				&& (lpObj->MapNumber != MAP_INDEX_CASTLESIEGE) &&  (lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)
; 23415: 				)
; 23416: 			{
; 23417: 				int nPercent = gObjGetTotalValueOfEffect( lpObj, EFFECTTYPE_RECOVERY_HP );
; 23418: 				if( nPercent > 0 )
; 23419: 					percent += nPercent;
; 23420: 			}
; 23421: 		}
; 23422: #endif // ADD_CASHITEM_4RD_MARK_20080723
; 23423: 
; 23424: #ifndef MODIFY_SOCKET_ITEM_NEW_OPTION_20080818						// !! NOT
; 23425: 	#ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_04_20080710
; 23426: 		if( lpObj->m_btRefillHPSocketOption > 0 )
; 23427: 		{
; 23428: 			percent += lpObj->m_btRefillHPSocketOption;
; 23429: 		}
; 23430: 	#endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_04_20080710
; 23431: #endif // MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 23432: 
; 23433: 		if( percent  )

  005b7	83 7d f0 00	 cmp	 DWORD PTR _percent$3[ebp], 0
  005bb	0f 84 e2 00 00
	00		 je	 $LN35@gObjRestPo

; 23434: 		{
; 23435: #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122	//  1 -    
; 23436: 			if( lpObj->m_MPSkillOpt.iMpsAutoRecoverLife > 0 )
; 23437: 			{	//     .
; 23438: 				percent += lpObj->m_MPSkillOpt.iMpsAutoRecoverLife;
; 23439: 			}		
; 23440: #endif
; 23441: 			float tlife;
; 23442: 			//float tmana;
; 23443: 			
; 23444: 			lpObj->m_LifeFillCount++;

  005c1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005c4	8a 88 3e 02 00
	00		 mov	 cl, BYTE PTR [eax+574]
  005ca	80 c1 01	 add	 cl, 1
  005cd	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005d0	88 8a 3e 02 00
	00		 mov	 BYTE PTR [edx+574], cl

; 23445: 			if( lpObj->m_LifeFillCount > 6 )

  005d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005d9	0f be 88 3e 02
	00 00		 movsx	 ecx, BYTE PTR [eax+574]
  005e0	83 f9 06	 cmp	 ecx, 6
  005e3	0f 8e ba 00 00
	00		 jle	 $LN35@gObjRestPo

; 23446: 			{
; 23447: 				lpObj->m_LifeFillCount = 0;

  005e9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005ec	c6 80 3e 02 00
	00 00		 mov	 BYTE PTR [eax+574], 0

; 23448: 				tlife  = lpObj->Life;

  005f3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005f6	f3 0f 10 80 bc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+188]
  005fe	f3 0f 11 45 ec	 movss	 DWORD PTR _tlife$2[ebp], xmm0

; 23449: 				tlife += (((lpObj->MaxLife+lpObj->AddLife)*percent)/100);

  00603	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00606	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  0060e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00611	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  00619	f3 0f 2a 4d f0	 cvtsi2ss xmm1, DWORD PTR _percent$3[ebp]
  0061e	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00622	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  0062a	f3 0f 58 45 ec	 addss	 xmm0, DWORD PTR _tlife$2[ebp]
  0062f	f3 0f 11 45 ec	 movss	 DWORD PTR _tlife$2[ebp], xmm0

; 23450: #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 23451: 				//      :    
; 23452: 				//   (/)      .
; 23453: 				tlife += lpObj->m_JewelOfHarmonyEffect.HJOpAddRefillHP;
; 23454: #endif	// ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 23455: 
; 23456: #ifdef MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 23457: 				if( lpObj->m_btRefillHPSocketOption > 0 )
; 23458: 				{
; 23459: 					tlife += lpObj->m_btRefillHPSocketOption;
; 23460: 				}
; 23461: #endif // MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 23462: 
; 23463: 				if( tlife > (lpObj->MaxLife+lpObj->AddLife) ) tlife = (lpObj->MaxLife+lpObj->AddLife);

  00634	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00637	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  0063f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00642	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  0064a	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _tlife$2[ebp]
  0064f	0f 2f c8	 comiss	 xmm1, xmm0
  00652	76 1b		 jbe	 SHORT $LN36@gObjRestPo
  00654	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00657	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  0065f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00662	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  0066a	f3 0f 11 45 ec	 movss	 DWORD PTR _tlife$2[ebp], xmm0
$LN36@gObjRestPo:

; 23464: 				lpObj->Life = tlife;

  0066f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00672	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _tlife$2[ebp]
  00677	f3 0f 11 80 bc
	00 00 00	 movss	 DWORD PTR [eax+188], xmm0

; 23465: 
; 23466: #ifdef ADD_SHIELD_POINT_01_20060403
; 23467: 				GCReFillSend(lpObj->m_Index, (WORD)lpObj->Life, 0xFF, 0, (WORD)lpObj->iShield);
; 23468: #else
; 23469: 				GCReFillSend(lpObj->m_Index, (WORD)lpObj->Life, 0xFF, 0);

  0067f	6a 00		 push	 0
  00681	68 ff 00 00 00	 push	 255			; 000000ffH
  00686	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00689	f3 0f 2c 88 bc
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+188]
  00691	0f b7 d1	 movzx	 edx, cx
  00694	52		 push	 edx
  00695	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00698	8b 08		 mov	 ecx, DWORD PTR [eax]
  0069a	51		 push	 ecx
  0069b	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  006a0	83 c4 10	 add	 esp, 16			; 00000010H
$LN35@gObjRestPo:

; 23470: #endif
; 23471: 		
; 23472: 				/*
; 23473: 				int tmana = 0;
; 23474: 				tmana = (lpObj->Mana+lpObj->AddMana);
; 23475: 				tmana += (((lpObj->MaxMana+lpObj->AddMana)*3)/100);
; 23476: 				if( tmana > (lpObj->MaxMana+lpObj->AddMana) ) tmana = lpObj->MaxMana+lpObj->AddMana;
; 23477: 				lpObj->Mana = tmana;
; 23478: 				GCManaSend(lpObj->m_Index, (WORD)lpObj->Mana, 0xFF, 0);		
; 23479: 				*/
; 23480: 			}
; 23481: 		}
; 23482: 	}
; 23483: 	
; 23484: #ifdef ADD_SHIELD_POINT_01_20060403
; 23485: 
; 23486: 	// CODEREVIEW_SHIELD : iFillShieldCount   
; 23487: 	if( lpObj->iFillShield > 0 )
; 23488: 	{
; 23489: 		int iFillSDPoint = 0;
; 23490: 
; 23491: 		if ( lpObj->iFillShieldCount <= 0 )
; 23492: 		{
; 23493: 			lpObj->iFillShieldCount = 1;
; 23494: 		}
; 23495: 
; 23496: 		iFillSDPoint= ( lpObj->iFillShieldMax / lpObj->iFillShieldCount );
; 23497: 		lpObj->iShield		= lpObj->iShield + iFillSDPoint;
; 23498: 		lpObj->iFillShield	= lpObj->iFillShield - iFillSDPoint;
; 23499: 
; 23500: 		if( lpObj->iFillShield < iFillSDPoint )
; 23501: 		{
; 23502: 			iFillSDPoint = lpObj->iFillShield;
; 23503: 			lpObj->iFillShield = 0;
; 23504: 			if( iFillSDPoint < 0 )
; 23505: 			{
; 23506: 				iFillSDPoint = 0;
; 23507: 			}
; 23508: 		}
; 23509: 
; 23510: 		if( lpObj->iShield > ( lpObj->iMaxShield + lpObj->iAddShield ) )
; 23511: 		{
; 23512: 			lpObj->iShield = ( lpObj->iMaxShield + lpObj->iAddShield );
; 23513: 			lpObj->iFillShield = 0;
; 23514: 			lpObj->iFillShieldMax = 0;
; 23515: 		}
; 23516: 
; 23517: 		GCReFillSend( lpObj->m_Index, (WORD)lpObj->Life, 0xFF, 0, (WORD)lpObj->iShield );
; 23518: 	}
; 23519: #endif
; 23520: 	
; 23521: 	if( lpObj->FillLife > 0.f )

  006a3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006a6	f3 0f 10 80 c8
	00 00 00	 movss	 xmm0, DWORD PTR [eax+200]
  006ae	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  006b5	0f 86 40 01 00
	00		 jbe	 $LN37@gObjRestPo

; 23522: 	{
; 23523: #ifdef ADD_HP_POTION_LEVEL1_20040401
; 23524: 		float cur = (lpObj->FillLifeMax*34)/100;

  006bb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006be	f3 0f 10 80 cc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+204]
  006c6	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@42080000
  006ce	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  006d6	f3 0f 11 45 e8	 movss	 DWORD PTR _cur$1[ebp], xmm0

; 23525: 
; 23526: 		if( lpObj->FillLifeCount == 2 )

  006db	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006de	0f b6 88 df 00
	00 00		 movzx	 ecx, BYTE PTR [eax+223]
  006e5	83 f9 02	 cmp	 ecx, 2
  006e8	75 20		 jne	 SHORT $LN38@gObjRestPo

; 23527: 		{
; 23528: 			cur = (lpObj->FillLifeMax*54)/100;

  006ea	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006ed	f3 0f 10 80 cc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+204]
  006f5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@42580000
  006fd	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00705	f3 0f 11 45 e8	 movss	 DWORD PTR _cur$1[ebp], xmm0
$LN38@gObjRestPo:

; 23529: 		}
; 23530: #else
; 23531: 		float cur = (lpObj->FillLifeMax*30)/100;
; 23532: #endif
; 23533: #ifdef ADD_SHIELD_POINT_01_20060403
; 23534: 		if( lpObj->FillLifeCount == 4 )
; 23535: 		{
; 23536: 			cur = (lpObj->FillLifeMax*25)/100;
; 23537: 		}
; 23538: #endif
; 23539: 		if( lpObj->FillLife < cur )

  0070a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0070d	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _cur$1[ebp]
  00712	0f 2f 80 c8 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+200]
  00719	76 31		 jbe	 SHORT $LN39@gObjRestPo

; 23540: 		{
; 23541: 			//lpObj->FillLife -= cur;
; 23542: 			cur = lpObj->FillLife;

  0071b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0071e	f3 0f 10 80 c8
	00 00 00	 movss	 xmm0, DWORD PTR [eax+200]
  00726	f3 0f 11 45 e8	 movss	 DWORD PTR _cur$1[ebp], xmm0

; 23543: 			lpObj->FillLife = 0;

  0072b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0072e	0f 57 c0	 xorps	 xmm0, xmm0
  00731	f3 0f 11 80 c8
	00 00 00	 movss	 DWORD PTR [eax+200], xmm0

; 23544: 			if( cur < 0 ) cur = 0;

  00739	0f 57 c0	 xorps	 xmm0, xmm0
  0073c	0f 2f 45 e8	 comiss	 xmm0, DWORD PTR _cur$1[ebp]
  00740	76 08		 jbe	 SHORT $LN41@gObjRestPo
  00742	0f 57 c0	 xorps	 xmm0, xmm0
  00745	f3 0f 11 45 e8	 movss	 DWORD PTR _cur$1[ebp], xmm0
$LN41@gObjRestPo:

; 23545: 		}

  0074a	eb 1b		 jmp	 SHORT $LN40@gObjRestPo
$LN39@gObjRestPo:

; 23546: 		else
; 23547: 		{
; 23548: 			lpObj->FillLife -= cur;

  0074c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0074f	f3 0f 10 80 c8
	00 00 00	 movss	 xmm0, DWORD PTR [eax+200]
  00757	f3 0f 5c 45 e8	 subss	 xmm0, DWORD PTR _cur$1[ebp]
  0075c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0075f	f3 0f 11 81 c8
	00 00 00	 movss	 DWORD PTR [ecx+200], xmm0
$LN40@gObjRestPo:

; 23549: 		}
; 23550: 		lpObj->Life += cur;

  00767	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0076a	f3 0f 10 80 bc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+188]
  00772	f3 0f 58 45 e8	 addss	 xmm0, DWORD PTR _cur$1[ebp]
  00777	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0077a	f3 0f 11 81 bc
	00 00 00	 movss	 DWORD PTR [ecx+188], xmm0

; 23551: 		if( lpObj->Life > (lpObj->MaxLife+lpObj->AddLife) ) 

  00782	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00785	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  0078d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00790	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  00798	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0079b	f3 0f 10 8a bc
	00 00 00	 movss	 xmm1, DWORD PTR [edx+188]
  007a3	0f 2f c8	 comiss	 xmm1, xmm0
  007a6	76 2f		 jbe	 SHORT $LN42@gObjRestPo

; 23552: 		{
; 23553: 			lpObj->Life = (lpObj->MaxLife+lpObj->AddLife);

  007a8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007ab	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  007b3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  007b6	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  007be	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  007c1	f3 0f 11 82 bc
	00 00 00	 movss	 DWORD PTR [edx+188], xmm0

; 23554: 			lpObj->FillLife = 0;	//    .

  007c9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007cc	0f 57 c0	 xorps	 xmm0, xmm0
  007cf	f3 0f 11 80 c8
	00 00 00	 movss	 DWORD PTR [eax+200], xmm0
$LN42@gObjRestPo:

; 23555: 		}
; 23556: #ifdef ADD_SHIELD_POINT_01_20060403
; 23557: 		GCReFillSend(lpObj->m_Index, (WORD)lpObj->Life, 0xFF, 0, (WORD)lpObj->iShield);
; 23558: #else
; 23559: 		GCReFillSend(lpObj->m_Index, (WORD)lpObj->Life, 0xFF, 0);

  007d7	6a 00		 push	 0
  007d9	68 ff 00 00 00	 push	 255			; 000000ffH
  007de	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007e1	f3 0f 2c 88 bc
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+188]
  007e9	0f b7 d1	 movzx	 edx, cx
  007ec	52		 push	 edx
  007ed	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007f0	8b 08		 mov	 ecx, DWORD PTR [eax]
  007f2	51		 push	 ecx
  007f3	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  007f8	83 c4 10	 add	 esp, 16			; 00000010H
$LN37@gObjRestPo:

; 23560: #endif
; 23561: 	}
; 23562: }

  007fb	5f		 pop	 edi
  007fc	5e		 pop	 esi
  007fd	5b		 pop	 ebx
  007fe	8b e5		 mov	 esp, ebp
  00800	5d		 pop	 ebp
  00801	c3		 ret	 0
?gObjRestPotionFill@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjRestPotionFill
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjManaPotionFill@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_bp$1 = -28						; size = 4
_iaddbppoint$2 = -24					; size = 4
_attr$3 = -17						; size = 1
_addbp$4 = -16						; size = 4
_maxbp$5 = -12						; size = 4
_ChangeMana$ = -8					; size = 4
_tmana$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjManaPotionFill@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjManaPotionFill, COMDAT

; 23066: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 23067: 	lpObj->m_ManaFillCount++;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	8a 88 3d 02 00
	00		 mov	 cl, BYTE PTR [eax+573]
  00012	80 c1 01	 add	 cl, 1
  00015	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00018	88 8a 3d 02 00
	00		 mov	 BYTE PTR [edx+573], cl

; 23068: 	float tmana;
; 23069: 	BOOL  ChangeMana = FALSE;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ChangeMana$[ebp], 0

; 23070: 	if( lpObj->m_ManaFillCount > 2 )

  00025	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00028	0f be 88 3d 02
	00 00		 movsx	 ecx, BYTE PTR [eax+573]
  0002f	83 f9 02	 cmp	 ecx, 2
  00032	0f 8e e9 01 00
	00		 jle	 $LN11@gObjManaPo

; 23071: 	{
; 23072: 		lpObj->m_ManaFillCount = 0;

  00038	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003b	c6 80 3d 02 00
	00 00		 mov	 BYTE PTR [eax+573], 0

; 23073: 		if( lpObj->Mana < lpObj->MaxMana+lpObj->AddMana )

  00042	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00045	f3 0f 2a 80 10
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+272]
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00050	f3 0f 58 81 d4
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+212]
  00058	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0005b	0f 2f 82 d0 00
	00 00		 comiss	 xmm0, DWORD PTR [edx+208]
  00062	0f 86 8a 00 00
	00		 jbe	 $LN3@gObjManaPo

; 23074: 		{
; 23075: #ifdef ADD_CASHITEM_4RD_MARK_20080723
; 23076: 			{
; 23077: 				float fPercent = 0.037f;
; 23078: 				if ( !CHECK_BLOODCASTLE(lpObj->MapNumber) && !CHECK_CHAOSCASTLE(lpObj->MapNumber) 
; 23079: 					&& !CHECK_KALIMAMAP(lpObj->MapNumber) && !CHECK_DEVILSQUARE(lpObj->MapNumber)
; 23080: 					&& !CHECK_ILLUSION_TEMPLE(lpObj->MapNumber) 
; 23081: 					&& (lpObj->MapNumber != MAP_INDEX_CASTLESIEGE) &&  (lpObj->MapNumber != MAP_INDEX_CASTLEHUNTZONE)
; 23082: 					)
; 23083: 				{
; 23084: 					int nPercent = gObjGetTotalValueOfEffect( lpObj, EFFECTTYPE_RECOVERY_MANA );
; 23085: 					if (nPercent > 0)
; 23086: 						fPercent += ((float)nPercent/100);
; 23087: 				}
; 23088: 				
; 23089: 				tmana = lpObj->Mana;
; 23090: 				tmana += (lpObj->MaxMana+lpObj->AddMana)*fPercent;
; 23091: 			}
; 23092: #else
; 23093: 			tmana = lpObj->Mana;

  00068	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006b	f3 0f 10 80 d0
	00 00 00	 movss	 xmm0, DWORD PTR [eax+208]
  00073	f3 0f 11 45 fc	 movss	 DWORD PTR _tmana$[ebp], xmm0

; 23094: 			tmana += (lpObj->MaxMana+lpObj->AddMana)*0.037f;

  00078	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007b	f3 0f 2a 80 10
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+272]
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00086	f3 0f 58 81 d4
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+212]
  0008e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3d178d50
  00096	f3 0f 58 45 fc	 addss	 xmm0, DWORD PTR _tmana$[ebp]
  0009b	f3 0f 11 45 fc	 movss	 DWORD PTR _tmana$[ebp], xmm0

; 23095: #endif // ADD_CASHITEM_4RD_MARK_20080723
; 23096: 
; 23097: #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 23098: 			//      :    
; 23099: 			tmana += lpObj->m_JewelOfHarmonyEffect.HJOpAddRefillMP;
; 23100: #endif	// ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 23101: 
; 23102: #ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_04_20080710
; 23103: 			if( lpObj->m_btRefillMPSocketOption > 0 )
; 23104: 			{
; 23105: #ifdef MODIFY_BUGFIX_20081119	//      
; 23106: 				tmana += lpObj->m_btRefillMPSocketOption;
; 23107: #else	// MODIFY_BUGFIX_20081119
; 23108: 				tmana += ( ( lpObj->MaxMana + lpObj->AddMana ) * lpObj->m_btRefillMPSocketOption ) / 100;
; 23109: #endif	// MODIFY_BUGFIX_20081119
; 23110: 			}
; 23111: #endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_04_20080710
; 23112: 
; 23113: 			if( tmana > lpObj->MaxMana+lpObj->AddMana ) tmana = lpObj->MaxMana+lpObj->AddMana;

  000a0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a3	f3 0f 2a 80 10
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+272]
  000ab	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ae	f3 0f 58 81 d4
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+212]
  000b6	f3 0f 10 4d fc	 movss	 xmm1, DWORD PTR _tmana$[ebp]
  000bb	0f 2f c8	 comiss	 xmm1, xmm0
  000be	76 1b		 jbe	 SHORT $LN4@gObjManaPo
  000c0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c3	f3 0f 2a 80 10
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+272]
  000cb	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ce	f3 0f 58 81 d4
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+212]
  000d6	f3 0f 11 45 fc	 movss	 DWORD PTR _tmana$[ebp], xmm0
$LN4@gObjManaPo:

; 23114: 			lpObj->Mana = tmana;

  000db	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000de	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _tmana$[ebp]
  000e3	f3 0f 11 80 d0
	00 00 00	 movss	 DWORD PTR [eax+208], xmm0

; 23115: 
; 23116: 			ChangeMana = TRUE;			

  000eb	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _ChangeMana$[ebp], 1
$LN3@gObjManaPo:

; 23117: 		}
; 23118: 
; 23119: #ifdef NEW_FORSKYLAND2
; 23120: 		int maxbp = lpObj->MaxBP+lpObj->AddBP;

  000f2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f5	8b 88 ec 00 00
	00		 mov	 ecx, DWORD PTR [eax+236]
  000fb	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000fe	03 8a f0 00 00
	00		 add	 ecx, DWORD PTR [edx+240]
  00104	89 4d f4	 mov	 DWORD PTR _maxbp$5[ebp], ecx

; 23121: 		if( lpObj->BP < maxbp )

  00107	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010a	8b 88 e8 00 00
	00		 mov	 ecx, DWORD PTR [eax+232]
  00110	3b 4d f4	 cmp	 ecx, DWORD PTR _maxbp$5[ebp]
  00113	0f 8d d3 00 00
	00		 jge	 $LN5@gObjManaPo

; 23122: 		{
; 23123: 			int addbp;
; 23124: 			BYTE attr = MapC[lpObj->MapNumber].GetAttr(lpObj->X, lpObj->Y);

  00119	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011c	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00123	51		 push	 ecx
  00124	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00127	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  0012e	50		 push	 eax
  0012f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00132	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00139	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  0013f	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00145	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0014a	88 45 ef	 mov	 BYTE PTR _attr$3[ebp], al

; 23125: 
; 23126: 			int iaddbppoint = 2;

  0014d	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR _iaddbppoint$2[ebp], 2

; 23127: 			if( attr&MAP_ATTR_SAFTYZONE )

  00154	0f b6 45 ef	 movzx	 eax, BYTE PTR _attr$3[ebp]
  00158	83 e0 01	 and	 eax, 1
  0015b	74 07		 je	 SHORT $LN6@gObjManaPo

; 23128: 			{	//  5%
; 23129: 				iaddbppoint = 5;				

  0015d	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR _iaddbppoint$2[ebp], 5
$LN6@gObjManaPo:

; 23130: 			}
; 23131: //----------->
; 23132: //20081013    - (grooving)
; 23133: // AG  
; 23134: #ifdef ADD_BUFF_XMASEVENT_20080930
; 23135: 			if( true == gObjCheckUsedBuffEffect(lpObj, BUFFTYPE_SANTA_LUCKY) )
; 23136: 			{
; 23137: 				iaddbppoint = 5;
; 23138: 
; 23139: 				if( attr&MAP_ATTR_SAFTYZONE )
; 23140: 				{	//  10%
; 23141: 					iaddbppoint = 10;				
; 23142: 				}
; 23143: 			}
; 23144: #endif //ADD_BUFF_XMASEVENT_20080930
; 23145: //<-----------
; 23146: 			if( lpObj->Class == CLASS_KNIGHT )

  00164	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00167	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0016e	83 f9 01	 cmp	 ecx, 1
  00171	75 14		 jne	 SHORT $LN7@gObjManaPo

; 23147: 			{	
; 23148: 				addbp = iaddbppoint+maxbp*5/100;

  00173	6b 45 f4 05	 imul	 eax, DWORD PTR _maxbp$5[ebp], 5
  00177	99		 cdq
  00178	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0017d	f7 f9		 idiv	 ecx
  0017f	03 45 e8	 add	 eax, DWORD PTR _iaddbppoint$2[ebp]
  00182	89 45 f0	 mov	 DWORD PTR _addbp$4[ebp], eax

; 23149: 			}

  00185	eb 12		 jmp	 SHORT $LN8@gObjManaPo
$LN7@gObjManaPo:

; 23150: 			else
; 23151: 			{
; 23152: 				addbp = iaddbppoint+maxbp*3/100;

  00187	6b 45 f4 03	 imul	 eax, DWORD PTR _maxbp$5[ebp], 3
  0018b	99		 cdq
  0018c	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00191	f7 f9		 idiv	 ecx
  00193	03 45 e8	 add	 eax, DWORD PTR _iaddbppoint$2[ebp]
  00196	89 45 f0	 mov	 DWORD PTR _addbp$4[ebp], eax
$LN8@gObjManaPo:

; 23153: 			}
; 23154: 			
; 23155: #ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116
; 23156: 			//     
; 23157: 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 23158: 			if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_SOUL_POTION ) == true )
; 23159: 	#else
; 23160: 			if( lpObj->m_iPotionSoulTime > 0  ) 
; 23161: 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 23162: 			{
; 23163: 				addbp += CASTLE_SOULPOTION_AG_REFILL_POINT;
; 23164: 			}
; 23165: #endif
; 23166: 
; 23167: 			addbp += lpObj->SetOpIncAGValue;			//  AG 

  00199	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019c	0f bf 88 36 0f
	00 00		 movsx	 ecx, WORD PTR [eax+3894]
  001a3	03 4d f0	 add	 ecx, DWORD PTR _addbp$4[ebp]
  001a6	89 4d f0	 mov	 DWORD PTR _addbp$4[ebp], ecx

; 23168: 
; 23169: 			if( addbp < 1 )	addbp = 1;			

  001a9	83 7d f0 01	 cmp	 DWORD PTR _addbp$4[ebp], 1
  001ad	7d 07		 jge	 SHORT $LN9@gObjManaPo
  001af	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _addbp$4[ebp], 1
$LN9@gObjManaPo:

; 23170: 
; 23171: 			int bp = lpObj->BP;

  001b6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b9	8b 88 e8 00 00
	00		 mov	 ecx, DWORD PTR [eax+232]
  001bf	89 4d e4	 mov	 DWORD PTR _bp$1[ebp], ecx

; 23172: 			bp += addbp;

  001c2	8b 45 e4	 mov	 eax, DWORD PTR _bp$1[ebp]
  001c5	03 45 f0	 add	 eax, DWORD PTR _addbp$4[ebp]
  001c8	89 45 e4	 mov	 DWORD PTR _bp$1[ebp], eax

; 23173: 			if( bp > maxbp)

  001cb	8b 45 e4	 mov	 eax, DWORD PTR _bp$1[ebp]
  001ce	3b 45 f4	 cmp	 eax, DWORD PTR _maxbp$5[ebp]
  001d1	7e 06		 jle	 SHORT $LN10@gObjManaPo

; 23174: 			{
; 23175: 				bp = maxbp;

  001d3	8b 45 f4	 mov	 eax, DWORD PTR _maxbp$5[ebp]
  001d6	89 45 e4	 mov	 DWORD PTR _bp$1[ebp], eax
$LN10@gObjManaPo:

; 23176: 			}
; 23177: 			lpObj->BP = bp;

  001d9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001dc	8b 4d e4	 mov	 ecx, DWORD PTR _bp$1[ebp]
  001df	89 88 e8 00 00
	00		 mov	 DWORD PTR [eax+232], ecx

; 23178: 			ChangeMana = TRUE;

  001e5	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _ChangeMana$[ebp], 1
$LN5@gObjManaPo:

; 23179: 		}
; 23180: #endif
; 23181: 
; 23182: 		if( ChangeMana )

  001ec	83 7d f8 00	 cmp	 DWORD PTR _ChangeMana$[ebp], 0
  001f0	74 2f		 je	 SHORT $LN11@gObjManaPo

; 23183: 		{
; 23184: #ifdef NEW_FORSKYLAND2
; 23185: 			GCManaSend(lpObj->m_Index, (short)lpObj->Mana, 0xFF, 0, lpObj->BP);

  001f2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f5	0f b7 88 e8 00
	00 00		 movzx	 ecx, WORD PTR [eax+232]
  001fc	51		 push	 ecx
  001fd	6a 00		 push	 0
  001ff	68 ff 00 00 00	 push	 255			; 000000ffH
  00204	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00207	f3 0f 2c 82 d0
	00 00 00	 cvttss2si eax, DWORD PTR [edx+208]
  0020f	0f b7 c8	 movzx	 ecx, ax
  00212	51		 push	 ecx
  00213	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00216	8b 02		 mov	 eax, DWORD PTR [edx]
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  0021e	83 c4 14	 add	 esp, 20			; 00000014H
$LN11@gObjManaPo:

; 23186: #else
; 23187: 			GCManaSend(lpObj->m_Index, (short)lpObj->Mana, 0xFF, 0, 0);
; 23188: #endif
; 23189: 		}
; 23190: 	}
; 23191: }

  00221	5f		 pop	 edi
  00222	5e		 pop	 esi
  00223	5b		 pop	 ebx
  00224	8b e5		 mov	 esp, ebp
  00226	5d		 pop	 ebp
  00227	c3		 ret	 0
?gObjManaPotionFill@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjManaPotionFill
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMagicDel@@YAHPAVOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_n$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_aSkill$ = 12						; size = 1
_Level$ = 16						; size = 1
?gObjMagicDel@@YAHPAVOBJECTSTRUCT@@EE@Z PROC		; gObjMagicDel, COMDAT

; 28144: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 28145: #ifdef MODIFY_WEAPONSKILL_STRENGTHEN_ICON_BUGFIX_2ND_20090514
; 28146: 	//////////////////////////////////////////////////////////////////////////
; 28147: 	//       .
; 28148: 	//////////////////////////////////////////////////////////////////////////
; 28149: #else // MODIFY_WEAPONSKILL_STRENGTHEN_ICON_BUGFIX_2ND_20090514
; 28150: 	#ifdef MODIFY_WEAPONSKILL_STRENGTHEN_ICON_BUGFIX_20080807
; 28151: 	if( g_MasterSkillSystem.MLS_WeaponSkillDel(lpObj, aSkill, Level) )
; 28152: 	{
; 28153: 		return -1;
; 28154: 	}
; 28155: 	#endif	// MODIFY_WEAPONSKILL_STRENGTHEN_ICON_BUGFIX_20080807
; 28156: #endif // MODIFY_WEAPONSKILL_STRENGTHEN_ICON_BUGFIX_2ND_20090514
; 28157: 	
; 28158: 	int n;
; 28159: 
; 28160: 	for( n=0; n<MAX_MAGIC; n++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@gObjMagicD
$LN2@gObjMagicD:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjMagicD:
  0001b	83 7d fc 3c	 cmp	 DWORD PTR _n$[ebp], 60	; 0000003cH
  0001f	7d 50		 jge	 SHORT $LN3@gObjMagicD

; 28161: 	{
; 28162: 		if( lpObj->Magic[n].IsMagic() == TRUE )

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  00024	c1 e1 04	 shl	 ecx, 4
  00027	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002a	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  00030	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  00035	83 f8 01	 cmp	 eax, 1
  00038	75 35		 jne	 SHORT $LN5@gObjMagicD

; 28163: 		{
; 28164: 			if( lpObj->Magic[n].m_Skill == aSkill )

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0003d	c1 e0 04	 shl	 eax, 4
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00043	8b 91 10 03 00
	00		 mov	 edx, DWORD PTR [ecx+784]
  00049	0f b6 44 02 05	 movzx	 eax, BYTE PTR [edx+eax+5]
  0004e	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _aSkill$[ebp]
  00052	3b c1		 cmp	 eax, ecx
  00054	75 19		 jne	 SHORT $LN5@gObjMagicD

; 28165: 			{
; 28166: 				lpObj->Magic[n].Clear();				

  00056	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  00059	c1 e1 04	 shl	 ecx, 4
  0005c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005f	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  00065	e8 00 00 00 00	 call	 ?Clear@CMagicInf@@QAEXXZ ; CMagicInf::Clear

; 28167: 				//LogAdd("");
; 28168: 				return n;

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0006d	eb 05		 jmp	 SHORT $LN1@gObjMagicD
$LN5@gObjMagicD:

; 28169: 			}
; 28170: 		}
; 28171: 	}

  0006f	eb a1		 jmp	 SHORT $LN2@gObjMagicD
$LN3@gObjMagicD:

; 28172: 	return -1;

  00071	83 c8 ff	 or	 eax, -1
$LN1@gObjMagicD:

; 28173: }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?gObjMagicDel@@YAHPAVOBJECTSTRUCT@@EE@Z ENDP		; gObjMagicDel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSkillBeAttackProc@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_ad$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjSkillBeAttackProc@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjSkillBeAttackProc, COMDAT

; 25638: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 25639: #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004					// !! NOT
; 25640: 	int ad;
; 25641: #ifdef ADD_SHIELD_POINT_01_20060403
; 25642: 	int iShieldDamage = 0;
; 25643: #endif
; 25644: 	if( lpObj->m_PoisonBeattackCount > 0)	//    

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f be 88 18 1a
	00 00		 movsx	 ecx, BYTE PTR [eax+6680]
  00013	85 c9		 test	 ecx, ecx
  00015	0f 8e 95 01 00
	00		 jle	 $LN2@gObjSkillB

; 25645: 	{
; 25646: 		//lpObj->m_ViewState = 4;
; 25647: 		lpObj->m_PoisonBeattackCount--;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001e	8a 88 18 1a 00
	00		 mov	 cl, BYTE PTR [eax+6680]
  00024	80 e9 01	 sub	 cl, 1
  00027	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0002a	88 8a 18 1a 00
	00		 mov	 BYTE PTR [edx+6680], cl

; 25648: 		if( (lpObj->m_PoisonBeattackCount%3) == 0 )

  00030	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00033	0f be 80 18 1a
	00 00		 movsx	 eax, BYTE PTR [eax+6680]
  0003a	99		 cdq
  0003b	b9 03 00 00 00	 mov	 ecx, 3
  00040	f7 f9		 idiv	 ecx
  00042	85 d2		 test	 edx, edx
  00044	0f 85 61 01 00
	00		 jne	 $LN12@gObjSkillB

; 25649: 		{
; 25650: 
; 25651: #ifdef ADD_SKILL_WITH_COMBO
; 25652: 			if( lpObj->Life > 0 )

  0004a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004d	f3 0f 10 80 bc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+188]
  00055	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0005c	76 57		 jbe	 SHORT $LN5@gObjSkillB

; 25653: 			{
; 25654: 				if( lpObj->m_PoisonType == AT_SKILL_EXPPOISON )

  0005e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00061	0f be 88 21 02
	00 00		 movsx	 ecx, BYTE PTR [eax+545]
  00068	83 f9 26	 cmp	 ecx, 38			; 00000026H
  0006b	75 24		 jne	 SHORT $LN7@gObjSkillB

; 25655: 				{	//   5%
; 25656: 					ad = (int)((lpObj->Life*3)/100);

  0006d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00070	f3 0f 10 80 bc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+188]
  00078	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40400000
  00080	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00088	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0008c	89 4d fc	 mov	 DWORD PTR _ad$[ebp], ecx

; 25657: 				}

  0008f	eb 22		 jmp	 SHORT $LN8@gObjSkillB
$LN7@gObjSkillB:

; 25658: 				else
; 25659: 				{
; 25660: 					ad = (int)((lpObj->Life*3)/100);

  00091	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00094	f3 0f 10 80 bc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+188]
  0009c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40400000
  000a4	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  000ac	f3 0f 2c c8	 cvttss2si ecx, xmm0
  000b0	89 4d fc	 mov	 DWORD PTR _ad$[ebp], ecx
$LN8@gObjSkillB:

; 25661: 				}
; 25662: 			}

  000b3	eb 07		 jmp	 SHORT $LN6@gObjSkillB
$LN5@gObjSkillB:

; 25663: #else
; 25664: 			if( lpObj->Life > 0 )
; 25665: 			{
; 25666: 				ad = (int)((lpObj->Life*3)/100);
; 25667: 			}
; 25668: #endif
; 25669: 			
; 25670: 			else ad = 1;

  000b5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _ad$[ebp], 1
$LN6@gObjSkillB:

; 25671: 			if( ad < 0 ) ad = 0;

  000bc	83 7d fc 00	 cmp	 DWORD PTR _ad$[ebp], 0
  000c0	7d 07		 jge	 SHORT $LN9@gObjSkillB
  000c2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ad$[ebp], 0
$LN9@gObjSkillB:

; 25672: 
; 25673: #ifdef ADD_SHIELD_POINT_01_20060403
; 25674: 			//        Shield  .
; 25675: 			if( g_ShieldSystemOn == TRUE )
; 25676: 			{
; 25677: #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_3_20070731
; 25678: 				if( lpObj->lpAttackObj != NULL && 
; 25679: 					lpObj->Type == OBJTYPE_CHARACTER &&lpObj->lpAttackObj->Type == OBJTYPE_CHARACTER )
; 25680: #else
; 25681: 				if( lpObj->Type == OBJTYPE_CHARACTER && lpObj->lpAttackObj->Type == OBJTYPE_CHARACTER )
; 25682: #endif
; 25683: 				{
; 25684: 					if( lpObj->iShield > ad )
; 25685: 					{
; 25686: 						lpObj->iShield -= ad;
; 25687: 						iShieldDamage = ad;
; 25688: 						ad = 0;
; 25689: 					}
; 25690: 					else
; 25691: 					{
; 25692: 						ad -= lpObj->iShield;
; 25693: 						iShieldDamage = lpObj->iShield;
; 25694: 						lpObj->iShield = 0;
; 25695: 						lpObj->Life -= ad;
; 25696: 						if( lpObj->Life < 0 )
; 25697: 						{
; 25698: 							lpObj->Life = 0;
; 25699: 						}
; 25700: 					}
; 25701: 
; 25702: 	#ifdef SHIELD_POINT_DEBUGLOG
; 25703: 					char Msg[256];
; 25704: 					sprintf(Msg, "[Shield][PoisonDamage]HP:%f,SD:%d,Damage:%d", lpObj->Life, lpObj->iShield, ad );
; 25705: 					GCServerMsgStringSend( Msg, lpObj->m_Index, 1 );
; 25706: 					GCServerMsgStringSend( Msg, lpObj->lpAttackObj->m_Index, 1 );
; 25707: 	#endif
; 25708: 				}
; 25709: 				else
; 25710: 				{
; 25711: 					lpObj->Life -= ad;
; 25712: 					if( lpObj->Life < 0 ) lpObj->Life = 0;
; 25713: 				}
; 25714: 			}
; 25715: 			else
; 25716: 			{
; 25717: 				lpObj->Life -= ad;
; 25718: 				if( lpObj->Life < 0 ) lpObj->Life = 0;
; 25719: 			}
; 25720: #else
; 25721: 			lpObj->Life -= ad;

  000c9	f3 0f 2a 45 fc	 cvtsi2ss xmm0, DWORD PTR _ad$[ebp]
  000ce	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d1	f3 0f 10 88 bc
	00 00 00	 movss	 xmm1, DWORD PTR [eax+188]
  000d9	f3 0f 5c c8	 subss	 xmm1, xmm0
  000dd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000e0	f3 0f 11 89 bc
	00 00 00	 movss	 DWORD PTR [ecx+188], xmm1

; 25722: 			if( lpObj->Life < 0 ) lpObj->Life = 0;

  000e8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000eb	0f 57 c0	 xorps	 xmm0, xmm0
  000ee	0f 2f 80 bc 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+188]
  000f5	76 0e		 jbe	 SHORT $LN10@gObjSkillB
  000f7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000fa	0f 57 c0	 xorps	 xmm0, xmm0
  000fd	f3 0f 11 80 bc
	00 00 00	 movss	 DWORD PTR [eax+188], xmm0
$LN10@gObjSkillB:

; 25723: #endif // ADD_SHIELD_POINT_01_20060403
; 25724: 			
; 25725: #ifdef ADD_SKILL_WITH_COMBO
; 25726: 			if( lpObj->lpAttackObj != NULL )

  00105	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00108	83 b8 30 02 00
	00 00		 cmp	 DWORD PTR [eax+560], 0
  0010f	74 22		 je	 SHORT $LN11@gObjSkillB

; 25727: 			{
; 25728: 	#ifdef ADD_SHIELD_POINT_01_20060403
; 25729: 				gObjLifeCheck(lpObj, lpObj->lpAttackObj, ad, 2, 0, 0, AT_SKILL_POISON, iShieldDamage);
; 25730: 	#else
; 25731: 				gObjLifeCheck(lpObj, lpObj->lpAttackObj, ad, 2, 0, 0, AT_SKILL_POISON);

  00111	6a 01		 push	 1
  00113	6a 00		 push	 0
  00115	6a 00		 push	 0
  00117	6a 02		 push	 2
  00119	8b 45 fc	 mov	 eax, DWORD PTR _ad$[ebp]
  0011c	50		 push	 eax
  0011d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00120	8b 91 30 02 00
	00		 mov	 edx, DWORD PTR [ecx+560]
  00126	52		 push	 edx
  00127	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 ?gObjLifeCheck@@YAXPAVOBJECTSTRUCT@@0HHHHE@Z ; gObjLifeCheck
  00130	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN11@gObjSkillB:

; 25732: 	#endif // ADD_SHIELD_POINT_01_20060403
; 25733: 			}
; 25734: #else
; 25735: 			if( lpObj->lpAttackObj != NULL )
; 25736: 			{
; 25737: 	#ifdef ADD_SHIELD_POINT_01_20060403
; 25738: 				gObjLifeCheck(lpObj, lpObj->lpAttackObj, ad, 1, 0, 0, iShieldDamage);
; 25739: 	#else
; 25740: 				gObjLifeCheck(lpObj, lpObj->lpAttackObj, ad, 1, 0, 0);
; 25741: 	#endif
; 25742: 			}
; 25743: 
; 25744: #endif
; 25745: 			//   .
; 25746: 			if( lpObj->m_PoisonBeattackCount <= 0 )

  00133	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00136	0f be 88 18 1a
	00 00		 movsx	 ecx, BYTE PTR [eax+6680]
  0013d	85 c9		 test	 ecx, ecx
  0013f	7f 6a		 jg	 SHORT $LN12@gObjSkillB

; 25747: 			{
; 25748: 				lpObj->lpAttackObj = NULL;

  00141	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00144	c7 80 30 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+560], 0

; 25749: 
; 25750: #ifdef EXPAND_VIEWSKILLSTATE_WORD_TO_INT_20041122
; 25751: 				DEL_VIEWSKILLSTATE( lpObj->m_ViewSkillState, STATE_POISON );
; 25752: #else
; 25753: 				lpObj->m_ViewSkillState &= 0xFE; //	1 

  0014e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00151	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  00158	81 e1 fe 00 00
	00		 and	 ecx, 254		; 000000feH
  0015e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00161	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 25754: #endif
; 25755: 
; 25756: 				lpObj->m_ViewState = 0;

  00168	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016b	c6 80 be 01 00
	00 00		 mov	 BYTE PTR [eax+446], 0

; 25757: 
; 25758: #ifdef ADD_SKILL_WITH_COMBO
; 25759: 				if( lpObj->m_PoisonType == AT_SKILL_EXPPOISON )

  00172	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00175	0f be 88 21 02
	00 00		 movsx	 ecx, BYTE PTR [eax+545]
  0017c	83 f9 26	 cmp	 ecx, 38			; 00000026H
  0017f	75 12		 jne	 SHORT $LN13@gObjSkillB

; 25760: 				{
; 25761: 					//    
; 25762: 					GCStateInfoSend(lpObj, 0, 0x01);

  00181	6a 01		 push	 1
  00183	6a 00		 push	 0
  00185	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAVOBJECTSTRUCT@@EG@Z ; GCStateInfoSend
  0018e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25763: 				}

  00191	eb 0e		 jmp	 SHORT $LN14@gObjSkillB
$LN13@gObjSkillB:

; 25764: 				else
; 25765: 				{
; 25766: 					//        . 
; 25767: 					GCMagicCancelSend(lpObj, AT_SKILL_POISON);

  00193	6a 01		 push	 1
  00195	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  0019e	83 c4 08	 add	 esp, 8
$LN14@gObjSkillB:

; 25768: 				}
; 25769: 				lpObj->m_PoisonType = 0;

  001a1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a4	c6 80 21 02 00
	00 00		 mov	 BYTE PTR [eax+545], 0
$LN12@gObjSkillB:

; 25770: #else
; 25771: 				GCMagicCancelSend(lpObj, AT_SKILL_POISON);
; 25772: #endif
; 25773: 			}
; 25774: 		}
; 25775: 	}

  001ab	e9 77 01 00 00	 jmp	 $LN24@gObjSkillB
$LN2@gObjSkillB:

; 25776: 	else if( lpObj->m_ColdBeattackCount > 0 ) //   ..

  001b0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b3	0f be 88 19 1a
	00 00		 movsx	 ecx, BYTE PTR [eax+6681]
  001ba	85 c9		 test	 ecx, ecx
  001bc	0f 8e ad 00 00
	00		 jle	 $LN15@gObjSkillB

; 25777: 	{
; 25778: 		//lpObj->m_ViewState = 5;
; 25779: 		lpObj->m_ColdBeattackCount--;

  001c2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c5	8a 88 19 1a 00
	00		 mov	 cl, BYTE PTR [eax+6681]
  001cb	80 e9 01	 sub	 cl, 1
  001ce	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001d1	88 8a 19 1a 00
	00		 mov	 BYTE PTR [edx+6681], cl

; 25780: 
; 25781: 		//   .
; 25782: 		if( lpObj->m_ColdBeattackCount <= 0 )

  001d7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001da	0f be 88 19 1a
	00 00		 movsx	 ecx, BYTE PTR [eax+6681]
  001e1	85 c9		 test	 ecx, ecx
  001e3	0f 8f 81 00 00
	00		 jg	 $LN17@gObjSkillB

; 25783: 		{
; 25784: 			lpObj->lpAttackObj = NULL;

  001e9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ec	c7 80 30 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+560], 0

; 25785: 			lpObj->DelayActionTime = 0;

  001f6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f9	c7 80 1c 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+540], 0

; 25786: 			lpObj->DelayLevel = 0;

  00203	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00206	c6 80 20 02 00
	00 00		 mov	 BYTE PTR [eax+544], 0

; 25787: 			
; 25788: #ifdef EXPAND_VIEWSKILLSTATE_WORD_TO_INT_20041122
; 25789: 			DEL_VIEWSKILLSTATE( lpObj->m_ViewSkillState, STATE_FREEZE );
; 25790: #else
; 25791: 			lpObj->m_ViewSkillState &= 0xFD; //	2 

  0020d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00210	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  00217	81 e1 fd 00 00
	00		 and	 ecx, 253		; 000000fdH
  0021d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00220	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 25792: #endif
; 25793: 			lpObj->m_ViewState = 0;

  00227	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0022a	c6 80 be 01 00
	00 00		 mov	 BYTE PTR [eax+446], 0

; 25794: 
; 25795: #ifdef ADD_SKILL_WITH_COMBO					
; 25796: #ifdef UPDATE_MASTER_LEVEL_4RANK_20080428			//   
; 25797: 			if( lpObj->m_IceType == AT_SKILL_EXPICE 
; 25798: 				|| lpObj->m_IceType == AT_SKILL_ML_STRENGTHEN_EXPICE	//   
; 25799: 				)
; 25800: #else	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 25801: 			if( lpObj->m_IceType == AT_SKILL_EXPICE )

  00231	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00234	0f be 88 22 02
	00 00		 movsx	 ecx, BYTE PTR [eax+546]
  0023b	83 f9 27	 cmp	 ecx, 39			; 00000027H
  0023e	75 12		 jne	 SHORT $LN18@gObjSkillB

; 25802: #endif	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 25803: 			{
; 25804: 				//    .
; 25805: 				GCStateInfoSend(lpObj, 0, 0x02);

  00240	6a 02		 push	 2
  00242	6a 00		 push	 0
  00244	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAVOBJECTSTRUCT@@EG@Z ; GCStateInfoSend
  0024d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25806: 			}

  00250	eb 0e		 jmp	 SHORT $LN19@gObjSkillB
$LN18@gObjSkillB:

; 25807: 			else
; 25808: 			{
; 25809: 				//       .
; 25810: 				GCMagicCancelSend(lpObj, AT_SKILL_SLOW);			

  00252	6a 07		 push	 7
  00254	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00257	50		 push	 eax
  00258	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  0025d	83 c4 08	 add	 esp, 8
$LN19@gObjSkillB:

; 25811: 			}
; 25812: 			lpObj->m_IceType = 0;

  00260	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00263	c6 80 22 02 00
	00 00		 mov	 BYTE PTR [eax+546], 0
$LN17@gObjSkillB:

; 25813: #else
; 25814: 			GCMagicCancelSend(lpObj, AT_SKILL_SLOW);			
; 25815: #endif
; 25816: 		}
; 25817: 	}

  0026a	e9 b8 00 00 00	 jmp	 $LN24@gObjSkillB
$LN15@gObjSkillB:

; 25818: #ifdef ADD_NEW_MAP_KALIMA_20040518
; 25819: 	else if( lpObj->m_ImmuneToMagicCount > 0 ) {	//    .

  0026f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00272	0f be 88 23 02
	00 00		 movsx	 ecx, BYTE PTR [eax+547]
  00279	85 c9		 test	 ecx, ecx
  0027b	7e 52		 jle	 SHORT $LN20@gObjSkillB

; 25820: 		lpObj->m_ImmuneToMagicCount--;

  0027d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00280	8a 88 23 02 00
	00		 mov	 cl, BYTE PTR [eax+547]
  00286	80 e9 01	 sub	 cl, 1
  00289	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0028c	88 8a 23 02 00
	00		 mov	 BYTE PTR [edx+547], cl

; 25821: 
; 25822: 		if( lpObj->m_ImmuneToMagicCount <= 0 )

  00292	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00295	0f be 88 23 02
	00 00		 movsx	 ecx, BYTE PTR [eax+547]
  0029c	85 c9		 test	 ecx, ecx
  0029e	7f 2d		 jg	 SHORT $LN22@gObjSkillB

; 25823: 		{
; 25824: 			lpObj->m_ViewSkillState	&= ~STATE_IMMUNE_TO_MAGIC;

  002a0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a3	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  002aa	81 e1 7f ff ff
	ff		 and	 ecx, -129		; ffffff7fH
  002b0	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002b3	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 25825: 			GCStateInfoSend(lpObj, 1, STATE_IMMUNE_TO_MAGIC);

  002ba	68 80 00 00 00	 push	 128			; 00000080H
  002bf	6a 01		 push	 1
  002c1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c4	50		 push	 eax
  002c5	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAVOBJECTSTRUCT@@EG@Z ; GCStateInfoSend
  002ca	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@gObjSkillB:

; 25826: 		}
; 25827: 	}

  002cd	eb 58		 jmp	 SHORT $LN24@gObjSkillB
$LN20@gObjSkillB:

; 25828: 	else if( lpObj->m_ImmuneToHarmCount > 0 ) {		//    .

  002cf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d2	0f be 88 24 02
	00 00		 movsx	 ecx, BYTE PTR [eax+548]
  002d9	85 c9		 test	 ecx, ecx
  002db	7e 4a		 jle	 SHORT $LN24@gObjSkillB

; 25829: 		lpObj->m_ImmuneToHarmCount--;

  002dd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002e0	8a 88 24 02 00
	00		 mov	 cl, BYTE PTR [eax+548]
  002e6	80 e9 01	 sub	 cl, 1
  002e9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002ec	88 8a 24 02 00
	00		 mov	 BYTE PTR [edx+548], cl

; 25830: 
; 25831: 		if( lpObj->m_ImmuneToHarmCount <= 0 )

  002f2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002f5	0f be 88 24 02
	00 00		 movsx	 ecx, BYTE PTR [eax+548]
  002fc	85 c9		 test	 ecx, ecx
  002fe	7f 27		 jg	 SHORT $LN24@gObjSkillB

; 25832: 		{
; 25833: 			lpObj->m_ViewSkillState	&= ~STATE_IMMUNE_TO_HARM;

  00300	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00303	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  0030a	83 e1 f7	 and	 ecx, -9			; fffffff7H
  0030d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00310	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 25834: 			GCStateInfoSend(lpObj, 0, STATE_IMMUNE_TO_HARM);

  00317	6a 08		 push	 8
  00319	6a 00		 push	 0
  0031b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0031e	50		 push	 eax
  0031f	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAVOBJECTSTRUCT@@EG@Z ; GCStateInfoSend
  00324	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN24@gObjSkillB:

; 25835: 		}
; 25836: 	}
; 25837: #endif
; 25838: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 25839: }

  00327	5f		 pop	 edi
  00328	5e		 pop	 esi
  00329	5b		 pop	 ebx
  0032a	8b e5		 mov	 esp, ebp
  0032c	5d		 pop	 ebp
  0032d	c3		 ret	 0
?gObjSkillBeAttackProc@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjSkillBeAttackProc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjViewportAllDel@@YAXF@Z
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_MVL$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 2
?gObjViewportAllDel@@YAXF@Z PROC			; gObjViewportAllDel, COMDAT

; 20906: void gObjViewportAllDel (short aIndex) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 20907: 	if (!gObjIsConnected(aIndex)) {

  00009	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00013	83 c4 04	 add	 esp, 4
  00016	85 c0		 test	 eax, eax
  00018	75 05		 jne	 SHORT $LN5@gObjViewpo

; 20908: 		return;

  0001a	e9 da 00 00 00	 jmp	 $LN1@gObjViewpo
$LN5@gObjViewpo:

; 20909: 	}
; 20910: 
; 20911: 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  0001f	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00023	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00029	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002f	89 4d fc	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 20912: 	
; 20913: 	int MVL = MAXVIEWPORTOBJECT;

  00032	c7 45 f8 4b 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 75 ; 0000004bH

; 20914: 	if( lpObj->Type == OBJTYPE_MONSTER ) MVL = MAX_MONVIEWPORTOBJECT;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00040	83 f9 02	 cmp	 ecx, 2
  00043	75 07		 jne	 SHORT $LN6@gObjViewpo
  00045	c7 45 f8 14 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 20 ; 00000014H
$LN6@gObjViewpo:

; 20915: 
; 20916: 	for( int n = 0; n < MVL ; n++)

  0004c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00053	eb 09		 jmp	 SHORT $LN4@gObjViewpo
$LN2@gObjViewpo:
  00055	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  00058	83 c0 01	 add	 eax, 1
  0005b	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjViewpo:
  0005e	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  00061	3b 45 f8	 cmp	 eax, DWORD PTR _MVL$[ebp]
  00064	0f 8d 8f 00 00
	00		 jge	 $LN1@gObjViewpo

; 20917: 	{
; 20918: 		//   
; 20919: 		if( (lpObj->VpPlayer[n].state == STVP_CREATE ||

  0006a	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00071	0f be 94 01 64
	03 00 00	 movsx	 edx, BYTE PTR [ecx+eax+868]
  00079	83 fa 01	 cmp	 edx, 1
  0007c	74 14		 je	 SHORT $LN8@gObjViewpo
  0007e	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00085	0f be 94 01 64
	03 00 00	 movsx	 edx, BYTE PTR [ecx+eax+868]
  0008d	83 fa 02	 cmp	 edx, 2
  00090	75 1d		 jne	 SHORT $LN7@gObjViewpo
$LN8@gObjViewpo:

; 20920: 			lpObj->VpPlayer[n].state == STVP_PLAYING)) 
; 20921: 		{
; 20922: 			Viewport2Del (lpObj->VpPlayer[n].number, aIndex);

  00092	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00096	50		 push	 eax
  00097	6b 4d f4 0c	 imul	 ecx, DWORD PTR _n$1[ebp], 12
  0009b	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0009e	0f b7 84 0a 66
	03 00 00	 movzx	 eax, WORD PTR [edx+ecx+870]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ?Viewport2Del@@YAXFH@Z	; Viewport2Del
  000ac	83 c4 08	 add	 esp, 8
$LN7@gObjViewpo:

; 20923: 		}
; 20924: 
; 20925: 		//   
; 20926: 		if( (lpObj->VpPlayer2[n].state == STVP_CREATE ||

  000af	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000b3	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000b6	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  000be	83 fa 01	 cmp	 edx, 1
  000c1	74 14		 je	 SHORT $LN10@gObjViewpo
  000c3	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ca	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  000d2	83 fa 02	 cmp	 edx, 2
  000d5	75 1d		 jne	 SHORT $LN9@gObjViewpo
$LN10@gObjViewpo:

; 20927: 			lpObj->VpPlayer2[n].state == STVP_PLAYING)) 
; 20928: 		{
; 20929: 			ViewportDel (lpObj->VpPlayer2[n].number, aIndex);

  000d7	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  000db	50		 push	 eax
  000dc	6b 4d f4 0c	 imul	 ecx, DWORD PTR _n$1[ebp], 12
  000e0	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e3	0f b7 84 0a ea
	06 00 00	 movzx	 eax, WORD PTR [edx+ecx+1770]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 ?ViewportDel@@YAXFH@Z	; ViewportDel
  000f1	83 c4 08	 add	 esp, 8
$LN9@gObjViewpo:

; 20930: 		}
; 20931: 	}

  000f4	e9 5c ff ff ff	 jmp	 $LN2@gObjViewpo
$LN1@gObjViewpo:

; 20932: }

  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx
  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c3		 ret	 0
?gObjViewportAllDel@@YAXF@Z ENDP			; gObjViewportAllDel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?Viewport2Del@@YAXFH@Z
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_MVL$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 2
_aDelIndex$ = 12					; size = 4
?Viewport2Del@@YAXFH@Z PROC				; Viewport2Del, COMDAT

; 20877: void Viewport2Del (short aIndex, int aDelIndex) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 20878: 	if (!gObjIsConnected(aIndex)) {

  00009	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00013	83 c4 04	 add	 esp, 4
  00016	85 c0		 test	 eax, eax
  00018	75 05		 jne	 SHORT $LN5@Viewport2D

; 20879: 		return;

  0001a	e9 d3 00 00 00	 jmp	 $LN1@Viewport2D
$LN5@Viewport2D:

; 20880: 	}
; 20881: 	if (!gObjIsConnected(aDelIndex )) {

  0001f	8b 45 0c	 mov	 eax, DWORD PTR _aDelIndex$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00028	83 c4 04	 add	 esp, 4
  0002b	85 c0		 test	 eax, eax
  0002d	75 05		 jne	 SHORT $LN6@Viewport2D

; 20882: 		return;

  0002f	e9 be 00 00 00	 jmp	 $LN1@Viewport2D
$LN6@Viewport2D:

; 20883: 	}
; 20884: 
; 20885: 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00034	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00038	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0003e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00044	89 4d fc	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 20886: 
; 20887: 	int MVL = MAXVIEWPORTOBJECT;

  00047	c7 45 f8 4b 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 75 ; 0000004bH

; 20888: 	if( lpObj->Type == OBJTYPE_MONSTER ) MVL = MAX_MONVIEWPORTOBJECT;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00051	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00055	83 f9 02	 cmp	 ecx, 2
  00058	75 07		 jne	 SHORT $LN7@Viewport2D
  0005a	c7 45 f8 14 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 20 ; 00000014H
$LN7@Viewport2D:

; 20889: 
; 20890: 	for( int n = 0; n < MVL ; n++)

  00061	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00068	eb 09		 jmp	 SHORT $LN4@Viewport2D
$LN2@Viewport2D:
  0006a	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  0006d	83 c0 01	 add	 eax, 1
  00070	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@Viewport2D:
  00073	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  00076	3b 45 f8	 cmp	 eax, DWORD PTR _MVL$[ebp]
  00079	7d 77		 jge	 SHORT $LN1@Viewport2D

; 20891: 	{
; 20892: 		//   
; 20893: 		if( (lpObj->VpPlayer2[n].state == STVP_CREATE ||

  0007b	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00082	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  0008a	83 fa 01	 cmp	 edx, 1
  0008d	74 14		 je	 SHORT $LN9@Viewport2D
  0008f	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00093	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00096	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  0009e	83 fa 02	 cmp	 edx, 2
  000a1	75 4a		 jne	 SHORT $LN8@Viewport2D
$LN9@Viewport2D:

; 20894: 			lpObj->VpPlayer2[n].state == STVP_PLAYING)) 
; 20895: 		{
; 20896: 			if (lpObj->VpPlayer2[n].number == aDelIndex) {

  000a3	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000aa	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  000b2	3b 55 0c	 cmp	 edx, DWORD PTR _aDelIndex$[ebp]
  000b5	75 36		 jne	 SHORT $LN8@Viewport2D

; 20897: 				lpObj->VpPlayer2[n].state   = STVP_NONE;

  000b7	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000be	c6 84 01 e8 06
	00 00 00	 mov	 BYTE PTR [ecx+eax+1768], 0

; 20898: 				lpObj->VpPlayer2[n].number  = -1;

  000c6	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000ca	83 c9 ff	 or	 ecx, -1
  000cd	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000d0	66 89 8c 02 ea
	06 00 00	 mov	 WORD PTR [edx+eax+1770], cx

; 20899: 				lpObj->VPCount2--;

  000d8	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000db	8b 88 70 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2672]
  000e1	83 e9 01	 sub	 ecx, 1
  000e4	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e7	89 8a 70 0a 00
	00		 mov	 DWORD PTR [edx+2672], ecx
$LN8@Viewport2D:

; 20900: 			}
; 20901: 		}
; 20902: 	}

  000ed	e9 78 ff ff ff	 jmp	 $LN2@Viewport2D
$LN1@Viewport2D:

; 20903: }

  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
?Viewport2Del@@YAXFH@Z ENDP				; Viewport2Del
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?ViewportDel@@YAXFH@Z
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_MVL$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 2
_aDelIndex$ = 12					; size = 4
?ViewportDel@@YAXFH@Z PROC				; ViewportDel, COMDAT

; 20848: void ViewportDel (short aIndex, int aDelIndex) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 20849: 	if (!gObjIsConnected(aIndex)) {

  00009	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00013	83 c4 04	 add	 esp, 4
  00016	85 c0		 test	 eax, eax
  00018	75 05		 jne	 SHORT $LN5@ViewportDe

; 20850: 		return;

  0001a	e9 d3 00 00 00	 jmp	 $LN1@ViewportDe
$LN5@ViewportDe:

; 20851: 	}
; 20852: 	if (!gObjIsConnected(aDelIndex )) {

  0001f	8b 45 0c	 mov	 eax, DWORD PTR _aDelIndex$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00028	83 c4 04	 add	 esp, 4
  0002b	85 c0		 test	 eax, eax
  0002d	75 05		 jne	 SHORT $LN6@ViewportDe

; 20853: 		return;

  0002f	e9 be 00 00 00	 jmp	 $LN1@ViewportDe
$LN6@ViewportDe:

; 20854: 	}
; 20855: 
; 20856: 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00034	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00038	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0003e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00044	89 4d fc	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 20857: 
; 20858: 	int MVL = MAXVIEWPORTOBJECT;

  00047	c7 45 f8 4b 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 75 ; 0000004bH

; 20859: 	if( lpObj->Type == OBJTYPE_MONSTER ) MVL = MAX_MONVIEWPORTOBJECT;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00051	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00055	83 f9 02	 cmp	 ecx, 2
  00058	75 07		 jne	 SHORT $LN7@ViewportDe
  0005a	c7 45 f8 14 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 20 ; 00000014H
$LN7@ViewportDe:

; 20860: 
; 20861: 	for( int n = 0; n < MVL ; n++)

  00061	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00068	eb 09		 jmp	 SHORT $LN4@ViewportDe
$LN2@ViewportDe:
  0006a	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  0006d	83 c0 01	 add	 eax, 1
  00070	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@ViewportDe:
  00073	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  00076	3b 45 f8	 cmp	 eax, DWORD PTR _MVL$[ebp]
  00079	7d 77		 jge	 SHORT $LN1@ViewportDe

; 20862: 	{
; 20863: 		//   
; 20864: 		if( (lpObj->VpPlayer[n].state == STVP_CREATE ||

  0007b	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00082	0f be 94 01 64
	03 00 00	 movsx	 edx, BYTE PTR [ecx+eax+868]
  0008a	83 fa 01	 cmp	 edx, 1
  0008d	74 14		 je	 SHORT $LN9@ViewportDe
  0008f	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00093	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00096	0f be 94 01 64
	03 00 00	 movsx	 edx, BYTE PTR [ecx+eax+868]
  0009e	83 fa 02	 cmp	 edx, 2
  000a1	75 4a		 jne	 SHORT $LN8@ViewportDe
$LN9@ViewportDe:

; 20865: 			lpObj->VpPlayer[n].state == STVP_PLAYING)) 
; 20866: 		{
; 20867: 			if (lpObj->VpPlayer[n].number == aDelIndex) {

  000a3	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000aa	0f bf 94 01 66
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax+870]
  000b2	3b 55 0c	 cmp	 edx, DWORD PTR _aDelIndex$[ebp]
  000b5	75 36		 jne	 SHORT $LN8@ViewportDe

; 20868: 				lpObj->VpPlayer[n].state   = STVP_NONE;

  000b7	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000be	c6 84 01 64 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+868], 0

; 20869: 				lpObj->VpPlayer[n].number  = -1;

  000c6	6b 45 f4 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000ca	83 c9 ff	 or	 ecx, -1
  000cd	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000d0	66 89 8c 02 66
	03 00 00	 mov	 WORD PTR [edx+eax+870], cx

; 20870: 				lpObj->VPCount--;

  000d8	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000db	8b 88 6c 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2668]
  000e1	83 e9 01	 sub	 ecx, 1
  000e4	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e7	89 8a 6c 0a 00
	00		 mov	 DWORD PTR [edx+2668], ecx
$LN8@ViewportDe:

; 20871: 			}
; 20872: 		}
; 20873: 	}	

  000ed	e9 78 ff ff ff	 jmp	 $LN2@ViewportDe
$LN1@ViewportDe:

; 20874: }

  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5b		 pop	 ebx
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
?ViewportDel@@YAXFH@Z ENDP				; ViewportDel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjStateProc@@YAXPAVOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
tv66 = -72						; size = 4
tv73 = -68						; size = 4
tv67 = -68						; size = 4
_lpObj$ = 8						; size = 4
_aMsgCode$ = 12						; size = 4
_aIndex$ = 16						; size = 4
_SubCode$ = 20						; size = 4
?gObjStateProc@@YAXPAVOBJECTSTRUCT@@HHH@Z PROC		; gObjStateProc, COMDAT

; 7214 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7215 : 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT)  )

  00009	83 7d 10 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN21@gObjStateP
  0000f	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN22@gObjStateP
$LN21@gObjStateP:
  00018	81 7d 10 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN19@gObjStateP
  00021	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN20@gObjStateP
$LN19@gObjStateP:
  0002a	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN20@gObjStateP:
  00031	8b 45 b8	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 bc	 mov	 DWORD PTR tv67[ebp], eax
$LN22@gObjStateP:
  00037	83 7d bc 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 21		 jne	 SHORT $LN4@gObjStateP

; 7216 : 	{
; 7217 : 		LogAdd("error : %s %d",__FILE__, __LINE__);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjStateProc@@YAXPAVOBJECTSTRUCT@@HHH@Z@4JA
  00042	83 c0 03	 add	 eax, 3
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7218 : 		return;

  00059	e9 a6 01 00 00	 jmp	 $LN1@gObjStateP
$LN4@gObjStateP:

; 7219 : 	}
; 7220 : 	
; 7221 : 	switch( aMsgCode )

  0005e	8b 45 0c	 mov	 eax, DWORD PTR _aMsgCode$[ebp]
  00061	89 45 bc	 mov	 DWORD PTR tv73[ebp], eax
  00064	81 7d bc e8 03
	00 00		 cmp	 DWORD PTR tv73[ebp], 1000 ; 000003e8H
  0006b	7f 26		 jg	 SHORT $LN23@gObjStateP
  0006d	81 7d bc e8 03
	00 00		 cmp	 DWORD PTR tv73[ebp], 1000 ; 000003e8H
  00074	74 60		 je	 SHORT $LN7@gObjStateP
  00076	8b 4d bc	 mov	 ecx, DWORD PTR tv73[ebp]
  00079	83 e9 02	 sub	 ecx, 2
  0007c	89 4d bc	 mov	 DWORD PTR tv73[ebp], ecx
  0007f	83 7d bc 08	 cmp	 DWORD PTR tv73[ebp], 8
  00083	0f 87 7b 01 00
	00		 ja	 $LN1@gObjStateP
  00089	8b 55 bc	 mov	 edx, DWORD PTR tv73[ebp]
  0008c	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN24@gObjStateP[edx*4]
$LN23@gObjStateP:
  00093	e9 6c 01 00 00	 jmp	 $LN1@gObjStateP
$LN5@gObjStateP:

; 7222 : 	{
; 7223 : 	case MSG_BEATTACK :		// .
; 7224 : 		gObjBackSpring(lpObj, &gObj[aIndex]);

  00098	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0009f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a5	50		 push	 eax
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a9	51		 push	 ecx
  000aa	e8 00 00 00 00	 call	 ?gObjBackSpring@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjBackSpring
  000af	83 c4 08	 add	 esp, 8

; 7225 : 		break;

  000b2	e9 4d 01 00 00	 jmp	 $LN1@gObjStateP
$LN6@gObjStateP:

; 7226 : 	case MSG_FILLENERGY :	//  .
; 7227 : 		gObjMonsterDieLifePlus(lpObj, &gObj[aIndex]);

  000b7	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000be	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c4	50		 push	 eax
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ?gObjMonsterDieLifePlus@@YAXPAVOBJECTSTRUCT@@0@Z ; gObjMonsterDieLifePlus
  000ce	83 c4 08	 add	 esp, 8

; 7228 : 		break;

  000d1	e9 2e 01 00 00	 jmp	 $LN1@gObjStateP
$LN7@gObjStateP:

; 7229 : 	case MSG_BILLSEND :		//   
; 7230 : 		gObjBillRequest(lpObj);

  000d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ?gObjBillRequest@@YAXPAVOBJECTSTRUCT@@@Z ; gObjBillRequest
  000df	83 c4 04	 add	 esp, 4

; 7231 : 		break;

  000e2	e9 1d 01 00 00	 jmp	 $LN1@gObjStateP
$LN8@gObjStateP:

; 7232 : #ifdef _NEW_EXDB_
; 7233 : 	case MSG_GUILDWAREND :	//     5   .
; 7234 : 		if( lpObj->lpGuild != NULL && lpObj->lpGuild->lpTargetGuildNode != NULL )

  000e7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ea	83 b8 94 02 00
	00 00		 cmp	 DWORD PTR [eax+660], 0
  000f1	74 34		 je	 SHORT $LN9@gObjStateP
  000f3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f6	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  000fc	83 b9 8c 05 00
	00 00		 cmp	 DWORD PTR [ecx+1420], 0
  00103	74 22		 je	 SHORT $LN9@gObjStateP

; 7235 : 		{
; 7236 : 			gObjGuildWarEnd(lpObj->lpGuild, lpObj->lpGuild->lpTargetGuildNode);

  00105	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00108	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  0010e	8b 91 8c 05 00
	00		 mov	 edx, DWORD PTR [ecx+1420]
  00114	52		 push	 edx
  00115	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00118	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  0011e	51		 push	 ecx
  0011f	e8 00 00 00 00	 call	 ?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarEnd
  00124	83 c4 08	 add	 esp, 8
$LN9@gObjStateP:

; 7237 : 		}
; 7238 : 		break;

  00127	e9 d8 00 00 00	 jmp	 $LN1@gObjStateP
$LN10@gObjStateP:

; 7239 : #endif
; 7240 : 	case MSG_BSSTART :		//   .
; 7241 : 		if( lpObj->lpGuild && lpObj->lpGuild->WarState && lpObj->lpGuild->WarType == 1)

  0012c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012f	83 b8 94 02 00
	00 00		 cmp	 DWORD PTR [eax+660], 0
  00136	74 33		 je	 SHORT $LN11@gObjStateP
  00138	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013b	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00141	0f b6 91 91 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1425]
  00148	85 d2		 test	 edx, edx
  0014a	74 1f		 je	 SHORT $LN11@gObjStateP
  0014c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014f	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00155	0f b6 91 92 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1426]
  0015c	83 fa 01	 cmp	 edx, 1
  0015f	75 0a		 jne	 SHORT $LN11@gObjStateP

; 7242 : 		{
; 7243 : 			BattleSoccerGoalStart(0);

  00161	6a 00		 push	 0
  00163	e8 00 00 00 00	 call	 ?BattleSoccerGoalStart@@YAXH@Z ; BattleSoccerGoalStart
  00168	83 c4 04	 add	 esp, 4
$LN11@gObjStateP:

; 7244 : 		}
; 7245 : 		break;

  0016b	e9 94 00 00 00	 jmp	 $LN1@gObjStateP
$LN12@gObjStateP:

; 7246 : 	case MSG_BSSTOP :
; 7247 : 		if( lpObj->lpGuild && lpObj->lpGuild->WarState && lpObj->lpGuild->WarType == 1)

  00170	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00173	83 b8 94 02 00
	00 00		 cmp	 DWORD PTR [eax+660], 0
  0017a	74 52		 je	 SHORT $LN13@gObjStateP
  0017c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017f	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00185	0f b6 91 91 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1425]
  0018c	85 d2		 test	 edx, edx
  0018e	74 3e		 je	 SHORT $LN13@gObjStateP
  00190	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00193	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00199	0f b6 91 92 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1426]
  001a0	83 fa 01	 cmp	 edx, 1
  001a3	75 29		 jne	 SHORT $LN13@gObjStateP

; 7248 : 		{
; 7249 : 			if( lpObj->lpGuild->BattleGroundIndex >= 0 )

  001a5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a8	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  001ae	0f b6 91 93 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1427]
  001b5	85 d2		 test	 edx, edx
  001b7	7c 15		 jl	 SHORT $LN13@gObjStateP

; 7250 : 				//BattleSoccerGoalEnd(lpObj->lpGuild->BattleGroundIndex);
; 7251 : 				GCManagerGuildWarEnd(lpObj->lpGuild->Name);

  001b9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001bc	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  001c2	83 c1 04	 add	 ecx, 4
  001c5	51		 push	 ecx
  001c6	e8 00 00 00 00	 call	 ?GCManagerGuildWarEnd@@YAXPAD@Z ; GCManagerGuildWarEnd
  001cb	83 c4 04	 add	 esp, 4
$LN13@gObjStateP:

; 7252 : 		}
; 7253 : 		break;

  001ce	eb 34		 jmp	 SHORT $LN1@gObjStateP
$LN15@gObjStateP:

; 7254 : 	case MSG_REFLECT :		//  ?
; 7255 : 		if( lpObj->DamageReflect )

  001d0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d3	0f b6 88 15 01
	00 00		 movzx	 ecx, BYTE PTR [eax+277]
  001da	85 c9		 test	 ecx, ecx
  001dc	74 26		 je	 SHORT $LN1@gObjStateP

; 7256 : 		{
; 7257 : 			gObjAttack(lpObj, &gObj[aIndex], NULL, 0, 0, SubCode);			

  001de	6a 00		 push	 0
  001e0	8b 45 14	 mov	 eax, DWORD PTR _SubCode$[ebp]
  001e3	50		 push	 eax
  001e4	6a 00		 push	 0
  001e6	6a 00		 push	 0
  001e8	6a 00		 push	 0
  001ea	69 4d 10 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001f1	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f7	51		 push	 ecx
  001f8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001fb	52		 push	 edx
  001fc	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  00201	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN1@gObjStateP:

; 7258 : 		}
; 7259 : 		break;
; 7260 : #ifdef NEW_FORSKYLAND2
; 7261 : 	case MSG_LIFECHECK :	// 
; 7262 : 		{
; 7263 : 		}
; 7264 : 		break;
; 7265 : #endif
; 7266 : #ifdef ADD_SKILL_DARKLOAD_FIRESCREAM_20060601	//     
; 7267 : 	case MSG_ATTACKPROC_FIRESCREAM:				//    
; 7268 : 		{
; 7269 : 			if( lpObj->Live )
; 7270 : 			{
; 7271 : 				CMagicInf*	lpMagic = &DefMagicInf[AT_SKILL_EXPLOSION];				
; 7272 : 								
; 7273 : 				//       .
; 7274 : 				gObjAttack( lpObj, &gObj[aIndex], lpMagic, 1, 0, SubCode );				
; 7275 : 			}
; 7276 : 		}
; 7277 : 		break;
; 7278 : #endif
; 7279 : #ifdef ADD_THIRD_WING_20070525	// 3   
; 7280 : 	case MSG_ATTACK_TURNING:	//   
; 7281 : 		gObjAttack( lpObj, &gObj[aIndex], NULL, 0, 0, SubCode );	
; 7282 : 		break;
; 7283 : 	case MSG_FULL_LIFE:			// 100%  
; 7284 : #ifdef MODIFY_THIRD_WING_OPTION_5_PERCENT_REFILL_ALL_BUGFIX_20080624
; 7285 : 		lpObj->Life = lpObj->MaxLife + lpObj->AddLife;
; 7286 : 		GCReFillSend( lpObj->m_Index, ( WORD )lpObj->Life, 0xFF, 0, ( WORD )lpObj->iShield );
; 7287 : #else
; 7288 : 		lpObj->Life = lpObj->MaxLife;
; 7289 : 		GCReFillSend( lpObj->m_Index, ( WORD )lpObj->Life, 0xFF, 0, ( WORD )lpObj->iShield );
; 7290 : #endif // MODIFY_THIRD_WING_OPTION_5_PERCENT_REFILL_ALL_BUGFIX_20080624
; 7291 : 		break;
; 7292 : 	case MSG_FULL_MANA:			// 100%  
; 7293 : #ifdef MODIFY_THIRD_WING_OPTION_5_PERCENT_REFILL_ALL_BUGFIX_20080624
; 7294 : 		lpObj->Mana = lpObj->MaxMana + lpObj->AddMana;
; 7295 : 		GCManaSend( lpObj->m_Index, ( short )lpObj->Mana, 0xFF, 0, lpObj->BP );
; 7296 : #else
; 7297 : 		lpObj->Mana = lpObj->MaxMana;
; 7298 : 		GCManaSend( lpObj->m_Index, ( short )lpObj->Mana, 0xFF, 0, lpObj->BP );
; 7299 : #endif // MODIFY_THIRD_WING_OPTION_5_PERCENT_REFILL_ALL_BUGFIX_20080624
; 7300 : 		break;
; 7301 : #endif	// ADD_THIRD_WING_20070525	
; 7302 : 
; 7303 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	// LighingOrb  Splash Damage 
; 7304 : 	case MSG_ATTACK_LIGHTNINGORB:
; 7305 : 		{
; 7306 : 			if( lpObj->Live )
; 7307 : 			{
; 7308 : 				CMagicInf*	lpMagic = &DefMagicInf[AT_SKILL_LIGHTNINGORB];				
; 7309 : 								
; 7310 : 				//       .
; 7311 : 				gObjAttack( lpObj, &gObj[aIndex], lpMagic, 1, 0, SubCode );				
; 7312 : 			}
; 7313 : 		}
; 7314 : 		break;
; 7315 : #endif
; 7316 : 
; 7317 : #ifdef UPDATE_ADD_SUMMONER_SKILL_POLLUTION_20080425
; 7318 : 	case MSG_SKILL_PULLUTION1:
; 7319 : 		{	
; 7320 : 			if( lpObj->Live )
; 7321 : 			{
; 7322 : 				BYTE PosX	= LOBYTE(LOWORD(SubCode));
; 7323 : 				BYTE PosY	= HIBYTE(LOWORD(SubCode));
; 7324 : 				BYTE Msg	= HIWORD(SubCode);
; 7325 : 
; 7326 : 				CMagicInf*	lpMagic = &DefMagicInf[AT_SKILL_PULLUTION];
; 7327 : 				gObjUseSkill.UseSkillPollution(lpObj->m_Index, lpMagic, PosX, PosY, aIndex, Msg+1);
; 7328 : 			}
; 7329 : 		}
; 7330 : 		break;
; 7331 : #endif	// UPDATE_ADD_SUMMONER_SKILL_POLLUTION_20080425
; 7332 : 	}
; 7333 : }

  00204	5f		 pop	 edi
  00205	5e		 pop	 esi
  00206	5b		 pop	 ebx
  00207	8b e5		 mov	 esp, ebp
  00209	5d		 pop	 ebp
  0020a	c3		 ret	 0
  0020b	90		 npad	 1
$LN24@gObjStateP:
  0020c	00 00 00 00	 DD	 $LN5@gObjStateP
  00210	00 00 00 00	 DD	 $LN6@gObjStateP
  00214	00 00 00 00	 DD	 $LN8@gObjStateP
  00218	00 00 00 00	 DD	 $LN10@gObjStateP
  0021c	00 00 00 00	 DD	 $LN1@gObjStateP
  00220	00 00 00 00	 DD	 $LN12@gObjStateP
  00224	00 00 00 00	 DD	 $LN1@gObjStateP
  00228	00 00 00 00	 DD	 $LN1@gObjStateP
  0022c	00 00 00 00	 DD	 $LN15@gObjStateP
?gObjStateProc@@YAXPAVOBJECTSTRUCT@@HHH@Z ENDP		; gObjStateProc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSkillUseProc@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv334 = -658						; size = 2
tv272 = -658						; size = 2
_msg$1 = -528						; size = 255
_msg$2 = -272						; size = 255
_bCheckInterfaceToMove$3 = -16				; size = 4
_bCheckEquipmentToMove$4 = -12				; size = 4
_bCheckMainToMove$5 = -8				; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjSkillUseProc@@YAXPAVOBJECTSTRUCT@@@Z PROC		; gObjSkillUseProc, COMDAT

; 25236: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 02 00
	00		 sub	 esp, 660		; 00000294H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 25237: 	//   
; 25238: 	if( lpObj->m_SkillAttackTime2 > 0 )

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00019	0f be 88 84 02
	00 00		 movsx	 ecx, BYTE PTR [eax+644]
  00020	85 c9		 test	 ecx, ecx
  00022	7e 3a		 jle	 SHORT $LN3@gObjSkillU

; 25239: 	{
; 25240: 		lpObj->m_SkillAttackTime2--;

  00024	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00027	8a 88 84 02 00
	00		 mov	 cl, BYTE PTR [eax+644]
  0002d	80 e9 01	 sub	 cl, 1
  00030	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00033	88 8a 84 02 00
	00		 mov	 BYTE PTR [edx+644], cl

; 25241: 		if( lpObj->m_SkillAttackTime2 <= 0 )

  00039	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003c	0f be 88 84 02
	00 00		 movsx	 ecx, BYTE PTR [eax+644]
  00043	85 c9		 test	 ecx, ecx
  00045	7f 17		 jg	 SHORT $LN3@gObjSkillU

; 25242: 		{
; 25243: 			lpObj->m_SkillAttack2 = 0;

  00047	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004a	c7 80 80 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+640], 0

; 25244: 			lpObj->m_SkillAttackTime2 = 0;

  00054	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00057	c6 80 84 02 00
	00 00		 mov	 BYTE PTR [eax+644], 0
$LN3@gObjSkillU:

; 25245: 		}
; 25246: 	}
; 25247: 
; 25248: #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004					// !! NOT
; 25249: 	if( lpObj->m_SkillAttackTime <= GetTickCount() )

  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00067	39 81 28 1a 00
	00		 cmp	 DWORD PTR [ecx+6696], eax
  0006d	77 42		 ja	 SHORT $LN4@gObjSkillU

; 25250: 	{
; 25251: // 		lpObj->m_SkillAttackTime--;
; 25252: // 		if( lpObj->m_SkillAttackTime == 0 )
; 25253: 		{
; 25254: 			lpObj->m_SkillAttack = 0;

  0006f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00072	c7 80 24 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6692], 0

; 25255: 			lpObj->m_SkillAttackTime = 0;

  0007c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007f	c7 80 28 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6696], 0

; 25256: 
; 25257: #ifdef EXPAND_VIEWSKILLSTATE_WORD_TO_INT_20041122
; 25258: 			DEL_VIEWSKILLSTATE( lpObj->m_ViewSkillState, STATE_ATTACK );
; 25259: #else
; 25260: 			lpObj->m_ViewSkillState &= 0xF7;

  00089	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008c	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  00093	81 e1 f7 00 00
	00		 and	 ecx, 247		; 000000f7H
  00099	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0009c	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 25261: #endif
; 25262: 
; 25263: 			GCMagicCancelSend(lpObj, AT_SKILL_ATTACK);

  000a3	6a 1c		 push	 28			; 0000001cH
  000a5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  000ae	83 c4 08	 add	 esp, 8
$LN4@gObjSkillU:

; 25264: 		}
; 25265: 	}
; 25266: 
; 25267: 	if( lpObj->m_SkillDefenseTime <= GetTickCount() )

  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ba	39 81 20 1a 00
	00		 cmp	 DWORD PTR [ecx+6688], eax
  000c0	77 42		 ja	 SHORT $LN5@gObjSkillU

; 25268: 	{
; 25269: // 		lpObj->m_SkillDefenseTime--;
; 25270: // 		if( lpObj->m_SkillDefenseTime == 0 )
; 25271: 		{			
; 25272: 			lpObj->m_SkillDefense = 0;

  000c2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c5	c7 80 1c 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6684], 0

; 25273: 			lpObj->m_SkillDefenseTime = 0;

  000cf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d2	c7 80 20 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6688], 0

; 25274: 
; 25275: #ifdef EXPAND_VIEWSKILLSTATE_WORD_TO_INT_20041122
; 25276: 			DEL_VIEWSKILLSTATE( lpObj->m_ViewSkillState, STATE_DEFENSE );
; 25277: #else
; 25278: 			lpObj->m_ViewSkillState &= 0xFB;

  000dc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000df	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  000e6	81 e1 fb 00 00
	00		 and	 ecx, 251		; 000000fbH
  000ec	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ef	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 25279: #endif
; 25280: 
; 25281: 			GCMagicCancelSend(lpObj, AT_SKILL_DEFENSE);

  000f6	6a 1b		 push	 27			; 0000001bH
  000f8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  00101	83 c4 08	 add	 esp, 8
$LN5@gObjSkillU:

; 25282: 		}
; 25283: 	}	
; 25284: 
; 25285: #ifdef NEW_FORSKYLAND2	
; 25286: 	if( lpObj->m_WizardSkillDefenseTime > 0 )

  00104	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00107	83 b8 10 1a 00
	00 00		 cmp	 DWORD PTR [eax+6672], 0
  0010e	7e 56		 jle	 SHORT $LN7@gObjSkillU

; 25287: 	{
; 25288: 		lpObj->m_WizardSkillDefenseTime--;

  00110	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00113	8b 88 10 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6672]
  00119	83 e9 01	 sub	 ecx, 1
  0011c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0011f	89 8a 10 1a 00
	00		 mov	 DWORD PTR [edx+6672], ecx

; 25289: 		if( lpObj->m_WizardSkillDefenseTime == 0 )

  00125	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00128	83 b8 10 1a 00
	00 00		 cmp	 DWORD PTR [eax+6672], 0
  0012f	75 35		 jne	 SHORT $LN7@gObjSkillU

; 25290: 		{
; 25291: 			lpObj->m_WizardSkillDefense = 0;

  00131	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00134	c7 80 0c 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6668], 0

; 25292: 
; 25293: #ifdef CHANGE_VIEWSTATE
; 25294: 			lpObj->m_ViewSkillState &= ~STATE_REDUCE_MAGICDEFENSE; //	9  :   

  0013e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00141	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  00148	81 e1 ff fe ff
	ff		 and	 ecx, -257		; fffffeffH
  0014e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00151	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 25295: #else
; 25296: 			lpObj->m_ViewSkillState |= 0;						  
; 25297: #endif;
; 25298: 			GCMagicCancelSend(lpObj, AT_SKILL_MAGICDEFENSE);

  00158	6a 10		 push	 16			; 00000010H
  0015a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0015d	50		 push	 eax
  0015e	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  00163	83 c4 08	 add	 esp, 8
$LN7@gObjSkillU:

; 25299: 		}
; 25300: 	}
; 25301: #endif
; 25302: 
; 25303: #ifdef NEW_SKILL_FORSKYLAND
; 25304: 	if( lpObj->m_SkillAddLifeTime > 0 )

  00166	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00169	83 b8 f8 19 00
	00 00		 cmp	 DWORD PTR [eax+6648], 0
  00170	0f 8e 29 01 00
	00		 jle	 $LN9@gObjSkillU

; 25305: 	{
; 25306: 		lpObj->m_SkillAddLifeTime--;

  00176	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00179	8b 88 f8 19 00
	00		 mov	 ecx, DWORD PTR [eax+6648]
  0017f	83 e9 01	 sub	 ecx, 1
  00182	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00185	89 8a f8 19 00
	00		 mov	 DWORD PTR [edx+6648], ecx

; 25307: 		if( lpObj->m_SkillAddLifeTime == 0 )

  0018b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0018e	83 b8 f8 19 00
	00 00		 cmp	 DWORD PTR [eax+6648], 0
  00195	0f 85 04 01 00
	00		 jne	 $LN9@gObjSkillU

; 25308: 		{	
; 25309: 			lpObj->AddLife -= lpObj->m_SkillAddLife;	//     

  0019b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001a1	8b 90 0c 01 00
	00		 mov	 edx, DWORD PTR [eax+268]
  001a7	2b 91 f4 19 00
	00		 sub	 edx, DWORD PTR [ecx+6644]
  001ad	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b0	89 90 0c 01 00
	00		 mov	 DWORD PTR [eax+268], edx

; 25310: 			if( lpObj->AddLife < 0 )

  001b6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b9	83 b8 0c 01 00
	00 00		 cmp	 DWORD PTR [eax+268], 0
  001c0	7d 0d		 jge	 SHORT $LN10@gObjSkillU

; 25311: 				lpObj->AddLife = 0;

  001c2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c5	c7 80 0c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+268], 0
$LN10@gObjSkillU:

; 25312: 
; 25313: #ifdef ADD_SHIELD_POINT_01_20060403
; 25314: 			GCReFillSend(lpObj->m_Index, (WORD)(lpObj->MaxLife+lpObj->AddLife), 0xFE, 0, (WORD)(lpObj->iMaxShield+lpObj->iAddShield));
; 25315: #else
; 25316: 			GCReFillSend(lpObj->m_Index, (WORD)(lpObj->MaxLife+lpObj->AddLife), 0xFE, 0);

  001cf	6a 00		 push	 0
  001d1	68 fe 00 00 00	 push	 254			; 000000feH
  001d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d9	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  001e1	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001e4	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  001ec	f3 0f 2c d0	 cvttss2si edx, xmm0
  001f0	0f b7 c2	 movzx	 eax, dx
  001f3	50		 push	 eax
  001f4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001f7	8b 11		 mov	 edx, DWORD PTR [ecx]
  001f9	52		 push	 edx
  001fa	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  001ff	83 c4 10	 add	 esp, 16			; 00000010H

; 25317: #endif
; 25318: 
; 25319: 			if( lpObj->Life > lpObj->MaxLife+lpObj->AddLife  )

  00202	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00205	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  0020d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00210	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  00218	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0021b	f3 0f 10 8a bc
	00 00 00	 movss	 xmm1, DWORD PTR [edx+188]
  00223	0f 2f c8	 comiss	 xmm1, xmm0
  00226	76 45		 jbe	 SHORT $LN11@gObjSkillU

; 25320: 			{
; 25321: 				lpObj->Life = lpObj->MaxLife+lpObj->AddLife;

  00228	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0022b	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  00233	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00236	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  0023e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00241	f3 0f 11 82 bc
	00 00 00	 movss	 DWORD PTR [edx+188], xmm0

; 25322: #ifdef ADD_SHIELD_POINT_01_20060403
; 25323: 				GCReFillSend(lpObj->m_Index, (WORD)(lpObj->Life), 0xFF, 0, (WORD)lpObj->iShield);
; 25324: #else
; 25325: 				GCReFillSend(lpObj->m_Index, (WORD)(lpObj->Life), 0xFF, 0);

  00249	6a 00		 push	 0
  0024b	68 ff 00 00 00	 push	 255			; 000000ffH
  00250	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00253	f3 0f 2c 88 bc
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+188]
  0025b	0f b7 d1	 movzx	 edx, cx
  0025e	52		 push	 edx
  0025f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00262	8b 08		 mov	 ecx, DWORD PTR [eax]
  00264	51		 push	 ecx
  00265	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  0026a	83 c4 10	 add	 esp, 16			; 00000010H
$LN11@gObjSkillU:

; 25326: #endif
; 25327: 			}
; 25328: 
; 25329: 			lpObj->m_SkillAddLife = 0;

  0026d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00270	c7 80 f4 19 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6644], 0

; 25330: 			lpObj->m_ViewSkillState &= ~STATE_ADD_LIFE;

  0027a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0027d	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  00284	83 e1 ef	 and	 ecx, -17		; ffffffefH
  00287	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0028a	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 25331: 			GCMagicCancelSend(lpObj, AT_SKILL_KNIGHTADDLIFE);			

  00291	6a 30		 push	 48			; 00000030H
  00293	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00296	50		 push	 eax
  00297	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  0029c	83 c4 08	 add	 esp, 8
$LN9@gObjSkillU:

; 25332: 		}
; 25333: 	}	
; 25334: 
; 25335: 	if( lpObj->m_SkillHardenTime > 0 )

  0029f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a2	83 b8 00 1a 00
	00 00		 cmp	 DWORD PTR [eax+6656], 0
  002a9	7e 53		 jle	 SHORT $LN13@gObjSkillU

; 25336: 	{
; 25337: 		lpObj->m_SkillHardenTime--;

  002ab	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ae	8b 88 00 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6656]
  002b4	83 e9 01	 sub	 ecx, 1
  002b7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002ba	89 8a 00 1a 00
	00		 mov	 DWORD PTR [edx+6656], ecx

; 25338: 		if( lpObj->m_SkillHardenTime <= 0 )

  002c0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c3	83 b8 00 1a 00
	00 00		 cmp	 DWORD PTR [eax+6656], 0
  002ca	7f 32		 jg	 SHORT $LN13@gObjSkillU

; 25339: 		{			
; 25340: 			lpObj->m_SkillHarden = 0;

  002cc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002cf	c7 80 fc 19 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6652], 0

; 25341: 			lpObj->m_ViewSkillState &= ~STATE_HARDEN;

  002d9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002dc	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  002e3	83 e1 df	 and	 ecx, -33		; ffffffdfH
  002e6	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002e9	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 25342: 			GCMagicCancelSend(lpObj, AT_SKILL_ELFHARDEN);			

  002f0	6a 33		 push	 51			; 00000033H
  002f2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002f5	50		 push	 eax
  002f6	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  002fb	83 c4 08	 add	 esp, 8
$LN13@gObjSkillU:

; 25343: 		}
; 25344: 	}
; 25345: 
; 25346: 	if( lpObj->m_SkillMagumReduceDefenseTime > 0 )

  002fe	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00301	83 b8 08 1a 00
	00 00		 cmp	 DWORD PTR [eax+6664], 0
  00308	7e 53		 jle	 SHORT $LN15@gObjSkillU

; 25347: 	{
; 25348: 		lpObj->m_SkillMagumReduceDefenseTime--;

  0030a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030d	8b 88 08 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6664]
  00313	83 e9 01	 sub	 ecx, 1
  00316	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00319	89 8a 08 1a 00
	00		 mov	 DWORD PTR [edx+6664], ecx

; 25349: 		if( lpObj->m_SkillMagumReduceDefenseTime == 0 )

  0031f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00322	83 b8 08 1a 00
	00 00		 cmp	 DWORD PTR [eax+6664], 0
  00329	75 32		 jne	 SHORT $LN15@gObjSkillU

; 25350: 		{			
; 25351: 			lpObj->m_SkillMagumReduceDefense = 0;

  0032b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0032e	c7 80 04 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6660], 0

; 25352: 			lpObj->m_ViewSkillState &= ~STATE_REDUCE_DEFENSE;

  00338	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0033b	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  00342	83 e1 bf	 and	 ecx, -65		; ffffffbfH
  00345	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00348	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 25353: 			GCMagicCancelSend(lpObj, AT_SKILL_DEFENSEDOWN);

  0034f	6a 37		 push	 55			; 00000037H
  00351	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00354	50		 push	 eax
  00355	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  0035a	83 c4 08	 add	 esp, 8
$LN15@gObjSkillU:

; 25354: 		}
; 25355: 	}
; 25356: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 25357: 
; 25358: #ifdef NEW_SKILL_FORSKYLAND
; 25359: 	if( lpObj->Class == 77 )

  0035d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00360	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00367	83 f9 4d	 cmp	 ecx, 77			; 0000004dH
  0036a	0f 85 b2 00 00
	00		 jne	 $LN19@gObjSkillU

; 25360: 	{	//   
; 25361: 		lpObj->m_SkyBossMonSheildTime++;

  00370	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00373	8b 88 cc 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3788]
  00379	83 c1 01	 add	 ecx, 1
  0037c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0037f	89 8a cc 0e 00
	00		 mov	 DWORD PTR [edx+3788], ecx

; 25362: 		if( lpObj->m_SkyBossMonSheildTime > 5 )

  00385	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00388	83 b8 cc 0e 00
	00 05		 cmp	 DWORD PTR [eax+3788], 5
  0038f	0f 8e 8d 00 00
	00		 jle	 $LN19@gObjSkillU

; 25363: 		{
; 25364: 			lpObj->m_SkyBossMonSheildTime = 0;

  00395	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00398	c7 80 cc 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3788], 0

; 25365: 			if( lpObj->m_SkyBossMonSheild )

  003a2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003a5	83 b8 c8 0e 00
	00 00		 cmp	 DWORD PTR [eax+3784], 0
  003ac	74 37		 je	 SHORT $LN18@gObjSkillU

; 25366: 			{
; 25367: 				lpObj->m_SkyBossMonSheild = FALSE;				

  003ae	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003b1	c7 80 c8 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3784], 0

; 25368: 				lpObj->m_ViewSkillState &= ~STATE_REDUCE_ATTACKDAMAGE;

  003bb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003be	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  003c5	81 e1 7f ff ff
	ff		 and	 ecx, -129		; ffffff7fH
  003cb	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003ce	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 25369: 				GCMagicCancelSend(lpObj, AT_SKILL_MAGICDEFENSE);

  003d5	6a 10		 push	 16			; 00000010H
  003d7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003da	50		 push	 eax
  003db	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  003e0	83 c4 08	 add	 esp, 8

; 25370: 				//STATE_REDUCE_MAGICDEFENSE
; 25371: 			}

  003e3	eb 3d		 jmp	 SHORT $LN19@gObjSkillU
$LN18@gObjSkillU:

; 25372: 			else
; 25373: 			{
; 25374: 				lpObj->m_SkyBossMonSheild = TRUE;				

  003e5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003e8	c7 80 c8 0e 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+3784], 1

; 25375: 				lpObj->m_ViewSkillState |= STATE_REDUCE_ATTACKDAMAGE; 

  003f2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003f5	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  003fc	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  00402	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00405	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 25376: 				GCMagicAttackNumberSend(lpObj, AT_SKILL_MAGICDEFENSE, lpObj->m_Index, 1);

  0040c	6a 01		 push	 1
  0040e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00411	8b 08		 mov	 ecx, DWORD PTR [eax]
  00413	51		 push	 ecx
  00414	6a 10		 push	 16			; 00000010H
  00416	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00419	52		 push	 edx
  0041a	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAVOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  0041f	83 c4 10	 add	 esp, 16			; 00000010H
$LN19@gObjSkillU:

; 25377: 			}
; 25378: 		}
; 25379: 	}
; 25380: #endif
; 25381: #endif
; 25382: 
; 25383: 
; 25384: #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 25385: 	#ifdef ADD_NPC_SHADOW_PHANTOM_20050616
; 25386: 	if(lpObj->m_iSkillNPCHelpTime > 0)
; 25387: 	{
; 25388: 		// 30    
; 25389: 	#ifdef UPDATE_SHADOW_PHANTOM_20070302		//   
; 25390: 		//     -- () = 30 + (/6)
; 25391: 		if( GetTickCount() > lpObj->m_iSkillNPCHelpTime + ( 1000 * 60 * (30 + (int)(lpObj->Level / 6) ) ) )
; 25392: 	#else
; 25393: 		// 30    
; 25394: 		if(GetTickCount() > lpObj->m_iSkillNPCHelpTime + (1000 * 60 * 30))
; 25395: 	#endif
; 25396: 		{
; 25397: 			lpObj->m_iSkillNPCHelpTime = 0;
; 25398: 			lpObj->m_iSkillNPCDefense = 0; 
; 25399: 			lpObj->m_iSkillNPCAttack = 0;
; 25400: 
; 25401: 			DEL_VIEWSKILLSTATE(lpObj->m_ViewSkillState, STATE_NPC_HELP);
; 25402: 			GCStateInfoSend(lpObj, 0, STATE_NPC_HELP);			
; 25403: 		}
; 25404: 	}
; 25405: 	#endif
; 25406: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 25407: 
; 25408: #ifdef DARKLORD_WORK	
; 25409: 	if( lpObj->SkillRecallParty_Time && lpObj->Type == OBJTYPE_CHARACTER )

  00422	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00425	0f b7 88 7c 10
	00 00		 movzx	 ecx, WORD PTR [eax+4220]
  0042c	85 c9		 test	 ecx, ecx
  0042e	0f 84 5e 01 00
	00		 je	 $LN26@gObjSkillU
  00434	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00437	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0043b	83 f9 01	 cmp	 ecx, 1
  0043e	0f 85 4e 01 00
	00		 jne	 $LN26@gObjSkillU

; 25410: 	{
; 25411: 		if( --lpObj->SkillRecallParty_Time <= 0 )

  00444	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00447	66 8b 88 7c 10
	00 00		 mov	 cx, WORD PTR [eax+4220]
  0044e	66 83 e9 01	 sub	 cx, 1
  00452	66 89 8d 6e fd
	ff ff		 mov	 WORD PTR tv272[ebp], cx
  00459	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0045c	66 8b 85 6e fd
	ff ff		 mov	 ax, WORD PTR tv272[ebp]
  00463	66 89 82 7c 10
	00 00		 mov	 WORD PTR [edx+4220], ax
  0046a	0f b7 8d 6e fd
	ff ff		 movzx	 ecx, WORD PTR tv272[ebp]
  00471	85 c9		 test	 ecx, ecx
  00473	0f 8f c7 00 00
	00		 jg	 $LN21@gObjSkillU

; 25412: 		{
; 25413: 			lpObj->SkillRecallParty_Time = 0;

  00479	33 c0		 xor	 eax, eax
  0047b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0047e	66 89 81 7c 10
	00 00		 mov	 WORD PTR [ecx+4220], ax

; 25414: 
; 25415: #ifdef MODIFY_DARKLORD_RECALL_BUGFIX_20051103
; 25416: 			// 0.     -  ,  , ,  
; 25417: 			BOOL bCheckMainToMove = gMoveCommand.CheckMainToMove( lpObj );

  00485	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00488	50		 push	 eax
  00489	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  0048e	e8 00 00 00 00	 call	 ?CheckMainToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@@Z ; CMoveCommand::CheckMainToMove
  00493	89 45 f8	 mov	 DWORD PTR _bCheckMainToMove$5[ebp], eax

; 25418: 			
; 25419: 			// 2.     
; 25420: 			BOOL bCheckEquipmentToMove = gMoveCommand.CheckEquipmentToMove( lpObj, lpObj->SkillRecallParty_MapNumber );

  00496	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00499	0f b6 88 7e 10
	00 00		 movzx	 ecx, BYTE PTR [eax+4222]
  004a0	51		 push	 ecx
  004a1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004a4	52		 push	 edx
  004a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  004aa	e8 00 00 00 00	 call	 ?CheckEquipmentToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@H@Z ; CMoveCommand::CheckEquipmentToMove
  004af	89 45 f4	 mov	 DWORD PTR _bCheckEquipmentToMove$4[ebp], eax

; 25421: 
; 25422: 			// 3.    
; 25423: 			BOOL bCheckInterfaceToMove = gMoveCommand.CheckInterfaceToMove( lpObj );

  004b2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004b5	50		 push	 eax
  004b6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  004bb	e8 00 00 00 00	 call	 ?CheckInterfaceToMove@CMoveCommand@@QAEHPAVOBJECTSTRUCT@@@Z ; CMoveCommand::CheckInterfaceToMove
  004c0	89 45 f0	 mov	 DWORD PTR _bCheckInterfaceToMove$3[ebp], eax

; 25424: 	
; 25425: 			if( !bCheckMainToMove 
; 25426: 				|| !bCheckEquipmentToMove 
; 25427: 				|| !bCheckInterfaceToMove	

  004c3	83 7d f8 00	 cmp	 DWORD PTR _bCheckMainToMove$5[ebp], 0
  004c7	74 0c		 je	 SHORT $LN25@gObjSkillU
  004c9	83 7d f4 00	 cmp	 DWORD PTR _bCheckEquipmentToMove$4[ebp], 0
  004cd	74 06		 je	 SHORT $LN25@gObjSkillU
  004cf	83 7d f0 00	 cmp	 DWORD PTR _bCheckInterfaceToMove$3[ebp], 0
  004d3	75 3a		 jne	 SHORT $LN23@gObjSkillU
$LN25@gObjSkillU:

; 25428: 			  )
; 25429: 			{
; 25430: 				char msg[255];
; 25431: 				wsprintf(msg, lMsg.Get(1254));	// ""

  004d5	68 e6 04 00 00	 push	 1254			; 000004e6H
  004da	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  004df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  004e5	50		 push	 eax
  004e6	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _msg$2[ebp]
  004ec	50		 push	 eax
  004ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  004f3	83 c4 08	 add	 esp, 8

; 25432: 
; 25433: 				GCServerMsgStringSend(msg, lpObj->m_Index, 1);

  004f6	6a 01		 push	 1
  004f8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004fb	8b 08		 mov	 ecx, DWORD PTR [eax]
  004fd	51		 push	 ecx
  004fe	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _msg$2[ebp]
  00504	52		 push	 edx
  00505	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0050a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25434: 			}

  0050d	eb 2f		 jmp	 SHORT $LN24@gObjSkillU
$LN23@gObjSkillU:

; 25435: 			else
; 25436: #endif
; 25437: 			gObjRecall(lpObj->m_Index, lpObj->SkillRecallParty_MapNumber, 

  0050f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00512	0f b6 88 80 10
	00 00		 movzx	 ecx, BYTE PTR [eax+4224]
  00519	51		 push	 ecx
  0051a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0051d	0f b6 82 7f 10
	00 00		 movzx	 eax, BYTE PTR [edx+4223]
  00524	50		 push	 eax
  00525	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00528	0f b6 91 7e 10
	00 00		 movzx	 edx, BYTE PTR [ecx+4222]
  0052f	52		 push	 edx
  00530	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00533	8b 08		 mov	 ecx, DWORD PTR [eax]
  00535	51		 push	 ecx
  00536	e8 00 00 00 00	 call	 ?gObjRecall@@YAXHHHH@Z	; gObjRecall
  0053b	83 c4 10	 add	 esp, 16			; 00000010H
$LN24@gObjSkillU:

; 25438: 					   lpObj->SkillRecallParty_X, lpObj->SkillRecallParty_Y);
; 25439: 
; 25440: #ifdef MODIFY_RECALLSKIL_BUGFIX_20081107
; 25441: 			//       . by natinda
; 25442: 			lpObj->SkillRecallParty_MapNumber	= 0;
; 25443: 			lpObj->SkillRecallParty_Time		= 0;
; 25444: 			lpObj->SkillRecallParty_X			= 0;
; 25445: 			lpObj->SkillRecallParty_Y			= 0;
; 25446: #endif
; 25447: 
; 25448: 
; 25449: 		}

  0053e	eb 52		 jmp	 SHORT $LN26@gObjSkillU
$LN21@gObjSkillU:

; 25450: 		else
; 25451: 		{
; 25452: 			if( lpObj->SkillRecallParty_Time <= 5 )

  00540	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00543	0f b7 88 7c 10
	00 00		 movzx	 ecx, WORD PTR [eax+4220]
  0054a	83 f9 05	 cmp	 ecx, 5
  0054d	7f 43		 jg	 SHORT $LN26@gObjSkillU

; 25453: 			{
; 25454: 				char msg[255];
; 25455: 				wsprintf(msg, lMsg.Get(1243), lpObj->SkillRecallParty_Time);	// "%d   "

  0054f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00552	0f b7 88 7c 10
	00 00		 movzx	 ecx, WORD PTR [eax+4220]
  00559	51		 push	 ecx
  0055a	68 db 04 00 00	 push	 1243			; 000004dbH
  0055f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00564	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0056a	50		 push	 eax
  0056b	8d 95 f0 fd ff
	ff		 lea	 edx, DWORD PTR _msg$1[ebp]
  00571	52		 push	 edx
  00572	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00578	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25456: 				GCServerMsgStringSend(msg, lpObj->m_Index, 1);	

  0057b	6a 01		 push	 1
  0057d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00580	8b 08		 mov	 ecx, DWORD PTR [eax]
  00582	51		 push	 ecx
  00583	8d 95 f0 fd ff
	ff		 lea	 edx, DWORD PTR _msg$1[ebp]
  00589	52		 push	 edx
  0058a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0058f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@gObjSkillU:

; 25457: 			}
; 25458: 		}
; 25459: 	}
; 25460: 
; 25461: #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004				// !! NOT
; 25462: 	if( lpObj->SkillAddCriticalDamageTime && lpObj->Type == OBJTYPE_CHARACTER )

  00592	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00595	0f b7 88 14 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6676]
  0059c	85 c9		 test	 ecx, ecx
  0059e	0f 84 a0 00 00
	00		 je	 $LN28@gObjSkillU
  005a4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005a7	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  005ab	83 f9 01	 cmp	 ecx, 1
  005ae	0f 85 90 00 00
	00		 jne	 $LN28@gObjSkillU

; 25463: 	{
; 25464: 		if( --lpObj->SkillAddCriticalDamageTime <= 0 )

  005b4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005b7	66 8b 88 14 1a
	00 00		 mov	 cx, WORD PTR [eax+6676]
  005be	66 83 e9 01	 sub	 cx, 1
  005c2	66 89 8d 6e fd
	ff ff		 mov	 WORD PTR tv334[ebp], cx
  005c9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005cc	66 8b 85 6e fd
	ff ff		 mov	 ax, WORD PTR tv334[ebp]
  005d3	66 89 82 14 1a
	00 00		 mov	 WORD PTR [edx+6676], ax
  005da	0f b7 8d 6e fd
	ff ff		 movzx	 ecx, WORD PTR tv334[ebp]
  005e1	85 c9		 test	 ecx, ecx
  005e3	7f 5f		 jg	 SHORT $LN28@gObjSkillU

; 25465: 		{
; 25466: 			lpObj->SkillAddCriticalDamageTime = 0;			

  005e5	33 c0		 xor	 eax, eax
  005e7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005ea	66 89 81 14 1a
	00 00		 mov	 WORD PTR [ecx+6676], ax

; 25467: 			lpObj->SkillAddCriticalDamage = 0;

  005f1	33 c0		 xor	 eax, eax
  005f3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005f6	66 89 81 16 1a
	00 00		 mov	 WORD PTR [ecx+6678], ax

; 25468: 
; 25469: 			MsgOutput(lpObj->m_Index, lMsg.Get(1242));	// "     "

  005fd	68 da 04 00 00	 push	 1242			; 000004daH
  00602	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00607	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0060d	50		 push	 eax
  0060e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00611	8b 08		 mov	 ecx, DWORD PTR [eax]
  00613	51		 push	 ecx
  00614	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00619	83 c4 08	 add	 esp, 8

; 25470: 
; 25471: 			lpObj->m_ViewSkillState &= ~STATE_ADD_CRITICAL_DAMAGE; //    

  0061c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0061f	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  00626	81 e1 ff f7 ff
	ff		 and	 ecx, -2049		; fffff7ffH
  0062c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0062f	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 25472: 			GCMagicCancelSend(lpObj, AT_SKILL_ADD_CRITICALDAMAGE);

  00636	6a 40		 push	 64			; 00000040H
  00638	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0063b	50		 push	 eax
  0063c	e8 00 00 00 00	 call	 ?GCMagicCancelSend@@YAXPAVOBJECTSTRUCT@@E@Z ; GCMagicCancelSend
  00641	83 c4 08	 add	 esp, 8
$LN28@gObjSkillU:

; 25473: 		}
; 25474: 	}
; 25475: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 25476: 
; 25477: #endif
; 25478: 
; 25479: #ifdef ADD_NEW_MONSTER_SYSTEM_01_20050714
; 25480: 	TMonsterSkillElementInfo::CheckSkillElementInfoProc(lpObj);
; 25481: #endif
; 25482: 
; 25483: #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004				// !! NOT
; 25484: 	#ifdef ADD_NEW_SKILL_FOR_CASTLE_01_20041116
; 25485: 	if( lpObj->m_iSkillStunTime && lpObj->Type == OBJTYPE_CHARACTER )
; 25486: 	{
; 25487: 		if( --lpObj->m_iSkillStunTime <= 0 )
; 25488: 		{
; 25489: 			lpObj->m_iSkillStunTime = 0;			
; 25490: 	
; 25491: 			MsgOutput(lpObj->m_Index, lMsg.Get(1636));	// "  ."
; 25492: 
; 25493: 			DEL_VIEWSKILLSTATE( lpObj->m_ViewSkillState, STATE_STUNED );
; 25494: 			GCStateInfoSend( lpObj, 0, STATE_STUNED );
; 25495: 		}
; 25496: 	}
; 25497: 
; 25498: 	if( lpObj->m_iSkillBrandOfSkillTime && lpObj->Type == OBJTYPE_CHARACTER )
; 25499: 	{
; 25500: 		if( --lpObj->m_iSkillBrandOfSkillTime <= 0 )
; 25501: 		{
; 25502: 			lpObj->m_iSkillBrandOfSkillTime = 0;			
; 25503: 	
; 25504: 			MsgOutput(lpObj->m_Index, lMsg.Get(1637));	// "  ."
; 25505: 
; 25506: 			DEL_VIEWSKILLSTATE( lpObj->m_ViewSkillState, STATE_BRAND_OF_SKILL );
; 25507: 			GCStateInfoSend( lpObj, 0, STATE_BRAND_OF_SKILL );
; 25508: 		}
; 25509: 	}
; 25510: 
; 25511: 	if( lpObj->m_iSkillInvisibleTime && lpObj->Type == OBJTYPE_CHARACTER )
; 25512: 	{
; 25513: 		if( --lpObj->m_iSkillInvisibleTime <= 0 )
; 25514: 		{
; 25515: 			lpObj->m_iSkillInvisibleTime = 0;			
; 25516: 	
; 25517: 			MsgOutput(lpObj->m_Index, lMsg.Get(1638) );	// "  ."
; 25518: 
; 25519: 			DEL_VIEWSKILLSTATE( lpObj->m_ViewSkillState, STATE_CLOAKING );
; 25520: 			GCStateInfoSend( lpObj, 0, STATE_CLOAKING );
; 25521: 		}
; 25522: 	}
; 25523: 
; 25524: 	if( lpObj->m_iSkillManaSwellTime && lpObj->Type == OBJTYPE_CHARACTER )
; 25525: 	{
; 25526: 		if( --lpObj->m_iSkillManaSwellTime <= 0 )
; 25527: 		{
; 25528: 			lpObj->AddMana -= lpObj->m_iSkillManaSwell;
; 25529: 
; 25530: 			if( lpObj->AddMana < 0 )
; 25531: 				lpObj->AddMana = 0;
; 25532: 
; 25533: 			GCManaSend(lpObj->m_Index, (short)(lpObj->MaxMana+lpObj->AddMana), 0xFE, 0, lpObj->MaxBP+lpObj->AddBP);
; 25534: 			
; 25535: 			if( lpObj->Mana > (lpObj->MaxMana+lpObj->AddMana) )
; 25536: 			{	//       
; 25537: 				lpObj->Mana = (lpObj->MaxMana+lpObj->AddMana);
; 25538: 				GCManaSend(lpObj->m_Index, (short)(lpObj->Mana), 0xFF, 0, lpObj->BP);		
; 25539: 			}
; 25540: 
; 25541: 			lpObj->m_iSkillManaSwellTime = 0;
; 25542: 			lpObj->m_iSkillManaSwell = 0;
; 25543: 	
; 25544: 			MsgOutput(lpObj->m_Index, lMsg.Get(1639) );	// "  ."
; 25545: 
; 25546: 			DEL_VIEWSKILLSTATE( lpObj->m_ViewSkillState, STATE_ADD_MANA );
; 25547: 			GCStateInfoSend( lpObj, 0, STATE_ADD_MANA );
; 25548: 		}
; 25549: 	}
; 25550: 	#endif
; 25551: 
; 25552: 	#ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116
; 25553: 	if( lpObj->m_iPotionBlessTime && lpObj->Type == OBJTYPE_CHARACTER )
; 25554: 	{
; 25555: 		if( --lpObj->m_iPotionBlessTime <= 0 )
; 25556: 		{
; 25557: 			lpObj->m_iPotionBlessTime = 0;			
; 25558: 	
; 25559: 			MsgOutput(lpObj->m_Index, lMsg.Get(1634));	// "   ."
; 25560: 
; 25561: 			DEL_VIEWSKILLSTATE( lpObj->m_ViewSkillState, STATE_BLESS_POTION );
; 25562: 			GCStateInfoSend( lpObj, 0, STATE_BLESS_POTION );
; 25563: 		}
; 25564: 	}
; 25565: 
; 25566: 	if( lpObj->m_iPotionSoulTime && lpObj->Type == OBJTYPE_CHARACTER )
; 25567: 	{
; 25568: 		if( --lpObj->m_iPotionSoulTime <= 0 )
; 25569: 		{
; 25570: 			lpObj->m_iPotionSoulTime = 0;			
; 25571: 	
; 25572: 			MsgOutput(lpObj->m_Index, lMsg.Get(1635) );	// "   ."
; 25573: 
; 25574: 			DEL_VIEWSKILLSTATE( lpObj->m_ViewSkillState, STATE_SOUL_POTION );
; 25575: 			GCStateInfoSend( lpObj, 0, STATE_SOUL_POTION );
; 25576: 		}
; 25577: 	}
; 25578: 	#endif
; 25579: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 25580: 
; 25581: #ifdef ITEM_ADD_OPTION_20061019
; 25582: 	if( lpObj->Type == OBJTYPE_CHARACTER && lpObj->m_iItemEffectValidTime > 0 )
; 25583: 	{
; 25584: 		lpObj->m_iItemEffectValidTime--;
; 25585: 
; 25586: 		if( lpObj->m_iItemEffectValidTime <= 0 )
; 25587: 		{
; 25588: 			lpObj->m_iItemEffectValidTime = 0;
; 25589: 			//      .
; 25590: 			g_ItemAddOption.ClearItemEffect( lpObj, ITEMUSE_EFFECT_OPTION_END );
; 25591: #ifdef ADD_SHIELD_POINT_01_20060403
; 25592: 			GCReFillSend( lpObj->m_Index, (WORD)(lpObj->MaxLife + lpObj->AddLife), 0xFE, 0, (WORD)(lpObj->iMaxShield+lpObj->iAddShield));
; 25593: #else
; 25594: 			GCReFillSend( lpObj->m_Index, (WORD)(lpObj->MaxLife + lpObj->AddLife), 0xFE, 0);
; 25595: #endif
; 25596: 			GCManaSend(lpObj->m_Index, (short)(lpObj->MaxMana+lpObj->AddMana), 0xFE, 0, lpObj->MaxBP);
; 25597: 		}
; 25598: 	}
; 25599: #endif // ITEM_ADD_OPTION_20061019
; 25600: 
; 25601: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//     
; 25602: 	if( CHECK_ILLUSION_TEMPLE(lpObj->MapNumber) && lpObj->m_iIllusionTempleIndex != -1 )
; 25603: 	{
; 25604: 		g_IllusionTempleEvent.EventSkillProc(lpObj);
; 25605: 	}
; 25606: #endif
; 25607: 
; 25608: 	if( lpObj->m_SkillNumber < 1 ) return;

  00644	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00647	0f bf 88 34 02
	00 00		 movsx	 ecx, WORD PTR [eax+564]
  0064e	83 f9 01	 cmp	 ecx, 1
  00651	7d 02		 jge	 SHORT $LN29@gObjSkillU
  00653	eb 2c		 jmp	 SHORT $LN1@gObjSkillU
$LN29@gObjSkillU:

; 25609: 
; 25610: 	if( lpObj->m_SkillNumber ==  AT_SKILL_BLOCKING )

  00655	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00658	0f bf 88 34 02
	00 00		 movsx	 ecx, WORD PTR [eax+564]
  0065f	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00662	75 1d		 jne	 SHORT $LN31@gObjSkillU

; 25611: 	{
; 25612: 		if( GetTickCount() > lpObj->m_SkillTime)

  00664	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0066a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0066d	3b 81 38 02 00
	00		 cmp	 eax, DWORD PTR [ecx+568]
  00673	76 0c		 jbe	 SHORT $LN31@gObjSkillU

; 25613: 		{
; 25614: 			lpObj->m_SkillNumber = 0;

  00675	33 c0		 xor	 eax, eax
  00677	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0067a	66 89 81 34 02
	00 00		 mov	 WORD PTR [ecx+564], ax
$LN31@gObjSkillU:
$LN1@gObjSkillU:

; 25615: 		}
; 25616: 	}	
; 25617: 
; 25618: #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004				// !! NOT
; 25619: 	#ifdef ADD_SKILL_MUSE_ELF_INFINITYARROW_20060406
; 25620: 	if( lpObj->m_iMuseElfInfinityArrowSkillTime && lpObj->Type == OBJTYPE_CHARACTER )
; 25621: 	{
; 25622: 		lpObj->m_iMuseElfInfinityArrowSkillTime -= 1;
; 25623: 		if( lpObj->m_iMuseElfInfinityArrowSkillTime <= 0 )
; 25624: 		{
; 25625: 			lpObj->m_iMuseElfInfinityArrowSkillTime = 0;			
; 25626: 
; 25627: 			DEL_VIEWSKILLSTATE( lpObj->m_ViewSkillState, STATE_INFINITY_ARROW );
; 25628: 			GCStateInfoSend( lpObj, 0, STATE_INFINITY_ARROW );
; 25629: 		}
; 25630: 	}
; 25631: 	#endif
; 25632: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 25633: }

  00681	5f		 pop	 edi
  00682	5e		 pop	 esi
  00683	5b		 pop	 ebx
  00684	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00687	33 cd		 xor	 ecx, ebp
  00689	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0068e	8b e5		 mov	 esp, ebp
  00690	5d		 pop	 ebp
  00691	c3		 ret	 0
?gObjSkillUseProc@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; gObjSkillUseProc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGiveItemWarehouseSearch@@YAXPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
tv75 = -104						; size = 4
_perc$1 = -36						; size = 4
_item_num$2 = -32					; size = 4
_NeedLevel$ = -28					; size = 4
_ItemPos$ = -24						; size = 4
_index$ = -20						; size = 4
_type$ = -16						; size = 4
_incount$ = -12						; size = 4
_count$ = -8						; size = 4
_result$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_maxlevel$ = 12						; size = 4
?gObjGiveItemWarehouseSearch@@YAXPAVOBJECTSTRUCT@@H@Z PROC ; gObjGiveItemWarehouseSearch, COMDAT

; 8443 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 8444 : 
; 8445 : #ifdef UPGRADE_GAMESERVER_01_20041006
; 8446 : ///////////////////////////////////////////////////////////////////
; 8447 : //
; 8448 : //	MonsterItemMng  .
; 8449 : //
; 8450 : ///////////////////////////////////////////////////////////////////
; 8451 : 	return;

  00009	e9 5f 03 00 00	 jmp	 $LN1@gObjGiveIt

; 8452 : #endif
; 8453 : 
; 8454 : 	int result;
; 8455 : 	int count=256;

  0000e	c7 45 f8 00 01
	00 00		 mov	 DWORD PTR _count$[ebp], 256 ; 00000100H

; 8456 : 	int incount=0;

  00015	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _incount$[ebp], 0

; 8457 : 	int type;
; 8458 : 	int index;
; 8459 : 	int ItemPos=0;

  0001c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _ItemPos$[ebp], 0

; 8460 : 
; 8461 : 	int	NeedLevel = lpObj->Level-25;

  00023	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00026	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0002d	83 e9 19	 sub	 ecx, 25			; 00000019H
  00030	89 4d e4	 mov	 DWORD PTR _NeedLevel$[ebp], ecx

; 8462 : 	if( NeedLevel <= 0 )

  00033	83 7d e4 00	 cmp	 DWORD PTR _NeedLevel$[ebp], 0
  00037	7f 05		 jg	 SHORT $LN4@gObjGiveIt

; 8463 : 	{	//    
; 8464 : 		return;

  00039	e9 2f 03 00 00	 jmp	 $LN1@gObjGiveIt
$LN4@gObjGiveIt:

; 8465 : 	}
; 8466 : 	
; 8467 : //	LogAdd("    : %s ", lpObj->Name);	
; 8468 : 	
; 8469 : 	memset(lpObj->pWarehouseMap, 0xFF, MAX_WAREHOUSEITEMS);

  0003e	6a 78		 push	 120			; 00000078H
  00040	68 ff 00 00 00	 push	 255			; 000000ffH
  00045	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00048	8b 88 98 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3224]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _memset
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8470 : 	lpObj->WarehouseCount = 0;

  00057	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005a	c6 80 9c 0c 00
	00 00		 mov	 BYTE PTR [eax+3228], 0
$LN2@gObjGiveIt:

; 8471 : 	while(count--)

  00061	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00064	89 45 98	 mov	 DWORD PTR tv75[ebp], eax
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _count$[ebp]
  0006a	83 e9 01	 sub	 ecx, 1
  0006d	89 4d f8	 mov	 DWORD PTR _count$[ebp], ecx
  00070	83 7d 98 00	 cmp	 DWORD PTR tv75[ebp], 0
  00074	0f 84 e7 02 00
	00		 je	 $LN3@gObjGiveIt

; 8472 : 	{
; 8473 : 		if( (rand()%40) == 0 )	//   

  0007a	e8 00 00 00 00	 call	 _rand
  0007f	99		 cdq
  00080	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00085	f7 f9		 idiv	 ecx
  00087	85 d2		 test	 edx, edx
  00089	75 1d		 jne	 SHORT $LN5@gObjGiveIt

; 8474 : 		{
; 8475 : 			type = 15;

  0008b	c7 45 f0 0f 00
	00 00		 mov	 DWORD PTR _type$[ebp], 15 ; 0000000fH

; 8476 : 			index = rand()%MAX_ITEM_INDEX;

  00092	e8 00 00 00 00	 call	 _rand
  00097	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  0009c	79 05		 jns	 SHORT $LN43@gObjGiveIt
  0009e	48		 dec	 eax
  0009f	83 c8 e0	 or	 eax, -32		; ffffffe0H
  000a2	40		 inc	 eax
$LN43@gObjGiveIt:
  000a3	89 45 ec	 mov	 DWORD PTR _index$[ebp], eax

; 8477 : 		}

  000a6	eb 28		 jmp	 SHORT $LN6@gObjGiveIt
$LN5@gObjGiveIt:

; 8478 : 		else
; 8479 : 		{		
; 8480 : 			type = rand()%MAX_ITEM_TYPE;

  000a8	e8 00 00 00 00	 call	 _rand
  000ad	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  000b2	79 05		 jns	 SHORT $LN44@gObjGiveIt
  000b4	48		 dec	 eax
  000b5	83 c8 f0	 or	 eax, -16		; fffffff0H
  000b8	40		 inc	 eax
$LN44@gObjGiveIt:
  000b9	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax

; 8481 : 			index = rand()%MAX_ITEM_INDEX;

  000bc	e8 00 00 00 00	 call	 _rand
  000c1	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  000c6	79 05		 jns	 SHORT $LN45@gObjGiveIt
  000c8	48		 dec	 eax
  000c9	83 c8 e0	 or	 eax, -32		; ffffffe0H
  000cc	40		 inc	 eax
$LN45@gObjGiveIt:
  000cd	89 45 ec	 mov	 DWORD PTR _index$[ebp], eax
$LN6@gObjGiveIt:

; 8482 : 		}
; 8483 : 
; 8484 : #ifdef ADD_NEW_MAP_KALIMA_20040518			// 6 -   90   .
; 8485 : 	if (lpObj->Class == 275) {

  000d0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d3	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000da	81 f9 13 01 00
	00		 cmp	 ecx, 275		; 00000113H
  000e0	75 4d		 jne	 SHORT $LN7@gObjGiveIt

; 8486 : 		int item_num	= (type*MAX_ITEM_INDEX)+index;

  000e2	8b 45 f0	 mov	 eax, DWORD PTR _type$[ebp]
  000e5	c1 e0 05	 shl	 eax, 5
  000e8	03 45 ec	 add	 eax, DWORD PTR _index$[ebp]
  000eb	89 45 e0	 mov	 DWORD PTR _item_num$2[ebp], eax

; 8487 : 
; 8488 : 		if( ItemAttribute[item_num].Level == 0xFF )	continue;	//   

  000ee	6b 45 e0 6c	 imul	 eax, DWORD PTR _item_num$2[ebp], 108
  000f2	0f b6 88 22 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+34]
  000f9	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  000ff	75 05		 jne	 SHORT $LN8@gObjGiveIt
  00101	e9 5b ff ff ff	 jmp	 $LN2@gObjGiveIt
$LN8@gObjGiveIt:

; 8489 : 		if( ItemAttribute[item_num].Level == 0    )	continue;

  00106	6b 45 e0 6c	 imul	 eax, DWORD PTR _item_num$2[ebp], 108
  0010a	0f b6 88 22 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+34]
  00111	85 c9		 test	 ecx, ecx
  00113	75 05		 jne	 SHORT $LN9@gObjGiveIt
  00115	e9 47 ff ff ff	 jmp	 $LN2@gObjGiveIt
$LN9@gObjGiveIt:

; 8490 : 		if( ItemAttribute[item_num].Level < 125 )	continue;	//  100 

  0011a	6b 45 e0 6c	 imul	 eax, DWORD PTR _item_num$2[ebp], 108
  0011e	0f b6 88 22 00
	00 00		 movzx	 ecx, BYTE PTR ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A[eax+34]
  00125	83 f9 7d	 cmp	 ecx, 125		; 0000007dH
  00128	7d 05		 jge	 SHORT $LN7@gObjGiveIt
  0012a	e9 32 ff ff ff	 jmp	 $LN2@gObjGiveIt
$LN7@gObjGiveIt:

; 8491 : 	}
; 8492 : #endif
; 8493 : 
; 8494 : #ifdef NEW_SKILL_FORSKYLAND
; 8495 : 		if( type == 13 && index == 3 )

  0012f	83 7d f0 0d	 cmp	 DWORD PTR _type$[ebp], 13 ; 0000000dH
  00133	75 0b		 jne	 SHORT $LN11@gObjGiveIt
  00135	83 7d ec 03	 cmp	 DWORD PTR _index$[ebp], 3
  00139	75 05		 jne	 SHORT $LN11@gObjGiveIt

; 8496 : 		{	//      
; 8497 : 			continue;

  0013b	e9 21 ff ff ff	 jmp	 $LN2@gObjGiveIt
$LN11@gObjGiveIt:

; 8498 : 		}
; 8499 : #endif
; 8500 : 		// type : 13, 14, 12  ..
; 8501 : 		// type : 13, 14, 12  ..
; 8502 : 		if( 
; 8503 : 				(	(type==13) && (index<8)	) || 
; 8504 : 
; 8505 : 				(	(type == 14) && ((index == 9)	|| 
; 8506 : 					(index == 10) || (index == 13)	|| 
; 8507 : 					(index == 14) || (index == 16)	|| 
; 8508 : 					(index == 17) || (index == 18))	) ||

  00140	83 7d f0 0d	 cmp	 DWORD PTR _type$[ebp], 13 ; 0000000dH
  00144	75 06		 jne	 SHORT $LN15@gObjGiveIt
  00146	83 7d ec 08	 cmp	 DWORD PTR _index$[ebp], 8
  0014a	7c 44		 jl	 SHORT $LN14@gObjGiveIt
$LN15@gObjGiveIt:
  0014c	83 7d f0 0e	 cmp	 DWORD PTR _type$[ebp], 14 ; 0000000eH
  00150	75 2a		 jne	 SHORT $LN16@gObjGiveIt
  00152	83 7d ec 09	 cmp	 DWORD PTR _index$[ebp], 9
  00156	74 38		 je	 SHORT $LN14@gObjGiveIt
  00158	83 7d ec 0a	 cmp	 DWORD PTR _index$[ebp], 10 ; 0000000aH
  0015c	74 32		 je	 SHORT $LN14@gObjGiveIt
  0015e	83 7d ec 0d	 cmp	 DWORD PTR _index$[ebp], 13 ; 0000000dH
  00162	74 2c		 je	 SHORT $LN14@gObjGiveIt
  00164	83 7d ec 0e	 cmp	 DWORD PTR _index$[ebp], 14 ; 0000000eH
  00168	74 26		 je	 SHORT $LN14@gObjGiveIt
  0016a	83 7d ec 10	 cmp	 DWORD PTR _index$[ebp], 16 ; 00000010H
  0016e	74 20		 je	 SHORT $LN14@gObjGiveIt
  00170	83 7d ec 11	 cmp	 DWORD PTR _index$[ebp], 17 ; 00000011H
  00174	74 1a		 je	 SHORT $LN14@gObjGiveIt
  00176	83 7d ec 12	 cmp	 DWORD PTR _index$[ebp], 18 ; 00000012H
  0017a	74 14		 je	 SHORT $LN14@gObjGiveIt
$LN16@gObjGiveIt:
  0017c	83 7d f0 0c	 cmp	 DWORD PTR _type$[ebp], 12 ; 0000000cH
  00180	0f 85 bd 00 00
	00		 jne	 $LN12@gObjGiveIt
  00186	83 7d ec 0f	 cmp	 DWORD PTR _index$[ebp], 15 ; 0000000fH
  0018a	0f 85 b3 00 00
	00		 jne	 $LN12@gObjGiveIt
$LN14@gObjGiveIt:

; 8509 : 
; 8510 : 				(	(type==12) && (index==15) ) 
; 8511 : 			)
; 8512 : 		{
; 8513 : 			int perc = rand()%8;

  00190	e8 00 00 00 00	 call	 _rand
  00195	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0019a	79 05		 jns	 SHORT $LN46@gObjGiveIt
  0019c	48		 dec	 eax
  0019d	83 c8 f8	 or	 eax, -8			; fffffff8H
  001a0	40		 inc	 eax
$LN46@gObjGiveIt:
  001a1	89 45 dc	 mov	 DWORD PTR _perc$1[ebp], eax

; 8514 : 
; 8515 : 			if( type==12 && index==15 )

  001a4	83 7d f0 0c	 cmp	 DWORD PTR _type$[ebp], 12 ; 0000000cH
  001a8	75 0d		 jne	 SHORT $LN17@gObjGiveIt
  001aa	83 7d ec 0f	 cmp	 DWORD PTR _index$[ebp], 15 ; 0000000fH
  001ae	75 07		 jne	 SHORT $LN17@gObjGiveIt

; 8516 : 			{
; 8517 : 				perc = 1;

  001b0	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _perc$1[ebp], 1
$LN17@gObjGiveIt:

; 8518 : 				//perc = rand()%5;
; 8519 : 			}
; 8520 : 
; 8521 : 			if( type==14 && index==17 )

  001b7	83 7d f0 0e	 cmp	 DWORD PTR _type$[ebp], 14 ; 0000000eH
  001bb	75 0d		 jne	 SHORT $LN18@gObjGiveIt
  001bd	83 7d ec 11	 cmp	 DWORD PTR _index$[ebp], 17 ; 00000011H
  001c1	75 07		 jne	 SHORT $LN18@gObjGiveIt

; 8522 : 			{	//  
; 8523 : 				perc = 1;

  001c3	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _perc$1[ebp], 1
$LN18@gObjGiveIt:

; 8524 : 			}
; 8525 : 
; 8526 : 			if( type==14 && index==18 )

  001ca	83 7d f0 0e	 cmp	 DWORD PTR _type$[ebp], 14 ; 0000000eH
  001ce	75 0d		 jne	 SHORT $LN19@gObjGiveIt
  001d0	83 7d ec 12	 cmp	 DWORD PTR _index$[ebp], 18 ; 00000012H
  001d4	75 07		 jne	 SHORT $LN19@gObjGiveIt

; 8527 : 			{	//  				
; 8528 : 				perc = 1;

  001d6	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _perc$1[ebp], 1
$LN19@gObjGiveIt:

; 8529 : 			}			
; 8530 : 
; 8531 : 			if( perc ==0 )

  001dd	83 7d dc 00	 cmp	 DWORD PTR _perc$1[ebp], 0
  001e1	75 5b		 jne	 SHORT $LN20@gObjGiveIt

; 8532 : 			{
; 8533 : 				if( zzzItemLevel(type, index, NeedLevel) == TRUE )

  001e3	8b 45 e4	 mov	 eax, DWORD PTR _NeedLevel$[ebp]
  001e6	50		 push	 eax
  001e7	8b 4d ec	 mov	 ecx, DWORD PTR _index$[ebp]
  001ea	51		 push	 ecx
  001eb	8b 55 f0	 mov	 edx, DWORD PTR _type$[ebp]
  001ee	52		 push	 edx
  001ef	e8 00 00 00 00	 call	 ?zzzItemLevel@@YAHHHH@Z	; zzzItemLevel
  001f4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f7	83 f8 01	 cmp	 eax, 1
  001fa	75 42		 jne	 SHORT $LN20@gObjGiveIt

; 8534 : 				{	
; 8535 : 					if( gObjWarehouseInsertItem(lpObj, type, index, 0, ItemPos) != 0xFF )

  001fc	8b 45 e8	 mov	 eax, DWORD PTR _ItemPos$[ebp]
  001ff	50		 push	 eax
  00200	6a 00		 push	 0
  00202	8b 4d ec	 mov	 ecx, DWORD PTR _index$[ebp]
  00205	51		 push	 ecx
  00206	8b 55 f0	 mov	 edx, DWORD PTR _type$[ebp]
  00209	52		 push	 edx
  0020a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0020d	50		 push	 eax
  0020e	e8 00 00 00 00	 call	 ?gObjWarehouseInsertItem@@YAEPAVOBJECTSTRUCT@@HHHH@Z ; gObjWarehouseInsertItem
  00213	83 c4 14	 add	 esp, 20			; 00000014H
  00216	0f b6 c8	 movzx	 ecx, al
  00219	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0021f	74 1d		 je	 SHORT $LN20@gObjGiveIt

; 8536 : 					{
; 8537 : 						//if( lpObj->Level >= 50 )
; 8538 : 						{
; 8539 : 						//LogAdd("(%d)(%s) Ex Item Add(level:%d) : type:%d index:%d level:%d Name : %s %s", 
; 8540 : 						//	  lpObj->Class, lpObj->Name, lpObj->Level, type, index, result, lpObj->pWarehouse[ItemPos].GetName(), lpObj->Name);
; 8541 : 						}
; 8542 : 						ItemPos++;

  00221	8b 45 e8	 mov	 eax, DWORD PTR _ItemPos$[ebp]
  00224	83 c0 01	 add	 eax, 1
  00227	89 45 e8	 mov	 DWORD PTR _ItemPos$[ebp], eax

; 8543 : 						incount++;

  0022a	8b 45 f4	 mov	 eax, DWORD PTR _incount$[ebp]
  0022d	83 c0 01	 add	 eax, 1
  00230	89 45 f4	 mov	 DWORD PTR _incount$[ebp], eax

; 8544 : 						if( incount > MAX_INVENTORY-1 ) break;

  00233	83 7d f4 4b	 cmp	 DWORD PTR _incount$[ebp], 75 ; 0000004bH
  00237	7e 05		 jle	 SHORT $LN20@gObjGiveIt
  00239	e9 23 01 00 00	 jmp	 $LN3@gObjGiveIt
$LN20@gObjGiveIt:

; 8545 : 					}
; 8546 : 				}
; 8547 : 			}
; 8548 : 		}

  0023e	e9 19 01 00 00	 jmp	 $LN13@gObjGiveIt
$LN12@gObjGiveIt:

; 8549 : 		else
; 8550 : 		{
; 8551 : 			result = GetLevelItem(type, index, NeedLevel);

  00243	8b 45 e4	 mov	 eax, DWORD PTR _NeedLevel$[ebp]
  00246	50		 push	 eax
  00247	8b 4d ec	 mov	 ecx, DWORD PTR _index$[ebp]
  0024a	51		 push	 ecx
  0024b	8b 55 f0	 mov	 edx, DWORD PTR _type$[ebp]
  0024e	52		 push	 edx
  0024f	e8 00 00 00 00	 call	 ?GetLevelItem@@YAHHHH@Z	; GetLevelItem
  00254	83 c4 0c	 add	 esp, 12			; 0000000cH
  00257	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax

; 8552 : 			if( result >= 0  )

  0025a	83 7d fc 00	 cmp	 DWORD PTR _result$[ebp], 0
  0025e	0f 8c f8 00 00
	00		 jl	 $LN13@gObjGiveIt

; 8553 : 			{
; 8554 : 				if( (type == 13 && index == 10) || 

  00264	83 7d f0 0d	 cmp	 DWORD PTR _type$[ebp], 13 ; 0000000dH
  00268	75 06		 jne	 SHORT $LN28@gObjGiveIt
  0026a	83 7d ec 0a	 cmp	 DWORD PTR _index$[ebp], 10 ; 0000000aH
  0026e	74 0c		 je	 SHORT $LN27@gObjGiveIt
$LN28@gObjGiveIt:
  00270	83 7d f0 0c	 cmp	 DWORD PTR _type$[ebp], 12 ; 0000000cH
  00274	75 4d		 jne	 SHORT $LN25@gObjGiveIt
  00276	83 7d ec 0b	 cmp	 DWORD PTR _index$[ebp], 11 ; 0000000bH
  0027a	75 47		 jne	 SHORT $LN25@gObjGiveIt
$LN27@gObjGiveIt:

; 8555 : 					(type == 12 && index == 11) )
; 8556 : 				{
; 8557 : 					if( gObjWarehouseInsertItem(lpObj, type, index, 0, ItemPos) != 0xFF )

  0027c	8b 45 e8	 mov	 eax, DWORD PTR _ItemPos$[ebp]
  0027f	50		 push	 eax
  00280	6a 00		 push	 0
  00282	8b 4d ec	 mov	 ecx, DWORD PTR _index$[ebp]
  00285	51		 push	 ecx
  00286	8b 55 f0	 mov	 edx, DWORD PTR _type$[ebp]
  00289	52		 push	 edx
  0028a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028d	50		 push	 eax
  0028e	e8 00 00 00 00	 call	 ?gObjWarehouseInsertItem@@YAEPAVOBJECTSTRUCT@@HHHH@Z ; gObjWarehouseInsertItem
  00293	83 c4 14	 add	 esp, 20			; 00000014H
  00296	0f b6 c8	 movzx	 ecx, al
  00299	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0029f	74 1d		 je	 SHORT $LN29@gObjGiveIt

; 8558 : 					{
; 8559 : 						//if( lpObj->Level >= 50 )
; 8560 : 						{
; 8561 : 						//LogAdd("(%d)(%s) Ex Item Add(level:%d) : type:%d index:%d level:%d Name : %s %s", 
; 8562 : 						//	  lpObj->Class, lpObj->Name, lpObj->Level, type, index, result, lpObj->pWarehouse[ItemPos].GetName(), lpObj->Name);
; 8563 : 						}
; 8564 : 						ItemPos ++;

  002a1	8b 45 e8	 mov	 eax, DWORD PTR _ItemPos$[ebp]
  002a4	83 c0 01	 add	 eax, 1
  002a7	89 45 e8	 mov	 DWORD PTR _ItemPos$[ebp], eax

; 8565 : 						incount++;

  002aa	8b 45 f4	 mov	 eax, DWORD PTR _incount$[ebp]
  002ad	83 c0 01	 add	 eax, 1
  002b0	89 45 f4	 mov	 DWORD PTR _incount$[ebp], eax

; 8566 : 						if( incount > MAX_INVENTORY-1 ) break;

  002b3	83 7d f4 4b	 cmp	 DWORD PTR _incount$[ebp], 75 ; 0000004bH
  002b7	7e 05		 jle	 SHORT $LN29@gObjGiveIt
  002b9	e9 a3 00 00 00	 jmp	 $LN3@gObjGiveIt
$LN29@gObjGiveIt:

; 8567 : 					}
; 8568 : 				}

  002be	e9 99 00 00 00	 jmp	 $LN13@gObjGiveIt
$LN25@gObjGiveIt:

; 8569 : 				else if( result <= maxlevel )

  002c3	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
  002c6	3b 45 0c	 cmp	 eax, DWORD PTR _maxlevel$[ebp]
  002c9	0f 8f 8d 00 00
	00		 jg	 $LN13@gObjGiveIt

; 8570 : 				{
; 8571 : 					if( type == 12)

  002cf	83 7d f0 0c	 cmp	 DWORD PTR _type$[ebp], 12 ; 0000000cH
  002d3	75 0d		 jne	 SHORT $LN32@gObjGiveIt

; 8572 : 					{
; 8573 : 						if( index != 11 ) result = 0;

  002d5	83 7d ec 0b	 cmp	 DWORD PTR _index$[ebp], 11 ; 0000000bH
  002d9	74 07		 je	 SHORT $LN32@gObjGiveIt
  002db	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0
$LN32@gObjGiveIt:

; 8574 : 					}
; 8575 : 					if( type == 12 && index == 11 )

  002e2	83 7d f0 0c	 cmp	 DWORD PTR _type$[ebp], 12 ; 0000000cH
  002e6	75 08		 jne	 SHORT $LN34@gObjGiveIt
  002e8	83 7d ec 0b	 cmp	 DWORD PTR _index$[ebp], 11 ; 0000000bH
  002ec	75 02		 jne	 SHORT $LN34@gObjGiveIt

; 8576 : 					{
; 8577 : 
; 8578 : 					}

  002ee	eb 0e		 jmp	 SHORT $LN35@gObjGiveIt
$LN34@gObjGiveIt:

; 8579 : 					else if( result > maxlevel ) result = maxlevel;

  002f0	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
  002f3	3b 45 0c	 cmp	 eax, DWORD PTR _maxlevel$[ebp]
  002f6	7e 06		 jle	 SHORT $LN35@gObjGiveIt
  002f8	8b 45 0c	 mov	 eax, DWORD PTR _maxlevel$[ebp]
  002fb	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax
$LN35@gObjGiveIt:

; 8580 : 
; 8581 : 					if( (type == 4 && index == 7) || (type == 4 && index == 15) )	// ,  

  002fe	83 7d f0 04	 cmp	 DWORD PTR _type$[ebp], 4
  00302	75 06		 jne	 SHORT $LN39@gObjGiveIt
  00304	83 7d ec 07	 cmp	 DWORD PTR _index$[ebp], 7
  00308	74 0c		 je	 SHORT $LN38@gObjGiveIt
$LN39@gObjGiveIt:
  0030a	83 7d f0 04	 cmp	 DWORD PTR _type$[ebp], 4
  0030e	75 0d		 jne	 SHORT $LN37@gObjGiveIt
  00310	83 7d ec 0f	 cmp	 DWORD PTR _index$[ebp], 15 ; 0000000fH
  00314	75 07		 jne	 SHORT $LN37@gObjGiveIt
$LN38@gObjGiveIt:

; 8582 : 					{
; 8583 : 						result = 0;

  00316	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0
$LN37@gObjGiveIt:

; 8584 : 					}
; 8585 : 					
; 8586 : 					if( gObjWarehouseInsertItem(lpObj, type, index, 0, ItemPos) != 0xFF )

  0031d	8b 45 e8	 mov	 eax, DWORD PTR _ItemPos$[ebp]
  00320	50		 push	 eax
  00321	6a 00		 push	 0
  00323	8b 4d ec	 mov	 ecx, DWORD PTR _index$[ebp]
  00326	51		 push	 ecx
  00327	8b 55 f0	 mov	 edx, DWORD PTR _type$[ebp]
  0032a	52		 push	 edx
  0032b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0032e	50		 push	 eax
  0032f	e8 00 00 00 00	 call	 ?gObjWarehouseInsertItem@@YAEPAVOBJECTSTRUCT@@HHHH@Z ; gObjWarehouseInsertItem
  00334	83 c4 14	 add	 esp, 20			; 00000014H
  00337	0f b6 c8	 movzx	 ecx, al
  0033a	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00340	74 1a		 je	 SHORT $LN13@gObjGiveIt

; 8587 : 					{
; 8588 : 						//if( lpObj->Level >= 50 )
; 8589 : 						{
; 8590 : 						//LogAdd("(%d)(%s) Ex Item Add(level:%d) : type:%d index:%d level:%d Name : %s %s", 
; 8591 : 						//	  lpObj->Class, lpObj->Name, lpObj->Level, type, index, result, lpObj->pWarehouse[ItemPos].GetName(), lpObj->Name);
; 8592 : 						}
; 8593 : 						
; 8594 : 						ItemPos ++;

  00342	8b 45 e8	 mov	 eax, DWORD PTR _ItemPos$[ebp]
  00345	83 c0 01	 add	 eax, 1
  00348	89 45 e8	 mov	 DWORD PTR _ItemPos$[ebp], eax

; 8595 : 						incount++;

  0034b	8b 45 f4	 mov	 eax, DWORD PTR _incount$[ebp]
  0034e	83 c0 01	 add	 eax, 1
  00351	89 45 f4	 mov	 DWORD PTR _incount$[ebp], eax

; 8596 : 						if( incount > MAX_INVENTORY-1 ) break;

  00354	83 7d f4 4b	 cmp	 DWORD PTR _incount$[ebp], 75 ; 0000004bH
  00358	7e 02		 jle	 SHORT $LN13@gObjGiveIt
  0035a	eb 05		 jmp	 SHORT $LN3@gObjGiveIt
$LN13@gObjGiveIt:

; 8597 : 					}
; 8598 : 				}
; 8599 : 			}
; 8600 : 		}
; 8601 : 	}

  0035c	e9 00 fd ff ff	 jmp	 $LN2@gObjGiveIt
$LN3@gObjGiveIt:

; 8602 : 	lpObj->WarehouseCount = ItemPos;

  00361	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00364	8a 4d e8	 mov	 cl, BYTE PTR _ItemPos$[ebp]
  00367	88 88 9c 0c 00
	00		 mov	 BYTE PTR [eax+3228], cl
$LN1@gObjGiveIt:

; 8603 : }

  0036d	5f		 pop	 edi
  0036e	5e		 pop	 esi
  0036f	5b		 pop	 ebx
  00370	8b e5		 mov	 esp, ebp
  00372	5d		 pop	 ebp
  00373	c3		 ret	 0
?gObjGiveItemWarehouseSearch@@YAXPAVOBJECTSTRUCT@@H@Z ENDP ; gObjGiveItemWarehouseSearch
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjWarehouseInsertItem@@YAEPAVOBJECTSTRUCT@@HHHH@Z
_TEXT	SEGMENT
_item_type$ = -176					; size = 4
_item$ = -172						; size = 168
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_type$ = 12						; size = 4
_index$ = 16						; size = 4
_level$ = 20						; size = 4
_pos$ = 24						; size = 4
?gObjWarehouseInsertItem@@YAEPAVOBJECTSTRUCT@@HHHH@Z PROC ; gObjWarehouseInsertItem, COMDAT

; 8427 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 8428 : 	CItem item;

  00016	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 8429 : 	int item_type;
; 8430 : 		
; 8431 : 	item_type    = ItemGetNumberMake(type, index );

  00021	8b 45 10	 mov	 eax, DWORD PTR _index$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _type$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0002e	83 c4 08	 add	 esp, 8
  00031	89 85 50 ff ff
	ff		 mov	 DWORD PTR _item_type$[ebp], eax

; 8432 : 	item.m_Level = level;

  00037	66 8b 45 14	 mov	 ax, WORD PTR _level$[ebp]
  0003b	66 89 85 5c ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], ax

; 8433 : 	item.Convert( item_type, 0, 0, 0);

  00042	6a 01		 push	 1
  00044	6a 00		 push	 0
  00046	6a 00		 push	 0
  00048	6a 00		 push	 0
  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _item_type$[ebp]
  00054	50		 push	 eax
  00055	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0005b	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 8434 : 
; 8435 : 	lpObj->pWarehouse[pos] = item;

  00060	69 45 18 a8 00
	00 00		 imul	 eax, DWORD PTR _pos$[ebp], 168
  00067	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0006a	8b b9 94 0c 00
	00		 mov	 edi, DWORD PTR [ecx+3220]
  00070	03 f8		 add	 edi, eax
  00072	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00077	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  0007d	f3 a5		 rep movsd

; 8436 : //	LogAdd("   : [%d] : %s ", pos, lpObj->pWarehouse[pos].GetName());
; 8437 : 	return pos;

  0007f	8a 45 18	 mov	 al, BYTE PTR _pos$[ebp]

; 8438 : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00088	33 cd		 xor	 ecx, ebp
  0008a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
?gObjWarehouseInsertItem@@YAEPAVOBJECTSTRUCT@@HHHH@Z ENDP ; gObjWarehouseInsertItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMonsterInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHHH@Z
_TEXT	SEGMENT
_a$ = -200						; size = 4
_item_type$ = -196					; size = 4
_blank$ = -189						; size = 1
_iheight$ = -188					; size = 4
_iwidth$ = -184						; size = 4
_h$ = -180						; size = 4
_w$ = -176						; size = 4
_item$ = -172						; size = 168
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_type$ = 12						; size = 4
_index$ = 16						; size = 4
_level$ = 20						; size = 4
_op1$ = 24						; size = 4
_op2$ = 28						; size = 4
_op3$ = 32						; size = 4
?gObjMonsterInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHHH@Z PROC ; gObjMonsterInventoryInsertItem, COMDAT

; 15556: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 15557: 	//g_MonsterItemMng.InsertItem(lpObj->Level, type, index, level, op1, op2, op3);
; 15558: 	
; 15559: 	CItem item;

  00016	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 15560: 	int w, h;
; 15561: 	int iwidth, iheight;
; 15562: 	BYTE blank=0;

  00021	c6 85 43 ff ff
	ff 00		 mov	 BYTE PTR _blank$[ebp], 0

; 15563: 	int item_type;
; 15564: 	int a=0;

  00028	c7 85 38 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _a$[ebp], 0

; 15565: 	
; 15566: 	
; 15567: 	//item_type = type<<4;
; 15568: 	//item_type += index;
; 15569: 	item_type    = ItemGetNumberMake(type, index );

  00032	8b 45 10	 mov	 eax, DWORD PTR _index$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _type$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  0003f	83 c4 08	 add	 esp, 8
  00042	89 85 3c ff ff
	ff		 mov	 DWORD PTR _item_type$[ebp], eax

; 15570: 
; 15571: 	item.m_Level = level;

  00048	66 8b 45 14	 mov	 ax, WORD PTR _level$[ebp]
  0004c	66 89 85 5c ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], ax

; 15572: 
; 15573: 	if( type == 13 && index == 10 )

  00053	83 7d 0c 0d	 cmp	 DWORD PTR _type$[ebp], 13 ; 0000000dH
  00057	75 27		 jne	 SHORT $LN8@gObjMonste
  00059	83 7d 10 0a	 cmp	 DWORD PTR _index$[ebp], 10 ; 0000000aH
  0005d	75 21		 jne	 SHORT $LN8@gObjMonste

; 15574: 	{
; 15575: 		item.m_Durability = (float)100+(rand()%100);

  0005f	e8 00 00 00 00	 call	 _rand
  00064	99		 cdq
  00065	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0006a	f7 f9		 idiv	 ecx
  0006c	f3 0f 2a c2	 cvtsi2ss xmm0, edx
  00070	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@42c80000
  00078	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _item$[ebp+36], xmm0
$LN8@gObjMonste:

; 15576: 	}
; 15577: 
; 15578: 	item.Convert( item_type, op1, op2, op3);	

  00080	6a 01		 push	 1
  00082	6a 00		 push	 0
  00084	6a 00		 push	 0
  00086	0f b6 45 20	 movzx	 eax, BYTE PTR _op3$[ebp]
  0008a	50		 push	 eax
  0008b	0f b6 4d 1c	 movzx	 ecx, BYTE PTR _op2$[ebp]
  0008f	51		 push	 ecx
  00090	0f b6 55 18	 movzx	 edx, BYTE PTR _op1$[ebp]
  00094	52		 push	 edx
  00095	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _item_type$[ebp]
  0009b	50		 push	 eax
  0009c	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  000a2	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 15579: 
; 15580: 	lpObj->pInventory[blank] = item;	

  000a7	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _blank$[ebp]
  000ae	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  000b4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000b7	8b ba 5c 0c 00
	00		 mov	 edi, DWORD PTR [edx+3164]
  000bd	03 f9		 add	 edi, ecx
  000bf	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  000c4	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  000ca	f3 a5		 rep movsd

; 15581: 	iwidth = 1;

  000cc	c7 85 48 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _iwidth$[ebp], 1

; 15582: 	iheight = 1;

  000d6	c7 85 44 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _iheight$[ebp], 1

; 15583: 
; 15584: 	for( h=0; h<8; h++)

  000e0	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _h$[ebp], 0
  000ea	eb 0f		 jmp	 SHORT $LN4@gObjMonste
$LN2@gObjMonste:
  000ec	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _h$[ebp]
  000f2	83 c0 01	 add	 eax, 1
  000f5	89 85 4c ff ff
	ff		 mov	 DWORD PTR _h$[ebp], eax
$LN4@gObjMonste:
  000fb	83 bd 4c ff ff
	ff 08		 cmp	 DWORD PTR _h$[ebp], 8
  00102	0f 8d 3b 01 00
	00		 jge	 $LN3@gObjMonste

; 15585: 	{
; 15586: 		for( w=0; w<8; w++)

  00108	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _w$[ebp], 0
  00112	eb 0f		 jmp	 SHORT $LN7@gObjMonste
$LN5@gObjMonste:
  00114	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _w$[ebp]
  0011a	83 c0 01	 add	 eax, 1
  0011d	89 85 50 ff ff
	ff		 mov	 DWORD PTR _w$[ebp], eax
$LN7@gObjMonste:
  00123	83 bd 50 ff ff
	ff 08		 cmp	 DWORD PTR _w$[ebp], 8
  0012a	0f 8d 0e 01 00
	00		 jge	 $LN6@gObjMonste

; 15587: 		{
; 15588: 			//  
; 15589: 			if( *(lpObj->pInventoryMap+(h*8)+w) == 0xFF )

  00130	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00133	8b 88 60 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3168]
  00139	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _h$[ebp]
  0013f	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00142	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _w$[ebp]
  00148	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  0014c	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00152	0f 85 e1 00 00
	00		 jne	 $LN12@gObjMonste

; 15590: 			{
; 15591: 				blank = gObjInventoryRectCheck(lpObj->m_Index, w, h, iwidth,iheight);

  00158	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _iheight$[ebp]
  0015e	50		 push	 eax
  0015f	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _iwidth$[ebp]
  00165	51		 push	 ecx
  00166	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _h$[ebp]
  0016c	52		 push	 edx
  0016d	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _w$[ebp]
  00173	50		 push	 eax
  00174	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00177	8b 11		 mov	 edx, DWORD PTR [ecx]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 ?gObjInventoryRectCheck@@YAEHHHHH@Z ; gObjInventoryRectCheck
  0017f	83 c4 14	 add	 esp, 20			; 00000014H
  00182	88 85 43 ff ff
	ff		 mov	 BYTE PTR _blank$[ebp], al

; 15592: 
; 15593: 				if( blank == 0xFE ) goto GOTO_EndFunc;

  00188	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _blank$[ebp]
  0018f	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  00194	75 0a		 jne	 SHORT $LN10@gObjMonste
  00196	e9 a8 00 00 00	 jmp	 $LN11@gObjMonste
  0019b	e9 a3 00 00 00	 jmp	 $GOTO_EndFunc$14
$LN10@gObjMonste:

; 15594: 				if( blank != 0xFF )	

  001a0	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _blank$[ebp]
  001a7	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  001ac	0f 84 87 00 00
	00		 je	 $LN12@gObjMonste

; 15595: 				{	//   
; 15596: 					lpObj->pInventory[blank] = item;

  001b2	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _blank$[ebp]
  001b9	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  001bf	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001c2	8b ba 5c 0c 00
	00		 mov	 edi, DWORD PTR [edx+3164]
  001c8	03 f9		 add	 edi, ecx
  001ca	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  001cf	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  001d5	f3 a5		 rep movsd

; 15597: 					
; 15598: 					*lpObj->pInventoryCount+=1;

  001d7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001da	8b 88 64 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3172]
  001e0	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  001e3	83 c2 01	 add	 edx, 1
  001e6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e9	8b 88 64 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3172]
  001ef	88 11		 mov	 BYTE PTR [ecx], dl

; 15599: 					
; 15600: 					gObjInventoryItemBoxSet(lpObj->m_Index, blank, iwidth, iwidth, (BYTE)lpObj->pInventory[blank].m_Type);

  001f1	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _blank$[ebp]
  001f8	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  001fe	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00201	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00207	0f b6 4c 08 06	 movzx	 ecx, BYTE PTR [eax+ecx+6]
  0020c	51		 push	 ecx
  0020d	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _iwidth$[ebp]
  00213	52		 push	 edx
  00214	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _iwidth$[ebp]
  0021a	50		 push	 eax
  0021b	0f b6 8d 43 ff
	ff ff		 movzx	 ecx, BYTE PTR _blank$[ebp]
  00222	51		 push	 ecx
  00223	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00226	8b 02		 mov	 eax, DWORD PTR [edx]
  00228	50		 push	 eax
  00229	e8 00 00 00 00	 call	 ?gObjInventoryItemBoxSet@@YAXHHHHE@Z ; gObjInventoryItemBoxSet
  0022e	83 c4 14	 add	 esp, 20			; 00000014H

; 15601: 
; 15602: 					return blank;

  00231	8a 85 43 ff ff
	ff		 mov	 al, BYTE PTR _blank$[ebp]
  00237	eb 0c		 jmp	 SHORT $LN1@gObjMonste
$LN12@gObjMonste:

; 15603: 				}			
; 15604: 
; 15605: 			}
; 15606: 		}

  00239	e9 d6 fe ff ff	 jmp	 $LN5@gObjMonste
$LN6@gObjMonste:

; 15607: 	}

  0023e	e9 a9 fe ff ff	 jmp	 $LN2@gObjMonste
$LN3@gObjMonste:
$LN11@gObjMonste:
$GOTO_EndFunc$14:

; 15608: 
; 15609: GOTO_EndFunc :
; 15610: 
; 15611: 	return 0xFF;

  00243	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjMonste:

; 15612: }

  00245	5f		 pop	 edi
  00246	5e		 pop	 esi
  00247	5b		 pop	 ebx
  00248	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024b	33 cd		 xor	 ecx, ebp
  0024d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00252	8b e5		 mov	 esp, ebp
  00254	5d		 pop	 ebp
  00255	c3		 ret	 0
?gObjMonsterInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHHH@Z ENDP ; gObjMonsterInventoryInsertItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMonsterItemLoadScript@@YAXPAVOBJECTSTRUCT@@PAD@Z
_TEXT	SEGMENT
_incount$ = -32						; size = 4
_op3$ = -28						; size = 4
_op2$ = -24						; size = 4
_op1$ = -20						; size = 4
_level$ = -16						; size = 4
_index$ = -12						; size = 4
_type$ = -8						; size = 4
_Token$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_script_file$ = 12					; size = 4
?gObjMonsterItemLoadScript@@YAXPAVOBJECTSTRUCT@@PAD@Z PROC ; gObjMonsterItemLoadScript, COMDAT

; 8142 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 8143 : 	if((SMDFile=fopen(script_file,"r")) == NULL)	

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  0000e	8b 45 0c	 mov	 eax, DWORD PTR _script_file$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _fopen
  00017	83 c4 08	 add	 esp, 8
  0001a	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax
  0001f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, 0
  00026	75 16		 jne	 SHORT $LN4@gObjMonste

; 8144 : 	{
; 8145 : 		MsgBox("file open error %s", script_file);

  00028	8b 45 0c	 mov	 eax, DWORD PTR _script_file$[ebp]
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs@
  00031	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00036	83 c4 08	 add	 esp, 8

; 8146 : 		return ;

  00039	e9 ee 00 00 00	 jmp	 $LN1@gObjMonste
$LN4@gObjMonste:

; 8147 : 	}
; 8148 : 	SMDToken Token;
; 8149 : 	int type;
; 8150 : 	int index;
; 8151 : 	int level;
; 8152 : 	int op1;
; 8153 : 	int op2;
; 8154 : 	int op3;
; 8155 : 	int incount=0;

  0003e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _incount$[ebp], 0
$LN2@gObjMonste:

; 8156 : 
; 8157 : 	while( true )

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	85 c0		 test	 eax, eax
  0004c	0f 84 cc 00 00
	00		 je	 $LN3@gObjMonste

; 8158 : 	{
; 8159 : 		Token = (*GetToken)();

  00052	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00057	89 45 fc	 mov	 DWORD PTR _Token$[ebp], eax

; 8160 : 		if(Token == END) break;

  0005a	83 7d fc 02	 cmp	 DWORD PTR _Token$[ebp], 2
  0005e	75 05		 jne	 SHORT $LN5@gObjMonste
  00060	e9 b9 00 00 00	 jmp	 $LN3@gObjMonste
$LN5@gObjMonste:

; 8161 : 		if(Token == NUMBER)

  00065	83 7d fc 01	 cmp	 DWORD PTR _Token$[ebp], 1
  00069	0f 85 aa 00 00
	00		 jne	 $LN8@gObjMonste

; 8162 : 		{
; 8163 : 			type	= (int)TokenNumber;

  0006f	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00077	89 45 f8	 mov	 DWORD PTR _type$[ebp], eax

; 8164 : 			Token = (*GetToken)(); index	= (int)TokenNumber;

  0007a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0007f	89 45 fc	 mov	 DWORD PTR _Token$[ebp], eax
  00082	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0008a	89 45 f4	 mov	 DWORD PTR _index$[ebp], eax

; 8165 : 			Token = (*GetToken)(); level	= (int)TokenNumber;

  0008d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00092	89 45 fc	 mov	 DWORD PTR _Token$[ebp], eax
  00095	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0009d	89 45 f0	 mov	 DWORD PTR _level$[ebp], eax

; 8166 : 			Token = (*GetToken)(); op1		= (int)TokenNumber;

  000a0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000a5	89 45 fc	 mov	 DWORD PTR _Token$[ebp], eax
  000a8	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000b0	89 45 ec	 mov	 DWORD PTR _op1$[ebp], eax

; 8167 : 			Token = (*GetToken)(); op2		= (int)TokenNumber;

  000b3	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000b8	89 45 fc	 mov	 DWORD PTR _Token$[ebp], eax
  000bb	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000c3	89 45 e8	 mov	 DWORD PTR _op2$[ebp], eax

; 8168 : 			Token = (*GetToken)(); op3		= (int)TokenNumber;

  000c6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000cb	89 45 fc	 mov	 DWORD PTR _Token$[ebp], eax
  000ce	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000d6	89 45 e4	 mov	 DWORD PTR _op3$[ebp], eax

; 8169 : 			
; 8170 : 			if( gObjMonsterInventoryInsertItem(lpObj, type, index, level, op1, op2, op3) != 0xFF )

  000d9	8b 45 e4	 mov	 eax, DWORD PTR _op3$[ebp]
  000dc	50		 push	 eax
  000dd	8b 4d e8	 mov	 ecx, DWORD PTR _op2$[ebp]
  000e0	51		 push	 ecx
  000e1	8b 55 ec	 mov	 edx, DWORD PTR _op1$[ebp]
  000e4	52		 push	 edx
  000e5	8b 45 f0	 mov	 eax, DWORD PTR _level$[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d f4	 mov	 ecx, DWORD PTR _index$[ebp]
  000ec	51		 push	 ecx
  000ed	8b 55 f8	 mov	 edx, DWORD PTR _type$[ebp]
  000f0	52		 push	 edx
  000f1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 ?gObjMonsterInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHHH@Z ; gObjMonsterInventoryInsertItem
  000fa	83 c4 1c	 add	 esp, 28			; 0000001cH
  000fd	0f b6 c8	 movzx	 ecx, al
  00100	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00106	74 11		 je	 SHORT $LN8@gObjMonste

; 8171 : 			{
; 8172 : 				//LogAdd("(%d)Item (level:%d) : type:%d index:%d level:%d op1%d  op2:%d  op3:%d", lpObj->Class, lpObj->Level, type, index, level, op1, op2,op3);
; 8173 : 				incount++;

  00108	8b 45 e0	 mov	 eax, DWORD PTR _incount$[ebp]
  0010b	83 c0 01	 add	 eax, 1
  0010e	89 45 e0	 mov	 DWORD PTR _incount$[ebp], eax

; 8174 : 				if( incount > MAX_INVENTORY-1 ) break;

  00111	83 7d e0 4b	 cmp	 DWORD PTR _incount$[ebp], 75 ; 0000004bH
  00115	7e 02		 jle	 SHORT $LN8@gObjMonste
  00117	eb 05		 jmp	 SHORT $LN3@gObjMonste
$LN8@gObjMonste:

; 8175 : 			}
; 8176 : 		}
; 8177 : 	}

  00119	e9 27 ff ff ff	 jmp	 $LN2@gObjMonste
$LN3@gObjMonste:

; 8178 : 	fclose(SMDFile);

  0011e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _fclose
  00129	83 c4 04	 add	 esp, 4
$LN1@gObjMonste:

; 8179 : }

  0012c	5f		 pop	 edi
  0012d	5e		 pop	 esi
  0012e	5b		 pop	 ebx
  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c3		 ret	 0
?gObjMonsterItemLoadScript@@YAXPAVOBJECTSTRUCT@@PAD@Z ENDP ; gObjMonsterItemLoadScript
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGiveItemSearch@@YAXPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
tv70 = -100						; size = 4
_devilitemlevel$1 = -32					; size = 4
_bCheckDevil$2 = -28					; size = 4
_perc$3 = -24						; size = 4
_index$ = -20						; size = 4
_type$ = -16						; size = 4
_incount$ = -12						; size = 4
_count$ = -8						; size = 4
_result$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_maxlevel$ = 12						; size = 4
?gObjGiveItemSearch@@YAXPAVOBJECTSTRUCT@@H@Z PROC	; gObjGiveItemSearch, COMDAT

; 8185 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 8186 : 
; 8187 : #ifdef UPGRADE_GAMESERVER_01_20041006
; 8188 : 	return;

  00009	e9 77 03 00 00	 jmp	 $LN1@gObjGiveIt

; 8189 : #endif
; 8190 : 
; 8191 : 	int result;
; 8192 : 	int count=256;

  0000e	c7 45 f8 00 01
	00 00		 mov	 DWORD PTR _count$[ebp], 256 ; 00000100H

; 8193 : 	int incount=0;

  00015	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _incount$[ebp], 0

; 8194 : 	int type;
; 8195 : 	int index;
; 8196 : 	
; 8197 : 	memset(lpObj->pInventoryMap, 0xFF, MAX_INVENTORYMAP);

  0001c	6a 40		 push	 64			; 00000040H
  0001e	68 ff 00 00 00	 push	 255			; 000000ffH
  00023	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00026	8b 88 60 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3168]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _memset
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@gObjGiveIt:

; 8198 : 	while(count--)

  00035	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00038	89 45 9c	 mov	 DWORD PTR tv70[ebp], eax
  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _count$[ebp]
  0003e	83 e9 01	 sub	 ecx, 1
  00041	89 4d f8	 mov	 DWORD PTR _count$[ebp], ecx
  00044	83 7d 9c 00	 cmp	 DWORD PTR tv70[ebp], 0
  00048	0f 84 37 03 00
	00		 je	 $LN1@gObjGiveIt

; 8199 : 	{
; 8200 : 		if( (rand()%40) == 0 )	//   

  0004e	e8 00 00 00 00	 call	 _rand
  00053	99		 cdq
  00054	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00059	f7 f9		 idiv	 ecx
  0005b	85 d2		 test	 edx, edx
  0005d	75 1d		 jne	 SHORT $LN4@gObjGiveIt

; 8201 : 		{
; 8202 : 			type = 15;

  0005f	c7 45 f0 0f 00
	00 00		 mov	 DWORD PTR _type$[ebp], 15 ; 0000000fH

; 8203 : 			index = rand()%MAX_ITEM_INDEX;

  00066	e8 00 00 00 00	 call	 _rand
  0006b	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  00070	79 05		 jns	 SHORT $LN49@gObjGiveIt
  00072	48		 dec	 eax
  00073	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00076	40		 inc	 eax
$LN49@gObjGiveIt:
  00077	89 45 ec	 mov	 DWORD PTR _index$[ebp], eax

; 8204 : 		}

  0007a	eb 28		 jmp	 SHORT $LN5@gObjGiveIt
$LN4@gObjGiveIt:

; 8205 : 		else
; 8206 : 		{		
; 8207 : 			type = rand()%MAX_ITEM_TYPE;

  0007c	e8 00 00 00 00	 call	 _rand
  00081	25 0f 00 00 80	 and	 eax, -2147483633	; 8000000fH
  00086	79 05		 jns	 SHORT $LN50@gObjGiveIt
  00088	48		 dec	 eax
  00089	83 c8 f0	 or	 eax, -16		; fffffff0H
  0008c	40		 inc	 eax
$LN50@gObjGiveIt:
  0008d	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax

; 8208 : 			index = rand()%MAX_ITEM_INDEX;

  00090	e8 00 00 00 00	 call	 _rand
  00095	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  0009a	79 05		 jns	 SHORT $LN51@gObjGiveIt
  0009c	48		 dec	 eax
  0009d	83 c8 e0	 or	 eax, -32		; ffffffe0H
  000a0	40		 inc	 eax
$LN51@gObjGiveIt:
  000a1	89 45 ec	 mov	 DWORD PTR _index$[ebp], eax
$LN5@gObjGiveIt:

; 8209 : 		}
; 8210 : 
; 8211 : 		/*
; 8212 : 		if( (type == 14) && ((index == 13)||(index == 14)) || 
; 8213 : 			(type == 12) && (index == 15) )
; 8214 : 		{	//   
; 8215 : 			continue;
; 8216 : 		}
; 8217 : 		*/
; 8218 : 
; 8219 : 		// type : 13, 14, 12  ..
; 8220 : 		if( 
; 8221 : 				(	(type==13) && (index<8)	) || 
; 8222 : 
; 8223 : 				(	(type == 14) && ((index == 9)	|| 
; 8224 : 					(index == 10) || (index == 13)	|| 
; 8225 : 					(index == 14) || (index == 16)	|| 
; 8226 : 					(index == 17) || (index == 18))	) ||

  000a4	83 7d f0 0d	 cmp	 DWORD PTR _type$[ebp], 13 ; 0000000dH
  000a8	75 06		 jne	 SHORT $LN9@gObjGiveIt
  000aa	83 7d ec 08	 cmp	 DWORD PTR _index$[ebp], 8
  000ae	7c 44		 jl	 SHORT $LN8@gObjGiveIt
$LN9@gObjGiveIt:
  000b0	83 7d f0 0e	 cmp	 DWORD PTR _type$[ebp], 14 ; 0000000eH
  000b4	75 2a		 jne	 SHORT $LN10@gObjGiveIt
  000b6	83 7d ec 09	 cmp	 DWORD PTR _index$[ebp], 9
  000ba	74 38		 je	 SHORT $LN8@gObjGiveIt
  000bc	83 7d ec 0a	 cmp	 DWORD PTR _index$[ebp], 10 ; 0000000aH
  000c0	74 32		 je	 SHORT $LN8@gObjGiveIt
  000c2	83 7d ec 0d	 cmp	 DWORD PTR _index$[ebp], 13 ; 0000000dH
  000c6	74 2c		 je	 SHORT $LN8@gObjGiveIt
  000c8	83 7d ec 0e	 cmp	 DWORD PTR _index$[ebp], 14 ; 0000000eH
  000cc	74 26		 je	 SHORT $LN8@gObjGiveIt
  000ce	83 7d ec 10	 cmp	 DWORD PTR _index$[ebp], 16 ; 00000010H
  000d2	74 20		 je	 SHORT $LN8@gObjGiveIt
  000d4	83 7d ec 11	 cmp	 DWORD PTR _index$[ebp], 17 ; 00000011H
  000d8	74 1a		 je	 SHORT $LN8@gObjGiveIt
  000da	83 7d ec 12	 cmp	 DWORD PTR _index$[ebp], 18 ; 00000012H
  000de	74 14		 je	 SHORT $LN8@gObjGiveIt
$LN10@gObjGiveIt:
  000e0	83 7d f0 0c	 cmp	 DWORD PTR _type$[ebp], 12 ; 0000000cH
  000e4	0f 85 80 01 00
	00		 jne	 $LN6@gObjGiveIt
  000ea	83 7d ec 0f	 cmp	 DWORD PTR _index$[ebp], 15 ; 0000000fH
  000ee	0f 85 76 01 00
	00		 jne	 $LN6@gObjGiveIt
$LN8@gObjGiveIt:

; 8227 : 
; 8228 : 				(	(type==12) && (index==15) ) 
; 8229 : 			)
; 8230 : 		{
; 8231 : 			int perc = rand()%8;

  000f4	e8 00 00 00 00	 call	 _rand
  000f9	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  000fe	79 05		 jns	 SHORT $LN52@gObjGiveIt
  00100	48		 dec	 eax
  00101	83 c8 f8	 or	 eax, -8			; fffffff8H
  00104	40		 inc	 eax
$LN52@gObjGiveIt:
  00105	89 45 e8	 mov	 DWORD PTR _perc$3[ebp], eax

; 8232 : 			BOOL bCheckDevil = FALSE;

  00108	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bCheckDevil$2[ebp], 0

; 8233 : 
; 8234 : 			if( type==12 && index==15 )

  0010f	83 7d f0 0c	 cmp	 DWORD PTR _type$[ebp], 12 ; 0000000cH
  00113	75 1a		 jne	 SHORT $LN11@gObjGiveIt
  00115	83 7d ec 0f	 cmp	 DWORD PTR _index$[ebp], 15 ; 0000000fH
  00119	75 14		 jne	 SHORT $LN11@gObjGiveIt

; 8235 : 			{
; 8236 : 				perc = rand()%4;

  0011b	e8 00 00 00 00	 call	 _rand
  00120	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00125	79 05		 jns	 SHORT $LN53@gObjGiveIt
  00127	48		 dec	 eax
  00128	83 c8 fc	 or	 eax, -4			; fffffffcH
  0012b	40		 inc	 eax
$LN53@gObjGiveIt:
  0012c	89 45 e8	 mov	 DWORD PTR _perc$3[ebp], eax
$LN11@gObjGiveIt:

; 8237 : 			}
; 8238 : 
; 8239 : 			//   ,   
; 8240 : #if !defined ( UPDATE_SEASON4_MARKET_CONDITIONS_BALANCE_20080828 ) && defined( DEVILSQARE_COMBINE_ITEM_DROP_20090114 )
; 8241 : 			if( type==14 && index==17 )
; 8242 : 			{	//  
; 8243 : 				if (gEyesOfDevilSquareDropRate <= 0)
; 8244 : 					gEyesOfDevilSquareDropRate = 1;
; 8245 : 				perc = rand()%gEyesOfDevilSquareDropRate;
; 8246 : 				bCheckDevil = TRUE;
; 8247 : 			}
; 8248 : 			
; 8249 : 			if( type==14 && index==18 )
; 8250 : 			{	//  
; 8251 : 				perc = rand()%gKeyOfDevilSquareDropRate;
; 8252 : 				bCheckDevil = TRUE;
; 8253 : 			}			
; 8254 : #endif	// UPDATE_SEASON4_MARKET_CONDITIONS_BALANCE_20080828
; 8255 : 
; 8256 : 			if( perc ==0 )

  0012f	83 7d e8 00	 cmp	 DWORD PTR _perc$3[ebp], 0
  00133	0f 85 2c 01 00
	00		 jne	 $LN12@gObjGiveIt

; 8257 : 			{
; 8258 : 				if( bCheckDevil == TRUE )

  00139	83 7d e4 01	 cmp	 DWORD PTR _bCheckDevil$2[ebp], 1
  0013d	0f 85 c8 00 00
	00		 jne	 $LN13@gObjGiveIt

; 8259 : 				{	//      
; 8260 : 					int devilitemlevel = 0;

  00143	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _devilitemlevel$1[ebp], 0

; 8261 : 
; 8262 : #ifndef UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123	// 7  gEventMonsterItemDrop()  
; 8263 : #ifdef ADD_DEVILSQURE_FOR_MASTER_LEVEL_20071010		// 7    
; 8264 : 					if( lpObj->Level >= 90 )
; 8265 : 					{
; 8266 : 						if( rand() % 1000 < 10 )
; 8267 : 						{
; 8268 : 							devilitemlevel = 7;
; 8269 : 						}
; 8270 : 					}
; 8271 : 					else
; 8272 : #endif
; 8273 : #endif	// UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123
; 8274 : 					if( rand()%5 != 0 )

  0014a	e8 00 00 00 00	 call	 _rand
  0014f	99		 cdq
  00150	b9 05 00 00 00	 mov	 ecx, 5
  00155	f7 f9		 idiv	 ecx
  00157	85 d2		 test	 edx, edx
  00159	0f 84 aa 00 00
	00		 je	 $LN15@gObjGiveIt

; 8275 : 					{	// 0 
; 8276 : #ifdef DEVILSQUARE_EXTEND_20050221		// !!! .  ->     
; 8277 : 						if( lpObj->Level < 3)
; 8278 : 						{
; 8279 : 							devilitemlevel = 0;
; 8280 : 						}
; 8281 : 						else if( lpObj->Level < 36)
; 8282 : 						{
; 8283 : 							devilitemlevel = 1;
; 8284 : 						}
; 8285 : 						else if( lpObj->Level < 47)
; 8286 : 						{
; 8287 : 							devilitemlevel = 2;
; 8288 : 						}
; 8289 : 						else if( lpObj->Level < 60)
; 8290 : 						{
; 8291 : 							devilitemlevel = 3;
; 8292 : 						}
; 8293 : 						else if( lpObj->Level < 70)
; 8294 : 						{
; 8295 : 							devilitemlevel = 4;
; 8296 : 						}
; 8297 : 						else if( lpObj->Level < 80)
; 8298 : 						{
; 8299 : 							devilitemlevel = 5;
; 8300 : 						}
; 8301 : 						else
; 8302 : 						{
; 8303 : 							devilitemlevel = 6;
; 8304 : 						}
; 8305 : #else
; 8306 : 						if( lpObj->Level <= 15)

  0015f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00162	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00169	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  0016c	7f 09		 jg	 SHORT $LN16@gObjGiveIt

; 8307 : 						{
; 8308 : 							devilitemlevel = 0;

  0016e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _devilitemlevel$1[ebp], 0

; 8309 : 						}

  00175	eb 4f		 jmp	 SHORT $LN17@gObjGiveIt
$LN16@gObjGiveIt:

; 8310 : 						else if( lpObj->Level <= 40)

  00177	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017a	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00181	83 f9 28	 cmp	 ecx, 40			; 00000028H
  00184	7f 09		 jg	 SHORT $LN18@gObjGiveIt

; 8311 : 						{
; 8312 : 							devilitemlevel = 1;

  00186	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _devilitemlevel$1[ebp], 1

; 8313 : 						}

  0018d	eb 37		 jmp	 SHORT $LN17@gObjGiveIt
$LN18@gObjGiveIt:

; 8314 : 						else if( lpObj->Level <= 54)

  0018f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00192	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00199	83 f9 36	 cmp	 ecx, 54			; 00000036H
  0019c	7f 09		 jg	 SHORT $LN20@gObjGiveIt

; 8315 : 						{
; 8316 : 							devilitemlevel = 2;

  0019e	c7 45 e0 02 00
	00 00		 mov	 DWORD PTR _devilitemlevel$1[ebp], 2

; 8317 : 						}

  001a5	eb 1f		 jmp	 SHORT $LN17@gObjGiveIt
$LN20@gObjGiveIt:

; 8318 : 						else if( lpObj->Level <= 66)

  001a7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001aa	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  001b1	83 f9 42	 cmp	 ecx, 66			; 00000042H
  001b4	7f 09		 jg	 SHORT $LN22@gObjGiveIt

; 8319 : 						{
; 8320 : 							devilitemlevel = 3;

  001b6	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _devilitemlevel$1[ebp], 3

; 8321 : 						}

  001bd	eb 07		 jmp	 SHORT $LN17@gObjGiveIt
$LN22@gObjGiveIt:

; 8322 : 						else
; 8323 : 						{
; 8324 : 							devilitemlevel = 4;

  001bf	c7 45 e0 04 00
	00 00		 mov	 DWORD PTR _devilitemlevel$1[ebp], 4
$LN17@gObjGiveIt:

; 8325 : 						}
; 8326 : #endif
; 8327 : #ifndef UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123	// 7  gEventMonsterItemDrop()  
; 8328 : #ifdef ADD_DEVILSQURE_FOR_MASTER_LEVEL_20071010
; 8329 : 					}
; 8330 : #endif	
; 8331 : #endif	// UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123					
; 8332 : 
; 8333 : 						if( devilitemlevel != 0 )

  001c6	83 7d e0 00	 cmp	 DWORD PTR _devilitemlevel$1[ebp], 0
  001ca	74 3d		 je	 SHORT $LN15@gObjGiveIt

; 8334 : 						{	//  0      
; 8335 : 							if( gObjMonsterInventoryInsertItem(lpObj, type, index, devilitemlevel) != 0xFF )

  001cc	6a 00		 push	 0
  001ce	6a 00		 push	 0
  001d0	6a 00		 push	 0
  001d2	8b 45 e0	 mov	 eax, DWORD PTR _devilitemlevel$1[ebp]
  001d5	50		 push	 eax
  001d6	8b 4d ec	 mov	 ecx, DWORD PTR _index$[ebp]
  001d9	51		 push	 ecx
  001da	8b 55 f0	 mov	 edx, DWORD PTR _type$[ebp]
  001dd	52		 push	 edx
  001de	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e1	50		 push	 eax
  001e2	e8 00 00 00 00	 call	 ?gObjMonsterInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHHH@Z ; gObjMonsterInventoryInsertItem
  001e7	83 c4 1c	 add	 esp, 28			; 0000001cH
  001ea	0f b6 c8	 movzx	 ecx, al
  001ed	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  001f3	74 14		 je	 SHORT $LN15@gObjGiveIt

; 8336 : 							{
; 8337 : 								///*if( lpObj->Level >= 50 )
; 8338 : 								//{
; 8339 : 								//LogAdd("(%d)Devil Square Item (level:%d) : type:%d index:%d level:%d %s", lpObj->Class, lpObj->Level, type, index, devilitemlevel, lpObj->Name);
; 8340 : 								//}
; 8341 : 								//*/
; 8342 : 								incount++;								

  001f5	8b 45 f4	 mov	 eax, DWORD PTR _incount$[ebp]
  001f8	83 c0 01	 add	 eax, 1
  001fb	89 45 f4	 mov	 DWORD PTR _incount$[ebp], eax

; 8343 : 								if( incount > MAX_INVENTORY-1 ) break;

  001fe	83 7d f4 4b	 cmp	 DWORD PTR _incount$[ebp], 75 ; 0000004bH
  00202	7e 05		 jle	 SHORT $LN15@gObjGiveIt
  00204	e9 7c 01 00 00	 jmp	 $LN1@gObjGiveIt
$LN15@gObjGiveIt:

; 8344 : 							}
; 8345 : 						}
; 8346 : #ifdef UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123	// 7  gEventMonsterItemDrop()  
; 8347 : 					}
; 8348 : #endif	// UPDATE_MASTER_LEVEL_EVENTMAP_TICKET_METERIAL_DROPRATE_20080123
; 8349 : #ifdef ADD_DEVILSQURE_FOR_MASTER_LEVEL_20071010
; 8350 : 				//	}
; 8351 : #else
; 8352 : 				}
; 8353 : #endif
; 8354 : 				}	

  00209	eb 5a		 jmp	 SHORT $LN12@gObjGiveIt
$LN13@gObjGiveIt:

; 8355 : 				else
; 8356 : 				{
; 8357 : 					if( zzzItemLevel(type, index, lpObj->Level) == TRUE )

  0020b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0020e	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00215	51		 push	 ecx
  00216	8b 55 ec	 mov	 edx, DWORD PTR _index$[ebp]
  00219	52		 push	 edx
  0021a	8b 45 f0	 mov	 eax, DWORD PTR _type$[ebp]
  0021d	50		 push	 eax
  0021e	e8 00 00 00 00	 call	 ?zzzItemLevel@@YAHHHH@Z	; zzzItemLevel
  00223	83 c4 0c	 add	 esp, 12			; 0000000cH
  00226	83 f8 01	 cmp	 eax, 1
  00229	75 3a		 jne	 SHORT $LN12@gObjGiveIt

; 8358 : 					{
; 8359 : 						if( gObjMonsterInventoryInsertItem(lpObj, type, index, 0) != 0xFF )

  0022b	6a 00		 push	 0
  0022d	6a 00		 push	 0
  0022f	6a 00		 push	 0
  00231	6a 00		 push	 0
  00233	8b 45 ec	 mov	 eax, DWORD PTR _index$[ebp]
  00236	50		 push	 eax
  00237	8b 4d f0	 mov	 ecx, DWORD PTR _type$[ebp]
  0023a	51		 push	 ecx
  0023b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0023e	52		 push	 edx
  0023f	e8 00 00 00 00	 call	 ?gObjMonsterInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHHH@Z ; gObjMonsterInventoryInsertItem
  00244	83 c4 1c	 add	 esp, 28			; 0000001cH
  00247	0f b6 c0	 movzx	 eax, al
  0024a	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0024f	74 14		 je	 SHORT $LN12@gObjGiveIt

; 8360 : 						{
; 8361 : 							///*if( lpObj->Level >= 50 )
; 8362 : 							//{
; 8363 : 							//LogAdd("(%d)Item (level:%d) : type:%d index:%d level:%d %s", lpObj->Class, lpObj->Level, type, index, result, lpObj->Name);
; 8364 : 							//}
; 8365 : 							//*/
; 8366 : 							incount++;							

  00251	8b 45 f4	 mov	 eax, DWORD PTR _incount$[ebp]
  00254	83 c0 01	 add	 eax, 1
  00257	89 45 f4	 mov	 DWORD PTR _incount$[ebp], eax

; 8367 : 							if( incount > MAX_INVENTORY-1 ) break;

  0025a	83 7d f4 4b	 cmp	 DWORD PTR _incount$[ebp], 75 ; 0000004bH
  0025e	7e 05		 jle	 SHORT $LN12@gObjGiveIt
  00260	e9 20 01 00 00	 jmp	 $LN1@gObjGiveIt
$LN12@gObjGiveIt:

; 8368 : 						}
; 8369 : 					}
; 8370 : 				}
; 8371 : 			}
; 8372 : 		}

  00265	e9 16 01 00 00	 jmp	 $LN7@gObjGiveIt
$LN6@gObjGiveIt:

; 8373 : 		else
; 8374 : 		{
; 8375 : 			result = GetLevelItem(type, index, lpObj->Level);

  0026a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0026d	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00274	51		 push	 ecx
  00275	8b 55 ec	 mov	 edx, DWORD PTR _index$[ebp]
  00278	52		 push	 edx
  00279	8b 45 f0	 mov	 eax, DWORD PTR _type$[ebp]
  0027c	50		 push	 eax
  0027d	e8 00 00 00 00	 call	 ?GetLevelItem@@YAHHHH@Z	; GetLevelItem
  00282	83 c4 0c	 add	 esp, 12			; 0000000cH
  00285	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax

; 8376 : 			if( result >= 0  )

  00288	83 7d fc 00	 cmp	 DWORD PTR _result$[ebp], 0
  0028c	0f 8c ee 00 00
	00		 jl	 $LN7@gObjGiveIt

; 8377 : 			{
; 8378 : 				if( (type == 13 && index == 10) || 

  00292	83 7d f0 0d	 cmp	 DWORD PTR _type$[ebp], 13 ; 0000000dH
  00296	75 06		 jne	 SHORT $LN34@gObjGiveIt
  00298	83 7d ec 0a	 cmp	 DWORD PTR _index$[ebp], 10 ; 0000000aH
  0029c	74 0c		 je	 SHORT $LN33@gObjGiveIt
$LN34@gObjGiveIt:
  0029e	83 7d f0 0c	 cmp	 DWORD PTR _type$[ebp], 12 ; 0000000cH
  002a2	75 48		 jne	 SHORT $LN31@gObjGiveIt
  002a4	83 7d ec 0b	 cmp	 DWORD PTR _index$[ebp], 11 ; 0000000bH
  002a8	75 42		 jne	 SHORT $LN31@gObjGiveIt
$LN33@gObjGiveIt:

; 8379 : 					(type == 12 && index == 11) )
; 8380 : 				{
; 8381 : 					if( gObjMonsterInventoryInsertItem(lpObj, type, index, result) != 0xFF )

  002aa	6a 00		 push	 0
  002ac	6a 00		 push	 0
  002ae	6a 00		 push	 0
  002b0	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
  002b3	50		 push	 eax
  002b4	8b 4d ec	 mov	 ecx, DWORD PTR _index$[ebp]
  002b7	51		 push	 ecx
  002b8	8b 55 f0	 mov	 edx, DWORD PTR _type$[ebp]
  002bb	52		 push	 edx
  002bc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002bf	50		 push	 eax
  002c0	e8 00 00 00 00	 call	 ?gObjMonsterInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHHH@Z ; gObjMonsterInventoryInsertItem
  002c5	83 c4 1c	 add	 esp, 28			; 0000001cH
  002c8	0f b6 c8	 movzx	 ecx, al
  002cb	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  002d1	74 14		 je	 SHORT $LN35@gObjGiveIt

; 8382 : 					{
; 8383 : 						//if( lpObj->Level >= 50 )
; 8384 : 						{
; 8385 : 						//LogAdd("(%d)Item (level:%d) : type:%d index:%d level:%d", lpObj->Class, lpObj->Level, type, index, result);
; 8386 : 						}
; 8387 : 						//*/
; 8388 : 						incount++;						

  002d3	8b 45 f4	 mov	 eax, DWORD PTR _incount$[ebp]
  002d6	83 c0 01	 add	 eax, 1
  002d9	89 45 f4	 mov	 DWORD PTR _incount$[ebp], eax

; 8389 : 						if( incount > MAX_INVENTORY-1 ) break;

  002dc	83 7d f4 4b	 cmp	 DWORD PTR _incount$[ebp], 75 ; 0000004bH
  002e0	7e 05		 jle	 SHORT $LN35@gObjGiveIt
  002e2	e9 9e 00 00 00	 jmp	 $LN1@gObjGiveIt
$LN35@gObjGiveIt:

; 8390 : 					}
; 8391 : 				}

  002e7	e9 94 00 00 00	 jmp	 $LN7@gObjGiveIt
$LN31@gObjGiveIt:

; 8392 : 				else if( result <= maxlevel )

  002ec	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
  002ef	3b 45 0c	 cmp	 eax, DWORD PTR _maxlevel$[ebp]
  002f2	0f 8f 88 00 00
	00		 jg	 $LN7@gObjGiveIt

; 8393 : 				{
; 8394 : 					if( type == 12)

  002f8	83 7d f0 0c	 cmp	 DWORD PTR _type$[ebp], 12 ; 0000000cH
  002fc	75 0d		 jne	 SHORT $LN38@gObjGiveIt

; 8395 : 					{
; 8396 : 						if( index != 11 ) result = 0;

  002fe	83 7d ec 0b	 cmp	 DWORD PTR _index$[ebp], 11 ; 0000000bH
  00302	74 07		 je	 SHORT $LN38@gObjGiveIt
  00304	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0
$LN38@gObjGiveIt:

; 8397 : 					}
; 8398 : 					if( type == 12 && index == 11 )

  0030b	83 7d f0 0c	 cmp	 DWORD PTR _type$[ebp], 12 ; 0000000cH
  0030f	75 08		 jne	 SHORT $LN40@gObjGiveIt
  00311	83 7d ec 0b	 cmp	 DWORD PTR _index$[ebp], 11 ; 0000000bH
  00315	75 02		 jne	 SHORT $LN40@gObjGiveIt

; 8399 : 					{
; 8400 : 
; 8401 : 					}

  00317	eb 0e		 jmp	 SHORT $LN41@gObjGiveIt
$LN40@gObjGiveIt:

; 8402 : 					else if( result > maxlevel ) result = maxlevel;

  00319	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
  0031c	3b 45 0c	 cmp	 eax, DWORD PTR _maxlevel$[ebp]
  0031f	7e 06		 jle	 SHORT $LN41@gObjGiveIt
  00321	8b 45 0c	 mov	 eax, DWORD PTR _maxlevel$[ebp]
  00324	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax
$LN41@gObjGiveIt:

; 8403 : 
; 8404 : 					if( (type == 4 && index == 7) || (type == 4 && index == 15) )	// ,  

  00327	83 7d f0 04	 cmp	 DWORD PTR _type$[ebp], 4
  0032b	75 06		 jne	 SHORT $LN45@gObjGiveIt
  0032d	83 7d ec 07	 cmp	 DWORD PTR _index$[ebp], 7
  00331	74 0c		 je	 SHORT $LN44@gObjGiveIt
$LN45@gObjGiveIt:
  00333	83 7d f0 04	 cmp	 DWORD PTR _type$[ebp], 4
  00337	75 0d		 jne	 SHORT $LN43@gObjGiveIt
  00339	83 7d ec 0f	 cmp	 DWORD PTR _index$[ebp], 15 ; 0000000fH
  0033d	75 07		 jne	 SHORT $LN43@gObjGiveIt
$LN44@gObjGiveIt:

; 8405 : 					{
; 8406 : 						result = 0;

  0033f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _result$[ebp], 0
$LN43@gObjGiveIt:

; 8407 : 					}
; 8408 : 					
; 8409 : 					if( gObjMonsterInventoryInsertItem(lpObj, type, index, result) != 0xFF )

  00346	6a 00		 push	 0
  00348	6a 00		 push	 0
  0034a	6a 00		 push	 0
  0034c	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
  0034f	50		 push	 eax
  00350	8b 4d ec	 mov	 ecx, DWORD PTR _index$[ebp]
  00353	51		 push	 ecx
  00354	8b 55 f0	 mov	 edx, DWORD PTR _type$[ebp]
  00357	52		 push	 edx
  00358	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0035b	50		 push	 eax
  0035c	e8 00 00 00 00	 call	 ?gObjMonsterInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHHH@Z ; gObjMonsterInventoryInsertItem
  00361	83 c4 1c	 add	 esp, 28			; 0000001cH
  00364	0f b6 c8	 movzx	 ecx, al
  00367	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0036d	74 11		 je	 SHORT $LN7@gObjGiveIt

; 8410 : 					{
; 8411 : 						//if( lpObj->Level >= 50 )
; 8412 : 						{
; 8413 : 						//LogAdd("(%d)Item (level:%d) : type:%d index:%d level:%d", lpObj->Class, lpObj->Level, type, index, result);
; 8414 : 						}
; 8415 : 						//*/
; 8416 : 						incount++;						

  0036f	8b 45 f4	 mov	 eax, DWORD PTR _incount$[ebp]
  00372	83 c0 01	 add	 eax, 1
  00375	89 45 f4	 mov	 DWORD PTR _incount$[ebp], eax

; 8417 : 						if( incount > MAX_INVENTORY-1 ) break;

  00378	83 7d f4 4b	 cmp	 DWORD PTR _incount$[ebp], 75 ; 0000004bH
  0037c	7e 02		 jle	 SHORT $LN7@gObjGiveIt
  0037e	eb 05		 jmp	 SHORT $LN1@gObjGiveIt
$LN7@gObjGiveIt:

; 8418 : 					}
; 8419 : 				}
; 8420 : 			}
; 8421 : 		}
; 8422 : 	}

  00380	e9 b0 fc ff ff	 jmp	 $LN2@gObjGiveIt
$LN1@gObjGiveIt:

; 8423 : }

  00385	5f		 pop	 edi
  00386	5e		 pop	 esi
  00387	5b		 pop	 ebx
  00388	8b e5		 mov	 esp, ebp
  0038a	5d		 pop	 ebp
  0038b	c3		 ret	 0
?gObjGiveItemSearch@@YAXPAVOBJECTSTRUCT@@H@Z ENDP	; gObjGiveItemSearch
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
_item_type$ = -196					; size = 4
_blank$ = -189						; size = 1
_iheight$ = -188					; size = 4
_iwidth$ = -184						; size = 4
_h$ = -180						; size = 4
_w$ = -176						; size = 4
_item$ = -172						; size = 168
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_type$ = 12						; size = 4
_index$ = 16						; size = 4
_level$ = 20						; size = 4
?gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHH@Z PROC ; gObjInventoryInsertItem, COMDAT

; 15457: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 15458: 	CItem item;

  00016	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 15459: 	int w, h;
; 15460: 	int iwidth, iheight;
; 15461: 	BYTE blank=0;

  00021	c6 85 43 ff ff
	ff 00		 mov	 BYTE PTR _blank$[ebp], 0

; 15462: 	int item_type;
; 15463: 
; 15464: 	//item_type = type<<4;
; 15465: 	//item_type += index;
; 15466: 	item_type    = ItemGetNumberMake(type, index );

  00028	8b 45 10	 mov	 eax, DWORD PTR _index$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _type$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00035	83 c4 08	 add	 esp, 8
  00038	89 85 3c ff ff
	ff		 mov	 DWORD PTR _item_type$[ebp], eax

; 15467: 
; 15468: 	item.m_Level = level;

  0003e	66 8b 45 14	 mov	 ax, WORD PTR _level$[ebp]
  00042	66 89 85 5c ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], ax

; 15469: 	item.Convert( item_type, 0);	

  00049	6a 01		 push	 1
  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	6a 00		 push	 0
  00051	6a 00		 push	 0
  00053	6a 00		 push	 0
  00055	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _item_type$[ebp]
  0005b	50		 push	 eax
  0005c	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  00062	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 15470: 	
; 15471: 	if( item.GetSize(iwidth, iheight) == FALSE )

  00067	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _iheight$[ebp]
  0006d	50		 push	 eax
  0006e	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00074	51		 push	 ecx
  00075	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0007b	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  00080	85 c0		 test	 eax, eax
  00082	75 2f		 jne	 SHORT $LN8@gObjInvent

; 15472: 	{
; 15473: 		LogAdd(lMsg.Get(527), __FILE__, __LINE__);

  00084	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHH@Z@4JA
  00089	83 c0 10	 add	 eax, 16			; 00000010H
  0008c	50		 push	 eax
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00092	68 0f 02 00 00	 push	 527			; 0000020fH
  00097	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000a2	50		 push	 eax
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15474: 		return 0xFF;

  000ac	0c ff		 or	 al, 255			; 000000ffH
  000ae	e9 60 01 00 00	 jmp	 $LN1@gObjInvent
$LN8@gObjInvent:

; 15475: 	}
; 15476: 
; 15477: 	for( h=0; h<8; h++)		

  000b3	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _h$[ebp], 0
  000bd	eb 0f		 jmp	 SHORT $LN4@gObjInvent
$LN2@gObjInvent:
  000bf	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _h$[ebp]
  000c5	83 c0 01	 add	 eax, 1
  000c8	89 85 4c ff ff
	ff		 mov	 DWORD PTR _h$[ebp], eax
$LN4@gObjInvent:
  000ce	83 bd 4c ff ff
	ff 08		 cmp	 DWORD PTR _h$[ebp], 8
  000d5	0f 8d 36 01 00
	00		 jge	 $GOTO_EndFunc$14

; 15478: 	{		
; 15479: 		for( w=0; w<8; w++)

  000db	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _w$[ebp], 0
  000e5	eb 0f		 jmp	 SHORT $LN7@gObjInvent
$LN5@gObjInvent:
  000e7	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _w$[ebp]
  000ed	83 c0 01	 add	 eax, 1
  000f0	89 85 50 ff ff
	ff		 mov	 DWORD PTR _w$[ebp], eax
$LN7@gObjInvent:
  000f6	83 bd 50 ff ff
	ff 08		 cmp	 DWORD PTR _w$[ebp], 8
  000fd	0f 8d 09 01 00
	00		 jge	 $LN6@gObjInvent

; 15480: 		{
; 15481: 			//  
; 15482: 			if( *(lpObj->pInventoryMap+(h*8)+w) == 0xFF )

  00103	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00106	8b 88 60 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3168]
  0010c	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _h$[ebp]
  00112	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00115	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _w$[ebp]
  0011b	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  0011f	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00125	0f 85 dc 00 00
	00		 jne	 $LN9@gObjInvent

; 15483: 			{				
; 15484: 				blank = gObjInventoryRectCheck(lpObj->m_Index, w, h, iwidth,iheight);

  0012b	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _iheight$[ebp]
  00131	50		 push	 eax
  00132	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _iwidth$[ebp]
  00138	51		 push	 ecx
  00139	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _h$[ebp]
  0013f	52		 push	 edx
  00140	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _w$[ebp]
  00146	50		 push	 eax
  00147	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0014a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014c	52		 push	 edx
  0014d	e8 00 00 00 00	 call	 ?gObjInventoryRectCheck@@YAEHHHHH@Z ; gObjInventoryRectCheck
  00152	83 c4 14	 add	 esp, 20			; 00000014H
  00155	88 85 43 ff ff
	ff		 mov	 BYTE PTR _blank$[ebp], al

; 15485: 				// 
; 15486: 				if( blank == 0xFE ) goto GOTO_EndFunc;

  0015b	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _blank$[ebp]
  00162	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  00167	75 0a		 jne	 SHORT $LN10@gObjInvent
  00169	e9 a3 00 00 00	 jmp	 $GOTO_EndFunc$14
  0016e	e9 9e 00 00 00	 jmp	 $GOTO_EndFunc$14
$LN10@gObjInvent:

; 15487: 				if( blank != 0xFF )	{	//   

  00173	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _blank$[ebp]
  0017a	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0017f	0f 84 82 00 00
	00		 je	 $LN9@gObjInvent

; 15488: 					lpObj->pInventory[blank] = item;

  00185	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _blank$[ebp]
  0018c	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  00192	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00195	8b ba 5c 0c 00
	00		 mov	 edi, DWORD PTR [edx+3164]
  0019b	03 f9		 add	 edi, ecx
  0019d	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  001a2	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  001a8	f3 a5		 rep movsd

; 15489: 					lpObj->pInventory[blank].m_Number = gGetItemNumber();

  001aa	e8 00 00 00 00	 call	 ?gGetItemNumber@@YAKXZ	; gGetItemNumber
  001af	0f b6 8d 43 ff
	ff ff		 movzx	 ecx, BYTE PTR _blank$[ebp]
  001b6	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  001bc	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001bf	8b 89 5c 0c 00
	00		 mov	 ecx, DWORD PTR [ecx+3164]
  001c5	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 15490: 					gPlusItemNumber();

  001c8	e8 00 00 00 00	 call	 ?gPlusItemNumber@@YAXXZ	; gPlusItemNumber

; 15491: 					gObjInventoryItemSet(lpObj->m_Index, blank, (BYTE)lpObj->pInventory[blank].m_Type);

  001cd	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _blank$[ebp]
  001d4	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  001da	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001dd	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  001e3	0f b6 4c 08 06	 movzx	 ecx, BYTE PTR [eax+ecx+6]
  001e8	51		 push	 ecx
  001e9	0f b6 95 43 ff
	ff ff		 movzx	 edx, BYTE PTR _blank$[ebp]
  001f0	52		 push	 edx
  001f1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f6	51		 push	 ecx
  001f7	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  001fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15492: 					return blank;

  001ff	8a 85 43 ff ff
	ff		 mov	 al, BYTE PTR _blank$[ebp]
  00205	eb 0c		 jmp	 SHORT $LN1@gObjInvent
$LN9@gObjInvent:

; 15493: 				}			
; 15494: 			}
; 15495: 		}

  00207	e9 db fe ff ff	 jmp	 $LN5@gObjInvent
$LN6@gObjInvent:

; 15496: 	}

  0020c	e9 ae fe ff ff	 jmp	 $LN2@gObjInvent
$GOTO_EndFunc$14:

; 15497: 
; 15498: GOTO_EndFunc :
; 15499: 	return 0xFF;

  00211	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjInvent:

; 15500: }

  00213	5f		 pop	 edi
  00214	5e		 pop	 esi
  00215	5b		 pop	 ebx
  00216	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00219	33 cd		 xor	 ecx, ebp
  0021b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00220	8b e5		 mov	 esp, ebp
  00222	5d		 pop	 ebp
  00223	c3		 ret	 0
?gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHH@Z ENDP ; gObjInventoryInsertItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjRefillProcess@@YAXHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_lpObj$ = 12						; size = 4
?gObjRefillProcess@@YAXHPAVOBJECTSTRUCT@@@Z PROC	; gObjRefillProcess, COMDAT

; 1011 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1012 : 	/*if( GetTickCount()-lpObj->LifeRefillTimer > 10000 )
; 1013 : 	{
; 1014 : 		if( (lpObj->Life+2) <= lpObj->MaxLife )
; 1015 : 		{
; 1016 : 			lpObj->Life += 2;
; 1017 : 			GCReFillSend(aIndex, lpObj->Life, 0xff);
; 1018 : 			lpObj->LifeRefillTimer = GetTickCount();
; 1019 : 		}
; 1020 : 	}*/
; 1021 : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?gObjRefillProcess@@YAXHPAVOBJECTSTRUCT@@@Z ENDP	; gObjRefillProcess
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?ViewportAdd2@@YAHHHH@Z
_TEXT	SEGMENT
_n$1 = -24						; size = 4
_lpAddObj$ = -20					; size = 4
_MVL$ = -16						; size = 4
_lpObj$ = -12						; size = 4
_count$ = -8						; size = 4
_blank$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_aAddIndex$ = 12					; size = 4
_aType$ = 16						; size = 4
?ViewportAdd2@@YAHHHH@Z PROC				; ViewportAdd2, COMDAT

; 20800: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 20801: 	int blank = -1;

  00009	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _blank$[ebp], -1

; 20802: 	int count =  0;

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 20803: 
; 20804: 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00017	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00024	89 45 f4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 20805: 
; 20806: 	int MVL = MAXVIEWPORTOBJECT;

  00027	c7 45 f0 4b 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 75 ; 0000004bH

; 20807: 	if( lpObj->Type == OBJTYPE_MONSTER ) MVL = MAX_MONVIEWPORTOBJECT;

  0002e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00031	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00035	83 f9 02	 cmp	 ecx, 2
  00038	75 07		 jne	 SHORT $LN5@ViewportAd
  0003a	c7 45 f0 14 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 20 ; 00000014H
$LN5@ViewportAd:

; 20808: 
; 20809: 	LPOBJECTSTRUCT lpAddObj = &gObj[aAddIndex];

  00041	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aAddIndex$[ebp], 7072
  00048	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004e	89 45 ec	 mov	 DWORD PTR _lpAddObj$[ebp], eax

; 20810: 
; 20811: 	if( (lpObj->m_stateEngagePVP == PVP_USER_PLAYING && lpAddObj->m_stateEngagePVP != PVP_USER_PLAYING) || (lpAddObj->m_stateEngagePVP == PVP_USER_PLAYING && lpObj->m_stateEngagePVP != PVP_USER_PLAYING) )

  00051	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00054	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  0005b	75 0c		 jne	 SHORT $LN8@ViewportAd
  0005d	8b 45 ec	 mov	 eax, DWORD PTR _lpAddObj$[ebp]
  00060	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  00067	75 18		 jne	 SHORT $LN7@ViewportAd
$LN8@ViewportAd:
  00069	8b 45 ec	 mov	 eax, DWORD PTR _lpAddObj$[ebp]
  0006c	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  00073	75 14		 jne	 SHORT $LN6@ViewportAd
  00075	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00078	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  0007f	74 08		 je	 SHORT $LN6@ViewportAd
$LN7@ViewportAd:

; 20812: 		return -1;

  00081	83 c8 ff	 or	 eax, -1
  00084	e9 c0 00 00 00	 jmp	 $LN1@ViewportAd
$LN6@ViewportAd:

; 20813: 
; 20814: // 1.      .
; 20815: // 2.    .
; 20816: // 3.    .
; 20817: 	for( int n=0; n<MVL; n++)

  00089	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00090	eb 09		 jmp	 SHORT $LN4@ViewportAd
$LN2@ViewportAd:
  00092	8b 45 e8	 mov	 eax, DWORD PTR _n$1[ebp]
  00095	83 c0 01	 add	 eax, 1
  00098	89 45 e8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@ViewportAd:
  0009b	8b 45 e8	 mov	 eax, DWORD PTR _n$1[ebp]
  0009e	3b 45 f0	 cmp	 eax, DWORD PTR _MVL$[ebp]
  000a1	7d 50		 jge	 SHORT $LN3@ViewportAd

; 20818: 	{
; 20819: 		if( lpObj->VpPlayer2[n].state )

  000a3	6b 45 e8 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000a7	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000aa	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  000b2	85 d2		 test	 edx, edx
  000b4	74 2f		 je	 SHORT $LN9@ViewportAd

; 20820: 		{ //  
; 20821: 			if( lpObj->VpPlayer2[n].number == aAddIndex &&

  000b6	6b 45 e8 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000ba	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000bd	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  000c5	3b 55 0c	 cmp	 edx, DWORD PTR _aAddIndex$[ebp]
  000c8	75 19		 jne	 SHORT $LN11@ViewportAd
  000ca	6b 45 e8 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000ce	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000d1	0f b6 94 01 ec
	06 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1772]
  000d9	3b 55 10	 cmp	 edx, DWORD PTR _aType$[ebp]
  000dc	75 05		 jne	 SHORT $LN11@ViewportAd

; 20822: 				lpObj->VpPlayer2[n].type == aType	) 
; 20823: 			{   // 
; 20824: 				return -1;

  000de	83 c8 ff	 or	 eax, -1
  000e1	eb 66		 jmp	 SHORT $LN1@ViewportAd
$LN11@ViewportAd:

; 20825: 			}
; 20826: 		} 

  000e3	eb 0c		 jmp	 SHORT $LN10@ViewportAd
$LN9@ViewportAd:

; 20827: 		else 
; 20828: 		{
; 20829: 			if( blank < 0 )	blank = n;

  000e5	83 7d fc 00	 cmp	 DWORD PTR _blank$[ebp], 0
  000e9	7d 06		 jge	 SHORT $LN10@ViewportAd
  000eb	8b 45 e8	 mov	 eax, DWORD PTR _n$1[ebp]
  000ee	89 45 fc	 mov	 DWORD PTR _blank$[ebp], eax
$LN10@ViewportAd:

; 20830: //			break;		//	 break  . (    )
; 20831: 		} 
; 20832: 	}

  000f1	eb 9f		 jmp	 SHORT $LN2@ViewportAd
$LN3@ViewportAd:

; 20833: 	if( blank < 0 ) 

  000f3	83 7d fc 00	 cmp	 DWORD PTR _blank$[ebp], 0
  000f7	7d 05		 jge	 SHORT $LN13@ViewportAd

; 20834: 	{
; 20835: 		//LogAdd("(%d)(%s)2  . MAX:%d [%s][%d]", aIndex, gObj[aIndex].Name, MVL, __FILE__, __LINE__);
; 20836: 		return -1;

  000f9	83 c8 ff	 or	 eax, -1
  000fc	eb 4b		 jmp	 SHORT $LN1@ViewportAd
$LN13@ViewportAd:

; 20837: 	}
; 20838: 
; 20839: 	lpObj->VpPlayer2[blank].state  = STVP_CREATE;

  000fe	6b 45 fc 0c	 imul	 eax, DWORD PTR _blank$[ebp], 12
  00102	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00105	c6 84 01 e8 06
	00 00 01	 mov	 BYTE PTR [ecx+eax+1768], 1

; 20840: 	lpObj->VpPlayer2[blank].number = aAddIndex;

  0010d	6b 45 fc 0c	 imul	 eax, DWORD PTR _blank$[ebp], 12
  00111	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00114	66 8b 55 0c	 mov	 dx, WORD PTR _aAddIndex$[ebp]
  00118	66 89 94 01 ea
	06 00 00	 mov	 WORD PTR [ecx+eax+1770], dx

; 20841: 	lpObj->VpPlayer2[blank].type   = aType;

  00120	6b 45 fc 0c	 imul	 eax, DWORD PTR _blank$[ebp], 12
  00124	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00127	8a 55 10	 mov	 dl, BYTE PTR _aType$[ebp]
  0012a	88 94 01 ec 06
	00 00		 mov	 BYTE PTR [ecx+eax+1772], dl

; 20842: 	lpObj->VPCount2++;

  00131	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00134	8b 88 70 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2672]
  0013a	83 c1 01	 add	 ecx, 1
  0013d	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00140	89 8a 70 0a 00
	00		 mov	 DWORD PTR [edx+2672], ecx

; 20843: 	return blank;

  00146	8b 45 fc	 mov	 eax, DWORD PTR _blank$[ebp]
$LN1@ViewportAd:

; 20844: }

  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi
  0014b	5b		 pop	 ebx
  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c3		 ret	 0
?ViewportAdd2@@YAHHHH@Z ENDP				; ViewportAdd2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?ViewportAdd@@YAHHHH@Z
_TEXT	SEGMENT
_n$1 = -24						; size = 4
_lpAddObj$ = -20					; size = 4
_MVL$ = -16						; size = 4
_lpObj$ = -12						; size = 4
_count$ = -8						; size = 4
_blank$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_aAddIndex$ = 12					; size = 4
_aType$ = 16						; size = 4
?ViewportAdd@@YAHHHH@Z PROC				; ViewportAdd, COMDAT

; 20727: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 20728: 	int blank = -1;

  00009	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _blank$[ebp], -1

; 20729: 	int count =  0;

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 20730: 
; 20731: 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00017	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00024	89 45 f4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 20732: 
; 20733: 	int MVL = MAXVIEWPORTOBJECT;

  00027	c7 45 f0 4b 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 75 ; 0000004bH

; 20734: 	if( lpObj->Type == OBJTYPE_MONSTER ) MVL = MAX_MONVIEWPORTOBJECT;

  0002e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00031	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00035	83 f9 02	 cmp	 ecx, 2
  00038	75 07		 jne	 SHORT $LN5@ViewportAd
  0003a	c7 45 f0 14 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 20 ; 00000014H
$LN5@ViewportAd:

; 20735: 
; 20736: 	LPOBJECTSTRUCT lpAddObj = &gObj[aAddIndex];

  00041	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aAddIndex$[ebp], 7072
  00048	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004e	89 45 ec	 mov	 DWORD PTR _lpAddObj$[ebp], eax

; 20737: 
; 20738: 	if( (lpObj->m_stateEngagePVP == PVP_USER_PLAYING && lpAddObj->m_stateEngagePVP != PVP_USER_PLAYING) || (lpAddObj->m_stateEngagePVP == PVP_USER_PLAYING && lpObj->m_stateEngagePVP != PVP_USER_PLAYING) )

  00051	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00054	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  0005b	75 0c		 jne	 SHORT $LN8@ViewportAd
  0005d	8b 45 ec	 mov	 eax, DWORD PTR _lpAddObj$[ebp]
  00060	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  00067	75 18		 jne	 SHORT $LN7@ViewportAd
$LN8@ViewportAd:
  00069	8b 45 ec	 mov	 eax, DWORD PTR _lpAddObj$[ebp]
  0006c	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  00073	75 14		 jne	 SHORT $LN6@ViewportAd
  00075	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00078	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  0007f	74 08		 je	 SHORT $LN6@ViewportAd
$LN7@ViewportAd:

; 20739: 		return -1;

  00081	83 c8 ff	 or	 eax, -1
  00084	e9 e1 00 00 00	 jmp	 $LN1@ViewportAd
$LN6@ViewportAd:

; 20740: 
; 20741: // 1.      .
; 20742: // 2.    .
; 20743: // 3.    .
; 20744: 	for( int n=0; n<MVL; n++)

  00089	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00090	eb 09		 jmp	 SHORT $LN4@ViewportAd
$LN2@ViewportAd:
  00092	8b 45 e8	 mov	 eax, DWORD PTR _n$1[ebp]
  00095	83 c0 01	 add	 eax, 1
  00098	89 45 e8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@ViewportAd:
  0009b	8b 45 e8	 mov	 eax, DWORD PTR _n$1[ebp]
  0009e	3b 45 f0	 cmp	 eax, DWORD PTR _MVL$[ebp]
  000a1	7d 53		 jge	 SHORT $LN3@ViewportAd

; 20745: 	{
; 20746: 		if( lpObj->VpPlayer[n].state )

  000a3	6b 45 e8 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000a7	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000aa	0f be 94 01 64
	03 00 00	 movsx	 edx, BYTE PTR [ecx+eax+868]
  000b2	85 d2		 test	 edx, edx
  000b4	74 32		 je	 SHORT $LN9@ViewportAd

; 20747: 		{ //  
; 20748: 			if( lpObj->VpPlayer[n].number == aAddIndex &&

  000b6	6b 45 e8 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000ba	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000bd	0f bf 94 01 66
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax+870]
  000c5	3b 55 0c	 cmp	 edx, DWORD PTR _aAddIndex$[ebp]
  000c8	75 1c		 jne	 SHORT $LN11@ViewportAd
  000ca	6b 45 e8 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  000ce	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000d1	0f b6 94 01 68
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+872]
  000d9	3b 55 10	 cmp	 edx, DWORD PTR _aType$[ebp]
  000dc	75 08		 jne	 SHORT $LN11@ViewportAd

; 20749: 				lpObj->VpPlayer[n].type == aType	) 
; 20750: 			{   // 
; 20751: 				//if( lpObj->VpPlayer[n].state == 1 ) lpObj->VpPlayer[n].state = 2;
; 20752: 				return -1;

  000de	83 c8 ff	 or	 eax, -1
  000e1	e9 84 00 00 00	 jmp	 $LN1@ViewportAd
$LN11@ViewportAd:

; 20753: 			}
; 20754: 		} 

  000e6	eb 0c		 jmp	 SHORT $LN10@ViewportAd
$LN9@ViewportAd:

; 20755: 		else 
; 20756: 		{
; 20757: 			if( blank < 0 )	blank = n;

  000e8	83 7d fc 00	 cmp	 DWORD PTR _blank$[ebp], 0
  000ec	7d 06		 jge	 SHORT $LN10@ViewportAd
  000ee	8b 45 e8	 mov	 eax, DWORD PTR _n$1[ebp]
  000f1	89 45 fc	 mov	 DWORD PTR _blank$[ebp], eax
$LN10@ViewportAd:

; 20758: //			break;		//	 break  . (    )
; 20759: 		} 
; 20760: 	}

  000f4	eb 9c		 jmp	 SHORT $LN2@ViewportAd
$LN3@ViewportAd:

; 20761: 	if( blank < 0 ) 

  000f6	83 7d fc 00	 cmp	 DWORD PTR _blank$[ebp], 0
  000fa	7d 05		 jge	 SHORT $LN13@ViewportAd

; 20762: 	{
; 20763: 		//LogAdd("(%d)  . MAX:%d [%s][%d]", aIndex, MVL, __FILE__, __LINE__);
; 20764: 		return -1;

  000fc	83 c8 ff	 or	 eax, -1
  000ff	eb 69		 jmp	 SHORT $LN1@ViewportAd
$LN13@ViewportAd:

; 20765: 	}
; 20766: 	lpObj->VpPlayer[blank].state     = STVP_CREATE;

  00101	6b 45 fc 0c	 imul	 eax, DWORD PTR _blank$[ebp], 12
  00105	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00108	c6 84 01 64 03
	00 00 01	 mov	 BYTE PTR [ecx+eax+868], 1

; 20767: 	lpObj->VpPlayer[blank].number    = aAddIndex;

  00110	6b 45 fc 0c	 imul	 eax, DWORD PTR _blank$[ebp], 12
  00114	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00117	66 8b 55 0c	 mov	 dx, WORD PTR _aAddIndex$[ebp]
  0011b	66 89 94 01 66
	03 00 00	 mov	 WORD PTR [ecx+eax+870], dx

; 20768: 	lpObj->VpPlayer[blank].type      = aType;

  00123	6b 45 fc 0c	 imul	 eax, DWORD PTR _blank$[ebp], 12
  00127	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0012a	8a 55 10	 mov	 dl, BYTE PTR _aType$[ebp]
  0012d	88 94 01 68 03
	00 00		 mov	 BYTE PTR [ecx+eax+872], dl

; 20769: 	lpObj->VPCount++;

  00134	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00137	8b 88 6c 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2668]
  0013d	83 c1 01	 add	 ecx, 1
  00140	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00143	89 8a 6c 0a 00
	00		 mov	 DWORD PTR [edx+2668], ecx

; 20770: 
; 20771: 	//    ..
; 20772: 	if( aType != OBJTYPE_ITEM )

  00149	83 7d 10 05	 cmp	 DWORD PTR _aType$[ebp], 5
  0014d	74 18		 je	 SHORT $LN14@ViewportAd

; 20773: 	{
; 20774: 		//    .
; 20775: #ifndef MODIFY_MOVEMAP_RESET_VIEWPORT_BUGFIX_20060511
; 20776: 		ViewportAdd2( aAddIndex, aIndex, lpObj->Type );

  0014f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00152	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00156	51		 push	 ecx
  00157	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0015a	52		 push	 edx
  0015b	8b 45 0c	 mov	 eax, DWORD PTR _aAddIndex$[ebp]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 ?ViewportAdd2@@YAHHHH@Z	; ViewportAdd2
  00164	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@ViewportAd:

; 20777: #endif
; 20778: 	}
; 20779: 
; 20780: #ifdef ADD_NEW_MONSTER_SYSTEM_02_20050725
; 20781: 	if( (lpObj->Type==OBJTYPE_MONSTER || lpObj->Type==OBJTYPE_NPC)
; 20782: 		&& aType==OBJTYPE_CHARACTER
; 20783: 	  )
; 20784: 	{
; 20785: 		// Agro System
; 20786: 		if( lpObj->m_iCurrentAI )
; 20787: 		{
; 20788: 			lpObj->m_Agro.SetAgro( aAddIndex, 1000 );
; 20789: 		}
; 20790: 	}
; 20791: #endif
; 20792: 
; 20793: 	return blank;

  00167	8b 45 fc	 mov	 eax, DWORD PTR _blank$[ebp]
$LN1@ViewportAd:

; 20794: }

  0016a	5f		 pop	 edi
  0016b	5e		 pop	 esi
  0016c	5b		 pop	 ebx
  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c3		 ret	 0
?ViewportAdd@@YAHHHH@Z ENDP				; ViewportAdd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ??__Em_ObjBill@@YAXXZ
text$di	SEGMENT
??__Em_ObjBill@@YAXXZ PROC				; `dynamic initializer for 'm_ObjBill'', COMDAT

; 365  : BILL_CLASS	m_ObjBill[MAX_OBJECT];

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	68 00 00 00 00	 push	 OFFSET ??0BILL_CLASS@@QAE@XZ ; BILL_CLASS::BILL_CLASS
  0000e	68 e8 1c 00 00	 push	 7400			; 00001ce8H
  00013	6a 1c		 push	 28			; 0000001cH
  00015	68 00 00 00 00	 push	 OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  0001a	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??__Em_ObjBill@@YAXXZ ENDP				; `dynamic initializer for 'm_ObjBill''
text$di	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Fg_kStaticObject@@YAXXZ
text$yd	SEGMENT
??__Fg_kStaticObject@@YAXXZ PROC			; `dynamic atexit destructor for 'g_kStaticObject'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kStaticObject@@3VStaticObject@@A ; g_kStaticObject
  0000e	e8 00 00 00 00	 call	 ??1StaticObject@@UAE@XZ	; StaticObject::~StaticObject
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_kStaticObject@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_kStaticObject''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ??__Eg_kStaticObject@@YAXXZ
text$di	SEGMENT
??__Eg_kStaticObject@@YAXXZ PROC			; `dynamic initializer for 'g_kStaticObject'', COMDAT

; 344  : StaticObject g_kStaticObject;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_kStaticObject@@3VStaticObject@@A ; g_kStaticObject
  0000e	e8 00 00 00 00	 call	 ??0StaticObject@@QAE@XZ	; StaticObject::StaticObject
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_kStaticObject@@YAXXZ ; `dynamic atexit destructor for 'g_kStaticObject''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_kStaticObject@@YAXXZ ENDP			; `dynamic initializer for 'g_kStaticObject''
text$di	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GStaticObject@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GStaticObject@@UAEPAXI@Z PROC			; StaticObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1StaticObject@@UAE@XZ	; StaticObject::~StaticObject
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 04		 push	 4
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_GStaticObject@@UAEPAXI@Z ENDP			; StaticObject::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ??1StaticObject@@UAE@XZ
_TEXT	SEGMENT
tv69 = -76						; size = 4
$T1 = -72						; size = 4
_this$ = -4						; size = 4
??1StaticObject@@UAE@XZ PROC				; StaticObject::~StaticObject, COMDAT
; _this$ = ecx

; 339  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7StaticObject@@6B@

; 340  : 	delete []gAllocObj;

  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gAllocObj@@3PAVOBJECTSTRUCT@@A ; gAllocObj
  0001a	89 45 b8	 mov	 DWORD PTR $T1[ebp], eax
  0001d	83 7d b8 00	 cmp	 DWORD PTR $T1[ebp], 0
  00021	74 0f		 je	 SHORT $LN3@StaticObje
  00023	6a 03		 push	 3
  00025	8b 4d b8	 mov	 ecx, DWORD PTR $T1[ebp]
  00028	e8 00 00 00 00	 call	 ??_EOBJECTSTRUCT@@QAEPAXI@Z
  0002d	89 45 b4	 mov	 DWORD PTR tv69[ebp], eax
  00030	eb 07		 jmp	 SHORT $LN4@StaticObje
$LN3@StaticObje:
  00032	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@StaticObje:

; 341  : 	gAllocObj = NULL;

  00039	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gAllocObj@@3PAVOBJECTSTRUCT@@A, 0 ; gAllocObj

; 342  : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??1StaticObject@@UAE@XZ ENDP				; StaticObject::~StaticObject
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ??0StaticObject@@QAE@XZ
_TEXT	SEGMENT
tv80 = -92						; size = 4
$T2 = -88						; size = 4
$T3 = -84						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0StaticObject@@QAE@XZ PROC				; StaticObject::StaticObject, COMDAT
; _this$ = ecx

; 329  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0StaticObject@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7StaticObject@@6B@

; 330  : 	gAllocObj = new OBJECTSTRUCT[MAX_OBJECT + 1];

  00034	68 a4 a4 1e 03	 push	 52339876		; 031ea4a4H
  00039	e8 00 00 00 00	 call	 ??_UZeroMemBase@@SAPAXI@Z ; ZeroMemBase::operator new[]
  0003e	83 c4 04	 add	 esp, 4
  00041	89 45 a8	 mov	 DWORD PTR $T2[ebp], eax
  00044	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004b	83 7d a8 00	 cmp	 DWORD PTR $T2[ebp], 0
  0004f	74 34		 je	 SHORT $LN3@StaticObje
  00051	8b 45 a8	 mov	 eax, DWORD PTR $T2[ebp]
  00054	c7 00 e9 1c 00
	00		 mov	 DWORD PTR [eax], 7401	; 00001ce9H
  0005a	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  0005f	68 00 00 00 00	 push	 OFFSET ??0OBJECTSTRUCT@@QAE@XZ
  00064	68 e9 1c 00 00	 push	 7401			; 00001ce9H
  00069	68 a0 1b 00 00	 push	 7072			; 00001ba0H
  0006e	8b 4d a8	 mov	 ecx, DWORD PTR $T2[ebp]
  00071	83 c1 04	 add	 ecx, 4
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  0007a	8b 55 a8	 mov	 edx, DWORD PTR $T2[ebp]
  0007d	83 c2 04	 add	 edx, 4
  00080	89 55 a4	 mov	 DWORD PTR tv80[ebp], edx
  00083	eb 07		 jmp	 SHORT $LN4@StaticObje
$LN3@StaticObje:
  00085	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
$LN4@StaticObje:
  0008c	8b 45 a4	 mov	 eax, DWORD PTR tv80[ebp]
  0008f	89 45 ac	 mov	 DWORD PTR $T3[ebp], eax
  00092	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00099	8b 4d ac	 mov	 ecx, DWORD PTR $T3[ebp]
  0009c	89 0d 00 00 00
	00		 mov	 DWORD PTR ?gAllocObj@@3PAVOBJECTSTRUCT@@A, ecx ; gAllocObj

; 331  : #ifndef MEM2_KUZIMO
; 332  : 	memset(gAllocObj, 0x00, sizeof(OBJECTSTRUCT) * (MAX_OBJECT + 1));
; 333  : #endif
; 334  : 
; 335  : 	gObj = &gAllocObj[1];

  000a2	b8 a0 1b 00 00	 mov	 eax, 7072		; 00001ba0H
  000a7	c1 e0 00	 shl	 eax, 0
  000aa	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gAllocObj@@3PAVOBJECTSTRUCT@@A ; gAllocObj
  000b0	a3 00 00 00 00	 mov	 DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A, eax ; gObj

; 336  : }

  000b5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000bb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c2	59		 pop	 ecx
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0StaticObject@@QAE@XZ$0:
  00000	8b 45 a8	 mov	 eax, DWORD PTR $T2[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??_VZeroMemBase@@SAXPAX@Z ; ZeroMemBase::operator delete[]
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0StaticObject@@QAE@XZ:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0StaticObject@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0StaticObject@@QAE@XZ ENDP				; StaticObject::StaticObject
; Function compile flags: /Odtp /ZI
;	COMDAT ??__FViewGuildMng@@YAXXZ
text$yd	SEGMENT
??__FViewGuildMng@@YAXXZ PROC				; `dynamic atexit destructor for 'ViewGuildMng'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?ViewGuildMng@@3VCViewportGuild@@A ; ViewGuildMng
  0000e	e8 00 00 00 00	 call	 ??1CViewportGuild@@UAE@XZ ; CViewportGuild::~CViewportGuild
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__FViewGuildMng@@YAXXZ ENDP				; `dynamic atexit destructor for 'ViewGuildMng''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ??__EViewGuildMng@@YAXXZ
text$di	SEGMENT
??__EViewGuildMng@@YAXXZ PROC				; `dynamic initializer for 'ViewGuildMng'', COMDAT

; 175  : CViewportGuild	ViewGuildMng;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?ViewGuildMng@@3VCViewportGuild@@A ; ViewGuildMng
  0000e	e8 00 00 00 00	 call	 ??0CViewportGuild@@QAE@XZ ; CViewportGuild::CViewportGuild
  00013	68 00 00 00 00	 push	 OFFSET ??__FViewGuildMng@@YAXXZ ; `dynamic atexit destructor for 'ViewGuildMng''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__EViewGuildMng@@YAXXZ ENDP				; `dynamic initializer for 'ViewGuildMng''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMonsterExpDivision@@YAXPAVOBJECTSTRUCT@@0HH@Z
_TEXT	SEGMENT
_bSendExp$1 = -17					; size = 1
_n$2 = -16						; size = 4
_lpTargetObj$ = -12					; size = 4
_exp$ = -8						; size = 4
_tObjNum$ = -4						; size = 4
_lpMonObj$ = 8						; size = 4
_lpObj$ = 12						; size = 4
_AttackDamage$ = 16					; size = 4
_MSBFlag$ = 20						; size = 4
?gObjMonsterExpDivision@@YAXPAVOBJECTSTRUCT@@0HH@Z PROC	; gObjMonsterExpDivision, COMDAT

; 12593: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 12594: 	int tObjNum;
; 12595: #ifdef BUGFIX_GAIN_EXP_20071210
; 12596: 	INT64 exp;
; 12597: #else
; 12598: 	int exp;
; 12599: #endif
; 12600: 	LPOBJECTSTRUCT lpTargetObj;
; 12601: 	
; 12602: 	gObjMonsterHitDamageUserDel(lpMonObj);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpMonObj$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?gObjMonsterHitDamageUserDel@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageUserDel
  00012	83 c4 04	 add	 esp, 4

; 12603: 
; 12604: 	lpMonObj->Money = 0;

  00015	8b 45 08	 mov	 eax, DWORD PTR _lpMonObj$[ebp]
  00018	c7 80 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+176], 0

; 12605: 	for( int n=0; n<MAX_HITDAMAGE; n++)

  00022	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$2[ebp], 0
  00029	eb 09		 jmp	 SHORT $LN4@gObjMonste
$LN2@gObjMonste:
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _n$2[ebp]
  0002e	83 c0 01	 add	 eax, 1
  00031	89 45 f0	 mov	 DWORD PTR _n$2[ebp], eax
$LN4@gObjMonste:
  00034	83 7d f0 28	 cmp	 DWORD PTR _n$2[ebp], 40	; 00000028H
  00038	0f 8d 19 01 00
	00		 jge	 $LN3@gObjMonste

; 12606: 	{
; 12607: 		if( lpMonObj->sHD[n].number >= 0 )

  0003e	6b 45 f0 0c	 imul	 eax, DWORD PTR _n$2[ebp], 12
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonObj$[ebp]
  00045	0f bf 94 01 74
	0a 00 00	 movsx	 edx, WORD PTR [ecx+eax+2676]
  0004d	85 d2		 test	 edx, edx
  0004f	0f 8c fd 00 00
	00		 jl	 $LN7@gObjMonste

; 12608: 		{
; 12609: 			tObjNum = lpMonObj->sHD[n].number;

  00055	6b 45 f0 0c	 imul	 eax, DWORD PTR _n$2[ebp], 12
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonObj$[ebp]
  0005c	0f bf 94 01 74
	0a 00 00	 movsx	 edx, WORD PTR [ecx+eax+2676]
  00064	89 55 fc	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 12610: 			lpTargetObj = &gObj[tObjNum];

  00067	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  0006e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00074	89 45 f4	 mov	 DWORD PTR _lpTargetObj$[ebp], eax

; 12611: 
; 12612: 			// ..
; 12613: 			if( lpMonObj->sHD[n].HitDamage > 0 )

  00077	6b 45 f0 0c	 imul	 eax, DWORD PTR _n$2[ebp], 12
  0007b	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonObj$[ebp]
  0007e	83 bc 01 78 0a
	00 00 00	 cmp	 DWORD PTR [ecx+eax+2680], 0
  00086	0f 8e c6 00 00
	00		 jle	 $LN7@gObjMonste

; 12614: 			{
; 12615: #ifdef MAX_LEVEL_BLOCK_GAIN_EXPERIENCE_20050613
; 12616: 				bool bSendExp = true;

  0008c	c6 45 ef 01	 mov	 BYTE PTR _bSendExp$1[ebp], 1

; 12617: 				exp = gObjMonsterExpSingle(lpTargetObj, lpMonObj, lpMonObj->sHD[n].HitDamage, (int)lpMonObj->MaxLife, bSendExp);

  00090	8d 45 ef	 lea	 eax, DWORD PTR _bSendExp$1[ebp]
  00093	50		 push	 eax
  00094	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonObj$[ebp]
  00097	f3 0f 2c 91 c0
	00 00 00	 cvttss2si edx, DWORD PTR [ecx+192]
  0009f	52		 push	 edx
  000a0	6b 45 f0 0c	 imul	 eax, DWORD PTR _n$2[ebp], 12
  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _lpMonObj$[ebp]
  000a7	8b 94 01 78 0a
	00 00		 mov	 edx, DWORD PTR [ecx+eax+2680]
  000ae	52		 push	 edx
  000af	8b 45 08	 mov	 eax, DWORD PTR _lpMonObj$[ebp]
  000b2	50		 push	 eax
  000b3	8b 4d f4	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  000b6	51		 push	 ecx
  000b7	e8 00 00 00 00	 call	 ?gObjMonsterExpSingle@@YAHPAVOBJECTSTRUCT@@0HHAA_N@Z ; gObjMonsterExpSingle
  000bc	83 c4 14	 add	 esp, 20			; 00000014H
  000bf	89 45 f8	 mov	 DWORD PTR _exp$[ebp], eax

; 12618: #else
; 12619: 				exp = gObjMonsterExpSingle(lpTargetObj, lpMonObj, lpMonObj->sHD[n].HitDamage, (int)lpMonObj->MaxLife);
; 12620: #endif
; 12621: 
; 12622: #ifdef BUGFIX_GAIN_EXP_20071210
; 12623: 	//			if( exp > 0 )
; 12624: #else
; 12625: 				if( exp > 0 )

  000c2	83 7d f8 00	 cmp	 DWORD PTR _exp$[ebp], 0
  000c6	0f 8e 86 00 00
	00		 jle	 $LN7@gObjMonste

; 12626: #endif
; 12627: 				{
; 12628: #ifdef MAX_LEVEL_BLOCK_GAIN_EXPERIENCE_20050613
; 12629: 					if (bSendExp == true) 

  000cc	0f b6 45 ef	 movzx	 eax, BYTE PTR _bSendExp$1[ebp]
  000d0	83 f8 01	 cmp	 eax, 1
  000d3	75 68		 jne	 SHORT $LN12@gObjMonste

; 12630: 					{
; 12631: 						if( lpTargetObj->m_Index == lpObj->m_Index )	//  ..

  000d5	8b 45 f4	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000d8	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000db	8b 10		 mov	 edx, DWORD PTR [eax]
  000dd	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000df	75 30		 jne	 SHORT $LN9@gObjMonste

; 12632: 						{
; 12633: #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 12634: 							GCKillPlayerExpSend(lpTargetObj->m_Index, lpMonObj->m_Index, exp, AttackDamage, MSBFlag);
; 12635: #else
; 12636: 	#ifdef ADD_PCS_MARK_OF_EXP_20070205
; 12637: 							if( lpObj->m_wExprienceRate > 0 )

  000e1	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e4	0f b7 88 2c 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6700]
  000eb	85 c9		 test	 ecx, ecx
  000ed	7e 20		 jle	 SHORT $LN11@gObjMonste

; 12638: 							{
; 12639: 								GCKillPlayerExpSend(lpTargetObj->m_Index, lpMonObj->m_Index, exp, AttackDamage, MSBFlag);

  000ef	8b 45 14	 mov	 eax, DWORD PTR _MSBFlag$[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d 10	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 f8	 mov	 edx, DWORD PTR _exp$[ebp]
  000fa	52		 push	 edx
  000fb	8b 45 08	 mov	 eax, DWORD PTR _lpMonObj$[ebp]
  000fe	8b 08		 mov	 ecx, DWORD PTR [eax]
  00100	51		 push	 ecx
  00101	8b 55 f4	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00104	8b 02		 mov	 eax, DWORD PTR [edx]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 ?GCKillPlayerExpSend@@YAXHHHHH@Z ; GCKillPlayerExpSend
  0010c	83 c4 14	 add	 esp, 20			; 00000014H
$LN11@gObjMonste:

; 12640: 							}
; 12641: 	#else
; 12642: 							GCKillPlayerExpSend(lpTargetObj->m_Index, lpMonObj->m_Index, exp, AttackDamage, MSBFlag);
; 12643: 	#endif // ADD_PCS_MARK_OF_EXP_20070205
; 12644: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 12645: 							
; 12646: 				#ifdef PCBANG_ADVANTAGE //happycat@20050201 
; 12647: 
; 12648: 					#ifdef PCBANG_ADVANTAGE_EXPAND_20060919
; 12649: 						#ifdef FOR_TAIWAN
; 12650: 							if( IsOKPCBangBenefitAll(lpObj) )
; 12651: 							{
; 12652: 								lpMonObj->Money += exp;
; 12653: 							}
; 12654: 						#else
; 12655: 							if( lpObj->Level <= 150 && IsOKPCBangBenefitAll(lpObj) )
; 12656: 							{
; 12657: 								lpMonObj->Money += exp;
; 12658: 							}
; 12659: 						#endif
; 12660: 					#else
; 12661: 						#ifdef FOR_TAIWAN
; 12662: 							if (lpTargetObj->m_bPCBangUser)	lpMonObj->Money += exp;
; 12663: 						#else
; 12664: 							if (lpObj->Level <= 150 && lpTargetObj->m_bPCBangUser)	lpMonObj->Money += exp;
; 12665: 						#endif
; 12666: 					#endif //PCBANG_ADVANTAGE_EXPAND_20060919
; 12667: 
; 12668: 				#endif //   150   PC ? double money!
; 12669: 											
; 12670: 						}

  0010f	eb 2c		 jmp	 SHORT $LN12@gObjMonste
$LN9@gObjMonste:

; 12671: 						else
; 12672: 						{
; 12673: #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 12674: 							GCKillPlayerExpSend(lpTargetObj->m_Index, lpMonObj->m_Index, exp, 0, MSBFlag);
; 12675: #else
; 12676: 	#ifdef ADD_PCS_MARK_OF_EXP_20070205
; 12677: 							if( lpTargetObj->m_wExprienceRate > 0 )

  00111	8b 45 f4	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00114	0f b7 88 2c 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6700]
  0011b	85 c9		 test	 ecx, ecx
  0011d	7e 1e		 jle	 SHORT $LN12@gObjMonste

; 12678: 							{
; 12679: 								GCKillPlayerExpSend(lpTargetObj->m_Index, lpMonObj->m_Index, exp, 0, MSBFlag);

  0011f	8b 45 14	 mov	 eax, DWORD PTR _MSBFlag$[ebp]
  00122	50		 push	 eax
  00123	6a 00		 push	 0
  00125	8b 4d f8	 mov	 ecx, DWORD PTR _exp$[ebp]
  00128	51		 push	 ecx
  00129	8b 55 08	 mov	 edx, DWORD PTR _lpMonObj$[ebp]
  0012c	8b 02		 mov	 eax, DWORD PTR [edx]
  0012e	50		 push	 eax
  0012f	8b 4d f4	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00132	8b 11		 mov	 edx, DWORD PTR [ecx]
  00134	52		 push	 edx
  00135	e8 00 00 00 00	 call	 ?GCKillPlayerExpSend@@YAXHHHHH@Z ; GCKillPlayerExpSend
  0013a	83 c4 14	 add	 esp, 20			; 00000014H
$LN12@gObjMonste:

; 12680: 							}
; 12681: 	#else
; 12682: 							GCKillPlayerExpSend(lpTargetObj->m_Index, lpMonObj->m_Index, exp, 0, MSBFlag);
; 12683: 	#endif // ADD_PCS_MARK_OF_EXP_20070205
; 12684: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 12685: 						}
; 12686: 					}
; 12687: #else
; 12688: 					if( lpTargetObj->m_Index == lpObj->m_Index )	//  ..
; 12689: 					{
; 12690: 						GCKillPlayerExpSend(lpTargetObj->m_Index, lpMonObj->m_Index, exp, AttackDamage, MSBFlag);
; 12691: 					
; 12692: 				#ifdef PCBANG_ADVANTAGE //happycat@20050201 
; 12693: 					#ifdef PCBANG_ADVANTAGE_EXPAND_20060919
; 12694: 						if( lpObj->Level <= 150 && IsOKPCBangBenefitAll(lpObj) )
; 12695: 						{
; 12696: 							lpMonObj->Money += exp;
; 12697: 						}
; 12698: 					#else
; 12699: 						if (lpObj->Level <= 150 && lpTargetObj->m_bPCBangUser)	lpMonObj->Money += exp;
; 12700: 					#endif //PCBANG_ADVANTAGE_EXPAND_20060919
; 12701: 				#endif //   150   PC ? double money!
; 12702: 					}
; 12703: 					else GCKillPlayerExpSend(lpTargetObj->m_Index, lpMonObj->m_Index, exp, 0, MSBFlag);
; 12704: #endif
; 12705: 
; 12706: #ifdef ADD_PREMIUMITEM_PANDA
; 12707: 					if( (lpObj->pInventory[EQUIPMENT_RING_RIGHT].IsItem() 
; 12708: 						&& lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM(13, 76) 
; 12709: 						&& lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability > 0) ||
; 12710: 						(lpObj->pInventory[EQUIPMENT_RING_LEFT].IsItem() 
; 12711: 						&& lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM(13, 76) 
; 12712: 						&& lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability > 0) 
; 12713: 						)
; 12714: 					{
; 12715: 						//   +50%
; 12716: 						//lpMonObj->Money += exp;
; 12717: 						lpMonObj->Money += exp * 0.5;
; 12718: 					}
; 12719: 					
; 12720: #endif // ADD_PREMIUMITEM_PANDA
; 12721: 
; 12722: #ifdef ADD_UNICORN_PET_20090915		//    50% 
; 12723: 					if( (lpObj->pInventory[EQUIPMENT_HELPER].IsItem() 
; 12724: 						&& lpObj->pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13, 106) 
; 12725: 						&& lpObj->pInventory[EQUIPMENT_HELPER].m_Durability > 0)
; 12726: 						)
; 12727: 					{
; 12728: 						//   +50%
; 12729: 						lpMonObj->Money += exp * 0.5;
; 12730: 					}					
; 12731: #endif // ADD_UNICORN_PET_20090915
; 12732: 
; 12733: 					//      
; 12734: 					lpMonObj->Money += exp;

  0013d	8b 45 08	 mov	 eax, DWORD PTR _lpMonObj$[ebp]
  00140	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00146	03 4d f8	 add	 ecx, DWORD PTR _exp$[ebp]
  00149	8b 55 08	 mov	 edx, DWORD PTR _lpMonObj$[ebp]
  0014c	89 8a b0 00 00
	00		 mov	 DWORD PTR [edx+176], ecx
$LN7@gObjMonste:

; 12735: 				}
; 12736: 			}
; 12737: 		}
; 12738: 	}

  00152	e9 d4 fe ff ff	 jmp	 $LN2@gObjMonste
$LN3@gObjMonste:

; 12739: }

  00157	5f		 pop	 edi
  00158	5e		 pop	 esi
  00159	5b		 pop	 ebx
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c3		 ret	 0
?gObjMonsterExpDivision@@YAXPAVOBJECTSTRUCT@@0HH@Z ENDP	; gObjMonsterExpDivision
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMonsterExpSingle@@YAHPAVOBJECTSTRUCT@@0HHAA_N@Z
_TEXT	SEGMENT
tv150 = -92						; size = 4
tv151 = -88						; size = 4
__fDivider$ = -20					; size = 4
_mymaxexp$ = -16					; size = 4
_level$ = -12						; size = 4
_maxexp$ = -8						; size = 4
_exp$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_dmg$ = 16						; size = 4
_tot_dmg$ = 20						; size = 4
_bSendExp$ = 24						; size = 4
?gObjMonsterExpSingle@@YAHPAVOBJECTSTRUCT@@0HHAA_N@Z PROC ; gObjMonsterExpSingle, COMDAT

; 12751: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 12752: #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	//         .
; 12753: 	if( !g_MasterLevelSystem.CheckMLGetExp( lpObj, lpTargetObj ) )
; 12754: 	{
; 12755: 		bSendExp = false;
; 12756: 		return 0;
; 12757: 	}
; 12758: #endif
; 12759: 	
; 12760: #ifdef DEVILSQUARE_EXTEND_20050221		//    
; 12761: 	if( CHECK_DEVILSQUARE(lpObj->MapNumber) ) 
; 12762: #else
; 12763: 	if( lpObj->MapNumber == 9 ) 

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00013	83 f9 09	 cmp	 ecx, 9
  00016	75 1f		 jne	 SHORT $LN2@gObjMonste

; 12764: #endif
; 12765: 	{	//  
; 12766: 		return g_DevilSquare.gObjMonsterExpSingle(lpObj, lpTargetObj, dmg, tot_dmg);

  00018	8b 45 14	 mov	 eax, DWORD PTR _tot_dmg$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _dmg$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00027	50		 push	 eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  0002d	e8 00 00 00 00	 call	 ?gObjMonsterExpSingle@CDevilSquare@@QAEHPAVOBJECTSTRUCT@@0HH@Z ; CDevilSquare::gObjMonsterExpSingle
  00032	e9 44 02 00 00	 jmp	 $LN1@gObjMonste
$LN2@gObjMonste:

; 12767: 	}
; 12768: 
; 12769: #ifdef BUGFIX_GAIN_EXP_20071210
; 12770: 	INT64 exp, maxexp=0;
; 12771: #else
; 12772: 	int exp, maxexp=0;

  00037	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _maxexp$[ebp], 0

; 12773: #endif
; 12774: 	
; 12775: #ifdef MODIFY_GETTING_EXP_RATE_20060214
; 12776: 	int level = ((lpTargetObj->Level+25)*lpTargetObj->Level)/3;

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00041	0f bf 80 a0 00
	00 00		 movsx	 eax, WORD PTR [eax+160]
  00048	83 c0 19	 add	 eax, 25			; 00000019H
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  0004e	0f bf 91 a0 00
	00 00		 movsx	 edx, WORD PTR [ecx+160]
  00055	0f af c2	 imul	 eax, edx
  00058	99		 cdq
  00059	b9 03 00 00 00	 mov	 ecx, 3
  0005e	f7 f9		 idiv	 ecx
  00060	89 45 f4	 mov	 DWORD PTR _level$[ebp], eax

; 12777: #else
; 12778: #ifdef MODIFY_GETTING_EXP_RATE_20051116
; 12779: 	int level = ((lpTargetObj->Level+20)*lpTargetObj->Level)/4;
; 12780: #else
; 12781: 	int level = ((lpTargetObj->Level+10)*lpTargetObj->Level)/4;
; 12782: #endif
; 12783: #endif // MODIFY_GETTING_EXP_RATE_20060214
; 12784: 
; 12785: #ifdef MASTER_LEVEL_UP_SYSTEM_20070912				//   .
; 12786: 	//   10   ..
; 12787: 	if( ( lpTargetObj->Level + 10) < ( lpObj->Level + lpObj->m_nMasterLevel ) )
; 12788: 	{
; 12789: 		level =  level * ( lpTargetObj->Level + 10 ) / ( lpObj->Level + lpObj->m_nMasterLevel );
; 12790: 	}
; 12791: #else
; 12792: 	//   10   ..
; 12793: 	if( (lpTargetObj->Level+10) < lpObj->Level )

  00063	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00066	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0006d	83 c1 0a	 add	 ecx, 10			; 0000000aH
  00070	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00073	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  0007a	3b c8		 cmp	 ecx, eax
  0007c	7d 23		 jge	 SHORT $LN3@gObjMonste

; 12794: 	{
; 12795: 		level =  level * (lpTargetObj->Level+10) / lpObj->Level;

  0007e	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00081	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00088	83 c1 0a	 add	 ecx, 10			; 0000000aH
  0008b	8b c1		 mov	 eax, ecx
  0008d	0f af 45 f4	 imul	 eax, DWORD PTR _level$[ebp]
  00091	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00094	0f bf 8a a0 00
	00 00		 movsx	 ecx, WORD PTR [edx+160]
  0009b	99		 cdq
  0009c	f7 f9		 idiv	 ecx
  0009e	89 45 f4	 mov	 DWORD PTR _level$[ebp], eax
$LN3@gObjMonste:

; 12796: 	}
; 12797: #endif	// MASTER_LEVEL_UP_SYSTEM_20070912
; 12798: 
; 12799: #ifdef EXP_CAL_CHANGE	
; 12800: 	if( lpTargetObj->Level >= 65 )	

  000a1	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000a4	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  000ab	83 f9 41	 cmp	 ecx, 65			; 00000041H
  000ae	7c 29		 jl	 SHORT $LN4@gObjMonste

; 12801: 	{	//   65
; 12802: 		//level += 200 - (lpObj->Level*0.2);
; 12803: 
; 12804: 	#ifdef MODIFY_GETTING_EXP_RATE_20051116
; 12805: 		level += (lpTargetObj->Level-64)*(lpTargetObj->Level/3);
; 12806: 	#else
; 12807: 		level += (lpTargetObj->Level-64)*(lpTargetObj->Level/4);

  000b0	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000b3	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  000ba	83 e9 40	 sub	 ecx, 64			; 00000040H
  000bd	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  000c0	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  000c7	99		 cdq
  000c8	83 e2 03	 and	 edx, 3
  000cb	03 c2		 add	 eax, edx
  000cd	c1 f8 02	 sar	 eax, 2
  000d0	0f af c8	 imul	 ecx, eax
  000d3	03 4d f4	 add	 ecx, DWORD PTR _level$[ebp]
  000d6	89 4d f4	 mov	 DWORD PTR _level$[ebp], ecx
$LN4@gObjMonste:

; 12808: 	#endif
; 12809: 
; 12810: 	}
; 12811: #endif
; 12812: 
; 12813: 	if( level > 0 ) 

  000d9	83 7d f4 00	 cmp	 DWORD PTR _level$[ebp], 0
  000dd	7e 0d		 jle	 SHORT $LN5@gObjMonste

; 12814: 	{
; 12815: 		// 50%   
; 12816: 		maxexp = level/2;

  000df	8b 45 f4	 mov	 eax, DWORD PTR _level$[ebp]
  000e2	99		 cdq
  000e3	2b c2		 sub	 eax, edx
  000e5	d1 f8		 sar	 eax, 1
  000e7	89 45 f8	 mov	 DWORD PTR _maxexp$[ebp], eax

; 12817: 	}

  000ea	eb 07		 jmp	 SHORT $LN6@gObjMonste
$LN5@gObjMonste:

; 12818: 	else level = 0;

  000ec	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _level$[ebp], 0
$LN6@gObjMonste:

; 12819: 	
; 12820: 	if( maxexp < 1 ) {

  000f3	83 7d f8 01	 cmp	 DWORD PTR _maxexp$[ebp], 1
  000f7	7d 08		 jge	 SHORT $LN7@gObjMonste

; 12821: 		exp = level;

  000f9	8b 45 f4	 mov	 eax, DWORD PTR _level$[ebp]
  000fc	89 45 fc	 mov	 DWORD PTR _exp$[ebp], eax

; 12822: 	}

  000ff	eb 0f		 jmp	 SHORT $LN8@gObjMonste
$LN7@gObjMonste:

; 12823: 	else 
; 12824: 	{
; 12825: 		exp = level+(rand()%maxexp);

  00101	e8 00 00 00 00	 call	 _rand
  00106	99		 cdq
  00107	f7 7d f8	 idiv	 DWORD PTR _maxexp$[ebp]
  0010a	03 55 f4	 add	 edx, DWORD PTR _level$[ebp]
  0010d	89 55 fc	 mov	 DWORD PTR _exp$[ebp], edx
$LN8@gObjMonste:

; 12826: 	}
; 12827: 	
; 12828: 	exp = (dmg*exp)/tot_dmg;

  00110	8b 45 10	 mov	 eax, DWORD PTR _dmg$[ebp]
  00113	0f af 45 fc	 imul	 eax, DWORD PTR _exp$[ebp]
  00117	99		 cdq
  00118	f7 7d 14	 idiv	 DWORD PTR _tot_dmg$[ebp]
  0011b	89 45 fc	 mov	 DWORD PTR _exp$[ebp], eax

; 12829: 
; 12830: #ifdef FOR_BLOODCASTLE2
; 12831: 	if( CHECK_BLOODCASTLE(lpObj->MapNumber) )		

  0011e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00121	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00128	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  0012b	7d 09		 jge	 SHORT $LN20@gObjMonste
  0012d	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv151[ebp], 0
  00134	eb 25		 jmp	 SHORT $LN21@gObjMonste
$LN20@gObjMonste:
  00136	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00139	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00140	83 f8 11	 cmp	 eax, 17			; 00000011H
  00143	7e 09		 jle	 SHORT $LN18@gObjMonste
  00145	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv150[ebp], 0
  0014c	eb 07		 jmp	 SHORT $LN19@gObjMonste
$LN18@gObjMonste:
  0014e	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv150[ebp], 1
$LN19@gObjMonste:
  00155	8b 4d a4	 mov	 ecx, DWORD PTR tv150[ebp]
  00158	89 4d a8	 mov	 DWORD PTR tv151[ebp], ecx
$LN21@gObjMonste:
  0015b	83 7d a8 00	 cmp	 DWORD PTR tv151[ebp], 0
  0015f	74 0f		 je	 SHORT $LN9@gObjMonste

; 12832: 	{	//      50%
; 12833: 		exp = exp*BC_MONSTER_KILL_EXP_PERCENT/100;

  00161	6b 45 fc 32	 imul	 eax, DWORD PTR _exp$[ebp], 50
  00165	99		 cdq
  00166	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0016b	f7 f9		 idiv	 ecx
  0016d	89 45 fc	 mov	 DWORD PTR _exp$[ebp], eax
$LN9@gObjMonste:

; 12834: 	}
; 12835: #endif
; 12836: 
; 12837: #ifdef MASTER_LEVEL_UP_SYSTEM_20070912		//        
; 12838: 	DWORD mymaxexp = 0;
; 12839: 	if( g_MasterLevelSystem.IsMasterLevelUser( lpObj ) )
; 12840: 	{
; 12841: 		mymaxexp = lpObj->m_i64NextMasterLevelExp;
; 12842: 	}
; 12843: 	else
; 12844: 	{
; 12845: 		mymaxexp = gLevelExperience[lpObj->Level];
; 12846: 	}
; 12847: #else
; 12848: 	DWORD mymaxexp = gLevelExperience[lpObj->Level];

  00170	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00173	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0017a	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?gLevelExperience@@3PAKA[ecx*4]
  00181	89 55 f0	 mov	 DWORD PTR _mymaxexp$[ebp], edx

; 12849: 	//    ..
; 12850: 	if( exp > mymaxexp ) exp = mymaxexp;

  00184	8b 45 fc	 mov	 eax, DWORD PTR _exp$[ebp]
  00187	3b 45 f0	 cmp	 eax, DWORD PTR _mymaxexp$[ebp]
  0018a	76 06		 jbe	 SHORT $LN10@gObjMonste
  0018c	8b 45 f0	 mov	 eax, DWORD PTR _mymaxexp$[ebp]
  0018f	89 45 fc	 mov	 DWORD PTR _exp$[ebp], eax
$LN10@gObjMonste:

; 12851: #endif
; 12852: 
; 12853: #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	//   -   	
; 12854: 	if( !g_MasterLevelSystem.IsMasterLevelUser( lpObj ) )
; 12855: 		exp = (int)((float)exp*gAddExperience);
; 12856: #else
; 12857: 	exp = (int)((float)exp*gAddExperience);

  00192	f3 0f 2a 45 fc	 cvtsi2ss xmm0, DWORD PTR _exp$[ebp]
  00197	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR ?gAddExperience@@3MA
  0019f	f3 0f 2c c0	 cvttss2si eax, xmm0
  001a3	89 45 fc	 mov	 DWORD PTR _exp$[ebp], eax

; 12858: 
; 12859: 	float _fDivider = _dynamic_experience._checkCondition(lpObj);

  001a6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a9	50		 push	 eax
  001aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?_dynamic_experience@@3VCDynamicExperience@@A ; _dynamic_experience
  001af	e8 00 00 00 00	 call	 ?_checkCondition@CDynamicExperience@@QAEMPAVOBJECTSTRUCT@@@Z ; CDynamicExperience::_checkCondition
  001b4	d9 5d ec	 fstp	 DWORD PTR __fDivider$[ebp]

; 12860: 	// ----
; 12861: 	if (_fDivider != 0) 

  001b7	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR __fDivider$[ebp]
  001bc	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  001c3	9f		 lahf
  001c4	f6 c4 44	 test	 ah, 68			; 00000044H
  001c7	7b 1c		 jnp	 SHORT $LN11@gObjMonste

; 12862: 	{
; 12863: 		exp = _dynamic_experience._getNewExperience(exp, _fDivider);

  001c9	51		 push	 ecx
  001ca	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR __fDivider$[ebp]
  001cf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d4	8b 45 fc	 mov	 eax, DWORD PTR _exp$[ebp]
  001d7	50		 push	 eax
  001d8	b9 00 00 00 00	 mov	 ecx, OFFSET ?_dynamic_experience@@3VCDynamicExperience@@A ; _dynamic_experience
  001dd	e8 00 00 00 00	 call	 ?_getNewExperience@CDynamicExperience@@QAEKKM@Z ; CDynamicExperience::_getNewExperience
  001e2	89 45 fc	 mov	 DWORD PTR _exp$[ebp], eax
$LN11@gObjMonste:

; 12864: 	}
; 12865: 
; 12866: #endif
; 12867: 
; 12868: #if defined(PCBANG_POINT_SYSTEM_20070206) && defined(ADD_PCBANG_EXPRATE)
; 12869: 	if( !g_MasterLevelSystem.IsMasterLevelUser( lpObj ) )
; 12870: 		g_PCBangPointSystem.CheckPCBangAddExperience(lpObj, exp);
; 12871: #endif // ADD_PCBANG_EXPRATE
; 12872: 
; 12873: #ifdef ADD_PCS_MARK_OF_EXP_20070205
; 12874: 	#ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004					// !! NOT
; 12875: 	if( lpObj->m_wExprienceRate > 0 )

  001e5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e8	0f b7 88 2c 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6700]
  001ef	85 c9		 test	 ecx, ecx
  001f1	7e 26		 jle	 SHORT $LN12@gObjMonste

; 12876: 	{
; 12877: 		exp = (int)(exp * ((float)lpObj->m_wExprienceRate / 100 ));

  001f3	f3 0f 2a 45 fc	 cvtsi2ss xmm0, DWORD PTR _exp$[ebp]
  001f8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001fb	0f b7 88 2c 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6700]
  00202	f3 0f 2a c9	 cvtsi2ss xmm1, ecx
  00206	f3 0f 5e 0d 00
	00 00 00	 divss	 xmm1, DWORD PTR __real@42c80000
  0020e	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00212	f3 0f 2c d0	 cvttss2si edx, xmm0
  00216	89 55 fc	 mov	 DWORD PTR _exp$[ebp], edx
$LN12@gObjMonste:

; 12878: 	}
; 12879: 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 12880: #endif // ADD_PCS_MARK_OF_EXP_20070205
; 12881: 
; 12882: #ifdef MU_CRYWOLF_PENALTY_20051215
; 12883: 	// MVP  :    
; 12884: 	if( g_CrywolfSync.GetOccupationState() == CRYWOLF_OCCUPATION_STATE_OCCUPIED 
; 12885: 		&& g_iCrywolfApplyMvpPenalty
; 12886: 	  )
; 12887: 	{
; 12888: 		exp = exp * g_CrywolfSync.GetGettingExpPenaltyRate() / 100;
; 12889: 	}
; 12890: #endif
; 12891: 
; 12892: 	//LogAdd(" : [%s][%s] [%s] %d (%d / %d:%d)", lpObj->AccountID, lpObj->Name, lpTargetObj->Name, exp, lpObj->MapNumber, lpObj->X, lpObj->Y);
; 12893: 
; 12894: 	if( exp > 0 ) 

  00219	83 7d fc 00	 cmp	 DWORD PTR _exp$[ebp], 0
  0021d	7e 59		 jle	 SHORT $LN16@gObjMonste

; 12895: 	{
; 12896: 		if( lpObj->Type == OBJTYPE_CHARACTER )

  0021f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00222	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00226	83 f9 01	 cmp	 ecx, 1
  00229	75 4d		 jne	 SHORT $LN16@gObjMonste

; 12897: 		{
; 12898: #ifdef CHN_PLAYTIME_LIMIT_SYSTEM_20050818	// > .      .
; 12899: 			if (g_bChnPlayTimeLimitOn)
; 12900: 			{
; 12901: 	#ifdef MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_01_20070509
; 12902: 				if( lpObj->m_iVerifyType != PLAYTIME_LIMIT_VERIFY_ADULT )
; 12903: 				{
; 12904: 					if (lpObj->m_iPlayTimeLimit >= 5*60*60)
; 12905: 					{
; 12906: 						exp = exp * g_iChnPlayTimeLimitLevel2Exp / 100;
; 12907: 					}
; 12908: 					else if (lpObj->m_iPlayTimeLimit >= 3*60*60)
; 12909: 					{
; 12910: 						exp = exp * g_iChnPlayTimeLimitLevel1Exp / 100;
; 12911: 					}
; 12912: 				}
; 12913: 	#else
; 12914: 				if (lpObj->m_iPlayTimeLimit >= 5*60*60)
; 12915: 				{
; 12916: 					exp = exp * g_iChnPlayTimeLimitLevel2Exp / 100;
; 12917: 				}
; 12918: 				else if (lpObj->m_iPlayTimeLimit >= 3*60*60)
; 12919: 				{
; 12920: 					exp = exp * g_iChnPlayTimeLimitLevel1Exp / 100;
; 12921: 				}
; 12922: 	#endif // MODIFY_CHN_PLAYTIME_LIMIT_SYSTEM_01_20070509
; 12923: 			}
; 12924: #endif
; 12925: 			
; 12926: #ifdef VTM_PLAYTIME_LIMIT_SYSTEM_20060626	//  :   
; 12927: 			if (g_bVtmPlayTimeLimitOn) 
; 12928: 			{
; 12929: 				if (lpObj->m_iPlayTimeLimit >= g_iVtmPlayTimeLimitLevel2Time*60) 
; 12930: 				{
; 12931: 					exp = exp * g_iVtmPlayTimeLimitLevel2Exp / 100;
; 12932: 				}
; 12933: 				else if (lpObj->m_iPlayTimeLimit >= g_iVtmPlayTimeLimitLevel1Time*60) 
; 12934: 				{
; 12935: 					exp = exp * g_iVtmPlayTimeLimitLevel1Exp / 100;
; 12936: 				}
; 12937: 			}
; 12938: #endif
; 12939: 
; 12940: #ifdef MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 12941: 			CheckItemOptForGetExpEx( lpObj, exp );
; 12942: #else
; 12943: //--> MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC     
; 12944: #ifdef PCBANG_POINT_SYSTEM_20070206		// PC    ()
; 12945: 	#ifdef ADD_NEWPVP_PKFIELD
; 12946: 			//  PC ( )  
; 12947: 			if (g_NewPVP.IsVulcanusMap(lpObj->MapNumber)) {
; 12948: 				g_NewPVP.CheckItemOptForGetExp(lpObj, exp);
; 12949: 			} else {
; 12950: 				g_PCBangPointSystem.CheckItemOptForGetExp( lpObj, exp );
; 12951: 			}
; 12952: 	#else
; 12953: 			g_PCBangPointSystem.CheckItemOptForGetExp( lpObj, exp );
; 12954: 	#endif // ADD_NEWPVP_PKFIELD
; 12955: #endif
; 12956: //<--
; 12957: #endif // MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 12958: /*
; 12959: 		lpObj->Experience += (int)exp;
; 12960: #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004		// !!NOT
; 12961: 	#ifdef ADD_PCS_MARK_OF_EXP_20070205
; 12962: 			if( lpObj->m_wExprienceRate > 0 )
; 12963: 			{
; 12964: 				lpObj->Experience += exp;
; 12965: 			}
; 12966: 	#else
; 12967: 			lpObj->Experience += exp;
; 12968: 	#endif // ADD_PCS_MARK_OF_EXP_20070205
; 12969: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 12970: */
; 12971: #ifdef MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 12972: 			lpObj->Experience += exp;
; 12973: #else
; 12974: //--> MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC     
; 12975: #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 12976: 	#ifdef MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 12977: 		CheckItemOptForGetExp(lpObj, exp);
; 12978: 	#else
; 12979: 		int iExpRate = 0;
; 12980: 		iExpRate = gObjGetTotalValueOfEffect( lpObj, EFFECTTYPE_EXPERIENCE );
; 12981: 		if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_PCS_MARK3 ) == false
; 12982: 			&& iExpRate == 0
; 12983: 			)
; 12984: 		{
; 12985: 			iExpRate = 100;
; 12986: 			exp = ( exp * iExpRate ) / 100;
; 12987: 		}
; 12988: 	#endif// MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 12989: 		
; 12990: 		lpObj->Experience += exp;
; 12991: 		
; 12992: #else
; 12993: 	#ifdef PCBANG_POINT_SYSTEM_20070206			//    
; 12994: 		if( lpObj->m_iPCBangPointItemTime )
; 12995: 		{					
; 12996: 			if( lpObj->m_bPCBangPointNoMoreExp > 0 )
; 12997: 			{
; 12998: 				//   
; 12999: 				exp = 0;
; 13000: 			}
; 13001: 			else if( lpObj->m_iPCBangPointItemAddExpPer > 0 )
; 13002: 			{
; 13003: 				//  
; 13004: 				exp = exp * lpObj->m_iPCBangPointItemAddExpPer / 100;
; 13005: 			}
; 13006: 		}
; 13007: 	#endif
; 13008: 		
; 13009: 	#ifdef ADD_PCS_MARK_OF_EXP_20070205
; 13010: 		if( lpObj->m_wExprienceRate > 0 )

  0022b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0022e	0f b7 88 2c 1a
	00 00		 movzx	 ecx, WORD PTR [eax+6700]
  00235	85 c9		 test	 ecx, ecx
  00237	7e 15		 jle	 SHORT $LN15@gObjMonste

; 13011: 		{
; 13012: 			lpObj->Experience += exp;

  00239	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0023c	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00242	03 4d fc	 add	 ecx, DWORD PTR _exp$[ebp]
  00245	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00248	89 8a a8 00 00
	00		 mov	 DWORD PTR [edx+168], ecx
$LN15@gObjMonste:

; 13013: 		}
; 13014: 	#else
; 13015: 		lpObj->Experience += exp;
; 13016: 	#endif // ADD_PCS_MARK_OF_EXP_20070205
; 13017: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 13018: //<--
; 13019: #endif // MODIFY_BUFF_EFFECT_SYSTEM_CHECKLOGIC
; 13020: 
; 13021: #ifdef MODIFY_EXP_LOG_MONSTER_EVENT_INDEX_20060906
; 13022: 			if (gObjLevelUp(lpObj, exp, lpTargetObj->Class, EVENT_TYPE_NONE) == false)

  0024e	6a 00		 push	 0
  00250	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00253	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0025a	51		 push	 ecx
  0025b	8b 55 fc	 mov	 edx, DWORD PTR _exp$[ebp]
  0025e	52		 push	 edx
  0025f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00262	50		 push	 eax
  00263	e8 00 00 00 00	 call	 ?gObjLevelUp@@YA_NPAVOBJECTSTRUCT@@HHH@Z ; gObjLevelUp
  00268	83 c4 10	 add	 esp, 16			; 00000010H
  0026b	0f b6 c8	 movzx	 ecx, al
  0026e	85 c9		 test	 ecx, ecx
  00270	75 06		 jne	 SHORT $LN16@gObjMonste

; 13023: 				bSendExp = false;

  00272	8b 45 18	 mov	 eax, DWORD PTR _bSendExp$[ebp]
  00275	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN16@gObjMonste:

; 13024: #else
; 13025: 	#ifdef MAX_LEVEL_BLOCK_GAIN_EXPERIENCE_20050613
; 13026: 			if (gObjLevelUp(lpObj, exp) == false)
; 13027: 				bSendExp = false;
; 13028: 	#endif
; 13029: #endif // MODIFY_EXP_LOG_MONSTER_EVENT_INDEX_20060906
; 13030: 		}
; 13031: 	}
; 13032: 	return exp;

  00278	8b 45 fc	 mov	 eax, DWORD PTR _exp$[ebp]
$LN1@gObjMonste:

; 13033: }

  0027b	5f		 pop	 edi
  0027c	5e		 pop	 esi
  0027d	5b		 pop	 ebx
  0027e	8b e5		 mov	 esp, ebp
  00280	5d		 pop	 ebp
  00281	c3		 ret	 0
?gObjMonsterExpSingle@@YAHPAVOBJECTSTRUCT@@0HHAA_N@Z ENDP ; gObjMonsterExpSingle
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ChaosCastle.h
;	COMDAT ??__Eg_iChaosCastle_MonsterItems@@YAXXZ
text$di	SEGMENT
??__Eg_iChaosCastle_MonsterItems@@YAXXZ PROC		; `dynamic initializer for 'g_iChaosCastle_MonsterItems'', COMDAT

; 359  : };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 337  : 	MAKE_ITEMNUM(14, 13),		1,								// 1  - 

  00009	6a 0d		 push	 13			; 0000000dH
  0000b	6a 0e		 push	 14			; 0000000eH
  0000d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00012	83 c4 08	 add	 esp, 8
  00015	a3 00 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA, eax
  0001a	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+4, 1

; 338  : 	MAKE_ITEMNUM(14, 14),		2,								// 1  - 

  00024	6a 0e		 push	 14			; 0000000eH
  00026	6a 0e		 push	 14			; 0000000eH
  00028	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0002d	83 c4 08	 add	 esp, 8
  00030	a3 08 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+8, eax
  00035	c7 05 0c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+12, 2

; 339  : 	
; 340  : 	MAKE_ITEMNUM(14, 13),		1,								// 2  - 

  0003f	6a 0d		 push	 13			; 0000000dH
  00041	6a 0e		 push	 14			; 0000000eH
  00043	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00048	83 c4 08	 add	 esp, 8
  0004b	a3 10 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+16, eax
  00050	c7 05 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+20, 1

; 341  : 	MAKE_ITEMNUM(14, 14),		3,								// 2  - 

  0005a	6a 0e		 push	 14			; 0000000eH
  0005c	6a 0e		 push	 14			; 0000000eH
  0005e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00063	83 c4 08	 add	 esp, 8
  00066	a3 18 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+24, eax
  0006b	c7 05 1c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+28, 3

; 342  : 	
; 343  : 	MAKE_ITEMNUM(14, 13),		1,								// 3  - 

  00075	6a 0d		 push	 13			; 0000000dH
  00077	6a 0e		 push	 14			; 0000000eH
  00079	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0007e	83 c4 08	 add	 esp, 8
  00081	a3 20 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+32, eax
  00086	c7 05 24 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+36, 1

; 344  : 	MAKE_ITEMNUM(14, 14),		3,								// 3  - 

  00090	6a 0e		 push	 14			; 0000000eH
  00092	6a 0e		 push	 14			; 0000000eH
  00094	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00099	83 c4 08	 add	 esp, 8
  0009c	a3 28 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+40, eax
  000a1	c7 05 2c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+44, 3

; 345  : 	
; 346  : 	MAKE_ITEMNUM(14, 13),		2,								// 4  - 

  000ab	6a 0d		 push	 13			; 0000000dH
  000ad	6a 0e		 push	 14			; 0000000eH
  000af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b4	83 c4 08	 add	 esp, 8
  000b7	a3 30 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+48, eax
  000bc	c7 05 34 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+52, 2

; 347  : 	MAKE_ITEMNUM(14, 14),		2,								// 4  - 

  000c6	6a 0e		 push	 14			; 0000000eH
  000c8	6a 0e		 push	 14			; 0000000eH
  000ca	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000cf	83 c4 08	 add	 esp, 8
  000d2	a3 38 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+56, eax
  000d7	c7 05 3c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+60, 2

; 348  : 	
; 349  : 	MAKE_ITEMNUM(14, 13),		2,								// 5  - 

  000e1	6a 0d		 push	 13			; 0000000dH
  000e3	6a 0e		 push	 14			; 0000000eH
  000e5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ea	83 c4 08	 add	 esp, 8
  000ed	a3 40 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+64, eax
  000f2	c7 05 44 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+68, 2

; 350  : 	MAKE_ITEMNUM(14, 14),		3,								// 5  - 

  000fc	6a 0e		 push	 14			; 0000000eH
  000fe	6a 0e		 push	 14			; 0000000eH
  00100	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00105	83 c4 08	 add	 esp, 8
  00108	a3 48 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+72, eax
  0010d	c7 05 4c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+76, 3

; 351  : 	
; 352  : 	MAKE_ITEMNUM(14, 13),		2,								// 6  - 

  00117	6a 0d		 push	 13			; 0000000dH
  00119	6a 0e		 push	 14			; 0000000eH
  0011b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00120	83 c4 08	 add	 esp, 8
  00123	a3 50 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+80, eax
  00128	c7 05 54 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+84, 2

; 353  : 	MAKE_ITEMNUM(14, 14),		3,								// 6  - 

  00132	6a 0e		 push	 14			; 0000000eH
  00134	6a 0e		 push	 14			; 0000000eH
  00136	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0013b	83 c4 08	 add	 esp, 8
  0013e	a3 58 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+88, eax
  00143	c7 05 5c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+92, 3
  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
??__Eg_iChaosCastle_MonsterItems@@YAXXZ ENDP		; `dynamic initializer for 'g_iChaosCastle_MonsterItems''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DragonEvent.h
;	COMDAT ?GetMapNumber@CDragonEvent@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMapNumber@CDragonEvent@@QAEEXZ PROC			; CDragonEvent::GetMapNumber, COMDAT
; _this$ = ecx

; 35   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 36   : 		return m_MapNumber;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8a 40 0c	 mov	 al, BYTE PTR [eax+12]

; 37   : 	}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetMapNumber@CDragonEvent@@QAEEXZ ENDP			; CDragonEvent::GetMapNumber
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\DragonEvent.h
;	COMDAT ?GetState@CDragonEvent@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetState@CDragonEvent@@QAEEXZ PROC			; CDragonEvent::GetState, COMDAT
; _this$ = ecx

; 30   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 31   : 		return EventState;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 32   : 	}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetState@CDragonEvent@@QAEEXZ ENDP			; CDragonEvent::GetState
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\gObjMonster.h
;	COMDAT ?TalkRefDel@CQeustNpcTeleport@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?TalkRefDel@CQeustNpcTeleport@@QAEXXZ PROC		; CQeustNpcTeleport::TalkRefDel, COMDAT
; _this$ = ecx

; 145  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 146  : 		EnterCriticalSection(&CsRef);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 147  : 		RefCount--;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001e	83 e9 01	 sub	 ecx, 1
  00021	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00024	89 0a		 mov	 DWORD PTR [edx], ecx

; 148  : 		if( RefCount < 0 )

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002c	7d 09		 jge	 SHORT $LN2@TalkRefDel

; 149  : 		{
; 150  : 			RefCount = 0;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN2@TalkRefDel:

; 151  : 		}
; 152  : 		LogAdd("QeustNpc RefCount Dec= %d", RefCount);

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	51		 push	 ecx
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CPKHJPAP@QeustNpc?5RefCount?5Dec?$DN?5?$CFd@
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00048	83 c4 08	 add	 esp, 8

; 153  : 		LeaveCriticalSection(&CsRef);

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	83 c0 04	 add	 eax, 4
  00051	50		 push	 eax
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 154  : 	}	

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?TalkRefDel@CQeustNpcTeleport@@QAEXXZ ENDP		; CQeustNpcTeleport::TalkRefDel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Include\ReadScript.h
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
tv93 = -184						; size = 4
$T1 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 26   : 	unsigned char ch;
; 27   : 	TokenString[0] = '\0';

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	6b c8 00	 imul	 ecx, eax, 0
  0001e	89 8d 4c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00024	83 bd 4c ff ff
	ff 64		 cmp	 DWORD PTR $T1[ebp], 100	; 00000064H
  0002b	73 02		 jae	 SHORT $LN31@GetToken
  0002d	eb 05		 jmp	 SHORT $LN32@GetToken
$LN31@GetToken:
  0002f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN32@GetToken:
  00034	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0003a	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?TokenString@@3PADA[edx], 0
$LN4@GetToken:

; 28   : 	do
; 29   : 	{
; 30   : 		if ( (ch =(unsigned char) fgetc(SMDFile)) == (BYTE)EOF) return END;

  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _fgetc
  0004c	83 c4 04	 add	 esp, 4
  0004f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00052	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00056	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0005c	75 0a		 jne	 SHORT $LN15@GetToken
  0005e	b8 02 00 00 00	 mov	 eax, 2
  00063	e9 d9 02 00 00	 jmp	 $LN7@GetToken
$LN15@GetToken:

; 31   : 		if (ch=='/' && (ch =(unsigned char) fgetc(SMDFile) )=='/')	

  00068	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0006c	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0006f	75 56		 jne	 SHORT $LN17@GetToken
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _fgetc
  0007c	83 c4 04	 add	 esp, 4
  0007f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00082	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00086	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00089	75 3c		 jne	 SHORT $LN17@GetToken
$LN5@GetToken:

; 32   : 		{
; 33   : 			while((ch != '\n') && (ch != (BYTE)EOF)) {			// 2003.09.02 H.J.I 

  0008b	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0008f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00092	74 1e		 je	 SHORT $LN6@GetToken
  00094	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00098	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0009d	74 13		 je	 SHORT $LN6@GetToken

; 34   : 				ch = (unsigned char) fgetc( SMDFile);

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _fgetc
  000aa	83 c4 04	 add	 esp, 4
  000ad	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 35   : 			}

  000b0	eb d9		 jmp	 SHORT $LN5@GetToken
$LN6@GetToken:

; 36   : 
; 37   : 			if (ch == (BYTE)EOF)

  000b2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000b6	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000bb	75 0a		 jne	 SHORT $LN17@GetToken

; 38   : 				return END;

  000bd	b8 02 00 00 00	 mov	 eax, 2
  000c2	e9 7a 02 00 00	 jmp	 $LN7@GetToken
$LN17@GetToken:

; 39   : 		}
; 40   : 	} while(  isspace(ch) );

  000c7	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _isspace
  000d1	83 c4 04	 add	 esp, 4
  000d4	85 c0		 test	 eax, eax
  000d6	0f 85 65 ff ff
	ff		 jne	 $LN4@GetToken

; 41   : 	
; 42   : 	char *p, TempString[100];
; 43   : 	switch(ch)

  000dc	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000e0	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], eax
  000e6	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv93[ebp]
  000ec	83 e9 22	 sub	 ecx, 34			; 00000022H
  000ef	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], ecx
  000f5	83 bd 48 ff ff
	ff 5b		 cmp	 DWORD PTR tv93[ebp], 91	; 0000005bH
  000fc	0f 87 86 01 00
	00		 ja	 $LN27@GetToken
  00102	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv93[ebp]
  00108	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN33@GetToken[edx]
  0010f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN34@GetToken[eax*4]
$LN18@GetToken:

; 44   : 	{	
; 45   : 	case '#':
; 46   : 		return CurrentToken = COMMAND;

  00116	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 35 ; 00000023H
  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00125	e9 17 02 00 00	 jmp	 $LN7@GetToken
$LN19@GetToken:

; 47   : 	case ';':
; 48   : 		return CurrentToken = SEMICOLON;

  0012a	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 59 ; 0000003bH
  00134	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00139	e9 03 02 00 00	 jmp	 $LN7@GetToken
$LN20@GetToken:

; 49   : 	case ',':
; 50   : 		return CurrentToken = COMMA;

  0013e	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 44 ; 0000002cH
  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0014d	e9 ef 01 00 00	 jmp	 $LN7@GetToken
$LN21@GetToken:

; 51   : 	case '{':
; 52   : 		return CurrentToken = LP;

  00152	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 123 ; 0000007bH
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00161	e9 db 01 00 00	 jmp	 $LN7@GetToken
$LN22@GetToken:

; 53   : 	case '}':
; 54   : 		return CurrentToken = RP;

  00166	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 125 ; 0000007dH
  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00175	e9 c7 01 00 00	 jmp	 $LN7@GetToken
$LN23@GetToken:

; 55   : 	case '0':	case '1':	case '2':	case '3':	case '4':
; 56   : 	case '5':	case '6':	case '7':	case '8':	case '9':
; 57   : 	case '.':	case '-':
; 58   : 		ungetc(ch,SMDFile);

  0017a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0017f	50		 push	 eax
  00180	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 _ungetc
  0018a	83 c4 08	 add	 esp, 8

; 59   : 		p = TempString;

  0018d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00190	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN9@GetToken:

; 60   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || isdigit(ch) || ch=='-') )

  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _getc
  0019e	83 c4 04	 add	 esp, 4
  001a1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  001a4	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  001a8	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  001ae	74 36		 je	 SHORT $LN10@GetToken
  001b0	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001b4	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001b7	74 1a		 je	 SHORT $LN24@GetToken
  001b9	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001bd	50		 push	 eax
  001be	e8 00 00 00 00	 call	 _isdigit
  001c3	83 c4 04	 add	 esp, 4
  001c6	85 c0		 test	 eax, eax
  001c8	75 09		 jne	 SHORT $LN24@GetToken
  001ca	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001ce	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  001d1	75 13		 jne	 SHORT $LN10@GetToken
$LN24@GetToken:

; 61   : 			*p++ = ch;

  001d3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001d6	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  001d9	88 08		 mov	 BYTE PTR [eax], cl
  001db	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  001de	83 c2 01	 add	 edx, 1
  001e1	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  001e4	eb ad		 jmp	 SHORT $LN9@GetToken
$LN10@GetToken:

; 62   : 		*p = 0;

  001e6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001e9	c6 00 00	 mov	 BYTE PTR [eax], 0

; 63   : 		TokenNumber = (float)atof(TempString);

  001ec	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _atof
  001f5	83 c4 04	 add	 esp, 4
  001f8	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?TokenNumber@@3MA

; 64   : 		//			sscanf(TempString," %f ",&TokenNumber);
; 65   : 		return CurrentToken = NUMBER;

  001fe	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 1
  00208	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0020d	e9 2f 01 00 00	 jmp	 $LN7@GetToken
$LN25@GetToken:

; 66   : 	case '"':
; 67   : 		p = TokenString;

  00212	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA
$LN11@GetToken:

; 68   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch!='"'))// || isalnum(ch)) )

  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _getc
  00224	83 c4 04	 add	 esp, 4
  00227	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0022a	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  0022e	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00234	74 1c		 je	 SHORT $LN12@GetToken
  00236	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0023a	83 f8 22	 cmp	 eax, 34			; 00000022H
  0023d	74 13		 je	 SHORT $LN12@GetToken

; 69   : 			*p++ = ch;

  0023f	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00242	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00245	88 08		 mov	 BYTE PTR [eax], cl
  00247	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  0024a	83 c2 01	 add	 edx, 1
  0024d	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00250	eb c7		 jmp	 SHORT $LN11@GetToken
$LN12@GetToken:

; 70   : 		if (ch!='"')

  00252	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00256	83 f8 22	 cmp	 eax, 34			; 00000022H
  00259	74 13		 je	 SHORT $LN26@GetToken

; 71   : 			ungetc(ch,SMDFile);

  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00260	50		 push	 eax
  00261	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00265	51		 push	 ecx
  00266	e8 00 00 00 00	 call	 _ungetc
  0026b	83 c4 08	 add	 esp, 8
$LN26@GetToken:

; 72   : 		*p = 0;

  0026e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00271	c6 00 00	 mov	 BYTE PTR [eax], 0

; 73   : 		return CurrentToken = NAME;

  00274	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0027e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00283	e9 b9 00 00 00	 jmp	 $LN7@GetToken
$LN27@GetToken:

; 74   : 	default:
; 75   : 		if (isalpha(ch))	

  00288	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0028c	50		 push	 eax
  0028d	e8 00 00 00 00	 call	 _isalpha
  00292	83 c4 04	 add	 esp, 4
  00295	85 c0		 test	 eax, eax
  00297	0f 84 95 00 00
	00		 je	 $LN28@GetToken

; 76   : 		{
; 77   : 			p = TokenString;

  0029d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA

; 78   : 			*p++ = ch;

  002a4	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002a7	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002aa	88 08		 mov	 BYTE PTR [eax], cl
  002ac	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  002af	83 c2 01	 add	 edx, 1
  002b2	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
$LN13@GetToken:

; 79   : 			while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || ch=='_' || isalnum(ch)) )

  002b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  002ba	50		 push	 eax
  002bb	e8 00 00 00 00	 call	 _getc
  002c0	83 c4 04	 add	 esp, 4
  002c3	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  002c6	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  002ca	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  002d0	74 36		 je	 SHORT $LN14@GetToken
  002d2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002d6	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  002d9	74 1a		 je	 SHORT $LN29@GetToken
  002db	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002df	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  002e2	74 11		 je	 SHORT $LN29@GetToken
  002e4	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 _isalnum
  002ee	83 c4 04	 add	 esp, 4
  002f1	85 c0		 test	 eax, eax
  002f3	74 13		 je	 SHORT $LN14@GetToken
$LN29@GetToken:

; 80   : 				*p++ = ch;

  002f5	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002f8	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002fb	88 08		 mov	 BYTE PTR [eax], cl
  002fd	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00300	83 c2 01	 add	 edx, 1
  00303	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00306	eb ad		 jmp	 SHORT $LN13@GetToken
$LN14@GetToken:

; 81   : 			ungetc(ch,SMDFile);

  00308	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0030d	50		 push	 eax
  0030e	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00312	51		 push	 ecx
  00313	e8 00 00 00 00	 call	 _ungetc
  00318	83 c4 08	 add	 esp, 8

; 82   : 			*p = 0;

  0031b	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0031e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 83   : 			return CurrentToken = NAME;

  00321	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0032b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00330	eb 0f		 jmp	 SHORT $LN7@GetToken
$LN28@GetToken:

; 84   : 		}
; 85   : 		return CurrentToken = SMD_ERROR;

  00332	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 60 ; 0000003cH
  0033c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
$LN7@GetToken:

; 86   : 	}
; 87   : }

  00341	5f		 pop	 edi
  00342	5e		 pop	 esi
  00343	5b		 pop	 ebx
  00344	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00347	33 cd		 xor	 ecx, ebp
  00349	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034e	8b e5		 mov	 esp, ebp
  00350	5d		 pop	 ebp
  00351	c3		 ret	 0
  00352	66 90		 npad	 2
$LN34@GetToken:
  00354	00 00 00 00	 DD	 $LN25@GetToken
  00358	00 00 00 00	 DD	 $LN18@GetToken
  0035c	00 00 00 00	 DD	 $LN20@GetToken
  00360	00 00 00 00	 DD	 $LN23@GetToken
  00364	00 00 00 00	 DD	 $LN19@GetToken
  00368	00 00 00 00	 DD	 $LN21@GetToken
  0036c	00 00 00 00	 DD	 $LN22@GetToken
  00370	00 00 00 00	 DD	 $LN27@GetToken
$LN33@GetToken:
  00374	00		 DB	 0
  00375	01		 DB	 1
  00376	07		 DB	 7
  00377	07		 DB	 7
  00378	07		 DB	 7
  00379	07		 DB	 7
  0037a	07		 DB	 7
  0037b	07		 DB	 7
  0037c	07		 DB	 7
  0037d	07		 DB	 7
  0037e	02		 DB	 2
  0037f	03		 DB	 3
  00380	03		 DB	 3
  00381	07		 DB	 7
  00382	03		 DB	 3
  00383	03		 DB	 3
  00384	03		 DB	 3
  00385	03		 DB	 3
  00386	03		 DB	 3
  00387	03		 DB	 3
  00388	03		 DB	 3
  00389	03		 DB	 3
  0038a	03		 DB	 3
  0038b	03		 DB	 3
  0038c	07		 DB	 7
  0038d	04		 DB	 4
  0038e	07		 DB	 7
  0038f	07		 DB	 7
  00390	07		 DB	 7
  00391	07		 DB	 7
  00392	07		 DB	 7
  00393	07		 DB	 7
  00394	07		 DB	 7
  00395	07		 DB	 7
  00396	07		 DB	 7
  00397	07		 DB	 7
  00398	07		 DB	 7
  00399	07		 DB	 7
  0039a	07		 DB	 7
  0039b	07		 DB	 7
  0039c	07		 DB	 7
  0039d	07		 DB	 7
  0039e	07		 DB	 7
  0039f	07		 DB	 7
  003a0	07		 DB	 7
  003a1	07		 DB	 7
  003a2	07		 DB	 7
  003a3	07		 DB	 7
  003a4	07		 DB	 7
  003a5	07		 DB	 7
  003a6	07		 DB	 7
  003a7	07		 DB	 7
  003a8	07		 DB	 7
  003a9	07		 DB	 7
  003aa	07		 DB	 7
  003ab	07		 DB	 7
  003ac	07		 DB	 7
  003ad	07		 DB	 7
  003ae	07		 DB	 7
  003af	07		 DB	 7
  003b0	07		 DB	 7
  003b1	07		 DB	 7
  003b2	07		 DB	 7
  003b3	07		 DB	 7
  003b4	07		 DB	 7
  003b5	07		 DB	 7
  003b6	07		 DB	 7
  003b7	07		 DB	 7
  003b8	07		 DB	 7
  003b9	07		 DB	 7
  003ba	07		 DB	 7
  003bb	07		 DB	 7
  003bc	07		 DB	 7
  003bd	07		 DB	 7
  003be	07		 DB	 7
  003bf	07		 DB	 7
  003c0	07		 DB	 7
  003c1	07		 DB	 7
  003c2	07		 DB	 7
  003c3	07		 DB	 7
  003c4	07		 DB	 7
  003c5	07		 DB	 7
  003c6	07		 DB	 7
  003c7	07		 DB	 7
  003c8	07		 DB	 7
  003c9	07		 DB	 7
  003ca	07		 DB	 7
  003cb	07		 DB	 7
  003cc	07		 DB	 7
  003cd	05		 DB	 5
  003ce	07		 DB	 7
  003cf	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\map
;	COMDAT ??$_Kfn@$$CBHU_TERRAIN_INFO@@@?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_TERRAIN_INFO@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHU_TERRAIN_INFO@@@?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_TERRAIN_INFO@@@1@@Z PROC ; std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0>::_Kfn<int const ,_TERRAIN_INFO>, COMDAT

; 68   :     static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val) { // extract key from element value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 69   :         return _Val.first;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 70   :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Kfn@$$CBHU_TERRAIN_INFO@@@?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_TERRAIN_INFO@@@1@@Z ENDP ; std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0>::_Kfn<int const ,_TERRAIN_INFO>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > const >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > const >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z
_TEXT	SEGMENT
tv78 = -72						; size = 4
_this$ = -4						; size = 4
__Bound$ = 8						; size = 4
__Keyval$ = 12						; size = 4
??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Lower_bound_duplicate<int>, COMDAT
; _this$ = ecx

; 1694 :     bool _Lower_bound_duplicate(const _Nodeptr _Bound, const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Bound$[ebp]
  0000f	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  00013	85 c9		 test	 ecx, ecx
  00015	75 33		 jne	 SHORT $LN3@Lower_boun
  00017	8b 55 08	 mov	 edx, DWORD PTR __Bound$[ebp]
  0001a	83 c2 10	 add	 edx, 16			; 00000010H
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHU_TERRAIN_INFO@@@?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_TERRAIN_INFO@@@1@@Z ; std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0>::_Kfn<int const ,_TERRAIN_INFO>
  00023	83 c4 04	 add	 esp, 4
  00026	50		 push	 eax
  00027	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Getcomp@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Getcomp
  00033	8b c8		 mov	 ecx, eax
  00035	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0003a	0f b6 c8	 movzx	 ecx, al
  0003d	85 c9		 test	 ecx, ecx
  0003f	75 09		 jne	 SHORT $LN3@Lower_boun
  00041	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  00048	eb 07		 jmp	 SHORT $LN4@Lower_boun
$LN3@Lower_boun:
  0004a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN4@Lower_boun:
  00051	8a 45 b8	 mov	 al, BYTE PTR tv78[ebp]

; 1696 :     }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Lower_bound_duplicate<int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@1@ABH@Z
_TEXT	SEGMENT
__Trynode$ = -24					; size = 4
__Result$ = -20						; size = 12
__Scary$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@1@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Find_lower_bound<int>, COMDAT
; _this$ = ecx

; 1699 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1700 :         const auto _Scary = _Get_scary();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1701 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001f	89 55 ec	 mov	 DWORD PTR __Result$[ebp], edx
  00022	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 0
  00029	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	89 4d f4	 mov	 DWORD PTR __Result$[ebp+8], ecx

; 1702 :         _Nodeptr _Trynode = _Result._Location._Parent;

  00031	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]
  00034	89 45 e8	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN2@Find_lower:

; 1703 :         while (!_Trynode->_Isnil) {

  00037	8b 45 e8	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0003a	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  0003e	85 c9		 test	 ecx, ecx
  00040	75 59		 jne	 SHORT $LN3@Find_lower

; 1704 :             _Result._Location._Parent = _Trynode;

  00042	8b 45 e8	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00045	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 1705 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  00048	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d e8	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  0004f	83 c1 10	 add	 ecx, 16			; 00000010H
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHU_TERRAIN_INFO@@@?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_TERRAIN_INFO@@@1@@Z ; std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0>::_Kfn<int const ,_TERRAIN_INFO>
  00058	83 c4 04	 add	 esp, 4
  0005b	50		 push	 eax
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Getcomp@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Getcomp
  00064	8b c8		 mov	 ecx, eax
  00066	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0006b	0f b6 d0	 movzx	 edx, al
  0006e	85 d2		 test	 edx, edx
  00070	74 12		 je	 SHORT $LN4@Find_lower

; 1706 :                 _Result._Location._Child = _Tree_child::_Right;

  00072	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 0

; 1707 :                 _Trynode                 = _Trynode->_Right;

  00079	8b 45 e8	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0007c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0007f	89 4d e8	 mov	 DWORD PTR __Trynode$[ebp], ecx

; 1708 :             } else {

  00082	eb 15		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1709 :                 _Result._Location._Child = _Tree_child::_Left;

  00084	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 1

; 1710 :                 _Result._Bound           = _Trynode;

  0008b	8b 45 e8	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008e	89 45 f4	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1711 :                 _Trynode                 = _Trynode->_Left;

  00091	8b 45 e8	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00094	8b 08		 mov	 ecx, DWORD PTR [eax]
  00096	89 4d e8	 mov	 DWORD PTR __Trynode$[ebp], ecx
$LN5@Find_lower:

; 1712 :             }
; 1713 :         }

  00099	eb 9c		 jmp	 SHORT $LN2@Find_lower
$LN3@Find_lower:

; 1714 : 
; 1715 :         return _Result;

  0009b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0009e	8b 4d ec	 mov	 ecx, DWORD PTR __Result$[ebp]
  000a1	89 08		 mov	 DWORD PTR [eax], ecx
  000a3	8b 55 f0	 mov	 edx, DWORD PTR __Result$[ebp+4]
  000a6	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000a9	8b 4d f4	 mov	 ecx, DWORD PTR __Result$[ebp+8]
  000ac	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000af	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1716 :     }

  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 08 00	 ret	 8
??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@1@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Find_lower_bound<int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@YAPAU?$pair@$$CBHU_TERRAIN_INFO@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@YAPAU?$pair@$$CBHU_TERRAIN_INFO@@@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,_TERRAIN_INFO> >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@YAPAU?$pair@$$CBHU_TERRAIN_INFO@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,_TERRAIN_INFO> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$_Find@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z
_TEXT	SEGMENT
__Loc$ = -16						; size = 12
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??$_Find@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Find<int>, COMDAT
; _this$ = ecx

; 1457 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1458 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f0	 lea	 ecx, DWORD PTR __Loc$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Find_lower_bound<int>

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  0001c	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f8	 mov	 ecx, DWORD PTR __Loc$[ebp+8]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Lower_bound_duplicate<int>
  0002c	0f b6 d0	 movzx	 edx, al
  0002f	85 d2		 test	 edx, edx
  00031	74 05		 je	 SHORT $LN2@Find

; 1460 :             return _Loc._Bound;

  00033	8b 45 f8	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  00036	eb 0a		 jmp	 SHORT $LN1@Find
$LN2@Find:

; 1461 :         }
; 1462 : 
; 1463 :         return _Get_scary()->_Myhead;

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary
  00040	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Find:

; 1464 :     }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
??$_Find@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Find<int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@SAPAU?$pair@$$CBHU_TERRAIN_INFO@@@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAU?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@SAPAU?$pair@$$CBHU_TERRAIN_INFO@@@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<int const ,_TERRAIN_INFO> *>::pointer_to, COMDAT

; 146  :     _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 147  :         return _STD addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@YAPAU?$pair@$$CBHU_TERRAIN_INFO@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_TERRAIN_INFO> >
  00012	83 c4 04	 add	 esp, 4

; 148  :     }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@SAPAU?$pair@$$CBHU_TERRAIN_INFO@@@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<int const ,_TERRAIN_INFO> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator->, COMDAT
; _this$ = ecx

; 276  :     _NODISCARD pointer operator->() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator*
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?pointer_to@?$pointer_traits@PAU?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@SAPAU?$pair@$$CBHU_TERRAIN_INFO@@@2@AAU32@@Z ; std::pointer_traits<std::pair<int const ,_TERRAIN_INFO> *>::pointer_to
  0001a	83 c4 04	 add	 esp, 4

; 278  :     }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator*, COMDAT
; _this$ = ecx

; 272  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 273  :         return const_cast<reference>(_Mybase::operator*());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator*

; 274  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,std::_Iterator_base0>
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv75 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator==, COMDAT
; _this$ = ecx

; 227  :     _NODISCARD bool operator==(const _Tree_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 228  : #if _ITERATOR_DEBUG_LEVEL == 2
; 229  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 230  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 231  : 
; 232  :         return this->_Ptr == _Right._Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00016	75 09		 jne	 SHORT $LN3@operator
  00018	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  0001f	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00021	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN4@operator:
  00028	8a 45 b8	 mov	 al, BYTE PTR tv75[ebp]

; 233  :     }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator*, COMDAT
; _this$ = ecx

; 178  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 179  : #if _ITERATOR_DEBUG_LEVEL == 2
; 180  :         const auto _Mycont = static_cast<const _Mytree*>(this->_Getcont());
; 181  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized map/set iterator");
; 182  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end map/set iterator");
; 183  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 184  : 
; 185  :         return this->_Ptr->_Myval;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	83 c0 10	 add	 eax, 16			; 00000010H

; 186  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 40   :         this->_Adopt(_Plist);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 41   :     }

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,_TERRAIN_INFO>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1348 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1349 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,_TERRAIN_INFO>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 2050 :     const _Scary_val* _Get_scary() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@ABV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > const >
  00015	83 c4 04	 add	 esp, 4

; 2052 :     }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 2046 :     _Scary_val* _Get_scary() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >
  00015	83 c4 04	 add	 esp, 4

; 2048 :     }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcomp@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 2034 :     const key_compare& _Getcomp() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2035 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,_TERRAIN_INFO>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,1>,1>::_Get_first

; 2036 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getcomp@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::find, COMDAT
; _this$ = ecx

; 1467 :     _NODISCARD iterator find(const key_type& _Keyval) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary
  00014	50		 push	 eax
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??$_Find@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Find<int>
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00025	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z
  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1469 :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__Scary$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::end, COMDAT
; _this$ = ecx

; 1248 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1249 :         const auto _Scary = _Get_scary();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	52		 push	 edx
  00021	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z
  00029	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1251 :     }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\TerrainManager.h
;	COMDAT ?GetMinLevel@CTerrainManager@@QAEHH@Z
_TEXT	SEGMENT
$T1 = -76						; size = 4
_it$ = -8						; size = 4
_this$ = -4						; size = 4
_MapNumber$ = 8						; size = 4
?GetMinLevel@CTerrainManager@@QAEHH@Z PROC		; CTerrainManager::GetMinLevel, COMDAT
; _this$ = ecx

; 27   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 28   : 		std::map<int, _TERRAIN_INFO>::iterator it = this->m_mTerrainMap.find(MapNumber);

  0000c	8d 45 08	 lea	 eax, DWORD PTR _MapNumber$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::find

; 29   : 
; 30   : 		if(it == this->m_mTerrainMap.end())

  0001c	8d 45 b4	 lea	 eax, DWORD PTR $T1[ebp]
  0001f	50		 push	 eax
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::end
  00028	50		 push	 eax
  00029	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  0002c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator==
  00031	0f b6 c8	 movzx	 ecx, al
  00034	85 c9		 test	 ecx, ecx
  00036	74 04		 je	 SHORT $LN2@GetMinLeve

; 31   : 			return 0;

  00038	33 c0		 xor	 eax, eax
  0003a	eb 0b		 jmp	 SHORT $LN1@GetMinLeve
$LN2@GetMinLeve:

; 32   : 		
; 33   : 		return it->second.iMinLevel;

  0003c	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  0003f	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator->
  00044	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN1@GetMinLeve:

; 34   : 	}

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?GetMinLevel@CTerrainManager@@QAEHH@Z ENDP		; CTerrainManager::GetMinLevel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\TerrainManager.h
;	COMDAT ?Size@CTerrainManager@@QAE?BHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Size@CTerrainManager@@QAE?BHXZ PROC			; CTerrainManager::Size, COMDAT
; _this$ = ecx

; 22   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 23   : 		return m_iSize;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 24   : 	}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?Size@CTerrainManager@@QAE?BHXZ ENDP			; CTerrainManager::Size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
tv65 = -72						; size = 4
_this$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 126  :     constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  :         return _Left < _Right;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00016	7d 09		 jge	 SHORT $LN3@operator
  00018	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  0001f	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00021	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
$LN4@operator:
  00028	8a 45 b8	 mov	 al, BYTE PTR tv65[ebp]

; 128  :     }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?MsgOutput@@YAXHPADZZ
_TEXT	SEGMENT
_pArguments$ = -520					; size = 4
_szBuffer$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_msg$ = 12						; size = 4
?MsgOutput@@YAXHPADZZ PROC				; MsgOutput, COMDAT

; 33506: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 02 00
	00		 sub	 esp, 652		; 0000028cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 33507: 	char		szBuffer[512]="";

  00016	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  0001b	88 85 fc fd ff
	ff		 mov	 BYTE PTR _szBuffer$[ebp], al
  00021	68 ff 01 00 00	 push	 511			; 000001ffH
  00026	6a 00		 push	 0
  00028	8d 85 fd fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp+1]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _memset
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 33508: 	va_list		pArguments;
; 33509: 	
; 33510: 	va_start(pArguments, msg);

  00037	8d 45 10	 lea	 eax, DWORD PTR _msg$[ebp+4]
  0003a	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _pArguments$[ebp], eax

; 33511:     vsprintf(szBuffer, msg, pArguments);

  00040	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _pArguments$[ebp]
  00046	50		 push	 eax
  00047	8b 4d 0c	 mov	 ecx, DWORD PTR _msg$[ebp]
  0004a	51		 push	 ecx
  0004b	8d 95 fc fd ff
	ff		 lea	 edx, DWORD PTR _szBuffer$[ebp]
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 _vsprintf
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 33512:     va_end(pArguments);

  0005a	c7 85 f8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _pArguments$[ebp], 0

; 33513: 			
; 33514: 	GCServerMsgStringSend(szBuffer, aIndex, 1);	

  00064	6a 01		 push	 1
  00066	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00069	50		 push	 eax
  0006a	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR _szBuffer$[ebp]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH

; 33515: }

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007f	33 cd		 xor	 ecx, ebp
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?MsgOutput@@YAXHPADZZ ENDP				; MsgOutput
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?MakeRewardSetItem@@YAXHEEH@Z
_TEXT	SEGMENT
tv76 = -108						; size = 4
_tmpSetOption$ = -40					; size = 4
_Option3$ = -36						; size = 4
_Option2$ = -32						; size = 4
_Option1$ = -28						; size = 4
_optionc$ = -24						; size = 4
_option3rand$ = -20					; size = 4
_option2rand$ = -16					; size = 4
_option1rand$ = -12					; size = 4
_SetOption$ = -8					; size = 4
_itemnum$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_cDropX$ = 12						; size = 1
_cDropY$ = 16						; size = 1
_iRewardType$ = 20					; size = 4
?MakeRewardSetItem@@YAXHEEH@Z PROC			; MakeRewardSetItem, COMDAT

; 32289: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 32290: 	int itemnum = gSetItemOption.GenRandomItemNum();

  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  0000e	e8 00 00 00 00	 call	 ?GenRandomItemNum@CSetItemOption@@QAEHXZ ; CSetItemOption::GenRandomItemNum
  00013	89 45 fc	 mov	 DWORD PTR _itemnum$[ebp], eax

; 32291: 	int	SetOption = gSetItemOption.GenSetOption(itemnum);

  00016	8b 45 fc	 mov	 eax, DWORD PTR _itemnum$[ebp]
  00019	50		 push	 eax
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  0001f	e8 00 00 00 00	 call	 ?GenSetOption@CSetItemOption@@QAEHH@Z ; CSetItemOption::GenSetOption
  00024	89 45 f8	 mov	 DWORD PTR _SetOption$[ebp], eax

; 32292: 
; 32293: 	int option1rand, option2rand, option3rand, optionc;	
; 32294: 	int	Option1 = 0, Option2 = 0, Option3 = 0;

  00027	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0
  0002e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0
  00035	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 32295: 
; 32296: 	
; 32297: 	option1rand = 6;				//  1 ()   6/100

  0003c	c7 45 f4 06 00
	00 00		 mov	 DWORD PTR _option1rand$[ebp], 6

; 32298: 	option2rand = 4;				//  2 ()   4/100

  00043	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR _option2rand$[ebp], 4

; 32299: 	option3rand = (rand()%100);		//  3 ()   /100

  0004a	e8 00 00 00 00	 call	 _rand
  0004f	99		 cdq
  00050	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00055	f7 f9		 idiv	 ecx
  00057	89 55 ec	 mov	 DWORD PTR _option3rand$[ebp], edx

; 32300: 	optionc		= (rand()%3);

  0005a	e8 00 00 00 00	 call	 _rand
  0005f	99		 cdq
  00060	b9 03 00 00 00	 mov	 ecx, 3
  00065	f7 f9		 idiv	 ecx
  00067	89 55 e8	 mov	 DWORD PTR _optionc$[ebp], edx

; 32301: 
; 32302: 	//    .
; 32303: 	if((rand()%100) < option2rand ) Option2 = 1;

  0006a	e8 00 00 00 00	 call	 _rand
  0006f	99		 cdq
  00070	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00075	f7 f9		 idiv	 ecx
  00077	3b 55 f0	 cmp	 edx, DWORD PTR _option2rand$[ebp]
  0007a	7d 07		 jge	 SHORT $LN4@MakeReward
  0007c	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 1
$LN4@MakeReward:

; 32304: 
; 32305: 	switch( optionc )

  00083	8b 45 e8	 mov	 eax, DWORD PTR _optionc$[ebp]
  00086	89 45 94	 mov	 DWORD PTR tv76[ebp], eax
  00089	83 7d 94 00	 cmp	 DWORD PTR tv76[ebp], 0
  0008d	74 0e		 je	 SHORT $LN5@MakeReward
  0008f	83 7d 94 01	 cmp	 DWORD PTR tv76[ebp], 1
  00093	74 17		 je	 SHORT $LN7@MakeReward
  00095	83 7d 94 02	 cmp	 DWORD PTR tv76[ebp], 2
  00099	74 20		 je	 SHORT $LN9@MakeReward
  0009b	eb 2b		 jmp	 SHORT $LN2@MakeReward
$LN5@MakeReward:

; 32306: 	{
; 32307: 	case 0 :
; 32308: 		if( option3rand < 4 ) Option3 = 3;	// 

  0009d	83 7d ec 04	 cmp	 DWORD PTR _option3rand$[ebp], 4
  000a1	7d 07		 jge	 SHORT $LN6@MakeReward
  000a3	c7 45 dc 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3
$LN6@MakeReward:

; 32309: 		break;

  000aa	eb 1c		 jmp	 SHORT $LN2@MakeReward
$LN7@MakeReward:

; 32310: 	case 1 :
; 32311: 		if( option3rand < 8 ) Option3 = 2;	// 

  000ac	83 7d ec 08	 cmp	 DWORD PTR _option3rand$[ebp], 8
  000b0	7d 07		 jge	 SHORT $LN8@MakeReward
  000b2	c7 45 dc 02 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 2
$LN8@MakeReward:

; 32312: 		break;

  000b9	eb 0d		 jmp	 SHORT $LN2@MakeReward
$LN9@MakeReward:

; 32313: 	case 2 :
; 32314: 		if( option3rand < 12 ) Option3 = 1;	// 

  000bb	83 7d ec 0c	 cmp	 DWORD PTR _option3rand$[ebp], 12 ; 0000000cH
  000bf	7d 07		 jge	 SHORT $LN2@MakeReward
  000c1	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 1
$LN2@MakeReward:

; 32315: 		break;
; 32316: 	}
; 32317: 
; 32318: 	//   .
; 32319: 	Option1 = 1;

  000c8	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 1

; 32320: 
; 32321: 	//  
; 32322: 	if( cDropX == 0 && cDropY == 0 )

  000cf	0f b6 45 0c	 movzx	 eax, BYTE PTR _cDropX$[ebp]
  000d3	85 c0		 test	 eax, eax
  000d5	75 36		 jne	 SHORT $LN11@MakeReward
  000d7	0f b6 45 10	 movzx	 eax, BYTE PTR _cDropY$[ebp]
  000db	85 c0		 test	 eax, eax
  000dd	75 2e		 jne	 SHORT $LN11@MakeReward

; 32323: 	{
; 32324: 		cDropX = (BYTE)gObj[aIndex].X;

  000df	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ec	8a 94 01 04 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+260]
  000f3	88 55 0c	 mov	 BYTE PTR _cDropX$[ebp], dl

; 32325: 		cDropY = (BYTE)gObj[aIndex].Y;

  000f6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00103	8a 94 01 06 01
	00 00		 mov	 dl, BYTE PTR [ecx+eax+262]
  0010a	88 55 10	 mov	 BYTE PTR _cDropY$[ebp], dl
$LN11@MakeReward:

; 32326: 	}
; 32327: 
; 32328: #ifdef MODIFY_KUNDUN_ITEM_DROP_MAP_20060216	
; 32329: 	ItemSerialCreateSend(aIndex, iMapnumber, cDropX, cDropY, itemnum, 
; 32330: 						 0, (BYTE)0, Option1, Option2, Option3, aIndex, 0, SetOption);
; 32331: #else
; 32332: 	ItemSerialCreateSend(aIndex, gObj[aIndex].MapNumber, cDropX, cDropY, itemnum, 

  0010d	6a 00		 push	 0
  0010f	0f b6 45 f8	 movzx	 eax, BYTE PTR _SetOption$[ebp]
  00113	50		 push	 eax
  00114	6a 00		 push	 0
  00116	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00119	51		 push	 ecx
  0011a	0f b6 55 dc	 movzx	 edx, BYTE PTR _Option3$[ebp]
  0011e	52		 push	 edx
  0011f	0f b6 45 e0	 movzx	 eax, BYTE PTR _Option2$[ebp]
  00123	50		 push	 eax
  00124	0f b6 4d e4	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  00128	51		 push	 ecx
  00129	6a 00		 push	 0
  0012b	6a 00		 push	 0
  0012d	8b 55 fc	 mov	 edx, DWORD PTR _itemnum$[ebp]
  00130	52		 push	 edx
  00131	0f b6 45 10	 movzx	 eax, BYTE PTR _cDropY$[ebp]
  00135	50		 push	 eax
  00136	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _cDropX$[ebp]
  0013a	51		 push	 ecx
  0013b	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00142	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00147	0f b6 8c 10 09
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+265]
  0014f	51		 push	 ecx
  00150	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00153	52		 push	 edx
  00154	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00159	83 c4 38	 add	 esp, 56			; 00000038H

; 32333: 						 0, (BYTE)0, Option1, Option2, Option3, aIndex, 0, SetOption);
; 32334: #endif // #ifdef MODIFY_KUNDUN_ITEM_DROP_MAP_20060216
; 32335: 
; 32336: 	//   
; 32337: #ifdef UPDATE_SET_ITEM_DROP_LOG_20080420	//   
; 32338: 	int tmpSetOption = 0;

  0015c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _tmpSetOption$[ebp], 0

; 32339: 
; 32340: 	if( SetOption & 0x01)

  00163	8b 45 f8	 mov	 eax, DWORD PTR _SetOption$[ebp]
  00166	83 e0 01	 and	 eax, 1
  00169	74 09		 je	 SHORT $LN12@MakeReward

; 32341: 	{
; 32342: 		tmpSetOption = 1;

  0016b	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _tmpSetOption$[ebp], 1

; 32343: 	}

  00172	eb 0f		 jmp	 SHORT $LN13@MakeReward
$LN12@MakeReward:

; 32344: 	else if( SetOption & 0x02 )

  00174	8b 45 f8	 mov	 eax, DWORD PTR _SetOption$[ebp]
  00177	83 e0 02	 and	 eax, 2
  0017a	74 07		 je	 SHORT $LN13@MakeReward

; 32345: 	{
; 32346: 		tmpSetOption = 2;

  0017c	c7 45 d8 02 00
	00 00		 mov	 DWORD PTR _tmpSetOption$[ebp], 2
$LN13@MakeReward:

; 32347: 	}
; 32348: 
; 32349: 	if( iRewardType == 1 )

  00183	83 7d 14 01	 cmp	 DWORD PTR _iRewardType$[ebp], 1
  00187	75 5b		 jne	 SHORT $LN15@MakeReward

; 32350: 	{
; 32351: 		LogAddTD("[Reward][KUNDUN] [%s][%s] Set Item itemnum:[%d] skill:[%d] luck:[%d] option:[%d] SetOption:[%d], SetName:[%s]",			 

  00189	8b 45 d8	 mov	 eax, DWORD PTR _tmpSetOption$[ebp]
  0018c	50		 push	 eax
  0018d	8b 4d fc	 mov	 ecx, DWORD PTR _itemnum$[ebp]
  00190	51		 push	 ecx
  00191	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  00196	e8 00 00 00 00	 call	 ?GetSetOptionName@CSetItemOption@@QAEPADHH@Z ; CSetItemOption::GetSetOptionName
  0019b	50		 push	 eax
  0019c	8b 55 f8	 mov	 edx, DWORD PTR _SetOption$[ebp]
  0019f	52		 push	 edx
  001a0	8b 45 dc	 mov	 eax, DWORD PTR _Option3$[ebp]
  001a3	50		 push	 eax
  001a4	8b 4d e0	 mov	 ecx, DWORD PTR _Option2$[ebp]
  001a7	51		 push	 ecx
  001a8	8b 55 e4	 mov	 edx, DWORD PTR _Option1$[ebp]
  001ab	52		 push	 edx
  001ac	8b 45 fc	 mov	 eax, DWORD PTR _itemnum$[ebp]
  001af	50		 push	 eax
  001b0	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001bd	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  001c1	50		 push	 eax
  001c2	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001cf	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  001d3	50		 push	 eax
  001d4	68 00 00 00 00	 push	 OFFSET ??_C@_0HC@BKBHDGJF@?$FL?$KB?Z?$KB?YReward?$FN?$FLKUNDUN?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5S@
  001d9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001df	83 c4 24	 add	 esp, 36			; 00000024H

; 32352: 			 gObj[aIndex].AccountID, 
; 32353: 			 gObj[aIndex].Name,
; 32354: 			 itemnum, Option1, Option2, Option3,SetOption,
; 32355: 			 gSetItemOption.GetSetOptionName(itemnum, tmpSetOption));
; 32356: 	}

  001e2	eb 59		 jmp	 SHORT $LN1@MakeReward
$LN15@MakeReward:

; 32357: 	else
; 32358: 	{
; 32359: 		LogAddTD("[Reward][Etc] [%s][%s] Set Item itemnum:[%d] skill:[%d] luck:[%d] option:[%d] SetOption:[%d], SetName:[%s]",			 

  001e4	8b 45 d8	 mov	 eax, DWORD PTR _tmpSetOption$[ebp]
  001e7	50		 push	 eax
  001e8	8b 4d fc	 mov	 ecx, DWORD PTR _itemnum$[ebp]
  001eb	51		 push	 ecx
  001ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  001f1	e8 00 00 00 00	 call	 ?GetSetOptionName@CSetItemOption@@QAEPADHH@Z ; CSetItemOption::GetSetOptionName
  001f6	50		 push	 eax
  001f7	8b 55 f8	 mov	 edx, DWORD PTR _SetOption$[ebp]
  001fa	52		 push	 edx
  001fb	8b 45 dc	 mov	 eax, DWORD PTR _Option3$[ebp]
  001fe	50		 push	 eax
  001ff	8b 4d e0	 mov	 ecx, DWORD PTR _Option2$[ebp]
  00202	51		 push	 ecx
  00203	8b 55 e4	 mov	 edx, DWORD PTR _Option1$[ebp]
  00206	52		 push	 edx
  00207	8b 45 fc	 mov	 eax, DWORD PTR _itemnum$[ebp]
  0020a	50		 push	 eax
  0020b	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00212	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00218	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  0021c	50		 push	 eax
  0021d	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00224	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0022a	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  0022e	50		 push	 eax
  0022f	68 00 00 00 00	 push	 OFFSET ??_C@_0GL@CFJINBHJ@?$FLReward?$FN?$FLEtc?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Set?5Item@
  00234	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0023a	83 c4 24	 add	 esp, 36			; 00000024H
$LN1@MakeReward:

; 32360: 			 gObj[aIndex].AccountID, 
; 32361: 			 gObj[aIndex].Name,
; 32362: 			 itemnum, Option1, Option2, Option3,SetOption,
; 32363: 			 gSetItemOption.GetSetOptionName(itemnum, tmpSetOption));
; 32364: 	}
; 32365: #else	// UPDATE_SET_ITEM_DROP_LOG_20080420
; 32366: 	if( iRewardType == 1 )
; 32367: 	{
; 32368: 		LogAddTD("[Reward][KUNDUN] [%s][%s] Set Item itemnum:[%d] skill:[%d] luck:[%d] option:[%d] SetOption:[%d]",			 
; 32369: 			 gObj[aIndex].AccountID, 
; 32370: 			 gObj[aIndex].Name,
; 32371: 			 itemnum, Option1, Option2, Option3,SetOption);
; 32372: 	}
; 32373: 	else
; 32374: 	{
; 32375: 		LogAddTD("[Reward][Etc] [%s][%s] Set Item itemnum:[%d] skill:[%d] luck:[%d] option:[%d] SetOption:[%d]",			 
; 32376: 			 gObj[aIndex].AccountID, 
; 32377: 			 gObj[aIndex].Name,
; 32378: 			 itemnum, Option1, Option2, Option3,SetOption);
; 32379: 	}
; 32380: #endif	// UPDATE_SET_ITEM_DROP_LOG_20080420
; 32381: 	
; 32382: }

  0023d	5f		 pop	 edi
  0023e	5e		 pop	 esi
  0023f	5b		 pop	 ebx
  00240	8b e5		 mov	 esp, ebp
  00242	5d		 pop	 ebp
  00243	c3		 ret	 0
?MakeRewardSetItem@@YAXHEEH@Z ENDP			; MakeRewardSetItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjFixInventoryPointer@@YA_NH@Z
_TEXT	SEGMENT
_n$1 = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjFixInventoryPointer@@YA_NH@Z PROC			; gObjFixInventoryPointer, COMDAT

; 14768: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14769: 	if (!gObjIsConnected(aIndex)) {

  00009	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00012	83 c4 04	 add	 esp, 4
  00015	85 c0		 test	 eax, eax
  00017	75 39		 jne	 SHORT $LN5@gObjFixInv

; 14770: 		LogAdd("[Fix Inv.Ptr] [%s][%s] - disconnected", 

  00019	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00026	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0002a	52		 push	 edx
  0002b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00038	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0003c	52		 push	 edx
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KONHFAKK@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5discon@
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14771: 			gObj[aIndex].AccountID, 
; 14772: 			gObj[aIndex].Name
; 14773: 			);
; 14774: 		return false;

  0004b	32 c0		 xor	 al, al
  0004d	e9 6a 01 00 00	 jmp	 $LN1@gObjFixInv
$LN5@gObjFixInv:

; 14775: 	}
; 14776: 	
; 14777: 	if (gObj[aIndex].pInventory == gObj[aIndex].Inventory1) {

  00052	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00059	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00060	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00066	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006c	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00073	3b 84 0e 6c 0c
	00 00		 cmp	 eax, DWORD PTR [esi+ecx+3180]
  0007a	75 07		 jne	 SHORT $LN6@gObjFixInv

; 14778: 		//     .
; 14779: 		return true;

  0007c	b0 01		 mov	 al, 1
  0007e	e9 39 01 00 00	 jmp	 $LN1@gObjFixInv
$LN6@gObjFixInv:

; 14780: 	}
; 14781: 	
; 14782: 	if (gObj[aIndex].pInventory == gObj[aIndex].Inventory2) {

  00083	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0008a	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00091	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00097	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009d	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  000a4	3b 84 0e 78 0c
	00 00		 cmp	 eax, DWORD PTR [esi+ecx+3192]
  000ab	0f 85 c1 00 00
	00		 jne	 $LN7@gObjFixInv

; 14783: #ifdef ITEM_DUPLICATE_PREVENT_PATCH_BUGFIX_20040825		//     
; 14784: 		if (gObj[aIndex].pTransaction == 1) {

  000b1	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000be	0f be 94 01 68
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3176]
  000c6	83 fa 01	 cmp	 edx, 1
  000c9	75 39		 jne	 SHORT $LN9@gObjFixInv

; 14785: 			//    (,  ) . (0: / 2:COMMIT / 3:ROLLBACK)
; 14786: 			LogAdd("[Fix Inv.Ptr] [%s][%s] - Transaction == 1, Do not change Pointer", 

  000cb	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d8	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000dc	52		 push	 edx
  000dd	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ea	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000ee	52		 push	 edx
  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@NEEGDNDB@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Transa@
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14787: 				gObj[aIndex].AccountID, 
; 14788: 				gObj[aIndex].Name
; 14789: 				);
; 14790: 			return false;

  000fd	32 c0		 xor	 al, al
  000ff	e9 b8 00 00 00	 jmp	 $LN1@gObjFixInv
$LN9@gObjFixInv:

; 14791: 		}
; 14792: #endif		
; 14793: 
; 14794: 		//      .
; 14795: 		LogAdd("[Fix Inv.Ptr] [%s][%s] - Inventory Pointer was 2", 

  00104	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0010b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00111	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00115	52		 push	 edx
  00116	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00123	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00127	52		 push	 edx
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@GPLONBA@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Invent@
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00133	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14796: 			gObj[aIndex].AccountID, 
; 14797: 			gObj[aIndex].Name
; 14798: 			);
; 14799: 
; 14800: #ifdef PERSONAL_SHOP_20040113
; 14801: 		for( int n=0; n<MAX_INVENTORY_EXTEND; n++)

  00136	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0013d	eb 09		 jmp	 SHORT $LN4@gObjFixInv
$LN2@gObjFixInv:
  0013f	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  00142	83 c0 01	 add	 eax, 1
  00145	89 45 fc	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjFixInv:
  00148	83 7d fc 6c	 cmp	 DWORD PTR _n$1[ebp], 108 ; 0000006cH
  0014c	7d 22		 jge	 SHORT $LN3@gObjFixInv

; 14802: //		for( int n=0; n<MAX_INVENTORY; n++)
; 14803: #else
; 14804: 		for( int n=0; n<MAX_INVENTORY; n++)
; 14805: #endif
; 14806: 		{
; 14807: 			gObj[aIndex].Inventory2[n].Clear();			//     (, , )         (    )

  0014e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00155	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  0015c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00162	03 8c 02 78 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3192]
  00169	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14808: 		}

  0016e	eb cf		 jmp	 SHORT $LN2@gObjFixInv
$LN3@gObjFixInv:

; 14809: 	}

  00170	eb 32		 jmp	 SHORT $LN8@gObjFixInv
$LN7@gObjFixInv:

; 14810: 	else {
; 14811: 		LogAdd("[Fix Inv.Ptr] [%s][%s] - Inventory Pointer was Wrong", 

  00172	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00179	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017f	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00183	52		 push	 edx
  00184	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0018b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00191	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00195	52		 push	 edx
  00196	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@DPJDFIHG@?$FLFix?5Inv?4Ptr?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5Invent@
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001a1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@gObjFixInv:

; 14812: 			gObj[aIndex].AccountID, 
; 14813: 			gObj[aIndex].Name
; 14814: 			);
; 14815: 	}
; 14816: 	
; 14817: 	gObjSetInventory1Pointer (&gObj[aIndex]);

  001a4	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001ab	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b1	50		 push	 eax
  001b2	e8 00 00 00 00	 call	 ?gObjSetInventory1Pointer@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer
  001b7	83 c4 04	 add	 esp, 4

; 14818: 
; 14819: 	return false;

  001ba	32 c0		 xor	 al, al
$LN1@gObjFixInv:

; 14820: }

  001bc	5f		 pop	 edi
  001bd	5e		 pop	 esi
  001be	5b		 pop	 ebx
  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c3		 ret	 0
?gObjFixInventoryPointer@@YA_NH@Z ENDP			; gObjFixInventoryPointer
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSetExpPetItem@@YAXHH@Z
_TEXT	SEGMENT
_addexp$1 = -16						; size = 4
_addexp$2 = -12						; size = 4
_addexp$3 = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_exp$ = 12						; size = 4
?gObjSetExpPetItem@@YAXHH@Z PROC			; gObjSetExpPetItem, COMDAT

; 32440: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 32441: 
; 32442: // MODIFY_ACCUMULATED_BUG_DARKLORD_PET_EXP_01_20050603 ?
; 32443: 
; 32444: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 32445: 	if(lpObj->Class != CLASS_DARKLORD )

  00019	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00023	83 f9 04	 cmp	 ecx, 4
  00026	74 05		 je	 SHORT $LN2@gObjSetExp

; 32446: 		return;

  00028	e9 fb 04 00 00	 jmp	 $LN1@gObjSetExp
$LN2@gObjSetExp:

; 32447: 
; 32448: 	exp = (int)((float)exp*gDarkSpiritAddExperience);

  0002d	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _exp$[ebp]
  00032	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR ?gDarkSpiritAddExperience@@3MA
  0003a	f3 0f 2c c0	 cvttss2si eax, xmm0
  0003e	89 45 0c	 mov	 DWORD PTR _exp$[ebp], eax

; 32449: 
; 32450: 	if( lpObj->pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,4) && 

  00041	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00046	c1 e0 03	 shl	 eax, 3
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0004c	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00052	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00057	6a 04		 push	 4
  00059	6a 0d		 push	 13			; 0000000dH
  0005b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00060	83 c4 08	 add	 esp, 8
  00063	3b f0		 cmp	 esi, eax
  00065	0f 85 42 02 00
	00		 jne	 $LN3@gObjSetExp
  0006b	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00070	c1 e0 00	 shl	 eax, 0
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00076	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0007c	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00081	6a 05		 push	 5
  00083	6a 0d		 push	 13			; 0000000dH
  00085	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0008a	83 c4 08	 add	 esp, 8
  0008d	3b f0		 cmp	 esi, eax
  0008f	0f 85 18 02 00
	00		 jne	 $LN3@gObjSetExp

; 32451: 		lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_Type == MAKE_ITEMNUM(13,5) )
; 32452: 	{	//     5%  
; 32453: 		int addexp = exp*10/100;

  00095	6b 45 0c 0a	 imul	 eax, DWORD PTR _exp$[ebp], 10
  00099	99		 cdq
  0009a	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0009f	f7 f9		 idiv	 ecx
  000a1	89 45 f8	 mov	 DWORD PTR _addexp$3[ebp], eax

; 32454: 
; 32455: 		if( lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].AddPetItemExp(addexp) )

  000a4	8b 45 f8	 mov	 eax, DWORD PTR _addexp$3[ebp]
  000a7	50		 push	 eax
  000a8	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  000ad	c1 e1 00	 shl	 ecx, 0
  000b0	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000b3	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  000b9	e8 00 00 00 00	 call	 ?AddPetItemExp@CItem@@QAEHH@Z ; CItem::AddPetItemExp
  000be	85 c0		 test	 eax, eax
  000c0	0f 84 e0 00 00
	00		 je	 $LN7@gObjSetExp

; 32456: 		{	
; 32457: 			if( !gObjIsItemPut(lpObj, &lpObj->pInventory[EQUIPMENT_WEAPON_LEFT], EQUIPMENT_WEAPON_LEFT) )

  000c6	6a 01		 push	 1
  000c8	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000cd	c1 e0 00	 shl	 eax, 0
  000d0	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000d3	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  000d9	50		 push	 eax
  000da	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000dd	52		 push	 edx
  000de	e8 00 00 00 00	 call	 ?gObjIsItemPut@@YAHPAVOBJECTSTRUCT@@PAVCItem@@H@Z ; gObjIsItemPut
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e6	85 c0		 test	 eax, eax
  000e8	75 3c		 jne	 SHORT $LN6@gObjSetExp

; 32458: 			{	//     
; 32459: 				lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].PetItemLevelDown(addexp);

  000ea	8b 45 f8	 mov	 eax, DWORD PTR _addexp$3[ebp]
  000ed	50		 push	 eax
  000ee	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  000f3	c1 e1 00	 shl	 ecx, 0
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000f9	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  000ff	e8 00 00 00 00	 call	 ?PetItemLevelDown@CItem@@QAEHH@Z ; CItem::PetItemLevelDown

; 32460: 
; 32461: 				//       
; 32462: 				MsgOutput(aIndex, lMsg.Get(1245));

  00104	68 dd 04 00 00	 push	 1245			; 000004ddH
  00109	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00114	50		 push	 eax
  00115	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0011e	83 c4 08	 add	 esp, 8

; 32463: 			}

  00121	e9 80 00 00 00	 jmp	 $LN7@gObjSetExp
$LN6@gObjSetExp:

; 32464: 			else
; 32465: 			{
; 32466: 				LogAddTD("[%s][%s][PetItemLevelUp] [%s] Level:[%d]Exp:[%d]AddExp:[%d]",

  00126	8b 45 f8	 mov	 eax, DWORD PTR _addexp$3[ebp]
  00129	50		 push	 eax
  0012a	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  0012f	c1 e1 00	 shl	 ecx, 0
  00132	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00135	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0013b	8b 8c 08 a4 00
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+164]
  00142	51		 push	 ecx
  00143	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  00148	c1 e2 00	 shl	 edx, 0
  0014b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014e	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00154	8b 94 11 a0 00
	00 00		 mov	 edx, DWORD PTR [ecx+edx+160]
  0015b	52		 push	 edx
  0015c	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00161	c1 e1 00	 shl	 ecx, 0
  00164	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00167	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0016d	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00172	50		 push	 eax
  00173	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00176	83 c1 73	 add	 ecx, 115		; 00000073H
  00179	51		 push	 ecx
  0017a	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0017d	83 c2 68	 add	 edx, 104		; 00000068H
  00180	52		 push	 edx
  00181	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@LPHFFNDE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemLevelUp?$FN?5?$FL?$CFs?$FN?5L@
  00186	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0018c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 32467: 						lpObj->AccountID,
; 32468: 						lpObj->Name,
; 32469: 						lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].GetName(), 
; 32470: 						lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_PetItem_Level,
; 32471: 						lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_PetItem_Exp,
; 32472: 						addexp);
; 32473: 
; 32474: 				CDarkSpirit::SendLevelmsg(lpObj->m_Index, EQUIPMENT_WEAPON_LEFT, 0, 254);

  0018f	68 fe 00 00 00	 push	 254			; 000000feH
  00194	6a 00		 push	 0
  00196	6a 01		 push	 1
  00198	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019d	51		 push	 ecx
  0019e	e8 00 00 00 00	 call	 ?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z ; CDarkSpirit::SendLevelmsg
  001a3	83 c4 10	 add	 esp, 16			; 00000010H
$LN7@gObjSetExp:

; 32475: 			}
; 32476: 		}
; 32477: 
; 32478: #if TESTSERVER == 1
; 32479: 		DebugOutput(aIndex, "[%s] Lv:%d Exp:%d", 
; 32480: 					lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].GetName(),				
; 32481: 					lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_PetItem_Level, 
; 32482: 					lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_PetItem_Exp);
; 32483: #endif
; 32484: 
; 32485: 		if( lpObj->pInventory[EQUIPMENT_HELPER].AddPetItemExp(addexp) )

  001a6	8b 45 f8	 mov	 eax, DWORD PTR _addexp$3[ebp]
  001a9	50		 push	 eax
  001aa	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  001af	c1 e1 03	 shl	 ecx, 3
  001b2	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001b5	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  001bb	e8 00 00 00 00	 call	 ?AddPetItemExp@CItem@@QAEHH@Z ; CItem::AddPetItemExp
  001c0	85 c0		 test	 eax, eax
  001c2	0f 84 e0 00 00
	00		 je	 $LN10@gObjSetExp

; 32486: 		{
; 32487: 			if( !gObjIsItemPut(lpObj, &lpObj->pInventory[EQUIPMENT_HELPER], EQUIPMENT_HELPER) )

  001c8	6a 08		 push	 8
  001ca	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  001cf	c1 e0 03	 shl	 eax, 3
  001d2	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001d5	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  001db	50		 push	 eax
  001dc	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001df	52		 push	 edx
  001e0	e8 00 00 00 00	 call	 ?gObjIsItemPut@@YAHPAVOBJECTSTRUCT@@PAVCItem@@H@Z ; gObjIsItemPut
  001e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e8	85 c0		 test	 eax, eax
  001ea	75 3c		 jne	 SHORT $LN9@gObjSetExp

; 32488: 			{	//     
; 32489: 				lpObj->pInventory[EQUIPMENT_HELPER].PetItemLevelDown(addexp);

  001ec	8b 45 f8	 mov	 eax, DWORD PTR _addexp$3[ebp]
  001ef	50		 push	 eax
  001f0	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  001f5	c1 e1 03	 shl	 ecx, 3
  001f8	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001fb	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00201	e8 00 00 00 00	 call	 ?PetItemLevelDown@CItem@@QAEHH@Z ; CItem::PetItemLevelDown

; 32490: 
; 32491: 				//       
; 32492: 				MsgOutput(aIndex, lMsg.Get(1246));

  00206	68 de 04 00 00	 push	 1246			; 000004deH
  0020b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00216	50		 push	 eax
  00217	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0021a	50		 push	 eax
  0021b	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00220	83 c4 08	 add	 esp, 8

; 32493: 			}

  00223	e9 80 00 00 00	 jmp	 $LN10@gObjSetExp
$LN9@gObjSetExp:

; 32494: 			else
; 32495: 			{
; 32496: 				LogAddTD("[%s][%s][PetItemLevelUp] [%s] Level:[%d]Exp:[%d]AddExp:[%d]",

  00228	8b 45 f8	 mov	 eax, DWORD PTR _addexp$3[ebp]
  0022b	50		 push	 eax
  0022c	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00231	c1 e1 03	 shl	 ecx, 3
  00234	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00237	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0023d	8b 8c 08 a4 00
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+164]
  00244	51		 push	 ecx
  00245	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  0024a	c1 e2 03	 shl	 edx, 3
  0024d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00250	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00256	8b 94 11 a0 00
	00 00		 mov	 edx, DWORD PTR [ecx+edx+160]
  0025d	52		 push	 edx
  0025e	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00263	c1 e1 03	 shl	 ecx, 3
  00266	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00269	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0026f	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00274	50		 push	 eax
  00275	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00278	83 c1 73	 add	 ecx, 115		; 00000073H
  0027b	51		 push	 ecx
  0027c	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0027f	83 c2 68	 add	 edx, 104		; 00000068H
  00282	52		 push	 edx
  00283	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@LPHFFNDE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemLevelUp?$FN?5?$FL?$CFs?$FN?5L@
  00288	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0028e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 32497: 						lpObj->AccountID,
; 32498: 						lpObj->Name,
; 32499: 						lpObj->pInventory[EQUIPMENT_HELPER].GetName(), 
; 32500: 						lpObj->pInventory[EQUIPMENT_HELPER].m_PetItem_Level,
; 32501: 						lpObj->pInventory[EQUIPMENT_HELPER].m_PetItem_Exp,
; 32502: 						addexp);
; 32503: 
; 32504: 				CDarkSpirit::SendLevelmsg(lpObj->m_Index, EQUIPMENT_HELPER, 1, 254);

  00291	68 fe 00 00 00	 push	 254			; 000000feH
  00296	6a 01		 push	 1
  00298	6a 08		 push	 8
  0029a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0029d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0029f	51		 push	 ecx
  002a0	e8 00 00 00 00	 call	 ?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z ; CDarkSpirit::SendLevelmsg
  002a5	83 c4 10	 add	 esp, 16			; 00000010H
$LN10@gObjSetExp:

; 32505: 			}
; 32506: 		}
; 32507: 
; 32508: #if TESTSERVER == 1
; 32509: 		DebugOutput(aIndex, "[%s] Lv:%d Exp:%d", 
; 32510: 					lpObj->pInventory[EQUIPMENT_HELPER].GetName(),				
; 32511: 					lpObj->pInventory[EQUIPMENT_HELPER].m_PetItem_Level, 
; 32512: 					lpObj->pInventory[EQUIPMENT_HELPER].m_PetItem_Exp);
; 32513: #endif
; 32514: 	}

  002a8	e9 7b 02 00 00	 jmp	 $LN19@gObjSetExp
$LN3@gObjSetExp:

; 32515: 	else if( lpObj->pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,4) )

  002ad	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  002b2	c1 e0 03	 shl	 eax, 3
  002b5	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002b8	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  002be	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  002c3	6a 04		 push	 4
  002c5	6a 0d		 push	 13			; 0000000dH
  002c7	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002cc	83 c4 08	 add	 esp, 8
  002cf	3b f0		 cmp	 esi, eax
  002d1	0f 85 16 01 00
	00		 jne	 $LN11@gObjSetExp

; 32516: 	{	//   
; 32517: 		int addexp = exp*20/100;

  002d7	6b 45 0c 14	 imul	 eax, DWORD PTR _exp$[ebp], 20
  002db	99		 cdq
  002dc	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  002e1	f7 f9		 idiv	 ecx
  002e3	89 45 f4	 mov	 DWORD PTR _addexp$2[ebp], eax

; 32518: 		if( lpObj->pInventory[EQUIPMENT_HELPER].AddPetItemExp(addexp) )

  002e6	8b 45 f4	 mov	 eax, DWORD PTR _addexp$2[ebp]
  002e9	50		 push	 eax
  002ea	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  002ef	c1 e1 03	 shl	 ecx, 3
  002f2	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002f5	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  002fb	e8 00 00 00 00	 call	 ?AddPetItemExp@CItem@@QAEHH@Z ; CItem::AddPetItemExp
  00300	85 c0		 test	 eax, eax
  00302	0f 84 e0 00 00
	00		 je	 $LN15@gObjSetExp

; 32519: 		{
; 32520: 			if( !gObjIsItemPut(lpObj, &lpObj->pInventory[EQUIPMENT_HELPER], EQUIPMENT_HELPER) )

  00308	6a 08		 push	 8
  0030a	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0030f	c1 e0 03	 shl	 eax, 3
  00312	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00315	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  0031b	50		 push	 eax
  0031c	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0031f	52		 push	 edx
  00320	e8 00 00 00 00	 call	 ?gObjIsItemPut@@YAHPAVOBJECTSTRUCT@@PAVCItem@@H@Z ; gObjIsItemPut
  00325	83 c4 0c	 add	 esp, 12			; 0000000cH
  00328	85 c0		 test	 eax, eax
  0032a	75 3c		 jne	 SHORT $LN14@gObjSetExp

; 32521: 			{	//     
; 32522: 				lpObj->pInventory[EQUIPMENT_HELPER].PetItemLevelDown(addexp);

  0032c	8b 45 f4	 mov	 eax, DWORD PTR _addexp$2[ebp]
  0032f	50		 push	 eax
  00330	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00335	c1 e1 03	 shl	 ecx, 3
  00338	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0033b	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00341	e8 00 00 00 00	 call	 ?PetItemLevelDown@CItem@@QAEHH@Z ; CItem::PetItemLevelDown

; 32523: 				//       
; 32524: 				MsgOutput(aIndex, lMsg.Get(1246));

  00346	68 de 04 00 00	 push	 1246			; 000004deH
  0034b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00350	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00356	50		 push	 eax
  00357	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0035a	50		 push	 eax
  0035b	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00360	83 c4 08	 add	 esp, 8

; 32525: 			}

  00363	e9 80 00 00 00	 jmp	 $LN15@gObjSetExp
$LN14@gObjSetExp:

; 32526: 			else
; 32527: 			{
; 32528: 				LogAddTD("[%s][%s][PetItemLevelUp] [%s] Level:[%d]Exp:[%d]AddExp:[%d]",

  00368	8b 45 f4	 mov	 eax, DWORD PTR _addexp$2[ebp]
  0036b	50		 push	 eax
  0036c	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00371	c1 e1 03	 shl	 ecx, 3
  00374	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00377	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0037d	8b 8c 08 a4 00
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+164]
  00384	51		 push	 ecx
  00385	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  0038a	c1 e2 03	 shl	 edx, 3
  0038d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00390	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00396	8b 94 11 a0 00
	00 00		 mov	 edx, DWORD PTR [ecx+edx+160]
  0039d	52		 push	 edx
  0039e	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  003a3	c1 e1 03	 shl	 ecx, 3
  003a6	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003a9	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  003af	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  003b4	50		 push	 eax
  003b5	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003b8	83 c1 73	 add	 ecx, 115		; 00000073H
  003bb	51		 push	 ecx
  003bc	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003bf	83 c2 68	 add	 edx, 104		; 00000068H
  003c2	52		 push	 edx
  003c3	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@LPHFFNDE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemLevelUp?$FN?5?$FL?$CFs?$FN?5L@
  003c8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003ce	83 c4 1c	 add	 esp, 28			; 0000001cH

; 32529: 						lpObj->AccountID,
; 32530: 						lpObj->Name,
; 32531: 						lpObj->pInventory[EQUIPMENT_HELPER].GetName(), 
; 32532: 						lpObj->pInventory[EQUIPMENT_HELPER].m_PetItem_Level,
; 32533: 						lpObj->pInventory[EQUIPMENT_HELPER].m_PetItem_Exp,
; 32534: 						addexp);
; 32535: 
; 32536: 				CDarkSpirit::SendLevelmsg(lpObj->m_Index, EQUIPMENT_HELPER, 1, 254);

  003d1	68 fe 00 00 00	 push	 254			; 000000feH
  003d6	6a 01		 push	 1
  003d8	6a 08		 push	 8
  003da	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  003df	51		 push	 ecx
  003e0	e8 00 00 00 00	 call	 ?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z ; CDarkSpirit::SendLevelmsg
  003e5	83 c4 10	 add	 esp, 16			; 00000010H
$LN15@gObjSetExp:

; 32537: 			}
; 32538: 		}
; 32539: 
; 32540: #if TESTSERVER == 1		
; 32541: 		DebugOutput(aIndex, "[%s] Lv:%d Exp:%d", 
; 32542: 					lpObj->pInventory[EQUIPMENT_HELPER].GetName(),				
; 32543: 					lpObj->pInventory[EQUIPMENT_HELPER].m_PetItem_Level, 
; 32544: 					lpObj->pInventory[EQUIPMENT_HELPER].m_PetItem_Exp);
; 32545: #endif
; 32546: 
; 32547: 	}

  003e8	e9 3b 01 00 00	 jmp	 $LN19@gObjSetExp
$LN11@gObjSetExp:

; 32548: 	else if( lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_Type == MAKE_ITEMNUM(13,5) )

  003ed	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  003f2	c1 e0 00	 shl	 eax, 0
  003f5	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003f8	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  003fe	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00403	6a 05		 push	 5
  00405	6a 0d		 push	 13			; 0000000dH
  00407	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0040c	83 c4 08	 add	 esp, 8
  0040f	3b f0		 cmp	 esi, eax
  00411	0f 85 11 01 00
	00		 jne	 $LN19@gObjSetExp

; 32549: 	{	//   
; 32550: 		int addexp = exp*20/100;

  00417	6b 45 0c 14	 imul	 eax, DWORD PTR _exp$[ebp], 20
  0041b	99		 cdq
  0041c	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00421	f7 f9		 idiv	 ecx
  00423	89 45 f0	 mov	 DWORD PTR _addexp$1[ebp], eax

; 32551: 
; 32552: 		if( lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].AddPetItemExp(addexp) )

  00426	8b 45 f0	 mov	 eax, DWORD PTR _addexp$1[ebp]
  00429	50		 push	 eax
  0042a	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  0042f	c1 e1 00	 shl	 ecx, 0
  00432	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00435	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0043b	e8 00 00 00 00	 call	 ?AddPetItemExp@CItem@@QAEHH@Z ; CItem::AddPetItemExp
  00440	85 c0		 test	 eax, eax
  00442	0f 84 e0 00 00
	00		 je	 $LN19@gObjSetExp

; 32553: 		{
; 32554: 			if( !gObjIsItemPut(lpObj, &lpObj->pInventory[EQUIPMENT_WEAPON_LEFT], EQUIPMENT_WEAPON_LEFT) )

  00448	6a 01		 push	 1
  0044a	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0044f	c1 e0 00	 shl	 eax, 0
  00452	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00455	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  0045b	50		 push	 eax
  0045c	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0045f	52		 push	 edx
  00460	e8 00 00 00 00	 call	 ?gObjIsItemPut@@YAHPAVOBJECTSTRUCT@@PAVCItem@@H@Z ; gObjIsItemPut
  00465	83 c4 0c	 add	 esp, 12			; 0000000cH
  00468	85 c0		 test	 eax, eax
  0046a	75 3c		 jne	 SHORT $LN18@gObjSetExp

; 32555: 			{	//     
; 32556: 				lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].PetItemLevelDown(addexp);

  0046c	8b 45 f0	 mov	 eax, DWORD PTR _addexp$1[ebp]
  0046f	50		 push	 eax
  00470	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00475	c1 e1 00	 shl	 ecx, 0
  00478	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0047b	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00481	e8 00 00 00 00	 call	 ?PetItemLevelDown@CItem@@QAEHH@Z ; CItem::PetItemLevelDown

; 32557: 				//       
; 32558: 				MsgOutput(aIndex, lMsg.Get(1245));				

  00486	68 dd 04 00 00	 push	 1245			; 000004ddH
  0048b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00490	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00496	50		 push	 eax
  00497	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0049a	50		 push	 eax
  0049b	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  004a0	83 c4 08	 add	 esp, 8

; 32559: 			}

  004a3	e9 80 00 00 00	 jmp	 $LN19@gObjSetExp
$LN18@gObjSetExp:

; 32560: 			else
; 32561: 			{
; 32562: 				LogAddTD("[%s][%s][PetItemLevelUp] [%s] Level:[%d]Exp:[%d]AddExp:[%d]",

  004a8	8b 45 f0	 mov	 eax, DWORD PTR _addexp$1[ebp]
  004ab	50		 push	 eax
  004ac	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  004b1	c1 e1 00	 shl	 ecx, 0
  004b4	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004b7	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  004bd	8b 8c 08 a4 00
	00 00		 mov	 ecx, DWORD PTR [eax+ecx+164]
  004c4	51		 push	 ecx
  004c5	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  004ca	c1 e2 00	 shl	 edx, 0
  004cd	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004d0	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  004d6	8b 94 11 a0 00
	00 00		 mov	 edx, DWORD PTR [ecx+edx+160]
  004dd	52		 push	 edx
  004de	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  004e3	c1 e1 00	 shl	 ecx, 0
  004e6	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004e9	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  004ef	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  004f4	50		 push	 eax
  004f5	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004f8	83 c1 73	 add	 ecx, 115		; 00000073H
  004fb	51		 push	 ecx
  004fc	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004ff	83 c2 68	 add	 edx, 104		; 00000068H
  00502	52		 push	 edx
  00503	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@LPHFFNDE@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemLevelUp?$FN?5?$FL?$CFs?$FN?5L@
  00508	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0050e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 32563: 						lpObj->AccountID,
; 32564: 						lpObj->Name,
; 32565: 						lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].GetName(), 
; 32566: 						lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_PetItem_Level,
; 32567: 						lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_PetItem_Exp,
; 32568: 						addexp);
; 32569: 
; 32570: 				CDarkSpirit::SendLevelmsg(lpObj->m_Index, EQUIPMENT_WEAPON_LEFT, 0, 254);

  00511	68 fe 00 00 00	 push	 254			; 000000feH
  00516	6a 00		 push	 0
  00518	6a 01		 push	 1
  0051a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0051d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0051f	51		 push	 ecx
  00520	e8 00 00 00 00	 call	 ?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z ; CDarkSpirit::SendLevelmsg
  00525	83 c4 10	 add	 esp, 16			; 00000010H
$LN19@gObjSetExp:
$LN1@gObjSetExp:

; 32571: 			}
; 32572: 		}
; 32573: 
; 32574: #if TESTSERVER == 1
; 32575: 		DebugOutput(aIndex, "[%s] Lv:%d Exp:%d", 
; 32576: 					lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].GetName(),				
; 32577: 					lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_PetItem_Level, 
; 32578: 					lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_PetItem_Exp);
; 32579: #endif
; 32580: 	}
; 32581: 
; 32582: }

  00528	5f		 pop	 edi
  00529	5e		 pop	 esi
  0052a	5b		 pop	 ebx
  0052b	8b e5		 mov	 esp, ebp
  0052d	5d		 pop	 ebp
  0052e	c3		 ret	 0
?gObjSetExpPetItem@@YAXHH@Z ENDP			; gObjSetExpPetItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjRecall@@YAXHHHH@Z
_TEXT	SEGMENT
_pAttack$1 = -8						; size = 8
_aIndex$ = 8						; size = 4
_mapnumber$ = 12					; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?gObjRecall@@YAXHHHH@Z PROC				; gObjRecall, COMDAT

; 32388: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 32389: 	if( gObj[aIndex].MapNumber != mapnumber )

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0001e	3b 55 0c	 cmp	 edx, DWORD PTR _mapnumber$[ebp]
  00021	0f 84 ac 01 00
	00		 je	 $LN2@gObjRecall

; 32390: 	{
; 32391: 		gObj[aIndex].X = x;

  00027	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00034	66 8b 55 10	 mov	 dx, WORD PTR _x$[ebp]
  00038	66 89 94 01 04
	01 00 00	 mov	 WORD PTR [ecx+eax+260], dx

; 32392: 		gObj[aIndex].Y = y;

  00040	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004d	66 8b 55 14	 mov	 dx, WORD PTR _y$[ebp]
  00051	66 89 94 01 06
	01 00 00	 mov	 WORD PTR [ecx+eax+262], dx

; 32393: 		gObj[aIndex].TX = x;

  00059	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00066	66 8b 55 10	 mov	 dx, WORD PTR _x$[ebp]
  0006a	66 89 94 01 20
	01 00 00	 mov	 WORD PTR [ecx+eax+288], dx

; 32394: 		gObj[aIndex].TX = y;

  00072	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007f	66 8b 55 14	 mov	 dx, WORD PTR _y$[ebp]
  00083	66 89 94 01 20
	01 00 00	 mov	 WORD PTR [ecx+eax+288], dx

; 32395: 		gObj[aIndex].MapNumber = mapnumber;	

  0008b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00092	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00098	8a 55 0c	 mov	 dl, BYTE PTR _mapnumber$[ebp]
  0009b	88 94 01 09 01
	00 00		 mov	 BYTE PTR [ecx+eax+265], dl

; 32396: 		gObj[aIndex].PathCount = 0;

  000a2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000af	c7 84 01 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+296], 0

; 32397: 		gObj[aIndex].Teleport  = 0;

  000ba	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c7	c6 84 01 fc 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+508], 0

; 32398: 
; 32399: 		//gObjViewportListProtocolDestroy(&gObj[aIndex]);		
; 32400: 		gObjClearViewport(&gObj[aIndex]);

  000cf	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000d6	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  000e2	83 c4 04	 add	 esp, 4

; 32401: 		GCTeleportSend(&gObj[aIndex], -1, mapnumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);

  000e5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f2	0f b6 94 01 08
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+264]
  000fa	52		 push	 edx
  000fb	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00102	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00108	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00110	52		 push	 edx
  00111	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00118	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011e	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  00126	52		 push	 edx
  00127	0f b6 45 0c	 movzx	 eax, BYTE PTR _mapnumber$[ebp]
  0012b	50		 push	 eax
  0012c	68 ff 00 00 00	 push	 255			; 000000ffH
  00131	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00138	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013e	51		 push	 ecx
  0013f	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  00144	83 c4 18	 add	 esp, 24			; 00000018H

; 32402: 
; 32403: 		if( gObj[aIndex].m_Change >= 0 )

  00147	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0014e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00154	83 bc 01 a8 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+680], 0
  0015c	7c 16		 jl	 SHORT $LN4@gObjRecall

; 32404: 		{
; 32405: 			gObjViewportListProtocolCreate(&gObj[aIndex]);

  0015e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00165	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00171	83 c4 04	 add	 esp, 4
$LN4@gObjRecall:

; 32406: 		}
; 32407: 
; 32408: 		gObj[aIndex].RegenMapNumber = mapnumber;

  00174	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0017b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00181	8a 55 0c	 mov	 dl, BYTE PTR _mapnumber$[ebp]
  00184	88 94 01 00 02
	00 00		 mov	 BYTE PTR [ecx+eax+512], dl

; 32409: 		gObj[aIndex].RegenMapX = (BYTE)x;

  0018b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00192	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00198	8a 55 10	 mov	 dl, BYTE PTR _x$[ebp]
  0019b	88 94 01 01 02
	00 00		 mov	 BYTE PTR [ecx+eax+513], dl

; 32410: 		gObj[aIndex].RegenMapY = (BYTE)y;		

  001a2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001af	8a 55 14	 mov	 dl, BYTE PTR _y$[ebp]
  001b2	88 94 01 02 02
	00 00		 mov	 BYTE PTR [ecx+eax+514], dl

; 32411: 		gObj[aIndex].RegenOk   = 1;

  001b9	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c6	c6 84 01 ff 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+511], 1

; 32412: 	}

  001ce	e9 90 00 00 00	 jmp	 $LN1@gObjRecall
$LN2@gObjRecall:

; 32413: 	else
; 32414: 	{
; 32415: 		PMSG_MAGICATTACK_RESULT	pAttack;
; 32416: 		
; 32417: 		PHeadSetBE((LPBYTE)&pAttack, 0x19, sizeof( pAttack));

  001d3	6a 08		 push	 8
  001d5	6a 19		 push	 25			; 00000019H
  001d7	8d 45 f8	 lea	 eax, DWORD PTR _pAttack$1[ebp]
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 ?PHeadSetBE@@YAXPAEEH@Z	; PHeadSetBE
  001e0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 32418: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//  BYTE -> WORD 
; 32419: 		pAttack.MagicNumberH   = HIBYTE( AT_SKILL_TELEPORT );
; 32420: 		pAttack.MagicNumberL   = LOBYTE( AT_SKILL_TELEPORT );
; 32421: #else
; 32422: 		pAttack.MagicNumber   = AT_SKILL_TELEPORT;

  001e3	c6 45 fb 06	 mov	 BYTE PTR _pAttack$1[ebp+3], 6

; 32423: #endif
; 32424: 		pAttack.SourceNumberH = HIBYTE(aIndex);

  001e7	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001ea	c1 e8 08	 shr	 eax, 8
  001ed	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001f2	88 45 fc	 mov	 BYTE PTR _pAttack$1[ebp+4], al

; 32425: 		pAttack.SourceNumberL = LOBYTE(aIndex);	

  001f5	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001f8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001fd	88 45 fd	 mov	 BYTE PTR _pAttack$1[ebp+5], al

; 32426: 		pAttack.TargetNumberH = HIBYTE(aIndex);

  00200	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00203	c1 e8 08	 shr	 eax, 8
  00206	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0020b	88 45 fe	 mov	 BYTE PTR _pAttack$1[ebp+6], al

; 32427: 		pAttack.TargetNumberL = LOBYTE(aIndex);	

  0020e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00211	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00216	88 45 ff	 mov	 BYTE PTR _pAttack$1[ebp+7], al

; 32428: 
; 32429: 		DataSend(aIndex, (LPBYTE)&pAttack, pAttack.h.size);

  00219	0f b6 45 f9	 movzx	 eax, BYTE PTR _pAttack$1[ebp+1]
  0021d	50		 push	 eax
  0021e	8d 4d f8	 lea	 ecx, DWORD PTR _pAttack$1[ebp]
  00221	51		 push	 ecx
  00222	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00225	52		 push	 edx
  00226	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0022b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 32430: 		MsgSendV2(&gObj[aIndex], (LPBYTE)&pAttack, pAttack.h.size);

  0022e	0f b6 45 f9	 movzx	 eax, BYTE PTR _pAttack$1[ebp+1]
  00232	50		 push	 eax
  00233	8d 4d f8	 lea	 ecx, DWORD PTR _pAttack$1[ebp]
  00236	51		 push	 ecx
  00237	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0023e	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00244	52		 push	 edx
  00245	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0024a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 32431: 
; 32432: 		//gObj[aIndex].MapNumber			= mapnumber;
; 32433: 
; 32434: 		gObjTeleportMagicUse(aIndex, x, y);	

  0024d	0f b6 45 14	 movzx	 eax, BYTE PTR _y$[ebp]
  00251	50		 push	 eax
  00252	0f b6 4d 10	 movzx	 ecx, BYTE PTR _x$[ebp]
  00256	51		 push	 ecx
  00257	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0025a	52		 push	 edx
  0025b	e8 00 00 00 00	 call	 ?gObjTeleportMagicUse@@YAXHEE@Z ; gObjTeleportMagicUse
  00260	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjRecall:

; 32435: 	}
; 32436: }

  00263	5f		 pop	 edi
  00264	5e		 pop	 esi
  00265	5b		 pop	 ebx
  00266	8b e5		 mov	 esp, ebp
  00268	5d		 pop	 ebp
  00269	c3		 ret	 0
?gObjRecall@@YAXHHHH@Z ENDP				; gObjRecall
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMagicEnergyCheck@@YAHPAVOBJECTSTRUCT@@E@Z
_TEXT	SEGMENT
_reqeng$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_aSkill$ = 12						; size = 1
?gObjMagicEnergyCheck@@YAHPAVOBJECTSTRUCT@@E@Z PROC	; gObjMagicEnergyCheck, COMDAT

; 28357: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 28358: 	int reqeng = MagicDamageC.SkillGetRequireEnergy(aSkill);

  00009	0f b6 45 0c	 movzx	 eax, BYTE PTR _aSkill$[ebp]
  0000d	50		 push	 eax
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00013	e8 00 00 00 00	 call	 ?SkillGetRequireEnergy@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetRequireEnergy
  00018	89 45 fc	 mov	 DWORD PTR _reqeng$[ebp], eax

; 28359: 	if( reqeng < 0 ) 

  0001b	83 7d fc 00	 cmp	 DWORD PTR _reqeng$[ebp], 0
  0001f	7d 04		 jge	 SHORT $LN2@gObjMagicE

; 28360: 	{	
; 28361: 		return FALSE;

  00021	33 c0		 xor	 eax, eax
  00023	eb 54		 jmp	 SHORT $LN1@gObjMagicE
$LN2@gObjMagicE:

; 28362: 	}
; 28363: 
; 28364: #ifdef MODIFY_SKILL_REQUIREENERGY_20080423
; 28365: 	if (lpObj->Class == CLASS_KNIGHT)	reqeng -= 10;

  00025	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00028	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0002f	83 f9 01	 cmp	 ecx, 1
  00032	75 09		 jne	 SHORT $LN3@gObjMagicE
  00034	8b 45 fc	 mov	 eax, DWORD PTR _reqeng$[ebp]
  00037	83 e8 0a	 sub	 eax, 10			; 0000000aH
  0003a	89 45 fc	 mov	 DWORD PTR _reqeng$[ebp], eax
$LN3@gObjMagicE:

; 28366: 	if (lpObj->Class == CLASS_ELF)		reqeng -= 5;

  0003d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00040	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00047	83 f9 02	 cmp	 ecx, 2
  0004a	75 09		 jne	 SHORT $LN4@gObjMagicE
  0004c	8b 45 fc	 mov	 eax, DWORD PTR _reqeng$[ebp]
  0004f	83 e8 05	 sub	 eax, 5
  00052	89 45 fc	 mov	 DWORD PTR _reqeng$[ebp], eax
$LN4@gObjMagicE:

; 28367: #endif // MODIFY_SKILL_REQUIREENERGY_20080423	
; 28368: 
; 28369: 	if( (lpObj->Energy+lpObj->AddEnergy) < reqeng ) 

  00055	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00058	0f b7 88 ba 00
	00 00		 movzx	 ecx, WORD PTR [eax+186]
  0005f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00062	0f b7 82 e6 00
	00 00		 movzx	 eax, WORD PTR [edx+230]
  00069	03 c8		 add	 ecx, eax
  0006b	3b 4d fc	 cmp	 ecx, DWORD PTR _reqeng$[ebp]
  0006e	7d 04		 jge	 SHORT $LN5@gObjMagicE

; 28370: 	{
; 28371: 		return FALSE;

  00070	33 c0		 xor	 eax, eax
  00072	eb 05		 jmp	 SHORT $LN1@gObjMagicE
$LN5@gObjMagicE:

; 28372: 	}
; 28373: 
; 28374: #ifdef ADD_CHECKING_LEVEL_TO_LEARN_MAGIC_20041115
; 28375: 	int reqlevel = MagicDamageC.SkillGetRequireLevel(aSkill);
; 28376: 	if( (lpObj->Level) < reqlevel && g_GlobalConfig.m_bCheckSkill == TRUE ) 
; 28377: 	{
; 28378: 		return FALSE;
; 28379: 	}
; 28380: #endif
; 28381: 	
; 28382: 	return TRUE;

  00074	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjMagicE:

; 28383: }

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?gObjMagicEnergyCheck@@YAHPAVOBJECTSTRUCT@@E@Z ENDP	; gObjMagicEnergyCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?MakeRandomSetItem@@YAXH@Z
_TEXT	SEGMENT
tv76 = -108						; size = 4
_tmpSetOption$ = -40					; size = 4
_Option3$ = -36						; size = 4
_Option2$ = -32						; size = 4
_Option1$ = -28						; size = 4
_optionc$ = -24						; size = 4
_option3rand$ = -20					; size = 4
_option2rand$ = -16					; size = 4
_option1rand$ = -12					; size = 4
_SetOption$ = -8					; size = 4
_itemnum$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?MakeRandomSetItem@@YAXH@Z PROC				; MakeRandomSetItem, COMDAT

; 32218: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 32219: #ifdef CHANGE_CHAOSCASTLE_SET_ITEM_DROP
; 32220: 	gChaosCastleSetItemDrop.MakeRandomSetItem(aIndex);
; 32221: #else
; 32222: 	int itemnum = gSetItemOption.GenRandomItemNum();

  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  0000e	e8 00 00 00 00	 call	 ?GenRandomItemNum@CSetItemOption@@QAEHXZ ; CSetItemOption::GenRandomItemNum
  00013	89 45 fc	 mov	 DWORD PTR _itemnum$[ebp], eax

; 32223: 	int	SetOption = gSetItemOption.GenSetOption(itemnum);

  00016	8b 45 fc	 mov	 eax, DWORD PTR _itemnum$[ebp]
  00019	50		 push	 eax
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  0001f	e8 00 00 00 00	 call	 ?GenSetOption@CSetItemOption@@QAEHH@Z ; CSetItemOption::GenSetOption
  00024	89 45 f8	 mov	 DWORD PTR _SetOption$[ebp], eax

; 32224: 
; 32225: 	int option1rand, option2rand, option3rand, optionc;	
; 32226: 	int	Option1 = 0, Option2 = 0, Option3 = 0;

  00027	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 0
  0002e	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 0
  00035	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 0

; 32227: 
; 32228: 	
; 32229: 	option1rand = 6;				//  1 ()   6/100

  0003c	c7 45 f4 06 00
	00 00		 mov	 DWORD PTR _option1rand$[ebp], 6

; 32230: 	option2rand = 4;				//  2 ()   4/100

  00043	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR _option2rand$[ebp], 4

; 32231: 	option3rand = (rand()%100);		//  3 ()   /100

  0004a	e8 00 00 00 00	 call	 _rand
  0004f	99		 cdq
  00050	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00055	f7 f9		 idiv	 ecx
  00057	89 55 ec	 mov	 DWORD PTR _option3rand$[ebp], edx

; 32232: 	optionc		= (rand()%3);

  0005a	e8 00 00 00 00	 call	 _rand
  0005f	99		 cdq
  00060	b9 03 00 00 00	 mov	 ecx, 3
  00065	f7 f9		 idiv	 ecx
  00067	89 55 e8	 mov	 DWORD PTR _optionc$[ebp], edx

; 32233: 
; 32234: 	//    .	
; 32235: 	if((rand()%100) < option2rand ) Option2 = 1;

  0006a	e8 00 00 00 00	 call	 _rand
  0006f	99		 cdq
  00070	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00075	f7 f9		 idiv	 ecx
  00077	3b 55 f0	 cmp	 edx, DWORD PTR _option2rand$[ebp]
  0007a	7d 07		 jge	 SHORT $LN4@MakeRandom
  0007c	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _Option2$[ebp], 1
$LN4@MakeRandom:

; 32236: 
; 32237: 	switch( optionc )

  00083	8b 45 e8	 mov	 eax, DWORD PTR _optionc$[ebp]
  00086	89 45 94	 mov	 DWORD PTR tv76[ebp], eax
  00089	83 7d 94 00	 cmp	 DWORD PTR tv76[ebp], 0
  0008d	74 0e		 je	 SHORT $LN5@MakeRandom
  0008f	83 7d 94 01	 cmp	 DWORD PTR tv76[ebp], 1
  00093	74 17		 je	 SHORT $LN7@MakeRandom
  00095	83 7d 94 02	 cmp	 DWORD PTR tv76[ebp], 2
  00099	74 20		 je	 SHORT $LN9@MakeRandom
  0009b	eb 2b		 jmp	 SHORT $LN2@MakeRandom
$LN5@MakeRandom:

; 32238: 	{
; 32239: 	case 0 :
; 32240: 		if( option3rand < 4 ) Option3 = 3;	// 

  0009d	83 7d ec 04	 cmp	 DWORD PTR _option3rand$[ebp], 4
  000a1	7d 07		 jge	 SHORT $LN6@MakeRandom
  000a3	c7 45 dc 03 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 3
$LN6@MakeRandom:

; 32241: 		break;

  000aa	eb 1c		 jmp	 SHORT $LN2@MakeRandom
$LN7@MakeRandom:

; 32242: 	case 1 :
; 32243: 		if( option3rand < 8 ) Option3 = 2;	// 

  000ac	83 7d ec 08	 cmp	 DWORD PTR _option3rand$[ebp], 8
  000b0	7d 07		 jge	 SHORT $LN8@MakeRandom
  000b2	c7 45 dc 02 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 2
$LN8@MakeRandom:

; 32244: 		break;

  000b9	eb 0d		 jmp	 SHORT $LN2@MakeRandom
$LN9@MakeRandom:

; 32245: 	case 2 :
; 32246: 		if( option3rand < 12 ) Option3 = 1;	// 

  000bb	83 7d ec 0c	 cmp	 DWORD PTR _option3rand$[ebp], 12 ; 0000000cH
  000bf	7d 07		 jge	 SHORT $LN2@MakeRandom
  000c1	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _Option3$[ebp], 1
$LN2@MakeRandom:

; 32247: 		break;
; 32248: 	}
; 32249: 
; 32250: 	Option1 = 1;

  000c8	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _Option1$[ebp], 1

; 32251: 	ItemSerialCreateSend(aIndex, gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y, itemnum, 

  000cf	6a 00		 push	 0
  000d1	0f b6 45 f8	 movzx	 eax, BYTE PTR _SetOption$[ebp]
  000d5	50		 push	 eax
  000d6	6a 00		 push	 0
  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000db	51		 push	 ecx
  000dc	0f b6 55 dc	 movzx	 edx, BYTE PTR _Option3$[ebp]
  000e0	52		 push	 edx
  000e1	0f b6 45 e0	 movzx	 eax, BYTE PTR _Option2$[ebp]
  000e5	50		 push	 eax
  000e6	0f b6 4d e4	 movzx	 ecx, BYTE PTR _Option1$[ebp]
  000ea	51		 push	 ecx
  000eb	6a 00		 push	 0
  000ed	6a 00		 push	 0
  000ef	8b 55 fc	 mov	 edx, DWORD PTR _itemnum$[ebp]
  000f2	52		 push	 edx
  000f3	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00100	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00108	52		 push	 edx
  00109	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00110	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00116	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  0011e	52		 push	 edx
  0011f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00126	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0012c	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00134	52		 push	 edx
  00135	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  0013e	83 c4 38	 add	 esp, 56			; 00000038H

; 32252: 						 0, (BYTE)0, Option1, Option2, Option3, aIndex, 0, SetOption);
; 32253: 
; 32254: #ifdef UPDATE_SET_ITEM_DROP_LOG_20080420
; 32255: 	int tmpSetOption = 0;

  00141	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _tmpSetOption$[ebp], 0

; 32256: 
; 32257: 	if( SetOption & 0x01)

  00148	8b 45 f8	 mov	 eax, DWORD PTR _SetOption$[ebp]
  0014b	83 e0 01	 and	 eax, 1
  0014e	74 09		 je	 SHORT $LN11@MakeRandom

; 32258: 	{
; 32259: 		tmpSetOption = 1;

  00150	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _tmpSetOption$[ebp], 1

; 32260: 	}

  00157	eb 0f		 jmp	 SHORT $LN12@MakeRandom
$LN11@MakeRandom:

; 32261: 	else if( SetOption & 0x02 )

  00159	8b 45 f8	 mov	 eax, DWORD PTR _SetOption$[ebp]
  0015c	83 e0 02	 and	 eax, 2
  0015f	74 07		 je	 SHORT $LN12@MakeRandom

; 32262: 	{
; 32263: 		tmpSetOption = 2;

  00161	c7 45 d8 02 00
	00 00		 mov	 DWORD PTR _tmpSetOption$[ebp], 2
$LN12@MakeRandom:

; 32264: 	}
; 32265: 
; 32266: 	LogAddTD("[Chaos Castle] [%s][%s] Winner Set Item itemnum:[%d] skill:[%d] luck:[%d] option:[%d] SetOption:[%d], SetName:[%s]",			 

  00168	8b 45 d8	 mov	 eax, DWORD PTR _tmpSetOption$[ebp]
  0016b	50		 push	 eax
  0016c	8b 4d fc	 mov	 ecx, DWORD PTR _itemnum$[ebp]
  0016f	51		 push	 ecx
  00170	b9 00 00 00 00	 mov	 ecx, OFFSET ?gSetItemOption@@3VCSetItemOption@@A ; gSetItemOption
  00175	e8 00 00 00 00	 call	 ?GetSetOptionName@CSetItemOption@@QAEPADHH@Z ; CSetItemOption::GetSetOptionName
  0017a	50		 push	 eax
  0017b	8b 55 f8	 mov	 edx, DWORD PTR _SetOption$[ebp]
  0017e	52		 push	 edx
  0017f	8b 45 dc	 mov	 eax, DWORD PTR _Option3$[ebp]
  00182	50		 push	 eax
  00183	8b 4d e0	 mov	 ecx, DWORD PTR _Option2$[ebp]
  00186	51		 push	 ecx
  00187	8b 55 e4	 mov	 edx, DWORD PTR _Option1$[ebp]
  0018a	52		 push	 edx
  0018b	8b 45 fc	 mov	 eax, DWORD PTR _itemnum$[ebp]
  0018e	50		 push	 eax
  0018f	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00196	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019c	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  001a0	50		 push	 eax
  001a1	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001a8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ae	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  001b2	50		 push	 eax
  001b3	68 00 00 00 00	 push	 OFFSET ??_C@_0HD@NHFJLKNN@?$FLChaos?5Castle?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Winner?5@
  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001be	83 c4 24	 add	 esp, 36			; 00000024H

; 32267: 			 gObj[aIndex].AccountID, 
; 32268: 			 gObj[aIndex].Name,
; 32269: 			 itemnum, Option1, Option2, Option3,SetOption,
; 32270: 			 gSetItemOption.GetSetOptionName(itemnum, tmpSetOption));
; 32271: #else	// UPDATE_SET_ITEM_DROP_LOG_20080420
; 32272: 	LogAddTD("[Chaos Castle] [%s][%s] Winner Set Item itemnum:[%d] skill:[%d] luck:[%d] option:[%d] SetOption:[%d]",			 
; 32273: 			 gObj[aIndex].AccountID, 
; 32274: 			 gObj[aIndex].Name,
; 32275: 			 itemnum, Option1, Option2, Option3,SetOption);
; 32276: #endif	// UPDATE_SET_ITEM_DROP_LOG_20080420
; 32277: #endif
; 32278: }

  001c1	5f		 pop	 edi
  001c2	5e		 pop	 esi
  001c3	5b		 pop	 ebx
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c3		 ret	 0
?MakeRandomSetItem@@YAXH@Z ENDP				; MakeRandomSetItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjIsItemPut@@YAHPAVOBJECTSTRUCT@@PAVCItem@@H@Z
_TEXT	SEGMENT
tv345 = -76						; size = 4
tv346 = -72						; size = 4
_itemcount$1 = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpItem$ = 12						; size = 4
_pos$ = 16						; size = 4
?gObjIsItemPut@@YAHPAVOBJECTSTRUCT@@PAVCItem@@H@Z PROC	; gObjIsItemPut, COMDAT

; 15786: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15787: 	//        
; 15788: 	if( lpItem->m_TwoHand == TRUE )

  00009	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  0000c	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  00010	83 f9 01	 cmp	 ecx, 1
  00013	0f 85 f0 00 00
	00		 jne	 $LN2@gObjIsItem

; 15789: 	{		
; 15790: 		if( pos == EQUIPMENT_WEAPON_RIGHT ||

  00019	83 7d 10 00	 cmp	 DWORD PTR _pos$[ebp], 0
  0001d	74 0a		 je	 SHORT $LN4@gObjIsItem
  0001f	83 7d 10 01	 cmp	 DWORD PTR _pos$[ebp], 1
  00023	0f 85 e0 00 00
	00		 jne	 $LN2@gObjIsItem
$LN4@gObjIsItem:

; 15791: 			pos == EQUIPMENT_WEAPON_LEFT )
; 15792: 		{
; 15793: 			if( lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].IsItem() == TRUE )

  00029	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0002e	6b c8 00	 imul	 ecx, eax, 0
  00031	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00034	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0003a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0003f	83 f8 01	 cmp	 eax, 1
  00042	75 55		 jne	 SHORT $LN5@gObjIsItem

; 15794: 			{
; 15795: 				if( (lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].m_Type == MAKE_ITEMNUM(4,7)) ||

  00044	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00049	6b c8 00	 imul	 ecx, eax, 0
  0004c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0004f	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00055	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0005a	6a 07		 push	 7
  0005c	6a 04		 push	 4
  0005e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00063	83 c4 08	 add	 esp, 8
  00066	3b f0		 cmp	 esi, eax
  00068	74 26		 je	 SHORT $LN8@gObjIsItem
  0006a	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0006f	6b c8 00	 imul	 ecx, eax, 0
  00072	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00075	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0007b	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00080	6a 0f		 push	 15			; 0000000fH
  00082	6a 04		 push	 4
  00084	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00089	83 c4 08	 add	 esp, 8
  0008c	3b f0		 cmp	 esi, eax
  0008e	75 02		 jne	 SHORT $LN6@gObjIsItem
$LN8@gObjIsItem:

; 15796: 					(lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].m_Type == MAKE_ITEMNUM(4,15)) )
; 15797: 				{					
; 15798: 				}	

  00090	eb 07		 jmp	 SHORT $LN5@gObjIsItem
$LN6@gObjIsItem:

; 15799: 				else return FALSE;

  00092	33 c0		 xor	 eax, eax
  00094	e9 78 04 00 00	 jmp	 $LN1@gObjIsItem
$LN5@gObjIsItem:

; 15800: 			}
; 15801: 			if( lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].IsItem() == TRUE )

  00099	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  0009e	c1 e1 00	 shl	 ecx, 0
  000a1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a4	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  000aa	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000af	83 f8 01	 cmp	 eax, 1
  000b2	75 55		 jne	 SHORT $LN2@gObjIsItem

; 15802: 			{
; 15803: 				if( (lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_Type == MAKE_ITEMNUM(4,7)) ||

  000b4	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000b9	c1 e0 00	 shl	 eax, 0
  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000bf	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000c5	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000ca	6a 07		 push	 7
  000cc	6a 04		 push	 4
  000ce	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000d3	83 c4 08	 add	 esp, 8
  000d6	3b f0		 cmp	 esi, eax
  000d8	74 26		 je	 SHORT $LN12@gObjIsItem
  000da	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  000df	c1 e0 00	 shl	 eax, 0
  000e2	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000e5	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000eb	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000f0	6a 0f		 push	 15			; 0000000fH
  000f2	6a 04		 push	 4
  000f4	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000f9	83 c4 08	 add	 esp, 8
  000fc	3b f0		 cmp	 esi, eax
  000fe	75 02		 jne	 SHORT $LN10@gObjIsItem
$LN12@gObjIsItem:

; 15804: 					(lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_Type == MAKE_ITEMNUM(4,15)) )
; 15805: 				{					
; 15806: 				}	

  00100	eb 07		 jmp	 SHORT $LN2@gObjIsItem
$LN10@gObjIsItem:

; 15807: 				else return FALSE;

  00102	33 c0		 xor	 eax, eax
  00104	e9 08 04 00 00	 jmp	 $LN1@gObjIsItem
$LN2@gObjIsItem:

; 15808: 			}			
; 15809: 		}
; 15810: 	}
; 15811: 	
; 15812: 	if( pos == EQUIPMENT_WEAPON_LEFT )

  00109	83 7d 10 01	 cmp	 DWORD PTR _pos$[ebp], 1
  0010d	75 6c		 jne	 SHORT $LN13@gObjIsItem

; 15813: 	{
; 15814: 		//        .
; 15815: 		if( lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].IsItem() == TRUE )

  0010f	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00114	6b c8 00	 imul	 ecx, eax, 0
  00117	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0011a	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00120	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00125	83 f8 01	 cmp	 eax, 1
  00128	75 51		 jne	 SHORT $LN13@gObjIsItem

; 15816: 		{		
; 15817: 			//   .
; 15818: 			if( (lpItem->m_Type == MAKE_ITEMNUM(4,7)) ||

  0012a	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  0012d	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00131	6a 07		 push	 7
  00133	6a 04		 push	 4
  00135	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0013a	83 c4 08	 add	 esp, 8
  0013d	3b f0		 cmp	 esi, eax
  0013f	74 17		 je	 SHORT $LN17@gObjIsItem
  00141	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00144	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00148	6a 0f		 push	 15			; 0000000fH
  0014a	6a 04		 push	 4
  0014c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00151	83 c4 08	 add	 esp, 8
  00154	3b f0		 cmp	 esi, eax
  00156	75 02		 jne	 SHORT $LN15@gObjIsItem
$LN17@gObjIsItem:

; 15819: 				(lpItem->m_Type == MAKE_ITEMNUM(4,15)) )
; 15820: 			{					
; 15821: 			}

  00158	eb 21		 jmp	 SHORT $LN13@gObjIsItem
$LN15@gObjIsItem:

; 15822: 			else if( lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].m_TwoHand )

  0015a	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0015f	6b c8 00	 imul	 ecx, eax, 0
  00162	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00165	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0016b	0f b6 4c 08 0c	 movzx	 ecx, BYTE PTR [eax+ecx+12]
  00170	85 c9		 test	 ecx, ecx
  00172	74 07		 je	 SHORT $LN13@gObjIsItem

; 15823: 			{
; 15824: 				return FALSE;

  00174	33 c0		 xor	 eax, eax
  00176	e9 96 03 00 00	 jmp	 $LN1@gObjIsItem
$LN13@gObjIsItem:

; 15825: 			}
; 15826: 		}
; 15827: 	}
; 15828: 
; 15829: #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//  
; 15830: 	//     
; 15831: 	if( lpObj->Class == CLASS_DARKLORD 
; 15832: 		&& (lpItem->m_Type >> ITEM_BITSHIFT) == ITEM_MACE / MAX_ITEM_INDEX
; 15833: 		)
; 15834: 	{
; 15835: 		if( lpItem->m_Part != pos ) 
; 15836: 			return FALSE;
; 15837: 	}
; 15838: 
; 15839: 	//     
; 15840: 	if( lpObj->Class == CLASS_WIZARD
; 15841: 		&& (lpItem->m_Type >> ITEM_BITSHIFT) == ITEM_STAFF / MAX_ITEM_INDEX
; 15842: 		)
; 15843: 	{
; 15844: 		if( lpItem->m_Part != pos ) 
; 15845: 			return FALSE;
; 15846: 	}
; 15847: 
; 15848: 	//      (    )
; 15849: 	if( lpObj->Class == CLASS_SUMMONER
; 15850: 		&& (lpItem->m_Type >> ITEM_BITSHIFT) == ITEM_STAFF / MAX_ITEM_INDEX
; 15851: 		)
; 15852: 	{
; 15853: 		if( lpItem->m_Part != pos ) 
; 15854: 			return FALSE;
; 15855: 	}
; 15856: #endif	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 15857: 
; 15858: 	//     ..
; 15859: 	if( lpItem->m_Part != pos ) 

  0017b	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  0017e	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  00182	3b 4d 10	 cmp	 ecx, DWORD PTR _pos$[ebp]
  00185	74 52		 je	 SHORT $LN19@gObjIsItem

; 15860: 	{
; 15861: 		if( pos == EQUIPMENT_WEAPON_LEFT ||

  00187	83 7d 10 01	 cmp	 DWORD PTR _pos$[ebp], 1
  0018b	74 06		 je	 SHORT $LN22@gObjIsItem
  0018d	83 7d 10 00	 cmp	 DWORD PTR _pos$[ebp], 0
  00191	75 22		 jne	 SHORT $LN20@gObjIsItem
$LN22@gObjIsItem:

; 15862: 			pos == EQUIPMENT_WEAPON_RIGHT )
; 15863: 		{
; 15864: 			if( lpItem->m_Part == EQUIPMENT_WEAPON_LEFT ||

  00193	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00196	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  0019a	83 f9 01	 cmp	 ecx, 1
  0019d	74 0b		 je	 SHORT $LN25@gObjIsItem
  0019f	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  001a2	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  001a6	85 c9		 test	 ecx, ecx
  001a8	75 02		 jne	 SHORT $LN23@gObjIsItem
$LN25@gObjIsItem:

; 15865: 				lpItem->m_Part == EQUIPMENT_WEAPON_RIGHT )
; 15866: 			{
; 15867: 				
; 15868: 			}	

  001aa	eb 07		 jmp	 SHORT $LN24@gObjIsItem
$LN23@gObjIsItem:

; 15869: 			else return FALSE;

  001ac	33 c0		 xor	 eax, eax
  001ae	e9 5e 03 00 00	 jmp	 $LN1@gObjIsItem
$LN24@gObjIsItem:

; 15870: 		}

  001b3	eb 24		 jmp	 SHORT $LN19@gObjIsItem
$LN20@gObjIsItem:

; 15871: 		else if( pos == EQUIPMENT_RING_LEFT )

  001b5	83 7d 10 0b	 cmp	 DWORD PTR _pos$[ebp], 11 ; 0000000bH
  001b9	75 17		 jne	 SHORT $LN26@gObjIsItem

; 15872: 		{
; 15873: 			if( lpItem->m_Part == EQUIPMENT_RING_RIGHT )

  001bb	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  001be	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  001c2	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  001c5	75 02		 jne	 SHORT $LN28@gObjIsItem

; 15874: 			{
; 15875: 			}

  001c7	eb 07		 jmp	 SHORT $LN29@gObjIsItem
$LN28@gObjIsItem:

; 15876: 			else {
; 15877: 				return FALSE;

  001c9	33 c0		 xor	 eax, eax
  001cb	e9 41 03 00 00	 jmp	 $LN1@gObjIsItem
$LN29@gObjIsItem:

; 15878: 			}
; 15879: 		}

  001d0	eb 07		 jmp	 SHORT $LN19@gObjIsItem
$LN26@gObjIsItem:

; 15880: 		else return FALSE;

  001d2	33 c0		 xor	 eax, eax
  001d4	e9 38 03 00 00	 jmp	 $LN1@gObjIsItem
$LN19@gObjIsItem:

; 15881: 	}
; 15882: 	
; 15883: 	//    
; 15884: 
; 15885: 	#ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 15886: 		if( lpObj->Strength+lpObj->AddStrength < lpItem->m_RequireStrength - lpItem->m_HJOpStrength ) 
; 15887: 			return FALSE;
; 15888: 		if( lpObj->Dexterity+lpObj->AddDexterity < lpItem->m_RequireDexterity - lpItem->m_HJOpDexterity ) 
; 15889: 			return FALSE;
; 15890: 	#else
; 15891: 		if( lpObj->Strength+lpObj->AddStrength < lpItem->m_RequireStrength ) return FALSE;			//  

  001d9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001dc	0f b7 88 b4 00
	00 00		 movzx	 ecx, WORD PTR [eax+180]
  001e3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001e6	0f b7 82 e0 00
	00 00		 movzx	 eax, WORD PTR [edx+224]
  001ed	03 c8		 add	 ecx, eax
  001ef	8b 55 0c	 mov	 edx, DWORD PTR _lpItem$[ebp]
  001f2	0f b7 42 42	 movzx	 eax, WORD PTR [edx+66]
  001f6	3b c8		 cmp	 ecx, eax
  001f8	7d 07		 jge	 SHORT $LN30@gObjIsItem
  001fa	33 c0		 xor	 eax, eax
  001fc	e9 10 03 00 00	 jmp	 $LN1@gObjIsItem
$LN30@gObjIsItem:

; 15892: 		if( lpObj->Dexterity+lpObj->AddDexterity < lpItem->m_RequireDexterity) return FALSE;		//  

  00201	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00204	0f b7 88 b6 00
	00 00		 movzx	 ecx, WORD PTR [eax+182]
  0020b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0020e	0f b7 82 e2 00
	00 00		 movzx	 eax, WORD PTR [edx+226]
  00215	03 c8		 add	 ecx, eax
  00217	8b 55 0c	 mov	 edx, DWORD PTR _lpItem$[ebp]
  0021a	0f b7 42 44	 movzx	 eax, WORD PTR [edx+68]
  0021e	3b c8		 cmp	 ecx, eax
  00220	7d 07		 jge	 SHORT $LN31@gObjIsItem
  00222	33 c0		 xor	 eax, eax
  00224	e9 e8 02 00 00	 jmp	 $LN1@gObjIsItem
$LN31@gObjIsItem:

; 15893: 	#endif	 // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 15894: 
; 15895: 	if( lpObj->Level < lpItem->m_RequireLevel) return FALSE;									//  

  00229	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0022c	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00233	8b 55 0c	 mov	 edx, DWORD PTR _lpItem$[ebp]
  00236	0f b7 42 48	 movzx	 eax, WORD PTR [edx+72]
  0023a	3b c8		 cmp	 ecx, eax
  0023c	7d 07		 jge	 SHORT $LN32@gObjIsItem
  0023e	33 c0		 xor	 eax, eax
  00240	e9 cc 02 00 00	 jmp	 $LN1@gObjIsItem
$LN32@gObjIsItem:

; 15896: 
; 15897: 
; 15898: #ifdef EXPAND_ITEMSCRIPT_01_20050808
; 15899: 	if( lpItem->m_Type >= ITEM_SWORD && lpItem->m_Type < ITEM_WING )

  00245	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00248	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0024c	85 c9		 test	 ecx, ecx
  0024e	7c 5f		 jl	 SHORT $LN33@gObjIsItem
  00250	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00253	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00257	81 f9 80 01 00
	00		 cmp	 ecx, 384		; 00000180H
  0025d	7d 50		 jge	 SHORT $LN33@gObjIsItem

; 15900: 	{
; 15901: 		if( lpObj->Vitality + lpObj->AddVitality< lpItem->m_RequireVitality	) return FALSE;		//  

  0025f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00262	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  00269	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0026c	0f b7 82 e4 00
	00 00		 movzx	 eax, WORD PTR [edx+228]
  00273	03 c8		 add	 ecx, eax
  00275	8b 55 0c	 mov	 edx, DWORD PTR _lpItem$[ebp]
  00278	0f b7 42 4a	 movzx	 eax, WORD PTR [edx+74]
  0027c	3b c8		 cmp	 ecx, eax
  0027e	7d 07		 jge	 SHORT $LN34@gObjIsItem
  00280	33 c0		 xor	 eax, eax
  00282	e9 8a 02 00 00	 jmp	 $LN1@gObjIsItem
$LN34@gObjIsItem:

; 15902: 		if( lpObj->Energy   + lpObj->AddEnergy	< lpItem->m_RequireEnergy	) return FALSE;		//  

  00287	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028a	0f b7 88 ba 00
	00 00		 movzx	 ecx, WORD PTR [eax+186]
  00291	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00294	0f b7 82 e6 00
	00 00		 movzx	 eax, WORD PTR [edx+230]
  0029b	03 c8		 add	 ecx, eax
  0029d	8b 55 0c	 mov	 edx, DWORD PTR _lpItem$[ebp]
  002a0	0f b7 42 46	 movzx	 eax, WORD PTR [edx+70]
  002a4	3b c8		 cmp	 ecx, eax
  002a6	7d 07		 jge	 SHORT $LN33@gObjIsItem
  002a8	33 c0		 xor	 eax, eax
  002aa	e9 62 02 00 00	 jmp	 $LN1@gObjIsItem
$LN33@gObjIsItem:

; 15903: 	}
; 15904: #endif
; 15905: 
; 15906: #ifdef DARKLORD_WORK
; 15907: 	if( (lpObj->Leadership+lpObj->AddLeadership) < lpItem->m_RequireLeaderShip ) return FALSE;	//  

  002af	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002b2	0f b7 88 d8 00
	00 00		 movzx	 ecx, WORD PTR [eax+216]
  002b9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002bc	0f b7 82 da 00
	00 00		 movzx	 eax, WORD PTR [edx+218]
  002c3	03 c8		 add	 ecx, eax
  002c5	8b 55 0c	 mov	 edx, DWORD PTR _lpItem$[ebp]
  002c8	0f b7 42 4c	 movzx	 eax, WORD PTR [edx+76]
  002cc	3b c8		 cmp	 ecx, eax
  002ce	7d 07		 jge	 SHORT $LN36@gObjIsItem
  002d0	33 c0		 xor	 eax, eax
  002d2	e9 3a 02 00 00	 jmp	 $LN1@gObjIsItem
$LN36@gObjIsItem:

; 15908: #endif
; 15909: 	
; 15910: 	if( lpItem->m_Type >=  MAKE_ITEMNUM(12,0) && lpItem->m_Type <=  MAKE_ITEMNUM(12,6))	

  002d7	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  002da	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  002de	6a 00		 push	 0
  002e0	6a 0c		 push	 12			; 0000000cH
  002e2	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002e7	83 c4 08	 add	 esp, 8
  002ea	3b f0		 cmp	 esi, eax
  002ec	7c 38		 jl	 SHORT $LN37@gObjIsItem
  002ee	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  002f1	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  002f5	6a 06		 push	 6
  002f7	6a 0c		 push	 12			; 0000000cH
  002f9	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002fe	83 c4 08	 add	 esp, 8
  00301	3b f0		 cmp	 esi, eax
  00303	7f 21		 jg	 SHORT $LN37@gObjIsItem

; 15911: 	{	//   
; 15912: 		if( lpObj->Level < lpItem->m_RequireLevel ) return FALSE;

  00305	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00308	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0030f	8b 55 0c	 mov	 edx, DWORD PTR _lpItem$[ebp]
  00312	0f b7 42 48	 movzx	 eax, WORD PTR [edx+72]
  00316	3b c8		 cmp	 ecx, eax
  00318	7d 07		 jge	 SHORT $LN39@gObjIsItem
  0031a	33 c0		 xor	 eax, eax
  0031c	e9 f0 01 00 00	 jmp	 $LN1@gObjIsItem
$LN39@gObjIsItem:

; 15913: 	}

  00321	e9 30 01 00 00	 jmp	 $LN38@gObjIsItem
$LN37@gObjIsItem:

; 15914: 	
; 15915: #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//  1( ) 
; 15916: 	if( lpItem->m_Type ==  MAKE_ITEMNUM(12, 41))	
; 15917: 	{	//   
; 15918: 		if( lpObj->Level < lpItem->m_RequireLevel ) return FALSE;
; 15919: 	}
; 15920: #endif
; 15921: 
; 15922: #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130	//      
; 15923: 	if( lpItem->m_Type ==  MAKE_ITEMNUM(12, 42)
; 15924: 		|| lpItem->m_Type ==  MAKE_ITEMNUM(12, 43))	
; 15925: 	{	//   
; 15926: 		if( lpObj->Level < lpItem->m_RequireLevel ) return FALSE;
; 15927: 	}
; 15928: #endif
; 15929: 
; 15930: 	//   "" "" " " " " " " " " " "
; 15931: 	//    .
; 15932: 	else if( lpItem->m_Type >= MAKE_ITEMNUM(13,0) && lpItem->m_Type <= MAKE_ITEMNUM(13,15))

  00326	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00329	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0032d	6a 00		 push	 0
  0032f	6a 0d		 push	 13			; 0000000dH
  00331	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00336	83 c4 08	 add	 esp, 8
  00339	3b f0		 cmp	 esi, eax
  0033b	0f 8c 15 01 00
	00		 jl	 $LN38@gObjIsItem
  00341	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00344	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00348	6a 0f		 push	 15			; 0000000fH
  0034a	6a 0d		 push	 13			; 0000000dH
  0034c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00351	83 c4 08	 add	 esp, 8
  00354	3b f0		 cmp	 esi, eax
  00356	0f 8f fa 00 00
	00		 jg	 $LN38@gObjIsItem

; 15933: 	{
; 15934: 		if( lpItem->m_Type == MAKE_ITEMNUM(13,10) )	//   ()    .

  0035c	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  0035f	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00363	6a 0a		 push	 10			; 0000000aH
  00365	6a 0d		 push	 13			; 0000000dH
  00367	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0036c	83 c4 08	 add	 esp, 8
  0036f	3b f0		 cmp	 esi, eax
  00371	75 3f		 jne	 SHORT $LN41@gObjIsItem

; 15935: 		{
; 15936: 			if( lpItem->m_Level  <= 2 )

  00373	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00376	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  0037a	83 f9 02	 cmp	 ecx, 2
  0037d	7f 18		 jg	 SHORT $LN43@gObjIsItem

; 15937: 			{
; 15938: 				if( lpObj->Level < 20 ) return FALSE;

  0037f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00382	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00389	83 f9 14	 cmp	 ecx, 20			; 00000014H
  0038c	7d 07		 jge	 SHORT $LN45@gObjIsItem
  0038e	33 c0		 xor	 eax, eax
  00390	e9 7c 01 00 00	 jmp	 $LN1@gObjIsItem
$LN45@gObjIsItem:

; 15939: 			}

  00395	eb 16		 jmp	 SHORT $LN44@gObjIsItem
$LN43@gObjIsItem:

; 15940: 			else if( lpObj->Level < 50 ) return FALSE;

  00397	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039a	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  003a1	83 f9 32	 cmp	 ecx, 50			; 00000032H
  003a4	7d 07		 jge	 SHORT $LN44@gObjIsItem
  003a6	33 c0		 xor	 eax, eax
  003a8	e9 64 01 00 00	 jmp	 $LN1@gObjIsItem
$LN44@gObjIsItem:

; 15941: 		}		

  003ad	e9 a4 00 00 00	 jmp	 $LN38@gObjIsItem
$LN41@gObjIsItem:

; 15942: 		else if( lpItem->m_Type == MAKE_ITEMNUM(13,2) )	//      

  003b2	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  003b5	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  003b9	6a 02		 push	 2
  003bb	6a 0d		 push	 13			; 0000000dH
  003bd	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  003c2	83 c4 08	 add	 esp, 8
  003c5	3b f0		 cmp	 esi, eax
  003c7	75 2d		 jne	 SHORT $LN47@gObjIsItem

; 15943: 		{
; 15944: 			if( lpObj->MapNumber == 7 || lpObj->Level < lpItem->m_RequireLevel )

  003c9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003cc	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  003d3	83 f9 07	 cmp	 ecx, 7
  003d6	74 15		 je	 SHORT $LN50@gObjIsItem
  003d8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003db	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  003e2	8b 55 0c	 mov	 edx, DWORD PTR _lpItem$[ebp]
  003e5	0f b7 42 48	 movzx	 eax, WORD PTR [edx+72]
  003e9	3b c8		 cmp	 ecx, eax
  003eb	7d 07		 jge	 SHORT $LN49@gObjIsItem
$LN50@gObjIsItem:

; 15945: 			{
; 15946: 				return FALSE;

  003ed	33 c0		 xor	 eax, eax
  003ef	e9 1d 01 00 00	 jmp	 $LN1@gObjIsItem
$LN49@gObjIsItem:

; 15947: 			}
; 15948: 		}

  003f4	eb 60		 jmp	 SHORT $LN38@gObjIsItem
$LN47@gObjIsItem:

; 15949: #ifdef NEW_SKILL_FORSKYLAND
; 15950: 		else if( lpItem->m_Type == MAKE_ITEMNUM(13,3) )	//      

  003f6	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  003f9	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  003fd	6a 03		 push	 3
  003ff	6a 0d		 push	 13			; 0000000dH
  00401	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00406	83 c4 08	 add	 esp, 8
  00409	3b f0		 cmp	 esi, eax
  0040b	75 2d		 jne	 SHORT $LN51@gObjIsItem

; 15951: 		{
; 15952: 			if( lpObj->MapNumber == 7 || lpObj->Level < lpItem->m_RequireLevel )

  0040d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00410	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00417	83 f9 07	 cmp	 ecx, 7
  0041a	74 15		 je	 SHORT $LN54@gObjIsItem
  0041c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0041f	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00426	8b 55 0c	 mov	 edx, DWORD PTR _lpItem$[ebp]
  00429	0f b7 42 48	 movzx	 eax, WORD PTR [edx+72]
  0042d	3b c8		 cmp	 ecx, eax
  0042f	7d 07		 jge	 SHORT $LN53@gObjIsItem
$LN54@gObjIsItem:

; 15953: 			{
; 15954: 				return FALSE;

  00431	33 c0		 xor	 eax, eax
  00433	e9 d9 00 00 00	 jmp	 $LN1@gObjIsItem
$LN53@gObjIsItem:

; 15955: 			}
; 15956: 		}

  00438	eb 1c		 jmp	 SHORT $LN38@gObjIsItem
$LN51@gObjIsItem:

; 15957: #endif
; 15958: 		else 
; 15959: 		{
; 15960: 			if( lpObj->Level < lpItem->m_RequireLevel ) return FALSE;

  0043a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0043d	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00444	8b 55 0c	 mov	 edx, DWORD PTR _lpItem$[ebp]
  00447	0f b7 42 48	 movzx	 eax, WORD PTR [edx+72]
  0044b	3b c8		 cmp	 ecx, eax
  0044d	7d 07		 jge	 SHORT $LN38@gObjIsItem
  0044f	33 c0		 xor	 eax, eax
  00451	e9 bb 00 00 00	 jmp	 $LN1@gObjIsItem
$LN38@gObjIsItem:

; 15961: 		}
; 15962: 	}
; 15963: 
; 15964: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//      
; 15965: 	if(CHECK_ILLUSION_TEMPLE(lpObj->MapNumber))
; 15966: 	{
; 15967: 		if(g_IllusionTempleEvent.CheckChangeRing(lpItem->m_Type))
; 15968: 		{
; 15969: 			return FALSE;
; 15970: 		}
; 15971: 	}
; 15972: #endif
; 15973: 
; 15974: #ifdef RING_EVENT_ITEMBOX_20031124		//  -         
; 15975: 	if( lpItem->m_Type == MAKE_ITEMNUM(13,20) && lpItem->m_Level == 0) {

  00456	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00459	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0045d	6a 14		 push	 20			; 00000014H
  0045f	6a 0d		 push	 13			; 0000000dH
  00461	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00466	83 c4 08	 add	 esp, 8
  00469	3b f0		 cmp	 esi, eax
  0046b	75 2c		 jne	 SHORT $LN56@gObjIsItem
  0046d	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00470	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00474	85 c9		 test	 ecx, ecx
  00476	75 21		 jne	 SHORT $LN56@gObjIsItem

; 15976: 		int itemcount = gObjGetItemCountInEquipment(lpObj->m_Index, 13, 20, 0);

  00478	6a 00		 push	 0
  0047a	6a 14		 push	 20			; 00000014H
  0047c	6a 0d		 push	 13			; 0000000dH
  0047e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00481	8b 08		 mov	 ecx, DWORD PTR [eax]
  00483	51		 push	 ecx
  00484	e8 00 00 00 00	 call	 ?gObjGetItemCountInEquipment@@YAHHHHH@Z ; gObjGetItemCountInEquipment
  00489	83 c4 10	 add	 esp, 16			; 00000010H
  0048c	89 45 fc	 mov	 DWORD PTR _itemcount$1[ebp], eax

; 15977: 
; 15978: #ifdef ADD_CRITICAL_WIZARD_RING_20090915	//      
; 15979: 		itemcount += gObjGetItemCountInEquipment(lpObj->m_Index, 13, 107, 0);
; 15980: #endif // ADD_CRITICAL_WIZARD_RING_20090915
; 15981: 
; 15982: 		if (itemcount)

  0048f	83 7d fc 00	 cmp	 DWORD PTR _itemcount$1[ebp], 0
  00493	74 04		 je	 SHORT $LN56@gObjIsItem

; 15983: 			return FALSE;

  00495	33 c0		 xor	 eax, eax
  00497	eb 78		 jmp	 SHORT $LN1@gObjIsItem
$LN56@gObjIsItem:

; 15984: 	}
; 15985: #endif
; 15986: 
; 15987: #ifdef ADD_CRITICAL_WIZARD_RING_20090915	//    -         
; 15988: 	if( lpItem->m_Type == MAKE_ITEMNUM(13, 107) ) {
; 15989: 
; 15990: 		//         
; 15991: 		int itemcount = gObjGetItemCountInEquipment(lpObj->m_Index, 13, 20, 0);
; 15992: 		itemcount += gObjGetItemCountInEquipment(lpObj->m_Index, 13, 107, 0);
; 15993: 		
; 15994: 		if (itemcount)
; 15995: 			return FALSE;
; 15996: 	}
; 15997: #endif // ADD_CRITICAL_WIZARD_RING_20090915
; 15998: 	
; 15999: #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 16000: 	if( lpItem->m_Type == MAKE_ITEMNUM( 13, 40 ) )
; 16001: 	{
; 16002: 		int iItemCount = gObjGetItemCountInEquipment( lpObj->m_Index, 13, 40, 0 );
; 16003: 
; 16004: 		if( iItemCount > 0 )
; 16005: 		{
; 16006: 			return FALSE;
; 16007: 		}
; 16008: 	}
; 16009: #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 16010: 
; 16011: #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 16012: 	//   1  .
; 16013: 	if( lpItem->m_Type == MAKE_ITEMNUM( 13, 41 ) )
; 16014: 	{
; 16015: 		int iItemCount = gObjGetItemCountInEquipment( lpObj->m_Index, 13, 41, 0 );
; 16016: 
; 16017: 		if( iItemCount > 0 )
; 16018: 		{
; 16019: 			return FALSE;
; 16020: 		}
; 16021: 	}
; 16022: #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 16023: 	
; 16024: #ifdef UPDATE_GM_FUNCTION_20070228	// GM   , 1  
; 16025: 	if( lpItem->m_Type == MAKE_ITEMNUM( 13, 42 ) )
; 16026: 	{
; 16027: 		if( CHECK_CHAOSCASTLE(lpObj->MapNumber) )
; 16028: 		{
; 16029: 			return FALSE;
; 16030: 		}
; 16031: 
; 16032: 		int iItemCount = gObjGetItemCountInEquipment( lpObj->m_Index, 13, 42, 0 );
; 16033: 
; 16034: 		if( iItemCount > 0 )
; 16035: 		{
; 16036: 			return FALSE;
; 16037: 		}
; 16038: 	}
; 16039: #endif
; 16040: 
; 16041: #ifdef MU_CHN_THANKS_RING_EVENT_20040908	//   -   
; 16042: 	if( lpItem->m_Type == MAKE_ITEMNUM(13,20) && lpItem->m_Level == 3) {
; 16043: 		int itemcount = gObjGetItemCountInEquipment(lpObj->m_Index, 13, 20, 3);
; 16044: 
; 16045: 		if (itemcount)
; 16046: 			return FALSE;
; 16047: 	}
; 16048: #endif
; 16049: 
; 16050: #ifdef CHAOSCASTLE_SYSTEM_20040408		//     .
; 16051: 	if( lpItem->m_Type == MAKE_ITEMNUM(13, 10) )

  00499	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  0049c	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  004a0	6a 0a		 push	 10			; 0000000aH
  004a2	6a 0d		 push	 13			; 0000000dH
  004a4	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  004a9	83 c4 08	 add	 esp, 8
  004ac	3b f0		 cmp	 esi, eax
  004ae	75 49		 jne	 SHORT $LN58@gObjIsItem

; 16052: 	{
; 16053: 		if( CHECK_CHAOSCASTLE(lpObj->MapNumber) )

  004b0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004b3	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  004ba	83 f9 12	 cmp	 ecx, 18			; 00000012H
  004bd	7d 09		 jge	 SHORT $LN65@gObjIsItem
  004bf	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv346[ebp], 0
  004c6	eb 25		 jmp	 SHORT $LN66@gObjIsItem
$LN65@gObjIsItem:
  004c8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004cb	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  004d2	83 f8 17	 cmp	 eax, 23			; 00000017H
  004d5	7e 09		 jle	 SHORT $LN63@gObjIsItem
  004d7	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv345[ebp], 0
  004de	eb 07		 jmp	 SHORT $LN64@gObjIsItem
$LN63@gObjIsItem:
  004e0	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv345[ebp], 1
$LN64@gObjIsItem:
  004e7	8b 4d b4	 mov	 ecx, DWORD PTR tv345[ebp]
  004ea	89 4d b8	 mov	 DWORD PTR tv346[ebp], ecx
$LN66@gObjIsItem:
  004ed	83 7d b8 00	 cmp	 DWORD PTR tv346[ebp], 0
  004f1	74 04		 je	 SHORT $LN60@gObjIsItem

; 16054: 		{
; 16055: 			return FALSE;

  004f3	33 c0		 xor	 eax, eax
  004f5	eb 1a		 jmp	 SHORT $LN1@gObjIsItem
$LN60@gObjIsItem:

; 16056: 		}
; 16057: 	}

  004f7	eb 13		 jmp	 SHORT $LN59@gObjIsItem
$LN58@gObjIsItem:

; 16058: #endif
; 16059: 
; 16060: #ifdef ADD_ITEM_FENRIR_01_20051110		//     .
; 16061: 	if( lpItem->m_Type == MAKE_ITEMNUM(13, 37) )
; 16062: 	{
; 16063: 		if( CHECK_CHAOSCASTLE(lpObj->MapNumber) )
; 16064: 		{
; 16065: 			return FALSE;
; 16066: 		}		
; 16067: 	}
; 16068: #endif // ADD_ITEM_FENRIR_01_20051110
; 16069: 	
; 16070: #ifdef KANTURU_MOONSTONEPENDANT_20060804	//         20060823
; 16071: 	if( lpItem->m_Type == MAKE_ITEMNUM( 13,38 ) )
; 16072: 	{
; 16073: 		int itemcount = gObjGetItemCountInEquipment( lpObj->m_Index, 13, 38, 0 );
; 16074: 
; 16075: 		if( itemcount )
; 16076: 			return FALSE;
; 16077: 	}
; 16078: #endif
; 16079: 
; 16080: #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	//   &    
; 16081: 	if( lpItem->m_Type == MAKE_ITEMNUM( 13, 39 ) )
; 16082: 	{
; 16083: 		if( CHECK_CHAOSCASTLE(lpObj->MapNumber) )
; 16084: 		{
; 16085: 			return FALSE;
; 16086: 		}
; 16087: 
; 16088: 		//  
; 16089: 		int itemcount = 0;
; 16090: 		for( int iLevelCount = 0; iLevelCount < 7; iLevelCount++ )
; 16091: 		{		
; 16092: 			itemcount = gObjGetItemCountInEquipment( lpObj->m_Index, 13, 10, iLevelCount );
; 16093: 			if( itemcount )
; 16094: 				return FALSE;
; 16095: 		}
; 16096: 
; 16097: 		// 
; 16098: 		itemcount = gObjGetItemCountInEquipment( lpObj->m_Index, 13, 39, 0 );
; 16099: 		if( itemcount )
; 16100: 			return FALSE;
; 16101: 	}
; 16102: 
; 16103: 	if( lpItem->m_Type == MAKE_ITEMNUM( 13, 10 ) )
; 16104: 	{
; 16105: 		//  
; 16106: 		int itemcount = 0;
; 16107: 		for( int iLevelCount = 0; iLevelCount < 7; iLevelCount++ )
; 16108: 		{
; 16109: 			itemcount = gObjGetItemCountInEquipment( lpObj->m_Index, 13, 10, iLevelCount );
; 16110: 			if( itemcount )
; 16111: 				return FALSE;
; 16112: 		}
; 16113: 
; 16114: 		// 
; 16115: 		itemcount = gObjGetItemCountInEquipment( lpObj->m_Index, 13, 39, 0 );
; 16116: 		if( itemcount )
; 16117: 			return FALSE;		
; 16118: 	}
; 16119: #endif	// ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830
; 16120: 
; 16121: #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 16122: 	if( lpItem->m_Type == MAKE_ITEMNUM( 13, 40 ) )
; 16123: 	{
; 16124: 		if( CHECK_CHAOSCASTLE( lpObj->MapNumber ) )
; 16125: 		{
; 16126: 			return FALSE;
; 16127: 		}
; 16128: 
; 16129: 		int iItemCount = 0;
; 16130: 
; 16131: 		iItemCount = gObjGetItemCountInEquipment( lpObj->m_Index, 13, 40, 0 );
; 16132: 		if( iItemCount > 0 )
; 16133: 		{
; 16134: 			return FALSE;
; 16135: 		}
; 16136: 	}
; 16137: #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 16138: 
; 16139: #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 16140: 	if( lpItem->m_Type == MAKE_ITEMNUM( 13, 41 ) )
; 16141: 	{
; 16142: 		if( CHECK_CHAOSCASTLE( lpObj->MapNumber ) )
; 16143: 		{
; 16144: 			return FALSE;
; 16145: 		}
; 16146: 
; 16147: 		int iItemCount = 0;
; 16148: 
; 16149: 		iItemCount = gObjGetItemCountInEquipment( lpObj->m_Index, 13, 41, 0 );
; 16150: 		if( iItemCount > 0 )
; 16151: 		{
; 16152: 			return FALSE;
; 16153: 		}
; 16154: 	}
; 16155: #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 16156: 
; 16157: //------------->
; 16158: //20081013    - (grooving)
; 16159: #ifdef ADD_XMASEVENT_POLYMORPH_RING_20080930
; 16160: 	//   1  .
; 16161: 	if( lpItem->m_Type == MAKE_ITEMNUM( 13, 68 ) )
; 16162: 	{
; 16163: 		if( CHECK_CHAOSCASTLE( lpObj->MapNumber ) )
; 16164: 		{
; 16165: 			return FALSE;
; 16166: 		}
; 16167: 		
; 16168: 		int iItemCount = 0;
; 16169: 		
; 16170: 		iItemCount = gObjGetItemCountInEquipment( lpObj->m_Index, 13, 68, 0 );
; 16171: 		if( iItemCount > 0 )
; 16172: 		{
; 16173: 			return FALSE;
; 16174: 		}
; 16175: 	}
; 16176: #endif // ADD_XMASEVENT_POLYMORPH_RING_20080930
; 16177: //<-------------
; 16178: #ifdef ADD_PREMIUMITEM_PANDA
; 16179: 	if( lpItem->m_Type == MAKE_ITEMNUM( 13, 76 ) )
; 16180: 	{
; 16181: 		if( CHECK_CHAOSCASTLE( lpObj->MapNumber ) )
; 16182: 		{
; 16183: 			return FALSE;
; 16184: 		}
; 16185: 		
; 16186: 		int iItemCount = 0;
; 16187: 		
; 16188: 		iItemCount = gObjGetItemCountInEquipment( lpObj->m_Index, 13, 76, 0 );
; 16189: 		if( iItemCount > 0 )
; 16190: 		{
; 16191: 			return FALSE;
; 16192: 		}
; 16193: 	}
; 16194: #endif // ADD_PREMIUMITEM_PANDA
; 16195: 
; 16196: 	//     .
; 16197: #ifdef ITEM_INDEX_EXTEND_20050706	//   14     .
; 16198: 	else if( lpItem->m_Type >= MAKE_ITEMNUM(14,0) ) return FALSE;
; 16199: #else
; 16200: 	else if( lpItem->m_Type > (14<<8) ) return FALSE;

  004f9	8b 45 0c	 mov	 eax, DWORD PTR _lpItem$[ebp]
  004fc	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00500	81 f9 00 0e 00
	00		 cmp	 ecx, 3584		; 00000e00H
  00506	7e 04		 jle	 SHORT $LN59@gObjIsItem
  00508	33 c0		 xor	 eax, eax
  0050a	eb 05		 jmp	 SHORT $LN1@gObjIsItem
$LN59@gObjIsItem:

; 16201: #endif
; 16202: 
; 16203: 	return TRUE;

  0050c	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjIsItem:

; 16204: }

  00511	5f		 pop	 edi
  00512	5e		 pop	 esi
  00513	5b		 pop	 ebx
  00514	8b e5		 mov	 esp, ebp
  00516	5d		 pop	 ebp
  00517	c3		 ret	 0
?gObjIsItemPut@@YAHPAVOBJECTSTRUCT@@PAVCItem@@H@Z ENDP	; gObjIsItemPut
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCheckMaxZen@@YAHHH@Z
_TEXT	SEGMENT
tv66 = -84						; size = 4
tv67 = -80						; size = 4
__Money$ = -12						; size = 8
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_nAddZen$ = 12						; size = 4
?gObjCheckMaxZen@@YAHHH@Z PROC				; gObjCheckMaxZen, COMDAT

; 32043: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 32044: 	if	(!CHECK_LIMIT(aIndex, MAX_OBJECT)) 

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN7@gObjCheckM
  0000f	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN8@gObjCheckM
$LN7@gObjCheckM:
  00018	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN5@gObjCheckM
  00021	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN6@gObjCheckM
$LN5@gObjCheckM:
  0002a	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN6@gObjCheckM:
  00031	8b 45 ac	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b0	 mov	 DWORD PTR tv67[ebp], eax
$LN8@gObjCheckM:
  00037	83 7d b0 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 04		 jne	 SHORT $LN2@gObjCheckM

; 32045: 		return FALSE;

  0003d	33 c0		 xor	 eax, eax
  0003f	eb 6d		 jmp	 SHORT $LN1@gObjCheckM
$LN2@gObjCheckM:

; 32046: 
; 32047: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00041	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00048	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004e	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 32048: 
; 32049: 	__int64 _Money = 0;

  00051	0f 57 c0	 xorps	 xmm0, xmm0
  00054	66 0f 13 45 f4	 movlpd	 QWORD PTR __Money$[ebp], xmm0

; 32050: 	_Money = (__int64)lpObj->Money + (__int64)nAddZen;

  00059	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005c	8b 80 b0 00 00
	00		 mov	 eax, DWORD PTR [eax+176]
  00062	99		 cdq
  00063	8b c8		 mov	 ecx, eax
  00065	8b f2		 mov	 esi, edx
  00067	8b 45 0c	 mov	 eax, DWORD PTR _nAddZen$[ebp]
  0006a	99		 cdq
  0006b	03 c8		 add	 ecx, eax
  0006d	13 f2		 adc	 esi, edx
  0006f	89 4d f4	 mov	 DWORD PTR __Money$[ebp], ecx
  00072	89 75 f8	 mov	 DWORD PTR __Money$[ebp+4], esi

; 32051: 
; 32052: 	if( _Money > MAX_ZEN )

  00075	83 7d f8 00	 cmp	 DWORD PTR __Money$[ebp+4], 0
  00079	7c 2e		 jl	 SHORT $LN3@gObjCheckM
  0007b	7f 09		 jg	 SHORT $LN9@gObjCheckM
  0007d	81 7d f4 00 94
	35 77		 cmp	 DWORD PTR __Money$[ebp], 2000000000 ; 77359400H
  00084	76 23		 jbe	 SHORT $LN3@gObjCheckM
$LN9@gObjCheckM:

; 32053: 	{
; 32054: 		GCServerMsgStringSend(lMsg.Get(1250), aIndex, 1);	//     ZEN  .

  00086	6a 01		 push	 1
  00088	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0008b	50		 push	 eax
  0008c	68 e2 04 00 00	 push	 1250			; 000004e2H
  00091	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 32055: 		return FALSE;

  000a5	33 c0		 xor	 eax, eax
  000a7	eb 05		 jmp	 SHORT $LN1@gObjCheckM
$LN3@gObjCheckM:

; 32056: 	}
; 32057: 	
; 32058: 	return TRUE;

  000a9	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjCheckM:

; 32059: }

  000ae	5f		 pop	 edi
  000af	5e		 pop	 esi
  000b0	5b		 pop	 ebx
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
?gObjCheckMaxZen@@YAHHH@Z ENDP				; gObjCheckMaxZen
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGetItemCountInEquipment@@YAHHHHH@Z
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_count$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_itemtype$ = 12						; size = 4
_itemindex$ = 16					; size = 4
_itemlevel$ = 20					; size = 4
?gObjGetItemCountInEquipment@@YAHHHHH@Z PROC		; gObjGetItemCountInEquipment, COMDAT

; 30017: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 30018: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 30019: 	int count = 0;

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 30020: 	for(int  n=0; n<MAX_EQUIPMENT; n++)

  00020	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00027	eb 09		 jmp	 SHORT $LN4@gObjGetIte
$LN2@gObjGetIte:
  00029	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjGetIte:
  00032	83 7d f4 0c	 cmp	 DWORD PTR _n$1[ebp], 12	; 0000000cH
  00036	7d 70		 jge	 SHORT $LN3@gObjGetIte

; 30021: 	{
; 30022: 		if( lpObj->pInventory[n].IsItem() == TRUE )

  00038	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00042	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00048	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0004d	83 f8 01	 cmp	 eax, 1
  00050	75 54		 jne	 SHORT $LN5@gObjGetIte

; 30023: 		{
; 30024: 			if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(itemtype,itemindex) )

  00052	69 45 f4 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0005c	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00062	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00067	8b 45 10	 mov	 eax, DWORD PTR _itemindex$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 0c	 mov	 ecx, DWORD PTR _itemtype$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00074	83 c4 08	 add	 esp, 8
  00077	3b f0		 cmp	 esi, eax
  00079	75 2b		 jne	 SHORT $LN5@gObjGetIte

; 30025: 			{
; 30026: #ifdef SECOND_QUEST
; 30027: 				if( itemlevel != -1 && lpObj->pInventory[n].m_Level != itemlevel )

  0007b	83 7d 14 ff	 cmp	 DWORD PTR _itemlevel$[ebp], -1
  0007f	74 1c		 je	 SHORT $LN7@gObjGetIte
  00081	69 45 f4 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00088	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0008b	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00091	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00096	3b 45 14	 cmp	 eax, DWORD PTR _itemlevel$[ebp]
  00099	74 02		 je	 SHORT $LN7@gObjGetIte

; 30028: 				{
; 30029: 					continue;

  0009b	eb 8c		 jmp	 SHORT $LN2@gObjGetIte
$LN7@gObjGetIte:

; 30030: 				}
; 30031: #endif
; 30032: 				count++;

  0009d	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  000a0	83 c0 01	 add	 eax, 1
  000a3	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN5@gObjGetIte:

; 30033: 			}
; 30034: 		}
; 30035: 	}

  000a6	eb 81		 jmp	 SHORT $LN2@gObjGetIte
$LN3@gObjGetIte:

; 30036: 	return count;

  000a8	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]

; 30037: }

  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?gObjGetItemCountInEquipment@@YAHHHHH@Z ENDP		; gObjGetItemCountInEquipment
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?SkillTestFrustrum@@YAHHHH@Z
_TEXT	SEGMENT
_d$1 = -16						; size = 4
_i$2 = -12						; size = 4
_j$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_aIndex$ = 16						; size = 4
?SkillTestFrustrum@@YAHHHH@Z PROC			; SkillTestFrustrum, COMDAT

; 32028: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 32029: 	LPOBJECTSTRUCT lpObj=(LPOBJECTSTRUCT)&gObj[aIndex];

  00009	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 32030: 
; 32031: 	int j = 3;

  00019	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _j$[ebp], 3

; 32032: 	for(int i=0;i<4;j=i,i++)

  00020	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00027	eb 0f		 jmp	 SHORT $LN4@SkillTestF
$LN2@SkillTestF:
  00029	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  0002c	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
  0002f	8b 4d f4	 mov	 ecx, DWORD PTR _i$2[ebp]
  00032	83 c1 01	 add	 ecx, 1
  00035	89 4d f4	 mov	 DWORD PTR _i$2[ebp], ecx
$LN4@SkillTestF:
  00038	83 7d f4 04	 cmp	 DWORD PTR _i$2[ebp], 4
  0003c	7d 5e		 jge	 SHORT $LN3@SkillTestF

; 32033: 	{
; 32034: 		int d = (lpObj->fSkillFrustrumX[i]-x) * (lpObj->fSkillFrustrumY[j]-y) -

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00044	8b 94 81 fc 0e
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+3836]
  0004b	2b 55 08	 sub	 edx, DWORD PTR _x$[ebp]
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00054	8b 84 81 0c 0f
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+3852]
  0005b	2b 45 0c	 sub	 eax, DWORD PTR _y$[ebp]
  0005e	0f af d0	 imul	 edx, eax
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  00064	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00067	8b 8c 88 fc 0e
	00 00		 mov	 ecx, DWORD PTR [eax+ecx*4+3836]
  0006e	2b 4d 08	 sub	 ecx, DWORD PTR _x$[ebp]
  00071	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  00074	8b 75 fc	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00077	8b 84 86 0c 0f
	00 00		 mov	 eax, DWORD PTR [esi+eax*4+3852]
  0007e	2b 45 0c	 sub	 eax, DWORD PTR _y$[ebp]
  00081	0f af c8	 imul	 ecx, eax
  00084	2b d1		 sub	 edx, ecx
  00086	89 55 f0	 mov	 DWORD PTR _d$1[ebp], edx

; 32035: 	      		(lpObj->fSkillFrustrumX[j]-x) * (lpObj->fSkillFrustrumY[i]-y);
; 32036: 		if(d < 0.f) return FALSE;

  00089	f3 0f 2a 45 f0	 cvtsi2ss xmm0, DWORD PTR _d$1[ebp]
  0008e	0f 57 c9	 xorps	 xmm1, xmm1
  00091	0f 2f c8	 comiss	 xmm1, xmm0
  00094	76 04		 jbe	 SHORT $LN5@SkillTestF
  00096	33 c0		 xor	 eax, eax
  00098	eb 07		 jmp	 SHORT $LN1@SkillTestF
$LN5@SkillTestF:

; 32037: 	}

  0009a	eb 8d		 jmp	 SHORT $LN2@SkillTestF
$LN3@SkillTestF:

; 32038: 	return TRUE;

  0009c	b8 01 00 00 00	 mov	 eax, 1
$LN1@SkillTestF:

; 32039: }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	5b		 pop	 ebx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
?SkillTestFrustrum@@YAHHHH@Z ENDP			; SkillTestFrustrum
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?SkillFrustrum@@YAXEH@Z
_TEXT	SEGMENT
_i$1 = -168						; size = 4
_vFrustrum$ = -164					; size = 48
_Matrix$ = -116						; size = 48
_Angle$ = -68						; size = 12
_p$ = -56						; size = 48
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_bangle$ = 8						; size = 1
_aIndex$ = 12						; size = 4
?SkillFrustrum@@YAXEH@Z PROC				; SkillFrustrum, COMDAT

; 32004: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 32005: 	LPOBJECTSTRUCT lpObj=(LPOBJECTSTRUCT)&gObj[aIndex];

  00016	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 32006: 
; 32007: 	vec3_t p[4];
; 32008: 	Vector(-6 ,6.f ,0.f,p[0]);

  00026	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0002b	6b c8 00	 imul	 ecx, eax, 0
  0002e	8d 54 0d c8	 lea	 edx, DWORD PTR _p$[ebp+ecx]
  00032	b8 04 00 00 00	 mov	 eax, 4
  00037	6b c8 00	 imul	 ecx, eax, 0
  0003a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c0c00000
  00042	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0
  00047	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0004c	6b c8 00	 imul	 ecx, eax, 0
  0004f	8d 54 0d c8	 lea	 edx, DWORD PTR _p$[ebp+ecx]
  00053	b8 04 00 00 00	 mov	 eax, 4
  00058	c1 e0 00	 shl	 eax, 0
  0005b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40c00000
  00063	f3 0f 11 04 02	 movss	 DWORD PTR [edx+eax], xmm0
  00068	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0006d	6b c8 00	 imul	 ecx, eax, 0
  00070	8d 54 0d c8	 lea	 edx, DWORD PTR _p$[ebp+ecx]
  00074	b8 04 00 00 00	 mov	 eax, 4
  00079	d1 e0		 shl	 eax, 1
  0007b	0f 57 c0	 xorps	 xmm0, xmm0
  0007e	f3 0f 11 04 02	 movss	 DWORD PTR [edx+eax], xmm0

; 32009: 	Vector( 6 ,6.f ,0.f,p[1]);

  00083	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00088	c1 e0 00	 shl	 eax, 0
  0008b	8d 4c 05 c8	 lea	 ecx, DWORD PTR _p$[ebp+eax]
  0008f	ba 04 00 00 00	 mov	 edx, 4
  00094	6b c2 00	 imul	 eax, edx, 0
  00097	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40c00000
  0009f	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
  000a4	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  000a9	c1 e0 00	 shl	 eax, 0
  000ac	8d 4c 05 c8	 lea	 ecx, DWORD PTR _p$[ebp+eax]
  000b0	ba 04 00 00 00	 mov	 edx, 4
  000b5	c1 e2 00	 shl	 edx, 0
  000b8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40c00000
  000c0	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0
  000c5	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  000ca	c1 e0 00	 shl	 eax, 0
  000cd	8d 4c 05 c8	 lea	 ecx, DWORD PTR _p$[ebp+eax]
  000d1	ba 04 00 00 00	 mov	 edx, 4
  000d6	d1 e2		 shl	 edx, 1
  000d8	0f 57 c0	 xorps	 xmm0, xmm0
  000db	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 32010: 	Vector( 1 ,0.f ,0.f,p[2]);

  000e0	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  000e5	d1 e0		 shl	 eax, 1
  000e7	8d 4c 05 c8	 lea	 ecx, DWORD PTR _p$[ebp+eax]
  000eb	ba 04 00 00 00	 mov	 edx, 4
  000f0	6b c2 00	 imul	 eax, edx, 0
  000f3	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000fb	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
  00100	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00105	d1 e0		 shl	 eax, 1
  00107	8d 4c 05 c8	 lea	 ecx, DWORD PTR _p$[ebp+eax]
  0010b	ba 04 00 00 00	 mov	 edx, 4
  00110	c1 e2 00	 shl	 edx, 0
  00113	0f 57 c0	 xorps	 xmm0, xmm0
  00116	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0
  0011b	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00120	d1 e0		 shl	 eax, 1
  00122	8d 4c 05 c8	 lea	 ecx, DWORD PTR _p$[ebp+eax]
  00126	ba 04 00 00 00	 mov	 edx, 4
  0012b	d1 e2		 shl	 edx, 1
  0012d	0f 57 c0	 xorps	 xmm0, xmm0
  00130	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 32011: 	Vector(-1 ,0.f ,0.f,p[3]);

  00135	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0013a	6b c8 03	 imul	 ecx, eax, 3
  0013d	8d 54 0d c8	 lea	 edx, DWORD PTR _p$[ebp+ecx]
  00141	b8 04 00 00 00	 mov	 eax, 4
  00146	6b c8 00	 imul	 ecx, eax, 0
  00149	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00151	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0
  00156	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0015b	6b c8 03	 imul	 ecx, eax, 3
  0015e	8d 54 0d c8	 lea	 edx, DWORD PTR _p$[ebp+ecx]
  00162	b8 04 00 00 00	 mov	 eax, 4
  00167	c1 e0 00	 shl	 eax, 0
  0016a	0f 57 c0	 xorps	 xmm0, xmm0
  0016d	f3 0f 11 04 02	 movss	 DWORD PTR [edx+eax], xmm0
  00172	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00177	6b c8 03	 imul	 ecx, eax, 3
  0017a	8d 54 0d c8	 lea	 edx, DWORD PTR _p$[ebp+ecx]
  0017e	b8 04 00 00 00	 mov	 eax, 4
  00183	d1 e0		 shl	 eax, 1
  00185	0f 57 c0	 xorps	 xmm0, xmm0
  00188	f3 0f 11 04 02	 movss	 DWORD PTR [edx+eax], xmm0

; 32012: 	vec3_t Angle;
; 32013: 	float Matrix[3][4];
; 32014: 	Vector(0.f,0.f,(float)(bangle*360/255),Angle);

  0018d	b8 04 00 00 00	 mov	 eax, 4
  00192	6b c8 00	 imul	 ecx, eax, 0
  00195	0f 57 c0	 xorps	 xmm0, xmm0
  00198	f3 0f 11 44 0d
	bc		 movss	 DWORD PTR _Angle$[ebp+ecx], xmm0
  0019e	b8 04 00 00 00	 mov	 eax, 4
  001a3	c1 e0 00	 shl	 eax, 0
  001a6	0f 57 c0	 xorps	 xmm0, xmm0
  001a9	f3 0f 11 44 05
	bc		 movss	 DWORD PTR _Angle$[ebp+eax], xmm0
  001af	0f b6 45 08	 movzx	 eax, BYTE PTR _bangle$[ebp]
  001b3	69 c0 68 01 00
	00		 imul	 eax, eax, 360
  001b9	99		 cdq
  001ba	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  001bf	f7 f9		 idiv	 ecx
  001c1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001c5	ba 04 00 00 00	 mov	 edx, 4
  001ca	d1 e2		 shl	 edx, 1
  001cc	f3 0f 11 44 15
	bc		 movss	 DWORD PTR _Angle$[ebp+edx], xmm0

; 32015: 	AngleMatrix(Angle,Matrix);

  001d2	8d 45 8c	 lea	 eax, DWORD PTR _Matrix$[ebp]
  001d5	50		 push	 eax
  001d6	8d 4d bc	 lea	 ecx, DWORD PTR _Angle$[ebp]
  001d9	51		 push	 ecx
  001da	e8 00 00 00 00	 call	 _AngleMatrix
  001df	83 c4 08	 add	 esp, 8

; 32016:     vec3_t vFrustrum[4];
; 32017: 	
; 32018: 	for(int i=0;i<4;i++)

  001e2	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$1[ebp], 0
  001ec	eb 0f		 jmp	 SHORT $LN4@SkillFrust
$LN2@SkillFrust:
  001ee	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  001f4	83 c0 01	 add	 eax, 1
  001f7	89 85 58 ff ff
	ff		 mov	 DWORD PTR _i$1[ebp], eax
$LN4@SkillFrust:
  001fd	83 bd 58 ff ff
	ff 04		 cmp	 DWORD PTR _i$1[ebp], 4
  00204	0f 8d 9a 00 00
	00		 jge	 $LN3@SkillFrust

; 32019: 	{
; 32020: 		VectorRotate(p[i],Matrix,vFrustrum[i]);

  0020a	6b 85 58 ff ff
	ff 0c		 imul	 eax, DWORD PTR _i$1[ebp], 12
  00211	8d 8c 05 5c ff
	ff ff		 lea	 ecx, DWORD PTR _vFrustrum$[ebp+eax]
  00218	51		 push	 ecx
  00219	8d 55 8c	 lea	 edx, DWORD PTR _Matrix$[ebp]
  0021c	52		 push	 edx
  0021d	6b 85 58 ff ff
	ff 0c		 imul	 eax, DWORD PTR _i$1[ebp], 12
  00224	8d 4c 05 c8	 lea	 ecx, DWORD PTR _p$[ebp+eax]
  00228	51		 push	 ecx
  00229	e8 00 00 00 00	 call	 _VectorRotate
  0022e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 32021: 		lpObj->fSkillFrustrumX[i] = (int)(vFrustrum[i][0])+lpObj->X;

  00231	6b 85 58 ff ff
	ff 0c		 imul	 eax, DWORD PTR _i$1[ebp], 12
  00238	8d 8c 05 5c ff
	ff ff		 lea	 ecx, DWORD PTR _vFrustrum$[ebp+eax]
  0023f	ba 04 00 00 00	 mov	 edx, 4
  00244	6b c2 00	 imul	 eax, edx, 0
  00247	f3 0f 2c 0c 01	 cvttss2si ecx, DWORD PTR [ecx+eax]
  0024c	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0024f	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  00256	03 c8		 add	 ecx, eax
  00258	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR _i$1[ebp]
  0025e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00261	89 8c 90 fc 0e
	00 00		 mov	 DWORD PTR [eax+edx*4+3836], ecx

; 32022: 		lpObj->fSkillFrustrumY[i] = (INT)(vFrustrum[i][1])+lpObj->Y;

  00268	6b 85 58 ff ff
	ff 0c		 imul	 eax, DWORD PTR _i$1[ebp], 12
  0026f	8d 8c 05 5c ff
	ff ff		 lea	 ecx, DWORD PTR _vFrustrum$[ebp+eax]
  00276	ba 04 00 00 00	 mov	 edx, 4
  0027b	c1 e2 00	 shl	 edx, 0
  0027e	f3 0f 2c 04 11	 cvttss2si eax, DWORD PTR [ecx+edx]
  00283	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00286	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  0028d	03 c2		 add	 eax, edx
  0028f	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _i$1[ebp]
  00295	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00298	89 84 8a 0c 0f
	00 00		 mov	 DWORD PTR [edx+ecx*4+3852], eax

; 32023: 	}

  0029f	e9 4a ff ff ff	 jmp	 $LN2@SkillFrust
$LN3@SkillFrust:

; 32024: }

  002a4	5f		 pop	 edi
  002a5	5e		 pop	 esi
  002a6	5b		 pop	 ebx
  002a7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002aa	33 cd		 xor	 ecx, ebp
  002ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b1	8b e5		 mov	 esp, ebp
  002b3	5d		 pop	 ebp
  002b4	c3		 ret	 0
?SkillFrustrum@@YAXEH@Z ENDP				; SkillFrustrum
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjDelayLifeCheck@@YAXH@Z
_TEXT	SEGMENT
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjDelayLifeCheck@@YAXH@Z PROC			; gObjDelayLifeCheck, COMDAT

; 31577: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31578: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 31579: 
; 31580: 	if( lpObj->m_CheckLifeTime > 0 )

  00019	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	83 b8 d8 0e 00
	00 00		 cmp	 DWORD PTR [eax+3800], 0
  00023	7e 77		 jle	 SHORT $LN5@gObjDelayL

; 31581: 	{	// 
; 31582: 		lpObj->m_CheckLifeTime--;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00028	8b 88 d8 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3800]
  0002e	83 e9 01	 sub	 ecx, 1
  00031	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00034	89 8a d8 0e 00
	00		 mov	 DWORD PTR [edx+3800], ecx

; 31583: 		if( lpObj->m_CheckLifeTime <= 0 )

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003d	83 b8 d8 0e 00
	00 00		 cmp	 DWORD PTR [eax+3800], 0
  00044	7f 56		 jg	 SHORT $LN5@gObjDelayL

; 31584: 		{
; 31585: 			lpObj->m_CheckLifeTime = 0;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00049	c7 80 d8 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3800], 0

; 31586: 			
; 31587: 			if( lpObj->Life < 0 ) lpObj->Life = 0;

  00053	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00056	0f 57 c0	 xorps	 xmm0, xmm0
  00059	0f 2f 80 bc 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+188]
  00060	76 0e		 jbe	 SHORT $LN4@gObjDelayL
  00062	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00065	0f 57 c0	 xorps	 xmm0, xmm0
  00068	f3 0f 11 80 bc
	00 00 00	 movss	 DWORD PTR [eax+188], xmm0
$LN4@gObjDelayL:

; 31588: 
; 31589: 			if( lpObj->lpAttackObj != NULL )

  00070	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00073	83 b8 30 02 00
	00 00		 cmp	 DWORD PTR [eax+560], 0
  0007a	74 20		 je	 SHORT $LN5@gObjDelayL

; 31590: #ifdef ADD_SKILL_WITH_COMBO
; 31591: 				gObjLifeCheck(lpObj, lpObj->lpAttackObj, 0, 1, 0, 0, 0);

  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	6a 00		 push	 0
  00082	6a 01		 push	 1
  00084	6a 00		 push	 0
  00086	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00089	8b 88 30 02 00
	00		 mov	 ecx, DWORD PTR [eax+560]
  0008f	51		 push	 ecx
  00090	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ?gObjLifeCheck@@YAXPAVOBJECTSTRUCT@@0HHHHE@Z ; gObjLifeCheck
  00099	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN5@gObjDelayL:

; 31592: #else
; 31593: 				gObjLifeCheck(lpObj, lpObj->lpAttackObj, 0, 1, 0, 0);
; 31594: #endif
; 31595: 		}
; 31596: 	}
; 31597: }

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
?gObjDelayLifeCheck@@YAXH@Z ENDP			; gObjDelayLifeCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjNextExpCal@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjNextExpCal@@YAXPAVOBJECTSTRUCT@@@Z PROC		; gObjNextExpCal, COMDAT

; 8629 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 8630 : 	lpObj->NextExp = gLevelExperience[lpObj->Level];

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00013	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00016	8b 04 8d 00 00
	00 00		 mov	 eax, DWORD PTR ?gLevelExperience@@3PAKA[ecx*4]
  0001d	89 82 ac 00 00
	00		 mov	 DWORD PTR [edx+172], eax

; 8631 : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?gObjNextExpCal@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; gObjNextExpCal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjUniriaSprite@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_Uniria$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjUniriaSprite@@YAHPAVOBJECTSTRUCT@@@Z PROC		; gObjUniriaSprite, COMDAT

; 10433: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 10434: 	//   
; 10435: 	if( lpObj->pInventory[EQUIPMENT_HELPER].IsItem() == FALSE ) return FALSE;

  00009	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  0000e	c1 e1 03	 shl	 ecx, 3
  00011	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00014	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0001a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0001f	85 c0		 test	 eax, eax
  00021	75 04		 jne	 SHORT $LN2@gObjUniria
  00023	33 c0		 xor	 eax, eax
  00025	eb 45		 jmp	 SHORT $LN1@gObjUniria
$LN2@gObjUniria:

; 10436: 
; 10437: 	CItem	*Uniria = &lpObj->pInventory[EQUIPMENT_HELPER];

  00027	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0002c	c1 e0 03	 shl	 eax, 3
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00032	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  00038	89 45 fc	 mov	 DWORD PTR _Uniria$[ebp], eax

; 10438: 	
; 10439: 	//  ..
; 10440: 	if( Uniria->m_Type == MAKE_ITEMNUM(13,2))

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _Uniria$[ebp]
  0003e	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00042	6a 02		 push	 2
  00044	6a 0d		 push	 13			; 0000000dH
  00046	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0004b	83 c4 08	 add	 esp, 8
  0004e	3b f0		 cmp	 esi, eax
  00050	75 18		 jne	 SHORT $LN4@gObjUniria

; 10441: 	{
; 10442: 		if( Uniria->m_Durability > 0 )

  00052	8b 45 fc	 mov	 eax, DWORD PTR _Uniria$[ebp]
  00055	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  0005a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00061	76 07		 jbe	 SHORT $LN4@gObjUniria

; 10443: 		{
; 10444: 			return TRUE;

  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	eb 02		 jmp	 SHORT $LN1@gObjUniria
$LN4@gObjUniria:

; 10445: 		}
; 10446: 	}
; 10447: 	return FALSE;

  0006a	33 c0		 xor	 eax, eax
$LN1@gObjUniria:

; 10448: }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?gObjUniriaSprite@@YAHPAVOBJECTSTRUCT@@@Z ENDP		; gObjUniriaSprite
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjWingSprite@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_Wing$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjWingSprite@@YAHPAVOBJECTSTRUCT@@@Z PROC		; gObjWingSprite, COMDAT

; 10393: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 10394: 	if( lpObj->Type != OBJTYPE_CHARACTER ) return FALSE;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00010	83 f9 01	 cmp	 ecx, 1
  00013	74 07		 je	 SHORT $LN2@gObjWingSp
  00015	33 c0		 xor	 eax, eax
  00017	e9 91 00 00 00	 jmp	 $LN1@gObjWingSp
$LN2@gObjWingSp:

; 10395: 
; 10396: 	//   
; 10397: 	if( lpObj->pInventory[EQUIPMENT_WING].IsItem() == FALSE ) return FALSE;

  0001c	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00021	6b c8 07	 imul	 ecx, eax, 7
  00024	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00027	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0002d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00032	85 c0		 test	 eax, eax
  00034	75 04		 jne	 SHORT $LN3@gObjWingSp
  00036	33 c0		 xor	 eax, eax
  00038	eb 73		 jmp	 SHORT $LN1@gObjWingSp
$LN3@gObjWingSp:

; 10398: 
; 10399: 	CItem	*Wing = &lpObj->pInventory[EQUIPMENT_WING];

  0003a	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0003f	6b c8 07	 imul	 ecx, eax, 7
  00042	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00045	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0004b	89 4d fc	 mov	 DWORD PTR _Wing$[ebp], ecx

; 10400: 		
; 10401: 	//  ..
; 10402: #ifdef ADD_THIRD_WING_20070525	// gObjWingSprite(...) 3 
; 10403: 	if( ( Wing->m_Type >= MAKE_ITEMNUM( 12, 0 ) && Wing->m_Type <= MAKE_ITEMNUM( 12, 6 ) )
; 10404: 		|| Wing->m_Type <= MAKE_ITEMNUM( 13, 30 ) 	// 
; 10405: 		|| ( Wing->m_Type >= MAKE_ITEMNUM( 12, 36 ) && Wing->m_Type <= MAKE_ITEMNUM( 12, 40 ) )	// 3 
; 10406: #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912 // gObjWingSprite(...)  1( ) 
; 10407: 		|| Wing->m_Type == MAKE_ITEMNUM( 12, 41 ) 	//  1 ( )
; 10408: #endif
; 10409: #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130	//gObjWingSprite(...)   ,   
; 10410: 		|| Wing->m_Type == MAKE_ITEMNUM( 12, 42 )
; 10411: 		|| Wing->m_Type == MAKE_ITEMNUM( 12, 43 )
; 10412: #endif		
; 10413: 		)
; 10414: #else
; 10415: #ifdef DARKLORD_WORK
; 10416: 	if( (Wing->m_Type >= MAKE_ITEMNUM(12,0) && Wing->m_Type <= MAKE_ITEMNUM(12,6)) || 

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _Wing$[ebp]
  00051	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00055	6a 00		 push	 0
  00057	6a 0c		 push	 12			; 0000000cH
  00059	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0005e	83 c4 08	 add	 esp, 8
  00061	3b f0		 cmp	 esi, eax
  00063	7c 17		 jl	 SHORT $LN6@gObjWingSp
  00065	8b 45 fc	 mov	 eax, DWORD PTR _Wing$[ebp]
  00068	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0006c	6a 06		 push	 6
  0006e	6a 0c		 push	 12			; 0000000cH
  00070	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00075	83 c4 08	 add	 esp, 8
  00078	3b f0		 cmp	 esi, eax
  0007a	7e 17		 jle	 SHORT $LN5@gObjWingSp
$LN6@gObjWingSp:
  0007c	8b 45 fc	 mov	 eax, DWORD PTR _Wing$[ebp]
  0007f	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00083	6a 1e		 push	 30			; 0000001eH
  00085	6a 0d		 push	 13			; 0000000dH
  00087	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0008c	83 c4 08	 add	 esp, 8
  0008f	3b f0		 cmp	 esi, eax
  00091	7f 18		 jg	 SHORT $LN7@gObjWingSp
$LN5@gObjWingSp:

; 10417: 		Wing->m_Type <= MAKE_ITEMNUM(13,30) )	//  
; 10418: #else
; 10419: 	if( Wing->m_Type >= MAKE_ITEMNUM(12,0) && Wing->m_Type <= MAKE_ITEMNUM(12,6) )
; 10420: #endif
; 10421: #endif	// ADD_THIRD_WING_20070525
; 10422: 	{
; 10423: 		if( Wing->m_Durability > 0 )

  00093	8b 45 fc	 mov	 eax, DWORD PTR _Wing$[ebp]
  00096	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  0009b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  000a2	76 07		 jbe	 SHORT $LN7@gObjWingSp

; 10424: 		{
; 10425: 			return TRUE;

  000a4	b8 01 00 00 00	 mov	 eax, 1
  000a9	eb 02		 jmp	 SHORT $LN1@gObjWingSp
$LN7@gObjWingSp:

; 10426: 		}
; 10427: 	}
; 10428: 	return FALSE;

  000ab	33 c0		 xor	 eax, eax
$LN1@gObjWingSp:

; 10429: }

  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
?gObjWingSprite@@YAHPAVOBJECTSTRUCT@@@Z ENDP		; gObjWingSprite
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjAngelSprite@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_Angel$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjAngelSprite@@YAHPAVOBJECTSTRUCT@@@Z PROC		; gObjAngelSprite, COMDAT

; 10303: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 10304: 	if( lpObj->Type != OBJTYPE_CHARACTER ) return FALSE;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00010	83 f9 01	 cmp	 ecx, 1
  00013	74 04		 je	 SHORT $LN2@gObjAngelS
  00015	33 c0		 xor	 eax, eax
  00017	eb 63		 jmp	 SHORT $LN1@gObjAngelS
$LN2@gObjAngelS:

; 10305: 
; 10306: 	//   
; 10307: 	if( lpObj->pInventory[EQUIPMENT_HELPER].IsItem() == FALSE ) return FALSE;

  00019	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  0001e	c1 e1 03	 shl	 ecx, 3
  00021	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00024	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0002a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002f	85 c0		 test	 eax, eax
  00031	75 04		 jne	 SHORT $LN3@gObjAngelS
  00033	33 c0		 xor	 eax, eax
  00035	eb 45		 jmp	 SHORT $LN1@gObjAngelS
$LN3@gObjAngelS:

; 10308: 
; 10309: 	CItem	*Angel = &lpObj->pInventory[EQUIPMENT_HELPER];

  00037	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0003c	c1 e0 03	 shl	 eax, 3
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00042	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  00048	89 45 fc	 mov	 DWORD PTR _Angel$[ebp], eax

; 10310: 	
; 10311: 	//  ..
; 10312: 	if( Angel->m_Type == MAKE_ITEMNUM(13,0)) 

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _Angel$[ebp]
  0004e	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00052	6a 00		 push	 0
  00054	6a 0d		 push	 13			; 0000000dH
  00056	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0005b	83 c4 08	 add	 esp, 8
  0005e	3b f0		 cmp	 esi, eax
  00060	75 18		 jne	 SHORT $LN5@gObjAngelS

; 10313: 	{
; 10314: 		if( Angel->m_Durability > 0 )

  00062	8b 45 fc	 mov	 eax, DWORD PTR _Angel$[ebp]
  00065	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  0006a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00071	76 07		 jbe	 SHORT $LN5@gObjAngelS

; 10315: 		{			
; 10316: 			return TRUE;

  00073	b8 01 00 00 00	 mov	 eax, 1
  00078	eb 02		 jmp	 SHORT $LN1@gObjAngelS
$LN5@gObjAngelS:

; 10317: 		}
; 10318: 	}
; 10319: 	return FALSE;

  0007a	33 c0		 xor	 eax, eax
$LN1@gObjAngelS:

; 10320: }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?gObjAngelSprite@@YAHPAVOBJECTSTRUCT@@@Z ENDP		; gObjAngelSprite
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSatanSprite@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_Satan$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjSatanSprite@@YAHPAVOBJECTSTRUCT@@@Z PROC		; gObjSatanSprite, COMDAT

; 10324: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 10325: 	if( lpObj->Type != OBJTYPE_CHARACTER ) return FALSE;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00010	83 f9 01	 cmp	 ecx, 1
  00013	74 04		 je	 SHORT $LN2@gObjSatanS
  00015	33 c0		 xor	 eax, eax
  00017	eb 63		 jmp	 SHORT $LN1@gObjSatanS
$LN2@gObjSatanS:

; 10326: 
; 10327: 	//   
; 10328: 	if( lpObj->pInventory[EQUIPMENT_HELPER].IsItem() == FALSE ) return FALSE;

  00019	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  0001e	c1 e1 03	 shl	 ecx, 3
  00021	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00024	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0002a	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0002f	85 c0		 test	 eax, eax
  00031	75 04		 jne	 SHORT $LN3@gObjSatanS
  00033	33 c0		 xor	 eax, eax
  00035	eb 45		 jmp	 SHORT $LN1@gObjSatanS
$LN3@gObjSatanS:

; 10329: 
; 10330: 	CItem	*Satan = &lpObj->pInventory[EQUIPMENT_HELPER];

  00037	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0003c	c1 e0 03	 shl	 eax, 3
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00042	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  00048	89 45 fc	 mov	 DWORD PTR _Satan$[ebp], eax

; 10331: 		
; 10332: 	//  ..
; 10333: 	if( Satan->m_Type == MAKE_ITEMNUM(13,1) )

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _Satan$[ebp]
  0004e	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00052	6a 01		 push	 1
  00054	6a 0d		 push	 13			; 0000000dH
  00056	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0005b	83 c4 08	 add	 esp, 8
  0005e	3b f0		 cmp	 esi, eax
  00060	75 18		 jne	 SHORT $LN5@gObjSatanS

; 10334: 	{
; 10335: 		if( Satan->m_Durability > 0 )

  00062	8b 45 fc	 mov	 eax, DWORD PTR _Satan$[ebp]
  00065	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  0006a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00071	76 07		 jbe	 SHORT $LN5@gObjSatanS

; 10336: 		{
; 10337: 			return TRUE;

  00073	b8 01 00 00 00	 mov	 eax, 1
  00078	eb 02		 jmp	 SHORT $LN1@gObjSatanS
$LN5@gObjSatanS:

; 10338: 		}
; 10339: 	}
; 10340: 	
; 10341: 	return FALSE;

  0007a	33 c0		 xor	 eax, eax
$LN1@gObjSatanS:

; 10342: }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?gObjSatanSprite@@YAHPAVOBJECTSTRUCT@@@Z ENDP		; gObjSatanSprite
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSpriteDamage@@YAXPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
tv296 = -148						; size = 4
tv287 = -148						; size = 4
tv297 = -144						; size = 4
tv288 = -144						; size = 4
_durTsend$1 = -76					; size = 4
_durSsend$2 = -72					; size = 4
_sItemInfo$3 = -68					; size = 5
_n$4 = -60						; size = 4
_founditem$5 = -56					; size = 4
_durTsend$6 = -52					; size = 4
_durSsend$7 = -48					; size = 4
_sItemInfo$8 = -44					; size = 5
_n$9 = -36						; size = 4
_founditem$10 = -32					; size = 4
_itemtype$11 = -28					; size = 4
_exp$12 = -24						; size = 4
_fdamage$ = -20						; size = 4
_sprite$ = -16						; size = 4
_fN$ = -12						; size = 4
_send_dur$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_damage$ = 12						; size = 4
?gObjSpriteDamage@@YAXPAVOBJECTSTRUCT@@H@Z PROC		; gObjSpriteDamage, COMDAT

; 10452: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 10453: 	if( lpObj->Type != OBJTYPE_CHARACTER ) return;

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00019	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0001d	83 f9 01	 cmp	 ecx, 1
  00020	74 05		 je	 SHORT $LN8@gObjSprite
  00022	e9 a7 07 00 00	 jmp	 $LN1@gObjSprite
$LN8@gObjSprite:

; 10454: 	BOOL send_dur=FALSE;

  00027	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _send_dur$[ebp], 0

; 10455: 
; 10456: 	//   
; 10457: 	if( lpObj->pInventory[EQUIPMENT_HELPER].IsItem() == FALSE ) return;

  0002e	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00033	c1 e1 03	 shl	 ecx, 3
  00036	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00039	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0003f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00044	85 c0		 test	 eax, eax
  00046	75 05		 jne	 SHORT $LN9@gObjSprite
  00048	e9 81 07 00 00	 jmp	 $LN1@gObjSprite
$LN9@gObjSprite:

; 10458: 
; 10459: 	float fN = 10.0;

  0004d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  00055	f3 0f 11 45 f4	 movss	 DWORD PTR _fN$[ebp], xmm0

; 10460: /*
; 10461: // pc   20090128 grooving
; 10462: #ifdef PCBANG_ADVANTAGE //happycat@20050203 (PC) - 	
; 10463: #ifdef PCBANG_ADVANTAGE_EXPAND_20060919	
; 10464: 	if( IsOKPCBangBenefitAll(lpObj) )
; 10465: #else
; 10466: 	if (lpObj->m_bPCBangUser)
; 10467: #endif//PCBANG_ADVANTAGE_EXPAND_20060919
; 10468: 	{
; 10469: 		fN = 20.0;
; 10470: 	}
; 10471: #endif//PCBANG_ADVANTAGE
; 10472: 
; 10473: #ifdef PCBANG_FREE_KALIMA_EVENT_20060124
; 10474: 	if( lpObj->m_bPCBangCouponUser )
; 10475: 	{
; 10476: 		fN = 20.0;
; 10477: 	}
; 10478: #endif //PCBANG_FREE_KALIMA_EVENT_20060124
; 10479: */
; 10480: 	CItem	*sprite = &lpObj->pInventory[EQUIPMENT_HELPER];

  0005a	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0005f	c1 e0 03	 shl	 eax, 3
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00065	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  0006b	89 45 f0	 mov	 DWORD PTR _sprite$[ebp], eax

; 10481: 	float	fdamage = (float)damage;

  0006e	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _damage$[ebp]
  00073	f3 0f 11 45 ec	 movss	 DWORD PTR _fdamage$[ebp], xmm0

; 10482: 
; 10483: 	if( sprite->m_Type == MAKE_ITEMNUM(13,0)

  00078	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  0007b	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0007f	6a 00		 push	 0
  00081	6a 0d		 push	 13			; 0000000dH
  00083	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00088	83 c4 08	 add	 esp, 8
  0008b	3b f0		 cmp	 esi, eax
  0008d	75 45		 jne	 SHORT $LN10@gObjSprite

; 10484: #if GAME_VERSION >= G_V_S3_E1
; 10485: 		|| sprite->m_Type == MAKE_ITEMNUM(13, 67)
; 10486: #endif
; 10487: 		)	// , 
; 10488: 	{
; 10489: 		fdamage  = (float)(damage*3)/10;								

  0008f	6b 45 0c 03	 imul	 eax, DWORD PTR _damage$[ebp], 3
  00093	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00097	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  0009f	f3 0f 11 45 ec	 movss	 DWORD PTR _fdamage$[ebp], xmm0

; 10490: 		fdamage /= fN;							// happycat@20050201

  000a4	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fdamage$[ebp]
  000a9	f3 0f 5e 45 f4	 divss	 xmm0, DWORD PTR _fN$[ebp]
  000ae	f3 0f 11 45 ec	 movss	 DWORD PTR _fdamage$[ebp], xmm0

; 10491: 
; 10492: 		sprite->m_Durability -= fdamage;

  000b3	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  000b6	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  000bb	f3 0f 5c 45 ec	 subss	 xmm0, DWORD PTR _fdamage$[ebp]
  000c0	8b 4d f0	 mov	 ecx, DWORD PTR _sprite$[ebp]
  000c3	f3 0f 11 41 24	 movss	 DWORD PTR [ecx+36], xmm0

; 10493: 		send_dur = TRUE;

  000c8	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _send_dur$[ebp], 1

; 10494: 	}

  000cf	e9 db 02 00 00	 jmp	 $LN18@gObjSprite
$LN10@gObjSprite:

; 10495: 	else if( sprite->m_Type == MAKE_ITEMNUM(13,1) )	// 

  000d4	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  000d7	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  000db	6a 01		 push	 1
  000dd	6a 0d		 push	 13			; 0000000dH
  000df	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000e4	83 c4 08	 add	 esp, 8
  000e7	3b f0		 cmp	 esi, eax
  000e9	75 46		 jne	 SHORT $LN12@gObjSprite

; 10496: 	{
; 10497: 		fdamage  = (float)(damage*2)/10;

  000eb	8b 45 0c	 mov	 eax, DWORD PTR _damage$[ebp]
  000ee	d1 e0		 shl	 eax, 1
  000f0	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000f4	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  000fc	f3 0f 11 45 ec	 movss	 DWORD PTR _fdamage$[ebp], xmm0

; 10498: 		fdamage /= fN;							// happycat@20050201

  00101	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fdamage$[ebp]
  00106	f3 0f 5e 45 f4	 divss	 xmm0, DWORD PTR _fN$[ebp]
  0010b	f3 0f 11 45 ec	 movss	 DWORD PTR _fdamage$[ebp], xmm0

; 10499: 		sprite->m_Durability -= fdamage;

  00110	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  00113	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00118	f3 0f 5c 45 ec	 subss	 xmm0, DWORD PTR _fdamage$[ebp]
  0011d	8b 4d f0	 mov	 ecx, DWORD PTR _sprite$[ebp]
  00120	f3 0f 11 41 24	 movss	 DWORD PTR [ecx+36], xmm0

; 10500: 		send_dur = TRUE;

  00125	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _send_dur$[ebp], 1

; 10501: 	}

  0012c	e9 7e 02 00 00	 jmp	 $LN18@gObjSprite
$LN12@gObjSprite:

; 10502: #ifdef ADD_PREMIUMITEM_PANDA
; 10503: 	else if( sprite->m_Type == MAKE_ITEMNUM(13, 80)) // 
; 10504: 	{
; 10505: 		fdamage  = (float)(damage*2)/50;
; 10506: 		fdamage /= fN;							// happycat@20050201
; 10507: 		
; 10508: 		sprite->m_Durability -= fdamage;
; 10509: 		send_dur = TRUE;
; 10510: 	}
; 10511: #endif // ADD_PREMIUMITEM_PANDA
; 10512: #ifdef ADD_UNICORN_PET_20090915
; 10513: 	else if( sprite->m_Type == MAKE_ITEMNUM(13, 106) )	//  
; 10514: 	{
; 10515: 		fdamage  = (float)(damage*2)/10;
; 10516: 		fdamage /= fN;
; 10517: 		sprite->m_Durability -= fdamage;
; 10518: 		send_dur = TRUE;
; 10519: 	}
; 10520: #endif // ADD_UNICORN_PET_20090915
; 10521: 
; 10522: #ifdef	ADD_SAFEGUARD_ITEM_20080702
; 10523: 	//------>
; 10524: 	//grooving  : ,   
; 10525: 
; 10526: #ifdef MODIFY_DEMON_AND_SPRITE_DURABILITY_20081023
; 10527: 	if( sprite->m_Type == MAKE_ITEMNUM(13,64) || sprite->m_Type == MAKE_ITEMNUM(13,65) ){
; 10528: 		//      . by natinda
; 10529: 		fN += 10.0f;
; 10530: 	}
; 10531: #endif // MODIFY_DEMON_AND_SPRITE_DURABILITY_20081023
; 10532: 
; 10533: 	if( sprite->m_Type == MAKE_ITEMNUM(13, 64) )	// 
; 10534: 	{
; 10535: 
; 10536: #if defined (PREMIUMITEM_20090106) && defined (FOR_KOREA)
; 10537: 		/*
; 10538: 		// pc   20090128 grooving
; 10539: 		if ( IsOKPCBangBenefitAll(lpObj) == TRUE )
; 10540: 		{
; 10541: 			//PC 
; 10542: 			fdamage  = (float)(damage*2)/10;
; 10543: 			fdamage /= 200;
; 10544: 		}
; 10545: 		else
; 10546: 		*/
; 10547: 		{
; 10548: 			fdamage  = (float)(damage*2)/10;
; 10549: 			fdamage /= 100;
; 10550: 		}
; 10551: #else //PREMIUMITEM_20090106
; 10552: 		fdamage  = (float)(damage*3)/10;
; 10553: 		fdamage /= fN;
; 10554: #endif //PREMIUMITEM_20090106
; 10555: 
; 10556: 		sprite->m_Durability -= fdamage;
; 10557: 		send_dur = TRUE;
; 10558: 	}
; 10559: 	else if( sprite->m_Type == MAKE_ITEMNUM(13, 65) )	// 
; 10560: 	{
; 10561: #if defined (PREMIUMITEM_20090106) && defined (FOR_KOREA)
; 10562: 		{
; 10563: 			fdamage  = (float)(damage*2)/10;
; 10564: 			fdamage /= 100;
; 10565: 		}
; 10566: #else
; 10567: 		fdamage  = (float)(damage*2)/10;
; 10568: 		fdamage /= fN;
; 10569: #endif // PREMIUMITEM_20090106
; 10570: 		sprite->m_Durability -= fdamage;
; 10571: 		send_dur = TRUE;
; 10572: 	}
; 10573: 	//<------
; 10574: #endif // ADD_SAFEGUARD_ITEM_20080702
; 10575: 	else if( sprite->m_Type == MAKE_ITEMNUM(13,2) )	//   

  00131	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  00134	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00138	6a 02		 push	 2
  0013a	6a 0d		 push	 13			; 0000000dH
  0013c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00141	83 c4 08	 add	 esp, 8
  00144	3b f0		 cmp	 esi, eax
  00146	75 45		 jne	 SHORT $LN14@gObjSprite

; 10576: 	{
; 10577: 		fdamage  = (float)(damage*1)/10;

  00148	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _damage$[ebp]
  0014d	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  00155	f3 0f 11 45 ec	 movss	 DWORD PTR _fdamage$[ebp], xmm0

; 10578: 		fdamage /= 10;

  0015a	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fdamage$[ebp]
  0015f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  00167	f3 0f 11 45 ec	 movss	 DWORD PTR _fdamage$[ebp], xmm0

; 10579: 		sprite->m_Durability -= fdamage;

  0016c	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  0016f	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00174	f3 0f 5c 45 ec	 subss	 xmm0, DWORD PTR _fdamage$[ebp]
  00179	8b 4d f0	 mov	 ecx, DWORD PTR _sprite$[ebp]
  0017c	f3 0f 11 41 24	 movss	 DWORD PTR [ecx+36], xmm0

; 10580: 		send_dur = TRUE;

  00181	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _send_dur$[ebp], 1

; 10581: 	}

  00188	e9 22 02 00 00	 jmp	 $LN18@gObjSprite
$LN14@gObjSprite:

; 10582: #ifdef NEW_SKILL_FORSKYLAND
; 10583: 	else if( sprite->m_Type == MAKE_ITEMNUM(13,3) )	// 

  0018d	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  00190	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00194	6a 03		 push	 3
  00196	6a 0d		 push	 13			; 0000000dH
  00198	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0019d	83 c4 08	 add	 esp, 8
  001a0	3b f0		 cmp	 esi, eax
  001a2	75 45		 jne	 SHORT $LN16@gObjSprite

; 10584: 	{
; 10585: 		fdamage  = (float)(damage*1)/20;

  001a4	f3 0f 2a 45 0c	 cvtsi2ss xmm0, DWORD PTR _damage$[ebp]
  001a9	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41a00000
  001b1	f3 0f 11 45 ec	 movss	 DWORD PTR _fdamage$[ebp], xmm0

; 10586: 		fdamage /= 10;

  001b6	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fdamage$[ebp]
  001bb	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  001c3	f3 0f 11 45 ec	 movss	 DWORD PTR _fdamage$[ebp], xmm0

; 10587: 		sprite->m_Durability -= fdamage;

  001c8	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  001cb	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  001d0	f3 0f 5c 45 ec	 subss	 xmm0, DWORD PTR _fdamage$[ebp]
  001d5	8b 4d f0	 mov	 ecx, DWORD PTR _sprite$[ebp]
  001d8	f3 0f 11 41 24	 movss	 DWORD PTR [ecx+36], xmm0

; 10588: 		send_dur = TRUE;

  001dd	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _send_dur$[ebp], 1

; 10589: 	}

  001e4	e9 c6 01 00 00	 jmp	 $LN18@gObjSprite
$LN16@gObjSprite:

; 10590: #endif
; 10591: #ifdef DARKLORD_WORK
; 10592: 	else if( sprite->m_Type == MAKE_ITEMNUM(13,4) )	// 

  001e9	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  001ec	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  001f0	6a 04		 push	 4
  001f2	6a 0d		 push	 13			; 0000000dH
  001f4	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001f9	83 c4 08	 add	 esp, 8
  001fc	3b f0		 cmp	 esi, eax
  001fe	0f 85 ab 01 00
	00		 jne	 $LN18@gObjSprite

; 10593: 	{
; 10594: 		if( sprite->m_Durability < 1 )			

  00204	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  00207	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0020f	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  00213	76 05		 jbe	 SHORT $LN19@gObjSprite

; 10595: 			return;				// 

  00215	e9 b4 05 00 00	 jmp	 $LN1@gObjSprite
$LN19@gObjSprite:

; 10596: 
; 10597: 		fdamage  = (float)(damage*2)/10;

  0021a	8b 45 0c	 mov	 eax, DWORD PTR _damage$[ebp]
  0021d	d1 e0		 shl	 eax, 1
  0021f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00223	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  0022b	f3 0f 11 45 ec	 movss	 DWORD PTR _fdamage$[ebp], xmm0

; 10598: 		fdamage /= 10;

  00230	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fdamage$[ebp]
  00235	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  0023d	f3 0f 11 45 ec	 movss	 DWORD PTR _fdamage$[ebp], xmm0

; 10599: 		fdamage++;

  00242	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fdamage$[ebp]
  00247	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  0024f	f3 0f 11 45 ec	 movss	 DWORD PTR _fdamage$[ebp], xmm0

; 10600: 
; 10601: 		sprite->m_DurabilitySmall += (WORD)fdamage;

  00254	f3 0f 2c 45 ec	 cvttss2si eax, DWORD PTR _fdamage$[ebp]
  00259	0f b7 c8	 movzx	 ecx, ax
  0025c	8b 55 f0	 mov	 edx, DWORD PTR _sprite$[ebp]
  0025f	0f b7 42 28	 movzx	 eax, WORD PTR [edx+40]
  00263	03 c1		 add	 eax, ecx
  00265	8b 4d f0	 mov	 ecx, DWORD PTR _sprite$[ebp]
  00268	66 89 41 28	 mov	 WORD PTR [ecx+40], ax

; 10602: 
; 10603: #ifdef UPDATE_MASTER_LEVEL_4RANK_20080428	//      ()
; 10604: 		if( sprite->m_DurabilitySmall > 1500 + lpObj->m_MPSkillOpt.iMpsPetDurDownSpeed)
; 10605: #else	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 10606: 		if( sprite->m_DurabilitySmall > 1500 )

  0026c	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  0026f	0f b7 48 28	 movzx	 ecx, WORD PTR [eax+40]
  00273	81 f9 dc 05 00
	00		 cmp	 ecx, 1500		; 000005dcH
  00279	0f 8e 2b 01 00
	00		 jle	 $LN20@gObjSprite

; 10607: #endif	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 10608: 		{
; 10609: 			sprite->m_Durability--;

  0027f	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  00282	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00287	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0028f	8b 4d f0	 mov	 ecx, DWORD PTR _sprite$[ebp]
  00292	f3 0f 11 41 24	 movss	 DWORD PTR [ecx+36], xmm0

; 10610: 			sprite->m_DurabilitySmall = 0;

  00297	33 c0		 xor	 eax, eax
  00299	8b 4d f0	 mov	 ecx, DWORD PTR _sprite$[ebp]
  0029c	66 89 41 28	 mov	 WORD PTR [ecx+40], ax

; 10611: 			send_dur = TRUE;

  002a0	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _send_dur$[ebp], 1

; 10612: 
; 10613: 			if( sprite->m_Durability < 1 )	

  002a7	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  002aa	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002b2	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  002b6	0f 86 d0 00 00
	00		 jbe	 $LN22@gObjSprite

; 10614: 			{
; 10615: 				sprite->m_Durability = 0.f;

  002bc	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  002bf	0f 57 c0	 xorps	 xmm0, xmm0
  002c2	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0

; 10616: 				int	exp = lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_PetItem_Exp;

  002c7	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  002cc	c1 e0 00	 shl	 eax, 0
  002cf	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002d2	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  002d8	8b 84 02 a4 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+164]
  002df	89 45 e8	 mov	 DWORD PTR _exp$12[ebp], eax

; 10617: 				if( sprite->DecPetItemExp(10) )	//  10% 

  002e2	6a 0a		 push	 10			; 0000000aH
  002e4	8b 4d f0	 mov	 ecx, DWORD PTR _sprite$[ebp]
  002e7	e8 00 00 00 00	 call	 ?DecPetItemExp@CItem@@QAEHH@Z ; CItem::DecPetItemExp
  002ec	85 c0		 test	 eax, eax
  002ee	0f 84 98 00 00
	00		 je	 $LN22@gObjSprite

; 10618: 				{	//      
; 10619: 					LogAddTD("[%s][%s][PetItemExpDown] [%s] Level:[%d]Exp:[%d]DecExp[%d]", 

  002f4	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  002f9	c1 e0 00	 shl	 eax, 0
  002fc	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002ff	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00305	8b 4d e8	 mov	 ecx, DWORD PTR _exp$12[ebp]
  00308	2b 8c 02 a4 00
	00 00		 sub	 ecx, DWORD PTR [edx+eax+164]
  0030f	51		 push	 ecx
  00310	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  00315	c1 e2 03	 shl	 edx, 3
  00318	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0031b	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00321	8b 94 11 a4 00
	00 00		 mov	 edx, DWORD PTR [ecx+edx+164]
  00328	52		 push	 edx
  00329	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0032e	c1 e0 03	 shl	 eax, 3
  00331	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00334	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0033a	8b 84 02 a0 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+160]
  00341	50		 push	 eax
  00342	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00347	c1 e1 03	 shl	 ecx, 3
  0034a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0034d	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00353	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00358	50		 push	 eax
  00359	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0035c	83 c0 73	 add	 eax, 115		; 00000073H
  0035f	50		 push	 eax
  00360	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00363	83 c1 68	 add	 ecx, 104		; 00000068H
  00366	51		 push	 ecx
  00367	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@HDCMLJGF@?$FL?$CFs?$FN?$FL?$CFs?$FN?$FLPetItemExpDown?$FN?5?$FL?$CFs?$FN?5L@
  0036c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00372	83 c4 1c	 add	 esp, 28			; 0000001cH

; 10620: 							lpObj->AccountID, lpObj->Name,
; 10621: 							lpObj->pInventory[EQUIPMENT_HELPER].GetName(),
; 10622: 							lpObj->pInventory[EQUIPMENT_HELPER].m_PetItem_Level,
; 10623: 							lpObj->pInventory[EQUIPMENT_HELPER].m_PetItem_Exp,
; 10624: 							exp-lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_PetItem_Exp);
; 10625: 					CDarkSpirit::SendLevelmsg(lpObj->m_Index, EQUIPMENT_HELPER, 1, 255);

  00375	68 ff 00 00 00	 push	 255			; 000000ffH
  0037a	6a 01		 push	 1
  0037c	6a 08		 push	 8
  0037e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00381	8b 08		 mov	 ecx, DWORD PTR [eax]
  00383	51		 push	 ecx
  00384	e8 00 00 00 00	 call	 ?SendLevelmsg@CDarkSpirit@@SAXHHHH@Z ; CDarkSpirit::SendLevelmsg
  00389	83 c4 10	 add	 esp, 16			; 00000010H
$LN22@gObjSprite:

; 10626: 				}
; 10627: 
; 10628: 	#if TESTSERVER == 1
; 10629: 				DebugOutput(lpObj->m_Index, "[%s] LevelDown Lv:%d Exp:%d", 
; 10630: 							lpObj->pInventory[EQUIPMENT_HELPER].GetName(),				
; 10631: 							lpObj->pInventory[EQUIPMENT_HELPER].m_PetItem_Level, 
; 10632: 							lpObj->pInventory[EQUIPMENT_HELPER].m_PetItem_Exp);	
; 10633: 	#endif
; 10634: 
; 10635: #ifdef MODIFY_LOG_SYSTEM_2_3_20060828
; 10636: 	#ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 10637: 				LogAddTD("[%s][%s]  Item is Broken because durability is exhausted [%u]",
; 10638: 	#else
; 10639: 				LogAddTD("[%s][%s]  Item is Broken because durability is exhausted [%d]",
; 10640: 	#endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 10641: 					lpObj->AccountID, lpObj->Name, lpObj->pInventory[EQUIPMENT_HELPER].m_Number );
; 10642: #endif // MODIFY_LOG_SYSTEM_2_3_20060828
; 10643: 			}
; 10644: 			GCItemDurSend(lpObj->m_Index, EQUIPMENT_HELPER, (BYTE)sprite->m_Durability, 0);

  0038c	6a 00		 push	 0
  0038e	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  00391	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  00396	0f b6 d1	 movzx	 edx, cl
  00399	52		 push	 edx
  0039a	6a 08		 push	 8
  0039c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039f	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a1	51		 push	 ecx
  003a2	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  003a7	83 c4 10	 add	 esp, 16			; 00000010H
$LN20@gObjSprite:

; 10645: 		}	
; 10646: 		
; 10647: 		return;

  003aa	e9 1f 04 00 00	 jmp	 $LN1@gObjSprite
$LN18@gObjSprite:

; 10648: 	}
; 10649: #endif
; 10650: 
; 10651: #ifdef ADD_ITEM_FENRIR_01_20051110
; 10652: 	//   	
; 10653: 	else if( sprite->m_Type == MAKE_ITEMNUM(13,37) )	// 
; 10654: 	{
; 10655: 		if( sprite->m_Durability < 1 )			
; 10656: 			return;				
; 10657: 		
; 10658: 		int iMaxDurSmall = g_iFenrirDefaultMaxDurSmall;
; 10659: 		int iMultipleDmg = 2;
; 10660: 
; 10661: 		if( lpObj->Class == CLASS_WIZARD )
; 10662: 		{
; 10663: 
; 10664: 		}
; 10665: 		else if( lpObj->Class == CLASS_KNIGHT )
; 10666: 		{
; 10667: 
; 10668: 		}
; 10669: 		else if( lpObj->Class == CLASS_ELF )
; 10670: 		{
; 10671: 			iMaxDurSmall = g_iFenrirElfMaxDurSmall;
; 10672: 			iMultipleDmg = 2;
; 10673: 		}
; 10674: 		else if( lpObj->Class == CLASS_MAGUMSA)
; 10675: 		{
; 10676: 
; 10677: 		}
; 10678: 		else if( lpObj->Class == CLASS_DARKLORD)
; 10679: 		{
; 10680: 
; 10681: 		}
; 10682: 
; 10683: 		fdamage  = (float)(damage*iMultipleDmg)/10;
; 10684: 		fdamage /= 10;
; 10685: 		fdamage++;
; 10686: 
; 10687: 		sprite->m_DurabilitySmall += (WORD)fdamage;
; 10688: 		
; 10689: 		if( sprite->m_DurabilitySmall > iMaxDurSmall )
; 10690: 		{
; 10691: 			sprite->m_Durability--;
; 10692: 			sprite->m_DurabilitySmall = 0;
; 10693: 
; 10694: 			if( sprite->m_Durability < 1 )	
; 10695: 			{
; 10696: 				sprite->m_Durability = 0.f;
; 10697: 			}
; 10698: 			
; 10699: 			send_dur = TRUE;
; 10700: 			
; 10701: 			//GCItemDurSend(lpObj->m_Index, EQUIPMENT_HELPER, (BYTE)sprite->m_Durability, 0);
; 10702: 		}	
; 10703: 		
; 10704: 		//    .
; 10705: 		//return;
; 10706: 	}
; 10707: #endif // ADD_ITEM_FENRIR_01_20051110
; 10708: 
; 10709: 	
; 10710: 	if( send_dur )

  003af	83 7d f8 00	 cmp	 DWORD PTR _send_dur$[ebp], 0
  003b3	0f 84 15 04 00
	00		 je	 $LN36@gObjSprite

; 10711: 	{
; 10712: 		GCItemDurSend(lpObj->m_Index, EQUIPMENT_HELPER, (BYTE)sprite->m_Durability, 0);

  003b9	6a 00		 push	 0
  003bb	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  003be	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  003c3	0f b6 d1	 movzx	 edx, cl
  003c6	52		 push	 edx
  003c7	6a 08		 push	 8
  003c9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ce	51		 push	 ecx
  003cf	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  003d4	83 c4 10	 add	 esp, 16			; 00000010H

; 10713: 		if( sprite->m_Durability < 1.f )

  003d7	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  003da	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003e2	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  003e6	0f 86 e2 03 00
	00		 jbe	 $LN36@gObjSprite

; 10714: 		{
; 10715: 			int itemtype = sprite->m_Type;

  003ec	8b 45 f0	 mov	 eax, DWORD PTR _sprite$[ebp]
  003ef	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  003f3	89 4d e4	 mov	 DWORD PTR _itemtype$11[ebp], ecx

; 10716: 
; 10717: 			LogAddTD(lMsg.Get(522), lpObj->AccountID, lpObj->Name, lpObj->pInventory[EQUIPMENT_HELPER].GetName(), lpObj->pInventory[EQUIPMENT_HELPER].m_Level);

  003f6	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  003fb	c1 e0 03	 shl	 eax, 3
  003fe	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00401	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00407	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  0040c	50		 push	 eax
  0040d	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00412	c1 e1 03	 shl	 ecx, 3
  00415	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00418	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0041e	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00423	50		 push	 eax
  00424	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00427	83 c0 73	 add	 eax, 115		; 00000073H
  0042a	50		 push	 eax
  0042b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0042e	83 c1 68	 add	 ecx, 104		; 00000068H
  00431	51		 push	 ecx
  00432	68 0a 02 00 00	 push	 522			; 0000020aH
  00437	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0043c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00442	50		 push	 eax
  00443	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00449	83 c4 14	 add	 esp, 20			; 00000014H

; 10718: 
; 10719: 			gObjInventoryDeleteItem(lpObj->m_Index, EQUIPMENT_HELPER);			

  0044c	6a 08		 push	 8
  0044e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00451	8b 08		 mov	 ecx, DWORD PTR [eax]
  00453	51		 push	 ecx
  00454	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00459	83 c4 08	 add	 esp, 8

; 10720: 			GCInventoryItemDeleteSend(lpObj->m_Index, EQUIPMENT_HELPER, 0);

  0045c	6a 00		 push	 0
  0045e	6a 08		 push	 8
  00460	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00463	8b 08		 mov	 ecx, DWORD PTR [eax]
  00465	51		 push	 ecx
  00466	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0046b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10721: 
; 10722: 			gObjMakePreviewCharSet(lpObj->m_Index);

  0046e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00471	8b 08		 mov	 ecx, DWORD PTR [eax]
  00473	51		 push	 ecx
  00474	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  00479	83 c4 04	 add	 esp, 4

; 10723: 			GCEquipmentChange(lpObj->m_Index, EQUIPMENT_HELPER);

  0047c	6a 08		 push	 8
  0047e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00481	8b 08		 mov	 ecx, DWORD PTR [eax]
  00483	51		 push	 ecx
  00484	e8 00 00 00 00	 call	 ?GCEquipmentChange@@YAXHH@Z ; GCEquipmentChange
  00489	83 c4 08	 add	 esp, 8

; 10724: 			
; 10725: #ifdef FOR_BLOODCASTLE
; 10726: 			if (CHECK_BLOODCASTLE(lpObj->MapNumber)
; 10727: #ifdef CHAOSCASTLE_SYSTEM_20040408		//      
; 10728: 				|| CHECK_CHAOSCASTLE(lpObj->MapNumber)

  0048c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0048f	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00496	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00499	7d 0c		 jge	 SHORT $LN41@gObjSprite
  0049b	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv288[ebp], 0
  004a5	eb 31		 jmp	 SHORT $LN42@gObjSprite
$LN41@gObjSprite:
  004a7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004aa	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  004b1	83 f8 11	 cmp	 eax, 17			; 00000011H
  004b4	7e 0c		 jle	 SHORT $LN39@gObjSprite
  004b6	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv287[ebp], 0
  004c0	eb 0a		 jmp	 SHORT $LN40@gObjSprite
$LN39@gObjSprite:
  004c2	c7 85 6c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv287[ebp], 1
$LN40@gObjSprite:
  004cc	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv287[ebp]
  004d2	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv288[ebp], ecx
$LN42@gObjSprite:
  004d8	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR tv288[ebp], 0
  004df	75 59		 jne	 SHORT $LN26@gObjSprite
  004e1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004e4	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  004eb	83 f9 12	 cmp	 ecx, 18			; 00000012H
  004ee	7d 0c		 jge	 SHORT $LN45@gObjSprite
  004f0	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv297[ebp], 0
  004fa	eb 31		 jmp	 SHORT $LN46@gObjSprite
$LN45@gObjSprite:
  004fc	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004ff	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00506	83 f8 17	 cmp	 eax, 23			; 00000017H
  00509	7e 0c		 jle	 SHORT $LN43@gObjSprite
  0050b	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv296[ebp], 0
  00515	eb 0a		 jmp	 SHORT $LN44@gObjSprite
$LN43@gObjSprite:
  00517	c7 85 6c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv296[ebp], 1
$LN44@gObjSprite:
  00521	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv296[ebp]
  00527	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv297[ebp], ecx
$LN46@gObjSprite:
  0052d	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR tv297[ebp], 0
  00534	0f 84 2e 01 00
	00		 je	 $LN31@gObjSprite
$LN26@gObjSprite:

; 10729: #endif
; 10730: 				) 
; 10731: 			{	// 
; 10732: 				if( itemtype == MAKE_ITEMNUM(13,0) 
; 10733: 					|| itemtype == MAKE_ITEMNUM(13,1) 

  0053a	6a 00		 push	 0
  0053c	6a 0d		 push	 13			; 0000000dH
  0053e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00543	83 c4 08	 add	 esp, 8
  00546	39 45 e4	 cmp	 DWORD PTR _itemtype$11[ebp], eax
  00549	74 15		 je	 SHORT $LN28@gObjSprite
  0054b	6a 01		 push	 1
  0054d	6a 0d		 push	 13			; 0000000dH
  0054f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00554	83 c4 08	 add	 esp, 8
  00557	39 45 e4	 cmp	 DWORD PTR _itemtype$11[ebp], eax
  0055a	0f 85 08 01 00
	00		 jne	 $LN31@gObjSprite
$LN28@gObjSprite:

; 10734: #ifdef ADD_SAFEGUARD_ITEM_20080702
; 10735: 					|| itemtype == MAKE_ITEMNUM( 13, 64 )	// 
; 10736: 					|| itemtype == MAKE_ITEMNUM( 13, 65 )	// 
; 10737: #endif // ADD_SAFEGUARD_ITEM_20080702
; 10738: 					)
; 10739: 				{	//     
; 10740: 					int	founditem = -1;

  00560	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _founditem$10[ebp], -1

; 10741: 					for(int  n=MAX_EQUIPMENT; n<MAX_INVENTORY; n++)

  00567	c7 45 dc 0c 00
	00 00		 mov	 DWORD PTR _n$9[ebp], 12	; 0000000cH
  0056e	eb 09		 jmp	 SHORT $LN4@gObjSprite
$LN2@gObjSprite:
  00570	8b 45 dc	 mov	 eax, DWORD PTR _n$9[ebp]
  00573	83 c0 01	 add	 eax, 1
  00576	89 45 dc	 mov	 DWORD PTR _n$9[ebp], eax
$LN4@gObjSprite:
  00579	83 7d dc 4c	 cmp	 DWORD PTR _n$9[ebp], 76	; 0000004cH
  0057d	7d 3e		 jge	 SHORT $LN3@gObjSprite

; 10742: 					{
; 10743: 						if( lpObj->pInventory[n].IsItem() == TRUE )

  0057f	69 4d dc a8 00
	00 00		 imul	 ecx, DWORD PTR _n$9[ebp], 168
  00586	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00589	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0058f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00594	83 f8 01	 cmp	 eax, 1
  00597	75 22		 jne	 SHORT $LN30@gObjSprite

; 10744: 						{
; 10745: 							if( lpObj->pInventory[n].m_Type == itemtype )

  00599	69 45 dc a8 00
	00 00		 imul	 eax, DWORD PTR _n$9[ebp], 168
  005a0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005a3	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  005a9	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  005ae	3b 45 e4	 cmp	 eax, DWORD PTR _itemtype$11[ebp]
  005b1	75 08		 jne	 SHORT $LN30@gObjSprite

; 10746: 							{
; 10747: 								founditem = n;

  005b3	8b 45 dc	 mov	 eax, DWORD PTR _n$9[ebp]
  005b6	89 45 e0	 mov	 DWORD PTR _founditem$10[ebp], eax

; 10748: 								break;

  005b9	eb 02		 jmp	 SHORT $LN3@gObjSprite
$LN30@gObjSprite:

; 10749: 							}
; 10750: 						}
; 10751: 					}		

  005bb	eb b3		 jmp	 SHORT $LN2@gObjSprite
$LN3@gObjSprite:

; 10752: 
; 10753: 					if( founditem != -1 )

  005bd	83 7d e0 ff	 cmp	 DWORD PTR _founditem$10[ebp], -1
  005c1	0f 84 a1 00 00
	00		 je	 $LN31@gObjSprite

; 10754: 					{
; 10755: 						BYTE	sItemInfo[ITEM_BUFFER_SIZE];
; 10756: 
; 10757: 						ItemByteConvert(sItemInfo, lpObj->pInventory[founditem]);

  005c7	69 45 e0 a8 00
	00 00		 imul	 eax, DWORD PTR _founditem$10[ebp], 168
  005ce	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005d1	8b b1 5c 0c 00
	00		 mov	 esi, DWORD PTR [ecx+3164]
  005d7	03 f0		 add	 esi, eax
  005d9	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  005df	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  005e4	8b fc		 mov	 edi, esp
  005e6	f3 a5		 rep movsd
  005e8	8d 55 d4	 lea	 edx, DWORD PTR _sItemInfo$8[ebp]
  005eb	52		 push	 edx
  005ec	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  005f1	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 10758: 
; 10759: 						int durSsend, durTsend;
; 10760: 						gObjInventoryMoveItem(lpObj->m_Index, founditem, EQUIPMENT_HELPER, durSsend, durTsend, 0, 0, sItemInfo);

  005f7	8d 45 d4	 lea	 eax, DWORD PTR _sItemInfo$8[ebp]
  005fa	50		 push	 eax
  005fb	6a 00		 push	 0
  005fd	6a 00		 push	 0
  005ff	8d 4d cc	 lea	 ecx, DWORD PTR _durTsend$6[ebp]
  00602	51		 push	 ecx
  00603	8d 55 d0	 lea	 edx, DWORD PTR _durSsend$7[ebp]
  00606	52		 push	 edx
  00607	6a 08		 push	 8
  00609	0f b6 45 e0	 movzx	 eax, BYTE PTR _founditem$10[ebp]
  0060d	50		 push	 eax
  0060e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00611	8b 11		 mov	 edx, DWORD PTR [ecx]
  00613	52		 push	 edx
  00614	e8 00 00 00 00	 call	 ?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z ; gObjInventoryMoveItem
  00619	83 c4 20	 add	 esp, 32			; 00000020H

; 10761: 
; 10762: 						GCItemMoveResultSend(lpObj->m_Index, 0, EQUIPMENT_HELPER, sItemInfo);						

  0061c	8d 45 d4	 lea	 eax, DWORD PTR _sItemInfo$8[ebp]
  0061f	50		 push	 eax
  00620	6a 08		 push	 8
  00622	6a 00		 push	 0
  00624	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00627	8b 11		 mov	 edx, DWORD PTR [ecx]
  00629	52		 push	 edx
  0062a	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  0062f	83 c4 10	 add	 esp, 16			; 00000010H

; 10763: 						GCInventoryItemDeleteSend(lpObj->m_Index, founditem, 0);

  00632	6a 00		 push	 0
  00634	0f b6 45 e0	 movzx	 eax, BYTE PTR _founditem$10[ebp]
  00638	50		 push	 eax
  00639	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0063c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0063e	52		 push	 edx
  0063f	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00644	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10764: 
; 10765: 						GCServerMsgStringSend(lMsg.Get(1182), lpObj->m_Index, 1);	

  00647	6a 01		 push	 1
  00649	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0064c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0064e	51		 push	 ecx
  0064f	68 9e 04 00 00	 push	 1182			; 0000049eH
  00654	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00659	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0065f	50		 push	 eax
  00660	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00665	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN31@gObjSprite:

; 10766: 						//GCServerMsgStringSend(" ", lpObj->m_Index, 1);	
; 10767: 					}					
; 10768: 				}
; 10769: 			}
; 10770: #endif
; 10771: 
; 10772: #ifdef NEW_SKILL_FORSKYLAND
; 10773: 			if( 
; 10774: 				( lpObj->MapNumber == 10 && itemtype == MAKE_ITEMNUM(13,3) )

  00668	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0066b	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00672	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00675	0f 85 53 01 00
	00		 jne	 $LN36@gObjSprite
  0067b	6a 03		 push	 3
  0067d	6a 0d		 push	 13			; 0000000dH
  0067f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00684	83 c4 08	 add	 esp, 8
  00687	39 45 e4	 cmp	 DWORD PTR _itemtype$11[ebp], eax
  0068a	0f 85 3e 01 00
	00		 jne	 $LN36@gObjSprite

; 10775: #ifdef ADD_ITEM_FENRIR_01_20051110
; 10776: 				//   ,    
; 10777: 				|| ( lpObj->MapNumber == 10 && itemtype == MAKE_ITEMNUM(13,37) )
; 10778: #endif
; 10779: 			  )
; 10780: 			{	
; 10781: 				//    ,    				
; 10782: 				int	founditem = -1;

  00690	c7 45 c8 ff ff
	ff ff		 mov	 DWORD PTR _founditem$5[ebp], -1

; 10783: 
; 10784: 				for(int  n=MAX_EQUIPMENT; n<MAX_INVENTORY; n++)

  00697	c7 45 c4 0c 00
	00 00		 mov	 DWORD PTR _n$4[ebp], 12	; 0000000cH
  0069e	eb 09		 jmp	 SHORT $LN7@gObjSprite
$LN5@gObjSprite:
  006a0	8b 45 c4	 mov	 eax, DWORD PTR _n$4[ebp]
  006a3	83 c0 01	 add	 eax, 1
  006a6	89 45 c4	 mov	 DWORD PTR _n$4[ebp], eax
$LN7@gObjSprite:
  006a9	83 7d c4 4c	 cmp	 DWORD PTR _n$4[ebp], 76	; 0000004cH
  006ad	7d 49		 jge	 SHORT $LN6@gObjSprite

; 10785: 				{
; 10786: 					if( lpObj->pInventory[n].IsItem() == TRUE )

  006af	69 4d c4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$4[ebp], 168
  006b6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006b9	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  006bf	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  006c4	83 f8 01	 cmp	 eax, 1
  006c7	75 2d		 jne	 SHORT $LN34@gObjSprite

; 10787: 					{
; 10788: 						if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(13,3) )

  006c9	69 45 c4 a8 00
	00 00		 imul	 eax, DWORD PTR _n$4[ebp], 168
  006d0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  006d3	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  006d9	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  006de	6a 03		 push	 3
  006e0	6a 0d		 push	 13			; 0000000dH
  006e2	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  006e7	83 c4 08	 add	 esp, 8
  006ea	3b f0		 cmp	 esi, eax
  006ec	75 08		 jne	 SHORT $LN34@gObjSprite

; 10789: 						{
; 10790: 							founditem = n;

  006ee	8b 45 c4	 mov	 eax, DWORD PTR _n$4[ebp]
  006f1	89 45 c8	 mov	 DWORD PTR _founditem$5[ebp], eax

; 10791: 							break;

  006f4	eb 02		 jmp	 SHORT $LN6@gObjSprite
$LN34@gObjSprite:

; 10792: 						}
; 10793: 					}
; 10794: 				}		

  006f6	eb a8		 jmp	 SHORT $LN5@gObjSprite
$LN6@gObjSprite:

; 10795: 
; 10796: 				if( founditem == -1 )

  006f8	83 7d c8 ff	 cmp	 DWORD PTR _founditem$5[ebp], -1
  006fc	75 2f		 jne	 SHORT $LN35@gObjSprite

; 10797: 				{
; 10798: 					if( !lpObj->pInventory[EQUIPMENT_WING].IsItem() )

  006fe	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00703	6b c8 07	 imul	 ecx, eax, 7
  00706	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00709	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0070f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00714	85 c0		 test	 eax, eax
  00716	75 10		 jne	 SHORT $LN37@gObjSprite

; 10799: 					{
; 10800: 						gObjMoveGate(lpObj->m_Index, 22);			

  00718	6a 16		 push	 22			; 00000016H
  0071a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0071d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0071f	51		 push	 ecx
  00720	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00725	83 c4 08	 add	 esp, 8
$LN37@gObjSprite:

; 10801: 					}
; 10802: 				}

  00728	e9 a1 00 00 00	 jmp	 $LN36@gObjSprite
$LN35@gObjSprite:

; 10803: 				else
; 10804: 				{
; 10805: 
; 10806: 					BYTE	sItemInfo[ITEM_BUFFER_SIZE];
; 10807: 
; 10808: 					ItemByteConvert(sItemInfo, lpObj->pInventory[founditem]);

  0072d	69 45 c8 a8 00
	00 00		 imul	 eax, DWORD PTR _founditem$5[ebp], 168
  00734	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00737	8b b1 5c 0c 00
	00		 mov	 esi, DWORD PTR [ecx+3164]
  0073d	03 f0		 add	 esi, eax
  0073f	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00745	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0074a	8b fc		 mov	 edi, esp
  0074c	f3 a5		 rep movsd
  0074e	8d 55 bc	 lea	 edx, DWORD PTR _sItemInfo$3[ebp]
  00751	52		 push	 edx
  00752	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  00757	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 10809: 
; 10810: 					int durSsend, durTsend;
; 10811: 					gObjInventoryMoveItem(lpObj->m_Index, founditem, EQUIPMENT_HELPER, durSsend, durTsend, 0, 0, sItemInfo);

  0075d	8d 45 bc	 lea	 eax, DWORD PTR _sItemInfo$3[ebp]
  00760	50		 push	 eax
  00761	6a 00		 push	 0
  00763	6a 00		 push	 0
  00765	8d 4d b4	 lea	 ecx, DWORD PTR _durTsend$1[ebp]
  00768	51		 push	 ecx
  00769	8d 55 b8	 lea	 edx, DWORD PTR _durSsend$2[ebp]
  0076c	52		 push	 edx
  0076d	6a 08		 push	 8
  0076f	0f b6 45 c8	 movzx	 eax, BYTE PTR _founditem$5[ebp]
  00773	50		 push	 eax
  00774	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00777	8b 11		 mov	 edx, DWORD PTR [ecx]
  00779	52		 push	 edx
  0077a	e8 00 00 00 00	 call	 ?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z ; gObjInventoryMoveItem
  0077f	83 c4 20	 add	 esp, 32			; 00000020H

; 10812: 
; 10813: 					GCItemMoveResultSend(lpObj->m_Index, 0, EQUIPMENT_HELPER, sItemInfo);					

  00782	8d 45 bc	 lea	 eax, DWORD PTR _sItemInfo$3[ebp]
  00785	50		 push	 eax
  00786	6a 08		 push	 8
  00788	6a 00		 push	 0
  0078a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0078d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0078f	52		 push	 edx
  00790	e8 00 00 00 00	 call	 ?GCItemMoveResultSend@@YAXHEEQAE@Z ; GCItemMoveResultSend
  00795	83 c4 10	 add	 esp, 16			; 00000010H

; 10814: 					GCInventoryItemDeleteSend(lpObj->m_Index, founditem, 0);

  00798	6a 00		 push	 0
  0079a	0f b6 45 c8	 movzx	 eax, BYTE PTR _founditem$5[ebp]
  0079e	50		 push	 eax
  0079f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  007a2	8b 11		 mov	 edx, DWORD PTR [ecx]
  007a4	52		 push	 edx
  007a5	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  007aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10815: 
; 10816: 					GCServerMsgStringSend(lMsg.Get(1182), lpObj->m_Index, 1);	// " "

  007ad	6a 01		 push	 1
  007af	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  007b4	51		 push	 ecx
  007b5	68 9e 04 00 00	 push	 1182			; 0000049eH
  007ba	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  007bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  007c5	50		 push	 eax
  007c6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  007cb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN36@gObjSprite:
$LN1@gObjSprite:

; 10817: 				}
; 10818: 			}
; 10819: #endif
; 10820: 		}
; 10821: 	}
; 10822: }

  007ce	5f		 pop	 edi
  007cf	5e		 pop	 esi
  007d0	5b		 pop	 ebx
  007d1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007d4	33 cd		 xor	 ecx, ebp
  007d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007db	8b e5		 mov	 esp, ebp
  007dd	5d		 pop	 ebp
  007de	c3		 ret	 0
?gObjSpriteDamage@@YAXPAVOBJECTSTRUCT@@H@Z ENDP		; gObjSpriteDamage
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?retCalcSkillResistance@@YAHPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpTargetObj$ = 8					; size = 4
_isDouble$ = 12						; size = 4
?retCalcSkillResistance@@YAHPAVOBJECTSTRUCT@@H@Z PROC	; retCalcSkillResistance, COMDAT

; 8678 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 8679 : 	if( isDouble )

  00009	83 7d 0c 00	 cmp	 DWORD PTR _isDouble$[ebp], 0
  0000d	74 1b		 je	 SHORT $LN2@retCalcSki

; 8680 : 	{
; 8681 : 		if( (rand()%(100)) < 45 ) return TRUE;

  0000f	e8 00 00 00 00	 call	 _rand
  00014	99		 cdq
  00015	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0001a	f7 f9		 idiv	 ecx
  0001c	83 fa 2d	 cmp	 edx, 45			; 0000002dH
  0001f	7d 07		 jge	 SHORT $LN4@retCalcSki
  00021	b8 01 00 00 00	 mov	 eax, 1
  00026	eb 1d		 jmp	 SHORT $LN1@retCalcSki
$LN4@retCalcSki:

; 8682 : 	}

  00028	eb 19		 jmp	 SHORT $LN3@retCalcSki
$LN2@retCalcSki:

; 8683 : 	else
; 8684 : 	{
; 8685 : 		if( (rand()%(100)) < 40 ) return TRUE;

  0002a	e8 00 00 00 00	 call	 _rand
  0002f	99		 cdq
  00030	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00035	f7 f9		 idiv	 ecx
  00037	83 fa 28	 cmp	 edx, 40			; 00000028H
  0003a	7d 07		 jge	 SHORT $LN3@retCalcSki
  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	eb 02		 jmp	 SHORT $LN1@retCalcSki
$LN3@retCalcSki:

; 8686 : 	}
; 8687 : 	return FALSE;

  00043	33 c0		 xor	 eax, eax
$LN1@retCalcSki:

; 8688 : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?retCalcSkillResistance@@YAHPAVOBJECTSTRUCT@@H@Z ENDP	; retCalcSkillResistance
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?retResistance@@YAHPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_r$ = -1						; size = 1
_lpObj$ = 8						; size = 4
_Resistance_Type$ = 12					; size = 4
?retResistance@@YAHPAVOBJECTSTRUCT@@H@Z PROC		; retResistance, COMDAT

; 8636 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 8637 : 	BYTE r = lpObj->m_Resistance[Resistance_Type];

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	03 45 0c	 add	 eax, DWORD PTR _Resistance_Type$[ebp]
  0000f	8a 88 35 03 00
	00		 mov	 cl, BYTE PTR [eax+821]
  00015	88 4d ff	 mov	 BYTE PTR _r$[ebp], cl

; 8638 : 
; 8639 : #ifdef MODIFY_MONSTER_RESISTANCE_IMMUNE_20060523
; 8640 : 	//   255  100%  ( )
; 8641 : 	if ( r == 255 ) 

  00018	0f b6 45 ff	 movzx	 eax, BYTE PTR _r$[ebp]
  0001c	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00021	75 07		 jne	 SHORT $LN2@retResista

; 8642 : 	{
; 8643 : 		return TRUE;

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	eb 28		 jmp	 SHORT $LN1@retResista
$LN2@retResista:

; 8644 : 	}
; 8645 : #endif // MODIFY_MONSTER_RESISTANCE_IMMUNE_20060523
; 8646 : 	
; 8647 : #ifdef UPDATE_GM_FUNCTION_20070228	// GM     Max
; 8648 : 	if( (lpObj->Authority&AUTHORITY_EVENT_GM) == AUTHORITY_EVENT_GM  
; 8649 : 		&& ( lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 42 )  
; 8650 : 		|| lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 42 ) ) )
; 8651 : 	{
; 8652 : 		return TRUE;
; 8653 : 	}
; 8654 : #endif
; 8655 : 
; 8656 : #ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116
; 8657 : //       .
; 8658 : 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 8659 : 	if( r > 0 && ( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_SOUL_POTION ) == true )
; 8660 : 		&& ( Resistance_Type == RESISTANCE_THUNDER || Resistance_Type == RESISTANCE_COLD ) 
; 8661 : 	  )
; 8662 : 	#else
; 8663 : 	if( r > 0 && ( lpObj->m_iPotionSoulTime > 0 ) 
; 8664 : 		&& ( Resistance_Type == RESISTANCE_THUNDER || Resistance_Type == RESISTANCE_COLD ) )
; 8665 : 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 8666 : 	{
; 8667 : 		r += r * CASTLE_SOULPOTION_ADD_RESISTANCE / 100;
; 8668 : 	}
; 8669 : #endif
; 8670 : 
; 8671 : 	if( r == 0 ) return FALSE;

  0002a	0f b6 45 ff	 movzx	 eax, BYTE PTR _r$[ebp]
  0002e	85 c0		 test	 eax, eax
  00030	75 04		 jne	 SHORT $LN3@retResista
  00032	33 c0		 xor	 eax, eax
  00034	eb 1c		 jmp	 SHORT $LN1@retResista
$LN3@retResista:

; 8672 : 	if( (rand()%(r+1)) == 0 ) return FALSE;

  00036	e8 00 00 00 00	 call	 _rand
  0003b	0f b6 4d ff	 movzx	 ecx, BYTE PTR _r$[ebp]
  0003f	83 c1 01	 add	 ecx, 1
  00042	99		 cdq
  00043	f7 f9		 idiv	 ecx
  00045	85 d2		 test	 edx, edx
  00047	75 04		 jne	 SHORT $LN4@retResista
  00049	33 c0		 xor	 eax, eax
  0004b	eb 05		 jmp	 SHORT $LN1@retResista
$LN4@retResista:

; 8673 : 	return TRUE;

  0004d	b8 01 00 00 00	 mov	 eax, 1
$LN1@retResista:

; 8674 : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?retResistance@@YAHPAVOBJECTSTRUCT@@H@Z ENDP		; retResistance
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjLifeCheck@@YAXPAVOBJECTSTRUCT@@0HHHHE@Z
_TEXT	SEGMENT
tv658 = -1296						; size = 4
tv645 = -1296						; size = 4
tv629 = -1296						; size = 4
tv591 = -1296						; size = 4
tv555 = -1296						; size = 4
tv402 = -1296						; size = 4
tv278 = -1296						; size = 4
tv190 = -1296						; size = 4
tv181 = -1296						; size = 4
tv659 = -1292						; size = 4
tv646 = -1292						; size = 4
tv630 = -1292						; size = 4
tv592 = -1292						; size = 4
tv556 = -1292						; size = 4
tv403 = -1292						; size = 4
tv279 = -1292						; size = 4
tv191 = -1292						; size = 4
tv182 = -1292						; size = 4
_ServerCmd$1 = -1096					; size = 7
_szText$2 = -1088					; size = 256
_pMsg$3 = -832						; size = 15
__bOnDuel$4 = -816					; size = 4
__guildWar$5 = -812					; size = 4
_iMaxHitIndex$6 = -808					; size = 4
_i$7 = -804						; size = 4
_msg$8 = -800						; size = 255
_iMaxHitIndex$9 = -544					; size = 4
_msg$10 = -540						; size = 255
_iMaxHitIndex$11 = -284					; size = 4
_lpCallObj$ = -280					; size = 4
_notice$ = -276						; size = 272
__$ArrayPad$ = -4					; size = 4
_lpTargetObj$ = 8					; size = 4
_lpObj$ = 12						; size = 4
_AttackDamage$ = 16					; size = 4
_DamageSendType$ = 20					; size = 4
_MSBFlag$ = 24						; size = 4
_MSBDamage$ = 28					; size = 4
_Skill$ = 32						; size = 1
?gObjLifeCheck@@YAXPAVOBJECTSTRUCT@@0HHHHE@Z PROC	; gObjLifeCheck, COMDAT

; 13764: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 05 00
	00		 sub	 esp, 1296		; 00000510H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 13765: 	TNotice notice;

  00016	6a 00		 push	 0
  00018	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _notice$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0TNotice@@QAE@E@Z	; TNotice::TNotice

; 13766: 	//---
; 13767: 	if(lpTargetObj->Life <= 0 && lpTargetObj->Live != 0 )

  00023	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00026	0f 57 c0	 xorps	 xmm0, xmm0
  00029	0f 2f 80 bc 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+188]
  00030	72 41		 jb	 SHORT $LN6@gObjLifeCh
  00032	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00035	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  00039	85 c9		 test	 ecx, ecx
  0003b	74 36		 je	 SHORT $LN6@gObjLifeCh

; 13768: 	{
; 13769: 		if(lpTargetObj->Type == OBJTYPE_MONSTER && lpTargetObj->Class == 78)

  0003d	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00040	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00044	83 f9 02	 cmp	 ecx, 2
  00047	75 2a		 jne	 SHORT $LN6@gObjLifeCh
  00049	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0004c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00053	83 f9 4e	 cmp	 ecx, 78			; 0000004eH
  00056	75 1b		 jne	 SHORT $LN6@gObjLifeCh

; 13770: 		{	
; 13771: 			notice.SendToAllUser("[%s] derroto un Goblin Dorado.",lpObj->Name);

  00058	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005b	83 c0 73	 add	 eax, 115		; 00000073H
  0005e	50		 push	 eax
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@GEEBCKIA@?$FL?$CFs?$FN?5derroto?5un?5Goblin?5Dorado?4@
  00064	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _notice$[ebp]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ?SendToAllUser@TNotice@@QAAXPADZZ ; TNotice::SendToAllUser
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@gObjLifeCh:

; 13772: 			//notice.SendToAllUser("[PVP Event] Inicio el evento! - %d jugadores", this->m_userList.size());
; 13773: 
; 13774: 		}
; 13775:     }
; 13776: 
; 13777: 	if(lpTargetObj->Life <= 0 && lpTargetObj->Live != 0 )

  00073	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00076	0f 57 c0	 xorps	 xmm0, xmm0
  00079	0f 2f 80 bc 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+188]
  00080	72 41		 jb	 SHORT $LN8@gObjLifeCh
  00082	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00085	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  00089	85 c9		 test	 ecx, ecx
  0008b	74 36		 je	 SHORT $LN8@gObjLifeCh

; 13778: 	{
; 13779: 		if(lpTargetObj->Type == OBJTYPE_MONSTER && lpTargetObj->Class == 53)

  0008d	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00090	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00094	83 f9 02	 cmp	 ecx, 2
  00097	75 2a		 jne	 SHORT $LN8@gObjLifeCh
  00099	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0009c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000a3	83 f9 35	 cmp	 ecx, 53			; 00000035H
  000a6	75 1b		 jne	 SHORT $LN8@gObjLifeCh

; 13780: 		{	
; 13781: 			notice.SendToAllUser("[%s] derroto un Titan Dorado.",lpObj->Name);

  000a8	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ab	83 c0 73	 add	 eax, 115		; 00000073H
  000ae	50		 push	 eax
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@EDKFBDOM@?$FL?$CFs?$FN?5derroto?5un?5Titan?5Dorado?4@
  000b4	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _notice$[ebp]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 ?SendToAllUser@TNotice@@QAAXPADZZ ; TNotice::SendToAllUser
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@gObjLifeCh:

; 13782: 		}
; 13783:     }
; 13784: 
; 13785: 	if(lpTargetObj->Life <= 0 && lpTargetObj->Live != 0 )

  000c3	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000c6	0f 57 c0	 xorps	 xmm0, xmm0
  000c9	0f 2f 80 bc 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+188]
  000d0	72 41		 jb	 SHORT $LN10@gObjLifeCh
  000d2	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000d5	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  000d9	85 c9		 test	 ecx, ecx
  000db	74 36		 je	 SHORT $LN10@gObjLifeCh

; 13786: 	{
; 13787: 		if(lpTargetObj->Type == OBJTYPE_MONSTER && lpTargetObj->Class == 79)

  000dd	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000e0	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  000e4	83 f9 02	 cmp	 ecx, 2
  000e7	75 2a		 jne	 SHORT $LN10@gObjLifeCh
  000e9	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000ec	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000f3	83 f9 4f	 cmp	 ecx, 79			; 0000004fH
  000f6	75 1b		 jne	 SHORT $LN10@gObjLifeCh

; 13788: 		{	
; 13789: 			notice.SendToAllUser("[%s] derroto un Dragon Dorado.",lpObj->Name);

  000f8	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000fb	83 c0 73	 add	 eax, 115		; 00000073H
  000fe	50		 push	 eax
  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@IAJJAOEN@?$FL?$CFs?$FN?5derroto?5un?5Dragon?5Dorado?4@
  00104	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _notice$[ebp]
  0010a	51		 push	 ecx
  0010b	e8 00 00 00 00	 call	 ?SendToAllUser@TNotice@@QAAXPADZZ ; TNotice::SendToAllUser
  00110	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@gObjLifeCh:

; 13790: 		}
; 13791:     }
; 13792: 
; 13793: 	if(lpTargetObj->Life <= 0 && lpTargetObj->Live != 0 )

  00113	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00116	0f 57 c0	 xorps	 xmm0, xmm0
  00119	0f 2f 80 bc 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+188]
  00120	72 41		 jb	 SHORT $LN12@gObjLifeCh
  00122	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00125	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  00129	85 c9		 test	 ecx, ecx
  0012b	74 36		 je	 SHORT $LN12@gObjLifeCh

; 13794: 	{
; 13795: 		if(lpTargetObj->Type == OBJTYPE_MONSTER && lpTargetObj->Class == 80)

  0012d	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00130	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00134	83 f9 02	 cmp	 ecx, 2
  00137	75 2a		 jne	 SHORT $LN12@gObjLifeCh
  00139	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0013c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00143	83 f9 50	 cmp	 ecx, 80			; 00000050H
  00146	75 1b		 jne	 SHORT $LN12@gObjLifeCh

; 13796: 		{	
; 13797: 			notice.SendToAllUser("[%s] derroto un Lizard King Dorado.",lpObj->Name);

  00148	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014b	83 c0 73	 add	 eax, 115		; 00000073H
  0014e	50		 push	 eax
  0014f	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@OLGAAMMO@?$FL?$CFs?$FN?5derroto?5un?5Lizard?5King?5Dor@
  00154	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _notice$[ebp]
  0015a	51		 push	 ecx
  0015b	e8 00 00 00 00	 call	 ?SendToAllUser@TNotice@@QAAXPADZZ ; TNotice::SendToAllUser
  00160	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@gObjLifeCh:

; 13798: 		}
; 13799:     }
; 13800: 
; 13801: 	if(lpTargetObj->Life <= 0 && lpTargetObj->Live != 0 )

  00163	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00166	0f 57 c0	 xorps	 xmm0, xmm0
  00169	0f 2f 80 bc 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+188]
  00170	72 41		 jb	 SHORT $LN14@gObjLifeCh
  00172	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00175	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  00179	85 c9		 test	 ecx, ecx
  0017b	74 36		 je	 SHORT $LN14@gObjLifeCh

; 13802: 	{
; 13803: 		if(lpTargetObj->Type == OBJTYPE_MONSTER && lpTargetObj->Class == 82)

  0017d	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00180	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00184	83 f9 02	 cmp	 ecx, 2
  00187	75 2a		 jne	 SHORT $LN14@gObjLifeCh
  00189	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0018c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00193	83 f9 52	 cmp	 ecx, 82			; 00000052H
  00196	75 1b		 jne	 SHORT $LN14@gObjLifeCh

; 13804: 		{	
; 13805: 			notice.SendToAllUser("[%s] derroto un Tantalo Dorado.",lpObj->Name);

  00198	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019b	83 c0 73	 add	 eax, 115		; 00000073H
  0019e	50		 push	 eax
  0019f	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@HJAGOCKC@?$FL?$CFs?$FN?5derroto?5un?5Tantalo?5Dorado?4@
  001a4	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _notice$[ebp]
  001aa	51		 push	 ecx
  001ab	e8 00 00 00 00	 call	 ?SendToAllUser@TNotice@@QAAXPADZZ ; TNotice::SendToAllUser
  001b0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@gObjLifeCh:

; 13806: 		}
; 13807:     }
; 13808: 
; 13809: 
; 13810: 	if( lpObj->Connected < CSS_GAMEPLAYING )	//     

  001b3	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b6	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  001ba	7d 05		 jge	 SHORT $LN15@gObjLifeCh

; 13811: 	{
; 13812: 		return;

  001bc	e9 2e 11 00 00	 jmp	 $LN1@gObjLifeCh
$LN15@gObjLifeCh:

; 13813: 	}
; 13814: 
; 13815: #ifdef ADD_NEW_MAP_KALIMA_20040518
; 13816: 	if (CHECK_KALIMAGATE(lpObj->m_Attribute) ||

  001c1	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c4	0f bf 88 fe 02
	00 00		 movsx	 ecx, WORD PTR [eax+766]
  001cb	83 f9 33	 cmp	 ecx, 51			; 00000033H
  001ce	7d 0c		 jge	 SHORT $LN73@gObjLifeCh
  001d0	c7 85 f4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv182[ebp], 0
  001da	eb 31		 jmp	 SHORT $LN74@gObjLifeCh
$LN73@gObjLifeCh:
  001dc	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001df	0f bf 82 fe 02
	00 00		 movsx	 eax, WORD PTR [edx+766]
  001e6	83 f8 38	 cmp	 eax, 56			; 00000038H
  001e9	7e 0c		 jle	 SHORT $LN71@gObjLifeCh
  001eb	c7 85 f0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv181[ebp], 0
  001f5	eb 0a		 jmp	 SHORT $LN72@gObjLifeCh
$LN71@gObjLifeCh:
  001f7	c7 85 f0 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR tv181[ebp], 1
$LN72@gObjLifeCh:
  00201	8b 8d f0 fa ff
	ff		 mov	 ecx, DWORD PTR tv181[ebp]
  00207	89 8d f4 fa ff
	ff		 mov	 DWORD PTR tv182[ebp], ecx
$LN74@gObjLifeCh:
  0020d	83 bd f4 fa ff
	ff 00		 cmp	 DWORD PTR tv182[ebp], 0
  00214	75 55		 jne	 SHORT $LN17@gObjLifeCh
  00216	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00219	0f bf 88 fe 02
	00 00		 movsx	 ecx, WORD PTR [eax+766]
  00220	83 f9 33	 cmp	 ecx, 51			; 00000033H
  00223	7d 0c		 jge	 SHORT $LN77@gObjLifeCh
  00225	c7 85 f4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv191[ebp], 0
  0022f	eb 31		 jmp	 SHORT $LN78@gObjLifeCh
$LN77@gObjLifeCh:
  00231	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00234	0f bf 82 fe 02
	00 00		 movsx	 eax, WORD PTR [edx+766]
  0023b	83 f8 38	 cmp	 eax, 56			; 00000038H
  0023e	7e 0c		 jle	 SHORT $LN75@gObjLifeCh
  00240	c7 85 f0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv190[ebp], 0
  0024a	eb 0a		 jmp	 SHORT $LN76@gObjLifeCh
$LN75@gObjLifeCh:
  0024c	c7 85 f0 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR tv190[ebp], 1
$LN76@gObjLifeCh:
  00256	8b 8d f0 fa ff
	ff		 mov	 ecx, DWORD PTR tv190[ebp]
  0025c	89 8d f4 fa ff
	ff		 mov	 DWORD PTR tv191[ebp], ecx
$LN78@gObjLifeCh:
  00262	83 bd f4 fa ff
	ff 00		 cmp	 DWORD PTR tv191[ebp], 0
  00269	74 05		 je	 SHORT $LN16@gObjLifeCh
$LN17@gObjLifeCh:

; 13817: 		CHECK_KALIMAGATE(lpTargetObj->m_Attribute)
; 13818: 		) 
; 13819: 	{
; 13820: 		//     .
; 13821: 		return;

  0026b	e9 7f 10 00 00	 jmp	 $LN1@gObjLifeCh
$LN16@gObjLifeCh:

; 13822: 	}
; 13823: #endif
; 13824: 	
; 13825: 	LPOBJECTSTRUCT lpCallObj;		//  
; 13826: 
; 13827: 	lpCallObj = lpObj;

  00270	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00273	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _lpCallObj$[ebp], eax

; 13828: 	if( lpObj->Type == OBJTYPE_MONSTER )

  00279	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0027c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00280	83 f9 02	 cmp	 ecx, 2
  00283	75 25		 jne	 SHORT $LN19@gObjLifeCh

; 13829: 	{
; 13830: 		if( lpObj->m_RecallMon >= 0 ) 

  00285	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00288	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  0028f	7c 19		 jl	 SHORT $LN19@gObjLifeCh

; 13831: 		{
; 13832: 			lpCallObj = &gObj[lpObj->m_RecallMon];

  00291	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00294	69 88 a4 02 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR [eax+676], 7072
  0029e	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002a4	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _lpCallObj$[ebp], ecx
$LN19@gObjLifeCh:

; 13833: 		}
; 13834: 	}
; 13835: 	//    
; 13836: 	if( AttackDamage && lpTargetObj->Type == OBJTYPE_MONSTER )

  002aa	83 7d 10 00	 cmp	 DWORD PTR _AttackDamage$[ebp], 0
  002ae	74 5b		 je	 SHORT $LN20@gObjLifeCh
  002b0	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  002b3	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  002b7	83 f9 02	 cmp	 ecx, 2
  002ba	75 4f		 jne	 SHORT $LN20@gObjLifeCh

; 13837: 	{		
; 13838: 		if( lpTargetObj->m_RecallMon >= 0 )

  002bc	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  002bf	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  002c6	7c 2a		 jl	 SHORT $LN21@gObjLifeCh

; 13839: 		{
; 13840: 			GCRecallMonLife(lpTargetObj->m_RecallMon, (int)lpTargetObj->MaxLife, (int)lpTargetObj->Life);

  002c8	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  002cb	f3 0f 2c 88 bc
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+188]
  002d3	51		 push	 ecx
  002d4	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  002d7	f3 0f 2c 82 c0
	00 00 00	 cvttss2si eax, DWORD PTR [edx+192]
  002df	50		 push	 eax
  002e0	8b 4d 08	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  002e3	8b 91 a4 02 00
	00		 mov	 edx, DWORD PTR [ecx+676]
  002e9	52		 push	 edx
  002ea	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife
  002ef	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@gObjLifeCh:

; 13841: 		}
; 13842: 		//     .
; 13843: 		gObjMonsterSetHitDamage(lpTargetObj, lpCallObj->m_Index, AttackDamage );		

  002f2	8b 45 10	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  002f5	50		 push	 eax
  002f6	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _lpCallObj$[ebp]
  002fc	8b 11		 mov	 edx, DWORD PTR [ecx]
  002fe	52		 push	 edx
  002ff	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00302	50		 push	 eax
  00303	e8 00 00 00 00	 call	 ?gObjMonsterSetHitDamage@@YAXPAVOBJECTSTRUCT@@HH@Z ; gObjMonsterSetHitDamage
  00308	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@gObjLifeCh:

; 13844: 	}
; 13845: 	
; 13846: 	//  ..?
; 13847: 	if( (lpTargetObj->Life <= 0) && lpTargetObj->Live) 

  0030b	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0030e	0f 57 c0	 xorps	 xmm0, xmm0
  00311	0f 2f 80 bc 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+188]
  00318	0f 82 65 0f 00
	00		 jb	 $LN22@gObjLifeCh
  0031e	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00321	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  00325	85 c9		 test	 ecx, ecx
  00327	0f 84 56 0f 00
	00		 je	 $LN22@gObjLifeCh

; 13848: 	{
; 13849: 		//        
; 13850: 		if( lpObj->Type == OBJTYPE_MONSTER)

  0032d	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00330	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00334	83 f9 02	 cmp	 ecx, 2
  00337	75 44		 jne	 SHORT $LN24@gObjLifeCh

; 13851: 		{
; 13852: 			gObjAddMsgSend(lpObj, 3, lpTargetObj->m_Index);

  00339	6a 00		 push	 0
  0033b	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0033e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00340	51		 push	 ecx
  00341	6a 03		 push	 3
  00343	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00346	52		 push	 edx
  00347	e8 00 00 00 00	 call	 ?gObjAddMsgSend@@YAXPAVOBJECTSTRUCT@@HHH@Z ; gObjAddMsgSend
  0034c	83 c4 10	 add	 esp, 16			; 00000010H

; 13853: 			CreateFrustrum(lpObj->X,lpObj->Y, lpObj->m_Index);

  0034f	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00352	8b 08		 mov	 ecx, DWORD PTR [eax]
  00354	51		 push	 ecx
  00355	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00358	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  0035f	50		 push	 eax
  00360	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00363	0f bf 91 04 01
	00 00		 movsx	 edx, WORD PTR [ecx+260]
  0036a	52		 push	 edx
  0036b	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  00370	83 c4 0c	 add	 esp, 12			; 0000000cH

; 13854: 			lpTargetObj->KillerType = KT_MONSTER;

  00373	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00376	c6 80 fd 01 00
	00 01		 mov	 BYTE PTR [eax+509], 1
$LN24@gObjLifeCh:

; 13855: 		}
; 13856: 
; 13857: #ifdef DARKLORD_WORK
; 13858: 		if( lpObj->Type == OBJTYPE_CHARACTER)

  0037d	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00380	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00384	83 f9 01	 cmp	 ecx, 1
  00387	75 17		 jne	 SHORT $LN25@gObjLifeCh

; 13859: 		{	//   
; 13860: 			gDarkSpirit[lpObj->m_Index].ReSetTarget(lpTargetObj->m_Index);

  00389	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0038c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0038e	51		 push	 ecx
  0038f	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00392	6b 0a 28	 imul	 ecx, DWORD PTR [edx], 40
  00395	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  0039b	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget
$LN25@gObjLifeCh:

; 13861: 		}
; 13862: #endif
; 13863: 
; 13864: 
; 13865: #ifdef ADD_NEW_SKILL_FOR_CASTLE_01_20041116
; 13866: 		// KillCount  .
; 13867: 		if( lpObj->Type == OBJTYPE_CHARACTER && lpTargetObj->Type == OBJTYPE_CHARACTER)
; 13868: 		{
; 13869: 			gObjSetKillCount( lpObj->m_Index );
; 13870: 
; 13871: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//     
; 13872: 			if(CHECK_ILLUSION_TEMPLE(lpObj->MapNumber) 
; 13873: 				&& g_IllusionTempleEvent.GetIllusionTempleState(lpObj->MapNumber) == ILLUSION_TEMPLE_STATE_PLAYING)
; 13874: 			{
; 13875: 				BYTE btSkillPoint = g_IllusionTempleEvent.IncSkillPoint(lpObj->m_Index, lpObj->MapNumber, OBJTYPE_CHARACTER);
; 13876: 				GCIllusionTempleSkillPoint(lpObj->m_Index, btSkillPoint);
; 13877: 				
; 13878: #ifdef  ADD_LOG_ILLUSION_TEMPLE_1_20070727
; 13879: 				LogAddTD("[Illusion Temple] (%d) (%s)(%s) Character Killed, (point: %d)", 
; 13880: 					lpObj->MapNumber - MAP_INDEX_ILLUSION_TEMPLE1 +1, lpObj->AccountID, lpObj->Name, btSkillPoint);
; 13881: #endif
; 13882: 			}
; 13883: #endif	
; 13884: 		}
; 13885: #endif
; 13886: 		//  ..
; 13887: 		if( lpTargetObj->Type == OBJTYPE_MONSTER )

  003a0	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  003a3	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  003a7	83 f9 02	 cmp	 ecx, 2
  003aa	0f 85 f2 07 00
	00		 jne	 $LN26@gObjLifeCh

; 13888: 		{	
; 13889: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//     
; 13890: 			if(CHECK_ILLUSION_TEMPLE(lpObj->MapNumber) 
; 13891: 				&& g_IllusionTempleEvent.GetIllusionTempleState(lpObj->MapNumber) == ILLUSION_TEMPLE_STATE_PLAYING)
; 13892: 			{
; 13893: 				BYTE btSkillPoint = g_IllusionTempleEvent.IncSkillPoint(lpObj->m_Index, lpObj->MapNumber, OBJTYPE_MONSTER);
; 13894: 				GCIllusionTempleSkillPoint(lpObj->m_Index, btSkillPoint);
; 13895: 
; 13896: 				lpTargetObj->m_PosNum	= -1;
; 13897: 
; 13898: #ifdef  ADD_LOG_ILLUSION_TEMPLE_1_20070727
; 13899: 				LogAddTD("[Illusion Temple] (%d) (%s)(%s) Monster Killed, (point: %d)", 
; 13900: 					lpObj->MapNumber - MAP_INDEX_ILLUSION_TEMPLE1 +1, lpObj->AccountID, lpObj->Name, btSkillPoint);
; 13901: #endif
; 13902: 			}
; 13903: #endif
; 13904: 
; 13905: #ifdef ADD_QPROCESSING_STATE_OF_DEAD_20050221
; 13906: 			//  & 
; 13907: 			if( lpTargetObj->Class == 275 || lpTargetObj->Class == 295

  003b0	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  003b3	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  003ba	81 f9 13 01 00
	00		 cmp	 ecx, 275		; 00000113H
  003c0	74 12		 je	 SHORT $LN30@gObjLifeCh
  003c2	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  003c5	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  003cc	81 f9 27 01 00
	00		 cmp	 ecx, 295		; 00000127H
  003d2	75 1f		 jne	 SHORT $LN28@gObjLifeCh
$LN30@gObjLifeCh:

; 13908: 	#ifdef CRYWOLF_MONSTER_WORK_20050914
; 13909: 				|| lpTargetObj->MapNumber == MAP_INDEX_CRYWOLF_FIRSTZONE
; 13910: 	#endif
; 13911: 				)
; 13912: 			{
; 13913: 				//       .
; 13914: 				gObjAddMsgSendDelayInSpecificQPos(lpTargetObj, 1, lpObj->m_Index, 800, 0);

  003d4	6a 00		 push	 0
  003d6	6a 00		 push	 0
  003d8	68 20 03 00 00	 push	 800			; 00000320H
  003dd	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e2	51		 push	 ecx
  003e3	6a 01		 push	 1
  003e5	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  003e8	52		 push	 edx
  003e9	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelayInSpecificQPos@@YAXPAVOBJECTSTRUCT@@HHHHH@Z ; gObjAddMsgSendDelayInSpecificQPos
  003ee	83 c4 18	 add	 esp, 24			; 00000018H

; 13915: 			}

  003f1	eb 1b		 jmp	 SHORT $LN29@gObjLifeCh
$LN28@gObjLifeCh:

; 13916: 			else
; 13917: 			{
; 13918: 				gObjAddMsgSendDelay(lpTargetObj, 1, lpObj->m_Index, 800);

  003f3	6a 00		 push	 0
  003f5	68 20 03 00 00	 push	 800			; 00000320H
  003fa	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003fd	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ff	51		 push	 ecx
  00400	6a 01		 push	 1
  00402	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00405	52		 push	 edx
  00406	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  0040b	83 c4 14	 add	 esp, 20			; 00000014H
$LN29@gObjLifeCh:

; 13919: 			}
; 13920: #else
; 13921: 			gObjAddMsgSendDelay(lpTargetObj, 1, lpObj->m_Index, 800);
; 13922: #endif
; 13923: 
; 13924: #ifdef CRYWOLF_MONSTER_WORK_20050914
; 13925: 			g_Crywolf.CrywolfMonsterDieProc(lpTargetObj->m_Index, lpObj->m_Index);
; 13926: #endif
; 13927: 			
; 13928: #ifdef ADD_KANTURU_20060627
; 13929: 			g_Kanturu.KanturuMonsterDieProc( lpTargetObj->m_Index, lpObj->m_Index );
; 13930: #endif
; 13931: 			
; 13932: #ifdef CASTLEDEEP_EVENT_20050413
; 13933: 			if (lpTargetObj->m_Attribute == MON_ATTR_CASTLEDEEP) {
; 13934: 				char szMsg[256];
; 13935: 
; 13936: 				switch(lpTargetObj->Class) {
; 13937: 				case 300:
; 13938: 				case 301:
; 13939: 				case 302:
; 13940: 				case 303:
; 13941: 					{
; 13942: 						//      .
; 13943: 						ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE) lpObj->X, (BYTE) lpObj->Y, ItemGetNumberMake(14, 13), 0, (BYTE)0, 0, 0, 0, lpObj->m_Index);
; 13944: 
; 13945: 						//   .
; 13946: 						if(gObjIsConnected(lpObj->m_Index)) {
; 13947: 							
; 13948: #ifdef MODIFY_CASTLEDEEP_EVENT_MESSAGE_20051013
; 13949: 							// 3227 "   %s  %s  ."
; 13950: 							wsprintf(szMsg, lMsg.Get(3227), lpTargetObj->Name, lpObj->Name);
; 13951: #endif
; 13952: 							LogAddTD("[CastleDeep Event] [%s][%s] Boss Monster Killed : %s",
; 13953: 								lpObj->AccountID,
; 13954: 								lpObj->Name,
; 13955: 								lpTargetObj->Name
; 13956: 								);
; 13957: 						}
; 13958: 						else {
; 13959: 
; 13960: #ifdef MODIFY_CASTLEDEEP_EVENT_MESSAGE_20051013
; 13961: 							// 3228 "   %s  ."
; 13962: 							wsprintf(szMsg, lMsg.Get(3228), lpTargetObj->Name);
; 13963: #endif
; 13964: 							LogAddTD("[CastleDeep Event] Boss Monster Killed : %s",
; 13965: 								lpTargetObj->Name
; 13966: 								);
; 13967: 						}
; 13968: 
; 13969: 						PMSG_NOTICE	pNotice;
; 13970: #ifdef MODIFY_NOTICE_20040325
; 13971: 						TNotice::MakeNoticeMsg(&pNotice, 0, szMsg);
; 13972: #else
; 13973: 						pNotice.type = 0;
; 13974: 						strcpy(pNotice.Notice, szMsg);
; 13975: 						PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 13976: #endif
; 13977: 						
; 13978: 						for( int i=ALLOC_USEROBJECTSTART ; i<MAX_OBJECT; i++)
; 13979: 						{
; 13980: 							if( (gObj[i].Connected == 3) && (gObj[i].Type == OBJTYPE_CHARACTER))
; 13981: 							{
; 13982: 								DataSend(i, (LPBYTE)&pNotice, pNotice.h.size);
; 13983: 							}
; 13984: 						}
; 13985: 					}
; 13986: 					break;
; 13987: 				case 295:
; 13988: 					{
; 13989: 						if(gObjIsConnected(lpObj->m_Index)) {
; 13990: 							
; 13991: #ifdef MODIFY_CASTLEDEEP_EVENT_MESSAGE_20051013
; 13992: 							// 3229 "     %s  ."
; 13993: 							wsprintf(szMsg, lMsg.Get(3229), lpObj->Name);
; 13994: #endif
; 13995: 
; 13996: 							LogAddTD("[CastleDeep Event] [%s][%s] Boss Monster Killed : %s",
; 13997: 								lpObj->AccountID,
; 13998: 								lpObj->Name,
; 13999: 								lpTargetObj->Name
; 14000: 								);
; 14001: 						}
; 14002: 						else {
; 14003: 
; 14004: #ifdef MODIFY_CASTLEDEEP_EVENT_MESSAGE_20051013
; 14005: 							// 3230 "     ."
; 14006: 							wsprintf(szMsg, lMsg.Get(3230));
; 14007: #endif
; 14008: 
; 14009: 							LogAddTD("[CastleDeep Event] Boss Monster Killed : %s",
; 14010: 								lpTargetObj->Name
; 14011: 								);
; 14012: 						}
; 14013: 					
; 14014: 						PMSG_NOTICE	pNotice;
; 14015: #ifdef MODIFY_NOTICE_20040325
; 14016: 						TNotice::MakeNoticeMsg(&pNotice, 0, szMsg);
; 14017: #else
; 14018: 						pNotice.type = 0;
; 14019: 						strcpy(pNotice.Notice, szMsg);
; 14020: 						PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 14021: #endif
; 14022: 						for( int i=ALLOC_USEROBJECTSTART ; i<MAX_OBJECT; i++)
; 14023: 						{
; 14024: 							if( (gObj[i].Connected == 3) && (gObj[i].Type == OBJTYPE_CHARACTER))
; 14025: 							{
; 14026: 								DataSend(i, (LPBYTE)&pNotice, pNotice.h.size);
; 14027: 							}
; 14028: 						}
; 14029: 					}
; 14030: 					break;
; 14031: 				}
; 14032: 			}
; 14033: #endif
; 14034: 
; 14035: 
; 14036: 
; 14037: #ifdef FOR_BLOODCASTLE
; 14038: 			if (CHECK_BLOODCASTLE(lpTargetObj->MapNumber)) {

  0040e	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00411	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00418	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  0041b	7d 0c		 jge	 SHORT $LN81@gObjLifeCh
  0041d	c7 85 f4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv279[ebp], 0
  00427	eb 31		 jmp	 SHORT $LN82@gObjLifeCh
$LN81@gObjLifeCh:
  00429	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  0042c	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00433	83 f8 11	 cmp	 eax, 17			; 00000011H
  00436	7e 0c		 jle	 SHORT $LN79@gObjLifeCh
  00438	c7 85 f0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv278[ebp], 0
  00442	eb 0a		 jmp	 SHORT $LN80@gObjLifeCh
$LN79@gObjLifeCh:
  00444	c7 85 f0 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR tv278[ebp], 1
$LN80@gObjLifeCh:
  0044e	8b 8d f0 fa ff
	ff		 mov	 ecx, DWORD PTR tv278[ebp]
  00454	89 8d f4 fa ff
	ff		 mov	 DWORD PTR tv279[ebp], ecx
$LN82@gObjLifeCh:
  0045a	83 bd f4 fa ff
	ff 00		 cmp	 DWORD PTR tv279[ebp], 0
  00461	0f 84 70 05 00
	00		 je	 $LN3@gObjLifeCh

; 14039: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 14040: 				int iBridgeIndex = g_BloodCastle.GetBridgeIndexByMapNum( lpTargetObj->MapNumber );
; 14041: #endif
; 14042: 				if (lpTargetObj->Class == 131) {	//  .

  00467	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0046a	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00471	81 f9 83 00 00
	00		 cmp	 ecx, 131		; 00000083H
  00477	0f 85 2a 02 00
	00		 jne	 $LN34@gObjLifeCh

; 14043: 					//     .
; 14044: 					int iMaxHitIndex = gObjMonsterTopHitDamageUser(lpTargetObj);

  0047d	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00480	50		 push	 eax
  00481	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00486	83 c4 04	 add	 esp, 4
  00489	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _iMaxHitIndex$11[ebp], eax

; 14045: 					if( iMaxHitIndex != -1 )

  0048f	83 bd e4 fe ff
	ff ff		 cmp	 DWORD PTR _iMaxHitIndex$11[ebp], -1
  00496	0f 84 ac 01 00
	00		 je	 $LN33@gObjLifeCh

; 14046: 					{	
; 14047: 						//     
; 14048: 						// "%s   "
; 14049: 						char msg[255];
; 14050: 						wsprintf(msg, lMsg.Get(1178), gObj[iMaxHitIndex].Name);

  0049c	69 85 e4 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$11[ebp], 7072
  004a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004ac	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  004b0	52		 push	 edx
  004b1	68 9a 04 00 00	 push	 1178			; 0000049aH
  004b6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  004bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  004c1	50		 push	 eax
  004c2	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _msg$10[ebp]
  004c8	50		 push	 eax
  004c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  004cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14051: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 14052: 						g_BloodCastle.SendNoticeMessage(iBridgeIndex, msg);
; 14053: #else
; 14054: 						g_BloodCastle.SendNoticeMessage(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1, msg);

  004d2	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _msg$10[ebp]
  004d8	50		 push	 eax
  004d9	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004dc	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  004e3	83 ea 0b	 sub	 edx, 11			; 0000000bH
  004e6	52		 push	 edx
  004e7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  004ec	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage

; 14055: #endif
; 14056: 
; 14057: 						//     .
; 14058: 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_iExtraEXP_Kill_Door_Party = gObj[iMaxHitIndex].PartyNumber;

  004f1	69 85 e4 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$11[ebp], 7072
  004fb	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004fe	0f be 91 d2 0c
	00 00		 movsx	 edx, BYTE PTR [ecx+3282]
  00505	69 ca 04 02 00
	00		 imul	 ecx, edx, 516
  0050b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00511	8b 84 02 88 02
	00 00		 mov	 eax, DWORD PTR [edx+eax+648]
  00518	89 81 a0 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+416], eax

; 14059: 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_iExtraEXP_Kill_Door_Index = iMaxHitIndex;

  0051e	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00521	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  00528	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  0052e	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _iMaxHitIndex$11[ebp]
  00534	89 82 a4 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+420], eax

; 14060: 						memcpy (g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_szKill_Door_CharName, gObj[iMaxHitIndex].Name, MAX_IDSTRING);

  0053a	6a 0a		 push	 10			; 0000000aH
  0053c	69 85 e4 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$11[ebp], 7072
  00546	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0054c	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00550	52		 push	 edx
  00551	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00554	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  0055b	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00561	81 c2 b3 01 00
	00		 add	 edx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A+435
  00567	52		 push	 edx
  00568	e8 00 00 00 00	 call	 _memcpy
  0056d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14061: 						memcpy (g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_szKill_Door_AccountID, gObj[iMaxHitIndex].AccountID, MAX_IDSTRING);

  00570	6a 0a		 push	 10			; 0000000aH
  00572	69 85 e4 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$11[ebp], 7072
  0057c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00582	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00586	52		 push	 edx
  00587	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0058a	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  00591	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00597	81 c2 a8 01 00
	00		 add	 edx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A+424
  0059d	52		 push	 edx
  0059e	e8 00 00 00 00	 call	 _memcpy
  005a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14062: 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_szKill_Door_CharName[MAX_IDSTRING] = '\0';

  005a6	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005a9	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  005b0	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  005b6	b8 01 00 00 00	 mov	 eax, 1
  005bb	6b c8 0a	 imul	 ecx, eax, 10
  005be	c6 84 0a b3 01
	00 00 00	 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+ecx+435], 0

; 14063: 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_szKill_Door_AccountID[MAX_IDSTRING] = '\0';

  005c6	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005c9	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  005d0	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  005d6	b8 01 00 00 00	 mov	 eax, 1
  005db	6b c8 0a	 imul	 ecx, eax, 10
  005de	c6 84 0a a8 01
	00 00 00	 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+ecx+424], 0

; 14064: 
; 14065: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 14066: 						LogAddTD("[Blood Castle] (%d) Door Terminated -> %d [%s][%s]", 
; 14067: 								iBridgeIndex+1, 
; 14068: 								g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT, 
; 14069: 								gObj[iMaxHitIndex].AccountID, 
; 14070: 								gObj[iMaxHitIndex].Name
; 14071: 								);
; 14072: #else
; 14073: 						LogAddTD("[Blood Castle] (%d) Door Terminated -> %d [%s][%s]", 

  005e6	69 85 e4 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$11[ebp], 7072
  005f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005f6	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  005fa	52		 push	 edx
  005fb	69 85 e4 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$11[ebp], 7072
  00605	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0060b	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0060f	52		 push	 edx
  00610	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00613	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0061a	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  0061d	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00623	8b 82 88 01 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+392]
  00629	50		 push	 eax
  0062a	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0062d	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00634	83 ea 0a	 sub	 edx, 10			; 0000000aH
  00637	52		 push	 edx
  00638	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@JANPNOOL@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Termin@
  0063d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00643	83 c4 14	 add	 esp, 20			; 00000014H

; 14074: 								lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1+1, 
; 14075: 								g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_KILL_COUNT, 
; 14076: 								gObj[iMaxHitIndex].AccountID, 
; 14077: 								gObj[iMaxHitIndex].Name
; 14078: 								);
; 14079: #endif
; 14080: 					}

  00646	eb 5f		 jmp	 SHORT $LN34@gObjLifeCh
$LN33@gObjLifeCh:

; 14081: 					else
; 14082: 					{	// ..  ...    "  ."
; 14083: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 14084: 						g_BloodCastle.SendNoticeMessage(iBridgeIndex, lMsg.Get(1169));	
; 14085: 						LogAddTD("[Blood Castle] (%d) Door Terminated -> %d)", 
; 14086: 							iBridgeIndex+1, 
; 14087: 							g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT);
; 14088: #else
; 14089: 						g_BloodCastle.SendNoticeMessage(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1, lMsg.Get(1169));	

  00648	68 91 04 00 00	 push	 1169			; 00000491H
  0064d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00652	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00658	50		 push	 eax
  00659	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0065c	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00663	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00666	51		 push	 ecx
  00667	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0066c	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage

; 14090: 						LogAddTD("[Blood Castle] (%d) Door Terminated -> %d)", 

  00671	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00674	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0067b	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  0067e	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00684	8b 82 88 01 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+392]
  0068a	50		 push	 eax
  0068b	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0068e	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00695	83 ea 0a	 sub	 edx, 10			; 0000000aH
  00698	52		 push	 edx
  00699	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@NGGLKHML@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Door?5Termin@
  0069e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  006a4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN34@gObjLifeCh:

; 14091: 							lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1+1, 
; 14092: 							g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_KILL_COUNT);
; 14093: #endif
; 14094: 					}
; 14095: 
; 14096: 				}
; 14097: 
; 14098: 				if (CHECK_LIMIT(lpTargetObj->Class-BC_SAINT_STATUE_1, 3))		//  

  006a7	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  006aa	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  006b1	81 e9 84 00 00
	00		 sub	 ecx, 132		; 00000084H
  006b7	79 0c		 jns	 SHORT $LN85@gObjLifeCh
  006b9	c7 85 f4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv403[ebp], 0
  006c3	eb 36		 jmp	 SHORT $LN86@gObjLifeCh
$LN85@gObjLifeCh:
  006c5	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  006c8	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  006cf	2d 84 00 00 00	 sub	 eax, 132		; 00000084H
  006d4	83 f8 02	 cmp	 eax, 2
  006d7	7e 0c		 jle	 SHORT $LN83@gObjLifeCh
  006d9	c7 85 f0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv402[ebp], 0
  006e3	eb 0a		 jmp	 SHORT $LN84@gObjLifeCh
$LN83@gObjLifeCh:
  006e5	c7 85 f0 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR tv402[ebp], 1
$LN84@gObjLifeCh:
  006ef	8b 8d f0 fa ff
	ff		 mov	 ecx, DWORD PTR tv402[ebp]
  006f5	89 8d f4 fa ff
	ff		 mov	 DWORD PTR tv403[ebp], ecx
$LN86@gObjLifeCh:
  006fb	83 bd f4 fa ff
	ff 00		 cmp	 DWORD PTR tv403[ebp], 0
  00702	0f 84 37 02 00
	00		 je	 $LN37@gObjLifeCh

; 14099: 				{
; 14100: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 14101: 					int iBridgeIndex = g_BloodCastle.GetBridgeIndexByMapNum( lpObj->MapNumber );
; 14102: #endif
; 14103: 					//     .
; 14104: 					int iMaxHitIndex = gObjMonsterTopHitDamageUser(lpTargetObj);

  00708	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0070b	50		 push	 eax
  0070c	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00711	83 c4 04	 add	 esp, 4
  00714	89 85 e0 fd ff
	ff		 mov	 DWORD PTR _iMaxHitIndex$9[ebp], eax

; 14105: 					if( iMaxHitIndex != -1 )

  0071a	83 bd e0 fd ff
	ff ff		 cmp	 DWORD PTR _iMaxHitIndex$9[ebp], -1
  00721	0f 84 b9 01 00
	00		 je	 $LN36@gObjLifeCh

; 14106: 					{	//     
; 14107: 						// "%s   "
; 14108: 						char msg[255];
; 14109: 						wsprintf(msg, lMsg.Get(1179), gObj[iMaxHitIndex].Name);

  00727	69 85 e0 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$9[ebp], 7072
  00731	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00737	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0073b	52		 push	 edx
  0073c	68 9b 04 00 00	 push	 1179			; 0000049bH
  00741	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00746	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0074c	50		 push	 eax
  0074d	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _msg$8[ebp]
  00753	50		 push	 eax
  00754	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0075a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14110: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    						
; 14111: 						g_BloodCastle.SendNoticeMessage(iBridgeIndex, msg);
; 14112: #else
; 14113: 						g_BloodCastle.SendNoticeMessage(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1, msg);

  0075d	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _msg$8[ebp]
  00763	50		 push	 eax
  00764	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00767	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0076e	83 ea 0b	 sub	 edx, 11			; 0000000bH
  00771	52		 push	 edx
  00772	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00777	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage

; 14114: #endif
; 14115: 
; 14116: 						//     .
; 14117: 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_iExtraEXP_Kill_Statue_Party = gObj[iMaxHitIndex].PartyNumber;

  0077c	69 85 e0 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$9[ebp], 7072
  00786	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00789	0f be 91 d2 0c
	00 00		 movsx	 edx, BYTE PTR [ecx+3282]
  00790	69 ca 04 02 00
	00		 imul	 ecx, edx, 516
  00796	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0079c	8b 84 02 88 02
	00 00		 mov	 eax, DWORD PTR [edx+eax+648]
  007a3	89 81 c0 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+448], eax

; 14118: 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_iExtraEXP_Kill_Statue_Index = gObj[iMaxHitIndex].m_Index;

  007a9	69 85 e0 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$9[ebp], 7072
  007b3	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  007b6	0f be 91 d2 0c
	00 00		 movsx	 edx, BYTE PTR [ecx+3282]
  007bd	69 ca 04 02 00
	00		 imul	 ecx, edx, 516
  007c3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007c9	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  007cc	89 81 c4 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[ecx+452], eax

; 14119: 						memcpy (g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_szKill_Status_CharName, gObj[iMaxHitIndex].Name, MAX_IDSTRING);

  007d2	6a 0a		 push	 10			; 0000000aH
  007d4	69 85 e0 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$9[ebp], 7072
  007de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007e4	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  007e8	52		 push	 edx
  007e9	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007ec	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  007f3	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  007f9	81 c2 c8 01 00
	00		 add	 edx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A+456
  007ff	52		 push	 edx
  00800	e8 00 00 00 00	 call	 _memcpy
  00805	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14120: 						memcpy (g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_szKill_Status_AccountID, gObj[iMaxHitIndex].AccountID, MAX_IDSTRING);

  00808	6a 0a		 push	 10			; 0000000aH
  0080a	69 85 e0 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$9[ebp], 7072
  00814	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0081a	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0081e	52		 push	 edx
  0081f	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00822	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  00829	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  0082f	81 c2 d3 01 00
	00		 add	 edx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A+467
  00835	52		 push	 edx
  00836	e8 00 00 00 00	 call	 _memcpy
  0083b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14121: 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_szKill_Status_CharName[MAX_IDSTRING] = '\0';

  0083e	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00841	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  00848	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  0084e	b8 01 00 00 00	 mov	 eax, 1
  00853	6b c8 0a	 imul	 ecx, eax, 10
  00856	c6 84 0a c8 01
	00 00 00	 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+ecx+456], 0

; 14122: 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_szKill_Status_AccountID[MAX_IDSTRING] = '\0';

  0085e	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00861	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  00868	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  0086e	b8 01 00 00 00	 mov	 eax, 1
  00873	6b c8 0a	 imul	 ecx, eax, 10
  00876	c6 84 0a d3 01
	00 00 00	 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+ecx+467], 0

; 14123: 
; 14124: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 14125: 						LogAddTD("[Blood Castle] (%d) a stone statue Of Saint Terminated -> %d [%s][%s]", 
; 14126: 							iBridgeIndex+1, 
; 14127: 							g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT, 
; 14128: 							gObj[iMaxHitIndex].AccountID, 
; 14129: 							gObj[iMaxHitIndex].Name
; 14130: 							);
; 14131: #else
; 14132: 						LogAddTD("[Blood Castle] (%d) a stone statue Of Saint Terminated -> %d [%s][%s]", 

  0087e	69 85 e0 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$9[ebp], 7072
  00888	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0088e	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00892	52		 push	 edx
  00893	69 85 e0 fd ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$9[ebp], 7072
  0089d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  008a3	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  008a7	52		 push	 edx
  008a8	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008ab	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  008b2	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  008b5	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  008bb	8b 82 88 01 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+392]
  008c1	50		 push	 eax
  008c2	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  008c5	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  008cc	83 ea 0a	 sub	 edx, 10			; 0000000aH
  008cf	52		 push	 edx
  008d0	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@KMNGALHI@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5a?5stone?5sta@
  008d5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  008db	83 c4 14	 add	 esp, 20			; 00000014H

; 14133: 							lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1+1, 
; 14134: 							g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_KILL_COUNT, 
; 14135: 							gObj[iMaxHitIndex].AccountID, 
; 14136: 							gObj[iMaxHitIndex].Name
; 14137: 							);
; 14138: #endif
; 14139: 					}

  008de	eb 5f		 jmp	 SHORT $LN37@gObjLifeCh
$LN36@gObjLifeCh:

; 14140: 					else
; 14141: 					{	// ..  ...    "  ."
; 14142: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 14143: 						g_BloodCastle.SendNoticeMessage(iBridgeIndex, lMsg.Get(1170));	
; 14144: 						LogAddTD("[Blood Castle] (%d) a stone statue Of Saint Terminated -> %d", 
; 14145: 							iBridgeIndex+1, 
; 14146: 							g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT);
; 14147: #else
; 14148: 						g_BloodCastle.SendNoticeMessage(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1, lMsg.Get(1170));	

  008e0	68 92 04 00 00	 push	 1170			; 00000492H
  008e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  008ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  008f0	50		 push	 eax
  008f1	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008f4	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  008fb	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  008fe	51		 push	 ecx
  008ff	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00904	e8 00 00 00 00	 call	 ?SendNoticeMessage@CBloodCastle@@QAEXHPAD@Z ; CBloodCastle::SendNoticeMessage

; 14149: 						LogAddTD("[Blood Castle] (%d) a stone statue Of Saint Terminated -> %d", 

  00909	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0090c	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00913	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00916	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  0091c	8b 82 88 01 00
	00		 mov	 eax, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+392]
  00922	50		 push	 eax
  00923	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00926	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0092d	83 ea 0a	 sub	 edx, 10			; 0000000aH
  00930	52		 push	 edx
  00931	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@HEKHJLCJ@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5a?5stone?5sta@
  00936	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0093c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN37@gObjLifeCh:

; 14150: 							lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1+1, 
; 14151: 							g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_KILL_COUNT);
; 14152: #endif
; 14153: 					}
; 14154: 				}
; 14155: 
; 14156: #ifdef FOR_BLOODCASTLE3
; 14157: 				//     .
; 14158: 				for (int i = 0 ; i < MAX_BLOODCASTLE_USER_COUNT ; i++) {

  0093f	c7 85 dc fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$7[ebp], 0
  00949	eb 0f		 jmp	 SHORT $LN4@gObjLifeCh
$LN2@gObjLifeCh:
  0094b	8b 85 dc fc ff
	ff		 mov	 eax, DWORD PTR _i$7[ebp]
  00951	83 c0 01	 add	 eax, 1
  00954	89 85 dc fc ff
	ff		 mov	 DWORD PTR _i$7[ebp], eax
$LN4@gObjLifeCh:
  0095a	83 bd dc fc ff
	ff 0a		 cmp	 DWORD PTR _i$7[ebp], 10	; 0000000aH
  00961	7d 74		 jge	 SHORT $LN3@gObjLifeCh

; 14159: 					if (g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[i].m_iIndex != -1 &&

  00963	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00966	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  0096d	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00973	6b 85 dc fc ff
	ff 14		 imul	 eax, DWORD PTR _i$7[ebp], 20
  0097a	83 bc 02 1c 00
	00 00 ff	 cmp	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+eax+28], -1
  00982	74 4e		 je	 SHORT $LN38@gObjLifeCh
  00984	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00987	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  0098e	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00994	6b 85 dc fc ff
	ff 14		 imul	 eax, DWORD PTR _i$7[ebp], 20
  0099b	69 8c 02 1c 00
	00 00 a0 1b 00
	00		 imul	 ecx, DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+eax+28], 7072
  009a6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009ac	83 7c 0a 04 02	 cmp	 DWORD PTR [edx+ecx+4], 2
  009b1	7e 1f		 jle	 SHORT $LN38@gObjLifeCh

; 14160: 						gObj[g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[i].m_iIndex].Connected > 2
; 14161: 						)
; 14162: 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_UserData[i].m_bLiveWhenDoorBreak = true;

  009b3	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009b6	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  009bd	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  009c3	6b 85 dc fc ff
	ff 14		 imul	 eax, DWORD PTR _i$7[ebp], 20
  009ca	c6 84 02 2d 00
	00 00 01	 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+eax+45], 1
$LN38@gObjLifeCh:

; 14163: 				}

  009d2	e9 74 ff ff ff	 jmp	 $LN2@gObjLifeCh
$LN3@gObjLifeCh:

; 14164: #endif
; 14165: 			}
; 14166: #endif			
; 14167: 
; 14168: #ifdef CHAOSCASTLE_SYSTEM_20040408		//      5x5  .
; 14169: 			if (CHECK_CHAOSCASTLE(lpTargetObj->MapNumber)) {

  009d7	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  009da	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  009e1	83 f9 12	 cmp	 ecx, 18			; 00000012H
  009e4	7d 0c		 jge	 SHORT $LN89@gObjLifeCh
  009e6	c7 85 f4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv556[ebp], 0
  009f0	eb 31		 jmp	 SHORT $LN90@gObjLifeCh
$LN89@gObjLifeCh:
  009f2	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  009f5	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  009fc	83 f8 17	 cmp	 eax, 23			; 00000017H
  009ff	7e 0c		 jle	 SHORT $LN87@gObjLifeCh
  00a01	c7 85 f0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv555[ebp], 0
  00a0b	eb 0a		 jmp	 SHORT $LN88@gObjLifeCh
$LN87@gObjLifeCh:
  00a0d	c7 85 f0 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR tv555[ebp], 1
$LN88@gObjLifeCh:
  00a17	8b 8d f0 fa ff
	ff		 mov	 ecx, DWORD PTR tv555[ebp]
  00a1d	89 8d f4 fa ff
	ff		 mov	 DWORD PTR tv556[ebp], ecx
$LN90@gObjLifeCh:
  00a23	83 bd f4 fa ff
	ff 00		 cmp	 DWORD PTR tv556[ebp], 0
  00a2a	0f 84 2f 01 00
	00		 je	 $LN42@gObjLifeCh

; 14170: 				if (rand()%100 < MAX_BLOWOUT_PERCENT) {

  00a30	e8 00 00 00 00	 call	 _rand
  00a35	99		 cdq
  00a36	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00a3b	f7 f9		 idiv	 ecx
  00a3d	83 fa 32	 cmp	 edx, 50			; 00000032H
  00a40	7d 2b		 jge	 SHORT $LN40@gObjLifeCh

; 14171: 					g_ChaosCastle.SearchNBlowObjs(lpTargetObj->MapNumber, lpTargetObj->X, lpTargetObj->Y);

  00a42	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00a45	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00a4c	51		 push	 ecx
  00a4d	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00a50	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  00a57	50		 push	 eax
  00a58	8b 4d 08	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00a5b	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00a62	52		 push	 edx
  00a63	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00a68	e8 00 00 00 00	 call	 ?SearchNBlowObjs@CChaosCastle@@QAEXHHH@Z ; CChaosCastle::SearchNBlowObjs
$LN40@gObjLifeCh:

; 14172: 				}
; 14173: 				
; 14174: 				//    .
; 14175: #ifdef ADD_CHAOSCASTLE_FOR_MASTER_LEVEL_20071010	//   
; 14176: 				g_ChaosCastle.DelMonsterList( g_ChaosCastle.GetChaosCastleByMapNum( lpTargetObj->MapNumber ), lpTargetObj->m_Index);
; 14177: #else
; 14178: 				g_ChaosCastle.DelMonsterList(lpTargetObj->MapNumber - MAP_INDEX_CHAOSCASTLE1, lpTargetObj->m_Index);

  00a6d	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00a70	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a72	51		 push	 ecx
  00a73	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00a76	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00a7d	83 e8 12	 sub	 eax, 18			; 00000012H
  00a80	50		 push	 eax
  00a81	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00a86	e8 00 00 00 00	 call	 ?DelMonsterList@CChaosCastle@@QAEXHH@Z ; CChaosCastle::DelMonsterList

; 14179: #endif
; 14180: 
; 14181: 				//      .
; 14182: 				int iMaxHitIndex = gObjMonsterTopHitDamageUser(lpTargetObj);

  00a8b	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00a8e	50		 push	 eax
  00a8f	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00a94	83 c4 04	 add	 esp, 4
  00a97	89 85 d8 fc ff
	ff		 mov	 DWORD PTR _iMaxHitIndex$6[ebp], eax

; 14183: 				if( iMaxHitIndex != -1 ) {

  00a9d	83 bd d8 fc ff
	ff ff		 cmp	 DWORD PTR _iMaxHitIndex$6[ebp], -1
  00aa4	0f 84 b5 00 00
	00		 je	 $LN42@gObjLifeCh

; 14184: 					if (CHECK_CHAOSCASTLE(gObj[iMaxHitIndex].MapNumber) && gObjIsConnected(iMaxHitIndex)) {

  00aaa	69 85 d8 fc ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$6[ebp], 7072
  00ab4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00aba	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00ac2	83 fa 12	 cmp	 edx, 18			; 00000012H
  00ac5	7d 0c		 jge	 SHORT $LN93@gObjLifeCh
  00ac7	c7 85 f4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv592[ebp], 0
  00ad1	eb 3f		 jmp	 SHORT $LN94@gObjLifeCh
$LN93@gObjLifeCh:
  00ad3	69 85 d8 fc ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$6[ebp], 7072
  00add	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ae3	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00aeb	83 fa 17	 cmp	 edx, 23			; 00000017H
  00aee	7e 0c		 jle	 SHORT $LN91@gObjLifeCh
  00af0	c7 85 f0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv591[ebp], 0
  00afa	eb 0a		 jmp	 SHORT $LN92@gObjLifeCh
$LN91@gObjLifeCh:
  00afc	c7 85 f0 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR tv591[ebp], 1
$LN92@gObjLifeCh:
  00b06	8b 85 f0 fa ff
	ff		 mov	 eax, DWORD PTR tv591[ebp]
  00b0c	89 85 f4 fa ff
	ff		 mov	 DWORD PTR tv592[ebp], eax
$LN94@gObjLifeCh:
  00b12	83 bd f4 fa ff
	ff 00		 cmp	 DWORD PTR tv592[ebp], 0
  00b19	74 44		 je	 SHORT $LN42@gObjLifeCh
  00b1b	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _iMaxHitIndex$6[ebp]
  00b21	50		 push	 eax
  00b22	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00b27	83 c4 04	 add	 esp, 4
  00b2a	85 c0		 test	 eax, eax
  00b2c	74 31		 je	 SHORT $LN42@gObjLifeCh

; 14185: 						gObj[iMaxHitIndex].m_cKillMonsterCount++;

  00b2e	69 85 d8 fc ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$6[ebp], 7072
  00b38	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b3e	8a 94 01 e1 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3297]
  00b45	80 c2 01	 add	 dl, 1
  00b48	69 85 d8 fc ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iMaxHitIndex$6[ebp], 7072
  00b52	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b58	88 94 01 e1 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3297], dl
$LN42@gObjLifeCh:

; 14186: 					}
; 14187: 				}
; 14188: 			}
; 14189: #endif
; 14190: 
; 14191: 			//     .
; 14192: 
; 14193: 
; 14194: 			gObjPkDownTimeCheck(lpObj, lpTargetObj->Level);

  00b5f	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00b62	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00b69	51		 push	 ecx
  00b6a	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b6d	52		 push	 edx
  00b6e	e8 00 00 00 00	 call	 ?gObjPkDownTimeCheck@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjPkDownTimeCheck
  00b73	83 c4 08	 add	 esp, 8

; 14195: 
; 14196: 			
; 14197: 			if( lpObj->Type == OBJTYPE_CHARACTER )

  00b76	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b79	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00b7d	83 f9 01	 cmp	 ecx, 1
  00b80	75 1b		 jne	 SHORT $LN43@gObjLifeCh

; 14198: 			{
; 14199: 				gObjAddMsgSendDelay(lpObj, 3, lpTargetObj->m_Index, 2000);

  00b82	6a 00		 push	 0
  00b84	68 d0 07 00 00	 push	 2000			; 000007d0H
  00b89	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00b8c	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b8e	51		 push	 ecx
  00b8f	6a 03		 push	 3
  00b91	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b94	52		 push	 edx
  00b95	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  00b9a	83 c4 14	 add	 esp, 20			; 00000014H
$LN43@gObjLifeCh:

; 14200: 			}
; 14201: 		}

  00b9d	e9 6a 02 00 00	 jmp	 $LN49@gObjLifeCh
$LN26@gObjLifeCh:

; 14202: 		else if( lpTargetObj->Type == OBJTYPE_CHARACTER )		//   .

  00ba2	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00ba5	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00ba9	83 f9 01	 cmp	 ecx, 1
  00bac	0f 85 5a 02 00
	00		 jne	 $LN49@gObjLifeCh

; 14203: 		{
; 14204: #ifdef FOR_BLOODCASTLE
; 14205: 			if (CHECK_BLOODCASTLE(lpTargetObj->MapNumber)) {	//    .

  00bb2	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00bb5	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00bbc	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00bbf	7d 0c		 jge	 SHORT $LN97@gObjLifeCh
  00bc1	c7 85 f4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv630[ebp], 0
  00bcb	eb 31		 jmp	 SHORT $LN98@gObjLifeCh
$LN97@gObjLifeCh:
  00bcd	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00bd0	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00bd7	83 f8 11	 cmp	 eax, 17			; 00000011H
  00bda	7e 0c		 jle	 SHORT $LN95@gObjLifeCh
  00bdc	c7 85 f0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv629[ebp], 0
  00be6	eb 0a		 jmp	 SHORT $LN96@gObjLifeCh
$LN95@gObjLifeCh:
  00be8	c7 85 f0 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR tv629[ebp], 1
$LN96@gObjLifeCh:
  00bf2	8b 8d f0 fa ff
	ff		 mov	 ecx, DWORD PTR tv629[ebp]
  00bf8	89 8d f4 fa ff
	ff		 mov	 DWORD PTR tv630[ebp], ecx
$LN98@gObjLifeCh:
  00bfe	83 bd f4 fa ff
	ff 00		 cmp	 DWORD PTR tv630[ebp], 0
  00c05	74 22		 je	 SHORT $LN45@gObjLifeCh

; 14206: 				//    .
; 14207: 				g_BloodCastle.SetUserState(lpTargetObj->m_Index, BC_USER_DEAD);

  00c07	6a 01		 push	 1
  00c09	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c0c	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c0e	51		 push	 ecx
  00c0f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00c14	e8 00 00 00 00	 call	 ?SetUserState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::SetUserState

; 14208: 				//      .
; 14209: 				g_BloodCastle.SearchUserDropQuestItem(lpTargetObj->m_Index);

  00c19	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c1c	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c1e	51		 push	 ecx
  00c1f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00c24	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem
$LN45@gObjLifeCh:

; 14210: 			}
; 14211: #endif
; 14212: 
; 14213: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328		//      
; 14214: 			if(CHECK_ILLUSION_TEMPLE(lpTargetObj->MapNumber))
; 14215: 			{
; 14216: 				g_IllusionTempleEvent.DropRelicsItem(lpTargetObj->MapNumber, lpTargetObj->m_Index);
; 14217: 			}
; 14218: #endif
; 14219: 
; 14220: #ifdef CHAOSCASTLE_SYSTEM_20040408								//        ,     .
; 14221: 			if (CHECK_CHAOSCASTLE(lpTargetObj->MapNumber)) {	//    .

  00c29	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c2c	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00c33	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00c36	7d 0c		 jge	 SHORT $LN101@gObjLifeCh
  00c38	c7 85 f4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv646[ebp], 0
  00c42	eb 31		 jmp	 SHORT $LN102@gObjLifeCh
$LN101@gObjLifeCh:
  00c44	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00c47	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00c4e	83 f8 17	 cmp	 eax, 23			; 00000017H
  00c51	7e 0c		 jle	 SHORT $LN99@gObjLifeCh
  00c53	c7 85 f0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv645[ebp], 0
  00c5d	eb 0a		 jmp	 SHORT $LN100@gObjLifeCh
$LN99@gObjLifeCh:
  00c5f	c7 85 f0 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR tv645[ebp], 1
$LN100@gObjLifeCh:
  00c69	8b 8d f0 fa ff
	ff		 mov	 ecx, DWORD PTR tv645[ebp]
  00c6f	89 8d f4 fa ff
	ff		 mov	 DWORD PTR tv646[ebp], ecx
$LN102@gObjLifeCh:
  00c75	83 bd f4 fa ff
	ff 00		 cmp	 DWORD PTR tv646[ebp], 0
  00c7c	0f 84 e4 00 00
	00		 je	 $LN46@gObjLifeCh

; 14222: 				g_ChaosCastle.SetUserState(lpTargetObj->m_Index, CC_USER_DEAD);

  00c82	6a 01		 push	 1
  00c84	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c87	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c89	51		 push	 ecx
  00c8a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00c8f	e8 00 00 00 00	 call	 ?SetUserState@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SetUserState

; 14223: 				if (CHECK_CHAOSCASTLE(lpObj->MapNumber) && gObjIsConnected(lpObj->m_Index)) {

  00c94	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c97	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00c9e	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00ca1	7d 0c		 jge	 SHORT $LN105@gObjLifeCh
  00ca3	c7 85 f4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv659[ebp], 0
  00cad	eb 31		 jmp	 SHORT $LN106@gObjLifeCh
$LN105@gObjLifeCh:
  00caf	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00cb2	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00cb9	83 f8 17	 cmp	 eax, 23			; 00000017H
  00cbc	7e 0c		 jle	 SHORT $LN103@gObjLifeCh
  00cbe	c7 85 f0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR tv658[ebp], 0
  00cc8	eb 0a		 jmp	 SHORT $LN104@gObjLifeCh
$LN103@gObjLifeCh:
  00cca	c7 85 f0 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR tv658[ebp], 1
$LN104@gObjLifeCh:
  00cd4	8b 8d f0 fa ff
	ff		 mov	 ecx, DWORD PTR tv658[ebp]
  00cda	89 8d f4 fa ff
	ff		 mov	 DWORD PTR tv659[ebp], ecx
$LN106@gObjLifeCh:
  00ce0	83 bd f4 fa ff
	ff 00		 cmp	 DWORD PTR tv659[ebp], 0
  00ce7	74 27		 je	 SHORT $LN47@gObjLifeCh
  00ce9	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cec	8b 08		 mov	 ecx, DWORD PTR [eax]
  00cee	51		 push	 ecx
  00cef	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00cf4	83 c4 04	 add	 esp, 4
  00cf7	85 c0		 test	 eax, eax
  00cf9	74 15		 je	 SHORT $LN47@gObjLifeCh

; 14224: 					lpObj->m_cKillUserCount++;

  00cfb	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cfe	8a 88 e0 0c 00
	00		 mov	 cl, BYTE PTR [eax+3296]
  00d04	80 c1 01	 add	 cl, 1
  00d07	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00d0a	88 8a e0 0c 00
	00		 mov	 BYTE PTR [edx+3296], cl
$LN47@gObjLifeCh:

; 14225: 				}
; 14226: 
; 14227: 				//     .
; 14228: #ifdef ADD_CHAOSCASTLE_FOR_MASTER_LEVEL_20071010	//   
; 14229: 				g_ChaosCastle.SendFailMessage ( g_ChaosCastle.GetChaosCastleByMapNum( lpTargetObj->MapNumber ), lpTargetObj->m_Index);
; 14230: #else
; 14231: 				g_ChaosCastle.SendFailMessage (lpTargetObj->MapNumber - MAP_INDEX_CHAOSCASTLE1, lpTargetObj->m_Index);

  00d10	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00d13	8b 08		 mov	 ecx, DWORD PTR [eax]
  00d15	51		 push	 ecx
  00d16	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00d19	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00d20	83 e8 12	 sub	 eax, 18			; 00000012H
  00d23	50		 push	 eax
  00d24	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00d29	e8 00 00 00 00	 call	 ?SendFailMessage@CChaosCastle@@QAEXHH@Z ; CChaosCastle::SendFailMessage

; 14232: #endif
; 14233: 
; 14234: 				LogAddTD("[Chaos Castle] (%d) [%s][%s] User Dead In Chaos Castle : Killed by [%s][%s]",

  00d2e	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d31	83 c0 73	 add	 eax, 115		; 00000073H
  00d34	50		 push	 eax
  00d35	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d38	83 c1 68	 add	 ecx, 104		; 00000068H
  00d3b	51		 push	 ecx
  00d3c	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00d3f	83 c2 73	 add	 edx, 115		; 00000073H
  00d42	52		 push	 edx
  00d43	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00d46	83 c0 68	 add	 eax, 104		; 00000068H
  00d49	50		 push	 eax
  00d4a	8b 4d 08	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00d4d	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00d54	83 ea 11	 sub	 edx, 17			; 00000011H
  00d57	52		 push	 edx
  00d58	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@OALGHOD@?$FLChaos?5Castle?$FN?5?$CI?$CFd?$CJ?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Us@
  00d5d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00d63	83 c4 18	 add	 esp, 24			; 00000018H
$LN46@gObjLifeCh:

; 14235: #ifdef ADD_CHAOSCASTLE_FOR_MASTER_LEVEL_20071010	//   
; 14236: 					( g_ChaosCastle.GetChaosCastleByMapNum( lpTargetObj->MapNumber ) + 1 ),
; 14237: #else
; 14238: 					lpTargetObj->MapNumber - MAP_INDEX_CHAOSCASTLE1 +1,
; 14239: #endif
; 14240: 					lpTargetObj->AccountID, 
; 14241: 					lpTargetObj->Name,
; 14242: 					lpObj->AccountID,
; 14243: 					lpObj->Name
; 14244: 					);
; 14245: 			}
; 14246: #endif
; 14247: 
; 14248: 			lpTargetObj->KillerType = KT_CHAR;

  00d66	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00d69	c6 80 fd 01 00
	00 00		 mov	 BYTE PTR [eax+509], 0

; 14249: 			gObjUserDie(lpTargetObj, lpCallObj);				//    ->      

  00d70	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _lpCallObj$[ebp]
  00d76	50		 push	 eax
  00d77	8b 4d 08	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00d7a	51		 push	 ecx
  00d7b	e8 00 00 00 00	 call	 ?gObjUserDie@@YAXPAVOBJECTSTRUCT@@0@Z ; gObjUserDie
  00d80	83 c4 08	 add	 esp, 8

; 14250: 
; 14251: 
; 14252: #ifdef DUEL_SYSTEM_20031028
; 14253: 			BOOL _guildWar = gObjGuildWarCheck(lpCallObj, lpTargetObj);

  00d83	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00d86	50		 push	 eax
  00d87	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _lpCallObj$[ebp]
  00d8d	51		 push	 ecx
  00d8e	e8 00 00 00 00	 call	 ?gObjGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjGuildWarCheck
  00d93	83 c4 08	 add	 esp, 8
  00d96	89 85 d4 fc ff
	ff		 mov	 DWORD PTR __guildWar$5[ebp], eax

; 14254: 			BOOL _bOnDuel = gObjDuelCheck(lpCallObj, lpTargetObj);

  00d9c	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00d9f	50		 push	 eax
  00da0	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _lpCallObj$[ebp]
  00da6	51		 push	 ecx
  00da7	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjDuelCheck
  00dac	83 c4 08	 add	 esp, 8
  00daf	89 85 d0 fc ff
	ff		 mov	 DWORD PTR __bOnDuel$4[ebp], eax

; 14255: 
; 14256: #ifdef CHINA_GM_EVENT
; 14257: 			if( lpTargetObj->Authority&AUTHORITY_EVENT_GM )
; 14258: 			{
; 14259: 				_guildWar = TRUE;
; 14260: 			}
; 14261: #endif
; 14262: 
; 14263: #ifdef MODIFY_CHN_GMEVENT_TO_TAIWAN_GM_EVENT_20070906
; 14264: 			if( lpTargetObj->Authority&AUTHORITY_EVENT_GM )
; 14265: 			{
; 14266: 				_guildWar = TRUE;
; 14267: 			}
; 14268: #endif // MODIFY_CHN_GMEVENT_TO_TAIWAN_GM_EVENT_20070906
; 14269: 
; 14270: #ifdef USER_DIE_MAKE_OPPOSIT_PK_20040329						//    PK  .
; 14271: #ifdef MOIDFY_PK_DAMAGE_REFLECT_NOPK_BUGFIX_20081202
; 14272: 			if( _guildWar == FALSE && _bOnDuel  == FALSE && lpTargetObj->m_bAttackerKilled == false) 
; 14273: 			{
; 14274: 				gObjPlayerKiller(lpCallObj, lpTargetObj, MSBDamage);
; 14275: 			}
; 14276: #else	// MOIDFY_PK_DAMAGE_REFLECT_NOPK_BUGFIX_20081202
; 14277: 			if( _guildWar == FALSE && _bOnDuel  == FALSE && lpTargetObj->m_bAttackerKilled == false) gObjPlayerKiller(lpCallObj, lpTargetObj);

  00db5	83 bd d4 fc ff
	ff 00		 cmp	 DWORD PTR __guildWar$5[ebp], 0
  00dbc	75 2a		 jne	 SHORT $LN48@gObjLifeCh
  00dbe	83 bd d0 fc ff
	ff 00		 cmp	 DWORD PTR __bOnDuel$4[ebp], 0
  00dc5	75 21		 jne	 SHORT $LN48@gObjLifeCh
  00dc7	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00dca	0f b6 88 3c 02
	00 00		 movzx	 ecx, BYTE PTR [eax+572]
  00dd1	85 c9		 test	 ecx, ecx
  00dd3	75 13		 jne	 SHORT $LN48@gObjLifeCh
  00dd5	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00dd8	50		 push	 eax
  00dd9	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _lpCallObj$[ebp]
  00ddf	51		 push	 ecx
  00de0	e8 00 00 00 00	 call	 ?gObjPlayerKiller@@YAXPAVOBJECTSTRUCT@@0@Z ; gObjPlayerKiller
  00de5	83 c4 08	 add	 esp, 8
$LN48@gObjLifeCh:

; 14278: #endif	// MOIDFY_PK_DAMAGE_REFLECT_NOPK_BUGFIX_20081202
; 14279: 			lpTargetObj->m_bAttackerKilled = false;

  00de8	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00deb	c6 80 3c 02 00
	00 00		 mov	 BYTE PTR [eax+572], 0

; 14280: #else
; 14281: 			if( _guildWar == FALSE && _bOnDuel  == FALSE ) gObjPlayerKiller(lpCallObj, lpTargetObj);
; 14282: #endif
; 14283: 
; 14284: #else
; 14285: #ifdef _NEW_EXDB_
; 14286: 			BOOL _guildWar = gObjGuildWarCheck(lpCallObj, lpTargetObj);
; 14287: 			if( _guildWar == FALSE ) gObjPlayerKiller(lpCallObj, lpTargetObj);
; 14288: #else
; 14289: 			gObjPlayerKiller(lpCallObj, lpTargetObj);
; 14290: #endif
; 14291: #endif
; 14292: 
; 14293: 			
; 14294: 			if( lpTargetObj->m_RecallMon >= 0 )

  00df2	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00df5	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  00dfc	7c 0e		 jl	 SHORT $LN49@gObjLifeCh

; 14295: 			{
; 14296: 				gObjMonsterCallKill(lpTargetObj->m_Index);

  00dfe	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00e01	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e03	51		 push	 ecx
  00e04	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  00e09	83 c4 04	 add	 esp, 4
$LN49@gObjLifeCh:

; 14297: 			}
; 14298: 		}
; 14299: 		lpTargetObj->Live	   = 0;

  00e0c	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00e0f	c6 40 66 00	 mov	 BYTE PTR [eax+102], 0

; 14300: 		lpTargetObj->m_State   = OBJST_DYING;	//   .

  00e13	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00e16	c7 80 b8 01 00
	00 04 00 00 00	 mov	 DWORD PTR [eax+440], 4

; 14301: 		lpTargetObj->RegenTime = GetTickCount();

  00e20	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00e26	8b 4d 08	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00e29	89 81 04 02 00
	00		 mov	 DWORD PTR [ecx+516], eax

; 14302: 		lpTargetObj->DieRegen  = 1;

  00e2f	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00e32	c6 80 fe 01 00
	00 01		 mov	 BYTE PTR [eax+510], 1

; 14303: 		lpTargetObj->PathCount = 0;

  00e39	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00e3c	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0

; 14304: 
; 14305: #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 14306: 		if( lpCallObj->m_btDuelScore >= 5 )
; 14307: 		{
; 14308: 			gObjSendDuelEnd(&gObj[lpCallObj->m_iDuelUser]);
; 14309: 			gObjSendDuelEnd(lpObj);
; 14310: 			gObjResetDuel(lpObj);
; 14311: 		}
; 14312: #endif
; 14313: 		
; 14314: 		//     20   ..
; 14315: #ifdef _NEW_EXDB_
; 14316: 		if( gObjTargetGuildWarCheck(lpTargetObj, lpCallObj) == TRUE )

  00e46	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _lpCallObj$[ebp]
  00e4c	50		 push	 eax
  00e4d	8b 4d 08	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00e50	51		 push	 ecx
  00e51	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00e56	83 c4 08	 add	 esp, 8
  00e59	83 f8 01	 cmp	 eax, 1
  00e5c	75 0a		 jne	 SHORT $LN50@gObjLifeCh

; 14317: 		{
; 14318: 			lpTargetObj->KillerType = KT_GUILDWARCHAR;

  00e5e	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00e61	c6 80 fd 01 00
	00 02		 mov	 BYTE PTR [eax+509], 2
$LN50@gObjLifeCh:

; 14319: 		}
; 14320: #endif
; 14321: 
; 14322: #ifdef DUEL_SYSTEM_20031028
; 14323: 		if (gObjDuelCheck(lpCallObj, lpTargetObj)) {

  00e68	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00e6b	50		 push	 eax
  00e6c	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _lpCallObj$[ebp]
  00e72	51		 push	 ecx
  00e73	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjDuelCheck
  00e78	83 c4 08	 add	 esp, 8
  00e7b	85 c0		 test	 eax, eax
  00e7d	0f 84 71 02 00
	00		 je	 $LN52@gObjLifeCh

; 14324: 			lpTargetObj->KillerType = KT_DUELCHAR;

  00e83	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00e86	c6 80 fd 01 00
	00 03		 mov	 BYTE PTR [eax+509], 3

; 14325: 
; 14326: #ifdef ADD_NEWPVP_PKFIELD
; 14327: 			g_NewPVP.CheckScore(*lpObj, *lpTargetObj);
; 14328: #else
; 14329: 			if (lpObj->m_btDuelScore >= 10) {

  00e8d	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e90	0f b6 88 f0 0c
	00 00		 movzx	 ecx, BYTE PTR [eax+3312]
  00e97	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00e9a	0f 8c 54 02 00
	00		 jl	 $LN52@gObjLifeCh

; 14330: 				//   .
; 14331: 				PMSG_ANS_END_DUEL pMsg;
; 14332: 				pMsg.h.c = PMHC_BYTE;

  00ea0	c6 85 c0 fc ff
	ff c1		 mov	 BYTE PTR _pMsg$3[ebp], 193 ; 000000c1H

; 14333: 				pMsg.h.headcode = 0xAB;

  00ea7	c6 85 c2 fc ff
	ff ab		 mov	 BYTE PTR _pMsg$3[ebp+2], 171 ; 000000abH

; 14334: 				pMsg.h.size = sizeof( pMsg );

  00eae	c6 85 c1 fc ff
	ff 0f		 mov	 BYTE PTR _pMsg$3[ebp+1], 15 ; 0000000fH

; 14335: 				pMsg.NumberH = HIBYTE(lpObj->m_Index);

  00eb5	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00eb8	8b 08		 mov	 ecx, DWORD PTR [eax]
  00eba	c1 e9 08	 shr	 ecx, 8
  00ebd	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00ec3	88 8d c3 fc ff
	ff		 mov	 BYTE PTR _pMsg$3[ebp+3], cl

; 14336: 				pMsg.NumberL = LOBYTE(lpObj->m_Index);

  00ec9	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ecc	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ece	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00ed4	88 8d c4 fc ff
	ff		 mov	 BYTE PTR _pMsg$3[ebp+4], cl

; 14337: 				memcpy(pMsg.szName, lpObj->Name, MAX_IDSTRING);

  00eda	6a 0a		 push	 10			; 0000000aH
  00edc	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00edf	83 c0 73	 add	 eax, 115		; 00000073H
  00ee2	50		 push	 eax
  00ee3	8d 8d c5 fc ff
	ff		 lea	 ecx, DWORD PTR _pMsg$3[ebp+5]
  00ee9	51		 push	 ecx
  00eea	e8 00 00 00 00	 call	 _memcpy
  00eef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14338: 				DataSend(lpTargetObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00ef2	0f b6 85 c1 fc
	ff ff		 movzx	 eax, BYTE PTR _pMsg$3[ebp+1]
  00ef9	50		 push	 eax
  00efa	8d 8d c0 fc ff
	ff		 lea	 ecx, DWORD PTR _pMsg$3[ebp]
  00f00	51		 push	 ecx
  00f01	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00f04	8b 02		 mov	 eax, DWORD PTR [edx]
  00f06	50		 push	 eax
  00f07	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00f0c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14339: 				lpTargetObj->m_iDuelUser = -1;

  00f0f	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00f12	c7 80 ec 0c 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+3308], -1

; 14340: 
; 14341: 				pMsg.NumberH = HIBYTE(lpTargetObj->m_Index);

  00f1c	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00f1f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f21	c1 e9 08	 shr	 ecx, 8
  00f24	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00f2a	88 8d c3 fc ff
	ff		 mov	 BYTE PTR _pMsg$3[ebp+3], cl

; 14342: 				pMsg.NumberL = LOBYTE(lpTargetObj->m_Index);

  00f30	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00f33	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f35	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00f3b	88 8d c4 fc ff
	ff		 mov	 BYTE PTR _pMsg$3[ebp+4], cl

; 14343: 				memcpy(pMsg.szName, lpTargetObj->Name, MAX_IDSTRING);

  00f41	6a 0a		 push	 10			; 0000000aH
  00f43	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00f46	83 c0 73	 add	 eax, 115		; 00000073H
  00f49	50		 push	 eax
  00f4a	8d 8d c5 fc ff
	ff		 lea	 ecx, DWORD PTR _pMsg$3[ebp+5]
  00f50	51		 push	 ecx
  00f51	e8 00 00 00 00	 call	 _memcpy
  00f56	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14344: 				DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00f59	0f b6 85 c1 fc
	ff ff		 movzx	 eax, BYTE PTR _pMsg$3[ebp+1]
  00f60	50		 push	 eax
  00f61	8d 8d c0 fc ff
	ff		 lea	 ecx, DWORD PTR _pMsg$3[ebp]
  00f67	51		 push	 ecx
  00f68	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00f6b	8b 02		 mov	 eax, DWORD PTR [edx]
  00f6d	50		 push	 eax
  00f6e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00f73	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14345: 				lpObj->m_iDuelUser = -1;

  00f76	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f79	c7 80 ec 0c 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+3308], -1

; 14346: 
; 14347: 			#ifdef MODIFY_DARKSPIRTI_TARGETRELEASE_ON_DUEL_20060524
; 14348: 				//    
; 14349: 				gDarkSpirit[lpObj->m_Index].ReSetTarget(lpTargetObj->m_Index);

  00f83	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00f86	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f88	51		 push	 ecx
  00f89	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00f8c	6b 0a 28	 imul	 ecx, DWORD PTR [edx], 40
  00f8f	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  00f95	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget

; 14350: 				gDarkSpirit[lpTargetObj->m_Index].ReSetTarget(lpObj->m_Index);

  00f9a	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f9d	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f9f	51		 push	 ecx
  00fa0	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00fa3	6b 0a 28	 imul	 ecx, DWORD PTR [edx], 40
  00fa6	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  00fac	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget

; 14351: 			#endif
; 14352: 				
; 14353: 				//  10    .
; 14354: 				CHAR szText[256];
; 14355: 				wsprintf(szText, lMsg.Get(1216),								// "%s  ."

  00fb1	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00fb4	83 c0 73	 add	 eax, 115		; 00000073H
  00fb7	50		 push	 eax
  00fb8	68 c0 04 00 00	 push	 1216			; 000004c0H
  00fbd	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00fc2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00fc8	50		 push	 eax
  00fc9	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _szText$2[ebp]
  00fcf	51		 push	 ecx
  00fd0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00fd6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14356: 					lpTargetObj->Name
; 14357: 					);
; 14358: 				GCServerMsgStringSend(szText, lpObj->m_Index, 1);				// "%s  ."

  00fd9	6a 01		 push	 1
  00fdb	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00fde	8b 08		 mov	 ecx, DWORD PTR [eax]
  00fe0	51		 push	 ecx
  00fe1	8d 95 c0 fb ff
	ff		 lea	 edx, DWORD PTR _szText$2[ebp]
  00fe7	52		 push	 edx
  00fe8	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00fed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14359: 				wsprintf(szText, lMsg.Get(1217),								// "%s  ."

  00ff0	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ff3	83 c0 73	 add	 eax, 115		; 00000073H
  00ff6	50		 push	 eax
  00ff7	68 c1 04 00 00	 push	 1217			; 000004c1H
  00ffc	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  01007	50		 push	 eax
  01008	8d 8d c0 fb ff
	ff		 lea	 ecx, DWORD PTR _szText$2[ebp]
  0100e	51		 push	 ecx
  0100f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  01015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14360: 					lpObj->Name
; 14361: 					);
; 14362: 				GCServerMsgStringSend(szText, lpTargetObj->m_Index, 1);			// "%s  ."

  01018	6a 01		 push	 1
  0101a	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0101d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0101f	51		 push	 ecx
  01020	8d 95 c0 fb ff
	ff		 lea	 edx, DWORD PTR _szText$2[ebp]
  01026	52		 push	 edx
  01027	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0102c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14363: 				
; 14364: 				
; 14365: 				//    .
; 14366: 				PMSG_SERVERCMD	ServerCmd;
; 14367: 				PHeadSubSetB((LPBYTE)&ServerCmd, 0xF3, 0x40, sizeof(ServerCmd));			

  0102f	6a 07		 push	 7
  01031	6a 40		 push	 64			; 00000040H
  01033	68 f3 00 00 00	 push	 243			; 000000f3H
  01038	8d 85 b8 fb ff
	ff		 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  0103e	50		 push	 eax
  0103f	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  01044	83 c4 10	 add	 esp, 16			; 00000010H

; 14368: 				ServerCmd.CmdType = 0;

  01047	c6 85 bc fb ff
	ff 00		 mov	 BYTE PTR _ServerCmd$1[ebp+4], 0

; 14369: 				ServerCmd.X = lpObj->X;

  0104e	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01051	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  01057	88 8d bd fb ff
	ff		 mov	 BYTE PTR _ServerCmd$1[ebp+5], cl

; 14370: 				ServerCmd.Y = lpObj->Y;

  0105d	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01060	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  01066	88 8d be fb ff
	ff		 mov	 BYTE PTR _ServerCmd$1[ebp+6], cl

; 14371: 				MsgSendV2(lpObj, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  0106c	6a 07		 push	 7
  0106e	8d 85 b8 fb ff
	ff		 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  01074	50		 push	 eax
  01075	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01078	51		 push	 ecx
  01079	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  0107e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14372: 				DataSend(lpObj->m_Index, (LPBYTE)&ServerCmd, sizeof(ServerCmd));

  01081	6a 07		 push	 7
  01083	8d 85 b8 fb ff
	ff		 lea	 eax, DWORD PTR _ServerCmd$1[ebp]
  01089	50		 push	 eax
  0108a	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0108d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0108f	52		 push	 edx
  01090	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01095	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14373: 
; 14374: 				LogAdd("[Duel] [%s][%s] Win Duel, Loser [%s][%s]",lpObj->AccountID,lpObj->Name,lpTargetObj->AccountID,lpTargetObj->Name);

  01098	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0109b	83 c0 73	 add	 eax, 115		; 00000073H
  0109e	50		 push	 eax
  0109f	8b 4d 08	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  010a2	83 c1 68	 add	 ecx, 104		; 00000068H
  010a5	51		 push	 ecx
  010a6	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  010a9	83 c2 73	 add	 edx, 115		; 00000073H
  010ac	52		 push	 edx
  010ad	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010b0	83 c0 68	 add	 eax, 104		; 00000068H
  010b3	50		 push	 eax
  010b4	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@KJGJCOOM@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win?5Duel?0?5Loser@
  010b9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  010bf	83 c4 14	 add	 esp, 20			; 00000014H

; 14375: 				Manager.ExecFormat("UPDATE [MuOnline].[dbo].[Character] SET DuelWins = DuelWins + 1 WHERE Name='%s'", lpObj->Name);					

  010c2	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010c5	83 c0 73	 add	 eax, 115		; 00000073H
  010c8	50		 push	 eax
  010c9	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@KCJNEJFM@UPDATE?5?$FLMuOnline?$FN?4?$FLdbo?$FN?4?$FLCharac@
  010ce	68 00 00 00 00	 push	 OFFSET ?Manager@@3VCManager@@A ; Manager
  010d3	e8 00 00 00 00	 call	 ?ExecFormat@CDataBase@@QAA_NPBDZZ ; CDataBase::ExecFormat
  010d8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14376: 			    Manager.ExecFormat("UPDATE [MuOnline].[dbo].[Character] SET DuelLoser = DuelLoser + 1 WHERE Name='%s'", lpTargetObj->Name); // sql duel wins

  010db	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  010de	83 c0 73	 add	 eax, 115		; 00000073H
  010e1	50		 push	 eax
  010e2	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@PMECEPOA@UPDATE?5?$FLMuOnline?$FN?4?$FLdbo?$FN?4?$FLCharac@
  010e7	68 00 00 00 00	 push	 OFFSET ?Manager@@3VCManager@@A ; Manager
  010ec	e8 00 00 00 00	 call	 ?ExecFormat@CDataBase@@QAA_NPBDZZ ; CDataBase::ExecFormat
  010f1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN52@gObjLifeCh:

; 14377: 			}
; 14378: #endif // ADD_NEWPVP_PKFIELD
; 14379: 		}
; 14380: #endif // DUEL_SYSTEM_20031028
; 14381: 
; 14382: 
; 14383: 		
; 14384: 		//   .
; 14385: 		if( lpTargetObj->Teleport == 1 ) lpTargetObj->Teleport = 0;

  010f4	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  010f7	0f be 88 fc 01
	00 00		 movsx	 ecx, BYTE PTR [eax+508]
  010fe	83 f9 01	 cmp	 ecx, 1
  01101	75 0a		 jne	 SHORT $LN53@gObjLifeCh
  01103	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  01106	c6 80 fc 01 00
	00 00		 mov	 BYTE PTR [eax+508], 0
$LN53@gObjLifeCh:

; 14386: 
; 14387: #ifdef ADD_SKILL_WITH_COMBO
; 14388: 		GCDiePlayerSend(lpTargetObj, lpTargetObj->m_Index, Skill, lpObj->m_Index);

  0110d	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01110	8b 08		 mov	 ecx, DWORD PTR [eax]
  01112	51		 push	 ecx
  01113	0f b6 55 20	 movzx	 edx, BYTE PTR _Skill$[ebp]
  01117	52		 push	 edx
  01118	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0111b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0111d	51		 push	 ecx
  0111e	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  01121	52		 push	 edx
  01122	e8 00 00 00 00	 call	 ?GCDiePlayerSend@@YAXPAVOBJECTSTRUCT@@HEH@Z ; GCDiePlayerSend
  01127	83 c4 10	 add	 esp, 16			; 00000010H

; 14389: #else
; 14390: 		GCDiePlayerSend(lpTargetObj, lpTargetObj->m_Index);
; 14391: #endif
; 14392: 		
; 14393: #ifdef ADD_RAKLION_20080408
; 14394: 		//    .
; 14395: 		if( lpTargetObj->MapNumber == MAP_INDEX_RAKLION_BOSS && lpTargetObj->Type >= OBJTYPE_MONSTER )
; 14396: 		{
; 14397: 			if( lpTargetObj->Class == 460 || lpTargetObj->Class == 461 || lpTargetObj->Class == 462 ) //  3
; 14398: 			{
; 14399: 				g_Raklion.BossEggDieDecrease();
; 14400: 				g_RaklionUtil.NotifyRaklionUserMonsterCount( g_Raklion.GetBossEggDieCount(), 0 );
; 14401: 			}
; 14402: 		}
; 14403: #endif //ADD_RAKLION_20080408
; 14404: 
; 14405: 		if( lpTargetObj->Class == 79 )

  0112a	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0112d	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  01134	83 f9 4f	 cmp	 ecx, 79			; 0000004fH
  01137	75 2a		 jne	 SHORT $LN54@gObjLifeCh

; 14406: 		{	//     						
; 14407: 			gEledoradoEvent.m_BossGoldDerconMapNumber[lpTargetObj->m_BossGoldDerconMapNumber] = -1;

  01139	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0113c	0f be 88 e7 0e
	00 00		 movsx	 ecx, BYTE PTR [eax+3815]
  01143	c7 04 8d 44 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ?gEledoradoEvent@@3VCEledoradoEvent@@A[ecx*4+68], -1

; 14408: 			gEledoradoEvent.CheckGoldDercon(lpObj->MapNumber);

  0114e	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01151	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  01158	51		 push	 ecx
  01159	b9 00 00 00 00	 mov	 ecx, OFFSET ?gEledoradoEvent@@3VCEledoradoEvent@@A ; gEledoradoEvent
  0115e	e8 00 00 00 00	 call	 ?CheckGoldDercon@CEledoradoEvent@@QAEXH@Z ; CEledoradoEvent::CheckGoldDercon
$LN54@gObjLifeCh:

; 14409: 		}
; 14410: 
; 14411: 		//-------------
; 14412: 		//  
; 14413: 		//-------------		
; 14414: 		if( lpTargetObj->m_RecallMon >= 0 ) return;	//    .

  01163	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  01166	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  0116d	7c 05		 jl	 SHORT $LN55@gObjLifeCh
  0116f	e9 7b 01 00 00	 jmp	 $LN1@gObjLifeCh
$LN55@gObjLifeCh:

; 14415: 		
; 14416: #ifdef MODIFY_NON_EXP_IN_CRYWOLF_MONSTER_20060530
; 14417: 		//       .
; 14418: 		if( lpTargetObj->Class == 340			// 
; 14419: //			|| lpTargetObj->Class == 341		// 
; 14420: //			|| lpTargetObj->Class == 344		// 
; 14421: //			|| lpTargetObj->Class == 345		// 
; 14422: 			|| lpTargetObj->Class == 348		// 
; 14423: 			|| lpTargetObj->Class == 349		// 
; 14424: 			)
; 14425: 		{
; 14426: 			return;
; 14427: 		}
; 14428: #endif
; 14429: 
; 14430: #ifdef ADD_NEW_MERCENARY_FOR_CASTLE_01_20041214
; 14431: 		//     .
; 14432: 		if( lpTargetObj->Class == NPC_INDEX_SPEARMAN 
; 14433: 			|| lpTargetObj->Class == NPC_INDEX_BOWMAN )
; 14434: 		{
; 14435: 			return;
; 14436: 		}
; 14437: #endif
; 14438: 
; 14439: #ifdef DISABLE_GETTING_EXP_FROM_KUNDUN_20070801
; 14440: 		if( lpTargetObj->Class == 275 )

  01174	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  01177	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0117e	81 f9 13 01 00
	00		 cmp	 ecx, 275		; 00000113H
  01184	75 05		 jne	 SHORT $LN56@gObjLifeCh

; 14441: 		{
; 14442: 			return;

  01186	e9 64 01 00 00	 jmp	 $LN1@gObjLifeCh
$LN56@gObjLifeCh:

; 14443: 		}
; 14444: #endif
; 14445: 
; 14446: #ifdef DISABLE_GETTING_EXP_FROM_GUARDTOWER_20070801
; 14447: 		if( lpTargetObj->Class == 288 )
; 14448: 		{
; 14449: 			return;
; 14450: 		}
; 14451: #endif
; 14452: 
; 14453: #ifdef DISABLE_GETTING_EXP_FROM_EROHIM_20050509
; 14454: 		if( lpTargetObj->Class == 295 )

  0118b	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0118e	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  01195	81 f9 27 01 00
	00		 cmp	 ecx, 295		; 00000127H
  0119b	75 05		 jne	 SHORT $LN57@gObjLifeCh

; 14455: 		{
; 14456: 			return;

  0119d	e9 4d 01 00 00	 jmp	 $LN1@gObjLifeCh
$LN57@gObjLifeCh:

; 14457: 		}
; 14458: #endif
; 14459: 		
; 14460: #ifdef KANTURU_BOSSMONSTER_EXP_NONE_20060809
; 14461: 		if( lpTargetObj->Class == KANTURU_MONSTER_MAYA_LEFTHAND 
; 14462: 			|| lpTargetObj->Class == KANTURU_MONSTER_MAYA_RIGHTHAND 
; 14463: 			|| lpTargetObj->Class == KANTURU_MONSTER_NIGHTMARE )
; 14464: 		{
; 14465: 			return;
; 14466: 		}
; 14467: #endif
; 14468: 
; 14469: #ifdef THIRD_CHANGEUP_SYSTEM_20070507	// ()   .
; 14470: 		if( lpTargetObj->Class == 412 )
; 14471: 		{
; 14472: 			return;
; 14473: 		}
; 14474: #endif
; 14475: 
; 14476: 		if( lpCallObj->Type == OBJTYPE_CHARACTER )

  011a2	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _lpCallObj$[ebp]
  011a8	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  011ac	83 f9 01	 cmp	 ecx, 1
  011af	0f 85 8b 00 00
	00		 jne	 $LN62@gObjLifeCh

; 14477: 		{
; 14478: 			//      ..
; 14479: 			if( lpCallObj->PartyNumber >= 0 )

  011b5	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _lpCallObj$[ebp]
  011bb	83 b8 88 02 00
	00 00		 cmp	 DWORD PTR [eax+648], 0
  011c2	7c 1d		 jl	 SHORT $LN59@gObjLifeCh

; 14480: 			{
; 14481: 				gObjExpParty(lpCallObj, lpTargetObj, AttackDamage, MSBFlag);

  011c4	8b 45 18	 mov	 eax, DWORD PTR _MSBFlag$[ebp]
  011c7	50		 push	 eax
  011c8	8b 4d 10	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  011cb	51		 push	 ecx
  011cc	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  011cf	52		 push	 edx
  011d0	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _lpCallObj$[ebp]
  011d6	50		 push	 eax
  011d7	e8 00 00 00 00	 call	 ?gObjExpParty@@YAXPAVOBJECTSTRUCT@@0HH@Z ; gObjExpParty
  011dc	83 c4 10	 add	 esp, 16			; 00000010H

; 14482: 			}

  011df	eb 27		 jmp	 SHORT $LN61@gObjLifeCh
$LN59@gObjLifeCh:

; 14483: 			else {
; 14484: 				if( lpTargetObj->Type == OBJTYPE_MONSTER )

  011e1	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  011e4	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  011e8	83 f9 02	 cmp	 ecx, 2
  011eb	75 1b		 jne	 SHORT $LN61@gObjLifeCh

; 14485: 				{
; 14486: 					gObjMonsterExpDivision(lpTargetObj, lpCallObj, AttackDamage, MSBFlag);

  011ed	8b 45 18	 mov	 eax, DWORD PTR _MSBFlag$[ebp]
  011f0	50		 push	 eax
  011f1	8b 4d 10	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  011f4	51		 push	 ecx
  011f5	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _lpCallObj$[ebp]
  011fb	52		 push	 edx
  011fc	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  011ff	50		 push	 eax
  01200	e8 00 00 00 00	 call	 ?gObjMonsterExpDivision@@YAXPAVOBJECTSTRUCT@@0HH@Z ; gObjMonsterExpDivision
  01205	83 c4 10	 add	 esp, 16			; 00000010H
$LN61@gObjLifeCh:

; 14487: 				}
; 14488: 			}
; 14489: 
; 14490: #ifdef DEVILSQUARE_EXTEND_20050221		//    
; 14491: 			if( lpTargetObj->Type == OBJTYPE_MONSTER && CHECK_DEVILSQUARE(lpTargetObj->MapNumber) )
; 14492: #else
; 14493: 			if( lpTargetObj->Type == OBJTYPE_MONSTER && lpTargetObj->MapNumber == 9 )

  01208	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0120b	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0120f	83 f9 02	 cmp	 ecx, 2
  01212	75 2c		 jne	 SHORT $LN62@gObjLifeCh
  01214	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  01217	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0121e	83 f9 09	 cmp	 ecx, 9
  01221	75 1d		 jne	 SHORT $LN62@gObjLifeCh

; 14494: #endif
; 14495: 			{
; 14496: 				g_DevilSquare.gObjMonsterScoreDivision(lpTargetObj, lpCallObj, AttackDamage, MSBFlag);

  01223	8b 45 18	 mov	 eax, DWORD PTR _MSBFlag$[ebp]
  01226	50		 push	 eax
  01227	8b 4d 10	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  0122a	51		 push	 ecx
  0122b	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _lpCallObj$[ebp]
  01231	52		 push	 edx
  01232	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  01235	50		 push	 eax
  01236	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  0123b	e8 00 00 00 00	 call	 ?gObjMonsterScoreDivision@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@0HH@Z ; CDevilSquare::gObjMonsterScoreDivision
$LN62@gObjLifeCh:

; 14497: 			}
; 14498: 		}
; 14499: 
; 14500: #ifdef MONSTER_HERD_SYSTEM_20031120
; 14501: 		if (
; 14502: 			lpTargetObj->Type == OBJTYPE_MONSTER &&

  01240	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  01243	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  01247	83 f9 02	 cmp	 ecx, 2
  0124a	75 35		 jne	 SHORT $LN64@gObjLifeCh
  0124c	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0124f	83 b8 ec 0e 00
	00 00		 cmp	 DWORD PTR [eax+3820], 0
  01256	74 29		 je	 SHORT $LN64@gObjLifeCh

; 14503: 			lpTargetObj->m_bIsInMonsterHerd
; 14504: 			) 
; 14505: 		{
; 14506: 			if (lpTargetObj->m_lpMonsterHerd != NULL)

  01258	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0125b	83 b8 f4 0e 00
	00 00		 cmp	 DWORD PTR [eax+3828], 0
  01262	74 1d		 je	 SHORT $LN64@gObjLifeCh

; 14507: 				lpTargetObj->m_lpMonsterHerd->MonsterDieAction(lpTargetObj);

  01264	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  01267	50		 push	 eax
  01268	8b 4d 08	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  0126b	8b 91 f4 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3828]
  01271	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  01274	8b 12		 mov	 edx, DWORD PTR [edx]
  01276	8b 88 f4 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3828]
  0127c	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  0127f	ff d0		 call	 eax
$LN64@gObjLifeCh:

; 14508: 		}
; 14509: #endif
; 14510: 	}

  01281	eb 6c		 jmp	 SHORT $LN69@gObjLifeCh
$LN22@gObjLifeCh:

; 14511: 	else
; 14512: 	{
; 14513: 		//       .!
; 14514: #ifdef ADD_SHIELD_POINT_01_20060403
; 14515: 		if( DamageSendType == 0 )
; 14516: 		{
; 14517: 			GCDamageSend(lpCallObj->m_Index, lpTargetObj->m_Index, AttackDamage, MSBFlag, MSBDamage, iShieldDamage);
; 14518: 		}
; 14519: 		else if( DamageSendType == 1 )
; 14520: 		{
; 14521: 			GCDamageSend(lpTargetObj->m_Index, AttackDamage, iShieldDamage);
; 14522: 		}
; 14523: #ifdef ADD_SKILL_WITH_COMBO
; 14524: 		else if( DamageSendType == 2 )
; 14525: 		{
; 14526: 			GCDamageSend(lpCallObj->m_Index, lpTargetObj->m_Index, AttackDamage, MSBFlag, DT_POISON, iShieldDamage);
; 14527: 		}
; 14528: #endif
; 14529: #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 14530: 		else if( DamageSendType == 3 )
; 14531: 		{
; 14532: 			GCDamageSend(lpCallObj->m_Index, lpTargetObj->m_Index, AttackDamage, MSBFlag, DT_SUMMONDOT, iShieldDamage);
; 14533: 		}
; 14534: #endif	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 14535: 
; 14536: #else
; 14537: 		if( DamageSendType == 0 )

  01283	83 7d 14 00	 cmp	 DWORD PTR _DamageSendType$[ebp], 0
  01287	75 25		 jne	 SHORT $LN65@gObjLifeCh

; 14538: 		{
; 14539: 			GCDamageSend(lpCallObj->m_Index, lpTargetObj->m_Index, AttackDamage, MSBFlag, MSBDamage);

  01289	8b 45 1c	 mov	 eax, DWORD PTR _MSBDamage$[ebp]
  0128c	50		 push	 eax
  0128d	8b 4d 18	 mov	 ecx, DWORD PTR _MSBFlag$[ebp]
  01290	51		 push	 ecx
  01291	8b 55 10	 mov	 edx, DWORD PTR _AttackDamage$[ebp]
  01294	52		 push	 edx
  01295	8b 45 08	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  01298	8b 08		 mov	 ecx, DWORD PTR [eax]
  0129a	51		 push	 ecx
  0129b	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _lpCallObj$[ebp]
  012a1	8b 02		 mov	 eax, DWORD PTR [edx]
  012a3	50		 push	 eax
  012a4	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHHH@Z ; GCDamageSend
  012a9	83 c4 14	 add	 esp, 20			; 00000014H

; 14540: 		}

  012ac	eb 41		 jmp	 SHORT $LN69@gObjLifeCh
$LN65@gObjLifeCh:

; 14541: 		else if( DamageSendType == 1 )

  012ae	83 7d 14 01	 cmp	 DWORD PTR _DamageSendType$[ebp], 1
  012b2	75 14		 jne	 SHORT $LN67@gObjLifeCh

; 14542: 		{
; 14543: 			GCDamageSend(lpTargetObj->m_Index, AttackDamage);

  012b4	8b 45 10	 mov	 eax, DWORD PTR _AttackDamage$[ebp]
  012b7	50		 push	 eax
  012b8	8b 4d 08	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  012bb	8b 11		 mov	 edx, DWORD PTR [ecx]
  012bd	52		 push	 edx
  012be	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHH@Z	; GCDamageSend
  012c3	83 c4 08	 add	 esp, 8

; 14544: 		}

  012c6	eb 27		 jmp	 SHORT $LN69@gObjLifeCh
$LN67@gObjLifeCh:

; 14545: #ifdef ADD_SKILL_WITH_COMBO
; 14546: 		else if( DamageSendType == 2 )

  012c8	83 7d 14 02	 cmp	 DWORD PTR _DamageSendType$[ebp], 2
  012cc	75 21		 jne	 SHORT $LN69@gObjLifeCh

; 14547: 		{
; 14548: 			GCDamageSend(lpCallObj->m_Index, lpTargetObj->m_Index, AttackDamage, MSBFlag, DT_POISON);

  012ce	6a 05		 push	 5
  012d0	8b 45 18	 mov	 eax, DWORD PTR _MSBFlag$[ebp]
  012d3	50		 push	 eax
  012d4	8b 4d 10	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  012d7	51		 push	 ecx
  012d8	8b 55 08	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  012db	8b 02		 mov	 eax, DWORD PTR [edx]
  012dd	50		 push	 eax
  012de	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _lpCallObj$[ebp]
  012e4	8b 11		 mov	 edx, DWORD PTR [ecx]
  012e6	52		 push	 edx
  012e7	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHHH@Z ; GCDamageSend
  012ec	83 c4 14	 add	 esp, 20			; 00000014H
$LN69@gObjLifeCh:
$LN1@gObjLifeCh:

; 14549: 		}
; 14550: #endif
; 14551: #endif
; 14552: 
; 14553: 	}	
; 14554: }

  012ef	5f		 pop	 edi
  012f0	5e		 pop	 esi
  012f1	5b		 pop	 ebx
  012f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012f5	33 cd		 xor	 ecx, ebp
  012f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012fc	8b e5		 mov	 esp, ebp
  012fe	5d		 pop	 ebp
  012ff	c3		 ret	 0
?gObjLifeCheck@@YAXPAVOBJECTSTRUCT@@0HHHHE@Z ENDP	; gObjLifeCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjAttackQ@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv136 = -72						; size = 4
tv79 = -72						; size = 4
tv70 = -72						; size = 4
tv137 = -68						; size = 4
tv80 = -68						; size = 4
tv71 = -68						; size = 4
_lpObj$ = 8						; size = 4
?gObjAttackQ@@YAHPAVOBJECTSTRUCT@@@Z PROC		; gObjAttackQ, COMDAT

; 8693 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 8694 : #ifdef ADD_NEW_MAP_KALIMA_20040518		//   .
; 8695 : 	if (CHECK_KALIMAGATE (lpObj->m_Attribute)) 

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f bf 88 fe 02
	00 00		 movsx	 ecx, WORD PTR [eax+766]
  00013	83 f9 33	 cmp	 ecx, 51			; 00000033H
  00016	7d 09		 jge	 SHORT $LN13@gObjAttack
  00018	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  0001f	eb 25		 jmp	 SHORT $LN14@gObjAttack
$LN13@gObjAttack:
  00021	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00024	0f bf 82 fe 02
	00 00		 movsx	 eax, WORD PTR [edx+766]
  0002b	83 f8 38	 cmp	 eax, 56			; 00000038H
  0002e	7e 09		 jle	 SHORT $LN11@gObjAttack
  00030	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00037	eb 07		 jmp	 SHORT $LN12@gObjAttack
$LN11@gObjAttack:
  00039	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
$LN12@gObjAttack:
  00040	8b 4d b8	 mov	 ecx, DWORD PTR tv70[ebp]
  00043	89 4d bc	 mov	 DWORD PTR tv71[ebp], ecx
$LN14@gObjAttack:
  00046	83 7d bc 00	 cmp	 DWORD PTR tv71[ebp], 0
  0004a	74 07		 je	 SHORT $LN2@gObjAttack

; 8696 : 	{
; 8697 : 		return FALSE;

  0004c	33 c0		 xor	 eax, eax
  0004e	e9 7a 01 00 00	 jmp	 $LN1@gObjAttack
$LN2@gObjAttack:

; 8698 : 	}
; 8699 : #endif
; 8700 : 
; 8701 : #ifdef ADD_NEW_WEAPON_FOR_CASTLE_01_20041116 //     .
; 8702 : 	if( lpObj->Class == NPC_SIEGE_MACHINE_ATTACK || lpObj->Class == NPC_SIEGE_MACHINE_DEFENSE )
; 8703 : 		return FALSE;
; 8704 : #endif
; 8705 : 
; 8706 : #ifdef CASTLE_MAIN_SCHEDULER_20041111		//  NPC  
; 8707 : 	if (((lpObj->Class == 277) || (lpObj->Class == 283)) &&
; 8708 : 		g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_STARTSIEGE)
; 8709 : 	{
; 8710 : 		//      .
; 8711 : 		return FALSE;
; 8712 : 	}
; 8713 : 
; 8714 : 	if ((lpObj->Class == 221)			// 
; 8715 : 		|| (lpObj->Class == 222)		// 
; 8716 : //		|| (lpObj->Class == 288)		// 
; 8717 : 		)
; 8718 : 	{
; 8719 : 		//    .
; 8720 : 		return FALSE;
; 8721 : 	}
; 8722 : 
; 8723 : 	if (lpObj->Class == 277 &&
; 8724 : 		lpObj->m_btCsGateOpen == CS_GATE_STATE_OPENED
; 8725 : 		)
; 8726 : 	{
; 8727 : 		//     .
; 8728 : 		return FALSE;
; 8729 : 	}
; 8730 : #endif
; 8731 : 	
; 8732 : #ifdef FOR_BLOODCASTLE
; 8733 : 	if( CHECK_BLOODCASTLE(lpObj->MapNumber) && lpObj->Type >= OBJTYPE_MONSTER ) {

  00053	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00056	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0005d	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00060	7d 09		 jge	 SHORT $LN17@gObjAttack
  00062	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  00069	eb 25		 jmp	 SHORT $LN18@gObjAttack
$LN17@gObjAttack:
  0006b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0006e	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00075	83 f8 11	 cmp	 eax, 17			; 00000011H
  00078	7e 09		 jle	 SHORT $LN15@gObjAttack
  0007a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  00081	eb 07		 jmp	 SHORT $LN16@gObjAttack
$LN15@gObjAttack:
  00083	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
$LN16@gObjAttack:
  0008a	8b 4d b8	 mov	 ecx, DWORD PTR tv79[ebp]
  0008d	89 4d bc	 mov	 DWORD PTR tv80[ebp], ecx
$LN18@gObjAttack:
  00090	83 7d bc 00	 cmp	 DWORD PTR tv80[ebp], 0
  00094	0f 84 b6 00 00
	00		 je	 $LN3@gObjAttack
  0009a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009d	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  000a1	83 f9 02	 cmp	 ecx, 2
  000a4	0f 8c a6 00 00
	00		 jl	 $LN3@gObjAttack

; 8734 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010		//    
; 8735 : 		int iBridgeIndex = g_BloodCastle.GetBridgeIndexByMapNum( lpObj->MapNumber );
; 8736 : 		//       .
; 8737 : 		if ( (lpObj->Class == 131) && (!g_BloodCastle.CheckMonsterKillSuccess(iBridgeIndex)) ) 
; 8738 : 			return FALSE;	
; 8739 : 
; 8740 : 		//        .
; 8741 : 		if ( CHECK_LIMIT(lpObj->Class-BC_SAINT_STATUE_1, 3) && (!g_BloodCastle.CheckBossKillSuccess(iBridgeIndex)) ) 
; 8742 : 			return FALSE;
; 8743 : #else
; 8744 : 		//       .
; 8745 : 		if ( (lpObj->Class == 131) && (!g_BloodCastle.CheckMonsterKillSuccess(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1)) ) 

  000aa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ad	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000b4	81 f9 83 00 00
	00		 cmp	 ecx, 131		; 00000083H
  000ba	75 26		 jne	 SHORT $LN4@gObjAttack
  000bc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bf	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000c6	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  000c9	51		 push	 ecx
  000ca	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  000cf	e8 00 00 00 00	 call	 ?CheckMonsterKillSuccess@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckMonsterKillSuccess
  000d4	0f b6 d0	 movzx	 edx, al
  000d7	85 d2		 test	 edx, edx
  000d9	75 07		 jne	 SHORT $LN4@gObjAttack

; 8746 : 			return FALSE;	

  000db	33 c0		 xor	 eax, eax
  000dd	e9 eb 00 00 00	 jmp	 $LN1@gObjAttack
$LN4@gObjAttack:

; 8747 : 
; 8748 : 		//        .
; 8749 : 		if ( CHECK_LIMIT(lpObj->Class-BC_SAINT_STATUE_1, 3) && (!g_BloodCastle.CheckBossKillSuccess(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1)) ) 

  000e2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e5	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000ec	81 e9 84 00 00
	00		 sub	 ecx, 132		; 00000084H
  000f2	79 09		 jns	 SHORT $LN21@gObjAttack
  000f4	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv137[ebp], 0
  000fb	eb 2a		 jmp	 SHORT $LN22@gObjAttack
$LN21@gObjAttack:
  000fd	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00100	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  00107	2d 84 00 00 00	 sub	 eax, 132		; 00000084H
  0010c	83 f8 02	 cmp	 eax, 2
  0010f	7e 09		 jle	 SHORT $LN19@gObjAttack
  00111	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv136[ebp], 0
  00118	eb 07		 jmp	 SHORT $LN20@gObjAttack
$LN19@gObjAttack:
  0011a	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv136[ebp], 1
$LN20@gObjAttack:
  00121	8b 4d b8	 mov	 ecx, DWORD PTR tv136[ebp]
  00124	89 4d bc	 mov	 DWORD PTR tv137[ebp], ecx
$LN22@gObjAttack:
  00127	83 7d bc 00	 cmp	 DWORD PTR tv137[ebp], 0
  0012b	74 23		 je	 SHORT $LN3@gObjAttack
  0012d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00130	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00137	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  0013a	51		 push	 ecx
  0013b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00140	e8 00 00 00 00	 call	 ?CheckBossKillSuccess@CBloodCastle@@QAE_NH@Z ; CBloodCastle::CheckBossKillSuccess
  00145	0f b6 d0	 movzx	 edx, al
  00148	85 d2		 test	 edx, edx
  0014a	75 04		 jne	 SHORT $LN3@gObjAttack

; 8750 : 			return FALSE;

  0014c	33 c0		 xor	 eax, eax
  0014e	eb 7d		 jmp	 SHORT $LN1@gObjAttack
$LN3@gObjAttack:

; 8751 : #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 8752 : 	}
; 8753 : 
; 8754 : 
; 8755 : 	if( lpObj->Class != 247 &&  lpObj->Class != 249 && (lpObj->Class >= 100 && lpObj->Class<= 110 ) ) return FALSE;	//100   NPC .

  00150	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00153	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0015a	81 f9 f7 00 00
	00		 cmp	 ecx, 247		; 000000f7H
  00160	74 34		 je	 SHORT $LN6@gObjAttack
  00162	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00165	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0016c	81 f9 f9 00 00
	00		 cmp	 ecx, 249		; 000000f9H
  00172	74 22		 je	 SHORT $LN6@gObjAttack
  00174	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00177	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0017e	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00181	7c 13		 jl	 SHORT $LN6@gObjAttack
  00183	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00186	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0018d	83 f9 6e	 cmp	 ecx, 110		; 0000006eH
  00190	7f 04		 jg	 SHORT $LN6@gObjAttack
  00192	33 c0		 xor	 eax, eax
  00194	eb 37		 jmp	 SHORT $LN1@gObjAttack
$LN6@gObjAttack:

; 8756 : 
; 8757 : 	
; 8758 : #else
; 8759 : 	if( lpObj->Class != 247 &&  lpObj->Class != 249 && (lpObj->Class >= 100 && lpObj->Class< 150 ) ) return FALSE;	//100   NPC .
; 8760 : #endif
; 8761 : 	if( lpObj->m_State != OBJST_PLAYING ) return FALSE;

  00196	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00199	83 b8 b8 01 00
	00 02		 cmp	 DWORD PTR [eax+440], 2
  001a0	74 04		 je	 SHORT $LN7@gObjAttack
  001a2	33 c0		 xor	 eax, eax
  001a4	eb 27		 jmp	 SHORT $LN1@gObjAttack
$LN7@gObjAttack:

; 8762 : 	if( lpObj->Live == 0 ) return FALSE;

  001a6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a9	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  001ad	85 c9		 test	 ecx, ecx
  001af	75 04		 jne	 SHORT $LN8@gObjAttack
  001b1	33 c0		 xor	 eax, eax
  001b3	eb 18		 jmp	 SHORT $LN1@gObjAttack
$LN8@gObjAttack:

; 8763 : 	if( lpObj->Teleport == 1 ) return FALSE;	//  .	

  001b5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b8	0f be 88 fc 01
	00 00		 movsx	 ecx, BYTE PTR [eax+508]
  001bf	83 f9 01	 cmp	 ecx, 1
  001c2	75 04		 jne	 SHORT $LN9@gObjAttack
  001c4	33 c0		 xor	 eax, eax
  001c6	eb 05		 jmp	 SHORT $LN1@gObjAttack
$LN9@gObjAttack:

; 8764 : 	return TRUE;

  001c8	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjAttack:

; 8765 : }

  001cd	5f		 pop	 edi
  001ce	5e		 pop	 esi
  001cf	5b		 pop	 ebx
  001d0	8b e5		 mov	 esp, ebp
  001d2	5d		 pop	 ebp
  001d3	c3		 ret	 0
?gObjAttackQ@@YAHPAVOBJECTSTRUCT@@@Z ENDP		; gObjAttackQ
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCheckSelfDefense@@YAXPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
tv66 = -160						; size = 4
tv67 = -156						; size = 4
_nPartyUser$1 = -88					; size = 4
_szTemp$ = -84						; size = 61
_blank$ = -20						; size = 4
_nSelfDefenseUser$ = -16				; size = 4
_partynum$ = -12					; size = 4
_n$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
?gObjCheckSelfDefense@@YAXPAVOBJECTSTRUCT@@H@Z PROC	; gObjCheckSelfDefense, COMDAT

; 12424: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 12425: 	if(!CHECK_LIMIT( aTargetIndex, MAX_OBJECT ) )

  00016	83 7d 0c 00	 cmp	 DWORD PTR _aTargetIndex$[ebp], 0
  0001a	7d 0c		 jge	 SHORT $LN26@gObjCheckS
  0001c	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00026	eb 2b		 jmp	 SHORT $LN27@gObjCheckS
$LN26@gObjCheckS:
  00028	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aTargetIndex$[ebp], 7399 ; 00001ce7H
  0002f	7e 0c		 jle	 SHORT $LN24@gObjCheckS
  00031	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
  0003b	eb 0a		 jmp	 SHORT $LN25@gObjCheckS
$LN24@gObjCheckS:
  0003d	c7 85 60 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
$LN25@gObjCheckS:
  00047	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  0004d	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN27@gObjCheckS:
  00053	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  0005a	75 05		 jne	 SHORT $LN11@gObjCheckS

; 12426: 	{
; 12427: 		return;

  0005c	e9 8d 02 00 00	 jmp	 $LN1@gObjCheckS
$LN11@gObjCheckS:

; 12428: 	}
; 12429: #ifdef ADD_NEWPVP_PKFIELD
; 12430: 	//   
; 12431: 	if (g_NewPVP.IsDuel(*lpObj, aTargetIndex) == TRUE)
; 12432: 		return;
; 12433: #endif // ADD_NEWPVP_PKFIELD
; 12434: 
; 12435: 	//    .
; 12436: 	if( gObj[aTargetIndex].m_PK_Level > PK_LEVEL_DEFAULT+1 )

  00061	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aTargetIndex$[ebp], 7072
  00068	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006e	0f be 94 01 fd
	00 00 00	 movsx	 edx, BYTE PTR [ecx+eax+253]
  00076	83 fa 04	 cmp	 edx, 4
  00079	7e 05		 jle	 SHORT $LN12@gObjCheckS

; 12437: 	{
; 12438: 		return;

  0007b	e9 6e 02 00 00	 jmp	 $LN1@gObjCheckS
$LN12@gObjCheckS:

; 12439: 	}	
; 12440: 	int n;
; 12441: 
; 12442: #ifdef MODIFY_PARTY_SELFDEFENSE_BUG_FIX_20071022	//         
; 12443: 	int partynum			= lpObj->PartyNumber;	//  

  00080	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00083	8b 88 88 02 00
	00		 mov	 ecx, DWORD PTR [eax+648]
  00089	89 4d f4	 mov	 DWORD PTR _partynum$[ebp], ecx

; 12444: 	int	nSelfDefenseUser	= -1;					//   

  0008c	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _nSelfDefenseUser$[ebp], -1

; 12445: 
; 12446: 	for( n=0; n<MAXSELFDEFENSE; n++)

  00093	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  0009a	eb 09		 jmp	 SHORT $LN4@gObjCheckS
$LN2@gObjCheckS:
  0009c	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0009f	83 c0 01	 add	 eax, 1
  000a2	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjCheckS:
  000a5	83 7d f8 07	 cmp	 DWORD PTR _n$[ebp], 7
  000a9	7d 79		 jge	 SHORT $LN3@gObjCheckS

; 12447: 	{
; 12448: 		//    ..  
; 12449: 		if( gObj[aTargetIndex].SelfDefense[n] >= 0)

  000ab	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aTargetIndex$[ebp], 7072
  000b2	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  000bb	83 bc 88 40 02
	00 00 00	 cmp	 DWORD PTR [eax+ecx*4+576], 0
  000c3	7c 5a		 jl	 SHORT $LN13@gObjCheckS

; 12450: 		{
; 12451: 			if( gObj[aTargetIndex].SelfDefense[n] == lpObj->m_Index ) return;		

  000c5	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aTargetIndex$[ebp], 7072
  000cc	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d2	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  000d5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000d8	8b 84 88 40 02
	00 00		 mov	 eax, DWORD PTR [eax+ecx*4+576]
  000df	3b 02		 cmp	 eax, DWORD PTR [edx]
  000e1	75 05		 jne	 SHORT $LN14@gObjCheckS
  000e3	e9 06 02 00 00	 jmp	 $LN1@gObjCheckS
$LN14@gObjCheckS:

; 12452: 
; 12453: 			//        
; 12454: 			if( partynum >= 0 
; 12455: 				&& gObj[gObj[aTargetIndex].SelfDefense[n]].PartyNumber == partynum )

  000e8	83 7d f4 00	 cmp	 DWORD PTR _partynum$[ebp], 0
  000ec	7c 31		 jl	 SHORT $LN13@gObjCheckS
  000ee	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aTargetIndex$[ebp], 7072
  000f5	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fb	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  000fe	69 94 88 40 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [eax+ecx*4+576], 7072
  00109	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010e	8b 8c 10 88 02
	00 00		 mov	 ecx, DWORD PTR [eax+edx+648]
  00115	3b 4d f4	 cmp	 ecx, DWORD PTR _partynum$[ebp]
  00118	75 05		 jne	 SHORT $LN13@gObjCheckS

; 12456: 			{
; 12457: 				return;

  0011a	e9 cf 01 00 00	 jmp	 $LN1@gObjCheckS
$LN13@gObjCheckS:

; 12458: 			}	
; 12459: 		}
; 12460: 	}

  0011f	e9 78 ff ff ff	 jmp	 $LN2@gObjCheckS
$LN3@gObjCheckS:

; 12461: 
; 12462: #else	// MODIFY_PARTY_SELFDEFENSE_BUG_FIX_20071022
; 12463: 
; 12464: 	for( n=0; n<MAXSELFDEFENSE; n++)
; 12465: 	{
; 12466: 		//    ..  
; 12467: 		if( gObj[aTargetIndex].SelfDefense[n] >= 0)
; 12468: 		{
; 12469: 			if( gObj[aTargetIndex].SelfDefense[n] == lpObj->m_Index ) return;		
; 12470: 		}
; 12471: 
; 12472: 	}
; 12473: #endif	// MODIFY_PARTY_SELFDEFENSE_BUG_FIX_20071022
; 12474: 
; 12475: 	int blank=-1;

  00124	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _blank$[ebp], -1

; 12476: 
; 12477: 	//     ..    .
; 12478: 	for( n=0; n<MAXSELFDEFENSE; n++)

  0012b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00132	eb 09		 jmp	 SHORT $LN7@gObjCheckS
$LN5@gObjCheckS:
  00134	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00137	83 c0 01	 add	 eax, 1
  0013a	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN7@gObjCheckS:
  0013d	83 7d f8 07	 cmp	 DWORD PTR _n$[ebp], 7
  00141	7d 49		 jge	 SHORT $LN6@gObjCheckS

; 12479: 	{
; 12480: 		if( lpObj->SelfDefense[n] >= 0 )

  00143	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00146	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00149	83 bc 81 40 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax*4+576], 0
  00151	7c 31		 jl	 SHORT $LN16@gObjCheckS

; 12481: 		{
; 12482: 			if( lpObj->SelfDefense[n] == aTargetIndex )

  00153	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00156	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00159	8b 94 81 40 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+576]
  00160	3b 55 0c	 cmp	 edx, DWORD PTR _aTargetIndex$[ebp]
  00163	75 1d		 jne	 SHORT $LN18@gObjCheckS

; 12483: 			{
; 12484: #ifdef MODIFY_SELFDEFENSETIME_MAXSELFDEFIENSE_20071221	//   60
; 12485: 				lpObj->SelfDefenseTime[n]	= GetTickCount()+(1000*60);

  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0016b	05 60 ea 00 00	 add	 eax, 60000		; 0000ea60H
  00170	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00173	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00176	89 84 8a 5c 02
	00 00		 mov	 DWORD PTR [edx+ecx*4+604], eax

; 12486: #else	// MODIFY_SELFDEFENSETIME_MAXSELFDEFIENSE_20071221					
; 12487: #ifdef UPDATE_PK_SYSTEM_20070302	//   
; 12488: 				lpObj->SelfDefenseTime[n]	= GetTickCount()+(1000*90);
; 12489: #else
; 12490: 				lpObj->SelfDefenseTime[n]	= GetTickCount()+(1000*30);
; 12491: #endif
; 12492: #endif	// MODIFY_SELFDEFENSETIME_MAXSELFDEFIENSE_20071221
; 12493: 				return;

  0017d	e9 6c 01 00 00	 jmp	 $LN1@gObjCheckS
$LN18@gObjCheckS:

; 12494: 			}
; 12495: 		}

  00182	eb 06		 jmp	 SHORT $LN17@gObjCheckS
$LN16@gObjCheckS:

; 12496: 		else blank = n;

  00184	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00187	89 45 ec	 mov	 DWORD PTR _blank$[ebp], eax
$LN17@gObjCheckS:

; 12497: 	}

  0018a	eb a8		 jmp	 SHORT $LN5@gObjCheckS
$LN6@gObjCheckS:

; 12498: 	if( blank < 0 ) {

  0018c	83 7d ec 00	 cmp	 DWORD PTR _blank$[ebp], 0
  00190	7d 1f		 jge	 SHORT $LN19@gObjCheckS

; 12499: 		LogAdd(lMsg.Get(523));

  00192	68 0b 02 00 00	 push	 523			; 0000020bH
  00197	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001a2	50		 push	 eax
  001a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001a9	83 c4 04	 add	 esp, 4

; 12500: 		return;

  001ac	e9 3d 01 00 00	 jmp	 $LN1@gObjCheckS
$LN19@gObjCheckS:

; 12501: 	}
; 12502: 	lpObj->MySelfDefenseTime = GetTickCount();

  001b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001b7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001ba	89 81 78 02 00
	00		 mov	 DWORD PTR [ecx+632], eax

; 12503: 
; 12504: 	//
; 12505: 	lpObj->SelfDefense[blank]	  = aTargetIndex;

  001c0	8b 45 ec	 mov	 eax, DWORD PTR _blank$[ebp]
  001c3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001c6	8b 55 0c	 mov	 edx, DWORD PTR _aTargetIndex$[ebp]
  001c9	89 94 81 40 02
	00 00		 mov	 DWORD PTR [ecx+eax*4+576], edx

; 12506: #ifdef MODIFY_SELFDEFENSETIME_MAXSELFDEFIENSE_20071221	//   60
; 12507: 	lpObj->SelfDefenseTime[blank] = GetTickCount()+(1000*60);

  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001d6	05 60 ea 00 00	 add	 eax, 60000		; 0000ea60H
  001db	8b 4d ec	 mov	 ecx, DWORD PTR _blank$[ebp]
  001de	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001e1	89 84 8a 5c 02
	00 00		 mov	 DWORD PTR [edx+ecx*4+604], eax

; 12508: #else	// MODIFY_SELFDEFENSETIME_MAXSELFDEFIENSE_20071221	
; 12509: #ifdef UPDATE_PK_SYSTEM_20070302	//   
; 12510: 	lpObj->SelfDefenseTime[blank] = GetTickCount()+(1000*90);
; 12511: #else
; 12512: 	lpObj->SelfDefenseTime[blank] = GetTickCount()+(1000*30);
; 12513: #endif
; 12514: #endif	// MODIFY_SELFDEFENSETIME_MAXSELFDEFIENSE_20071221
; 12515: 
; 12516: 	char szTemp[MAX_CHAT+1];
; 12517: 
; 12518: #ifdef MODIFY_PARTY_SELFDEFENSE_BUG_FIX_20071022	//       .
; 12519: 	wsprintf(szTemp, lMsg.Get(1114), lpObj->Name, gObj[aTargetIndex].Name);

  001e8	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aTargetIndex$[ebp], 7072
  001ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f5	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  001f9	52		 push	 edx
  001fa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001fd	83 c0 73	 add	 eax, 115		; 00000073H
  00200	50		 push	 eax
  00201	68 5a 04 00 00	 push	 1114			; 0000045aH
  00206	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0020b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00211	50		 push	 eax
  00212	8d 4d ac	 lea	 ecx, DWORD PTR _szTemp$[ebp]
  00215	51		 push	 ecx
  00216	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0021c	83 c4 10	 add	 esp, 16			; 00000010H

; 12520: 	partynum = gObj[aTargetIndex].PartyNumber;

  0021f	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aTargetIndex$[ebp], 7072
  00226	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0022c	8b 94 01 88 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+648]
  00233	89 55 f4	 mov	 DWORD PTR _partynum$[ebp], edx

; 12521: 	if(partynum >= 0 )

  00236	83 7d f4 00	 cmp	 DWORD PTR _partynum$[ebp], 0
  0023a	7c 4c		 jl	 SHORT $LN20@gObjCheckS

; 12522: 	{
; 12523: 		int nPartyUser = -1;

  0023c	c7 45 a8 ff ff
	ff ff		 mov	 DWORD PTR _nPartyUser$1[ebp], -1

; 12524: 		for( n = 0; n < MAX_PARTYUSER; n++)

  00243	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  0024a	eb 09		 jmp	 SHORT $LN10@gObjCheckS
$LN8@gObjCheckS:
  0024c	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0024f	83 c0 01	 add	 eax, 1
  00252	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN10@gObjCheckS:
  00255	83 7d f8 05	 cmp	 DWORD PTR _n$[ebp], 5
  00259	7d 2b		 jge	 SHORT $LN9@gObjCheckS

; 12525: 		{
; 12526: 			nPartyUser = gParty.m_PartyS[partynum].Number[n];

  0025b	6b 45 f4 30	 imul	 eax, DWORD PTR _partynum$[ebp], 48
  0025f	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00262	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  00269	89 55 a8	 mov	 DWORD PTR _nPartyUser$1[ebp], edx

; 12527: 			if ( nPartyUser >= 0)

  0026c	83 7d a8 00	 cmp	 DWORD PTR _nPartyUser$1[ebp], 0
  00270	7c 12		 jl	 SHORT $LN22@gObjCheckS

; 12528: 			{
; 12529: 				GCServerMsgStringSend(szTemp, nPartyUser, 1);

  00272	6a 01		 push	 1
  00274	8b 45 a8	 mov	 eax, DWORD PTR _nPartyUser$1[ebp]
  00277	50		 push	 eax
  00278	8d 4d ac	 lea	 ecx, DWORD PTR _szTemp$[ebp]
  0027b	51		 push	 ecx
  0027c	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00281	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@gObjCheckS:

; 12530: 			}
; 12531: 		}

  00284	eb c6		 jmp	 SHORT $LN8@gObjCheckS
$LN9@gObjCheckS:

; 12532: 	}

  00286	eb 12		 jmp	 SHORT $LN21@gObjCheckS
$LN20@gObjCheckS:

; 12533: 	else
; 12534: 	{
; 12535: 		GCServerMsgStringSend(szTemp, aTargetIndex, 1);

  00288	6a 01		 push	 1
  0028a	8b 45 0c	 mov	 eax, DWORD PTR _aTargetIndex$[ebp]
  0028d	50		 push	 eax
  0028e	8d 4d ac	 lea	 ecx, DWORD PTR _szTemp$[ebp]
  00291	51		 push	 ecx
  00292	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00297	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@gObjCheckS:

; 12536: 	}
; 12537: 	
; 12538: 	GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  0029a	6a 01		 push	 1
  0029c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0029f	8b 08		 mov	 ecx, DWORD PTR [eax]
  002a1	51		 push	 ecx
  002a2	8d 55 ac	 lea	 edx, DWORD PTR _szTemp$[ebp]
  002a5	52		 push	 edx
  002a6	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  002ab	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12539: 
; 12540: #else	// MODIFY_PARTY_SELFDEFENSE_BUG_FIX_20071022
; 12541: 
; 12542: 	wsprintf(szTemp, lMsg.Get(1114), lpObj->Name, gObj[aTargetIndex].Name);
; 12543: 	GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);
; 12544: 	GCServerMsgStringSend(szTemp, aTargetIndex, 1);
; 12545: #endif	// MODIFY_PARTY_SELFDEFENSE_BUG_FIX_20071022
; 12546: 
; 12547: 	LogAddTD("[%s][%s] Set SelfDefence [%s][%s]", 

  002ae	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aTargetIndex$[ebp], 7072
  002b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002bb	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  002bf	52		 push	 edx
  002c0	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aTargetIndex$[ebp], 7072
  002c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002cd	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  002d1	52		 push	 edx
  002d2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d5	83 c0 73	 add	 eax, 115		; 00000073H
  002d8	50		 push	 eax
  002d9	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002dc	83 c1 68	 add	 ecx, 104		; 00000068H
  002df	51		 push	 ecx
  002e0	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@IPHFNLBG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Set?5SelfDefence?5?$FL?$CFs?$FN?$FL?$CF@
  002e5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002eb	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@gObjCheckS:

; 12548: 			 lpObj->AccountID, lpObj->Name, 
; 12549: 			 gObj[aTargetIndex].AccountID, gObj[aTargetIndex].Name);
; 12550: }

  002ee	5f		 pop	 edi
  002ef	5e		 pop	 esi
  002f0	5b		 pop	 ebx
  002f1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f4	33 cd		 xor	 ecx, ebp
  002f6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002fb	8b e5		 mov	 esp, ebp
  002fd	5d		 pop	 ebp
  002fe	c3		 ret	 0
?gObjCheckSelfDefense@@YAXPAVOBJECTSTRUCT@@H@Z ENDP	; gObjCheckSelfDefense
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjTargetGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjTargetGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z PROC	; gObjTargetGuildWarCheck, COMDAT

; 28931: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 28932: 	if( lpObj->Type       != OBJTYPE_CHARACTER )					return FALSE;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00010	83 f9 01	 cmp	 ecx, 1
  00013	74 07		 je	 SHORT $LN2@gObjTarget
  00015	33 c0		 xor	 eax, eax
  00017	e9 8b 00 00 00	 jmp	 $LN1@gObjTarget
$LN2@gObjTarget:

; 28933: 	if( lpTargetObj->Type != OBJTYPE_CHARACTER )					return FALSE;

  0001c	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0001f	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00023	83 f9 01	 cmp	 ecx, 1
  00026	74 04		 je	 SHORT $LN3@gObjTarget
  00028	33 c0		 xor	 eax, eax
  0002a	eb 7b		 jmp	 SHORT $LN1@gObjTarget
$LN3@gObjTarget:

; 28934: 	if( lpObj->GuildNumber < 1 || lpTargetObj->GuildNumber < 1 )	return FALSE;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002f	83 b8 90 02 00
	00 01		 cmp	 DWORD PTR [eax+656], 1
  00036	7c 0c		 jl	 SHORT $LN5@gObjTarget
  00038	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0003b	83 b8 90 02 00
	00 01		 cmp	 DWORD PTR [eax+656], 1
  00042	7d 04		 jge	 SHORT $LN4@gObjTarget
$LN5@gObjTarget:
  00044	33 c0		 xor	 eax, eax
  00046	eb 5f		 jmp	 SHORT $LN1@gObjTarget
$LN4@gObjTarget:

; 28935: 	
; 28936: 	if( lpObj->lpGuild->WarState != 1 || lpTargetObj->lpGuild->WarState != 1 )		return FALSE;

  00048	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004b	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00051	0f b6 91 91 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1425]
  00058	83 fa 01	 cmp	 edx, 1
  0005b	75 15		 jne	 SHORT $LN7@gObjTarget
  0005d	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00060	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00066	0f b6 91 91 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1425]
  0006d	83 fa 01	 cmp	 edx, 1
  00070	74 04		 je	 SHORT $LN6@gObjTarget
$LN7@gObjTarget:
  00072	33 c0		 xor	 eax, eax
  00074	eb 31		 jmp	 SHORT $LN1@gObjTarget
$LN6@gObjTarget:

; 28937: 	if( strcmp(lpObj->lpGuild->TargetGuildName, lpTargetObj->lpGuild->Name) != 0 )	return FALSE;

  00076	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00079	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  0007f	83 c1 04	 add	 ecx, 4
  00082	51		 push	 ecx
  00083	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00086	8b 82 94 02 00
	00		 mov	 eax, DWORD PTR [edx+660]
  0008c	05 e0 04 00 00	 add	 eax, 1248		; 000004e0H
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 _strcmp
  00097	83 c4 08	 add	 esp, 8
  0009a	85 c0		 test	 eax, eax
  0009c	74 04		 je	 SHORT $LN8@gObjTarget
  0009e	33 c0		 xor	 eax, eax
  000a0	eb 05		 jmp	 SHORT $LN1@gObjTarget
$LN8@gObjTarget:

; 28938: 
; 28939: 	return TRUE;

  000a2	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjTarget:

; 28940: }

  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
?gObjTargetGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z ENDP	; gObjTargetGuildWarCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjArmorRandomDurDown@@YAXPAVOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_ret$ = -48						; size = 4
_damagemin$ = -44					; size = 4
_DurItem$ = -40						; size = 4
_item_pos$ = -36					; size = 4
_item_num$ = -32					; size = 28
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpAttackObj$ = 12					; size = 4
?gObjArmorRandomDurDown@@YAXPAVOBJECTSTRUCT@@0@Z PROC	; gObjArmorRandomDurDown, COMDAT

; 12324: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 12325: #ifdef DURABILITY_DOWN_CHANGE	//    ( , )
; 12326: 	return;
; 12327: #endif
; 12328: 	int item_num[7] = {EQUIPMENT_WEAPON_RIGHT, EQUIPMENT_WEAPON_LEFT, EQUIPMENT_HELM, EQUIPMENT_ARMOR,EQUIPMENT_PANTS, EQUIPMENT_GLOVES, EQUIPMENT_BOOTS};

  00013	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _item_num$[ebp], 0
  0001a	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+4], 1
  00021	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+8], 2
  00028	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+12], 3
  0002f	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+16], 4
  00036	c7 45 f4 05 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+20], 5
  0003d	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+24], 6

; 12329: 	int item_pos = rand()%7;

  00044	e8 00 00 00 00	 call	 _rand
  00049	99		 cdq
  0004a	b9 07 00 00 00	 mov	 ecx, 7
  0004f	f7 f9		 idiv	 ecx
  00051	89 55 dc	 mov	 DWORD PTR _item_pos$[ebp], edx

; 12330: 
; 12331: 	if( lpObj->Type != OBJTYPE_CHARACTER ) return;

  00054	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00057	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0005b	83 f9 01	 cmp	 ecx, 1
  0005e	74 05		 je	 SHORT $LN2@gObjArmorR
  00060	e9 27 01 00 00	 jmp	 $LN1@gObjArmorR
$LN2@gObjArmorR:

; 12332: 
; 12333: 	CItem	*DurItem = &lpObj->pInventory[item_num[item_pos]];

  00065	8b 45 dc	 mov	 eax, DWORD PTR _item_pos$[ebp]
  00068	69 4c 85 e0 a8
	00 00 00	 imul	 ecx, DWORD PTR _item_num$[ebp+eax*4], 168
  00070	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00073	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00079	89 4d d8	 mov	 DWORD PTR _DurItem$[ebp], ecx

; 12334: 
; 12335: 	int damagemin = lpAttackObj->m_AttackDamageMin;

  0007c	8b 45 0c	 mov	 eax, DWORD PTR _lpAttackObj$[ebp]
  0007f	8b 88 b4 02 00
	00		 mov	 ecx, DWORD PTR [eax+692]
  00085	89 4d d4	 mov	 DWORD PTR _damagemin$[ebp], ecx

; 12336: 	int ret;
; 12337: 
; 12338: #ifdef ADD_PARTIALY_CHARGE_SYSTEM_06_20090129
; 12339: 	
; 12340: 	short nType = DurItem->m_Type;
; 12341: 	
; 12342: 	if(gObjCheckUsedBuffEffect(lpObj, BUFFTYPE_CHARM_PROTECTITEM) ) {
; 12343: 		//     ..   
; 12344: 		
; 12345: 		if(nType >= ITEM_SWORD && nType < ITEM_WING) {
; 12346: 			//  &  
; 12347: 			return;
; 12348: 		} else if(nType >= ITEM_WING && nType < ITEM_HELPER) {
; 12349: 			//  
; 12350: 			if( (MAKE_ITEMNUM_INDEX(nType) >= 0 && MAKE_ITEMNUM_INDEX(nType) <= 16) 
; 12351: 				|| (MAKE_ITEMNUM_INDEX(nType) >= 36 && MAKE_ITEMNUM_INDEX(nType) <= 43) ) {
; 12352: 				//  INDEX ..
; 12353: 				return;
; 12354: 			} else {
; 12355: 				//      
; 12356: 			}
; 12357: 		} else {
; 12358: 			//      
; 12359: 		}
; 12360: 	}
; 12361: #endif //ADD_PARTIALY_CHARGE_SYSTEM_06_20090129
; 12362: 
; 12363: 	//     .
; 12364: 	if( item_pos < 2 )

  00088	83 7d dc 02	 cmp	 DWORD PTR _item_pos$[ebp], 2
  0008c	7d 7c		 jge	 SHORT $LN3@gObjArmorR

; 12365: 	{
; 12366: 		if( (DurItem->m_Type >= ITEM_SHIELD && DurItem->m_Type < ITEM_HELM) )

  0008e	8b 45 d8	 mov	 eax, DWORD PTR _DurItem$[ebp]
  00091	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00095	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  0009b	7c 68		 jl	 SHORT $LN5@gObjArmorR
  0009d	8b 45 d8	 mov	 eax, DWORD PTR _DurItem$[ebp]
  000a0	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  000a4	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  000aa	7d 59		 jge	 SHORT $LN5@gObjArmorR

; 12367: 		{
; 12368: 			//      .			
; 12369: 			ret = DurItem->ArmorDurabilityDown(damagemin, lpObj->m_Index);

  000ac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000af	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b1	51		 push	 ecx
  000b2	8b 55 d4	 mov	 edx, DWORD PTR _damagemin$[ebp]
  000b5	52		 push	 edx
  000b6	8b 4d d8	 mov	 ecx, DWORD PTR _DurItem$[ebp]
  000b9	e8 00 00 00 00	 call	 ?ArmorDurabilityDown@CItem@@QAEHHH@Z ; CItem::ArmorDurabilityDown
  000be	89 45 d0	 mov	 DWORD PTR _ret$[ebp], eax

; 12370: 			if( ret )

  000c1	83 7d d0 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000c5	74 39		 je	 SHORT $LN7@gObjArmorR

; 12371: 			{	//    
; 12372: 				GCItemDurSend(lpObj->m_Index, item_num[item_pos], DurItem->m_Durability, 0);

  000c7	6a 00		 push	 0
  000c9	8b 45 d8	 mov	 eax, DWORD PTR _DurItem$[ebp]
  000cc	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  000d1	0f b6 d1	 movzx	 edx, cl
  000d4	52		 push	 edx
  000d5	8b 45 dc	 mov	 eax, DWORD PTR _item_pos$[ebp]
  000d8	0f b6 4c 85 e0	 movzx	 ecx, BYTE PTR _item_num$[ebp+eax*4]
  000dd	51		 push	 ecx
  000de	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e1	8b 02		 mov	 eax, DWORD PTR [edx]
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  000e9	83 c4 10	 add	 esp, 16			; 00000010H

; 12373: 				if( ret == 2 )

  000ec	83 7d d0 02	 cmp	 DWORD PTR _ret$[ebp], 2
  000f0	75 0e		 jne	 SHORT $LN7@gObjArmorR

; 12374: 				{	//    
; 12375: 					gObjCalCharacter(lpObj->m_Index);

  000f2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f7	51		 push	 ecx
  000f8	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  000fd	83 c4 04	 add	 esp, 4
$LN7@gObjArmorR:

; 12376: 				}
; 12377: 			}
; 12378: 			return;

  00100	e9 87 00 00 00	 jmp	 $LN1@gObjArmorR
$LN5@gObjArmorR:

; 12379: 		}		
; 12380: 	}

  00105	e9 82 00 00 00	 jmp	 $LN10@gObjArmorR
$LN3@gObjArmorR:

; 12381: 	else
; 12382: 	{
; 12383: 		if( DurItem->m_Type != MAKE_ITEMNUM(4,7) && DurItem->m_Type != MAKE_ITEMNUM(4,15) )

  0010a	8b 45 d8	 mov	 eax, DWORD PTR _DurItem$[ebp]
  0010d	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00111	6a 07		 push	 7
  00113	6a 04		 push	 4
  00115	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0011a	83 c4 08	 add	 esp, 8
  0011d	3b f0		 cmp	 esi, eax
  0011f	74 6b		 je	 SHORT $LN10@gObjArmorR
  00121	8b 45 d8	 mov	 eax, DWORD PTR _DurItem$[ebp]
  00124	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00128	6a 0f		 push	 15			; 0000000fH
  0012a	6a 04		 push	 4
  0012c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00131	83 c4 08	 add	 esp, 8
  00134	3b f0		 cmp	 esi, eax
  00136	74 54		 je	 SHORT $LN10@gObjArmorR

; 12384: 		{
; 12385: 			ret = DurItem->ArmorDurabilityDown(damagemin, lpObj->m_Index);

  00138	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013d	51		 push	 ecx
  0013e	8b 55 d4	 mov	 edx, DWORD PTR _damagemin$[ebp]
  00141	52		 push	 edx
  00142	8b 4d d8	 mov	 ecx, DWORD PTR _DurItem$[ebp]
  00145	e8 00 00 00 00	 call	 ?ArmorDurabilityDown@CItem@@QAEHHH@Z ; CItem::ArmorDurabilityDown
  0014a	89 45 d0	 mov	 DWORD PTR _ret$[ebp], eax

; 12386: 			if( ret )

  0014d	83 7d d0 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00151	74 39		 je	 SHORT $LN10@gObjArmorR

; 12387: 			{	//    
; 12388: 				GCItemDurSend(lpObj->m_Index, item_num[item_pos], DurItem->m_Durability, 0);

  00153	6a 00		 push	 0
  00155	8b 45 d8	 mov	 eax, DWORD PTR _DurItem$[ebp]
  00158	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  0015d	0f b6 d1	 movzx	 edx, cl
  00160	52		 push	 edx
  00161	8b 45 dc	 mov	 eax, DWORD PTR _item_pos$[ebp]
  00164	0f b6 4c 85 e0	 movzx	 ecx, BYTE PTR _item_num$[ebp+eax*4]
  00169	51		 push	 ecx
  0016a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0016d	8b 02		 mov	 eax, DWORD PTR [edx]
  0016f	50		 push	 eax
  00170	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00175	83 c4 10	 add	 esp, 16			; 00000010H

; 12389: 				if( ret == 2 )

  00178	83 7d d0 02	 cmp	 DWORD PTR _ret$[ebp], 2
  0017c	75 0e		 jne	 SHORT $LN10@gObjArmorR

; 12390: 				{	//    
; 12391: 					gObjCalCharacter(lpObj->m_Index);

  0017e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00181	8b 08		 mov	 ecx, DWORD PTR [eax]
  00183	51		 push	 ecx
  00184	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00189	83 c4 04	 add	 esp, 4
$LN10@gObjArmorR:
$LN1@gObjArmorR:

; 12392: 				}
; 12393: 			}
; 12394: 		}	
; 12395: 	}
; 12396: }

  0018c	5f		 pop	 edi
  0018d	5e		 pop	 esi
  0018e	5b		 pop	 ebx
  0018f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00192	33 cd		 xor	 ecx, ebp
  00194	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c3		 ret	 0
?gObjArmorRandomDurDown@@YAXPAVOBJECTSTRUCT@@0@Z ENDP	; gObjArmorRandomDurDown
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjWeaponDurDown@@YAXPAVOBJECTSTRUCT@@0H@Z
_TEXT	SEGMENT
_ret$ = -16						; size = 4
_Left$ = -12						; size = 4
_Right$ = -8						; size = 4
_itargetdefence$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_type$ = 16						; size = 4
?gObjWeaponDurDown@@YAXPAVOBJECTSTRUCT@@0H@Z PROC	; gObjWeaponDurDown, COMDAT

; 12084: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 12085: #ifdef DURABILITY_DOWN_CHANGE	//    ( , )
; 12086: 	return;
; 12087: #endif
; 12088: 
; 12089: 	if( lpObj->Type == OBJTYPE_MONSTER || lpObj->Type == OBJTYPE_NPC)

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00010	83 f9 02	 cmp	 ecx, 2
  00013	74 0c		 je	 SHORT $LN3@gObjWeapon
  00015	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00018	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0001c	83 f9 03	 cmp	 ecx, 3
  0001f	75 05		 jne	 SHORT $LN2@gObjWeapon
$LN3@gObjWeapon:

; 12090: 	{	//      
; 12091: 		return;

  00021	e9 eb 03 00 00	 jmp	 $LN1@gObjWeapon
$LN2@gObjWeapon:

; 12092: 	}
; 12093: 
; 12094: 	int	itargetdefence = 0;

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _itargetdefence$[ebp], 0

; 12095: 	
; 12096: 	CItem	*Right = &lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT];

  0002d	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00032	6b c8 00	 imul	 ecx, eax, 0
  00035	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00038	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0003e	89 4d f8	 mov	 DWORD PTR _Right$[ebp], ecx

; 12097: 	CItem	*Left  = &lpObj->pInventory[EQUIPMENT_WEAPON_LEFT];			

  00041	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00046	c1 e0 00	 shl	 eax, 0
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0004c	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  00052	89 45 f4	 mov	 DWORD PTR _Left$[ebp], eax

; 12098: 
; 12099: 	int ret = 0;

  00055	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 12100: 
; 12101: #ifdef ADD_PARTIALY_CHARGE_SYSTEM_06_20090129
; 12102: 	if(gObjCheckUsedBuffEffect(lpObj, BUFFTYPE_CHARM_PROTECTITEM) ){
; 12103: 		return ;
; 12104: 	}
; 12105: #endif //ADD_PARTIALY_CHARGE_SYSTEM_06_20090129
; 12106: 
; 12107: 	if( type == 0 )

  0005c	83 7d 10 00	 cmp	 DWORD PTR _type$[ebp], 0
  00060	0f 85 0e 03 00
	00		 jne	 $LN4@gObjWeapon

; 12108: 	{	//  
; 12109: 		itargetdefence = lpTargetObj->m_Defense;

  00066	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00069	8b 88 e8 02 00
	00		 mov	 ecx, DWORD PTR [eax+744]
  0006f	89 4d fc	 mov	 DWORD PTR _itargetdefence$[ebp], ecx

; 12110: 
; 12111: #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004			// !! NOT
; 12112: 	#ifdef ADD_NPC_SHADOW_PHANTOM_20050616
; 12113: 		itargetdefence += lpTargetObj->m_iSkillNPCDefense;
; 12114: 	#endif
; 12115: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 12116: 
; 12117: 		//  	
; 12118: #ifdef DARKLORD_WORK
; 12119: 		if(lpObj->Class == CLASS_KNIGHT || lpObj->Class == CLASS_MAGUMSA || lpObj->Class == CLASS_DARKLORD )

  00072	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00075	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0007c	83 f9 01	 cmp	 ecx, 1
  0007f	74 22		 je	 SHORT $LN7@gObjWeapon
  00081	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00084	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0008b	83 f9 03	 cmp	 ecx, 3
  0008e	74 13		 je	 SHORT $LN7@gObjWeapon
  00090	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00093	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0009a	83 f9 04	 cmp	 ecx, 4
  0009d	0f 85 fa 00 00
	00		 jne	 $LN8@gObjWeapon
$LN7@gObjWeapon:

; 12120: #else
; 12121: 		if(lpObj->Class == CLASS_KNIGHT || lpObj->Class == CLASS_MAGUMSA )
; 12122: #endif
; 12123: 		{
; 12124: 			if( Right->m_Type >= 0 && Right->m_Type < ITEM_BOW && Left->m_Type >= 0 && Left->m_Type < ITEM_BOW )

  000a3	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  000a6	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  000aa	85 c9		 test	 ecx, ecx
  000ac	0f 8c eb 00 00
	00		 jl	 $LN8@gObjWeapon
  000b2	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  000b5	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  000b9	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  000bf	0f 8d d8 00 00
	00		 jge	 $LN8@gObjWeapon
  000c5	8b 45 f4	 mov	 eax, DWORD PTR _Left$[ebp]
  000c8	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  000cc	85 c9		 test	 ecx, ecx
  000ce	0f 8c c9 00 00
	00		 jl	 $LN8@gObjWeapon
  000d4	8b 45 f4	 mov	 eax, DWORD PTR _Left$[ebp]
  000d7	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  000db	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  000e1	0f 8d b6 00 00
	00		 jge	 $LN8@gObjWeapon

; 12125: 			{
; 12126: 				if( rand()%2 == 0 )

  000e7	e8 00 00 00 00	 call	 _rand
  000ec	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000f1	79 05		 jns	 SHORT $LN39@gObjWeapon
  000f3	48		 dec	 eax
  000f4	83 c8 fe	 or	 eax, -2			; fffffffeH
  000f7	40		 inc	 eax
$LN39@gObjWeapon:
  000f8	85 c0		 test	 eax, eax
  000fa	75 4f		 jne	 SHORT $LN9@gObjWeapon

; 12127: 				{	//   
; 12128: 					ret = Left->NormalWeaponDurabilityDown(itargetdefence, lpObj->m_Index);

  000fc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ff	8b 08		 mov	 ecx, DWORD PTR [eax]
  00101	51		 push	 ecx
  00102	8b 55 fc	 mov	 edx, DWORD PTR _itargetdefence$[ebp]
  00105	52		 push	 edx
  00106	8b 4d f4	 mov	 ecx, DWORD PTR _Left$[ebp]
  00109	e8 00 00 00 00	 call	 ?NormalWeaponDurabilityDown@CItem@@QAEHHH@Z ; CItem::NormalWeaponDurabilityDown
  0010e	89 45 f0	 mov	 DWORD PTR _ret$[ebp], eax

; 12129: 					if( ret )

  00111	83 7d f0 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00115	74 32		 je	 SHORT $LN12@gObjWeapon

; 12130: 					{
; 12131: 						GCItemDurSend(lpObj->m_Index, EQUIPMENT_WEAPON_LEFT, Left->m_Durability, 0);

  00117	6a 00		 push	 0
  00119	8b 45 f4	 mov	 eax, DWORD PTR _Left$[ebp]
  0011c	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  00121	0f b6 d1	 movzx	 edx, cl
  00124	52		 push	 edx
  00125	6a 01		 push	 1
  00127	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012c	51		 push	 ecx
  0012d	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00132	83 c4 10	 add	 esp, 16			; 00000010H

; 12132: 						if( ret == 2 )

  00135	83 7d f0 02	 cmp	 DWORD PTR _ret$[ebp], 2
  00139	75 0e		 jne	 SHORT $LN12@gObjWeapon

; 12133: 						{
; 12134: 							gObjCalCharacter(lpObj->m_Index);

  0013b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00140	51		 push	 ecx
  00141	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00146	83 c4 04	 add	 esp, 4
$LN12@gObjWeapon:

; 12135: 						}
; 12136: 					}
; 12137: 				}

  00149	eb 4d		 jmp	 SHORT $LN14@gObjWeapon
$LN9@gObjWeapon:

; 12138: 				else
; 12139: 				{	//   
; 12140: 					ret = Right->NormalWeaponDurabilityDown(itargetdefence, lpObj->m_Index);					

  0014b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00150	51		 push	 ecx
  00151	8b 55 fc	 mov	 edx, DWORD PTR _itargetdefence$[ebp]
  00154	52		 push	 edx
  00155	8b 4d f8	 mov	 ecx, DWORD PTR _Right$[ebp]
  00158	e8 00 00 00 00	 call	 ?NormalWeaponDurabilityDown@CItem@@QAEHHH@Z ; CItem::NormalWeaponDurabilityDown
  0015d	89 45 f0	 mov	 DWORD PTR _ret$[ebp], eax

; 12141: 					if( ret )

  00160	83 7d f0 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00164	74 32		 je	 SHORT $LN14@gObjWeapon

; 12142: 					{
; 12143: 						GCItemDurSend(lpObj->m_Index, EQUIPMENT_WEAPON_RIGHT, Right->m_Durability, 0);

  00166	6a 00		 push	 0
  00168	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  0016b	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  00170	0f b6 d1	 movzx	 edx, cl
  00173	52		 push	 edx
  00174	6a 00		 push	 0
  00176	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00179	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017b	51		 push	 ecx
  0017c	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00181	83 c4 10	 add	 esp, 16			; 00000010H

; 12144: 						if( ret == 2 )

  00184	83 7d f0 02	 cmp	 DWORD PTR _ret$[ebp], 2
  00188	75 0e		 jne	 SHORT $LN14@gObjWeapon

; 12145: 						{
; 12146: 							gObjCalCharacter(lpObj->m_Index);

  0018a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0018d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018f	51		 push	 ecx
  00190	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00195	83 c4 04	 add	 esp, 4
$LN14@gObjWeapon:

; 12147: 						}
; 12148: 					}
; 12149: 				}
; 12150: 				return;

  00198	e9 74 02 00 00	 jmp	 $LN1@gObjWeapon
$LN8@gObjWeapon:

; 12151: 			}
; 12152: 		}
; 12153: 
; 12154: 		//
; 12155: 		if( (Left->m_Type >= ITEM_BOW && Left->m_Type < ITEM_BOW+7) 

  0019d	8b 45 f4	 mov	 eax, DWORD PTR _Left$[ebp]
  001a0	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  001a4	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  001aa	7c 61		 jl	 SHORT $LN15@gObjWeapon
  001ac	8b 45 f4	 mov	 eax, DWORD PTR _Left$[ebp]
  001af	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  001b3	81 f9 87 00 00
	00		 cmp	 ecx, 135		; 00000087H
  001b9	7d 52		 jge	 SHORT $LN15@gObjWeapon

; 12156: #ifdef MODIFY_APPLYING_BOW_01_20050825
; 12157: 			|| Left->m_Type == ITEM_BOW + 20
; 12158: 			|| Left->m_Type == ITEM_BOW + 21
; 12159: #endif
; 12160: #ifdef MODIFY_ALBATROS_BOW_DURABILITY_BUGFIX_20080813	//   
; 12161: 			|| Left->m_Type == ITEM_BOW + 22
; 12162: #endif // MODIFY_ALBATROS_BOW_DURABILITY_BUGFIX_20080813
; 12163: #ifdef MODIFY_DARKSTINGER_BUGFIX_20081119
; 12164: 			|| Left->m_Type == ITEM_BOW + 23			//  
; 12165: #endif // MODIFY_DARKSTINGER_BUGFIX_20081119
; 12166: #ifdef ADD_AERINBOW_20090309
; 12167: 			|| Left->m_Type == ITEM_BOW + 24			//  
; 12168: #endif // ADD_AERINBOW_20090309
; 12169: 		  )
; 12170: 		{
; 12171: 			ret = Left->BowWeaponDurabilityDown(itargetdefence, lpObj->m_Index);

  001bb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001be	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c0	51		 push	 ecx
  001c1	8b 55 fc	 mov	 edx, DWORD PTR _itargetdefence$[ebp]
  001c4	52		 push	 edx
  001c5	8b 4d f4	 mov	 ecx, DWORD PTR _Left$[ebp]
  001c8	e8 00 00 00 00	 call	 ?BowWeaponDurabilityDown@CItem@@QAEHHH@Z ; CItem::BowWeaponDurabilityDown
  001cd	89 45 f0	 mov	 DWORD PTR _ret$[ebp], eax

; 12172: 			if( ret )

  001d0	83 7d f0 00	 cmp	 DWORD PTR _ret$[ebp], 0
  001d4	74 32		 je	 SHORT $LN18@gObjWeapon

; 12173: 			{
; 12174: 				GCItemDurSend(lpObj->m_Index, EQUIPMENT_WEAPON_LEFT, Left->m_Durability, 0);

  001d6	6a 00		 push	 0
  001d8	8b 45 f4	 mov	 eax, DWORD PTR _Left$[ebp]
  001db	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  001e0	0f b6 d1	 movzx	 edx, cl
  001e3	52		 push	 edx
  001e4	6a 01		 push	 1
  001e6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  001eb	51		 push	 ecx
  001ec	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  001f1	83 c4 10	 add	 esp, 16			; 00000010H

; 12175: 				if( ret == 2 )

  001f4	83 7d f0 02	 cmp	 DWORD PTR _ret$[ebp], 2
  001f8	75 0e		 jne	 SHORT $LN18@gObjWeapon

; 12176: 				{
; 12177: 					gObjCalCharacter(lpObj->m_Index);

  001fa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001fd	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ff	51		 push	 ecx
  00200	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00205	83 c4 04	 add	 esp, 4
$LN18@gObjWeapon:

; 12178: 				}
; 12179: 			}
; 12180: 		}

  00208	e9 62 01 00 00	 jmp	 $LN31@gObjWeapon
$LN15@gObjWeapon:

; 12181: 		//
; 12182: 		else if(( Right->m_Type >= ITEM_BOW+8 && Right->m_Type < ITEM_BOW+15) ||

  0020d	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  00210	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00214	81 f9 88 00 00
	00		 cmp	 ecx, 136		; 00000088H
  0021a	7c 0f		 jl	 SHORT $LN22@gObjWeapon
  0021c	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  0021f	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00223	81 f9 8f 00 00
	00		 cmp	 ecx, 143		; 0000008fH
  00229	7c 1e		 jl	 SHORT $LN21@gObjWeapon
$LN22@gObjWeapon:
  0022b	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  0022e	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00232	81 f9 90 00 00
	00		 cmp	 ecx, 144		; 00000090H
  00238	7c 61		 jl	 SHORT $LN19@gObjWeapon
  0023a	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  0023d	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00241	81 f9 a0 00 00
	00		 cmp	 ecx, 160		; 000000a0H
  00247	7d 52		 jge	 SHORT $LN19@gObjWeapon
$LN21@gObjWeapon:

; 12183: 			  ( Right->m_Type >= ITEM_BOW+16 && Right->m_Type < ITEM_BOW+MAX_ITEM_INDEX))
; 12184: 		{		
; 12185: 			
; 12186: 			ret = Right->BowWeaponDurabilityDown(itargetdefence, lpObj->m_Index);			

  00249	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0024c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024e	51		 push	 ecx
  0024f	8b 55 fc	 mov	 edx, DWORD PTR _itargetdefence$[ebp]
  00252	52		 push	 edx
  00253	8b 4d f8	 mov	 ecx, DWORD PTR _Right$[ebp]
  00256	e8 00 00 00 00	 call	 ?BowWeaponDurabilityDown@CItem@@QAEHHH@Z ; CItem::BowWeaponDurabilityDown
  0025b	89 45 f0	 mov	 DWORD PTR _ret$[ebp], eax

; 12187: 			if( ret )

  0025e	83 7d f0 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00262	74 32		 je	 SHORT $LN24@gObjWeapon

; 12188: 			{
; 12189: 				GCItemDurSend(lpObj->m_Index, EQUIPMENT_WEAPON_RIGHT, Right->m_Durability, 0);

  00264	6a 00		 push	 0
  00266	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  00269	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  0026e	0f b6 d1	 movzx	 edx, cl
  00271	52		 push	 edx
  00272	6a 00		 push	 0
  00274	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00277	8b 08		 mov	 ecx, DWORD PTR [eax]
  00279	51		 push	 ecx
  0027a	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  0027f	83 c4 10	 add	 esp, 16			; 00000010H

; 12190: 				if( ret == 2 )

  00282	83 7d f0 02	 cmp	 DWORD PTR _ret$[ebp], 2
  00286	75 0e		 jne	 SHORT $LN24@gObjWeapon

; 12191: 				{
; 12192: 					gObjCalCharacter(lpObj->m_Index);

  00288	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0028d	51		 push	 ecx
  0028e	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00293	83 c4 04	 add	 esp, 4
$LN24@gObjWeapon:

; 12193: 				}
; 12194: 			}
; 12195: 		}

  00296	e9 d4 00 00 00	 jmp	 $LN31@gObjWeapon
$LN19@gObjWeapon:

; 12196: 		//
; 12197: 		else if( Right->m_Type >= 0 && Right->m_Type < ITEM_BOW )

  0029b	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  0029e	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  002a2	85 c9		 test	 ecx, ecx
  002a4	7c 5e		 jl	 SHORT $LN25@gObjWeapon
  002a6	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  002a9	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  002ad	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  002b3	7d 4f		 jge	 SHORT $LN25@gObjWeapon

; 12198: 		{
; 12199: 			ret = Right->NormalWeaponDurabilityDown(itargetdefence, lpObj->m_Index);

  002b5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ba	51		 push	 ecx
  002bb	8b 55 fc	 mov	 edx, DWORD PTR _itargetdefence$[ebp]
  002be	52		 push	 edx
  002bf	8b 4d f8	 mov	 ecx, DWORD PTR _Right$[ebp]
  002c2	e8 00 00 00 00	 call	 ?NormalWeaponDurabilityDown@CItem@@QAEHHH@Z ; CItem::NormalWeaponDurabilityDown
  002c7	89 45 f0	 mov	 DWORD PTR _ret$[ebp], eax

; 12200: 			if( ret )

  002ca	83 7d f0 00	 cmp	 DWORD PTR _ret$[ebp], 0
  002ce	74 32		 je	 SHORT $LN28@gObjWeapon

; 12201: 			{
; 12202: 				GCItemDurSend(lpObj->m_Index, EQUIPMENT_WEAPON_RIGHT, Right->m_Durability, 0);

  002d0	6a 00		 push	 0
  002d2	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  002d5	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  002da	0f b6 d1	 movzx	 edx, cl
  002dd	52		 push	 edx
  002de	6a 00		 push	 0
  002e0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  002e5	51		 push	 ecx
  002e6	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  002eb	83 c4 10	 add	 esp, 16			; 00000010H

; 12203: 				if( ret == 2 )

  002ee	83 7d f0 02	 cmp	 DWORD PTR _ret$[ebp], 2
  002f2	75 0e		 jne	 SHORT $LN28@gObjWeapon

; 12204: 				{
; 12205: 					gObjCalCharacter(lpObj->m_Index);

  002f4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002f7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f9	51		 push	 ecx
  002fa	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  002ff	83 c4 04	 add	 esp, 4
$LN28@gObjWeapon:

; 12206: 				}
; 12207: 			}
; 12208: 		}

  00302	eb 6b		 jmp	 SHORT $LN31@gObjWeapon
$LN25@gObjWeapon:

; 12209: 		//
; 12210: 		else if( Right->m_Type >= ITEM_STAFF && Right->m_Type < ITEM_SHIELD )

  00304	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  00307	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0030b	81 f9 a0 00 00
	00		 cmp	 ecx, 160		; 000000a0H
  00311	7c 5c		 jl	 SHORT $LN31@gObjWeapon
  00313	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  00316	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0031a	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  00320	7d 4d		 jge	 SHORT $LN31@gObjWeapon

; 12211: 		{	
; 12212: 			ret = Right->StaffWeaponDurabilityDown(itargetdefence, lpObj->m_Index);

  00322	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00325	8b 08		 mov	 ecx, DWORD PTR [eax]
  00327	51		 push	 ecx
  00328	8b 55 fc	 mov	 edx, DWORD PTR _itargetdefence$[ebp]
  0032b	52		 push	 edx
  0032c	8b 4d f8	 mov	 ecx, DWORD PTR _Right$[ebp]
  0032f	e8 00 00 00 00	 call	 ?StaffWeaponDurabilityDown@CItem@@QAEHHH@Z ; CItem::StaffWeaponDurabilityDown
  00334	89 45 f0	 mov	 DWORD PTR _ret$[ebp], eax

; 12213: 
; 12214: 			if( ret )

  00337	83 7d f0 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0033b	74 32		 je	 SHORT $LN31@gObjWeapon

; 12215: 			{
; 12216: 				GCItemDurSend(lpObj->m_Index, EQUIPMENT_WEAPON_RIGHT, Right->m_Durability, 0);

  0033d	6a 00		 push	 0
  0033f	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  00342	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  00347	0f b6 d1	 movzx	 edx, cl
  0034a	52		 push	 edx
  0034b	6a 00		 push	 0
  0034d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00350	8b 08		 mov	 ecx, DWORD PTR [eax]
  00352	51		 push	 ecx
  00353	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00358	83 c4 10	 add	 esp, 16			; 00000010H

; 12217: 				if( ret == 2 )

  0035b	83 7d f0 02	 cmp	 DWORD PTR _ret$[ebp], 2
  0035f	75 0e		 jne	 SHORT $LN31@gObjWeapon

; 12218: 				{
; 12219: 					gObjCalCharacter(lpObj->m_Index);

  00361	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00364	8b 08		 mov	 ecx, DWORD PTR [eax]
  00366	51		 push	 ecx
  00367	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  0036c	83 c4 04	 add	 esp, 4
$LN31@gObjWeapon:

; 12220: 				}
; 12221: 			}
; 12222: 		}
; 12223: 	}

  0036f	e9 9d 00 00 00	 jmp	 $LN37@gObjWeapon
$LN4@gObjWeapon:

; 12224: 	else
; 12225: 	{	//  
; 12226: 		if( lpTargetObj->Type == OBJTYPE_MONSTER || lpTargetObj->Type == OBJTYPE_NPC)

  00374	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00377	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0037b	83 f9 02	 cmp	 ecx, 2
  0037e	74 0c		 je	 SHORT $LN34@gObjWeapon
  00380	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00383	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00387	83 f9 03	 cmp	 ecx, 3
  0038a	75 0e		 jne	 SHORT $LN32@gObjWeapon
$LN34@gObjWeapon:

; 12227: 		{	//     
; 12228: 			itargetdefence = lpTargetObj->m_MagicDefense;

  0038c	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0038f	8b 88 ec 02 00
	00		 mov	 ecx, DWORD PTR [eax+748]
  00395	89 4d fc	 mov	 DWORD PTR _itargetdefence$[ebp], ecx

; 12229: 		}

  00398	eb 0c		 jmp	 SHORT $LN33@gObjWeapon
$LN32@gObjWeapon:

; 12230: 		else
; 12231: 		{	//      
; 12232: 			itargetdefence = lpTargetObj->m_Defense;

  0039a	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0039d	8b 88 e8 02 00
	00		 mov	 ecx, DWORD PTR [eax+744]
  003a3	89 4d fc	 mov	 DWORD PTR _itargetdefence$[ebp], ecx
$LN33@gObjWeapon:

; 12233: 		}
; 12234: 
; 12235: #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004			// !! NOT
; 12236: 	#ifdef ADD_NPC_SHADOW_PHANTOM_20050616
; 12237: 		itargetdefence += lpTargetObj->m_iSkillNPCDefense;
; 12238: 	#endif
; 12239: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 12240: 
; 12241: #ifdef MODIFY_SUMMONER_ITEM_DURABILITY_DOWN_BUGFIX_20071213	// 
; 12242: 		if( lpObj->Class == CLASS_SUMMONER )
; 12243: 		{
; 12244: 			if( Right->m_Type >= 0 && Right->m_Type >= ITEM_STAFF && Right->m_Type < ITEM_SHIELD
; 12245: 				&& Left->m_Type >= 0 && Left->m_Type >= ITEM_STAFF && Left->m_Type < ITEM_SHIELD )
; 12246: 			{
; 12247: 				//  ,  
; 12248: 				if( rand()%2 == 0 )
; 12249: 				{
; 12250: 					ret = Right->StaffWeaponDurabilityDown(itargetdefence, lpObj->m_Index);
; 12251: 					
; 12252: 					if( ret )
; 12253: 					{
; 12254: 						GCItemDurSend(lpObj->m_Index, EQUIPMENT_WEAPON_RIGHT, Right->m_Durability, 0);
; 12255: 						if( ret == 2 )
; 12256: 						{
; 12257: 							gObjCalCharacter(lpObj->m_Index);
; 12258: 						}
; 12259: 					}
; 12260: 				}
; 12261: 				else
; 12262: 				{
; 12263: 					ret = Left->StaffWeaponDurabilityDown(itargetdefence, lpObj->m_Index);
; 12264: 					
; 12265: 					if( ret )
; 12266: 					{
; 12267: 						GCItemDurSend(lpObj->m_Index, EQUIPMENT_WEAPON_LEFT, Left->m_Durability, 0);
; 12268: 						if( ret == 2 )
; 12269: 						{
; 12270: 							gObjCalCharacter(lpObj->m_Index);
; 12271: 						}
; 12272: 					}
; 12273: 				}
; 12274: 				return;
; 12275: 			}
; 12276: 			else if( Right->m_Type >= 0 && Right->m_Type >= ITEM_STAFF && Right->m_Type < ITEM_SHIELD)
; 12277: 			{
; 12278: 				//  
; 12279: 				GCItemDurSend(lpObj->m_Index, EQUIPMENT_WEAPON_RIGHT, Right->m_Durability, 0);
; 12280: 				if( ret == 2 )
; 12281: 				{
; 12282: 					gObjCalCharacter(lpObj->m_Index);
; 12283: 				}
; 12284: 				return;
; 12285: 			}
; 12286: 			else if( Left->m_Type >= 0 && Left->m_Type >= ITEM_STAFF && Left->m_Type < ITEM_SHIELD)
; 12287: 			{
; 12288: 				//   
; 12289: 				ret = Left->StaffWeaponDurabilityDown(itargetdefence, lpObj->m_Index);
; 12290: 				
; 12291: 				if( ret )
; 12292: 				{
; 12293: 					GCItemDurSend(lpObj->m_Index, EQUIPMENT_WEAPON_LEFT, Left->m_Durability, 0);
; 12294: 					if( ret == 2 )
; 12295: 					{
; 12296: 						gObjCalCharacter(lpObj->m_Index);
; 12297: 					}
; 12298: 				}
; 12299: 				return;
; 12300: 			}
; 12301: 		}
; 12302: 
; 12303: #endif	// MODIFY_SUMMONER_ITEM_DURABILITY_DOWN_BUGFIX_20071213
; 12304: 		
; 12305: 		//
; 12306: 		if( Right->m_Type >= ITEM_STAFF && Right->m_Type < ITEM_SHIELD )

  003a6	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  003a9	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  003ad	81 f9 a0 00 00
	00		 cmp	 ecx, 160		; 000000a0H
  003b3	7c 5c		 jl	 SHORT $LN37@gObjWeapon
  003b5	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  003b8	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  003bc	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  003c2	7d 4d		 jge	 SHORT $LN37@gObjWeapon

; 12307: 		{	
; 12308: 			ret = Right->StaffWeaponDurabilityDown(itargetdefence, lpObj->m_Index);

  003c4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c9	51		 push	 ecx
  003ca	8b 55 fc	 mov	 edx, DWORD PTR _itargetdefence$[ebp]
  003cd	52		 push	 edx
  003ce	8b 4d f8	 mov	 ecx, DWORD PTR _Right$[ebp]
  003d1	e8 00 00 00 00	 call	 ?StaffWeaponDurabilityDown@CItem@@QAEHHH@Z ; CItem::StaffWeaponDurabilityDown
  003d6	89 45 f0	 mov	 DWORD PTR _ret$[ebp], eax

; 12309: 
; 12310: 			if( ret )

  003d9	83 7d f0 00	 cmp	 DWORD PTR _ret$[ebp], 0
  003dd	74 32		 je	 SHORT $LN37@gObjWeapon

; 12311: 			{
; 12312: 				GCItemDurSend(lpObj->m_Index, EQUIPMENT_WEAPON_RIGHT, Right->m_Durability, 0);

  003df	6a 00		 push	 0
  003e1	8b 45 f8	 mov	 eax, DWORD PTR _Right$[ebp]
  003e4	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  003e9	0f b6 d1	 movzx	 edx, cl
  003ec	52		 push	 edx
  003ed	6a 00		 push	 0
  003ef	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003f2	8b 08		 mov	 ecx, DWORD PTR [eax]
  003f4	51		 push	 ecx
  003f5	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  003fa	83 c4 10	 add	 esp, 16			; 00000010H

; 12313: 				if( ret == 2 )

  003fd	83 7d f0 02	 cmp	 DWORD PTR _ret$[ebp], 2
  00401	75 0e		 jne	 SHORT $LN37@gObjWeapon

; 12314: 				{
; 12315: 					gObjCalCharacter(lpObj->m_Index);

  00403	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00406	8b 08		 mov	 ecx, DWORD PTR [eax]
  00408	51		 push	 ecx
  00409	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  0040e	83 c4 04	 add	 esp, 4
$LN37@gObjWeapon:
$LN1@gObjWeapon:

; 12316: 				}
; 12317: 			}
; 12318: 		}
; 12319: 	}
; 12320: }

  00411	5f		 pop	 edi
  00412	5e		 pop	 esi
  00413	5b		 pop	 ebx
  00414	8b e5		 mov	 esp, ebp
  00416	5d		 pop	 ebp
  00417	c3		 ret	 0
?gObjWeaponDurDown@@YAXPAVOBJECTSTRUCT@@0H@Z ENDP	; gObjWeaponDurDown
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjPenaltyDurDown@@YAXPAVOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
tv71 = -136						; size = 4
_Wing$ = -68						; size = 4
_DurItem$ = -64						; size = 4
_item_pos$ = -60					; size = 4
_item_num$ = -56					; size = 28
_Weapon$1 = -28						; size = 4
_decdur$ = -24						; size = 4
_Weapon$ = -20						; size = 4
_irand$ = -16						; size = 4
_reCalCharacter$ = -12					; size = 4
_ret$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjPenaltyDurDown@@YAXPAVOBJECTSTRUCT@@0@Z PROC	; gObjPenaltyDurDown, COMDAT

; 11947: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 11948: 	int ret = 0, reCalCharacter = FALSE;

  00016	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
  0001d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 0

; 11949: 	//   
; 11950: 	int irand = rand()%2;

  00024	e8 00 00 00 00	 call	 _rand
  00029	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0002e	79 05		 jns	 SHORT $LN29@gObjPenalt
  00030	48		 dec	 eax
  00031	83 c8 fe	 or	 eax, -2			; fffffffeH
  00034	40		 inc	 eax
$LN29@gObjPenalt:
  00035	89 45 f0	 mov	 DWORD PTR _irand$[ebp], eax

; 11951: 	CItem	*Weapon = &lpObj->pInventory[irand];

  00038	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _irand$[ebp], 168
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00042	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  00048	89 45 ec	 mov	 DWORD PTR _Weapon$[ebp], eax

; 11952: 	int decdur = 1;

  0004b	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _decdur$[ebp], 1

; 11953: 
; 11954: 	switch(lpObj->Class)

  00052	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00055	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0005c	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv71[ebp], ecx
  00062	83 bd 78 ff ff
	ff 04		 cmp	 DWORD PTR tv71[ebp], 4
  00069	0f 87 a3 00 00
	00		 ja	 $LN2@gObjPenalt
  0006f	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR tv71[ebp]
  00075	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN28@gObjPenalt[edx*4]
$LN4@gObjPenalt:

; 11955: 	{
; 11956: 		case CLASS_WIZARD: 
; 11957: 			{
; 11958: 				decdur = (lpObj->Level - (lpTargetObj->Level*38/20));

  0007c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007f	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00086	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00089	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  00090	6b c0 26	 imul	 eax, eax, 38
  00093	99		 cdq
  00094	be 14 00 00 00	 mov	 esi, 20			; 00000014H
  00099	f7 fe		 idiv	 esi
  0009b	2b c8		 sub	 ecx, eax
  0009d	89 4d e8	 mov	 DWORD PTR _decdur$[ebp], ecx

; 11959: 			}
; 11960: 		break;

  000a0	eb 70		 jmp	 SHORT $LN2@gObjPenalt
$LN5@gObjPenalt:

; 11961: 
; 11962: 		case CLASS_KNIGHT: 
; 11963: 			{
; 11964: 				decdur = (lpObj->Level - (lpTargetObj->Level*37/20));

  000a2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a5	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  000ac	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  000af	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  000b6	6b c0 25	 imul	 eax, eax, 37
  000b9	99		 cdq
  000ba	be 14 00 00 00	 mov	 esi, 20			; 00000014H
  000bf	f7 fe		 idiv	 esi
  000c1	2b c8		 sub	 ecx, eax
  000c3	89 4d e8	 mov	 DWORD PTR _decdur$[ebp], ecx

; 11965: 			}
; 11966: 		break;

  000c6	eb 4a		 jmp	 SHORT $LN2@gObjPenalt
$LN6@gObjPenalt:

; 11967: 
; 11968: 		case CLASS_ELF: 
; 11969: 			{
; 11970: 				decdur = (lpObj->Level - (lpTargetObj->Level*36/20));

  000c8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000cb	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  000d2	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  000d5	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  000dc	6b c0 24	 imul	 eax, eax, 36
  000df	99		 cdq
  000e0	be 14 00 00 00	 mov	 esi, 20			; 00000014H
  000e5	f7 fe		 idiv	 esi
  000e7	2b c8		 sub	 ecx, eax
  000e9	89 4d e8	 mov	 DWORD PTR _decdur$[ebp], ecx

; 11971: 			}
; 11972: 		break;

  000ec	eb 24		 jmp	 SHORT $LN2@gObjPenalt
$LN7@gObjPenalt:

; 11973: 
; 11974: #ifdef DARKLORD_WORK
; 11975: 		case CLASS_DARKLORD: 		
; 11976: #endif
; 11977: 		case CLASS_MAGUMSA: 
; 11978: 			{
; 11979: 				decdur = (lpObj->Level - (lpTargetObj->Level*37/20));

  000ee	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f1	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  000f8	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  000fb	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  00102	6b c0 25	 imul	 eax, eax, 37
  00105	99		 cdq
  00106	be 14 00 00 00	 mov	 esi, 20			; 00000014H
  0010b	f7 fe		 idiv	 esi
  0010d	2b c8		 sub	 ecx, eax
  0010f	89 4d e8	 mov	 DWORD PTR _decdur$[ebp], ecx
$LN2@gObjPenalt:

; 11980: 			}
; 11981: 		break;
; 11982: 
; 11983: #ifdef MODIFY_SUMMONER_ITEM_DURABILITY_DOWN_BUGFIX_20071213
; 11984: 		case CLASS_SUMMONER: 
; 11985: 			{
; 11986: 				decdur = (lpObj->Level - (lpTargetObj->Level*38/20));
; 11987: 			}
; 11988: 		break;
; 11989: #endif
; 11990: 	}
; 11991: 
; 11992: 	decdur /= 10;

  00112	8b 45 e8	 mov	 eax, DWORD PTR _decdur$[ebp]
  00115	99		 cdq
  00116	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0011b	f7 f9		 idiv	 ecx
  0011d	89 45 e8	 mov	 DWORD PTR _decdur$[ebp], eax

; 11993: 	
; 11994: 
; 11995: 	if( Weapon->m_Type != MAKE_ITEMNUM(4,7) && Weapon->m_Type != MAKE_ITEMNUM(4,15) )

  00120	8b 45 ec	 mov	 eax, DWORD PTR _Weapon$[ebp]
  00123	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00127	6a 07		 push	 7
  00129	6a 04		 push	 4
  0012b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00130	83 c4 08	 add	 esp, 8
  00133	3b f0		 cmp	 esi, eax
  00135	0f 84 8c 00 00
	00		 je	 $LN12@gObjPenalt
  0013b	8b 45 ec	 mov	 eax, DWORD PTR _Weapon$[ebp]
  0013e	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00142	6a 0f		 push	 15			; 0000000fH
  00144	6a 04		 push	 4
  00146	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0014b	83 c4 08	 add	 esp, 8
  0014e	3b f0		 cmp	 esi, eax
  00150	74 75		 je	 SHORT $LN12@gObjPenalt

; 11996: 	{	//;   
; 11997: 		if( (Weapon->m_Type < ITEM_SHIELD && Weapon->m_Type >= ITEM_HELM) )

  00152	8b 45 ec	 mov	 eax, DWORD PTR _Weapon$[ebp]
  00155	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00159	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  0015f	7d 32		 jge	 SHORT $LN9@gObjPenalt
  00161	8b 45 ec	 mov	 eax, DWORD PTR _Weapon$[ebp]
  00164	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00168	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  0016e	7c 23		 jl	 SHORT $LN9@gObjPenalt

; 11998: 		{	//  
; 11999: 			if( Weapon->IsItem() )

  00170	8b 4d ec	 mov	 ecx, DWORD PTR _Weapon$[ebp]
  00173	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00178	85 c0		 test	 eax, eax
  0017a	74 15		 je	 SHORT $LN11@gObjPenalt

; 12000: 			{
; 12001: 				ret = Weapon->DurabilityDown2(decdur, lpObj->m_Index);

  0017c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00181	51		 push	 ecx
  00182	8b 55 e8	 mov	 edx, DWORD PTR _decdur$[ebp]
  00185	52		 push	 edx
  00186	8b 4d ec	 mov	 ecx, DWORD PTR _Weapon$[ebp]
  00189	e8 00 00 00 00	 call	 ?DurabilityDown2@CItem@@QAEHHH@Z ; CItem::DurabilityDown2
  0018e	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
$LN11@gObjPenalt:

; 12002: 			}
; 12003: 		}

  00191	eb 34		 jmp	 SHORT $LN12@gObjPenalt
$LN9@gObjPenalt:

; 12004: 		else
; 12005: 		{			
; 12006: 			CItem	*Weapon = &lpObj->pInventory[irand];

  00193	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _irand$[ebp], 168
  0019a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0019d	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  001a3	89 45 e4	 mov	 DWORD PTR _Weapon$1[ebp], eax

; 12007: 			if( Weapon->IsItem() )

  001a6	8b 4d e4	 mov	 ecx, DWORD PTR _Weapon$1[ebp]
  001a9	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  001ae	85 c0		 test	 eax, eax
  001b0	74 15		 je	 SHORT $LN12@gObjPenalt

; 12008: 			{
; 12009: 				ret = Weapon->DurabilityDown2(decdur, lpObj->m_Index);

  001b2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b7	51		 push	 ecx
  001b8	8b 55 e8	 mov	 edx, DWORD PTR _decdur$[ebp]
  001bb	52		 push	 edx
  001bc	8b 4d e4	 mov	 ecx, DWORD PTR _Weapon$1[ebp]
  001bf	e8 00 00 00 00	 call	 ?DurabilityDown2@CItem@@QAEHHH@Z ; CItem::DurabilityDown2
  001c4	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
$LN12@gObjPenalt:

; 12010: 			}
; 12011: 		}
; 12012: 	}
; 12013: 	
; 12014: 	if( ret )

  001c7	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  001cb	74 2f		 je	 SHORT $LN13@gObjPenalt

; 12015: 	{
; 12016: 		GCItemDurSend2(lpObj->m_Index, irand, lpObj->pInventory[irand].m_Durability, 0);			

  001cd	6a 00		 push	 0
  001cf	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _irand$[ebp], 168
  001d6	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001d9	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  001df	f3 0f 2c 44 02
	24		 cvttss2si eax, DWORD PTR [edx+eax+36]
  001e5	0f b6 c8	 movzx	 ecx, al
  001e8	51		 push	 ecx
  001e9	0f b6 55 f0	 movzx	 edx, BYTE PTR _irand$[ebp]
  001ed	52		 push	 edx
  001ee	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f3	51		 push	 ecx
  001f4	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  001f9	83 c4 10	 add	 esp, 16			; 00000010H
$LN13@gObjPenalt:

; 12017: 	}
; 12018: 	if( ret == 2 )

  001fc	83 7d f8 02	 cmp	 DWORD PTR _ret$[ebp], 2
  00200	75 07		 jne	 SHORT $LN14@gObjPenalt

; 12019: 	{	
; 12020: 		reCalCharacter = TRUE;

  00202	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 1
$LN14@gObjPenalt:

; 12021: 	}
; 12022: 
; 12023: 	//   
; 12024: 	int item_num[7] = {EQUIPMENT_WEAPON_RIGHT, EQUIPMENT_WEAPON_LEFT, EQUIPMENT_HELM, EQUIPMENT_ARMOR,EQUIPMENT_PANTS, EQUIPMENT_GLOVES, EQUIPMENT_BOOTS};

  00209	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _item_num$[ebp], 0
  00210	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+4], 1
  00217	c7 45 d0 02 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+8], 2
  0021e	c7 45 d4 03 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+12], 3
  00225	c7 45 d8 04 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+16], 4
  0022c	c7 45 dc 05 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+20], 5
  00233	c7 45 e0 06 00
	00 00		 mov	 DWORD PTR _item_num$[ebp+24], 6

; 12025: 	int item_pos = rand()%7;

  0023a	e8 00 00 00 00	 call	 _rand
  0023f	99		 cdq
  00240	b9 07 00 00 00	 mov	 ecx, 7
  00245	f7 f9		 idiv	 ecx
  00247	89 55 c4	 mov	 DWORD PTR _item_pos$[ebp], edx

; 12026: 
; 12027: 	CItem	*DurItem = &lpObj->pInventory[item_num[item_pos]];

  0024a	8b 45 c4	 mov	 eax, DWORD PTR _item_pos$[ebp]
  0024d	69 4c 85 c8 a8
	00 00 00	 imul	 ecx, DWORD PTR _item_num$[ebp+eax*4], 168
  00255	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00258	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0025e	89 4d c0	 mov	 DWORD PTR _DurItem$[ebp], ecx

; 12028: 
; 12029: 	if( DurItem->m_Type != MAKE_ITEMNUM(4,7) && DurItem->m_Type != MAKE_ITEMNUM(4,15) )

  00261	8b 45 c0	 mov	 eax, DWORD PTR _DurItem$[ebp]
  00264	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00268	6a 07		 push	 7
  0026a	6a 04		 push	 4
  0026c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00271	83 c4 08	 add	 esp, 8
  00274	3b f0		 cmp	 esi, eax
  00276	0f 84 db 00 00
	00		 je	 $LN22@gObjPenalt
  0027c	8b 45 c0	 mov	 eax, DWORD PTR _DurItem$[ebp]
  0027f	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00283	6a 0f		 push	 15			; 0000000fH
  00285	6a 04		 push	 4
  00287	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0028c	83 c4 08	 add	 esp, 8
  0028f	3b f0		 cmp	 esi, eax
  00291	0f 84 c0 00 00
	00		 je	 $LN22@gObjPenalt

; 12030: 	{
; 12031: 		//     .
; 12032: 		if( item_pos < 2 )

  00297	83 7d c4 02	 cmp	 DWORD PTR _item_pos$[ebp], 2
  0029b	7d 6d		 jge	 SHORT $LN16@gObjPenalt

; 12033: 		{
; 12034: 			if( (DurItem->m_Type >= ITEM_SHIELD && DurItem->m_Type < ITEM_HELM) )

  0029d	8b 45 c0	 mov	 eax, DWORD PTR _DurItem$[ebp]
  002a0	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  002a4	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  002aa	7c 5c		 jl	 SHORT $LN20@gObjPenalt
  002ac	8b 45 c0	 mov	 eax, DWORD PTR _DurItem$[ebp]
  002af	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  002b3	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  002b9	7d 4d		 jge	 SHORT $LN20@gObjPenalt

; 12035: 			{	// 
; 12036: 				ret = DurItem->DurabilityDown2(decdur, lpObj->m_Index);

  002bb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002be	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c0	51		 push	 ecx
  002c1	8b 55 e8	 mov	 edx, DWORD PTR _decdur$[ebp]
  002c4	52		 push	 edx
  002c5	8b 4d c0	 mov	 ecx, DWORD PTR _DurItem$[ebp]
  002c8	e8 00 00 00 00	 call	 ?DurabilityDown2@CItem@@QAEHHH@Z ; CItem::DurabilityDown2
  002cd	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 12037: 				if( ret )

  002d0	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  002d4	74 32		 je	 SHORT $LN20@gObjPenalt

; 12038: 				{	//    
; 12039: 					GCItemDurSend2(lpObj->m_Index, item_num[item_pos], DurItem->m_Durability, 0);

  002d6	6a 00		 push	 0
  002d8	8b 45 c0	 mov	 eax, DWORD PTR _DurItem$[ebp]
  002db	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  002e0	0f b6 d1	 movzx	 edx, cl
  002e3	52		 push	 edx
  002e4	8b 45 c4	 mov	 eax, DWORD PTR _item_pos$[ebp]
  002e7	0f b6 4c 85 c8	 movzx	 ecx, BYTE PTR _item_num$[ebp+eax*4]
  002ec	51		 push	 ecx
  002ed	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002f0	8b 02		 mov	 eax, DWORD PTR [edx]
  002f2	50		 push	 eax
  002f3	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  002f8	83 c4 10	 add	 esp, 16			; 00000010H

; 12040: 					if( ret == 2 )

  002fb	83 7d f8 02	 cmp	 DWORD PTR _ret$[ebp], 2
  002ff	75 07		 jne	 SHORT $LN20@gObjPenalt

; 12041: 					{	//    
; 12042: 						reCalCharacter = TRUE;

  00301	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 1
$LN20@gObjPenalt:

; 12043: 					}
; 12044: 				}				
; 12045: 			}		
; 12046: 		}

  00308	eb 4d		 jmp	 SHORT $LN22@gObjPenalt
$LN16@gObjPenalt:

; 12047: 		else
; 12048: 		{
; 12049: 			ret = DurItem->DurabilityDown2(decdur, lpObj->m_Index);

  0030a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030f	51		 push	 ecx
  00310	8b 55 e8	 mov	 edx, DWORD PTR _decdur$[ebp]
  00313	52		 push	 edx
  00314	8b 4d c0	 mov	 ecx, DWORD PTR _DurItem$[ebp]
  00317	e8 00 00 00 00	 call	 ?DurabilityDown2@CItem@@QAEHHH@Z ; CItem::DurabilityDown2
  0031c	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 12050: 			if( ret )

  0031f	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00323	74 32		 je	 SHORT $LN22@gObjPenalt

; 12051: 			{	//    
; 12052: 				GCItemDurSend2(lpObj->m_Index, item_num[item_pos], DurItem->m_Durability, 0);

  00325	6a 00		 push	 0
  00327	8b 45 c0	 mov	 eax, DWORD PTR _DurItem$[ebp]
  0032a	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  0032f	0f b6 d1	 movzx	 edx, cl
  00332	52		 push	 edx
  00333	8b 45 c4	 mov	 eax, DWORD PTR _item_pos$[ebp]
  00336	0f b6 4c 85 c8	 movzx	 ecx, BYTE PTR _item_num$[ebp+eax*4]
  0033b	51		 push	 ecx
  0033c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0033f	8b 02		 mov	 eax, DWORD PTR [edx]
  00341	50		 push	 eax
  00342	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  00347	83 c4 10	 add	 esp, 16			; 00000010H

; 12053: 				if( ret == 2 )

  0034a	83 7d f8 02	 cmp	 DWORD PTR _ret$[ebp], 2
  0034e	75 07		 jne	 SHORT $LN22@gObjPenalt

; 12054: 				{	//    
; 12055: 					reCalCharacter = TRUE;

  00350	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 1
$LN22@gObjPenalt:

; 12056: 				}
; 12057: 			}
; 12058: 		}
; 12059: 	}
; 12060: 
; 12061: 	//    
; 12062: 	CItem	*Wing = &lpObj->pInventory[EQUIPMENT_WING];	

  00357	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0035c	6b c8 07	 imul	 ecx, eax, 7
  0035f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00362	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00368	89 4d bc	 mov	 DWORD PTR _Wing$[ebp], ecx

; 12063: 	if( Wing->IsItem() )

  0036b	8b 4d bc	 mov	 ecx, DWORD PTR _Wing$[ebp]
  0036e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00373	85 c0		 test	 eax, eax
  00375	74 4d		 je	 SHORT $LN25@gObjPenalt

; 12064: 	{
; 12065: 		ret = DurItem->DurabilityDown2(decdur, lpObj->m_Index);

  00377	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0037a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0037c	51		 push	 ecx
  0037d	8b 55 e8	 mov	 edx, DWORD PTR _decdur$[ebp]
  00380	52		 push	 edx
  00381	8b 4d c0	 mov	 ecx, DWORD PTR _DurItem$[ebp]
  00384	e8 00 00 00 00	 call	 ?DurabilityDown2@CItem@@QAEHHH@Z ; CItem::DurabilityDown2
  00389	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 12066: 		if( ret )

  0038c	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00390	74 32		 je	 SHORT $LN25@gObjPenalt

; 12067: 		{	//    
; 12068: 			GCItemDurSend2(lpObj->m_Index, item_num[item_pos], DurItem->m_Durability, 0);

  00392	6a 00		 push	 0
  00394	8b 45 c0	 mov	 eax, DWORD PTR _DurItem$[ebp]
  00397	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  0039c	0f b6 d1	 movzx	 edx, cl
  0039f	52		 push	 edx
  003a0	8b 45 c4	 mov	 eax, DWORD PTR _item_pos$[ebp]
  003a3	0f b6 4c 85 c8	 movzx	 ecx, BYTE PTR _item_num$[ebp+eax*4]
  003a8	51		 push	 ecx
  003a9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003ac	8b 02		 mov	 eax, DWORD PTR [edx]
  003ae	50		 push	 eax
  003af	e8 00 00 00 00	 call	 ?GCItemDurSend2@@YAXHEEE@Z ; GCItemDurSend2
  003b4	83 c4 10	 add	 esp, 16			; 00000010H

; 12069: 			if( ret == 2 )

  003b7	83 7d f8 02	 cmp	 DWORD PTR _ret$[ebp], 2
  003bb	75 07		 jne	 SHORT $LN25@gObjPenalt

; 12070: 			{	//    
; 12071: 				reCalCharacter = TRUE;

  003bd	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _reCalCharacter$[ebp], 1
$LN25@gObjPenalt:

; 12072: 			}
; 12073: 		}				
; 12074: 	}	
; 12075: 
; 12076: 	if( reCalCharacter )

  003c4	83 7d f4 00	 cmp	 DWORD PTR _reCalCharacter$[ebp], 0
  003c8	74 0e		 je	 SHORT $LN26@gObjPenalt

; 12077: 	{	//         
; 12078: 		gObjCalCharacter(lpObj->m_Index);

  003ca	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003cd	8b 08		 mov	 ecx, DWORD PTR [eax]
  003cf	51		 push	 ecx
  003d0	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  003d5	83 c4 04	 add	 esp, 4
$LN26@gObjPenalt:

; 12079: 	}
; 12080: }

  003d8	5f		 pop	 edi
  003d9	5e		 pop	 esi
  003da	5b		 pop	 ebx
  003db	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003de	33 cd		 xor	 ecx, ebp
  003e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003e5	8b e5		 mov	 esp, ebp
  003e7	5d		 pop	 ebp
  003e8	c3		 ret	 0
  003e9	0f 1f 00	 npad	 3
$LN28@gObjPenalt:
  003ec	00 00 00 00	 DD	 $LN4@gObjPenalt
  003f0	00 00 00 00	 DD	 $LN5@gObjPenalt
  003f4	00 00 00 00	 DD	 $LN6@gObjPenalt
  003f8	00 00 00 00	 DD	 $LN7@gObjPenalt
  003fc	00 00 00 00	 DD	 $LN7@gObjPenalt
?gObjPenaltyDurDown@@YAXPAVOBJECTSTRUCT@@0@Z ENDP	; gObjPenaltyDurDown
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGetStatPointState@@YAXHAAF0@Z
_TEXT	SEGMENT
_addpoint$ = -16					; size = 4
_ori_point$ = -12					; size = 4
_total_point$ = -8					; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_AddPoint$ = 12						; size = 4
_MaxAddPoint$ = 16					; size = 4
?gObjGetStatPointState@@YAXHAAF0@Z PROC			; gObjGetStatPointState, COMDAT

; 30140: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 30141: 	if( gObj[aIndex].Level <= 5 )

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  0001e	83 fa 05	 cmp	 edx, 5
  00021	7f 10		 jg	 SHORT $LN2@gObjGetSta

; 30142: 	{
; 30143: 		AddPoint = 0;

  00023	33 c0		 xor	 eax, eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _AddPoint$[ebp]
  00028	66 89 01	 mov	 WORD PTR [ecx], ax

; 30144: 		MaxAddPoint = 0;

  0002b	33 c0		 xor	 eax, eax
  0002d	8b 4d 10	 mov	 ecx, DWORD PTR _MaxAddPoint$[ebp]
  00030	66 89 01	 mov	 WORD PTR [ecx], ax
$LN2@gObjGetSta:

; 30145: 	}
; 30146: 
; 30147: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00033	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003a	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00040	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 30148: #ifdef DARKLORD_WORK
; 30149: 	int total_point = lpObj->Strength+lpObj->Dexterity+lpObj->Vitality+lpObj->Energy+lpObj->Leadership+lpObj->LevelUpPoint;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00046	0f b7 88 b4 00
	00 00		 movzx	 ecx, WORD PTR [eax+180]
  0004d	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00050	0f b7 82 b6 00
	00 00		 movzx	 eax, WORD PTR [edx+182]
  00057	03 c8		 add	 ecx, eax
  00059	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0005c	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  00063	03 c8		 add	 ecx, eax
  00065	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00068	0f b7 82 ba 00
	00 00		 movzx	 eax, WORD PTR [edx+186]
  0006f	03 c8		 add	 ecx, eax
  00071	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00074	0f b7 82 d8 00
	00 00		 movzx	 eax, WORD PTR [edx+216]
  0007b	03 c8		 add	 ecx, eax
  0007d	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00080	03 8a a4 00 00
	00		 add	 ecx, DWORD PTR [edx+164]
  00086	89 4d f8	 mov	 DWORD PTR _total_point$[ebp], ecx

; 30150: #else
; 30151: 	int total_point = lpObj->Strength+lpObj->Dexterity+lpObj->Vitality+lpObj->Energy+lpObj->LevelUpPoint;
; 30152: #endif
; 30153: 	int ori_point;
; 30154: 	
; 30155: 
; 30156: 	//     +  *     ,     .
; 30157: #ifdef DARKLORD_WORK
; 30158: 	if( lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA )

  00089	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00093	83 f9 04	 cmp	 ecx, 4
  00096	74 0f		 je	 SHORT $LN5@gObjGetSta
  00098	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009b	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000a2	83 f9 03	 cmp	 ecx, 3
  000a5	75 2c		 jne	 SHORT $LN3@gObjGetSta
$LN5@gObjGetSta:

; 30159: #else
; 30160: 	if( lpObj->Class == CLASS_MAGUMSA )
; 30161: #endif
; 30162: 	{	//   7
; 30163: 		ori_point   = DCInfo.GetDefPoint(lpObj->Class)+((lpObj->Level-1)*7);

  000a7	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000aa	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000b1	51		 push	 ecx
  000b2	b9 00 00 00 00	 mov	 ecx, OFFSET ?DCInfo@@3Vclassdef@@A ; DCInfo
  000b7	e8 00 00 00 00	 call	 ?GetDefPoint@classdef@@QAEHH@Z ; classdef::GetDefPoint
  000bc	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000bf	0f bf 8a a0 00
	00 00		 movsx	 ecx, WORD PTR [edx+160]
  000c6	83 e9 01	 sub	 ecx, 1
  000c9	6b d1 07	 imul	 edx, ecx, 7
  000cc	03 c2		 add	 eax, edx
  000ce	89 45 f4	 mov	 DWORD PTR _ori_point$[ebp], eax

; 30164: 	}

  000d1	eb 2a		 jmp	 SHORT $LN4@gObjGetSta
$LN3@gObjGetSta:

; 30165: 	else
; 30166: 	{
; 30167: 		ori_point   = DCInfo.GetDefPoint(lpObj->Class)+((lpObj->Level-1)*5);

  000d3	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d6	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000dd	51		 push	 ecx
  000de	b9 00 00 00 00	 mov	 ecx, OFFSET ?DCInfo@@3Vclassdef@@A ; DCInfo
  000e3	e8 00 00 00 00	 call	 ?GetDefPoint@classdef@@QAEHH@Z ; classdef::GetDefPoint
  000e8	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000eb	0f bf 8a a0 00
	00 00		 movsx	 ecx, WORD PTR [edx+160]
  000f2	83 e9 01	 sub	 ecx, 1
  000f5	6b d1 05	 imul	 edx, ecx, 5
  000f8	03 c2		 add	 eax, edx
  000fa	89 45 f4	 mov	 DWORD PTR _ori_point$[ebp], eax
$LN4@gObjGetSta:

; 30168: 	}
; 30169: 
; 30170: #ifdef NEW_FORSKYLAND2
; 30171: 	// 1    +10 
; 30172: 	if( g_QuestInfo.GetQuestState(lpObj, 0) == QS_CLEAR )

  000fd	6a 00		 push	 0
  000ff	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00102	50		 push	 eax
  00103	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00108	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAVOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  0010d	83 f8 02	 cmp	 eax, 2
  00110	75 09		 jne	 SHORT $LN6@gObjGetSta

; 30173: 	{
; 30174: 		ori_point += 10;

  00112	8b 45 f4	 mov	 eax, DWORD PTR _ori_point$[ebp]
  00115	83 c0 0a	 add	 eax, 10			; 0000000aH
  00118	89 45 f4	 mov	 DWORD PTR _ori_point$[ebp], eax
$LN6@gObjGetSta:

; 30175: 	}
; 30176: 
; 30177: 	// 2    +10 
; 30178: 	if( g_QuestInfo.GetQuestState(lpObj, 1) == QS_CLEAR )

  0011b	6a 01		 push	 1
  0011d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00120	50		 push	 eax
  00121	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00126	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAVOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  0012b	83 f8 02	 cmp	 eax, 2
  0012e	75 09		 jne	 SHORT $LN7@gObjGetSta

; 30179: 	{
; 30180: 		ori_point += 10;

  00130	8b 45 f4	 mov	 eax, DWORD PTR _ori_point$[ebp]
  00133	83 c0 0a	 add	 eax, 10			; 0000000aH
  00136	89 45 f4	 mov	 DWORD PTR _ori_point$[ebp], eax
$LN7@gObjGetSta:

; 30181: 	}
; 30182: #endif
; 30183: #ifdef SECOND_QUEST
; 30184: 	if( g_QuestInfo.GetQuestState(lpObj, 2) == QS_CLEAR )

  00139	6a 02		 push	 2
  0013b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013e	50		 push	 eax
  0013f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00144	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAVOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  00149	83 f8 02	 cmp	 eax, 2
  0014c	75 17		 jne	 SHORT $LN8@gObjGetSta

; 30185: 	{
; 30186: 		ori_point += lpObj->Level-220;

  0014e	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00151	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00158	8b 55 f4	 mov	 edx, DWORD PTR _ori_point$[ebp]
  0015b	8d 84 0a 24 ff
	ff ff		 lea	 eax, DWORD PTR [edx+ecx-220]
  00162	89 45 f4	 mov	 DWORD PTR _ori_point$[ebp], eax
$LN8@gObjGetSta:

; 30187: 	}
; 30188: #endif
; 30189: #ifdef THIRD_CHANGEUP_SYSTEM_20070507	// 3           
; 30190: 	if( g_QuestInfo.GetQuestState(lpObj, 4) == QS_CLEAR )
; 30191: 	{
; 30192: 		ori_point += 20;
; 30193: 	}
; 30194: 	if( g_QuestInfo.GetQuestState(lpObj, 5) == QS_CLEAR )
; 30195: 	{
; 30196: 		ori_point += 20;
; 30197: 	}
; 30198: 	if( g_QuestInfo.GetQuestState(lpObj, 6) == QS_CLEAR )
; 30199: 	{
; 30200: 		ori_point += 30;
; 30201: 	}
; 30202: #endif
; 30203: 
; 30204: 	int addpoint = ori_point;

  00165	8b 45 f4	 mov	 eax, DWORD PTR _ori_point$[ebp]
  00168	89 45 f0	 mov	 DWORD PTR _addpoint$[ebp], eax

; 30205: 
; 30206: 	//     
; 30207: 	addpoint += gStatMng.GetMaxStat(lpObj->Level, lpObj->Class);

  0016b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016e	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00175	51		 push	 ecx
  00176	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00179	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  00180	50		 push	 eax
  00181	b9 00 00 00 00	 mov	 ecx, OFFSET ?gStatMng@@3VCStatMng@@A ; gStatMng
  00186	e8 00 00 00 00	 call	 ?GetMaxStat@CStatMng@@QAEHHH@Z ; CStatMng::GetMaxStat
  0018b	03 45 f0	 add	 eax, DWORD PTR _addpoint$[ebp]
  0018e	89 45 f0	 mov	 DWORD PTR _addpoint$[ebp], eax

; 30208: 
; 30209: #ifdef ADD_MINUS_STAT_SYSTEM_USING_FRUIT_20050712
; 30210: 	AddPoint		= total_point - ori_point;
; 30211: 	MaxAddPoint		= gStatMng.GetMaxStat(lpObj->Level, lpObj->Class);
; 30212: 
; 30213: 	MinusPoint		= lpObj->iFruitPoint;
; 30214: 	MaxMinusPoint	= gStatMng.GetMaxMinusStat(lpObj->Level, lpObj->Class);
; 30215: #else
; 30216: 	AddPoint = total_point - ori_point;

  00191	8b 45 f8	 mov	 eax, DWORD PTR _total_point$[ebp]
  00194	2b 45 f4	 sub	 eax, DWORD PTR _ori_point$[ebp]
  00197	8b 4d 0c	 mov	 ecx, DWORD PTR _AddPoint$[ebp]
  0019a	66 89 01	 mov	 WORD PTR [ecx], ax

; 30217: 	MaxAddPoint = addpoint - ori_point;

  0019d	8b 45 f0	 mov	 eax, DWORD PTR _addpoint$[ebp]
  001a0	2b 45 f4	 sub	 eax, DWORD PTR _ori_point$[ebp]
  001a3	8b 4d 10	 mov	 ecx, DWORD PTR _MaxAddPoint$[ebp]
  001a6	66 89 01	 mov	 WORD PTR [ecx], ax

; 30218: #endif
; 30219: 
; 30220: }

  001a9	5f		 pop	 edi
  001aa	5e		 pop	 esi
  001ab	5b		 pop	 ebx
  001ac	8b e5		 mov	 esp, ebp
  001ae	5d		 pop	 ebp
  001af	c3		 ret	 0
?gObjGetStatPointState@@YAXHAAF0@Z ENDP			; gObjGetStatPointState
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCalcMaxLifePower@@YAXH@Z
_TEXT	SEGMENT
tv68 = -72						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjCalcMaxLifePower@@YAXH@Z PROC			; gObjCalcMaxLifePower, COMDAT

; 31541: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31542: #ifdef NEW_FORSKYLAND2
; 31543: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 31544: 
; 31545: 	switch( lpObj->Class )

  00019	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00023	89 4d b8	 mov	 DWORD PTR tv68[ebp], ecx
  00026	83 7d b8 04	 cmp	 DWORD PTR tv68[ebp], 4
  0002a	0f 87 96 00 00
	00		 ja	 $LN8@gObjCalcMa
  00030	8b 55 b8	 mov	 edx, DWORD PTR tv68[ebp]
  00033	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN10@gObjCalcMa[edx*4]
$LN4@gObjCalcMa:

; 31546: 	{
; 31547: 		case CLASS_WIZARD:
; 31548: 				lpObj->m_MaxLifePower = 110+lpObj->Level+lpObj->Vitality;			

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003d	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00044	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00047	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  0004e	8d 4c 01 6e	 lea	 ecx, DWORD PTR [ecx+eax+110]
  00052	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00055	89 8a d0 0e 00
	00		 mov	 DWORD PTR [edx+3792], ecx

; 31549: 		break;

  0005b	eb 76		 jmp	 SHORT $LN1@gObjCalcMa
$LN5@gObjCalcMa:

; 31550: 
; 31551: 		case CLASS_KNIGHT:
; 31552: 				lpObj->m_MaxLifePower = 60+lpObj->Level*2+lpObj->Vitality;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00060	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00067	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0006a	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  00071	8d 4c 48 3c	 lea	 ecx, DWORD PTR [eax+ecx*2+60]
  00075	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00078	89 8a d0 0e 00
	00		 mov	 DWORD PTR [edx+3792], ecx

; 31553: 		break;

  0007e	eb 53		 jmp	 SHORT $LN1@gObjCalcMa
$LN6@gObjCalcMa:

; 31554: 
; 31555: 		case CLASS_ELF:			
; 31556: 				lpObj->m_MaxLifePower = 80+lpObj->Level+lpObj->Vitality;		

  00080	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00083	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0008a	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0008d	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  00094	8d 4c 01 50	 lea	 ecx, DWORD PTR [ecx+eax+80]
  00098	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0009b	89 8a d0 0e 00
	00		 mov	 DWORD PTR [edx+3792], ecx

; 31557: 		break;

  000a1	eb 30		 jmp	 SHORT $LN1@gObjCalcMa
$LN7@gObjCalcMa:

; 31558: 
; 31559: #ifdef DARKLORD_WORK
; 31560: 		case CLASS_DARKLORD:		
; 31561: #endif	
; 31562: 		case CLASS_MAGUMSA:			
; 31563: 				lpObj->m_MaxLifePower = 110+lpObj->Level+lpObj->Vitality;			

  000a3	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a6	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  000ad	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000b0	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  000b7	8d 4c 01 6e	 lea	 ecx, DWORD PTR [ecx+eax+110]
  000bb	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000be	89 8a d0 0e 00
	00		 mov	 DWORD PTR [edx+3792], ecx

; 31564: 		break;

  000c4	eb 0d		 jmp	 SHORT $LN1@gObjCalcMa
$LN8@gObjCalcMa:

; 31565: 
; 31566: 		default:
; 31567: 			lpObj->m_MaxLifePower = 0;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c9	c7 80 d0 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3792], 0
$LN1@gObjCalcMa:

; 31568: 		break;
; 31569: 	}
; 31570: #endif
; 31571: }

  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c3		 ret	 0
  000da	66 90		 npad	 2
$LN10@gObjCalcMa:
  000dc	00 00 00 00	 DD	 $LN4@gObjCalcMa
  000e0	00 00 00 00	 DD	 $LN5@gObjCalcMa
  000e4	00 00 00 00	 DD	 $LN6@gObjCalcMa
  000e8	00 00 00 00	 DD	 $LN7@gObjCalcMa
  000ec	00 00 00 00	 DD	 $LN7@gObjCalcMa
?gObjCalcMaxLifePower@@YAXH@Z ENDP			; gObjCalcMaxLifePower
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSetBP@@YAXH@Z
_TEXT	SEGMENT
tv145 = -88						; size = 4
_Leadership$ = -20					; size = 4
_Energy$ = -16						; size = 4
_Vitality$ = -12					; size = 4
_Dexterity$ = -8					; size = 4
_Strength$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjSetBP@@YAXH@Z PROC					; gObjSetBP, COMDAT

; 2915 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2916 : 	int	Strength	= gObj[aIndex].Strength+gObj[aIndex].AddStrength;

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	0f b7 94 01 b4
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+180]
  0001e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002b	0f b7 84 01 e0
	00 00 00	 movzx	 eax, WORD PTR [ecx+eax+224]
  00033	03 d0		 add	 edx, eax
  00035	89 55 fc	 mov	 DWORD PTR _Strength$[ebp], edx

; 2917 : 	int	Dexterity	= gObj[aIndex].Dexterity+gObj[aIndex].AddDexterity;

  00038	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00045	0f b7 94 01 b6
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+182]
  0004d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005a	0f b7 84 01 e2
	00 00 00	 movzx	 eax, WORD PTR [ecx+eax+226]
  00062	03 d0		 add	 edx, eax
  00064	89 55 f8	 mov	 DWORD PTR _Dexterity$[ebp], edx

; 2918 : 	int	Vitality	= gObj[aIndex].Vitality+gObj[aIndex].AddVitality;

  00067	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0006e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00074	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  0007c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00083	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00089	0f b7 84 01 e4
	00 00 00	 movzx	 eax, WORD PTR [ecx+eax+228]
  00091	03 d0		 add	 edx, eax
  00093	89 55 f4	 mov	 DWORD PTR _Vitality$[ebp], edx

; 2919 : 	int	Energy		= gObj[aIndex].Energy+gObj[aIndex].AddEnergy;

  00096	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0009d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a3	0f b7 94 01 ba
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+186]
  000ab	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b8	0f b7 84 01 e6
	00 00 00	 movzx	 eax, WORD PTR [ecx+eax+230]
  000c0	03 d0		 add	 edx, eax
  000c2	89 55 f0	 mov	 DWORD PTR _Energy$[ebp], edx

; 2920 : #ifdef DARKLORD_WORK	
; 2921 : 	int Leadership	= gObj[aIndex].Leadership+gObj[aIndex].AddLeadership;

  000c5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d2	0f b7 94 01 d8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+216]
  000da	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e7	0f b7 84 01 da
	00 00 00	 movzx	 eax, WORD PTR [ecx+eax+218]
  000ef	03 d0		 add	 edx, eax
  000f1	89 55 ec	 mov	 DWORD PTR _Leadership$[ebp], edx

; 2922 : #endif
; 2923 : 
; 2924 : 	switch(gObj[aIndex].Class)

  000f4	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00101	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  00109	89 55 a8	 mov	 DWORD PTR tv145[ebp], edx
  0010c	83 7d a8 04	 cmp	 DWORD PTR tv145[ebp], 4
  00110	0f 87 e4 01 00
	00		 ja	 $LN2@gObjSetBP
  00116	8b 45 a8	 mov	 eax, DWORD PTR tv145[ebp]
  00119	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN10@gObjSetBP[eax*4]
$LN4@gObjSetBP:

; 2925 : 	{
; 2926 : 		case CLASS_WIZARD:
; 2927 : 			gObj[aIndex].MaxBP = Strength*0.2+Dexterity*0.4+Vitality*0.3+Energy*0.2;

  00120	f2 0f 2a 45 fc	 cvtsi2sd xmm0, DWORD PTR _Strength$[ebp]
  00125	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fc999999999999a
  0012d	f2 0f 2a 4d f8	 cvtsi2sd xmm1, DWORD PTR _Dexterity$[ebp]
  00132	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fd999999999999a
  0013a	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0013e	f2 0f 2a 4d f4	 cvtsi2sd xmm1, DWORD PTR _Vitality$[ebp]
  00143	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fd3333333333333
  0014b	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0014f	f2 0f 2a 4d f0	 cvtsi2sd xmm1, DWORD PTR _Energy$[ebp]
  00154	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fc999999999999a
  0015c	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00160	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00164	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0016b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00171	89 84 0a ec 00
	00 00		 mov	 DWORD PTR [edx+ecx+236], eax

; 2928 : 		break;

  00178	e9 7d 01 00 00	 jmp	 $LN2@gObjSetBP
$LN5@gObjSetBP:

; 2929 : 
; 2930 : 		case CLASS_KNIGHT:
; 2931 : 			gObj[aIndex].MaxBP = Strength*0.15+Dexterity*0.2+Vitality*0.3+Energy*1.0;

  0017d	f2 0f 2a 45 fc	 cvtsi2sd xmm0, DWORD PTR _Strength$[ebp]
  00182	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fc3333333333333
  0018a	f2 0f 2a 4d f8	 cvtsi2sd xmm1, DWORD PTR _Dexterity$[ebp]
  0018f	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fc999999999999a
  00197	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0019b	f2 0f 2a 4d f4	 cvtsi2sd xmm1, DWORD PTR _Vitality$[ebp]
  001a0	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fd3333333333333
  001a8	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001ac	f2 0f 2a 4d f0	 cvtsi2sd xmm1, DWORD PTR _Energy$[ebp]
  001b1	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3ff0000000000000
  001b9	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001bd	f2 0f 2c c0	 cvttsd2si eax, xmm0
  001c1	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ce	89 84 0a ec 00
	00 00		 mov	 DWORD PTR [edx+ecx+236], eax

; 2932 : 		break;

  001d5	e9 20 01 00 00	 jmp	 $LN2@gObjSetBP
$LN6@gObjSetBP:

; 2933 : 
; 2934 : 		case CLASS_ELF:
; 2935 : 			gObj[aIndex].MaxBP = Strength*0.3+Dexterity*0.2+Vitality*0.3+Energy*0.2;

  001da	f2 0f 2a 45 fc	 cvtsi2sd xmm0, DWORD PTR _Strength$[ebp]
  001df	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fd3333333333333
  001e7	f2 0f 2a 4d f8	 cvtsi2sd xmm1, DWORD PTR _Dexterity$[ebp]
  001ec	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fc999999999999a
  001f4	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001f8	f2 0f 2a 4d f4	 cvtsi2sd xmm1, DWORD PTR _Vitality$[ebp]
  001fd	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fd3333333333333
  00205	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00209	f2 0f 2a 4d f0	 cvtsi2sd xmm1, DWORD PTR _Energy$[ebp]
  0020e	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fc999999999999a
  00216	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0021a	f2 0f 2c c0	 cvttsd2si eax, xmm0
  0021e	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00225	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0022b	89 84 0a ec 00
	00 00		 mov	 DWORD PTR [edx+ecx+236], eax

; 2936 : 		break;

  00232	e9 c3 00 00 00	 jmp	 $LN2@gObjSetBP
$LN7@gObjSetBP:

; 2937 : 
; 2938 : 		case CLASS_MAGUMSA:
; 2939 : 			gObj[aIndex].MaxBP = Strength*0.2+Dexterity*0.25+Vitality*0.3+Energy*0.15;

  00237	f2 0f 2a 45 fc	 cvtsi2sd xmm0, DWORD PTR _Strength$[ebp]
  0023c	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fc999999999999a
  00244	f2 0f 2a 4d f8	 cvtsi2sd xmm1, DWORD PTR _Dexterity$[ebp]
  00249	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fd0000000000000
  00251	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00255	f2 0f 2a 4d f4	 cvtsi2sd xmm1, DWORD PTR _Vitality$[ebp]
  0025a	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fd3333333333333
  00262	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00266	f2 0f 2a 4d f0	 cvtsi2sd xmm1, DWORD PTR _Energy$[ebp]
  0026b	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fc3333333333333
  00273	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00277	f2 0f 2c c0	 cvttsd2si eax, xmm0
  0027b	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00282	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00288	89 84 0a ec 00
	00 00		 mov	 DWORD PTR [edx+ecx+236], eax

; 2940 : 		break;

  0028f	eb 69		 jmp	 SHORT $LN2@gObjSetBP
$LN8@gObjSetBP:

; 2941 : 
; 2942 : #ifdef DARKLORD_WORK
; 2943 : 		case CLASS_DARKLORD:
; 2944 : 			gObj[aIndex].MaxBP = Strength*0.3+Dexterity*0.2+Vitality*0.1+Energy*0.15+Leadership*0.3;

  00291	f2 0f 2a 45 fc	 cvtsi2sd xmm0, DWORD PTR _Strength$[ebp]
  00296	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fd3333333333333
  0029e	f2 0f 2a 4d f8	 cvtsi2sd xmm1, DWORD PTR _Dexterity$[ebp]
  002a3	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fc999999999999a
  002ab	f2 0f 58 c1	 addsd	 xmm0, xmm1
  002af	f2 0f 2a 4d f4	 cvtsi2sd xmm1, DWORD PTR _Vitality$[ebp]
  002b4	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fb999999999999a
  002bc	f2 0f 58 c1	 addsd	 xmm0, xmm1
  002c0	f2 0f 2a 4d f0	 cvtsi2sd xmm1, DWORD PTR _Energy$[ebp]
  002c5	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fc3333333333333
  002cd	f2 0f 58 c1	 addsd	 xmm0, xmm1
  002d1	f2 0f 2a 4d ec	 cvtsi2sd xmm1, DWORD PTR _Leadership$[ebp]
  002d6	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fd3333333333333
  002de	f2 0f 58 c1	 addsd	 xmm0, xmm1
  002e2	f2 0f 2c c0	 cvttsd2si eax, xmm0
  002e6	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  002ed	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002f3	89 84 0a ec 00
	00 00		 mov	 DWORD PTR [edx+ecx+236], eax
$LN2@gObjSetBP:

; 2945 : 		break;	
; 2946 : #endif
; 2947 : 
; 2948 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//  AG 
; 2949 : 		case CLASS_SUMMONER:
; 2950 : 			gObj[aIndex].MaxBP = Strength*0.2+Dexterity*0.25+Vitality*0.3+Energy*0.15;
; 2951 : 		break;	
; 2952 : #endif
; 2953 : 	}
; 2954 : }

  002fa	5f		 pop	 edi
  002fb	5e		 pop	 esi
  002fc	5b		 pop	 ebx
  002fd	8b e5		 mov	 esp, ebp
  002ff	5d		 pop	 ebp
  00300	c3		 ret	 0
  00301	0f 1f 00	 npad	 3
$LN10@gObjSetBP:
  00304	00 00 00 00	 DD	 $LN4@gObjSetBP
  00308	00 00 00 00	 DD	 $LN5@gObjSetBP
  0030c	00 00 00 00	 DD	 $LN6@gObjSetBP
  00310	00 00 00 00	 DD	 $LN7@gObjSetBP
  00314	00 00 00 00	 DD	 $LN8@gObjSetBP
?gObjSetBP@@YAXH@Z ENDP					; gObjSetBP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjUseCircle@@YAXHH@Z
_TEXT	SEGMENT
tv248 = -100						; size = 4
_AddStat$1 = -32					; size = 4
_incvalue$ = -28					; size = 4
_iSuccessRate$ = -24					; size = 4
_MaxAddPoint$ = -20					; size = 2
_AddPoint$ = -16					; size = 2
_pResult$ = -12						; size = 4
_iSerial$ = -8						; size = 4
_level$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_pos$ = 12						; size = 4
?gObjUseCircle@@YAXHH@Z PROC				; gObjUseCircle, COMDAT

; 30360: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 30361: 	int level = gObj[aIndex].pInventory[pos].m_Level;

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 168
  00017	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0001d	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00024	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  00029	89 4d fc	 mov	 DWORD PTR _level$[ebp], ecx

; 30362: 	int iSerial = gObj[aIndex].pInventory[pos].m_Number;

  0002c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00033	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 168
  0003a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00040	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00047	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0004a	89 4d f8	 mov	 DWORD PTR _iSerial$[ebp], ecx

; 30363: 
; 30364: 	PMSG_DEFRESULT	pResult;
; 30365: 	PHeadSetB((LPBYTE)&pResult, 0x2c, sizeof( pResult ));

  0004d	6a 04		 push	 4
  0004f	6a 2c		 push	 44			; 0000002cH
  00051	8d 45 f4	 lea	 eax, DWORD PTR _pResult$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 30366: 	pResult.result = 0;

  0005d	c6 45 f7 00	 mov	 BYTE PTR _pResult$[ebp+3], 0

; 30367: 
; 30368: 	if( gObj[aIndex].Level <= 10 || level > 3 )

  00061	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00068	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006e	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  00076	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00079	7e 06		 jle	 SHORT $LN5@gObjUseCir
  0007b	83 7d fc 03	 cmp	 DWORD PTR _level$[ebp], 3
  0007f	7e 26		 jle	 SHORT $LN4@gObjUseCir
$LN5@gObjUseCir:

; 30369: 	{	//  5  
; 30370: 		pResult.result |= (0x03<<6);

  00081	0f b6 45 f7	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
  00085	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  0008a	88 45 f7	 mov	 BYTE PTR _pResult$[ebp+3], al

; 30371: 		DataSend( aIndex, (LPBYTE)&pResult, pResult.h.size);

  0008d	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  00091	50		 push	 eax
  00092	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  00095	51		 push	 ecx
  00096	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00099	52		 push	 edx
  0009a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0009f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 30372: 		return;

  000a2	e9 31 05 00 00	 jmp	 $LN1@gObjUseCir
$LN4@gObjUseCir:

; 30373: 	}
; 30374: 
; 30375: 	if( !gObjCheckStatPointUp(aIndex) )

  000a7	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ?gObjCheckStatPointUp@@YAHH@Z ; gObjCheckStatPointUp
  000b0	83 c4 04	 add	 esp, 4
  000b3	85 c0		 test	 eax, eax
  000b5	75 26		 jne	 SHORT $LN6@gObjUseCir

; 30376: 	{	//    
; 30377: 		pResult.result |= (0x03<<6);

  000b7	0f b6 45 f7	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
  000bb	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  000c0	88 45 f7	 mov	 BYTE PTR _pResult$[ebp+3], al

; 30378: 		DataSend( aIndex, (LPBYTE)&pResult, pResult.h.size);

  000c3	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  000c7	50		 push	 eax
  000c8	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  000cb	51		 push	 ecx
  000cc	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000cf	52		 push	 edx
  000d0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 30379: 		return;

  000d8	e9 fb 04 00 00	 jmp	 $LN1@gObjUseCir
$LN6@gObjUseCir:

; 30380: 	}
; 30381: 		
; 30382: 	//  
; 30383: 
; 30384: #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 30385: 	LogAddTD("[StatUp] [%s][%s] Use StatUpItem Level:%d Pos:%d serial:%u", 
; 30386: #else
; 30387: 	LogAddTD("[StatUp] [%s][%s] Use StatUpItem Level:%d Pos:%d serial:%d", 

  000dd	8b 45 f8	 mov	 eax, DWORD PTR _iSerial$[ebp]
  000e0	50		 push	 eax
  000e1	8b 4d 0c	 mov	 ecx, DWORD PTR _pos$[ebp]
  000e4	51		 push	 ecx
  000e5	8b 55 fc	 mov	 edx, DWORD PTR _level$[ebp]
  000e8	52		 push	 edx
  000e9	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f6	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000fa	52		 push	 edx
  000fb	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00102	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00108	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0010c	52		 push	 edx
  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GGMAOOIG@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Use?5StatUpIte@
  00112	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00118	83 c4 18	 add	 esp, 24			; 00000018H

; 30388: #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 30389: 			 gObj[aIndex].AccountID, gObj[aIndex].Name, 
; 30390: 			 level, pos, iSerial);
; 30391: 
; 30392: 	gObjInventoryItemSet(aIndex, pos, 0xFF);

  0011b	68 ff 00 00 00	 push	 255			; 000000ffH
  00120	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  00123	50		 push	 eax
  00124	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00127	51		 push	 ecx
  00128	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  0012d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 30393: 	gObj[aIndex].pInventory[pos].Clear();

  00130	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00137	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$[ebp], 168
  0013e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00144	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  0014b	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 30394: 	GCInventoryItemDeleteSend(aIndex, pos, 1);

  00150	6a 01		 push	 1
  00152	0f b6 45 0c	 movzx	 eax, BYTE PTR _pos$[ebp]
  00156	50		 push	 eax
  00157	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0015a	51		 push	 ecx
  0015b	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00160	83 c4 0c	 add	 esp, 12			; 0000000cH

; 30395: 
; 30396: 
; 30397: 	short	AddPoint, MaxAddPoint;
; 30398: 	
; 30399: #ifdef ADD_MINUS_STAT_SYSTEM_USING_FRUIT_20050712
; 30400: 	short	MinusPoint;
; 30401: 	short	MaxMinusPoint;
; 30402: 	gObjGetStatPointState(aIndex, AddPoint, MaxAddPoint, MinusPoint, MaxMinusPoint);
; 30403: #else
; 30404: 	gObjGetStatPointState(aIndex, AddPoint, MaxAddPoint);

  00163	8d 45 ec	 lea	 eax, DWORD PTR _MaxAddPoint$[ebp]
  00166	50		 push	 eax
  00167	8d 4d f0	 lea	 ecx, DWORD PTR _AddPoint$[ebp]
  0016a	51		 push	 ecx
  0016b	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0016e	52		 push	 edx
  0016f	e8 00 00 00 00	 call	 ?gObjGetStatPointState@@YAXHAAF0@Z ; gObjGetStatPointState
  00174	83 c4 0c	 add	 esp, 12			; 0000000cH

; 30405: #endif
; 30406: 
; 30407: 	int iSuccessRate = 0;;

  00177	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 0

; 30408: 
; 30409: 	if( AddPoint <= 10 )

  0017e	0f bf 45 f0	 movsx	 eax, WORD PTR _AddPoint$[ebp]
  00182	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00185	7f 0c		 jg	 SHORT $LN7@gObjUseCir

; 30410: 	{	// 10  100%
; 30411: 		iSuccessRate = 100;

  00187	c7 45 e8 64 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 100 ; 00000064H

; 30412: 	}

  0018e	e9 b2 00 00 00	 jmp	 $LN16@gObjUseCir
$LN7@gObjUseCir:

; 30413: 	else if( (AddPoint-10) < MaxAddPoint*0.1 )

  00193	0f bf 45 f0	 movsx	 eax, WORD PTR _AddPoint$[ebp]
  00197	83 e8 0a	 sub	 eax, 10			; 0000000aH
  0019a	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  0019e	0f bf 4d ec	 movsx	 ecx, WORD PTR _MaxAddPoint$[ebp]
  001a2	f2 0f 2a c9	 cvtsi2sd xmm1, ecx
  001a6	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fb999999999999a
  001ae	66 0f 2f c8	 comisd	 xmm1, xmm0
  001b2	76 0c		 jbe	 SHORT $LN9@gObjUseCir

; 30414: 	{
; 30415: 		iSuccessRate = 90;

  001b4	c7 45 e8 5a 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 90 ; 0000005aH

; 30416: 	}

  001bb	e9 85 00 00 00	 jmp	 $LN16@gObjUseCir
$LN9@gObjUseCir:

; 30417: 	else if( (AddPoint-10) < MaxAddPoint*0.3 )

  001c0	0f bf 45 f0	 movsx	 eax, WORD PTR _AddPoint$[ebp]
  001c4	83 e8 0a	 sub	 eax, 10			; 0000000aH
  001c7	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  001cb	0f bf 4d ec	 movsx	 ecx, WORD PTR _MaxAddPoint$[ebp]
  001cf	f2 0f 2a c9	 cvtsi2sd xmm1, ecx
  001d3	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fd3333333333333
  001db	66 0f 2f c8	 comisd	 xmm1, xmm0
  001df	76 09		 jbe	 SHORT $LN11@gObjUseCir

; 30418: 	{
; 30419: 		iSuccessRate = 80;

  001e1	c7 45 e8 50 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 80 ; 00000050H

; 30420: 	}

  001e8	eb 5b		 jmp	 SHORT $LN16@gObjUseCir
$LN11@gObjUseCir:

; 30421: 	else if( (AddPoint-10) < MaxAddPoint*0.5 )

  001ea	0f bf 45 f0	 movsx	 eax, WORD PTR _AddPoint$[ebp]
  001ee	83 e8 0a	 sub	 eax, 10			; 0000000aH
  001f1	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  001f5	0f bf 4d ec	 movsx	 ecx, WORD PTR _MaxAddPoint$[ebp]
  001f9	f2 0f 2a c9	 cvtsi2sd xmm1, ecx
  001fd	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fe0000000000000
  00205	66 0f 2f c8	 comisd	 xmm1, xmm0
  00209	76 09		 jbe	 SHORT $LN13@gObjUseCir

; 30422: 	{
; 30423: 		iSuccessRate = 70;

  0020b	c7 45 e8 46 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 70 ; 00000046H

; 30424: 	}

  00212	eb 31		 jmp	 SHORT $LN16@gObjUseCir
$LN13@gObjUseCir:

; 30425: 	else if( (AddPoint-10) < MaxAddPoint*0.8 )

  00214	0f bf 45 f0	 movsx	 eax, WORD PTR _AddPoint$[ebp]
  00218	83 e8 0a	 sub	 eax, 10			; 0000000aH
  0021b	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  0021f	0f bf 4d ec	 movsx	 ecx, WORD PTR _MaxAddPoint$[ebp]
  00223	f2 0f 2a c9	 cvtsi2sd xmm1, ecx
  00227	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fe999999999999a
  0022f	66 0f 2f c8	 comisd	 xmm1, xmm0
  00233	76 09		 jbe	 SHORT $LN15@gObjUseCir

; 30426: 	{
; 30427: 		iSuccessRate = 60;

  00235	c7 45 e8 3c 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 60 ; 0000003cH

; 30428: 	}

  0023c	eb 07		 jmp	 SHORT $LN16@gObjUseCir
$LN15@gObjUseCir:

; 30429: 	else
; 30430: 	{
; 30431: 		iSuccessRate = 50;

  0023e	c7 45 e8 32 00
	00 00		 mov	 DWORD PTR _iSuccessRate$[ebp], 50 ; 00000032H
$LN16@gObjUseCir:

; 30432: 	}
; 30433: 	
; 30434: 	int incvalue = 0;

  00245	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _incvalue$[ebp], 0

; 30435: 
; 30436: 	if( (rand()%100) < iSuccessRate )

  0024c	e8 00 00 00 00	 call	 _rand
  00251	99		 cdq
  00252	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00257	f7 f9		 idiv	 ecx
  00259	3b 55 e8	 cmp	 edx, DWORD PTR _iSuccessRate$[ebp]
  0025c	0f 8d c6 00 00
	00		 jge	 $LN17@gObjUseCir

; 30437: 	{	//  ( )
; 30438: 		iSuccessRate = rand()%100;

  00262	e8 00 00 00 00	 call	 _rand
  00267	99		 cdq
  00268	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0026d	f7 f9		 idiv	 ecx
  0026f	89 55 e8	 mov	 DWORD PTR _iSuccessRate$[ebp], edx

; 30439: 		int AddStat =  0;

  00272	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _AddStat$1[ebp], 0

; 30440: 		if( iSuccessRate < 70 )

  00279	83 7d e8 46	 cmp	 DWORD PTR _iSuccessRate$[ebp], 70 ; 00000046H
  0027d	7d 09		 jge	 SHORT $LN19@gObjUseCir

; 30441: 		{	// 1 
; 30442: 			AddStat = 1;

  0027f	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _AddStat$1[ebp], 1

; 30443: 		}

  00286	eb 16		 jmp	 SHORT $LN22@gObjUseCir
$LN19@gObjUseCir:

; 30444: 		else if( iSuccessRate < 95 )

  00288	83 7d e8 5f	 cmp	 DWORD PTR _iSuccessRate$[ebp], 95 ; 0000005fH
  0028c	7d 09		 jge	 SHORT $LN21@gObjUseCir

; 30445: 		{	// 2 
; 30446: 			AddStat = 2;

  0028e	c7 45 e0 02 00
	00 00		 mov	 DWORD PTR _AddStat$1[ebp], 2

; 30447: 		}		

  00295	eb 07		 jmp	 SHORT $LN22@gObjUseCir
$LN21@gObjUseCir:

; 30448: 		else
; 30449: 		{
; 30450: 			AddStat = 3;

  00297	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _AddStat$1[ebp], 3
$LN22@gObjUseCir:

; 30451: 		}
; 30452: 
; 30453: 		if( AddStat+AddPoint > MaxAddPoint )

  0029e	0f bf 45 f0	 movsx	 eax, WORD PTR _AddPoint$[ebp]
  002a2	03 45 e0	 add	 eax, DWORD PTR _AddStat$1[ebp]
  002a5	0f bf 4d ec	 movsx	 ecx, WORD PTR _MaxAddPoint$[ebp]
  002a9	3b c1		 cmp	 eax, ecx
  002ab	7e 07		 jle	 SHORT $LN23@gObjUseCir

; 30454: 		{
; 30455: 			AddStat = 1;

  002ad	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _AddStat$1[ebp], 1
$LN23@gObjUseCir:

; 30456: 		}
; 30457: 
; 30458: 		//pResult.result |= (0x00<<6);
; 30459: 		//  
; 30460: 		pResult.result |= (level<<4);

  002b4	8b 45 fc	 mov	 eax, DWORD PTR _level$[ebp]
  002b7	c1 e0 04	 shl	 eax, 4
  002ba	0f b6 4d f7	 movzx	 ecx, BYTE PTR _pResult$[ebp+3]
  002be	0b c8		 or	 ecx, eax
  002c0	88 4d f7	 mov	 BYTE PTR _pResult$[ebp+3], cl

; 30461: 		pResult.result |= AddStat;

  002c3	0f b6 45 f7	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
  002c7	0b 45 e0	 or	 eax, DWORD PTR _AddStat$1[ebp]
  002ca	88 45 f7	 mov	 BYTE PTR _pResult$[ebp+3], al

; 30462: 		DataSend( aIndex, (LPBYTE)&pResult, pResult.h.size);

  002cd	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  002d1	50		 push	 eax
  002d2	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  002d5	51		 push	 ecx
  002d6	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  002d9	52		 push	 edx
  002da	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 30463: 		incvalue = AddStat;

  002e2	8b 45 e0	 mov	 eax, DWORD PTR _AddStat$1[ebp]
  002e5	89 45 e4	 mov	 DWORD PTR _incvalue$[ebp], eax

; 30464: #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 30465: 		LogAddTD("[StatUp] [%s][%s] Success [%d][%d] %u", gObj[aIndex].AccountID, gObj[aIndex].Name, level, incvalue, iSerial);
; 30466: #else
; 30467: 		LogAddTD("[StatUp] [%s][%s] Success [%d][%d] %d", gObj[aIndex].AccountID, gObj[aIndex].Name, level, incvalue, iSerial);

  002e8	8b 45 f8	 mov	 eax, DWORD PTR _iSerial$[ebp]
  002eb	50		 push	 eax
  002ec	8b 4d e4	 mov	 ecx, DWORD PTR _incvalue$[ebp]
  002ef	51		 push	 ecx
  002f0	8b 55 fc	 mov	 edx, DWORD PTR _level$[ebp]
  002f3	52		 push	 edx
  002f4	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00301	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00305	52		 push	 edx
  00306	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0030d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00313	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00317	52		 push	 edx
  00318	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KNEHLHCP@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Success?5?$FL?$CFd?$FN?$FL@
  0031d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00323	83 c4 18	 add	 esp, 24			; 00000018H

; 30468: #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 30469: 	}

  00326	eb 71		 jmp	 SHORT $LN18@gObjUseCir
$LN17@gObjUseCir:

; 30470: 	else
; 30471: 	{	//    	
; 30472: 		pResult.result |= (0x01<<6);

  00328	0f b6 45 f7	 movzx	 eax, BYTE PTR _pResult$[ebp+3]
  0032c	83 c8 40	 or	 eax, 64			; 00000040H
  0032f	88 45 f7	 mov	 BYTE PTR _pResult$[ebp+3], al

; 30473: 		//  
; 30474: 		pResult.result |= (level<<4);		

  00332	8b 45 fc	 mov	 eax, DWORD PTR _level$[ebp]
  00335	c1 e0 04	 shl	 eax, 4
  00338	0f b6 4d f7	 movzx	 ecx, BYTE PTR _pResult$[ebp+3]
  0033c	0b c8		 or	 ecx, eax
  0033e	88 4d f7	 mov	 BYTE PTR _pResult$[ebp+3], cl

; 30475: 		pResult.result |= 0;

  00341	8a 45 f7	 mov	 al, BYTE PTR _pResult$[ebp+3]
  00344	88 45 f7	 mov	 BYTE PTR _pResult$[ebp+3], al

; 30476: 		DataSend( aIndex, (LPBYTE)&pResult, pResult.h.size);

  00347	0f b6 45 f5	 movzx	 eax, BYTE PTR _pResult$[ebp+1]
  0034b	50		 push	 eax
  0034c	8d 4d f4	 lea	 ecx, DWORD PTR _pResult$[ebp]
  0034f	51		 push	 ecx
  00350	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00353	52		 push	 edx
  00354	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00359	83 c4 0c	 add	 esp, 12			; 0000000cH

; 30477: #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 30478: 		LogAddTD("[StatUp] [%s][%s] Fail [%d] %u", gObj[aIndex].AccountID, gObj[aIndex].Name, level, iSerial);
; 30479: #else
; 30480: 		LogAddTD("[StatUp] [%s][%s] Fail [%d] %d", gObj[aIndex].AccountID, gObj[aIndex].Name, level, iSerial);

  0035c	8b 45 f8	 mov	 eax, DWORD PTR _iSerial$[ebp]
  0035f	50		 push	 eax
  00360	8b 4d fc	 mov	 ecx, DWORD PTR _level$[ebp]
  00363	51		 push	 ecx
  00364	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0036b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00370	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00374	51		 push	 ecx
  00375	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0037c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00381	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00385	51		 push	 ecx
  00386	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DLHDMMOD@?$FLStatUp?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Fail?5?$FL?$CFd?$FN?5?$CFd@
  0038b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00391	83 c4 14	 add	 esp, 20			; 00000014H

; 30481: #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 30482: 		return;

  00394	e9 3f 02 00 00	 jmp	 $LN1@gObjUseCir
$LN18@gObjUseCir:

; 30483: 	}	
; 30484: 
; 30485: 	switch( level )

  00399	8b 45 fc	 mov	 eax, DWORD PTR _level$[ebp]
  0039c	89 45 9c	 mov	 DWORD PTR tv248[ebp], eax
  0039f	83 7d 9c 03	 cmp	 DWORD PTR tv248[ebp], 3
  003a3	0f 87 23 02 00
	00		 ja	 $LN2@gObjUseCir
  003a9	8b 4d 9c	 mov	 ecx, DWORD PTR tv248[ebp]
  003ac	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN29@gObjUseCir[ecx*4]
$LN24@gObjUseCir:

; 30486: 	{
; 30487: 	case 3 : // 
; 30488: 		gObj[aIndex].Strength += incvalue;

  003b3	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003c0	0f b7 94 01 b4
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+180]
  003c8	03 55 e4	 add	 edx, DWORD PTR _incvalue$[ebp]
  003cb	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003d8	66 89 94 01 b4
	00 00 00	 mov	 WORD PTR [ecx+eax+180], dx

; 30489: 		break;

  003e0	e9 e7 01 00 00	 jmp	 $LN2@gObjUseCir
$LN25@gObjUseCir:

; 30490: 	case 2 : // 
; 30491: 		gObj[aIndex].Dexterity += incvalue;

  003e5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003f2	0f b7 94 01 b6
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+182]
  003fa	03 55 e4	 add	 edx, DWORD PTR _incvalue$[ebp]
  003fd	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00404	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0040a	66 89 94 01 b6
	00 00 00	 mov	 WORD PTR [ecx+eax+182], dx

; 30492: 		break;

  00412	e9 b5 01 00 00	 jmp	 $LN2@gObjUseCir
$LN26@gObjUseCir:

; 30493: 	case 1 : // 
; 30494: 		gObj[aIndex].Vitality += incvalue;

  00417	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0041e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00424	0f b7 94 01 b8
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+184]
  0042c	03 55 e4	 add	 edx, DWORD PTR _incvalue$[ebp]
  0042f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00436	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0043c	66 89 94 01 b8
	00 00 00	 mov	 WORD PTR [ecx+eax+184], dx

; 30495: 		gObj[aIndex].MaxLife += (gObj[aIndex].VitalityToLife*incvalue);

  00444	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0044b	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00452	f3 0f 2a 45 e4	 cvtsi2ss xmm0, DWORD PTR _incvalue$[ebp]
  00457	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0045d	f3 0f 59 84 0a
	f4 00 00 00	 mulss	 xmm0, DWORD PTR [edx+ecx+244]
  00466	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0046c	f3 0f 58 84 01
	c0 00 00 00	 addss	 xmm0, DWORD PTR [ecx+eax+192]
  00475	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0047c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00481	f3 0f 11 84 10
	c0 00 00 00	 movss	 DWORD PTR [eax+edx+192], xmm0

; 30496: #ifdef ADD_SHIELD_POINT_01_20060403
; 30497: 		GCReFillSend(gObj[aIndex].m_Index, (WORD)(gObj[aIndex].MaxLife+gObj[aIndex].AddLife), 0xFE, 0, (WORD)(gObj[aIndex].iMaxShield+gObj[aIndex].iAddShield));
; 30498: #else
; 30499: 		GCReFillSend(gObj[aIndex].m_Index, (WORD)(gObj[aIndex].MaxLife+gObj[aIndex].AddLife), 0xFE, 0);

  0048a	6a 00		 push	 0
  0048c	68 fe 00 00 00	 push	 254			; 000000feH
  00491	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00498	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0049f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004a5	f3 0f 2a 84 0a
	0c 01 00 00	 cvtsi2ss xmm0, DWORD PTR [edx+ecx+268]
  004ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004b4	f3 0f 58 84 01
	c0 00 00 00	 addss	 xmm0, DWORD PTR [ecx+eax+192]
  004bd	f3 0f 2c d0	 cvttss2si edx, xmm0
  004c1	0f b7 c2	 movzx	 eax, dx
  004c4	50		 push	 eax
  004c5	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  004cc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004d2	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  004d5	50		 push	 eax
  004d6	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  004db	83 c4 10	 add	 esp, 16			; 00000010H

; 30500: #endif
; 30501: 		break;

  004de	e9 e9 00 00 00	 jmp	 $LN2@gObjUseCir
$LN27@gObjUseCir:

; 30502: 	case 0 : // 
; 30503: 		gObj[aIndex].Energy += incvalue;

  004e3	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  004ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004f0	0f b7 94 01 ba
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+186]
  004f8	03 55 e4	 add	 edx, DWORD PTR _incvalue$[ebp]
  004fb	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00502	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00508	66 89 94 01 ba
	00 00 00	 mov	 WORD PTR [ecx+eax+186], dx

; 30504: 		gObj[aIndex].MaxMana += (gObj[aIndex].EnergyToMana*incvalue);

  00510	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00517	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0051e	f3 0f 2a 45 e4	 cvtsi2ss xmm0, DWORD PTR _incvalue$[ebp]
  00523	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00529	f3 0f 59 84 0a
	f8 00 00 00	 mulss	 xmm0, DWORD PTR [edx+ecx+248]
  00532	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00538	f3 0f 58 84 01
	d4 00 00 00	 addss	 xmm0, DWORD PTR [ecx+eax+212]
  00541	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00548	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0054d	f3 0f 11 84 10
	d4 00 00 00	 movss	 DWORD PTR [eax+edx+212], xmm0

; 30505: 
; 30506: #ifdef NEW_FORSKYLAND2
; 30507: 		gObjSetBP(aIndex);

  00556	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00559	50		 push	 eax
  0055a	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP
  0055f	83 c4 04	 add	 esp, 4

; 30508: 		GCManaSend(gObj[aIndex].m_Index, (short)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana), 0xFE, 0, gObj[aIndex].MaxBP);

  00562	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00569	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0056f	0f b7 94 01 ec
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+236]
  00577	52		 push	 edx
  00578	6a 00		 push	 0
  0057a	68 fe 00 00 00	 push	 254			; 000000feH
  0057f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00586	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0058d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00593	f3 0f 2a 84 0a
	10 01 00 00	 cvtsi2ss xmm0, DWORD PTR [edx+ecx+272]
  0059c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005a2	f3 0f 58 84 01
	d4 00 00 00	 addss	 xmm0, DWORD PTR [ecx+eax+212]
  005ab	f3 0f 2c d0	 cvttss2si edx, xmm0
  005af	0f b7 c2	 movzx	 eax, dx
  005b2	50		 push	 eax
  005b3	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  005ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005c0	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  005c3	50		 push	 eax
  005c4	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  005c9	83 c4 14	 add	 esp, 20			; 00000014H
$LN2@gObjUseCir:

; 30509: #else
; 30510: 		GCManaSend(gObj[aIndex].m_Index, (short)(gObj[aIndex].MaxMana+gObj[aIndex].AddMana), 0xFE, 0, 0);
; 30511: #endif
; 30512: 		break;
; 30513: 	}
; 30514: 	// 
; 30515: 	gObjCalCharacter(aIndex);

  005cc	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  005cf	50		 push	 eax
  005d0	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  005d5	83 c4 04	 add	 esp, 4
$LN1@gObjUseCir:

; 30516: }

  005d8	5f		 pop	 edi
  005d9	5e		 pop	 esi
  005da	5b		 pop	 ebx
  005db	8b e5		 mov	 esp, ebp
  005dd	5d		 pop	 ebp
  005de	c3		 ret	 0
  005df	90		 npad	 1
$LN29@gObjUseCir:
  005e0	00 00 00 00	 DD	 $LN27@gObjUseCir
  005e4	00 00 00 00	 DD	 $LN26@gObjUseCir
  005e8	00 00 00 00	 DD	 $LN25@gObjUseCir
  005ec	00 00 00 00	 DD	 $LN24@gObjUseCir
?gObjUseCircle@@YAXHH@Z ENDP				; gObjUseCircle
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjDelteItemCountInInventory@@YAXHHHH@Z
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_delcount$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_itemtype$ = 12						; size = 4
_itemindex$ = 16					; size = 4
_count$ = 20						; size = 4
?gObjDelteItemCountInInventory@@YAXHHHH@Z PROC		; gObjDelteItemCountInInventory, COMDAT

; 30106: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 30107: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 30108: 	int delcount = 0;

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _delcount$[ebp], 0

; 30109: 	for(int  n=0; n<MAX_INVENTORY; n++)

  00020	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00027	eb 09		 jmp	 SHORT $LN4@gObjDelteI
$LN2@gObjDelteI:
  00029	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjDelteI:
  00032	83 7d f4 4c	 cmp	 DWORD PTR _n$1[ebp], 76	; 0000004cH
  00036	0f 8d aa 00 00
	00		 jge	 $LN1@gObjDelteI

; 30110: 	{
; 30111: 		if( lpObj->pInventory[n].IsItem() == TRUE )

  0003c	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00043	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00046	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0004c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00051	83 f8 01	 cmp	 eax, 1
  00054	0f 85 87 00 00
	00		 jne	 $LN5@gObjDelteI

; 30112: 		{
; 30113: 			if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(itemtype,itemindex) )

  0005a	69 45 f4 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00061	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00064	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0006a	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  0006f	8b 45 10	 mov	 eax, DWORD PTR _itemindex$[ebp]
  00072	50		 push	 eax
  00073	8b 4d 0c	 mov	 ecx, DWORD PTR _itemtype$[ebp]
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0007c	83 c4 08	 add	 esp, 8
  0007f	3b f0		 cmp	 esi, eax
  00081	75 5e		 jne	 SHORT $LN5@gObjDelteI

; 30114: 			{
; 30115: 				gObjInventoryDeleteItem(aIndex, n);				

  00083	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  00086	50		 push	 eax
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00090	83 c4 08	 add	 esp, 8

; 30116: 				GCInventoryItemDeleteSend(aIndex, n, 1);

  00093	6a 01		 push	 1
  00095	0f b6 45 f4	 movzx	 eax, BYTE PTR _n$1[ebp]
  00099	50		 push	 eax
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 30117: 
; 30118: 				LogAddTD("[DeleteItem] [%s][%s] Delete (%d,%d)(%d)", 

  000a6	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  000a9	50		 push	 eax
  000aa	8b 4d 10	 mov	 ecx, DWORD PTR _itemindex$[ebp]
  000ad	51		 push	 ecx
  000ae	8b 55 0c	 mov	 edx, DWORD PTR _itemtype$[ebp]
  000b1	52		 push	 edx
  000b2	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b5	83 c0 73	 add	 eax, 115		; 00000073H
  000b8	50		 push	 eax
  000b9	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000bc	83 c1 68	 add	 ecx, 104		; 00000068H
  000bf	51		 push	 ecx
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@FBOHLINL@?$FLDeleteItem?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5?$CI?$CF@
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000cb	83 c4 18	 add	 esp, 24			; 00000018H

; 30119: 						 lpObj->AccountID, lpObj->Name, 
; 30120: 						 itemtype,itemindex, n);
; 30121: 
; 30122: 				delcount++;

  000ce	8b 45 f8	 mov	 eax, DWORD PTR _delcount$[ebp]
  000d1	83 c0 01	 add	 eax, 1
  000d4	89 45 f8	 mov	 DWORD PTR _delcount$[ebp], eax

; 30123: 
; 30124: 				if( delcount >= count )

  000d7	8b 45 f8	 mov	 eax, DWORD PTR _delcount$[ebp]
  000da	3b 45 14	 cmp	 eax, DWORD PTR _count$[ebp]
  000dd	7c 02		 jl	 SHORT $LN5@gObjDelteI

; 30125: 				{
; 30126: 					return;

  000df	eb 05		 jmp	 SHORT $LN1@gObjDelteI
$LN5@gObjDelteI:

; 30127: 				}
; 30128: 			}
; 30129: 		}
; 30130: 	}	

  000e1	e9 43 ff ff ff	 jmp	 $LN2@gObjDelteI
$LN1@gObjDelteI:

; 30131: }

  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c3		 ret	 0
?gObjDelteItemCountInInventory@@YAXHHHH@Z ENDP		; gObjDelteItemCountInInventory
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGetManaItemPos@@YAHH@Z
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_count$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjGetManaItemPos@@YAHH@Z PROC			; gObjGetManaItemPos, COMDAT

; 30087: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 30088: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 30089: 	int count = 0;

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 30090: 	for(int  n=0; n<MAX_INVENTORY; n++)

  00020	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00027	eb 09		 jmp	 SHORT $LN4@gObjGetMan
$LN2@gObjGetMan:
  00029	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjGetMan:
  00032	83 7d f4 4c	 cmp	 DWORD PTR _n$1[ebp], 76	; 0000004cH
  00036	0f 8d 93 00 00
	00		 jge	 $LN3@gObjGetMan

; 30091: 	{
; 30092: 		if( lpObj->pInventory[n].IsItem() == TRUE )

  0003c	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00043	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00046	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0004c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00051	83 f8 01	 cmp	 eax, 1
  00054	75 74		 jne	 SHORT $LN5@gObjGetMan

; 30093: 		{
; 30094: 			if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(14,4) || 
; 30095: 				lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(14,5) || 

  00056	69 45 f4 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00060	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00066	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  0006b	6a 04		 push	 4
  0006d	6a 0e		 push	 14			; 0000000eH
  0006f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00074	83 c4 08	 add	 esp, 8
  00077	3b f0		 cmp	 esi, eax
  00079	74 4a		 je	 SHORT $LN7@gObjGetMan
  0007b	69 45 f4 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00085	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0008b	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00090	6a 05		 push	 5
  00092	6a 0e		 push	 14			; 0000000eH
  00094	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00099	83 c4 08	 add	 esp, 8
  0009c	3b f0		 cmp	 esi, eax
  0009e	74 25		 je	 SHORT $LN7@gObjGetMan
  000a0	69 45 f4 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000aa	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000b0	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000b5	6a 06		 push	 6
  000b7	6a 0e		 push	 14			; 0000000eH
  000b9	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000be	83 c4 08	 add	 esp, 8
  000c1	3b f0		 cmp	 esi, eax
  000c3	75 05		 jne	 SHORT $LN5@gObjGetMan
$LN7@gObjGetMan:

; 30096: 				lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(14,6) )
; 30097: 			{
; 30098: 				return n;

  000c5	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  000c8	eb 08		 jmp	 SHORT $LN1@gObjGetMan
$LN5@gObjGetMan:

; 30099: 			}
; 30100: 		}
; 30101: 	}

  000ca	e9 5a ff ff ff	 jmp	 $LN2@gObjGetMan
$LN3@gObjGetMan:

; 30102: 	return -1;

  000cf	83 c8 ff	 or	 eax, -1
$LN1@gObjGetMan:

; 30103: }

  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
?gObjGetManaItemPos@@YAHH@Z ENDP			; gObjGetManaItemPos
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGetItemCountInIventory@@YAHHH@Z
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_count$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_itemnum$ = 12						; size = 4
?gObjGetItemCountInIventory@@YAHHH@Z PROC		; gObjGetItemCountInIventory, COMDAT

; 30069: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 30070: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 30071: 	int count = 0;

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 30072: 	for(int  n=0; n<MAX_INVENTORY; n++)

  00020	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00027	eb 09		 jmp	 SHORT $LN4@gObjGetIte
$LN2@gObjGetIte:
  00029	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjGetIte:
  00032	83 7d f4 4c	 cmp	 DWORD PTR _n$1[ebp], 76	; 0000004cH
  00036	7d 3f		 jge	 SHORT $LN3@gObjGetIte

; 30073: 	{
; 30074: 		if( lpObj->pInventory[n].IsItem() == TRUE )

  00038	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00042	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00048	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0004d	83 f8 01	 cmp	 eax, 1
  00050	75 23		 jne	 SHORT $LN5@gObjGetIte

; 30075: 		{
; 30076: 			if( lpObj->pInventory[n].m_Type == itemnum )

  00052	69 45 f4 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0005c	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00062	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  00067	3b 45 0c	 cmp	 eax, DWORD PTR _itemnum$[ebp]
  0006a	75 09		 jne	 SHORT $LN5@gObjGetIte

; 30077: 			{
; 30078: 				count++;

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0006f	83 c0 01	 add	 eax, 1
  00072	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN5@gObjGetIte:

; 30079: 			}
; 30080: 		}
; 30081: 	}

  00075	eb b2		 jmp	 SHORT $LN2@gObjGetIte
$LN3@gObjGetIte:

; 30082: 	return count;

  00077	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]

; 30083: }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
?gObjGetItemCountInIventory@@YAHHH@Z ENDP		; gObjGetItemCountInIventory
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGetItemCountInIventory@@YAHHHHH@Z
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_count$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_itemtype$ = 12						; size = 4
_itemindex$ = 16					; size = 4
_itemlevel$ = 20					; size = 4
?gObjGetItemCountInIventory@@YAHHHHH@Z PROC		; gObjGetItemCountInIventory, COMDAT

; 30046: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 30047: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 30048: 	int count = 0;

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 30049: 	for(int  n=0; n<MAX_INVENTORY; n++)

  00020	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00027	eb 09		 jmp	 SHORT $LN4@gObjGetIte
$LN2@gObjGetIte:
  00029	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjGetIte:
  00032	83 7d f4 4c	 cmp	 DWORD PTR _n$1[ebp], 76	; 0000004cH
  00036	7d 70		 jge	 SHORT $LN3@gObjGetIte

; 30050: 	{
; 30051: 		if( lpObj->pInventory[n].IsItem() == TRUE )

  00038	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00042	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00048	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0004d	83 f8 01	 cmp	 eax, 1
  00050	75 54		 jne	 SHORT $LN5@gObjGetIte

; 30052: 		{
; 30053: 			if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(itemtype,itemindex) )

  00052	69 45 f4 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0005c	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00062	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00067	8b 45 10	 mov	 eax, DWORD PTR _itemindex$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d 0c	 mov	 ecx, DWORD PTR _itemtype$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00074	83 c4 08	 add	 esp, 8
  00077	3b f0		 cmp	 esi, eax
  00079	75 2b		 jne	 SHORT $LN5@gObjGetIte

; 30054: 			{
; 30055: #ifdef SECOND_QUEST
; 30056: 				if( itemlevel != -1 && lpObj->pInventory[n].m_Level != itemlevel )

  0007b	83 7d 14 ff	 cmp	 DWORD PTR _itemlevel$[ebp], -1
  0007f	74 1c		 je	 SHORT $LN7@gObjGetIte
  00081	69 45 f4 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00088	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0008b	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00091	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00096	3b 45 14	 cmp	 eax, DWORD PTR _itemlevel$[ebp]
  00099	74 02		 je	 SHORT $LN7@gObjGetIte

; 30057: 				{
; 30058: 					continue;

  0009b	eb 8c		 jmp	 SHORT $LN2@gObjGetIte
$LN7@gObjGetIte:

; 30059: 				}
; 30060: #endif
; 30061: 				count++;

  0009d	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  000a0	83 c0 01	 add	 eax, 1
  000a3	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN5@gObjGetIte:

; 30062: 			}
; 30063: 		}
; 30064: 	}

  000a6	eb 81		 jmp	 SHORT $LN2@gObjGetIte
$LN3@gObjGetIte:

; 30065: 	return count;

  000a8	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]

; 30066: }

  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?gObjGetItemCountInIventory@@YAHHHHH@Z ENDP		; gObjGetItemCountInIventory
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSetPosition@@YAXHHH@Z
_TEXT	SEGMENT
_pMove$ = -12						; size = 5
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?gObjSetPosition@@YAXHHH@Z PROC				; gObjSetPosition, COMDAT

; 29992: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29993: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 29994: 
; 29995: 	PMSG_POSISTION_SET	pMove;
; 29996: 	pMove.h.c		 = PMHC_BYTE;

  00019	c6 45 f4 c1	 mov	 BYTE PTR _pMove$[ebp], 193 ; 000000c1H

; 29997: 
; 29998: #ifdef PACKET_CHANGE	
; 29999: 	pMove.h.headcode = PACKET_POSITION;

  0001d	c6 45 f6 d0	 mov	 BYTE PTR _pMove$[ebp+2], 208 ; 000000d0H

; 30000: #else
; 30001: 	pMove.h.headcode = 0x11;
; 30002: #endif
; 30003: 
; 30004: 	pMove.h.size     = sizeof( pMove );

  00021	c6 45 f5 05	 mov	 BYTE PTR _pMove$[ebp+1], 5

; 30005: 	pMove.X          = (BYTE)x;

  00025	8a 45 0c	 mov	 al, BYTE PTR _x$[ebp]
  00028	88 45 f7	 mov	 BYTE PTR _pMove$[ebp+3], al

; 30006: 	pMove.Y			 = (BYTE)y;

  0002b	8a 45 10	 mov	 al, BYTE PTR _y$[ebp]
  0002e	88 45 f8	 mov	 BYTE PTR _pMove$[ebp+4], al

; 30007: 	lpObj->m_Rest = 0;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00034	c6 80 bd 01 00
	00 00		 mov	 BYTE PTR [eax+445], 0

; 30008: 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003e	0f bf 88 1e 01
	00 00		 movsx	 ecx, WORD PTR [eax+286]
  00045	51		 push	 ecx
  00046	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00049	0f bf 82 1c 01
	00 00		 movsx	 eax, WORD PTR [edx+284]
  00050	50		 push	 eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00054	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0005b	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00061	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00067	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 30009: 	MapC[lpObj->MapNumber].SetStandAttr(x, y);

  0006c	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  00073	51		 push	 ecx
  00074	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00077	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0007e	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00084	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0008a	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 30010: 	lpObj->m_OldX = x;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00092	66 8b 4d 0c	 mov	 cx, WORD PTR _x$[ebp]
  00096	66 89 88 1c 01
	00 00		 mov	 WORD PTR [eax+284], cx

; 30011: 	lpObj->m_OldY = y;

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a0	66 8b 4d 10	 mov	 cx, WORD PTR _y$[ebp]
  000a4	66 89 88 1e 01
	00 00		 mov	 WORD PTR [eax+286], cx

; 30012: 	RecvPositionSetProc(&pMove, lpObj->m_Index);

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	51		 push	 ecx
  000b1	8d 55 f4	 lea	 edx, DWORD PTR _pMove$[ebp]
  000b4	52		 push	 edx
  000b5	e8 00 00 00 00	 call	 ?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ; RecvPositionSetProc
  000ba	83 c4 08	 add	 esp, 8

; 30013: }

  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
?gObjSetPosition@@YAXHHH@Z ENDP				; gObjSetPosition
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjDelete10EventChip@@YAHH@Z
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_count$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjDelete10EventChip@@YAHH@Z PROC			; gObjDelete10EventChip, COMDAT

; 29966: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29967: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 29968: 	int count = 0;

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 29969: 	for(int  n=0; n<MAX_INVENTORY; n++)

  00020	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00027	eb 09		 jmp	 SHORT $LN4@gObjDelete
$LN2@gObjDelete:
  00029	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjDelete:
  00032	83 7d f4 4c	 cmp	 DWORD PTR _n$1[ebp], 76	; 0000004cH
  00036	0f 8d 9d 00 00
	00		 jge	 $LN3@gObjDelete

; 29970: 	{
; 29971: 		if( lpObj->pInventory[n].IsItem() == TRUE )

  0003c	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00043	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00046	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0004c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00051	83 f8 01	 cmp	 eax, 1
  00054	75 7e		 jne	 SHORT $LN5@gObjDelete

; 29972: 		{
; 29973: 			if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(14,21) )

  00056	69 45 f4 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00060	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00066	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  0006b	6a 15		 push	 21			; 00000015H
  0006d	6a 0e		 push	 14			; 0000000eH
  0006f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00074	83 c4 08	 add	 esp, 8
  00077	3b f0		 cmp	 esi, eax
  00079	75 59		 jne	 SHORT $LN5@gObjDelete

; 29974: 			{
; 29975: 				gObjInventoryDeleteItem(aIndex, n);				

  0007b	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00088	83 c4 08	 add	 esp, 8

; 29976: 				GCInventoryItemDeleteSend(aIndex, n, 1);

  0008b	6a 01		 push	 1
  0008d	0f b6 45 f4	 movzx	 eax, BYTE PTR _n$1[ebp]
  00091	50		 push	 eax
  00092	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 29977: 
; 29978: 				LogAddTD("[EventChip] [%s][%s] Delete Rena (%d)", lpObj->AccountID, lpObj->Name, n);

  0009e	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  000a1	50		 push	 eax
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a5	83 c1 73	 add	 ecx, 115		; 00000073H
  000a8	51		 push	 ecx
  000a9	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ac	83 c2 68	 add	 edx, 104		; 00000068H
  000af	52		 push	 edx
  000b0	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@GHIPHJMP@?$FLEventChip?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Delete?5Ren@
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000bb	83 c4 10	 add	 esp, 16			; 00000010H

; 29979: 				count++;

  000be	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  000c1	83 c0 01	 add	 eax, 1
  000c4	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 29980: 				if( count >= 10 )

  000c7	83 7d f8 0a	 cmp	 DWORD PTR _count$[ebp], 10 ; 0000000aH
  000cb	7c 07		 jl	 SHORT $LN5@gObjDelete

; 29981: 				{
; 29982: 					return TRUE;

  000cd	b8 01 00 00 00	 mov	 eax, 1
  000d2	eb 07		 jmp	 SHORT $LN1@gObjDelete
$LN5@gObjDelete:

; 29983: 				}
; 29984: 			}
; 29985: 		}
; 29986: 	}	

  000d4	e9 50 ff ff ff	 jmp	 $LN2@gObjDelete
$LN3@gObjDelete:

; 29987: 	return FALSE;

  000d9	33 c0		 xor	 eax, eax
$LN1@gObjDelete:

; 29988: }

  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c3		 ret	 0
?gObjDelete10EventChip@@YAHH@Z ENDP			; gObjDelete10EventChip
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjFind10EventChip@@YAHH@Z
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_count$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjFind10EventChip@@YAHH@Z PROC			; gObjFind10EventChip, COMDAT

; 29945: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29946: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 29947: 	int count = 0;

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 29948: 	for(int  n=0; n<MAX_INVENTORY; n++)

  00020	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00027	eb 09		 jmp	 SHORT $LN4@gObjFind10
$LN2@gObjFind10:
  00029	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjFind10:
  00032	83 7d f4 4c	 cmp	 DWORD PTR _n$1[ebp], 76	; 0000004cH
  00036	7d 57		 jge	 SHORT $LN3@gObjFind10

; 29949: 	{
; 29950: 		if( lpObj->pInventory[n].IsItem() == TRUE )

  00038	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00042	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00048	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0004d	83 f8 01	 cmp	 eax, 1
  00050	75 3b		 jne	 SHORT $LN5@gObjFind10

; 29951: 		{
; 29952: 			if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(14,21) )

  00052	69 45 f4 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0005c	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00062	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00067	6a 15		 push	 21			; 00000015H
  00069	6a 0e		 push	 14			; 0000000eH
  0006b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00070	83 c4 08	 add	 esp, 8
  00073	3b f0		 cmp	 esi, eax
  00075	75 16		 jne	 SHORT $LN5@gObjFind10

; 29953: 			{
; 29954: 				count++;

  00077	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0007a	83 c0 01	 add	 eax, 1
  0007d	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax

; 29955: 				if( count >= 10 )

  00080	83 7d f8 0a	 cmp	 DWORD PTR _count$[ebp], 10 ; 0000000aH
  00084	7c 07		 jl	 SHORT $LN5@gObjFind10

; 29956: 				{
; 29957: 					return TRUE;

  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	eb 04		 jmp	 SHORT $LN1@gObjFind10
$LN5@gObjFind10:

; 29958: 				}
; 29959: 			}
; 29960: 		}
; 29961: 	}	

  0008d	eb 9a		 jmp	 SHORT $LN2@gObjFind10
$LN3@gObjFind10:

; 29962: 	return FALSE;

  0008f	33 c0		 xor	 eax, eax
$LN1@gObjFind10:

; 29963: }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
?gObjFind10EventChip@@YAHH@Z ENDP			; gObjFind10EventChip
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjFind@@YAPAVOBJECTSTRUCT@@PAD@Z
_TEXT	SEGMENT
_lpObj$ = -8						; size = 4
_n$ = -4						; size = 4
_targetcharname$ = 8					; size = 4
?gObjFind@@YAPAVOBJECTSTRUCT@@PAD@Z PROC		; gObjFind, COMDAT

; 29916: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29917: 	if( gDisconnect == 1 ) return NULL;

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gDisconnect@@3HA, 1 ; gDisconnect
  00010	75 04		 jne	 SHORT $LN5@gObjFind
  00012	33 c0		 xor	 eax, eax
  00014	eb 77		 jmp	 SHORT $LN1@gObjFind
$LN5@gObjFind:

; 29918: 
; 29919: 	int n;
; 29920: 	LPOBJECTSTRUCT	lpObj;
; 29921: 
; 29922: #if TESTSERVER == 1
; 29923: 	for( n=0; n<MAX_OBJECT; n++ )
; 29924: #else
; 29925: 	for( n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++ )

  00016	c7 45 fc 00 19
	00 00		 mov	 DWORD PTR _n$[ebp], 6400 ; 00001900H
  0001d	eb 09		 jmp	 SHORT $LN4@gObjFind
$LN2@gObjFind:
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00022	83 c0 01	 add	 eax, 1
  00025	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjFind:
  00028	81 7d fc e8 1c
	00 00		 cmp	 DWORD PTR _n$[ebp], 7400 ; 00001ce8H
  0002f	7d 5a		 jge	 SHORT $LN3@gObjFind

; 29926: #endif
; 29927: 	{
; 29928: 		lpObj = &gObj[n];

  00031	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  00038	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003e	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 29929: 		
; 29930: 		if( lpObj->Connected > 2 )

  00041	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00044	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  00048	7e 3f		 jle	 SHORT $LN6@gObjFind

; 29931: 		{	
; 29932: 			if( lpObj->Name[0] == targetcharname[0] )

  0004a	b8 01 00 00 00	 mov	 eax, 1
  0004f	6b c8 00	 imul	 ecx, eax, 0
  00052	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00055	0f be 44 0a 73	 movsx	 eax, BYTE PTR [edx+ecx+115]
  0005a	b9 01 00 00 00	 mov	 ecx, 1
  0005f	6b d1 00	 imul	 edx, ecx, 0
  00062	8b 4d 08	 mov	 ecx, DWORD PTR _targetcharname$[ebp]
  00065	0f be 14 11	 movsx	 edx, BYTE PTR [ecx+edx]
  00069	3b c2		 cmp	 eax, edx
  0006b	75 1c		 jne	 SHORT $LN6@gObjFind

; 29933: 			{
; 29934: 				if( !strcmp(lpObj->Name, targetcharname ) )

  0006d	8b 45 08	 mov	 eax, DWORD PTR _targetcharname$[ebp]
  00070	50		 push	 eax
  00071	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00074	83 c1 73	 add	 ecx, 115		; 00000073H
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 _strcmp
  0007d	83 c4 08	 add	 esp, 8
  00080	85 c0		 test	 eax, eax
  00082	75 05		 jne	 SHORT $LN6@gObjFind

; 29935: 				{
; 29936: 					return lpObj;

  00084	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00087	eb 04		 jmp	 SHORT $LN1@gObjFind
$LN6@gObjFind:

; 29937: 				}
; 29938: 			}			
; 29939: 		}
; 29940: 	}

  00089	eb 94		 jmp	 SHORT $LN2@gObjFind
$LN3@gObjFind:

; 29941: 	return NULL;

  0008b	33 c0		 xor	 eax, eax
$LN1@gObjFind:

; 29942: }

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?gObjFind@@YAPAVOBJECTSTRUCT@@PAD@Z ENDP		; gObjFind
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSendUserStatistic@@YAXHHH@Z
_TEXT	SEGMENT
_sClassCount$ = -32					; size = 20
_lpObj$ = -12						; size = 4
_n$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_startLevel$ = 12					; size = 4
_endLevel$ = 16						; size = 4
?gObjSendUserStatistic@@YAXHHH@Z PROC			; gObjSendUserStatistic, COMDAT

; 29817: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 29818: 	int n;
; 29819: 	LPOBJECTSTRUCT	lpObj;
; 29820: 	
; 29821: 	if( gDisconnect == 1 ) return;

  00013	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gDisconnect@@3HA, 1 ; gDisconnect
  0001a	75 05		 jne	 SHORT $LN5@gObjSendUs
  0001c	e9 6d 01 00 00	 jmp	 $LN1@gObjSendUs
$LN5@gObjSendUs:

; 29822: 
; 29823: 	if( endLevel < startLevel )

  00021	8b 45 10	 mov	 eax, DWORD PTR _endLevel$[ebp]
  00024	3b 45 0c	 cmp	 eax, DWORD PTR _startLevel$[ebp]
  00027	7d 08		 jge	 SHORT $LN6@gObjSendUs

; 29824: 	{
; 29825: 		endLevel = g_GlobalConfig.m_iMaxLevel;

  00029	a1 c8 00 00 00	 mov	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+200
  0002e	89 45 10	 mov	 DWORD PTR _endLevel$[ebp], eax
$LN6@gObjSendUs:

; 29826: 	}
; 29827: #ifdef GMCOMMAND_EX_1ST_BUGFIX
; 29828: 	int sClassCount[6] = {0,0,0,0,0,0};
; 29829: 	int nTotal = 0;
; 29830: 	
; 29831: 	for( n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++ )
; 29832: 	{
; 29833: 		lpObj = &gObj[n];
; 29834: 		
; 29835: 		if( lpObj->Connected > 2 )
; 29836: 		{				
; 29837: 			if( lpObj->Class >= 6 && lpObj->Class < 0 )
; 29838: 				continue;
; 29839: 			
; 29840: 			if( lpObj->Level >= startLevel && lpObj->Level <= endLevel )
; 29841: 			{
; 29842: 				sClassCount[lpObj->Class]++;				
; 29843: 			}
; 29844: 			nTotal++;
; 29845: 		}
; 29846: 	}
; 29847: 
; 29848: 	MsgOutput(gObj[aIndex].m_Index, "[%d]-[%d] Total %d %s %d %s %d %s %d %s %d %s %d %s %d", 
; 29849: 		startLevel, endLevel, nTotal, 
; 29850: 		lMsg.Get(1900), sClassCount[0],
; 29851: 		lMsg.Get(1901), sClassCount[1],
; 29852: 		lMsg.Get(1902), sClassCount[2],
; 29853: 		lMsg.Get(1903), sClassCount[3],
; 29854: 		lMsg.Get(1904), sClassCount[4], 
; 29855: 		lMsg.Get(1905), sClassCount[5]);
; 29856: 
; 29857: #else
; 29858: 
; 29859: #ifdef MODIFY_GMCOMMAND_USERSTAT_20041127
; 29860: 	int sClassCount[6] = {0,0,0,0,0,0};
; 29861: 
; 29862: 	for( n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++ )
; 29863: 	{
; 29864: 		lpObj = &gObj[n];
; 29865: 		
; 29866: 		if( lpObj->Connected > 2 )
; 29867: 		{				
; 29868: 			if( lpObj->Class >= 6 && lpObj->Class < 0 )
; 29869: 				continue;
; 29870: 
; 29871: 			if( lpObj->Level >= startLevel && lpObj->Level <= endLevel )
; 29872: 			{
; 29873: 				sClassCount[lpObj->Class]++;				
; 29874: 			}
; 29875: 			sClassCount[5]++;
; 29876: 		}
; 29877: 	}
; 29878: 
; 29879: 	MsgOutput(gObj[aIndex].m_Index, "[%d]-[%d] Total %d %s %d %s %d %s %d %s %d %s %d", 
; 29880: 				 startLevel, endLevel, sClassCount[5], 
; 29881: 				 lMsg.Get(1900), sClassCount[0],
; 29882: 				 lMsg.Get(1901), sClassCount[1],
; 29883: 				 lMsg.Get(1902), sClassCount[2],
; 29884: 				 lMsg.Get(1903), sClassCount[3],
; 29885: 				 lMsg.Get(1904), sClassCount[4]);
; 29886: #else
; 29887: 	int sClassCount[5] = {0,0,0,0,0};

  00031	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _sClassCount$[ebp], 0
  00038	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _sClassCount$[ebp+4], 0
  0003f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _sClassCount$[ebp+8], 0
  00046	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _sClassCount$[ebp+12], 0
  0004d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _sClassCount$[ebp+16], 0

; 29888: 
; 29889: 	for( n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++ )

  00054	c7 45 f8 00 19
	00 00		 mov	 DWORD PTR _n$[ebp], 6400 ; 00001900H
  0005b	eb 09		 jmp	 SHORT $LN4@gObjSendUs
$LN2@gObjSendUs:
  0005d	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00060	83 c0 01	 add	 eax, 1
  00063	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjSendUs:
  00066	81 7d f8 e8 1c
	00 00		 cmp	 DWORD PTR _n$[ebp], 7400 ; 00001ce8H
  0006d	7d 76		 jge	 SHORT $LN3@gObjSendUs

; 29890: 	{
; 29891: 		lpObj = &gObj[n];

  0006f	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  00076	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007c	89 45 f4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 29892: 		
; 29893: 		if( lpObj->Connected > 2 )

  0007f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00082	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  00086	7e 58		 jle	 SHORT $LN7@gObjSendUs

; 29894: 		{				
; 29895: 			if( lpObj->Level >= startLevel && lpObj->Level <= endLevel )

  00088	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008b	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00092	3b 4d 0c	 cmp	 ecx, DWORD PTR _startLevel$[ebp]
  00095	7c 2e		 jl	 SHORT $LN8@gObjSendUs
  00097	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009a	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  000a1	3b 4d 10	 cmp	 ecx, DWORD PTR _endLevel$[ebp]
  000a4	7f 1f		 jg	 SHORT $LN8@gObjSendUs

; 29896: 			{
; 29897: 				sClassCount[lpObj->Class]++;				

  000a6	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a9	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000b0	8b 54 8d e0	 mov	 edx, DWORD PTR _sClassCount$[ebp+ecx*4]
  000b4	83 c2 01	 add	 edx, 1
  000b7	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ba	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000c1	89 54 8d e0	 mov	 DWORD PTR _sClassCount$[ebp+ecx*4], edx
$LN8@gObjSendUs:

; 29898: 			}
; 29899: 			sClassCount[4]++;

  000c5	b8 04 00 00 00	 mov	 eax, 4
  000ca	c1 e0 02	 shl	 eax, 2
  000cd	8b 4c 05 e0	 mov	 ecx, DWORD PTR _sClassCount$[ebp+eax]
  000d1	83 c1 01	 add	 ecx, 1
  000d4	ba 04 00 00 00	 mov	 edx, 4
  000d9	c1 e2 02	 shl	 edx, 2
  000dc	89 4c 15 e0	 mov	 DWORD PTR _sClassCount$[ebp+edx], ecx
$LN7@gObjSendUs:

; 29900: 			}
; 29901: 	}

  000e0	e9 78 ff ff ff	 jmp	 $LN2@gObjSendUs
$LN3@gObjSendUs:

; 29902: 
; 29903: 	MsgOutput(gObj[aIndex].m_Index, "[%d]-[%d] Total %d %s %d %s %d %s %d %s %d", 

  000e5	b8 04 00 00 00	 mov	 eax, 4
  000ea	6b c8 03	 imul	 ecx, eax, 3
  000ed	8b 54 0d e0	 mov	 edx, DWORD PTR _sClassCount$[ebp+ecx]
  000f1	52		 push	 edx
  000f2	68 6f 07 00 00	 push	 1903			; 0000076fH
  000f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00102	50		 push	 eax
  00103	b8 04 00 00 00	 mov	 eax, 4
  00108	d1 e0		 shl	 eax, 1
  0010a	8b 4c 05 e0	 mov	 ecx, DWORD PTR _sClassCount$[ebp+eax]
  0010e	51		 push	 ecx
  0010f	68 6e 07 00 00	 push	 1902			; 0000076eH
  00114	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0011f	50		 push	 eax
  00120	ba 04 00 00 00	 mov	 edx, 4
  00125	c1 e2 00	 shl	 edx, 0
  00128	8b 44 15 e0	 mov	 eax, DWORD PTR _sClassCount$[ebp+edx]
  0012c	50		 push	 eax
  0012d	68 6d 07 00 00	 push	 1901			; 0000076dH
  00132	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0013d	50		 push	 eax
  0013e	b9 04 00 00 00	 mov	 ecx, 4
  00143	6b d1 00	 imul	 edx, ecx, 0
  00146	8b 44 15 e0	 mov	 eax, DWORD PTR _sClassCount$[ebp+edx]
  0014a	50		 push	 eax
  0014b	68 6c 07 00 00	 push	 1900			; 0000076cH
  00150	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0015b	50		 push	 eax
  0015c	b9 04 00 00 00	 mov	 ecx, 4
  00161	c1 e1 02	 shl	 ecx, 2
  00164	8b 54 0d e0	 mov	 edx, DWORD PTR _sClassCount$[ebp+ecx]
  00168	52		 push	 edx
  00169	8b 45 10	 mov	 eax, DWORD PTR _endLevel$[ebp]
  0016c	50		 push	 eax
  0016d	8b 4d 0c	 mov	 ecx, DWORD PTR _startLevel$[ebp]
  00170	51		 push	 ecx
  00171	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@IFDDAPIM@?$FL?$CFd?$FN?9?$FL?$CFd?$FN?5Total?5?$CFd?5?$CFs?5?$CFd?5?$CFs?5?$CFd?5@
  00176	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0017d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00182	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00185	51		 push	 ecx
  00186	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  0018b	83 c4 34	 add	 esp, 52			; 00000034H
$LN1@gObjSendUs:

; 29904: 				 startLevel, endLevel, sClassCount[4], 
; 29905: 				 lMsg.Get(1900), sClassCount[0],
; 29906: 				 lMsg.Get(1901), sClassCount[1],
; 29907: 				 lMsg.Get(1902), sClassCount[2],
; 29908: 				 lMsg.Get(1903), sClassCount[3]);
; 29909: #endif
; 29910: 
; 29911: #endif // GMCOMMAND_EX_1ST_BUGFIX
; 29912: }

  0018e	5f		 pop	 edi
  0018f	5e		 pop	 esi
  00190	5b		 pop	 ebx
  00191	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00194	33 cd		 xor	 ecx, ebp
  00196	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019b	8b e5		 mov	 esp, ebp
  0019d	5d		 pop	 ebp
  0019e	c3		 ret	 0
?gObjSendUserStatistic@@YAXHHH@Z ENDP			; gObjSendUserStatistic
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gUserFindDevilSquareKeyEyes@@YAHH@Z
_TEXT	SEGMENT
_n$1 = -16						; size = 4
_bFindEyes$ = -12					; size = 4
_bFindKey$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gUserFindDevilSquareKeyEyes@@YAHH@Z PROC		; gUserFindDevilSquareKeyEyes, COMDAT

; 29789: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29790: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 29791: 
; 29792: 	BOOL bFindKey = FALSE, bFindEyes = FALSE;

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bFindKey$[ebp], 0
  00020	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _bFindEyes$[ebp], 0

; 29793: 
; 29794: 	for(int  n=0; n<MAX_INVENTORY; n++)

  00027	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0002e	eb 09		 jmp	 SHORT $LN4@gUserFindD
$LN2@gUserFindD:
  00030	8b 45 f0	 mov	 eax, DWORD PTR _n$1[ebp]
  00033	83 c0 01	 add	 eax, 1
  00036	89 45 f0	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gUserFindD:
  00039	83 7d f0 4c	 cmp	 DWORD PTR _n$1[ebp], 76	; 0000004cH
  0003d	7d 77		 jge	 SHORT $LN3@gUserFindD

; 29795: 	{
; 29796: 		if( lpObj->pInventory[n].IsItem() == TRUE )

  0003f	69 4d f0 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00046	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00049	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0004f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00054	83 f8 01	 cmp	 eax, 1
  00057	75 58		 jne	 SHORT $LN5@gUserFindD

; 29797: 		{
; 29798: 			if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(14, 17) )

  00059	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00063	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00069	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  0006e	6a 11		 push	 17			; 00000011H
  00070	6a 0e		 push	 14			; 0000000eH
  00072	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00077	83 c4 08	 add	 esp, 8
  0007a	3b f0		 cmp	 esi, eax
  0007c	75 07		 jne	 SHORT $LN6@gUserFindD

; 29799: 			{
; 29800: 				bFindEyes = TRUE;

  0007e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _bFindEyes$[ebp], 1
$LN6@gUserFindD:

; 29801: 			}
; 29802: 			if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(14, 18) )

  00085	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0008f	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00095	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  0009a	6a 12		 push	 18			; 00000012H
  0009c	6a 0e		 push	 14			; 0000000eH
  0009e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000a3	83 c4 08	 add	 esp, 8
  000a6	3b f0		 cmp	 esi, eax
  000a8	75 07		 jne	 SHORT $LN5@gUserFindD

; 29803: 			{
; 29804: 				bFindKey = TRUE;

  000aa	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bFindKey$[ebp], 1
$LN5@gUserFindD:

; 29805: 			}
; 29806: 		}
; 29807: 	}

  000b1	e9 7a ff ff ff	 jmp	 $LN2@gUserFindD
$LN3@gUserFindD:

; 29808: 
; 29809: 	if( bFindKey && bFindEyes )

  000b6	83 7d f8 00	 cmp	 DWORD PTR _bFindKey$[ebp], 0
  000ba	74 0d		 je	 SHORT $LN8@gUserFindD
  000bc	83 7d f4 00	 cmp	 DWORD PTR _bFindEyes$[ebp], 0
  000c0	74 07		 je	 SHORT $LN8@gUserFindD

; 29810: 		return TRUE;

  000c2	b8 01 00 00 00	 mov	 eax, 1
  000c7	eb 02		 jmp	 SHORT $LN1@gUserFindD
$LN8@gUserFindD:

; 29811: 
; 29812: 	return FALSE;

  000c9	33 c0		 xor	 eax, eax
$LN1@gUserFindD:

; 29813: }

  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	5b		 pop	 ebx
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c3		 ret	 0
?gUserFindDevilSquareKeyEyes@@YAHH@Z ENDP		; gUserFindDevilSquareKeyEyes
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gUserFindDevilSquareInvitation@@YAHH@Z
_TEXT	SEGMENT
_n$1 = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gUserFindDevilSquareInvitation@@YAHH@Z PROC		; gUserFindDevilSquareInvitation, COMDAT

; 29763: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29764: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 29765: 
; 29766: 	for(int  n=0; n<MAX_INVENTORY; n++)

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00020	eb 09		 jmp	 SHORT $LN4@gUserFindD
$LN2@gUserFindD:
  00022	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  00025	83 c0 01	 add	 eax, 1
  00028	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gUserFindD:
  0002b	83 7d f8 4c	 cmp	 DWORD PTR _n$1[ebp], 76	; 0000004cH
  0002f	7d 48		 jge	 SHORT $LN3@gUserFindD

; 29767: 	{
; 29768: 		if( lpObj->pInventory[n].IsItem() == TRUE )

  00031	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00038	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003b	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00041	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00046	83 f8 01	 cmp	 eax, 1
  00049	75 2c		 jne	 SHORT $LN5@gUserFindD

; 29769: 		{
; 29770: 			if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM(14, 19) )

  0004b	69 45 f8 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00055	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0005b	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00060	6a 13		 push	 19			; 00000013H
  00062	6a 0e		 push	 14			; 0000000eH
  00064	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00069	83 c4 08	 add	 esp, 8
  0006c	3b f0		 cmp	 esi, eax
  0006e	75 07		 jne	 SHORT $LN5@gUserFindD

; 29771: 			{
; 29772: 				return TRUE;

  00070	b8 01 00 00 00	 mov	 eax, 1
  00075	eb 04		 jmp	 SHORT $LN1@gUserFindD
$LN5@gUserFindD:

; 29773: 			}
; 29774: #ifdef ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 29775: 			//     
; 29776: 			if( lpObj->pInventory[n].m_Type == MAKE_ITEMNUM( 13, 46 ) )
; 29777: 			{
; 29778: 				return TRUE;
; 29779: 			}
; 29780: #endif // ADD_PCS_EVENT_MAP_FREE_TICKET_20070110
; 29781: 		}
; 29782: 	}

  00077	eb a9		 jmp	 SHORT $LN2@gUserFindD
$LN3@gUserFindD:

; 29783: 	return FALSE;

  00079	33 c0		 xor	 eax, eax
$LN1@gUserFindD:

; 29784: }

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5b		 pop	 ebx
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
?gUserFindDevilSquareInvitation@@YAHH@Z ENDP		; gUserFindDevilSquareInvitation
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCheckAllUserDuelStop@@YAXXZ
_TEXT	SEGMENT
tv83 = -76						; size = 4
tv84 = -72						; size = 4
_i$1 = -4						; size = 4
?gObjCheckAllUserDuelStop@@YAXXZ PROC			; gObjCheckAllUserDuelStop, COMDAT

; 31730: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31731: #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 31732: 	return;
; 31733: #endif
; 31734: 	for( int i=ALLOC_USEROBJECTSTART ; i<MAX_OBJECT; i++)

  00009	c7 45 fc 00 19
	00 00		 mov	 DWORD PTR _i$1[ebp], 6400 ; 00001900H
  00010	eb 09		 jmp	 SHORT $LN4@gObjCheckA
$LN2@gObjCheckA:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@gObjCheckA:
  0001b	81 7d fc e8 1c
	00 00		 cmp	 DWORD PTR _i$1[ebp], 7400 ; 00001ce8H
  00022	0f 8d 01 01 00
	00		 jge	 $LN1@gObjCheckA

; 31735: 	{
; 31736: 		if( (gObj[i].Connected == 3) && (gObj[i].Type == OBJTYPE_CHARACTER))

  00028	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 7072
  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00035	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  0003a	0f 85 e4 00 00
	00		 jne	 $LN5@gObjCheckA
  00040	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 7072
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004d	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00052	83 fa 01	 cmp	 edx, 1
  00055	0f 85 c9 00 00
	00		 jne	 $LN5@gObjCheckA

; 31737: 		{
; 31738: 			//    
; 31739: 			if (CHECK_LIMIT(gObj[i].m_iDuelUser, MAX_OBJECT)) {

  0005b	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 7072
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00068	83 bc 01 ec 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3308], 0
  00070	7d 09		 jge	 SHORT $LN11@gObjCheckA
  00072	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
  00079	eb 2f		 jmp	 SHORT $LN12@gObjCheckA
$LN11@gObjCheckA:
  0007b	69 55 fc a0 1b
	00 00		 imul	 edx, DWORD PTR _i$1[ebp], 7072
  00082	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00087	81 bc 10 ec 0c
	00 00 e7 1c 00
	00		 cmp	 DWORD PTR [eax+edx+3308], 7399 ; 00001ce7H
  00092	7e 09		 jle	 SHORT $LN9@gObjCheckA
  00094	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
  0009b	eb 07		 jmp	 SHORT $LN10@gObjCheckA
$LN9@gObjCheckA:
  0009d	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv83[ebp], 1
$LN10@gObjCheckA:
  000a4	8b 4d b4	 mov	 ecx, DWORD PTR tv83[ebp]
  000a7	89 4d b8	 mov	 DWORD PTR tv84[ebp], ecx
$LN12@gObjCheckA:
  000aa	83 7d b8 00	 cmp	 DWORD PTR tv84[ebp], 0
  000ae	74 74		 je	 SHORT $LN5@gObjCheckA

; 31740: 				if ((GetTickCount() - gObj[i].m_iDuelTickCount) > (60 * 1000)) {

  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000b6	69 4d fc a0 1b
	00 00		 imul	 ecx, DWORD PTR _i$1[ebp], 7072
  000bd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c3	2b 84 0a f4 0c
	00 00		 sub	 eax, DWORD PTR [edx+ecx+3316]
  000ca	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  000cf	76 53		 jbe	 SHORT $LN5@gObjCheckA

; 31741: 					//   1    .
; 31742: 					gObjSendDuelEnd(&gObj[gObj[i].m_iDuelUser]);

  000d1	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 7072
  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000de	69 94 01 ec 0c
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax+3308], 7072
  000e9	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ef	52		 push	 edx
  000f0	e8 00 00 00 00	 call	 ?gObjSendDuelEnd@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSendDuelEnd
  000f5	83 c4 04	 add	 esp, 4

; 31743: 					gObjSendDuelEnd(&gObj[i]);

  000f8	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 7072
  000ff	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ?gObjSendDuelEnd@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSendDuelEnd
  0010b	83 c4 04	 add	 esp, 4

; 31744: 					gObjResetDuel(&gObj[i]);

  0010e	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 7072
  00115	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ?gObjResetDuel@@YAXPAVOBJECTSTRUCT@@@Z ; gObjResetDuel
  00121	83 c4 04	 add	 esp, 4
$LN5@gObjCheckA:

; 31745: 				}
; 31746: 			}
; 31747: 		}
; 31748: 	}

  00124	e9 e9 fe ff ff	 jmp	 $LN2@gObjCheckA
$LN1@gObjCheckA:

; 31749: }

  00129	5f		 pop	 edi
  0012a	5e		 pop	 esi
  0012b	5b		 pop	 ebx
  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c3		 ret	 0
?gObjCheckAllUserDuelStop@@YAXXZ ENDP			; gObjCheckAllUserDuelStop
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSendDuelEnd@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pMsg$ = -20						; size = 15
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjSendDuelEnd@@YAXPAVOBJECTSTRUCT@@@Z PROC		; gObjSendDuelEnd, COMDAT

; 31670: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 31671: 	//   .
; 31672: 	if( gObjIsConnected(lpObj->m_Index) == FALSE ) return;

  00013	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	75 05		 jne	 SHORT $LN2@gObjSendDu
  00025	e9 cf 00 00 00	 jmp	 $LN1@gObjSendDu
$LN2@gObjSendDu:

; 31673: 	if( lpObj->Type == OBJTYPE_MONSTER ) return;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002d	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00031	83 f9 02	 cmp	 ecx, 2
  00034	75 05		 jne	 SHORT $LN3@gObjSendDu
  00036	e9 be 00 00 00	 jmp	 $LN1@gObjSendDu
$LN3@gObjSendDu:

; 31674: 	if( lpObj->CloseCount >= 0 ) return;

  0003b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003e	0f be 48 0a	 movsx	 ecx, BYTE PTR [eax+10]
  00042	85 c9		 test	 ecx, ecx
  00044	7c 05		 jl	 SHORT $LN4@gObjSendDu
  00046	e9 ae 00 00 00	 jmp	 $LN1@gObjSendDu
$LN4@gObjSendDu:

; 31675: 
; 31676: #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 31677: 	int	iTargetIndex = lpObj->m_iDuelUser;
; 31678: 	if( gObjDuelCheck(&gObj[iTargetIndex], lpObj) ) 
; 31679: 	{	//      ,    				
; 31680: 		PMSG_MATCH_RESULT	pMsg;
; 31681: 
; 31682: 		PHeadSubSetB((LPBYTE)&pMsg, 0xF3, 0x24, sizeof( pMsg) );
; 31683: 		pMsg.MatchType	= eMatchType_Dual;
; 31684: 
; 31685: 		memcpy(pMsg.MatchTeamName1, lpObj->Name, MAX_IDSTRING);
; 31686: 		pMsg.Score1 = lpObj->m_btDuelScore;		
; 31687: 
; 31688: 		memcpy(pMsg.MatchTeamName2, gObj[iTargetIndex].Name, MAX_IDSTRING);
; 31689: 		pMsg.Score2 = gObj[iTargetIndex].m_btDuelScore;
; 31690: 
; 31691: 		DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);
; 31692: 		DataSend(iTargetIndex, (LPBYTE)&pMsg, pMsg.h.size);
; 31693: 
; 31694: 		LogAddTD("[WTEvent] Duel Result Send = %s-%d %s-%d", 
; 31695: 				 lpObj->Name , lpObj->m_btDuelScore, 
; 31696: 				 gObj[iTargetIndex].Name, gObj[iTargetIndex].m_btDuelScore);
; 31697: 	}
; 31698: #endif
; 31699: 
; 31700: 
; 31701: 	lpObj->m_iDuelUser = -1;

  0004b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004e	c7 80 ec 0c 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+3308], -1

; 31702: 	lpObj->m_iDuelUserReserved = -1;

  00058	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005b	c7 80 e4 0c 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+3300], -1

; 31703: 	lpObj->m_iDuelUserRequested = -1;

  00065	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00068	c7 80 e8 0c 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+3304], -1

; 31704: 	lpObj->m_btDuelScore = 0;

  00072	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00075	c6 80 f0 0c 00
	00 00		 mov	 BYTE PTR [eax+3312], 0

; 31705: #ifdef DUEL_SYSTEM_FIX_20031224
; 31706: 	lpObj->m_iDuelTickCount = 0;

  0007c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007f	c7 80 f4 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3316], 0

; 31707: #endif
; 31708: 
; 31709: #ifdef ADD_NEWPVP_PKFIELD
; 31710: #else
; 31711: 	PMSG_ANS_END_DUEL pMsg;
; 31712: 	pMsg.h.c = PMHC_BYTE;

  00089	c6 45 ec c1	 mov	 BYTE PTR _pMsg$[ebp], 193 ; 000000c1H

; 31713: 	pMsg.h.headcode = 0xAB;

  0008d	c6 45 ee ab	 mov	 BYTE PTR _pMsg$[ebp+2], 171 ; 000000abH

; 31714: 	pMsg.h.size = sizeof( pMsg );

  00091	c6 45 ed 0f	 mov	 BYTE PTR _pMsg$[ebp+1], 15 ; 0000000fH

; 31715: 
; 31716: 	pMsg.NumberH = HIBYTE(lpObj->m_iDuelUser);

  00095	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00098	8b 88 ec 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3308]
  0009e	c1 e9 08	 shr	 ecx, 8
  000a1	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000a7	88 4d ef	 mov	 BYTE PTR _pMsg$[ebp+3], cl

; 31717: 	pMsg.NumberL = LOBYTE(lpObj->m_iDuelUser);

  000aa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ad	8b 88 ec 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3308]
  000b3	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000b9	88 4d f0	 mov	 BYTE PTR _pMsg$[ebp+4], cl

; 31718: 	memcpy(pMsg.szName, gObj[lpObj->m_iDuelUser].Name, MAX_IDSTRING);

  000bc	6a 0a		 push	 10			; 0000000aH
  000be	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c1	69 88 ec 0c 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR [eax+3308], 7072
  000cb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d1	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  000d5	50		 push	 eax
  000d6	8d 4d f1	 lea	 ecx, DWORD PTR _pMsg$[ebp+5]
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 _memcpy
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 31719: 	DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  000e2	0f b6 45 ed	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000e6	50		 push	 eax
  000e7	8d 4d ec	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000ea	51		 push	 ecx
  000eb	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ee	8b 02		 mov	 eax, DWORD PTR [edx]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjSendDu:

; 31720: #endif // ADD_NEWPVP_PKFIELD
; 31721: }

  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx
  000fc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ff	33 cd		 xor	 ecx, ebp
  00101	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c3		 ret	 0
?gObjSendDuelEnd@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; gObjSendDuelEnd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjResetDuel@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv67 = -76						; size = 4
tv68 = -72						; size = 4
_iDuelIndex$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjResetDuel@@YAXPAVOBJECTSTRUCT@@@Z PROC		; gObjResetDuel, COMDAT

; 31641: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31642: 	INT iDuelIndex = lpObj->m_iDuelUser;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	8b 88 ec 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3308]
  00012	89 4d fc	 mov	 DWORD PTR _iDuelIndex$[ebp], ecx

; 31643: 
; 31644: 	if (CHECK_LIMIT(iDuelIndex, MAX_OBJECT)) {

  00015	83 7d fc 00	 cmp	 DWORD PTR _iDuelIndex$[ebp], 0
  00019	7d 09		 jge	 SHORT $LN6@gObjResetD
  0001b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  00022	eb 1f		 jmp	 SHORT $LN7@gObjResetD
$LN6@gObjResetD:
  00024	81 7d fc e7 1c
	00 00		 cmp	 DWORD PTR _iDuelIndex$[ebp], 7399 ; 00001ce7H
  0002b	7e 09		 jle	 SHORT $LN4@gObjResetD
  0002d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00034	eb 07		 jmp	 SHORT $LN5@gObjResetD
$LN4@gObjResetD:
  00036	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
$LN5@gObjResetD:
  0003d	8b 45 b4	 mov	 eax, DWORD PTR tv67[ebp]
  00040	89 45 b8	 mov	 DWORD PTR tv68[ebp], eax
$LN7@gObjResetD:
  00043	83 7d b8 00	 cmp	 DWORD PTR tv68[ebp], 0
  00047	0f 84 bb 00 00
	00		 je	 $LN1@gObjResetD

; 31645: 		lpObj->m_iDuelUser = -1;

  0004d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00050	c7 80 ec 0c 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+3308], -1

; 31646: 		lpObj->m_iDuelUserReserved = -1;

  0005a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005d	c7 80 e4 0c 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+3300], -1

; 31647: 		lpObj->m_btDuelScore = 0;

  00067	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006a	c6 80 f0 0c 00
	00 00		 mov	 BYTE PTR [eax+3312], 0

; 31648: #ifdef DUEL_SYSTEM_FIX_20031224
; 31649: 		lpObj->m_iDuelTickCount = 0;

  00071	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00074	c7 80 f4 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3316], 0

; 31650: #endif
; 31651: 
; 31652: #ifdef MODIFY_DARKSPIRTI_TARGETRELEASE_ON_DUEL_20060524
; 31653: 		//    
; 31654: 		gDarkSpirit[lpObj->m_Index].ReSetTarget(iDuelIndex);

  0007e	8b 45 fc	 mov	 eax, DWORD PTR _iDuelIndex$[ebp]
  00081	50		 push	 eax
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00085	6b 09 28	 imul	 ecx, DWORD PTR [ecx], 40
  00088	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  0008e	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget

; 31655: 		gDarkSpirit[iDuelIndex].ReSetTarget(lpObj->m_Index);

  00093	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00096	8b 08		 mov	 ecx, DWORD PTR [eax]
  00098	51		 push	 ecx
  00099	6b 4d fc 28	 imul	 ecx, DWORD PTR _iDuelIndex$[ebp], 40
  0009d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  000a3	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget

; 31656: #endif
; 31657: 
; 31658: 		gObj[iDuelIndex].m_iDuelUser = -1;

  000a8	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  000af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b5	c7 84 01 ec 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3308], -1

; 31659: 		gObj[iDuelIndex].m_iDuelUserReserved = -1;

  000c0	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  000c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cd	c7 84 01 e4 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3300], -1

; 31660: 		gObj[iDuelIndex].m_iDuelUserRequested = -1;

  000d8	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  000df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e5	c7 84 01 e8 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+3304], -1

; 31661: #ifdef DUEL_SYSTEM_FIX_20031224
; 31662: 		gObj[iDuelIndex].m_iDuelTickCount = 0;

  000f0	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _iDuelIndex$[ebp], 7072
  000f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fd	c7 84 01 f4 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+3316], 0
$LN1@gObjResetD:

; 31663: #endif
; 31664: 	}
; 31665: }

  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
?gObjResetDuel@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; gObjResetDuel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_bRetVal$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@0@Z PROC		; gObjDuelCheck, COMDAT

; 31623: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31624: 	BOOL bRetVal = FALSE;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bRetVal$[ebp], 0

; 31625: 
; 31626: 	if (lpObj->Type == OBJTYPE_CHARACTER &&

  00010	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00013	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00017	83 f9 01	 cmp	 ecx, 1
  0001a	75 33		 jne	 SHORT $LN2@gObjDuelCh
  0001c	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0001f	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00023	83 f9 01	 cmp	 ecx, 1
  00026	75 27		 jne	 SHORT $LN2@gObjDuelCh

; 31627: 		lpTargetObj->Type == OBJTYPE_CHARACTER
; 31628: 		) 
; 31629: 	{
; 31630: 		if ( (lpObj->m_iDuelUser == lpTargetObj->m_Index) && (lpTargetObj->m_iDuelUser == lpObj->m_Index) ) {

  00028	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  0002e	8b 90 ec 0c 00
	00		 mov	 edx, DWORD PTR [eax+3308]
  00034	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00036	75 17		 jne	 SHORT $LN2@gObjDuelCh
  00038	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0003e	8b 90 ec 0c 00
	00		 mov	 edx, DWORD PTR [eax+3308]
  00044	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00046	75 07		 jne	 SHORT $LN2@gObjDuelCh

; 31631: 			bRetVal = TRUE;

  00048	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bRetVal$[ebp], 1
$LN2@gObjDuelCh:

; 31632: 		}
; 31633: 	}
; 31634: 
; 31635: 	return bRetVal;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _bRetVal$[ebp]

; 31636: }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@0@Z ENDP		; gObjDuelCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv70 = -80						; size = 4
tv71 = -76						; size = 4
_iDuelIndex$1 = -8					; size = 4
_bRetVal$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@@Z PROC		; gObjDuelCheck, COMDAT

; 31606: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 31607: 	BOOL bRetVal = FALSE;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bRetVal$[ebp], 0

; 31608: 
; 31609: 	if (lpObj->Type == OBJTYPE_CHARACTER) {

  00010	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00013	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00017	83 f9 01	 cmp	 ecx, 1
  0001a	75 47		 jne	 SHORT $LN2@gObjDuelCh

; 31610: 		INT iDuelIndex = lpObj->m_iDuelUser;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001f	8b 88 ec 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3308]
  00025	89 4d f8	 mov	 DWORD PTR _iDuelIndex$1[ebp], ecx

; 31611: 
; 31612: 		if (CHECK_LIMIT(iDuelIndex, MAX_OBJECT)) {

  00028	83 7d f8 00	 cmp	 DWORD PTR _iDuelIndex$1[ebp], 0
  0002c	7d 09		 jge	 SHORT $LN7@gObjDuelCh
  0002e	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  00035	eb 1f		 jmp	 SHORT $LN8@gObjDuelCh
$LN7@gObjDuelCh:
  00037	81 7d f8 e7 1c
	00 00		 cmp	 DWORD PTR _iDuelIndex$1[ebp], 7399 ; 00001ce7H
  0003e	7e 09		 jle	 SHORT $LN5@gObjDuelCh
  00040	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  00047	eb 07		 jmp	 SHORT $LN6@gObjDuelCh
$LN5@gObjDuelCh:
  00049	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
$LN6@gObjDuelCh:
  00050	8b 45 b0	 mov	 eax, DWORD PTR tv70[ebp]
  00053	89 45 b4	 mov	 DWORD PTR tv71[ebp], eax
$LN8@gObjDuelCh:
  00056	83 7d b4 00	 cmp	 DWORD PTR tv71[ebp], 0
  0005a	74 07		 je	 SHORT $LN2@gObjDuelCh

; 31613: 			bRetVal = TRUE;

  0005c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bRetVal$[ebp], 1
$LN2@gObjDuelCh:

; 31614: 		}
; 31615: 	}
; 31616: 
; 31617: 	return bRetVal;

  00063	8b 45 fc	 mov	 eax, DWORD PTR _bRetVal$[ebp]

; 31618: }

  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5b		 pop	 ebx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@@Z ENDP		; gObjDuelCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjIsSelfDefense@@YA_NPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv67 = -72						; size = 4
_n$1 = -4						; size = 4
_lpObj$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
?gObjIsSelfDefense@@YA_NPAVOBJECTSTRUCT@@H@Z PROC	; gObjIsSelfDefense, COMDAT

; 12403: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 12404: 	if(!CHECK_LIMIT( aTargetIndex, MAX_OBJECT ) )

  00009	83 7d 0c 00	 cmp	 DWORD PTR _aTargetIndex$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN11@gObjIsSelf
  0000f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN12@gObjIsSelf
$LN11@gObjIsSelf:
  00018	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aTargetIndex$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN9@gObjIsSelf
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN10@gObjIsSelf
$LN9@gObjIsSelf:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN10@gObjIsSelf:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN12@gObjIsSelf:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 04		 jne	 SHORT $LN5@gObjIsSelf

; 12405: 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	eb 42		 jmp	 SHORT $LN1@gObjIsSelf
$LN5@gObjIsSelf:

; 12406: 
; 12407: 	for( int n=0; n<MAXSELFDEFENSE; n++)

  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00048	eb 09		 jmp	 SHORT $LN4@gObjIsSelf
$LN2@gObjIsSelf:
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  0004d	83 c0 01	 add	 eax, 1
  00050	89 45 fc	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjIsSelf:
  00053	83 7d fc 07	 cmp	 DWORD PTR _n$1[ebp], 7
  00057	7d 28		 jge	 SHORT $LN3@gObjIsSelf

; 12408: 	{
; 12409: 		//    ..  
; 12410: 		if( lpObj->SelfDefense[n] >= 0)

  00059	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0005f	83 bc 81 40 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax*4+576], 0
  00067	7c 16		 jl	 SHORT $LN6@gObjIsSelf

; 12411: 		{
; 12412: 			if( lpObj->SelfDefense[n] == aTargetIndex ) return true;		

  00069	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0006f	8b 94 81 40 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+576]
  00076	3b 55 0c	 cmp	 edx, DWORD PTR _aTargetIndex$[ebp]
  00079	75 04		 jne	 SHORT $LN6@gObjIsSelf
  0007b	b0 01		 mov	 al, 1
  0007d	eb 04		 jmp	 SHORT $LN1@gObjIsSelf
$LN6@gObjIsSelf:

; 12413: 		}
; 12414: 	}

  0007f	eb c9		 jmp	 SHORT $LN2@gObjIsSelf
$LN3@gObjIsSelf:

; 12415: 
; 12416: 	return false;

  00081	32 c0		 xor	 al, al
$LN1@gObjIsSelf:

; 12417: }

  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?gObjIsSelfDefense@@YA_NPAVOBJECTSTRUCT@@H@Z ENDP	; gObjIsSelfDefense
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCheckAttackArea@@YAHHH@Z
_TEXT	SEGMENT
_attr$ = -9						; size = 1
_tarmapnumber$ = -8					; size = 4
_mapnumber$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_TarObjIndex$ = 12					; size = 4
?gObjCheckAttackArea@@YAHHH@Z PROC			; gObjCheckAttackArea, COMDAT

; 29701: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29702: #ifdef WORLD_TOURNAMENT_EVENT_SETTING	
; 29703: 	return 0;
; 29704: #endif
; 29705: 	if( !gObjCheckattackAreaUsedViewPort(aIndex, TarObjIndex) )

  00009	8b 45 0c	 mov	 eax, DWORD PTR _TarObjIndex$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ?gObjCheckattackAreaUsedViewPort@@YAHHH@Z ; gObjCheckattackAreaUsedViewPort
  00016	83 c4 08	 add	 esp, 8
  00019	85 c0		 test	 eax, eax
  0001b	75 0a		 jne	 SHORT $LN2@gObjCheckA

; 29706: 	{	//     
; 29707: 		return 1;

  0001d	b8 01 00 00 00	 mov	 eax, 1
  00022	e9 34 01 00 00	 jmp	 $LN1@gObjCheckA
$LN2@gObjCheckA:

; 29708: 	}
; 29709: 
; 29710: 		/*
; 29711: 	if( (gObj[TarObjIndex].X < (gObj[aIndex].X-10)) || (gObj[TarObjIndex].X > (gObj[aIndex].X+10)) ||
; 29712: 	    (gObj[TarObjIndex].Y < (gObj[aIndex].Y-10)) || (gObj[TarObjIndex].Y > (gObj[aIndex].Y+10)) )
; 29713: 	{	//  
; 29714: 		if( !gObjCheckAttackAreaUsedPath(aIndex, TarObjIndex) )
; 29715: 		{	//    ...
; 29716: 			return 1;
; 29717: 		}
; 29718: 		return 7;
; 29719: 	}
; 29720: 	*/
; 29721: 
; 29722: 	//    
; 29723: 
; 29724: 	// ..
; 29725: 	int mapnumber = gObj[aIndex].MapNumber;

  00027	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00034	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0003c	89 55 fc	 mov	 DWORD PTR _mapnumber$[ebp], edx

; 29726: 	if( mapnumber < 0  || mapnumber >= g_TerrainManager.Size() )

  0003f	83 7d fc 00	 cmp	 DWORD PTR _mapnumber$[ebp], 0
  00043	7c 0f		 jl	 SHORT $LN4@gObjCheckA
  00045	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  0004a	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size
  0004f	39 45 fc	 cmp	 DWORD PTR _mapnumber$[ebp], eax
  00052	7c 0a		 jl	 SHORT $LN3@gObjCheckA
$LN4@gObjCheckA:

; 29727: 	{
; 29728: 		return 2;

  00054	b8 02 00 00 00	 mov	 eax, 2
  00059	e9 fd 00 00 00	 jmp	 $LN1@gObjCheckA
$LN3@gObjCheckA:

; 29729: 	}	
; 29730: 
; 29731: 	//  
; 29732: 	int tarmapnumber = gObj[TarObjIndex].MapNumber;

  0005e	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _TarObjIndex$[ebp], 7072
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006b	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00073	89 55 f8	 mov	 DWORD PTR _tarmapnumber$[ebp], edx

; 29733: 	if( tarmapnumber < 0  || tarmapnumber >= g_TerrainManager.Size() )

  00076	83 7d f8 00	 cmp	 DWORD PTR _tarmapnumber$[ebp], 0
  0007a	7c 0f		 jl	 SHORT $LN6@gObjCheckA
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  00081	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size
  00086	39 45 f8	 cmp	 DWORD PTR _tarmapnumber$[ebp], eax
  00089	7c 0a		 jl	 SHORT $LN5@gObjCheckA
$LN6@gObjCheckA:

; 29734: 	{
; 29735: 		return 3;

  0008b	b8 03 00 00 00	 mov	 eax, 3
  00090	e9 c6 00 00 00	 jmp	 $LN1@gObjCheckA
$LN5@gObjCheckA:

; 29736: 	}	
; 29737: 
; 29738: 	if( tarmapnumber != mapnumber )

  00095	8b 45 f8	 mov	 eax, DWORD PTR _tarmapnumber$[ebp]
  00098	3b 45 fc	 cmp	 eax, DWORD PTR _mapnumber$[ebp]
  0009b	74 0a		 je	 SHORT $LN7@gObjCheckA

; 29739: 	{	//   , 
; 29740: 		return 4;

  0009d	b8 04 00 00 00	 mov	 eax, 4
  000a2	e9 b4 00 00 00	 jmp	 $LN1@gObjCheckA
$LN7@gObjCheckA:

; 29741: 	}
; 29742: 
; 29743: #ifdef CASTLE_NPC_GATE_WORK_20041206		//        .
; 29744: 	BYTE attr = 0;
; 29745: #else
; 29746: 	BYTE attr = MapC[mapnumber].GetAttr(gObj[TarObjIndex].X, gObj[TarObjIndex].Y);

  000a7	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _TarObjIndex$[ebp], 7072
  000ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b4	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  000bc	52		 push	 edx
  000bd	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _TarObjIndex$[ebp], 7072
  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ca	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  000d2	52		 push	 edx
  000d3	69 4d fc 8c 04
	05 00		 imul	 ecx, DWORD PTR _mapnumber$[ebp], 328844
  000da	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000e0	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000e5	88 45 f7	 mov	 BYTE PTR _attr$[ebp], al

; 29747: 	if( (attr != MAP_ATTR_NONE) && !(attr & MAP_ATTR_STAND) )

  000e8	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  000ec	85 c0		 test	 eax, eax
  000ee	74 10		 je	 SHORT $LN8@gObjCheckA
  000f0	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  000f4	83 e0 02	 and	 eax, 2
  000f7	75 07		 jne	 SHORT $LN8@gObjCheckA

; 29748: 	{	//    
; 29749: 		return 5;

  000f9	b8 05 00 00 00	 mov	 eax, 5
  000fe	eb 5b		 jmp	 SHORT $LN1@gObjCheckA
$LN8@gObjCheckA:

; 29750: 	}
; 29751: #endif
; 29752: 
; 29753: 	attr = MapC[mapnumber].GetAttr(gObj[aIndex].X, gObj[aIndex].Y);

  00100	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00107	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010d	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  00115	52		 push	 edx
  00116	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0011d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00123	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  0012b	52		 push	 edx
  0012c	69 4d fc 8c 04
	05 00		 imul	 ecx, DWORD PTR _mapnumber$[ebp], 328844
  00133	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00139	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0013e	88 45 f7	 mov	 BYTE PTR _attr$[ebp], al

; 29754: 	if( (attr != MAP_ATTR_NONE) && !(attr & MAP_ATTR_STAND) )

  00141	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  00145	85 c0		 test	 eax, eax
  00147	74 10		 je	 SHORT $LN9@gObjCheckA
  00149	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  0014d	83 e0 02	 and	 eax, 2
  00150	75 07		 jne	 SHORT $LN9@gObjCheckA

; 29755: 	{	//    
; 29756: 		return 6;

  00152	b8 06 00 00 00	 mov	 eax, 6
  00157	eb 02		 jmp	 SHORT $LN1@gObjCheckA
$LN9@gObjCheckA:

; 29757: 	}	
; 29758: 
; 29759: 	return 0;

  00159	33 c0		 xor	 eax, eax
$LN1@gObjCheckA:

; 29760: }

  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c3		 ret	 0
?gObjCheckAttackArea@@YAHHH@Z ENDP			; gObjCheckAttackArea
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCheckTeleportArea@@YAHHEE@Z
_TEXT	SEGMENT
_attr$ = -5						; size = 1
_mapnumber$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_x$ = 12						; size = 1
_y$ = 16						; size = 1
?gObjCheckTeleportArea@@YAHHEE@Z PROC			; gObjCheckTeleportArea, COMDAT

; 29606: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29607: 
; 29608: 	if( (x < (gObj[aIndex].X-8)) || (x > (gObj[aIndex].X+8)) ||
; 29609: 	    (y < (gObj[aIndex].Y-8)) || (y > (gObj[aIndex].Y+8)) )

  00009	0f b6 45 0c	 movzx	 eax, BYTE PTR _x$[ebp]
  0000d	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00014	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0001a	0f bf 8c 0a 04
	01 00 00	 movsx	 ecx, WORD PTR [edx+ecx+260]
  00022	83 e9 08	 sub	 ecx, 8
  00025	3b c1		 cmp	 eax, ecx
  00027	7c 60		 jl	 SHORT $LN3@gObjCheckT
  00029	0f b6 45 0c	 movzx	 eax, BYTE PTR _x$[ebp]
  0002d	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00034	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003a	0f bf 8c 0a 04
	01 00 00	 movsx	 ecx, WORD PTR [edx+ecx+260]
  00042	83 c1 08	 add	 ecx, 8
  00045	3b c1		 cmp	 eax, ecx
  00047	7f 40		 jg	 SHORT $LN3@gObjCheckT
  00049	0f b6 45 10	 movzx	 eax, BYTE PTR _y$[ebp]
  0004d	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00054	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005a	0f bf 8c 0a 06
	01 00 00	 movsx	 ecx, WORD PTR [edx+ecx+262]
  00062	83 e9 08	 sub	 ecx, 8
  00065	3b c1		 cmp	 eax, ecx
  00067	7c 20		 jl	 SHORT $LN3@gObjCheckT
  00069	0f b6 45 10	 movzx	 eax, BYTE PTR _y$[ebp]
  0006d	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00074	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007a	0f bf 8c 0a 06
	01 00 00	 movsx	 ecx, WORD PTR [edx+ecx+262]
  00082	83 c1 08	 add	 ecx, 8
  00085	3b c1		 cmp	 eax, ecx
  00087	7e 07		 jle	 SHORT $LN2@gObjCheckT
$LN3@gObjCheckT:

; 29610: 	{	//     
; 29611: 		return FALSE;

  00089	33 c0		 xor	 eax, eax
  0008b	e9 af 00 00 00	 jmp	 $LN1@gObjCheckT
$LN2@gObjCheckT:

; 29612: 	}
; 29613: 
; 29614: 	//    
; 29615: 	int mapnumber = gObj[aIndex].MapNumber;

  00090	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009d	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000a5	89 55 fc	 mov	 DWORD PTR _mapnumber$[ebp], edx

; 29616: 	if( mapnumber < 0  || mapnumber >= g_TerrainManager.Size() )

  000a8	83 7d fc 00	 cmp	 DWORD PTR _mapnumber$[ebp], 0
  000ac	7c 0f		 jl	 SHORT $LN5@gObjCheckT
  000ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  000b3	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size
  000b8	39 45 fc	 cmp	 DWORD PTR _mapnumber$[ebp], eax
  000bb	7c 04		 jl	 SHORT $LN4@gObjCheckT
$LN5@gObjCheckT:

; 29617: 	{
; 29618: 		return FALSE;

  000bd	33 c0		 xor	 eax, eax
  000bf	eb 7e		 jmp	 SHORT $LN1@gObjCheckT
$LN4@gObjCheckT:

; 29619: 	}	
; 29620: 
; 29621: 	BYTE attr = MapC[mapnumber].GetAttr(x, y);

  000c1	0f b6 45 10	 movzx	 eax, BYTE PTR _y$[ebp]
  000c5	50		 push	 eax
  000c6	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _x$[ebp]
  000ca	51		 push	 ecx
  000cb	69 4d fc 8c 04
	05 00		 imul	 ecx, DWORD PTR _mapnumber$[ebp], 328844
  000d2	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000d8	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000dd	88 45 fb	 mov	 BYTE PTR _attr$[ebp], al

; 29622: 	if( attr != MAP_ATTR_NONE )

  000e0	0f b6 45 fb	 movzx	 eax, BYTE PTR _attr$[ebp]
  000e4	85 c0		 test	 eax, eax
  000e6	74 04		 je	 SHORT $LN6@gObjCheckT

; 29623: 	{	//    ( )
; 29624: 		return FALSE;

  000e8	33 c0		 xor	 eax, eax
  000ea	eb 53		 jmp	 SHORT $LN1@gObjCheckT
$LN6@gObjCheckT:

; 29625: 	}
; 29626: 
; 29627: 	attr = MapC[mapnumber].GetAttr(gObj[aIndex].X, gObj[aIndex].Y);

  000ec	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f9	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  00101	52		 push	 edx
  00102	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00109	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010f	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  00117	52		 push	 edx
  00118	69 4d fc 8c 04
	05 00		 imul	 ecx, DWORD PTR _mapnumber$[ebp], 328844
  0011f	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00125	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0012a	88 45 fb	 mov	 BYTE PTR _attr$[ebp], al

; 29628: 	if( attr & MAP_ATTR_SAFTYZONE )

  0012d	0f b6 45 fb	 movzx	 eax, BYTE PTR _attr$[ebp]
  00131	83 e0 01	 and	 eax, 1
  00134	74 04		 je	 SHORT $LN7@gObjCheckT

; 29629: 	{	//   
; 29630: 		return FALSE;

  00136	33 c0		 xor	 eax, eax
  00138	eb 05		 jmp	 SHORT $LN1@gObjCheckT
$LN7@gObjCheckT:

; 29631: 	}
; 29632: 
; 29633: 	return TRUE;

  0013a	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjCheckT:

; 29634: }

  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5b		 pop	 ebx
  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c3		 ret	 0
?gObjCheckTeleportArea@@YAHHEE@Z ENDP			; gObjCheckTeleportArea
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_buf$ = 8						; size = 4
_lpItem$ = 12						; size = 4
?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z PROC		; ItemIsBufExOption, COMDAT

; 4282 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4283 : 	
; 4284 : 	for( int i=0; i<8; i++) buf[i]=0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@ItemIsBufE
$LN2@ItemIsBufE:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@ItemIsBufE:
  0001b	83 7d fc 08	 cmp	 DWORD PTR _i$1[ebp], 8
  0001f	7d 0b		 jge	 SHORT $LN3@ItemIsBufE
  00021	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00024	03 45 fc	 add	 eax, DWORD PTR _i$1[ebp]
  00027	c6 00 00	 mov	 BYTE PTR [eax], 0
  0002a	eb e6		 jmp	 SHORT $LN2@ItemIsBufE
$LN3@ItemIsBufE:

; 4285 : 
; 4286 : 	if( lpItem->IsExtLifeAdd()            ) buf[0] = 1;

  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  0002f	e8 00 00 00 00	 call	 ?IsExtLifeAdd@CItem@@QAEHXZ ; CItem::IsExtLifeAdd
  00034	85 c0		 test	 eax, eax
  00036	74 0f		 je	 SHORT $LN5@ItemIsBufE
  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	6b c8 00	 imul	 ecx, eax, 0
  00040	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00043	c6 04 0a 01	 mov	 BYTE PTR [edx+ecx], 1
$LN5@ItemIsBufE:

; 4287 : 	if( lpItem->IsExtManaAdd()            ) buf[1] = 1;

  00047	8b 4d 0c	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  0004a	e8 00 00 00 00	 call	 ?IsExtManaAdd@CItem@@QAEHXZ ; CItem::IsExtManaAdd
  0004f	85 c0		 test	 eax, eax
  00051	74 0f		 je	 SHORT $LN6@ItemIsBufE
  00053	b8 01 00 00 00	 mov	 eax, 1
  00058	c1 e0 00	 shl	 eax, 0
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  0005e	c6 04 01 01	 mov	 BYTE PTR [ecx+eax], 1
$LN6@ItemIsBufE:

; 4288 : 	if( lpItem->IsExtDamageMinus()        ) buf[2] = 1;

  00062	8b 4d 0c	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  00065	e8 00 00 00 00	 call	 ?IsExtDamageMinus@CItem@@QAEHXZ ; CItem::IsExtDamageMinus
  0006a	85 c0		 test	 eax, eax
  0006c	74 0e		 je	 SHORT $LN7@ItemIsBufE
  0006e	b8 01 00 00 00	 mov	 eax, 1
  00073	d1 e0		 shl	 eax, 1
  00075	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  00078	c6 04 01 01	 mov	 BYTE PTR [ecx+eax], 1
$LN7@ItemIsBufE:

; 4289 : 	if( lpItem->IsExtDamageReflect()      ) buf[3] = 1;

  0007c	8b 4d 0c	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  0007f	e8 00 00 00 00	 call	 ?IsExtDamageReflect@CItem@@QAEHXZ ; CItem::IsExtDamageReflect
  00084	85 c0		 test	 eax, eax
  00086	74 0f		 je	 SHORT $LN8@ItemIsBufE
  00088	b8 01 00 00 00	 mov	 eax, 1
  0008d	6b c8 03	 imul	 ecx, eax, 3
  00090	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00093	c6 04 0a 01	 mov	 BYTE PTR [edx+ecx], 1
$LN8@ItemIsBufE:

; 4290 : 	if( lpItem->IsExtDefenseSuccessfull() ) buf[4] = 1;

  00097	8b 4d 0c	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  0009a	e8 00 00 00 00	 call	 ?IsExtDefenseSuccessfull@CItem@@QAEHXZ ; CItem::IsExtDefenseSuccessfull
  0009f	85 c0		 test	 eax, eax
  000a1	74 0f		 je	 SHORT $LN9@ItemIsBufE
  000a3	b8 01 00 00 00	 mov	 eax, 1
  000a8	c1 e0 02	 shl	 eax, 2
  000ab	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  000ae	c6 04 01 01	 mov	 BYTE PTR [ecx+eax], 1
$LN9@ItemIsBufE:

; 4291 : 	if( lpItem->IsExtMonsterMoney()       ) buf[5] = 1;

  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  000b5	e8 00 00 00 00	 call	 ?IsExtMonsterMoney@CItem@@QAEHXZ ; CItem::IsExtMonsterMoney
  000ba	85 c0		 test	 eax, eax
  000bc	74 0f		 je	 SHORT $LN1@ItemIsBufE
  000be	b8 01 00 00 00	 mov	 eax, 1
  000c3	6b c8 05	 imul	 ecx, eax, 5
  000c6	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  000c9	c6 04 0a 01	 mov	 BYTE PTR [edx+ecx], 1
$LN1@ItemIsBufE:

; 4292 : }

  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx
  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c3		 ret	 0
?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ENDP		; ItemIsBufExOption
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCanItemTouch@@YAHPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_type$ = 12						; size = 4
?gObjCanItemTouch@@YAHPAVOBJECTSTRUCT@@H@Z PROC		; gObjCanItemTouch, COMDAT

; 4246 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4247 : 	//     ..
; 4248 : 	if( (lpObj->Penalty&CTLCODE_ITEMDONTTOUCH) == CTLCODE_ITEMDONTTOUCH)

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	8b 88 a8 01 00
	00		 mov	 ecx, DWORD PTR [eax+424]
  00012	83 e1 04	 and	 ecx, 4
  00015	74 04		 je	 SHORT $LN2@gObjCanIte

; 4249 : 	{
; 4250 : 		return FALSE;

  00017	33 c0		 xor	 eax, eax
  00019	eb 2a		 jmp	 SHORT $LN1@gObjCanIte
$LN2@gObjCanIte:

; 4251 : 	}
; 4252 : 
; 4253 : 	//      .. 
; 4254 : 	if( (lpObj->Penalty&CTLCODE_ACCOUNTITEMBLOCK) == CTLCODE_ACCOUNTITEMBLOCK)

  0001b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001e	8b 88 a8 01 00
	00		 mov	 ecx, DWORD PTR [eax+424]
  00024	83 e1 08	 and	 ecx, 8
  00027	74 17		 je	 SHORT $LN3@gObjCanIte

; 4255 : 	{
; 4256 : 		if( type == I_WAREHOUSE || type == I_INVENTORY)

  00029	83 7d 0c 06	 cmp	 DWORD PTR _type$[ebp], 6
  0002d	74 06		 je	 SHORT $LN5@gObjCanIte
  0002f	83 7d 0c 08	 cmp	 DWORD PTR _type$[ebp], 8
  00033	75 07		 jne	 SHORT $LN4@gObjCanIte
$LN5@gObjCanIte:

; 4257 : 		{
; 4258 : 			return TRUE;

  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	eb 09		 jmp	 SHORT $LN1@gObjCanIte
$LN4@gObjCanIte:

; 4259 : 		}
; 4260 : 		return FALSE;

  0003c	33 c0		 xor	 eax, eax
  0003e	eb 05		 jmp	 SHORT $LN1@gObjCanIte
$LN3@gObjCanIte:

; 4261 : 	}
; 4262 : 	return TRUE;

  00040	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjCanIte:

; 4263 : }

  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?gObjCanItemTouch@@YAHPAVOBJECTSTRUCT@@H@Z ENDP		; gObjCanItemTouch
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjChaosItemSet@@YAXHHE@Z
_TEXT	SEGMENT
_height$ = -8						; size = 4
_width$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_itempos$ = 12						; size = 4
_set_byte$ = 16						; size = 1
?gObjChaosItemSet@@YAXHHE@Z PROC			; gObjChaosItemSet, COMDAT

; 16365: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 16366: 	if( itempos < 0 ) return;

  00009	83 7d 0c 00	 cmp	 DWORD PTR _itempos$[ebp], 0
  0000d	7d 02		 jge	 SHORT $LN2@gObjChaosI
  0000f	eb 7a		 jmp	 SHORT $LN1@gObjChaosI
$LN2@gObjChaosI:

; 16367: 	if( itempos > MAX_CHAOSBOXITEMS-1 ) return;

  00011	83 7d 0c 1f	 cmp	 DWORD PTR _itempos$[ebp], 31 ; 0000001fH
  00015	7e 02		 jle	 SHORT $LN3@gObjChaosI
  00017	eb 72		 jmp	 SHORT $LN1@gObjChaosI
$LN3@gObjChaosI:

; 16368: 	
; 16369: 	int width, height;
; 16370: 
; 16371: 	if( gObj[aIndex].pChaosBox[itempos].GetSize( width, height ) == FALSE ) 

  00019	8d 45 f8	 lea	 eax, DWORD PTR _height$[ebp]
  0001c	50		 push	 eax
  0001d	8d 4d fc	 lea	 ecx, DWORD PTR _width$[ebp]
  00020	51		 push	 ecx
  00021	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00028	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _itempos$[ebp], 168
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00034	03 8c 10 ac 0c
	00 00		 add	 ecx, DWORD PTR [eax+edx+3244]
  0003b	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  00040	85 c0		 test	 eax, eax
  00042	75 2a		 jne	 SHORT $LN4@gObjChaosI

; 16372: 	{
; 16373: 		LogAdd(lMsg.Get(527), __FILE__, __LINE__);

  00044	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjChaosItemSet@@YAXHHE@Z@4JA
  00049	83 c0 08	 add	 eax, 8
  0004c	50		 push	 eax
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00052	68 0f 02 00 00	 push	 527			; 0000020fH
  00057	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00062	50		 push	 eax
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16374: 		return;

  0006c	eb 1d		 jmp	 SHORT $LN1@gObjChaosI
$LN4@gObjChaosI:

; 16375: 	}
; 16376: 	gObjChaosItemBoxSet(aIndex, itempos, width, height, set_byte);	

  0006e	0f b6 45 10	 movzx	 eax, BYTE PTR _set_byte$[ebp]
  00072	50		 push	 eax
  00073	8b 4d f8	 mov	 ecx, DWORD PTR _height$[ebp]
  00076	51		 push	 ecx
  00077	8b 55 fc	 mov	 edx, DWORD PTR _width$[ebp]
  0007a	52		 push	 edx
  0007b	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 ?gObjChaosItemBoxSet@@YAXHHHHE@Z ; gObjChaosItemBoxSet
  00088	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@gObjChaosI:

; 16377: }

  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?gObjChaosItemSet@@YAXHHE@Z ENDP			; gObjChaosItemSet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z
_TEXT	SEGMENT
_useClass$ = -64					; size = 4
_blank$ = -60						; size = 4
_iheight$ = -56						; size = 4
_iwidth$ = -52						; size = 4
_h$ = -48						; size = 4
_w$ = -44						; size = 4
_TempMap$ = -40						; size = 32
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_item$ = 12						; size = 168
_pos$ = 180						; size = 4
_source$ = 184						; size = 4
?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z PROC	; gObjChaosBoxInsertItemPos, COMDAT

; 16381: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 16382: 	if( pos < 0 || pos > MAX_CHAOSBOXITEMS-1 )

  00016	83 bd b4 00 00
	00 00		 cmp	 DWORD PTR _pos$[ebp], 0
  0001d	7c 09		 jl	 SHORT $LN3@gObjChaosB
  0001f	83 bd b4 00 00
	00 1f		 cmp	 DWORD PTR _pos$[ebp], 31 ; 0000001fH
  00026	7e 07		 jle	 SHORT $LN2@gObjChaosB
$LN3@gObjChaosB:

; 16383: 	{
; 16384: 		return 0xFF;

  00028	0c ff		 or	 al, 255			; 000000ffH
  0002a	e9 a9 01 00 00	 jmp	 $LN1@gObjChaosB
$LN2@gObjChaosB:

; 16385: 	}
; 16386: 	
; 16387: 	LPOBJECTSTRUCT	lpObj;
; 16388: 
; 16389: 	BYTE			TempMap[MAX_CHAOSBOXITEMS];				//   
; 16390: 	int				w, h, iwidth, iheight;
; 16391: 	int				blank;
; 16392: 	BOOL			useClass=FALSE;

  0002f	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _useClass$[ebp], 0

; 16393: 
; 16394: 	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  00036	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00043	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 16395: 
; 16396: 	//    ?
; 16397: 	if( lpObj->pChaosBox[pos].IsItem() == TRUE ) return 0xFF;

  00046	69 8d b4 00 00
	00 a8 00 00 00	 imul	 ecx, DWORD PTR _pos$[ebp], 168
  00050	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00053	03 88 ac 0c 00
	00		 add	 ecx, DWORD PTR [eax+3244]
  00059	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005e	83 f8 01	 cmp	 eax, 1
  00061	75 07		 jne	 SHORT $LN4@gObjChaosB
  00063	0c ff		 or	 al, 255			; 000000ffH
  00065	e9 6e 01 00 00	 jmp	 $LN1@gObjChaosB
$LN4@gObjChaosB:

; 16398: 
; 16399: 	//   ?
; 16400: 	if( item.IsItem() == FALSE ) return 0xFF;

  0006a	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  0006d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00072	85 c0		 test	 eax, eax
  00074	75 07		 jne	 SHORT $LN5@gObjChaosB
  00076	0c ff		 or	 al, 255			; 000000ffH
  00078	e9 5b 01 00 00	 jmp	 $LN1@gObjChaosB
$LN5@gObjChaosB:

; 16401: 	
; 16402: 	w = pos%8;

  0007d	8b 85 b4 00 00
	00		 mov	 eax, DWORD PTR _pos$[ebp]
  00083	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00088	79 05		 jns	 SHORT $LN13@gObjChaosB
  0008a	48		 dec	 eax
  0008b	83 c8 f8	 or	 eax, -8			; fffffff8H
  0008e	40		 inc	 eax
$LN13@gObjChaosB:
  0008f	89 45 d4	 mov	 DWORD PTR _w$[ebp], eax

; 16403: 	h = pos/8;

  00092	8b 85 b4 00 00
	00		 mov	 eax, DWORD PTR _pos$[ebp]
  00098	99		 cdq
  00099	83 e2 07	 and	 edx, 7
  0009c	03 c2		 add	 eax, edx
  0009e	c1 f8 03	 sar	 eax, 3
  000a1	89 45 d0	 mov	 DWORD PTR _h$[ebp], eax

; 16404: 		
; 16405: 	if( ExtentCheck(w, h, 8, 4) == FALSE) return 0xFF;

  000a4	6a 04		 push	 4
  000a6	6a 08		 push	 8
  000a8	8b 45 d0	 mov	 eax, DWORD PTR _h$[ebp]
  000ab	50		 push	 eax
  000ac	8b 4d d4	 mov	 ecx, DWORD PTR _w$[ebp]
  000af	51		 push	 ecx
  000b0	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  000b5	83 c4 10	 add	 esp, 16			; 00000010H
  000b8	85 c0		 test	 eax, eax
  000ba	75 07		 jne	 SHORT $LN6@gObjChaosB
  000bc	0c ff		 or	 al, 255			; 000000ffH
  000be	e9 15 01 00 00	 jmp	 $LN1@gObjChaosB
$LN6@gObjChaosB:

; 16406: 	item.GetSize(iwidth, iheight);

  000c3	8d 45 c8	 lea	 eax, DWORD PTR _iheight$[ebp]
  000c6	50		 push	 eax
  000c7	8d 4d cc	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  000ca	51		 push	 ecx
  000cb	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  000ce	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 16407: 
; 16408: 	if( source >= 0 )

  000d3	83 bd b8 00 00
	00 00		 cmp	 DWORD PTR _source$[ebp], 0
  000da	7c 3a		 jl	 SHORT $LN7@gObjChaosB

; 16409: 	{
; 16410: 		memcpy(TempMap, lpObj->pChaosBoxMap, MAX_CHAOSBOXITEMS);

  000dc	6a 20		 push	 32			; 00000020H
  000de	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e1	8b 88 b0 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3248]
  000e7	51		 push	 ecx
  000e8	8d 55 d8	 lea	 edx, DWORD PTR _TempMap$[ebp]
  000eb	52		 push	 edx
  000ec	e8 00 00 00 00	 call	 _memcpy
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16411: 		
; 16412: 		gObjChaosItemBoxSet(lpObj->m_Index, source, iwidth, iheight, 0xFF);

  000f4	68 ff 00 00 00	 push	 255			; 000000ffH
  000f9	8b 45 c8	 mov	 eax, DWORD PTR _iheight$[ebp]
  000fc	50		 push	 eax
  000fd	8b 4d cc	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  00100	51		 push	 ecx
  00101	8b 95 b8 00 00
	00		 mov	 edx, DWORD PTR _source$[ebp]
  00107	52		 push	 edx
  00108	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010d	51		 push	 ecx
  0010e	e8 00 00 00 00	 call	 ?gObjChaosItemBoxSet@@YAXHHHHE@Z ; gObjChaosItemBoxSet
  00113	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@gObjChaosB:

; 16413: 	}
; 16414: 	// .. ..
; 16415: 	if( *(lpObj->pChaosBoxMap+(h*8)+w) != 0xFF ) 

  00116	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00119	8b 88 b0 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3248]
  0011f	8b 55 d0	 mov	 edx, DWORD PTR _h$[ebp]
  00122	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00125	8b 4d d4	 mov	 ecx, DWORD PTR _w$[ebp]
  00128	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  0012c	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00132	74 25		 je	 SHORT $LN8@gObjChaosB

; 16416: 	{
; 16417: 		if( source >= 0 )

  00134	83 bd b8 00 00
	00 00		 cmp	 DWORD PTR _source$[ebp], 0
  0013b	7c 18		 jl	 SHORT $LN9@gObjChaosB

; 16418: 		{
; 16419: 			memcpy(lpObj->pChaosBoxMap, TempMap, MAX_CHAOSBOXITEMS);

  0013d	6a 20		 push	 32			; 00000020H
  0013f	8d 45 d8	 lea	 eax, DWORD PTR _TempMap$[ebp]
  00142	50		 push	 eax
  00143	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00146	8b 91 b0 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3248]
  0014c	52		 push	 edx
  0014d	e8 00 00 00 00	 call	 _memcpy
  00152	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@gObjChaosB:

; 16420: 		}
; 16421: 		return 0xFF;

  00155	0c ff		 or	 al, 255			; 000000ffH
  00157	eb 7f		 jmp	 SHORT $LN1@gObjChaosB
$LN8@gObjChaosB:

; 16422: 	}
; 16423: 
; 16424: 	blank = gObjMapRectCheck(lpObj->pChaosBoxMap, w, h, 8, 4, iwidth, iheight);

  00159	8b 45 c8	 mov	 eax, DWORD PTR _iheight$[ebp]
  0015c	50		 push	 eax
  0015d	8b 4d cc	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  00160	51		 push	 ecx
  00161	6a 04		 push	 4
  00163	6a 08		 push	 8
  00165	8b 55 d0	 mov	 edx, DWORD PTR _h$[ebp]
  00168	52		 push	 edx
  00169	8b 45 d4	 mov	 eax, DWORD PTR _w$[ebp]
  0016c	50		 push	 eax
  0016d	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00170	8b 91 b0 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3248]
  00176	52		 push	 edx
  00177	e8 00 00 00 00	 call	 ?gObjMapRectCheck@@YAEPAEHHHHHH@Z ; gObjMapRectCheck
  0017c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0017f	0f b6 c0	 movzx	 eax, al
  00182	89 45 c4	 mov	 DWORD PTR _blank$[ebp], eax

; 16425: 	//	gObjWerehouseRectCheck(lpObj->m_Index, w, h, iwidth, iheight);
; 16426: 	
; 16427: 	if( blank == 0xFF )

  00185	81 7d c4 ff 00
	00 00		 cmp	 DWORD PTR _blank$[ebp], 255 ; 000000ffH
  0018c	75 25		 jne	 SHORT $LN10@gObjChaosB

; 16428: 	{
; 16429: 		if( source >= 0 )

  0018e	83 bd b8 00 00
	00 00		 cmp	 DWORD PTR _source$[ebp], 0
  00195	7c 18		 jl	 SHORT $LN11@gObjChaosB

; 16430: 		{
; 16431: 			memcpy(lpObj->pChaosBoxMap, TempMap, MAX_CHAOSBOXITEMS);

  00197	6a 20		 push	 32			; 00000020H
  00199	8d 45 d8	 lea	 eax, DWORD PTR _TempMap$[ebp]
  0019c	50		 push	 eax
  0019d	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001a0	8b 91 b0 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3248]
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 _memcpy
  001ac	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@gObjChaosB:

; 16432: 		}
; 16433: 		return 0xFF;

  001af	0c ff		 or	 al, 255			; 000000ffH
  001b1	eb 25		 jmp	 SHORT $LN1@gObjChaosB
$LN10@gObjChaosB:

; 16434: 	}
; 16435: 	lpObj->pChaosBox[pos] = item;

  001b3	69 85 b4 00 00
	00 a8 00 00 00	 imul	 eax, DWORD PTR _pos$[ebp], 168
  001bd	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001c0	8b b9 ac 0c 00
	00		 mov	 edi, DWORD PTR [ecx+3244]
  001c6	03 f8		 add	 edi, eax
  001c8	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  001cd	8d 75 0c	 lea	 esi, DWORD PTR _item$[ebp]
  001d0	f3 a5		 rep movsd

; 16436: 	return pos;

  001d2	8a 85 b4 00 00
	00		 mov	 al, BYTE PTR _pos$[ebp]
$LN1@gObjChaosB:

; 16437: }

  001d8	5f		 pop	 edi
  001d9	5e		 pop	 esi
  001da	5b		 pop	 ebx
  001db	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001de	33 cd		 xor	 ecx, ebp
  001e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e5	8b e5		 mov	 esp, ebp
  001e7	5d		 pop	 ebp
  001e8	c3		 ret	 0
?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z ENDP	; gObjChaosBoxInsertItemPos
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?GetMapMoveLevel@@YAHPAVOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_overLevel$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_mapnumber$ = 12					; size = 4
_max_over$ = 16						; size = 4
?GetMapMoveLevel@@YAHPAVOBJECTSTRUCT@@HH@Z PROC		; GetMapMoveLevel, COMDAT

; 2313 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2314 : 	int overLevel=0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _overLevel$[ebp], 0

; 2315 : 	
; 2316 : 	if( mapnumber > g_TerrainManager.Size()-1 ) 

  00010	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  00015	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size
  0001a	83 e8 01	 sub	 eax, 1
  0001d	39 45 0c	 cmp	 DWORD PTR _mapnumber$[ebp], eax
  00020	7e 27		 jle	 SHORT $LN2@GetMapMove

; 2317 : 	{
; 2318 : 		mapnumber = 0;

  00022	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _mapnumber$[ebp], 0

; 2319 : 		LogAdd("error-L3 : map number not %s %d", __FILE__, __LINE__);

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??GetMapMoveLevel@@YAHPAVOBJECTSTRUCT@@HH@Z@4JA
  0002e	83 c0 06	 add	 eax, 6
  00031	50		 push	 eax
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@HDKCFMCD@error?9L3?5?3?5map?5number?5not?5?$CFs?5?$CFd@
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2320 : 		return 0;

  00045	33 c0		 xor	 eax, eax
  00047	eb 6d		 jmp	 SHORT $LN1@GetMapMove
$LN2@GetMapMove:

; 2321 : 	}
; 2322 : 
; 2323 : 	if( max_over )

  00049	83 7d 10 00	 cmp	 DWORD PTR _max_over$[ebp], 0
  0004d	74 08		 je	 SHORT $LN3@GetMapMove

; 2324 : 	{
; 2325 : 		overLevel = max_over;

  0004f	8b 45 10	 mov	 eax, DWORD PTR _max_over$[ebp]
  00052	89 45 fc	 mov	 DWORD PTR _overLevel$[ebp], eax

; 2326 : 	}

  00055	eb 22		 jmp	 SHORT $LN4@GetMapMove
$LN3@GetMapMove:

; 2327 : 	else 
; 2328 : 	{
; 2329 : 		max_over  = g_TerrainManager.GetMinLevel(mapnumber);

  00057	8b 45 0c	 mov	 eax, DWORD PTR _mapnumber$[ebp]
  0005a	50		 push	 eax
  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  00060	e8 00 00 00 00	 call	 ?GetMinLevel@CTerrainManager@@QAEHH@Z ; CTerrainManager::GetMinLevel
  00065	89 45 10	 mov	 DWORD PTR _max_over$[ebp], eax

; 2330 : 		overLevel = g_TerrainManager.GetMinLevel(mapnumber);

  00068	8b 45 0c	 mov	 eax, DWORD PTR _mapnumber$[ebp]
  0006b	50		 push	 eax
  0006c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  00071	e8 00 00 00 00	 call	 ?GetMinLevel@CTerrainManager@@QAEHH@Z ; CTerrainManager::GetMinLevel
  00076	89 45 fc	 mov	 DWORD PTR _overLevel$[ebp], eax
$LN4@GetMapMove:

; 2331 : 	}
; 2332 : 	
; 2333 : 	//  2/3  .
; 2334 : #ifdef DARKLORD_WORK
; 2335 : 	if( lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA )	

  00079	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00083	83 f9 04	 cmp	 ecx, 4
  00086	74 0f		 je	 SHORT $LN6@GetMapMove
  00088	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008b	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00092	83 f9 03	 cmp	 ecx, 3
  00095	75 1c		 jne	 SHORT $LN5@GetMapMove
$LN6@GetMapMove:

; 2336 : #else
; 2337 : 	if( lpObj->Class == CLASS_MAGUMSA )	
; 2338 : #endif
; 2339 : 	{		
; 2340 : 		if( overLevel > 0 )

  00097	83 7d fc 00	 cmp	 DWORD PTR _overLevel$[ebp], 0
  0009b	7e 16		 jle	 SHORT $LN5@GetMapMove

; 2341 : 		{
; 2342 : 			if( max_over > 0 )

  0009d	83 7d 10 00	 cmp	 DWORD PTR _max_over$[ebp], 0
  000a1	7e 10		 jle	 SHORT $LN5@GetMapMove

; 2343 : 			{
; 2344 : 				overLevel = ((max_over/3)*2);

  000a3	8b 45 10	 mov	 eax, DWORD PTR _max_over$[ebp]
  000a6	99		 cdq
  000a7	b9 03 00 00 00	 mov	 ecx, 3
  000ac	f7 f9		 idiv	 ecx
  000ae	d1 e0		 shl	 eax, 1
  000b0	89 45 fc	 mov	 DWORD PTR _overLevel$[ebp], eax
$LN5@GetMapMove:

; 2345 : 			}
; 2346 : 		}
; 2347 : 	}
; 2348 : 
; 2349 : 	return overLevel;

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _overLevel$[ebp]
$LN1@GetMapMove:

; 2350 : }

  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
?GetMapMoveLevel@@YAHPAVOBJECTSTRUCT@@HH@Z ENDP		; GetMapMoveLevel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv269 = -5624						; size = 4
tv153 = -5624						; size = 4
tv270 = -5620						; size = 4
tv154 = -5620						; size = 4
_pwCount$1 = -5104					; size = 5
_pGUCount$2 = -5096					; size = 5
_pGVCount$3 = -5088					; size = 5
_pMsg$4 = -5080						; size = 42
_pGVUMsg$5 = -5036					; size = 4
_MVL$ = -5032						; size = 4
_pwCount$ = -5028					; size = 5
_count$ = -5020						; size = 4
_lOfs$ = -5016						; size = 4
_sendBuf$ = -5012					; size = 5000
_tObjNum$ = -12						; size = 4
_n$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z PROC ; gObjViewportListProtocolCreate, COMDAT

; 23700: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 f8 15 00 00	 mov	 eax, 5624		; 000015f8H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi

; 23701: 	int		n;
; 23702: 	int		tObjNum;
; 23703: 	BYTE	sendBuf[5000];
; 23704: 	int		lOfs;
; 23705: 	int		count      = 0;

  0001a	c7 85 64 ec ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$[ebp], 0

; 23706: 
; 23707: #ifdef MODIFY_NEW_MONSTER_SKILL_01_20060724
; 23708: 	int		moncount = 0;
; 23709: #endif
; 23710: 	
; 23711: 	PWMSG_COUNT			pwCount;
; 23712: 	lOfs       = sizeof( pwCount);

  00024	c7 85 68 ec ff
	ff 05 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 5

; 23713: 
; 23714: #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 23715: 	int iViewportSize = 0;
; 23716: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 23717: 
; 23718: 	int MVL = MAXVIEWPORTOBJECT;

  0002e	c7 85 58 ec ff
	ff 4b 00 00 00	 mov	 DWORD PTR _MVL$[ebp], 75 ; 0000004bH

; 23719: 	if( lpObj->Type == OBJTYPE_MONSTER ) MVL = MAX_MONVIEWPORTOBJECT;

  00038	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003b	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0003f	83 f9 02	 cmp	 ecx, 2
  00042	75 0a		 jne	 SHORT $LN5@gObjViewpo
  00044	c7 85 58 ec ff
	ff 14 00 00 00	 mov	 DWORD PTR _MVL$[ebp], 20 ; 00000014H
$LN5@gObjViewpo:

; 23720: 
; 23721: 	if( lpObj->Type == OBJTYPE_CHARACTER ) 

  0004e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00051	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00055	83 f9 01	 cmp	 ecx, 1
  00058	0f 85 b3 07 00
	00		 jne	 $LN6@gObjViewpo

; 23722: 	{
; 23723: 		if( lpObj->m_Change >= 0 )

  0005e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00061	83 b8 a8 02 00
	00 00		 cmp	 DWORD PTR [eax+680], 0
  00068	0f 8c d6 01 00
	00		 jl	 $LN8@gObjViewpo

; 23724: 		{
; 23725: 			pViewportCreateChange.NumberH	= HIBYTE(lpObj->m_Index);

  0006e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	c1 e9 08	 shr	 ecx, 8
  00076	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0007c	88 0d 00 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A, cl

; 23726: 			pViewportCreateChange.NumberL	= LOBYTE(lpObj->m_Index);

  00082	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]
  00087	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0008d	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+1, cl

; 23727: 			
; 23728: 			pViewportCreateChange.NumberH |= (0x01<<7);	//   ..

  00093	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A
  0009a	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  0009f	a2 00 00 00 00	 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A, al

; 23729: 
; 23730: 			//LogAdd("  : %d %d",lpObj->X, lpObj->Y);
; 23731: 			pViewportCreateChange.X			= (BYTE)lpObj->X;

  000a4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a7	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  000ad	88 0d 02 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+2, cl

; 23732: 			pViewportCreateChange.Y			= (BYTE)lpObj->Y;

  000b3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b6	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  000bc	88 0d 03 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+3, cl

; 23733: 			pViewportCreateChange.TX		= (BYTE)lpObj->TX;

  000c2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c5	8a 88 20 01 00
	00		 mov	 cl, BYTE PTR [eax+288]
  000cb	88 0d 12 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+18, cl

; 23734: 			pViewportCreateChange.TY		= (BYTE)lpObj->TY;

  000d1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d4	8a 88 22 01 00
	00		 mov	 cl, BYTE PTR [eax+290]
  000da	88 0d 13 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+19, cl

; 23735: #ifdef ENHANCE_MONSTER_TYPE_TO_WORD_20040618
; 23736: 			pViewportCreateChange.SkinH		= HIBYTE(LOWORD(lpObj->m_Change));

  000e0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e3	8b 88 a8 02 00
	00		 mov	 ecx, DWORD PTR [eax+680]
  000e9	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000ef	0f b7 d1	 movzx	 edx, cx
  000f2	c1 ea 08	 shr	 edx, 8
  000f5	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000fb	88 15 04 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+4, dl

; 23737: 			pViewportCreateChange.SkinL		= LOBYTE(LOWORD(lpObj->m_Change));

  00101	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00104	8b 88 a8 02 00
	00		 mov	 ecx, DWORD PTR [eax+680]
  0010a	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00110	0f b7 d1	 movzx	 edx, cx
  00113	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00119	88 15 05 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+5, dl

; 23738: #else
; 23739: 			pViewportCreateChange.Skin		= lpObj->m_Change;
; 23740: #endif
; 23741: 
; 23742: #ifdef UPDATE_GM_FUNCTION_20070228
; 23743: 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 23744: 			if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_GM_MARK ) == true )
; 23745: 			{
; 23746: 				gObjAddBuffEffect( lpObj, BUFFTYPE_GM_MARK, 0, 0, 0, 0, BUFFTIME_INFINITE );
; 23747: 			}
; 23748: 	#else
; 23749: 			if((lpObj->Authority&AUTHORITY_EVENT_GM) == AUTHORITY_EVENT_GM)
; 23750: 			{
; 23751: 				pViewportCreateChange.ViewSkillState	|= STATE_ADD_GM_MARK;
; 23752: 				lpObj->m_ViewSkillState					|= STATE_ADD_GM_MARK;
; 23753: 			}
; 23754: 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 23755: #endif
; 23756: 
; 23757: #ifndef MODIFY_BUFF_SYSTEM_EXTENTION_20070917					// !! NOT
; 23758: 			pViewportCreateChange.ViewSkillState = lpObj->m_ViewSkillState;

  0011f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00122	66 8b 88 c0 01
	00 00		 mov	 cx, WORD PTR [eax+448]
  00129	66 89 0d 06 00
	00 00		 mov	 WORD PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+6, cx

; 23759: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 23760: 			pViewportCreateChange.DirAndPkLevel = lpObj->Dir<<4;

  00130	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00133	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  0013a	c1 e1 04	 shl	 ecx, 4
  0013d	88 0d 14 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+20, cl

; 23761: 
; 23762: 			if(lpObj->m_stateEngagePVP == PVP_USER_PLAYING)

  00143	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00146	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  0014d	75 11		 jne	 SHORT $LN10@gObjViewpo

; 23763: 				pViewportCreateChange.DirAndPkLevel |= ((PK_LEVEL_DEFAULT+3)&0x0F);

  0014f	0f b6 05 14 00
	00 00		 movzx	 eax, BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+20
  00156	83 c8 06	 or	 eax, 6
  00159	a2 14 00 00 00	 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+20, al
  0015e	eb 1c		 jmp	 SHORT $LN11@gObjViewpo
$LN10@gObjViewpo:

; 23764: 			else
; 23765: 				pViewportCreateChange.DirAndPkLevel |= (lpObj->m_PK_Level&0x0F);

  00160	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00163	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  0016a	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0016d	0f b6 15 14 00
	00 00		 movzx	 edx, BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+20
  00174	0b d1		 or	 edx, ecx
  00176	88 15 14 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+20, dl
$LN11@gObjViewpo:

; 23766: 
; 23767: #ifdef THIRD_CHANGEUP_SYSTEM_20070507	// 3  m_ViewState 
; 23768: 		lpObj->CharSet[0] &= 0xF8;						// 3   
; 23769: 		lpObj->CharSet[0] |= ( lpObj->m_ViewState & 0x07 );	// m_ViewState  3bit .
; 23770: #else
; 23771: #ifdef UPDATE_VIEWPORTCREATE_CHANGE_ADD_CHARSET_20070314
; 23772: 		lpObj->CharSet[0] &= 0xF0;
; 23773: 		lpObj->CharSet[0] |= (lpObj->m_ViewState&0x0F);
; 23774: #endif
; 23775: #endif	// THIRD_CHANGEUP_SYSTEM_20070507
; 23776: 
; 23777: #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004				// !! NOT
; 23778: 	#ifdef CHAOSCASTLE_SYSTEM_20040408		// !!> .          .
; 23779: 			if (CHECK_CHAOSCASTLE(lpObj->MapNumber)) {

  0017c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017f	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00186	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00189	7d 0c		 jge	 SHORT $LN37@gObjViewpo
  0018b	c7 85 0c ea ff
	ff 00 00 00 00	 mov	 DWORD PTR tv154[ebp], 0
  00195	eb 31		 jmp	 SHORT $LN38@gObjViewpo
$LN37@gObjViewpo:
  00197	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0019a	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  001a1	83 f8 17	 cmp	 eax, 23			; 00000017H
  001a4	7e 0c		 jle	 SHORT $LN35@gObjViewpo
  001a6	c7 85 08 ea ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
  001b0	eb 0a		 jmp	 SHORT $LN36@gObjViewpo
$LN35@gObjViewpo:
  001b2	c7 85 08 ea ff
	ff 01 00 00 00	 mov	 DWORD PTR tv153[ebp], 1
$LN36@gObjViewpo:
  001bc	8b 8d 08 ea ff
	ff		 mov	 ecx, DWORD PTR tv153[ebp]
  001c2	89 8d 0c ea ff
	ff		 mov	 DWORD PTR tv154[ebp], ecx
$LN38@gObjViewpo:
  001c8	83 bd 0c ea ff
	ff 00		 cmp	 DWORD PTR tv154[ebp], 0
  001cf	74 08		 je	 SHORT $LN12@gObjViewpo

; 23780: //				pViewportCreateChange.ViewSkillState &= ~STATE_REDUCE_MAGICDEFENSE;		// 
; 23781: //				pViewportCreateChange.ViewSkillState &= ~STATE_ADD_LIFE;				// 
; 23782: //				pViewportCreateChange.ViewSkillState &= ~STATE_ATTACK;					// 
; 23783: //				pViewportCreateChange.ViewSkillState &= ~STATE_DEFENSE;					// 
; 23784: 				pViewportCreateChange.ViewSkillState = 0;

  001d1	33 c0		 xor	 eax, eax
  001d3	66 a3 06 00 00
	00		 mov	 WORD PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+6, ax
$LN12@gObjViewpo:

; 23785: 			}
; 23786: 	#endif
; 23787: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 23788: 
; 23789: #ifdef UPDATE_VIEWPORTCREATE_CHANGE_ADD_CHARSET_20070314	// gObjViewportListProtocolCreate()    
; 23790: 			memcpy(&pViewportCreateChange.CharSet, lpObj->CharSet, MAX_PREVIEWCHARSET+9);
; 23791: #endif	
; 23792: 
; 23793: 			memcpy(pViewportCreateChange.Id, lpObj->Name, MAX_IDSTRING);

  001d9	6a 0a		 push	 10			; 0000000aH
  001db	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001de	83 c0 73	 add	 eax, 115		; 00000073H
  001e1	50		 push	 eax
  001e2	68 08 00 00 00	 push	 OFFSET ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+8
  001e7	e8 00 00 00 00	 call	 _memcpy
  001ec	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23794: #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 23795: 			iViewportSize = gObjMakeViewportState( lpObj, pViewportCreateChange.BuffEffectList );
; 23796: 			pViewportCreateChange.BuffEffectCount = iViewportSize;
; 23797: 			memcpy((sendBuf+lOfs), (char*)&pViewportCreateChange, ( sizeof(PMSG_VIEWPORTCREATE_CHANGE) - ( MAX_BUFF_SLOT_INDEX - iViewportSize ) ) );
; 23798: 			//memcpy((sendBuf+lOfs), (char*)&pViewportCreateChange, ( sizeof(PMSG_VIEWPORTCREATE_CHANGE) - ( MAX_BUFF_SLOT_INDEX - iViewportSize ) ) );
; 23799: 			lOfs += ( sizeof(PMSG_VIEWPORTCREATE_CHANGE) - ( MAX_BUFF_SLOT_INDEX - iViewportSize ) );
; 23800: #else
; 23801: 			memcpy((sendBuf+lOfs), (char*)&pViewportCreateChange, sizeof(PMSG_VIEWPORTCREATE_CHANGE));

  001ef	6a 16		 push	 22			; 00000016H
  001f1	68 00 00 00 00	 push	 OFFSET ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A ; pViewportCreateChange
  001f6	8b 85 68 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  001fc	8d 8c 05 6c ec
	ff ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp+eax]
  00203	51		 push	 ecx
  00204	e8 00 00 00 00	 call	 _memcpy
  00209	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23802: 			lOfs += sizeof(PMSG_VIEWPORTCREATE_CHANGE);

  0020c	8b 85 68 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00212	83 c0 16	 add	 eax, 22			; 00000016H
  00215	89 85 68 ec ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 23803: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 23804: 			count++;

  0021b	8b 85 64 ec ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  00221	83 c0 01	 add	 eax, 1
  00224	89 85 64 ec ff
	ff		 mov	 DWORD PTR _count$[ebp], eax

; 23805: 
; 23806: 			if( count < 1 )

  0022a	83 bd 64 ec ff
	ff 01		 cmp	 DWORD PTR _count$[ebp], 1
  00231	7d 05		 jge	 SHORT $LN13@gObjViewpo

; 23807: 			{
; 23808: 				return;

  00233	e9 ce 07 00 00	 jmp	 $LN1@gObjViewpo
$LN13@gObjViewpo:

; 23809: 			}
; 23810: 			pwCount.h.headcode  = 0x45;

  00238	c6 85 5f ec ff
	ff 45		 mov	 BYTE PTR _pwCount$[ebp+3], 69 ; 00000045H

; 23811: 		}

  0023f	e9 4d 02 00 00	 jmp	 $LN9@gObjViewpo
$LN8@gObjViewpo:

; 23812: 		else
; 23813: 		{			
; 23814: 			pViewportCreate.NumberH = HIBYTE(lpObj->m_Index);

  00244	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00247	8b 08		 mov	 ecx, DWORD PTR [eax]
  00249	c1 e9 08	 shr	 ecx, 8
  0024c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00252	88 0d 00 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A, cl

; 23815: 			pViewportCreate.NumberL = LOBYTE(lpObj->m_Index);

  00258	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0025b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0025d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00263	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+1, cl

; 23816: 			
; 23817: #ifdef THIRD_CHANGEUP_SYSTEM_20070507	//     3     .
; 23818: 			lpObj->CharSet[0] &= 0xF8;	// 3  
; 23819: #else
; 23820: 			lpObj->CharSet[0] &= 0xF0;	

  00269	b8 01 00 00 00	 mov	 eax, 1
  0026e	6b c8 00	 imul	 ecx, eax, 0
  00271	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00274	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  0027c	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00281	b9 01 00 00 00	 mov	 ecx, 1
  00286	6b d1 00	 imul	 edx, ecx, 0
  00289	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0028c	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al

; 23821: #endif
; 23822: 			
; 23823: 			if( lpObj->m_State == OBJST_CREATE )

  00293	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00296	83 b8 b8 01 00
	00 01		 cmp	 DWORD PTR [eax+440], 1
  0029d	75 1f		 jne	 SHORT $LN14@gObjViewpo

; 23824: 			{
; 23825: 				if( !lpObj->Teleport )

  0029f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a2	0f be 88 fc 01
	00 00		 movsx	 ecx, BYTE PTR [eax+508]
  002a9	85 c9		 test	 ecx, ecx
  002ab	75 11		 jne	 SHORT $LN14@gObjViewpo

; 23826: 				{
; 23827: 					pViewportCreate.NumberH |= (0x01<<7);	//   ..

  002ad	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A
  002b4	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  002b9	a2 00 00 00 00	 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A, al
$LN14@gObjViewpo:

; 23828: 				}
; 23829: 			}
; 23830: 
; 23831: #ifndef MODIFY_BUFF_SYSTEM_EXTENTION_20070917					// !! NOT
; 23832: 			pViewportCreate.ViewSkillState = lpObj->m_ViewSkillState;

  002be	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c1	66 8b 88 c0 01
	00 00		 mov	 cx, WORD PTR [eax+448]
  002c8	66 89 0d 12 00
	00 00		 mov	 WORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+18, cx

; 23833: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 23834: #ifdef THIRD_CHANGEUP_SYSTEM_20070507	// m_ViewState 
; 23835: 			lpObj->CharSet[0] |= (lpObj->m_ViewState&0x07);	// 3  
; 23836: #else
; 23837: 			lpObj->CharSet[0] |= (lpObj->m_ViewState&0x0F);

  002cf	b8 01 00 00 00	 mov	 eax, 1
  002d4	6b c8 00	 imul	 ecx, eax, 0
  002d7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002da	0f be 82 be 01
	00 00		 movsx	 eax, BYTE PTR [edx+446]
  002e1	83 e0 0f	 and	 eax, 15			; 0000000fH
  002e4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002e7	0f b6 8c 0a 28
	03 00 00	 movzx	 ecx, BYTE PTR [edx+ecx+808]
  002ef	0b c8		 or	 ecx, eax
  002f1	ba 01 00 00 00	 mov	 edx, 1
  002f6	6b c2 00	 imul	 eax, edx, 0
  002f9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002fc	88 8c 02 28 03
	00 00		 mov	 BYTE PTR [edx+eax+808], cl

; 23838: #endif
; 23839: 
; 23840: 			//LogAdd(" 2 : %d %d",lpObj->X, lpObj->Y);
; 23841: 
; 23842: 			pViewportCreate.X       = (BYTE)lpObj->X;

  00303	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00306	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  0030c	88 0d 02 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+2, cl

; 23843: 			pViewportCreate.Y       = (BYTE)lpObj->Y;

  00312	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00315	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  0031b	88 0d 03 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+3, cl

; 23844: 			pViewportCreate.TX		= (BYTE)lpObj->TX;

  00321	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00324	8a 88 20 01 00
	00		 mov	 cl, BYTE PTR [eax+288]
  0032a	88 0d 1e 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+30, cl

; 23845: 			pViewportCreate.TY		= (BYTE)lpObj->TY;

  00330	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00333	8a 88 22 01 00
	00		 mov	 cl, BYTE PTR [eax+290]
  00339	88 0d 1f 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+31, cl

; 23846: 			pViewportCreate.DirAndPkLevel = lpObj->Dir<<4;

  0033f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00342	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  00349	c1 e1 04	 shl	 ecx, 4
  0034c	88 0d 20 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+32, cl

; 23847: 
; 23848: 			if(lpObj->m_stateEngagePVP == PVP_USER_PLAYING && lpObj->MapNumber != PVP_EVENT_MAP)

  00352	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00355	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  0035c	75 1f		 jne	 SHORT $LN16@gObjViewpo
  0035e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00361	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00368	83 f9 09	 cmp	 ecx, 9
  0036b	74 10		 je	 SHORT $LN16@gObjViewpo

; 23849: 			{
; 23850: 				g_PvpEvent.DeleteUser(lpObj->m_Index);

  0036d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00370	8b 08		 mov	 ecx, DWORD PTR [eax]
  00372	51		 push	 ecx
  00373	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PvpEvent@@3VCEngagePVP@@A ; g_PvpEvent
  00378	e8 00 00 00 00	 call	 ?DeleteUser@CEngagePVP@@QAEXH@Z ; CEngagePVP::DeleteUser
$LN16@gObjViewpo:

; 23851: 			}
; 23852: 
; 23853: 			if(lpObj->m_stateEngagePVP == PVP_USER_PLAYING)

  0037d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00380	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  00387	75 11		 jne	 SHORT $LN17@gObjViewpo

; 23854: 				pViewportCreate.DirAndPkLevel |= ((PK_LEVEL_DEFAULT+3)&0x0F);

  00389	0f b6 05 20 00
	00 00		 movzx	 eax, BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+32
  00390	83 c8 06	 or	 eax, 6
  00393	a2 20 00 00 00	 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+32, al
  00398	eb 1c		 jmp	 SHORT $LN18@gObjViewpo
$LN17@gObjViewpo:

; 23855: 			else
; 23856: 				pViewportCreate.DirAndPkLevel |= (lpObj->m_PK_Level&0x0F);

  0039a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039d	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  003a4	83 e1 0f	 and	 ecx, 15			; 0000000fH
  003a7	0f b6 15 20 00
	00 00		 movzx	 edx, BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+32
  003ae	0b d1		 or	 edx, ecx
  003b0	88 15 20 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+32, dl
$LN18@gObjViewpo:

; 23857: 
; 23858: #ifndef MODIFY_BUFF_SYSTEM_EXTENTION_20070917			// !! NOT
; 23859: 	#ifdef CHAOSCASTLE_SYSTEM_20040408		// !!> .          .
; 23860: 			if (CHECK_CHAOSCASTLE(lpObj->MapNumber)) {

  003b6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003b9	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  003c0	83 f9 12	 cmp	 ecx, 18			; 00000012H
  003c3	7d 0c		 jge	 SHORT $LN41@gObjViewpo
  003c5	c7 85 0c ea ff
	ff 00 00 00 00	 mov	 DWORD PTR tv270[ebp], 0
  003cf	eb 31		 jmp	 SHORT $LN42@gObjViewpo
$LN41@gObjViewpo:
  003d1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003d4	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  003db	83 f8 17	 cmp	 eax, 23			; 00000017H
  003de	7e 0c		 jle	 SHORT $LN39@gObjViewpo
  003e0	c7 85 08 ea ff
	ff 00 00 00 00	 mov	 DWORD PTR tv269[ebp], 0
  003ea	eb 0a		 jmp	 SHORT $LN40@gObjViewpo
$LN39@gObjViewpo:
  003ec	c7 85 08 ea ff
	ff 01 00 00 00	 mov	 DWORD PTR tv269[ebp], 1
$LN40@gObjViewpo:
  003f6	8b 8d 08 ea ff
	ff		 mov	 ecx, DWORD PTR tv269[ebp]
  003fc	89 8d 0c ea ff
	ff		 mov	 DWORD PTR tv270[ebp], ecx
$LN42@gObjViewpo:
  00402	83 bd 0c ea ff
	ff 00		 cmp	 DWORD PTR tv270[ebp], 0
  00409	74 08		 je	 SHORT $LN19@gObjViewpo

; 23861: //				pViewportCreateChange.ViewSkillState &= ~STATE_REDUCE_MAGICDEFENSE;		// 
; 23862: //				pViewportCreateChange.ViewSkillState &= ~STATE_ADD_LIFE;				// 
; 23863: //				pViewportCreateChange.ViewSkillState &= ~STATE_ATTACK;					// 
; 23864: //				pViewportCreateChange.ViewSkillState &= ~STATE_DEFENSE;					// 
; 23865: 				pViewportCreate.ViewSkillState = 0;

  0040b	33 c0		 xor	 eax, eax
  0040d	66 a3 12 00 00
	00		 mov	 WORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+18, ax
$LN19@gObjViewpo:

; 23866: 			}
; 23867: 	#endif
; 23868: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 23869: 
; 23870: #ifdef ITEM_INDEX_EXTEND_20050706
; 23871: 				memcpy(&pViewportCreate.CharSet, lpObj->CharSet, MAX_PREVIEWCHARSET+9);
; 23872: #else
; 23873: #ifdef DARKLORD_WORK
; 23874: 				memcpy(&pViewportCreate.CharSet, lpObj->CharSet, MAX_PREVIEWCHARSET+4);

  00413	6a 0d		 push	 13			; 0000000dH
  00415	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00418	05 28 03 00 00	 add	 eax, 808		; 00000328H
  0041d	50		 push	 eax
  0041e	68 04 00 00 00	 push	 OFFSET ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+4
  00423	e8 00 00 00 00	 call	 _memcpy
  00428	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23875: #else
; 23876: 				memcpy(&pViewportCreate.CharSet, lpObj->CharSet, MAX_PREVIEWCHARSET+3);
; 23877: #endif
; 23878: #endif
; 23879: 
; 23880: 			memcpy(pViewportCreate.Id, lpObj->Name, MAX_IDSTRING);

  0042b	6a 0a		 push	 10			; 0000000aH
  0042d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00430	83 c0 73	 add	 eax, 115		; 00000073H
  00433	50		 push	 eax
  00434	68 14 00 00 00	 push	 OFFSET ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+20
  00439	e8 00 00 00 00	 call	 _memcpy
  0043e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23881: #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 23882: 			iViewportSize = gObjMakeViewportState( lpObj, pViewportCreate.BuffEffectList );
; 23883: 			pViewportCreate.BuffEffectCount = iViewportSize;
; 23884: 			//memcpy((sendBuf+lOfs), (char*)&pViewportCreate, ( sizeof(PMSG_VIEWPORTCREATE) - ( MAX_BUFF_SLOT_INDEX - iViewportSize ) ) );
; 23885: 			memcpy((sendBuf+lOfs), (char*)&pViewportCreate, sizeof(PMSG_VIEWPORTCREATE) );
; 23886: 			lOfs += ( sizeof(PMSG_VIEWPORTCREATE) - ( MAX_BUFF_SLOT_INDEX - iViewportSize ) );
; 23887: #else
; 23888: 			memcpy((sendBuf+lOfs), (char*)&pViewportCreate, sizeof(PMSG_VIEWPORTCREATE));

  00441	6a 22		 push	 34			; 00000022H
  00443	68 00 00 00 00	 push	 OFFSET ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A ; pViewportCreate
  00448	8b 85 68 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0044e	8d 8c 05 6c ec
	ff ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp+eax]
  00455	51		 push	 ecx
  00456	e8 00 00 00 00	 call	 _memcpy
  0045b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23889: 			lOfs += sizeof(PMSG_VIEWPORTCREATE);

  0045e	8b 85 68 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00464	83 c0 22	 add	 eax, 34			; 00000022H
  00467	89 85 68 ec ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 23890: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 23891: 			count++;

  0046d	8b 85 64 ec ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  00473	83 c0 01	 add	 eax, 1
  00476	89 85 64 ec ff
	ff		 mov	 DWORD PTR _count$[ebp], eax

; 23892: 
; 23893: 			if( count < 1 )

  0047c	83 bd 64 ec ff
	ff 01		 cmp	 DWORD PTR _count$[ebp], 1
  00483	7d 05		 jge	 SHORT $LN20@gObjViewpo

; 23894: 			{
; 23895: 				return;

  00485	e9 7c 05 00 00	 jmp	 $LN1@gObjViewpo
$LN20@gObjViewpo:

; 23896: 			}
; 23897: 			pwCount.h.headcode  = PMHC_VIEWPORTCREATE;

  0048a	c6 85 5f ec ff
	ff 12		 mov	 BYTE PTR _pwCount$[ebp+3], 18 ; 00000012H
$LN9@gObjViewpo:

; 23898: 		}
; 23899: 
; 23900: #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004			// !! NOT
; 23901: 	#ifdef UPDATE_GM_FUNCTION_20070228
; 23902: 		if((lpObj->Authority&AUTHORITY_EVENT_GM) == AUTHORITY_EVENT_GM)
; 23903: 		{
; 23904: 			pViewportCreate.ViewSkillState			|= STATE_ADD_GM_MARK;
; 23905: 			lpObj->m_ViewSkillState					|= STATE_ADD_GM_MARK;
; 23906: 		}
; 23907: 	#endif
; 23908: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 23909: 
; 23910: 		pwCount.h.c         = PMHC_WORD;

  00491	c6 85 5c ec ff
	ff c2		 mov	 BYTE PTR _pwCount$[ebp], 194 ; 000000c2H

; 23911: 		pwCount.h.sizeH     = HIBYTE(lOfs);

  00498	8b 85 68 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0049e	c1 e8 08	 shr	 eax, 8
  004a1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004a6	88 85 5d ec ff
	ff		 mov	 BYTE PTR _pwCount$[ebp+1], al

; 23912: 		pwCount.h.sizeL     = LOBYTE(lOfs);

  004ac	8b 85 68 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  004b2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004b7	88 85 5e ec ff
	ff		 mov	 BYTE PTR _pwCount$[ebp+2], al

; 23913: 		pwCount.count       = count;

  004bd	8a 85 64 ec ff
	ff		 mov	 al, BYTE PTR _count$[ebp]
  004c3	88 85 60 ec ff
	ff		 mov	 BYTE PTR _pwCount$[ebp+4], al

; 23914: 		memcpy(sendBuf, (char*)&pwCount, sizeof(PWMSG_COUNT));

  004c9	6a 05		 push	 5
  004cb	8d 85 5c ec ff
	ff		 lea	 eax, DWORD PTR _pwCount$[ebp]
  004d1	50		 push	 eax
  004d2	8d 8d 6c ec ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  004d8	51		 push	 ecx
  004d9	e8 00 00 00 00	 call	 _memcpy
  004de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23915: 		DataSend(lpObj->m_Index, (LPBYTE)sendBuf, lOfs);

  004e1	8b 85 68 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  004e7	50		 push	 eax
  004e8	8d 8d 6c ec ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  004ee	51		 push	 ecx
  004ef	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004f2	8b 02		 mov	 eax, DWORD PTR [edx]
  004f4	50		 push	 eax
  004f5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  004fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23916: 		
; 23917: #ifdef MODIFY_GUILD_VIEWPORT_01_20040701
; 23918: //   .
; 23919: 		if( lpObj->GuildNumber )
; 23920: 		{
; 23921: 			GuildInfoOfs=0;
; 23922: 			GuildInfoOfs=sizeof(PMSG_SIMPLE_GUILDVIEWPORT_COUNT);
; 23923: 
; 23924: 			PMSG_SIMPLE_GUILDVIEWPORT		pMsg;
; 23925: 
; 23926: #ifdef MODIFY_GUILD_VIEWPORT_02_20040830
; 23927: 			pMsg.GuildNumber= lpObj->lpGuild->Number;
; 23928: #else
; 23929: 			pMsg.GNumberH	= HIBYTE(lpObj->lpGuild->Number);
; 23930: 			pMsg.GNumberL	= LOBYTE(lpObj->lpGuild->Number);
; 23931: #endif
; 23932: 			pMsg.NumberH	= HIBYTE(lpObj->m_Index)&0x7f;
; 23933: 			pMsg.NumberL	= LOBYTE(lpObj->m_Index);
; 23934: 			if(!strcmp(lpObj->lpGuild->Names[0], lpObj->Name))
; 23935: 			{	//   
; 23936: 				pMsg.NumberH |= 0x80;
; 23937: 			}
; 23938: 		
; 23939: #ifdef ADD_NEW_GUILD_02_20040922
; 23940: 			pMsg.btGuildType = lpObj->lpGuild->btGuildType;
; 23941: #endif
; 23942: 			
; 23943: #ifdef ADD_NEW_GUILD_01_20040913
; 23944: 			pMsg.btGuildStatus = lpObj->GuildStatus;
; 23945: #endif
; 23946: 
; 23947: #ifdef UPDATE_CHECK_CASTLE_OWNERMEMBER_20090217
; 23948: 			if (g_CastleSiegeSync.CheckCastleOwnerMember(lpObj->m_Index) == TRUE ||
; 23949: 				g_CastleSiegeSync.CheckCastleOwnerUnionMember(lpObj->m_Index) == TRUE)
; 23950: 			{
; 23951: 				pMsg.btCastleOwner = 0x01;
; 23952: 			}
; 23953: 			else
; 23954: 			{
; 23955: 				pMsg.btCastleOwner = 0x00;
; 23956: 			}						
; 23957: #endif	// UPDATE_CHECK_CASTLE_OWNERMEMBER_20090217
; 23958: 
; 23959: 			memcpy(GuildInfoBuf+GuildInfoOfs, &pMsg, sizeof(pMsg));
; 23960: 			GuildInfoOfs += sizeof( pMsg );
; 23961: 			
; 23962: 			PMSG_SIMPLE_GUILDVIEWPORT_COUNT pGVCount;
; 23963: 			
; 23964: 			pGVCount.h.c		= PMHC_WORD;
; 23965: 			pGVCount.h.headcode = 0x65;
; 23966: 			pGVCount.h.sizeH	= HIBYTE( GuildInfoOfs );
; 23967: 			pGVCount.h.sizeL	= LOBYTE( GuildInfoOfs );
; 23968: 			pGVCount.Count		= 1;
; 23969: 			memcpy(GuildInfoBuf, &pGVCount, sizeof(pGVCount));
; 23970: 			DataSend(lpObj->m_Index, (LPBYTE)GuildInfoBuf, GuildInfoOfs);
; 23971: 		}
; 23972: 		
; 23973: #else // MODIFY_GUILD_VIEWPORT_01_20040701
; 23974: 		
; 23975: 		//ViewGuildMng.Init();
; 23976: 		GuildInfoOfs=0;

  004fd	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GuildInfoOfs@@3HA, 0 ; GuildInfoOfs

; 23977: 		GuildInfoCount=0;

  00507	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GuildInfoCount@@3HA, 0 ; GuildInfoCount

; 23978: 		GuildUserOfs=0;

  00511	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GuildUserOfs@@3HA, 0 ; GuildUserOfs

; 23979: 		GuildUserCount=0;

  0051b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GuildUserCount@@3HA, 0 ; GuildUserCount

; 23980: 		
; 23981: 		
; 23982: 		GuildInfoOfs=sizeof(PMSG_GUILDVIEWPORT_COUNT);

  00525	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?GuildInfoOfs@@3HA, 5 ; GuildInfoOfs

; 23983: 		GuildUserOfs=sizeof(PMSG_GUILDVIEWPORT_USERCOUNT);

  0052f	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?GuildUserOfs@@3HA, 5 ; GuildUserOfs

; 23984: 
; 23985: 		//    ..
; 23986: 		if( lpObj->GuildNumber )

  00539	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0053c	83 b8 90 02 00
	00 00		 cmp	 DWORD PTR [eax+656], 0
  00543	0f 84 00 02 00
	00		 je	 $LN21@gObjViewpo

; 23987: 		{
; 23988: 			PMSG_GUILDVIEWPORT_USER pGVUMsg;
; 23989: 			PMSG_GUILDVIEWPORT		pMsg;
; 23990: 			
; 23991: 			pMsg.NumberH = HIBYTE(lpObj->lpGuild->Number);

  00549	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0054c	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00552	8b 11		 mov	 edx, DWORD PTR [ecx]
  00554	c1 ea 08	 shr	 edx, 8
  00557	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0055d	88 95 28 ec ff
	ff		 mov	 BYTE PTR _pMsg$4[ebp], dl

; 23992: 			pMsg.NumberL = LOBYTE(lpObj->lpGuild->Number);		

  00563	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00566	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  0056c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0056e	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00574	88 95 29 ec ff
	ff		 mov	 BYTE PTR _pMsg$4[ebp+1], dl

; 23993: 			strcpy(pMsg.GuildName, lpObj->lpGuild->Name);

  0057a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0057d	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00583	83 c1 04	 add	 ecx, 4
  00586	51		 push	 ecx
  00587	8d 95 2a ec ff
	ff		 lea	 edx, DWORD PTR _pMsg$4[ebp+2]
  0058d	52		 push	 edx
  0058e	e8 00 00 00 00	 call	 _strcpy
  00593	83 c4 08	 add	 esp, 8

; 23994: 			memcpy(pMsg.Mark, lpObj->lpGuild->Mark, 32);

  00596	6a 20		 push	 32			; 00000020H
  00598	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0059b	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  005a1	83 c1 0d	 add	 ecx, 13			; 0000000dH
  005a4	51		 push	 ecx
  005a5	8d 95 32 ec ff
	ff		 lea	 edx, DWORD PTR _pMsg$4[ebp+10]
  005ab	52		 push	 edx
  005ac	e8 00 00 00 00	 call	 _memcpy
  005b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23995: 			memcpy(GuildInfoBuf+GuildInfoOfs, &pMsg, sizeof(pMsg));

  005b4	6a 2a		 push	 42			; 0000002aH
  005b6	8d 85 28 ec ff
	ff		 lea	 eax, DWORD PTR _pMsg$4[ebp]
  005bc	50		 push	 eax
  005bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GuildInfoOfs@@3HA ; GuildInfoOfs
  005c3	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?GuildInfoBuf@@3PAEA ; GuildInfoBuf
  005c9	51		 push	 ecx
  005ca	e8 00 00 00 00	 call	 _memcpy
  005cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23996: 			GuildInfoOfs += sizeof(pMsg);

  005d2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildInfoOfs@@3HA ; GuildInfoOfs
  005d7	83 c0 2a	 add	 eax, 42			; 0000002aH
  005da	a3 00 00 00 00	 mov	 DWORD PTR ?GuildInfoOfs@@3HA, eax ; GuildInfoOfs

; 23997: 			GuildInfoCount++;

  005df	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildInfoCount@@3HA ; GuildInfoCount
  005e4	83 c0 01	 add	 eax, 1
  005e7	a3 00 00 00 00	 mov	 DWORD PTR ?GuildInfoCount@@3HA, eax ; GuildInfoCount

; 23998: 		
; 23999: 
; 24000: 	#ifdef GUILD_VIEWPORT_MODIFY
; 24001: 			pGVUMsg.NumberH = HIBYTE(lpObj->m_Index)&0x7f;
; 24002: 			pGVUMsg.NumberL = LOBYTE(lpObj->m_Index);
; 24003: 			if(!strcmp(lpObj->lpGuild->Names[0], lpObj->Name))
; 24004: 			{	//   
; 24005: 				pGVUMsg.NumberH |= 0x80;
; 24006: 			}
; 24007: 	#else
; 24008: 			pGVUMsg.NumberH = HIBYTE(lpObj->m_Index);

  005ec	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005ef	8b 08		 mov	 ecx, DWORD PTR [eax]
  005f1	c1 e9 08	 shr	 ecx, 8
  005f4	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  005fa	88 8d 54 ec ff
	ff		 mov	 BYTE PTR _pGVUMsg$5[ebp], cl

; 24009: 			pGVUMsg.NumberL = LOBYTE(lpObj->m_Index);

  00600	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00603	8b 08		 mov	 ecx, DWORD PTR [eax]
  00605	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0060b	88 8d 55 ec ff
	ff		 mov	 BYTE PTR _pGVUMsg$5[ebp+1], cl

; 24010: 	#endif
; 24011: 
; 24012: 			pGVUMsg.GNumberH = HIBYTE(lpObj->lpGuild->Number);

  00611	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00614	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  0061a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0061c	c1 ea 08	 shr	 edx, 8
  0061f	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00625	88 95 56 ec ff
	ff		 mov	 BYTE PTR _pGVUMsg$5[ebp+2], dl

; 24013: 			pGVUMsg.GNumberL = LOBYTE(lpObj->lpGuild->Number);						

  0062b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0062e	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00634	8b 11		 mov	 edx, DWORD PTR [ecx]
  00636	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0063c	88 95 57 ec ff
	ff		 mov	 BYTE PTR _pGVUMsg$5[ebp+3], dl

; 24014: 			memcpy(GuildUserBuf+GuildUserOfs, &pGVUMsg, sizeof(pGVUMsg));

  00642	6a 04		 push	 4
  00644	8d 85 54 ec ff
	ff		 lea	 eax, DWORD PTR _pGVUMsg$5[ebp]
  0064a	50		 push	 eax
  0064b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GuildUserOfs@@3HA ; GuildUserOfs
  00651	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?GuildUserBuf@@3PAEA ; GuildUserBuf
  00657	51		 push	 ecx
  00658	e8 00 00 00 00	 call	 _memcpy
  0065d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24015: 			GuildUserOfs += sizeof(pGVUMsg);

  00660	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildUserOfs@@3HA ; GuildUserOfs
  00665	83 c0 04	 add	 eax, 4
  00668	a3 00 00 00 00	 mov	 DWORD PTR ?GuildUserOfs@@3HA, eax ; GuildUserOfs

; 24016: 			GuildUserCount++;

  0066d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildUserCount@@3HA ; GuildUserCount
  00672	83 c0 01	 add	 eax, 1
  00675	a3 00 00 00 00	 mov	 DWORD PTR ?GuildUserCount@@3HA, eax ; GuildUserCount

; 24017: 
; 24018: 			//    ..
; 24019: 			if ( GuildInfoCount )

  0067a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GuildInfoCount@@3HA, 0 ; GuildInfoCount
  00681	74 52		 je	 SHORT $LN22@gObjViewpo

; 24020: 			{
; 24021: 				PMSG_GUILDVIEWPORT_COUNT pGVCount;
; 24022: 				pGVCount.h.c		= PMHC_WORD;

  00683	c6 85 20 ec ff
	ff c2		 mov	 BYTE PTR _pGVCount$3[ebp], 194 ; 000000c2H

; 24023: 				pGVCount.h.headcode = 0x5A;

  0068a	c6 85 23 ec ff
	ff 5a		 mov	 BYTE PTR _pGVCount$3[ebp+3], 90 ; 0000005aH

; 24024: 				pGVCount.h.sizeH	= HIBYTE( GuildInfoOfs );

  00691	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildInfoOfs@@3HA ; GuildInfoOfs
  00696	c1 e8 08	 shr	 eax, 8
  00699	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0069e	88 85 21 ec ff
	ff		 mov	 BYTE PTR _pGVCount$3[ebp+1], al

; 24025: 				pGVCount.h.sizeL	= LOBYTE( GuildInfoOfs );

  006a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildInfoOfs@@3HA ; GuildInfoOfs
  006a9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006ae	88 85 22 ec ff
	ff		 mov	 BYTE PTR _pGVCount$3[ebp+2], al

; 24026: 				pGVCount.Count		= GuildInfoCount;

  006b4	a0 00 00 00 00	 mov	 al, BYTE PTR ?GuildInfoCount@@3HA
  006b9	88 85 24 ec ff
	ff		 mov	 BYTE PTR _pGVCount$3[ebp+4], al

; 24027: 				memcpy(GuildInfoBuf, &pGVCount, sizeof(pGVCount));

  006bf	6a 05		 push	 5
  006c1	8d 85 20 ec ff
	ff		 lea	 eax, DWORD PTR _pGVCount$3[ebp]
  006c7	50		 push	 eax
  006c8	68 00 00 00 00	 push	 OFFSET ?GuildInfoBuf@@3PAEA ; GuildInfoBuf
  006cd	e8 00 00 00 00	 call	 _memcpy
  006d2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@gObjViewpo:

; 24028: 			}
; 24029: 			//   .
; 24030: 			if( GuildUserCount )

  006d5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GuildUserCount@@3HA, 0 ; GuildUserCount
  006dc	74 6b		 je	 SHORT $LN21@gObjViewpo

; 24031: 			{
; 24032: 				PMSG_GUILDVIEWPORT_USERCOUNT pGUCount;
; 24033: 				pGUCount.h.c		= PMHC_WORD;

  006de	c6 85 18 ec ff
	ff c2		 mov	 BYTE PTR _pGUCount$2[ebp], 194 ; 000000c2H

; 24034: 				pGUCount.h.headcode = 0x5B;

  006e5	c6 85 1b ec ff
	ff 5b		 mov	 BYTE PTR _pGUCount$2[ebp+3], 91 ; 0000005bH

; 24035: 				pGUCount.h.sizeH	= HIBYTE( GuildUserOfs );

  006ec	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildUserOfs@@3HA ; GuildUserOfs
  006f1	c1 e8 08	 shr	 eax, 8
  006f4	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006f9	88 85 19 ec ff
	ff		 mov	 BYTE PTR _pGUCount$2[ebp+1], al

; 24036: 				pGUCount.h.sizeL	= LOBYTE( GuildUserOfs );

  006ff	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildUserOfs@@3HA ; GuildUserOfs
  00704	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00709	88 85 1a ec ff
	ff		 mov	 BYTE PTR _pGUCount$2[ebp+2], al

; 24037: 				pGUCount.Count		= GuildUserCount;

  0070f	a0 00 00 00 00	 mov	 al, BYTE PTR ?GuildUserCount@@3HA
  00714	88 85 1c ec ff
	ff		 mov	 BYTE PTR _pGUCount$2[ebp+4], al

; 24038: 				memcpy(GuildUserBuf, &pGUCount, sizeof(pGUCount));

  0071a	6a 05		 push	 5
  0071c	8d 85 18 ec ff
	ff		 lea	 eax, DWORD PTR _pGUCount$2[ebp]
  00722	50		 push	 eax
  00723	68 00 00 00 00	 push	 OFFSET ?GuildUserBuf@@3PAEA ; GuildUserBuf
  00728	e8 00 00 00 00	 call	 _memcpy
  0072d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24039: 				DataSend(lpObj->m_Index, (LPBYTE)GuildUserBuf, GuildUserOfs);

  00730	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildUserOfs@@3HA ; GuildUserOfs
  00735	50		 push	 eax
  00736	68 00 00 00 00	 push	 OFFSET ?GuildUserBuf@@3PAEA ; GuildUserBuf
  0073b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0073e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00740	52		 push	 edx
  00741	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00746	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN21@gObjViewpo:

; 24040: 			}
; 24041: 		}
; 24042: #endif //MODIFY_GUILD_VIEWPORT_01_20040701
; 24043: 
; 24044: 
; 24045: // , ,     		
; 24046: #ifdef FOR_KOREA
; 24047: #ifdef UPDATE_GM_FUNCTION_20070228	// '/' '/'
; 24048: 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24049: 		if( lpObj->Authority != AUTHORITY_ADMIN
; 24050: 			&& ( ( ( lpObj->Authority & AUTHORITY_EVENT_GM ) != AUTHORITY_EVENT_GM )
; 24051: 			|| ( ( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_INVISABLE ) ) ) ) )
; 24052: 	#else
; 24053: 		if( lpObj->Authority != AUTHORITY_ADMIN
; 24054: 			&&  ( ( ( lpObj->Authority&AUTHORITY_EVENT_GM) != AUTHORITY_EVENT_GM) 
; 24055: 			|| ( (lpObj->m_ViewSkillState&STATE_CLOAKING) != STATE_CLOAKING ) ))
; 24056: 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24057: #else
; 24058: 		//if( lpObj->Authority != AUTHORITY_ADMIN )
; 24059: #endif	// UPDATE_GM_FUNCTION_20070228
; 24060: #endif
; 24061: #ifdef FOR_CHINA
; 24062: 		if( lpObj->Authority != AUTHORITY_ADMIN )
; 24063: #endif
; 24064: #ifdef FOR_GLOBAL
; 24065: 		if( lpObj->Authority != AUTHORITY_ADMIN )
; 24066: #endif
; 24067: #ifdef FOR_USA
; 24068: 		if( lpObj->Authority != AUTHORITY_ADMIN )
; 24069: #endif
; 24070: 
; 24071: #ifdef FOR_PHILIPPINE	// 
; 24072: 		if( lpObj->Authority != AUTHORITY_ADMIN )
; 24073: #endif
; 24074: 
; 24075: #ifdef FOR_VIETNAM		// 
; 24076: 		if( lpObj->Authority != AUTHORITY_ADMIN )
; 24077: #endif
; 24078: 
; 24079: #ifdef FOR_TAIWAN
; 24080: 		if( lpObj->Authority != AUTHORITY_ADMIN )
; 24081: #endif
; 24082: 		{		
; 24083: 			for( n=0; n<MVL; n++)

  00749	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00750	eb 09		 jmp	 SHORT $LN4@gObjViewpo
$LN2@gObjViewpo:
  00752	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00755	83 c0 01	 add	 eax, 1
  00758	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjViewpo:
  0075b	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0075e	3b 85 58 ec ff
	ff		 cmp	 eax, DWORD PTR _MVL$[ebp]
  00764	0f 8d a2 00 00
	00		 jge	 $LN3@gObjViewpo

; 24084: 			{
; 24085: 				if( lpObj->VpPlayer2[n].state ) 

  0076a	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  0076e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00771	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  00779	85 d2		 test	 edx, edx
  0077b	0f 84 86 00 00
	00		 je	 $LN24@gObjViewpo

; 24086: 				{
; 24087: 					tObjNum = lpObj->VpPlayer2[n].number;

  00781	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  00785	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00788	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  00790	89 55 f4	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 24088: 					if( tObjNum >= 0 )

  00793	83 7d f4 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  00797	7c 6e		 jl	 SHORT $LN24@gObjViewpo

; 24089: 					{
; 24090: 						if(lpObj->VpPlayer2[n].type == OBJTYPE_CHARACTER)

  00799	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  0079d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  007a0	0f b6 94 01 ec
	06 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1772]
  007a8	83 fa 01	 cmp	 edx, 1
  007ab	75 5a		 jne	 SHORT $LN24@gObjViewpo

; 24091: 						{
; 24092: 							DataSend(tObjNum, (LPBYTE)sendBuf, lOfs);

  007ad	8b 85 68 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  007b3	50		 push	 eax
  007b4	8d 8d 6c ec ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  007ba	51		 push	 ecx
  007bb	8b 55 f4	 mov	 edx, DWORD PTR _tObjNum$[ebp]
  007be	52		 push	 edx
  007bf	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  007c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24093: 							if( GuildInfoCount )

  007c7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GuildInfoCount@@3HA, 0 ; GuildInfoCount
  007ce	74 17		 je	 SHORT $LN27@gObjViewpo

; 24094: 							{
; 24095: 								DataSend(tObjNum, (LPBYTE)GuildInfoBuf, GuildInfoOfs);

  007d0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildInfoOfs@@3HA ; GuildInfoOfs
  007d5	50		 push	 eax
  007d6	68 00 00 00 00	 push	 OFFSET ?GuildInfoBuf@@3PAEA ; GuildInfoBuf
  007db	8b 4d f4	 mov	 ecx, DWORD PTR _tObjNum$[ebp]
  007de	51		 push	 ecx
  007df	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  007e4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN27@gObjViewpo:

; 24096: 							}
; 24097: 							if( GuildUserCount )

  007e7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GuildUserCount@@3HA, 0 ; GuildUserCount
  007ee	74 17		 je	 SHORT $LN24@gObjViewpo

; 24098: 							{
; 24099: 								DataSend(tObjNum, (LPBYTE)GuildUserBuf, GuildUserOfs);

  007f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildUserOfs@@3HA ; GuildUserOfs
  007f5	50		 push	 eax
  007f6	68 00 00 00 00	 push	 OFFSET ?GuildUserBuf@@3PAEA ; GuildUserBuf
  007fb	8b 4d f4	 mov	 ecx, DWORD PTR _tObjNum$[ebp]
  007fe	51		 push	 ecx
  007ff	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00804	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN24@gObjViewpo:

; 24100: 							}
; 24101: 						}
; 24102: 					}
; 24103: 				}
; 24104: 			}

  00807	e9 46 ff ff ff	 jmp	 $LN2@gObjViewpo
$LN3@gObjViewpo:

; 24105: 		}
; 24106: 	}

  0080c	e9 f5 01 00 00	 jmp	 $LN1@gObjViewpo
$LN6@gObjViewpo:

; 24107: 	else
; 24108: 	{	
; 24109: 		count = 0;

  00811	c7 85 64 ec ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$[ebp], 0

; 24110: 		if( lpObj->m_RecallMon >= 0 )

  0081b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0081e	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  00825	0f 8c 61 01 00
	00		 jl	 $LN29@gObjViewpo

; 24111: 		{
; 24112: 			pCallMonsterViewportCreate.NumberH = HIBYTE(lpObj->m_Index);

  0082b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0082e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00830	c1 e9 08	 shr	 ecx, 8
  00833	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00839	88 0d 00 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A, cl

; 24113: 			pCallMonsterViewportCreate.NumberL = LOBYTE(lpObj->m_Index);

  0083f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00842	8b 08		 mov	 ecx, DWORD PTR [eax]
  00844	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0084a	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+1, cl

; 24114: 			if( lpObj->m_State == OBJST_CREATE )

  00850	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00853	83 b8 b8 01 00
	00 01		 cmp	 DWORD PTR [eax+440], 1
  0085a	75 11		 jne	 SHORT $LN30@gObjViewpo

; 24115: 				pCallMonsterViewportCreate.NumberH |= (0x01<<7);	//   ..

  0085c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A
  00863	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  00868	a2 00 00 00 00	 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A, al
$LN30@gObjViewpo:

; 24116: 								
; 24117: #ifdef ENHANCE_MONSTER_TYPE_TO_WORD_20040618
; 24118: 			pCallMonsterViewportCreate.Type_HI    = HIBYTE(lpObj->Class);

  0086d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00870	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00877	c1 e9 08	 shr	 ecx, 8
  0087a	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00880	88 0d 02 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+2, cl

; 24119: 			pCallMonsterViewportCreate.Type_LO    = LOBYTE(lpObj->Class);

  00886	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00889	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00890	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00896	88 0d 03 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+3, cl

; 24120: #else
; 24121: 			pCallMonsterViewportCreate.Type		  = lpObj->Class;
; 24122: #endif
; 24123: #ifndef MODIFY_BUFF_SYSTEM_EXTENTION_20070917					 // !! NOT
; 24124: 			pCallMonsterViewportCreate.ViewState = lpObj->m_ViewSkillState;

  0089c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0089f	66 8b 88 c0 01
	00 00		 mov	 cx, WORD PTR [eax+448]
  008a6	66 89 0d 04 00
	00 00		 mov	 WORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+4, cx

; 24125: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24126: 			pCallMonsterViewportCreate.X       = (BYTE)lpObj->X;

  008ad	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008b0	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  008b6	88 0d 06 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+6, cl

; 24127: 			pCallMonsterViewportCreate.Y       = (BYTE)lpObj->Y;

  008bc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008bf	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  008c5	88 0d 07 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+7, cl

; 24128: 			pCallMonsterViewportCreate.TX      = (BYTE)lpObj->TX;

  008cb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008ce	8a 88 20 01 00
	00		 mov	 cl, BYTE PTR [eax+288]
  008d4	88 0d 08 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+8, cl

; 24129: 			pCallMonsterViewportCreate.TY      = (BYTE)lpObj->TY;

  008da	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008dd	8a 88 22 01 00
	00		 mov	 cl, BYTE PTR [eax+290]
  008e3	88 0d 09 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+9, cl

; 24130: 			pCallMonsterViewportCreate.Path    = lpObj->Dir<<4;

  008e9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008ec	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  008f3	c1 e1 04	 shl	 ecx, 4
  008f6	88 0d 0a 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+10, cl

; 24131: 
; 24132: 			if( lpObj->m_RecallMon >= 0 && lpObj->m_RecallMon < MAX_OBJECT-1 )

  008fc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008ff	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  00906	7c 38		 jl	 SHORT $LN31@gObjViewpo
  00908	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0090b	81 b8 a4 02 00
	00 e7 1c 00 00	 cmp	 DWORD PTR [eax+676], 7399 ; 00001ce7H
  00915	7d 29		 jge	 SHORT $LN31@gObjViewpo

; 24133: 			{
; 24134: 				memcpy(pCallMonsterViewportCreate.Id, gObj[lpObj->m_RecallMon].Name, MAX_IDSTRING);

  00917	6a 0a		 push	 10			; 0000000aH
  00919	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0091c	69 88 a4 02 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR [eax+676], 7072
  00926	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0092c	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00930	50		 push	 eax
  00931	68 0b 00 00 00	 push	 OFFSET ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+11
  00936	e8 00 00 00 00	 call	 _memcpy
  0093b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24135: 			}

  0093e	eb 11		 jmp	 SHORT $LN32@gObjViewpo
$LN31@gObjViewpo:

; 24136: 			else memset(pCallMonsterViewportCreate.Id, 0, MAX_IDSTRING);								

  00940	6a 0a		 push	 10			; 0000000aH
  00942	6a 00		 push	 0
  00944	68 0b 00 00 00	 push	 OFFSET ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+11
  00949	e8 00 00 00 00	 call	 _memset
  0094e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN32@gObjViewpo:

; 24137: 									
; 24138: #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24139: 			iViewportSize = gObjMakeViewportState( lpObj, pCallMonsterViewportCreate.BuffEffectList );
; 24140: 			pCallMonsterViewportCreate.BuffEffectCount = iViewportSize;
; 24141: 			memcpy((sendBuf+lOfs), (char*)&pCallMonsterViewportCreate, sizeof(PMSG_CALLMONSTER_VIEWPORTCREATE) );
; 24142: 			lOfs += ( sizeof(PMSG_CALLMONSTER_VIEWPORTCREATE) - ( MAX_BUFF_SLOT_INDEX - iViewportSize ) );
; 24143: #else
; 24144: 			memcpy((sendBuf+lOfs), (char*)&pCallMonsterViewportCreate, sizeof(PMSG_CALLMONSTER_VIEWPORTCREATE));

  00951	6a 16		 push	 22			; 00000016H
  00953	68 00 00 00 00	 push	 OFFSET ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A ; pCallMonsterViewportCreate
  00958	8b 85 68 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  0095e	8d 8c 05 6c ec
	ff ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp+eax]
  00965	51		 push	 ecx
  00966	e8 00 00 00 00	 call	 _memcpy
  0096b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24145: 			lOfs += sizeof(PMSG_CALLMONSTER_VIEWPORTCREATE);

  0096e	8b 85 68 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00974	83 c0 16	 add	 eax, 22			; 00000016H
  00977	89 85 68 ec ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 24146: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24147: 			count++;

  0097d	8b 85 64 ec ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  00983	83 c0 01	 add	 eax, 1
  00986	89 85 64 ec ff
	ff		 mov	 DWORD PTR _count$[ebp], eax
$LN29@gObjViewpo:

; 24148: 		}
; 24149: #ifdef MODIFY_NEW_MONSTER_SKILL_01_20060724		
; 24150: 		else
; 24151: 		{
; 24152: 			pMonsterViewportCreate.NumberH = HIBYTE(lpObj->m_Index);
; 24153: 			pMonsterViewportCreate.NumberL = LOBYTE(lpObj->m_Index);
; 24154: 			if( lpObj->m_State == OBJST_CREATE )
; 24155: 			{
; 24156: 				if ( !lpObj->Teleport )
; 24157: 				{
; 24158: 					pMonsterViewportCreate.NumberH |= (0x01<<7);	//   ..
; 24159: 
; 24160: 					//   . NumberH  2bit 1.  1bit  . 
; 24161: 					//  2bit . 2bit | 4bit : 0 ~ 16383  .
; 24162: 					pMonsterViewportCreate.NumberH |= (0x01<<6);
; 24163: 				}
; 24164: 
; 24165: 			}
; 24166: #ifdef ENHANCE_MONSTER_TYPE_TO_WORD_20040618
; 24167: 			pMonsterViewportCreate.Type_HI    = HIBYTE(lpObj->Class);
; 24168: 			pMonsterViewportCreate.Type_LO    = LOBYTE(lpObj->Class);
; 24169: #else
; 24170: 			pMonsterViewportCreate.Type		  = lpObj->Class;
; 24171: #endif						
; 24172: 
; 24173: 
; 24174: 			//pMonsterViewportCreate.ViewState = lpTargetObj->m_ViewState;
; 24175: #ifndef MODIFY_BUFF_SYSTEM_EXTENTION_20070917					 // !! NOT
; 24176: 			pMonsterViewportCreate.ViewState = lpObj->m_ViewSkillState;
; 24177: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24178: 			pMonsterViewportCreate.X       = (BYTE)lpObj->X;
; 24179: 			pMonsterViewportCreate.Y       = (BYTE)lpObj->Y;
; 24180: 			pMonsterViewportCreate.TX      = (BYTE)lpObj->TX;
; 24181: 			pMonsterViewportCreate.TY      = (BYTE)lpObj->TY;
; 24182: 			pMonsterViewportCreate.Path    = lpObj->Dir<<4;
; 24183: 
; 24184: #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24185: 			iViewportSize = gObjMakeViewportState( lpObj, pMonsterViewportCreate.BuffEffectList );
; 24186: 			pMonsterViewportCreate.BuffEffectCount = iViewportSize;
; 24187: 			memcpy((sendBuf+lOfs), (char*)&pMonsterViewportCreate, sizeof(PMSG_MONSTER_VIEWPORTCREATE) );
; 24188: 			lOfs += ( sizeof(PMSG_MONSTER_VIEWPORTCREATE) - ( MAX_BUFF_SLOT_INDEX - iViewportSize ) );
; 24189: #else 
; 24190: 			memcpy((sendBuf+lOfs), (char*)&pMonsterViewportCreate, sizeof(PMSG_MONSTER_VIEWPORTCREATE));
; 24191: 			lOfs += sizeof(PMSG_MONSTER_VIEWPORTCREATE);
; 24192: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24193: 			moncount++;
; 24194: 		}
; 24195: #endif // MODIFY_NEW_MONSTER_SKILL_01_20060724
; 24196: 		if( count > 0 )

  0098c	83 bd 64 ec ff
	ff 00		 cmp	 DWORD PTR _count$[ebp], 0
  00993	7e 71		 jle	 SHORT $LN1@gObjViewpo

; 24197: 		{
; 24198: 			PWMSG_COUNT			pwCount;
; 24199: 			pwCount.h.c         = PMHC_WORD;

  00995	c6 85 10 ec ff
	ff c2		 mov	 BYTE PTR _pwCount$1[ebp], 194 ; 000000c2H

; 24200: 			pwCount.h.headcode  = 0x1F;

  0099c	c6 85 13 ec ff
	ff 1f		 mov	 BYTE PTR _pwCount$1[ebp+3], 31 ; 0000001fH

; 24201: 			pwCount.h.sizeH     = HIBYTE(lOfs);

  009a3	8b 85 68 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  009a9	c1 e8 08	 shr	 eax, 8
  009ac	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009b1	88 85 11 ec ff
	ff		 mov	 BYTE PTR _pwCount$1[ebp+1], al

; 24202: 			pwCount.h.sizeL     = LOBYTE(lOfs);

  009b7	8b 85 68 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  009bd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  009c2	88 85 12 ec ff
	ff		 mov	 BYTE PTR _pwCount$1[ebp+2], al

; 24203: 			pwCount.count       = count;

  009c8	8a 85 64 ec ff
	ff		 mov	 al, BYTE PTR _count$[ebp]
  009ce	88 85 14 ec ff
	ff		 mov	 BYTE PTR _pwCount$1[ebp+4], al

; 24204: 			memcpy(sendBuf, (char*)&pwCount, sizeof(PWMSG_COUNT));

  009d4	6a 05		 push	 5
  009d6	8d 85 10 ec ff
	ff		 lea	 eax, DWORD PTR _pwCount$1[ebp]
  009dc	50		 push	 eax
  009dd	8d 8d 6c ec ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  009e3	51		 push	 ecx
  009e4	e8 00 00 00 00	 call	 _memcpy
  009e9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24205: 			MsgSendV2(lpObj, sendBuf, lOfs);

  009ec	8b 85 68 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  009f2	50		 push	 eax
  009f3	8d 8d 6c ec ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  009f9	51		 push	 ecx
  009fa	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  009fd	52		 push	 edx
  009fe	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00a03	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjViewpo:

; 24206: 		}
; 24207: #ifdef MODIFY_NEW_MONSTER_SKILL_01_20060724
; 24208: 		//  
; 24209: 		if( moncount > 0 )
; 24210: 		{
; 24211: 			PWMSG_COUNT			pwCount;
; 24212: 			pwCount.h.c         = PMHC_WORD;
; 24213: 			pwCount.h.headcode  = PMHC_VIEWPORTMONSTERCREATE;
; 24214: 			pwCount.h.sizeH     = HIBYTE(lOfs);
; 24215: 			pwCount.h.sizeL     = LOBYTE(lOfs);
; 24216: 			pwCount.count       = moncount;
; 24217: 			memcpy(sendBuf, (char*)&pwCount, sizeof(PWMSG_COUNT));
; 24218: 			MsgSendV2(lpObj, sendBuf, lOfs);
; 24219: 		}
; 24220: 
; 24221: #endif // MODIFY_NEW_MONSTER_SKILL_01_20060724
; 24222: 	}
; 24223: }

  00a06	5f		 pop	 edi
  00a07	5e		 pop	 esi
  00a08	5b		 pop	 ebx
  00a09	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a0c	33 cd		 xor	 ecx, ebp
  00a0e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a13	8b e5		 mov	 esp, ebp
  00a15	5d		 pop	 ebp
  00a16	c3		 ret	 0
?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ENDP ; gObjViewportListProtocolCreate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjViewportListProtocolDestroy@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pCount$ = -5016					; size = 4
_count$ = -5012						; size = 4
_lOfs$ = -5008						; size = 4
_sendBuf$ = -5004					; size = 5000
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjViewportListProtocolDestroy@@YAXPAVOBJECTSTRUCT@@@Z PROC ; gObjViewportListProtocolDestroy, COMDAT

; 23667: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 98 15 00 00	 mov	 eax, 5528		; 00001598H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi

; 23668: 	//if( lpObj->Type != OBJTYPE_CHARACTER ) return;
; 23669: 	BYTE			sendBuf[5000];
; 23670: 	int				lOfs;
; 23671: 	int				count      = 0;

  0001a	c7 85 6c ec ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$[ebp], 0

; 23672: 	PBMSG_COUNT		pCount;
; 23673: 	
; 23674: 	lOfs			= sizeof( PBMSG_COUNT );

  00024	c7 85 70 ec ff
	ff 04 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 4

; 23675: 
; 23676: 	pViewportDestroy.NumberH = HIBYTE(lpObj->m_Index);

  0002e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	c1 e9 08	 shr	 ecx, 8
  00036	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0003c	88 0d 00 00 00
	00		 mov	 BYTE PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A, cl

; 23677: 	pViewportDestroy.NumberL = LOBYTE(lpObj->m_Index);

  00042	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00045	8b 08		 mov	 ecx, DWORD PTR [eax]
  00047	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0004d	88 0d 01 00 00
	00		 mov	 BYTE PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A+1, cl

; 23678: 	memcpy((sendBuf+lOfs), (char*)&pViewportDestroy, sizeof(PMSG_VIEWPORTDESTROY));

  00053	6a 02		 push	 2
  00055	68 00 00 00 00	 push	 OFFSET ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A ; pViewportDestroy
  0005a	8b 85 70 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00060	8d 8c 05 74 ec
	ff ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp+eax]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 _memcpy
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23679: 	lOfs += sizeof(PMSG_VIEWPORTDESTROY);

  00070	8b 85 70 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00076	83 c0 02	 add	 eax, 2
  00079	89 85 70 ec ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 23680: 	count++;

  0007f	8b 85 6c ec ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  00085	83 c0 01	 add	 eax, 1
  00088	89 85 6c ec ff
	ff		 mov	 DWORD PTR _count$[ebp], eax

; 23681: 
; 23682: 	pCount.h.c        = PMHC_BYTE;

  0008e	c6 85 68 ec ff
	ff c1		 mov	 BYTE PTR _pCount$[ebp], 193 ; 000000c1H

; 23683: 	pCount.h.headcode = PMHC_VIEWPORTDESTROY;

  00095	c6 85 6a ec ff
	ff 14		 mov	 BYTE PTR _pCount$[ebp+2], 20 ; 00000014H

; 23684: 	pCount.h.size     = lOfs;

  0009c	8a 85 70 ec ff
	ff		 mov	 al, BYTE PTR _lOfs$[ebp]
  000a2	88 85 69 ec ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], al

; 23685: 	pCount.count      = count;

  000a8	8a 85 6c ec ff
	ff		 mov	 al, BYTE PTR _count$[ebp]
  000ae	88 85 6b ec ff
	ff		 mov	 BYTE PTR _pCount$[ebp+3], al

; 23686: 	memcpy(sendBuf, (char*)&pCount, sizeof(PBMSG_COUNT));

  000b4	6a 04		 push	 4
  000b6	8d 85 68 ec ff
	ff		 lea	 eax, DWORD PTR _pCount$[ebp]
  000bc	50		 push	 eax
  000bd	8d 8d 74 ec ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 _memcpy
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23687: 	
; 23688: 	if( count < 1 )

  000cc	83 bd 6c ec ff
	ff 01		 cmp	 DWORD PTR _count$[ebp], 1
  000d3	7d 02		 jge	 SHORT $LN2@gObjViewpo

; 23689: 	{
; 23690: 		return;

  000d5	eb 1a		 jmp	 SHORT $LN1@gObjViewpo
$LN2@gObjViewpo:

; 23691: 	}
; 23692: 	MsgSendV2(lpObj, sendBuf, lOfs);

  000d7	8b 85 70 ec ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  000dd	50		 push	 eax
  000de	8d 8d 74 ec ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  000e4	51		 push	 ecx
  000e5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e8	52		 push	 edx
  000e9	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  000ee	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjViewpo:

; 23693: 
; 23694: 	//LogAdd(" ");
; 23695: }

  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f7	33 cd		 xor	 ecx, ebp
  000f9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c3		 ret	 0
?gObjViewportListProtocolDestroy@@YAXPAVOBJECTSTRUCT@@@Z ENDP ; gObjViewportListProtocolDestroy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z PROC		; gObjClearViewport, COMDAT

; 1262 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1263 : 	int i;
; 1264 : 	for( i=0; i<MAXVIEWPORTOBJECT; i++) 

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@gObjClearV
$LN2@gObjClearV:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@gObjClearV:
  0001b	83 7d fc 4b	 cmp	 DWORD PTR _i$[ebp], 75	; 0000004bH
  0001f	7d 44		 jge	 SHORT $LN3@gObjClearV

; 1265 : 	{
; 1266 : 		lpObj->VpPlayer[i].state   = STVP_NONE;

  00021	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00028	c6 84 01 64 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+868], 0

; 1267 : 		lpObj->VpPlayer[i].number  = -1;

  00030	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00034	83 c9 ff	 or	 ecx, -1
  00037	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0003a	66 89 8c 02 66
	03 00 00	 mov	 WORD PTR [edx+eax+870], cx

; 1268 : 		lpObj->VpPlayer2[i].state  = STVP_NONE;

  00042	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00046	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00049	c6 84 01 e8 06
	00 00 00	 mov	 BYTE PTR [ecx+eax+1768], 0

; 1269 : 		lpObj->VpPlayer2[i].number = -1;

  00051	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$[ebp], 12
  00055	83 c9 ff	 or	 ecx, -1
  00058	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0005b	66 89 8c 02 ea
	06 00 00	 mov	 WORD PTR [edx+eax+1770], cx

; 1270 : 	}

  00063	eb ad		 jmp	 SHORT $LN2@gObjClearV
$LN3@gObjClearV:

; 1271 : 	lpObj->VPCount = 0;

  00065	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00068	c7 80 6c 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2668], 0

; 1272 : 	lpObj->VPCount2 = 0;

  00072	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00075	c7 80 70 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2672], 0

; 1273 : }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; gObjClearViewport
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjClearViewportOfMine@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjClearViewportOfMine@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjClearViewportOfMine, COMDAT

; 1250 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1251 : 	for( int i = 0; i < MAXVIEWPORTOBJECT; i++) 

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@gObjClearV
$LN2@gObjClearV:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@gObjClearV:
  0001b	83 7d fc 4b	 cmp	 DWORD PTR _i$1[ebp], 75	; 0000004bH
  0001f	7d 23		 jge	 SHORT $LN3@gObjClearV

; 1252 : 	{
; 1253 : 		lpObj->VpPlayer[i].state   = STVP_NONE;

  00021	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$1[ebp], 12
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00028	c6 84 01 64 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+868], 0

; 1254 : 		lpObj->VpPlayer[i].number  = -1;

  00030	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$1[ebp], 12
  00034	83 c9 ff	 or	 ecx, -1
  00037	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0003a	66 89 8c 02 66
	03 00 00	 mov	 WORD PTR [edx+eax+870], cx

; 1255 : 	}

  00042	eb ce		 jmp	 SHORT $LN2@gObjClearV
$LN3@gObjClearV:

; 1256 : 
; 1257 : 	lpObj->VPCount = 0;

  00044	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00047	c7 80 6c 0a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+2668], 0

; 1258 : }	

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?gObjClearViewportOfMine@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjClearViewportOfMine
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?IsOnDuel@@YA_NHH@Z
_TEXT	SEGMENT
tv71 = -72						; size = 4
tv66 = -72						; size = 4
tv72 = -68						; size = 4
tv67 = -68						; size = 4
_aIndex1$ = 8						; size = 4
_aIndex2$ = 12						; size = 4
?IsOnDuel@@YA_NHH@Z PROC				; IsOnDuel, COMDAT

; 2292 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2293 : 	if (!CHECK_LIMIT(aIndex1, MAX_OBJECT) || !CHECK_LIMIT(aIndex2, MAX_OBJECT))

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex1$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN10@IsOnDuel
  0000f	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN11@IsOnDuel
$LN10@IsOnDuel:
  00018	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex1$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN8@IsOnDuel
  00021	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN9@IsOnDuel
$LN8@IsOnDuel:
  0002a	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN9@IsOnDuel:
  00031	8b 45 b8	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 bc	 mov	 DWORD PTR tv67[ebp], eax
$LN11@IsOnDuel:
  00037	83 7d bc 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	74 34		 je	 SHORT $LN3@IsOnDuel
  0003d	83 7d 0c 00	 cmp	 DWORD PTR _aIndex2$[ebp], 0
  00041	7d 09		 jge	 SHORT $LN14@IsOnDuel
  00043	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  0004a	eb 1f		 jmp	 SHORT $LN15@IsOnDuel
$LN14@IsOnDuel:
  0004c	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex2$[ebp], 7399 ; 00001ce7H
  00053	7e 09		 jle	 SHORT $LN12@IsOnDuel
  00055	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
  0005c	eb 07		 jmp	 SHORT $LN13@IsOnDuel
$LN12@IsOnDuel:
  0005e	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
$LN13@IsOnDuel:
  00065	8b 45 b8	 mov	 eax, DWORD PTR tv71[ebp]
  00068	89 45 bc	 mov	 DWORD PTR tv72[ebp], eax
$LN15@IsOnDuel:
  0006b	83 7d bc 00	 cmp	 DWORD PTR tv72[ebp], 0
  0006f	75 04		 jne	 SHORT $LN2@IsOnDuel
$LN3@IsOnDuel:

; 2294 : 		return false;

  00071	32 c0		 xor	 al, al
  00073	eb 6a		 jmp	 SHORT $LN1@IsOnDuel
$LN2@IsOnDuel:

; 2295 : 
; 2296 : 	if (gObj[aIndex1].Type != OBJTYPE_CHARACTER ||

  00075	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex1$[ebp], 7072
  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00082	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00087	83 fa 01	 cmp	 edx, 1
  0008a	75 17		 jne	 SHORT $LN5@IsOnDuel
  0008c	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex2$[ebp], 7072
  00093	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00099	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0009e	83 fa 01	 cmp	 edx, 1
  000a1	74 04		 je	 SHORT $LN4@IsOnDuel
$LN5@IsOnDuel:

; 2297 : 		gObj[aIndex2].Type != OBJTYPE_CHARACTER
; 2298 : 		)
; 2299 : 		return false;

  000a3	32 c0		 xor	 al, al
  000a5	eb 38		 jmp	 SHORT $LN1@IsOnDuel
$LN4@IsOnDuel:

; 2300 : 
; 2301 : 	if (gObj[aIndex1].m_iDuelUser == aIndex2 &&

  000a7	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex1$[ebp], 7072
  000ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b4	8b 94 01 ec 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3308]
  000bb	3b 55 0c	 cmp	 edx, DWORD PTR _aIndex2$[ebp]
  000be	75 1d		 jne	 SHORT $LN6@IsOnDuel
  000c0	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex2$[ebp], 7072
  000c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cd	8b 94 01 ec 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3308]
  000d4	3b 55 08	 cmp	 edx, DWORD PTR _aIndex1$[ebp]
  000d7	75 04		 jne	 SHORT $LN6@IsOnDuel

; 2302 : 		gObj[aIndex2].m_iDuelUser == aIndex1
; 2303 : 		)
; 2304 : 		return true;

  000d9	b0 01		 mov	 al, 1
  000db	eb 02		 jmp	 SHORT $LN1@IsOnDuel
$LN6@IsOnDuel:

; 2305 : 
; 2306 : 	return false;

  000dd	32 c0		 xor	 al, al
$LN1@IsOnDuel:

; 2307 : }

  000df	5f		 pop	 edi
  000e0	5e		 pop	 esi
  000e1	5b		 pop	 ebx
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
?IsOnDuel@@YA_NHH@Z ENDP				; IsOnDuel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?IsDuelEnable@@YA_NH@Z
_TEXT	SEGMENT
tv66 = -72						; size = 4
tv67 = -68						; size = 4
_aIndex$ = 8						; size = 4
?IsDuelEnable@@YA_NH@Z PROC				; IsDuelEnable, COMDAT

; 2277 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2278 : 	if (!CHECK_LIMIT(aIndex, MAX_OBJECT))

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN8@IsDuelEnab
  0000f	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN9@IsDuelEnab
$LN8@IsDuelEnab:
  00018	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN6@IsDuelEnab
  00021	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN7@IsDuelEnab
$LN6@IsDuelEnab:
  0002a	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN7@IsDuelEnab:
  00031	8b 45 b8	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 bc	 mov	 DWORD PTR tv67[ebp], eax
$LN9@IsDuelEnab:
  00037	83 7d bc 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 04		 jne	 SHORT $LN2@IsDuelEnab

; 2279 : 		return false;

  0003d	32 c0		 xor	 al, al
  0003f	eb 30		 jmp	 SHORT $LN1@IsDuelEnab
$LN2@IsDuelEnab:

; 2280 : 
; 2281 : 	if( gObjIsConnected(aIndex) == TRUE ) 

  00041	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0004a	83 c4 04	 add	 esp, 4
  0004d	83 f8 01	 cmp	 eax, 1
  00050	75 1d		 jne	 SHORT $LN3@IsDuelEnab

; 2282 : 	{
; 2283 : 		if( (gObj[aIndex].m_Option&OPTION_DUEL) == OPTION_DUEL ) {

  00052	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00059	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005f	8b 94 01 c0 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3264]
  00066	83 e2 02	 and	 edx, 2
  00069	74 04		 je	 SHORT $LN3@IsDuelEnab

; 2284 : 			return true;

  0006b	b0 01		 mov	 al, 1
  0006d	eb 02		 jmp	 SHORT $LN1@IsDuelEnab
$LN3@IsDuelEnab:

; 2285 : 		}
; 2286 : 	}
; 2287 : 
; 2288 : 	return false;

  0006f	32 c0		 xor	 al, al
$LN1@IsDuelEnab:

; 2289 : }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?IsDuelEnable@@YA_NH@Z ENDP				; IsDuelEnable
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSetDuelOption@@YAXHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_option$ = 12						; size = 4
?gObjSetDuelOption@@YAXHH@Z PROC			; gObjSetDuelOption, COMDAT

; 2261 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2262 : 	if( gObjIsConnected(aIndex) == TRUE ) 

  00009	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00012	83 c4 04	 add	 esp, 4
  00015	83 f8 01	 cmp	 eax, 1
  00018	75 5e		 jne	 SHORT $LN1@gObjSetDue

; 2263 : 	{
; 2264 : 		if( option == 0 ) 

  0001a	83 7d 0c 00	 cmp	 DWORD PTR _option$[ebp], 0
  0001e	75 2d		 jne	 SHORT $LN3@gObjSetDue

; 2265 : 		{
; 2266 : 			gObj[aIndex].m_Option &= !OPTION_DUEL;

  00020	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002d	8b 94 01 c0 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3264]
  00034	83 e2 00	 and	 edx, 0
  00037	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00044	89 94 01 c0 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3264], edx

; 2267 : //			GCServerMsgStringSend(lMsg.Get(1121), aIndex, 1);
; 2268 : 		}

  0004b	eb 2b		 jmp	 SHORT $LN1@gObjSetDue
$LN3@gObjSetDue:

; 2269 : 		else {
; 2270 : 			gObj[aIndex].m_Option |= OPTION_DUEL;

  0004d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005a	8b 94 01 c0 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3264]
  00061	83 ca 02	 or	 edx, 2
  00064	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0006b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00071	89 94 01 c0 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3264], edx
$LN1@gObjSetDue:

; 2271 : //			GCServerMsgStringSend(lMsg.Get(1120), aIndex, 1);
; 2272 : 		}		
; 2273 : 	}
; 2274 : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?gObjSetDuelOption@@YAXHH@Z ENDP			; gObjSetDuelOption
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSetTradeOption@@YAXHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_option$ = 12						; size = 4
?gObjSetTradeOption@@YAXHH@Z PROC			; gObjSetTradeOption, COMDAT

; 2242 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2243 : 	if( gObjIsConnected(aIndex) == TRUE ) 

  00009	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00012	83 c4 04	 add	 esp, 4
  00015	83 f8 01	 cmp	 eax, 1
  00018	0f 85 9c 00 00
	00		 jne	 $LN1@gObjSetTra

; 2244 : 	{
; 2245 : 		if( option == 0 ) 

  0001e	83 7d 0c 00	 cmp	 DWORD PTR _option$[ebp], 0
  00022	75 4c		 jne	 SHORT $LN3@gObjSetTra

; 2246 : 		{
; 2247 : 			gObj[aIndex].m_Option &= !OPTION_TRADE;

  00024	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00031	8b 94 01 c0 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3264]
  00038	83 e2 00	 and	 edx, 0
  0003b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00048	89 94 01 c0 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3264], edx

; 2248 : 			GCServerMsgStringSend(lMsg.Get(1121), aIndex, 1);

  0004f	6a 01		 push	 1
  00051	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00054	50		 push	 eax
  00055	68 61 04 00 00	 push	 1121			; 00000461H
  0005a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2249 : 		}

  0006e	eb 4a		 jmp	 SHORT $LN1@gObjSetTra
$LN3@gObjSetTra:

; 2250 : 		else {
; 2251 : 			gObj[aIndex].m_Option |= OPTION_TRADE;

  00070	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007d	8b 94 01 c0 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3264]
  00084	83 ca 01	 or	 edx, 1
  00087	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0008e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00094	89 94 01 c0 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3264], edx

; 2252 : 			GCServerMsgStringSend(lMsg.Get(1120), aIndex, 1);

  0009b	6a 01		 push	 1
  0009d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000a0	50		 push	 eax
  000a1	68 60 04 00 00	 push	 1120			; 00000460H
  000a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjSetTra:

; 2253 : 		}		
; 2254 : 	}
; 2255 : }

  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c3		 ret	 0
?gObjSetTradeOption@@YAXHH@Z ENDP			; gObjSetTradeOption
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjBackSpring2@@YAHPAVOBJECTSTRUCT@@0H@Z
_TEXT	SEGMENT
tv73 = -96						; size = 4
tv74 = -92						; size = 4
_pMove$ = -24						; size = 5
_n$1 = -16						; size = 4
_y$ = -12						; size = 4
_x$ = -8						; size = 4
_tdir$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_count$ = 16						; size = 4
?gObjBackSpring2@@YAHPAVOBJECTSTRUCT@@0H@Z PROC		; gObjBackSpring2, COMDAT

; 7628 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7629 : 	int tdir;
; 7630 : 
; 7631 : 	if( !CHECK_LIMIT(lpObj->MapNumber, g_TerrainManager.Size())  )

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00013	85 c9		 test	 ecx, ecx
  00015	7d 09		 jge	 SHORT $LN15@gObjBackSp
  00017	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  0001e	eb 31		 jmp	 SHORT $LN16@gObjBackSp
$LN15@gObjBackSp:
  00020	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00023	0f b6 b2 09 01
	00 00		 movzx	 esi, BYTE PTR [edx+265]
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  0002f	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size
  00034	83 e8 01	 sub	 eax, 1
  00037	3b f0		 cmp	 esi, eax
  00039	7e 09		 jle	 SHORT $LN13@gObjBackSp
  0003b	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00042	eb 07		 jmp	 SHORT $LN14@gObjBackSp
$LN13@gObjBackSp:
  00044	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
$LN14@gObjBackSp:
  0004b	8b 45 a0	 mov	 eax, DWORD PTR tv73[ebp]
  0004e	89 45 a4	 mov	 DWORD PTR tv74[ebp], eax
$LN16@gObjBackSp:
  00051	83 7d a4 00	 cmp	 DWORD PTR tv74[ebp], 0
  00055	75 23		 jne	 SHORT $LN5@gObjBackSp

; 7632 : 	{
; 7633 : 		LogAdd("error : %s %d",__FILE__, __LINE__);

  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjBackSpring2@@YAHPAVOBJECTSTRUCT@@0H@Z@4JA
  0005c	83 c0 05	 add	 eax, 5
  0005f	50		 push	 eax
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7634 : 		return FALSE;

  00073	33 c0		 xor	 eax, eax
  00075	e9 d7 01 00 00	 jmp	 $LN1@gObjBackSp
$LN5@gObjBackSp:

; 7635 : 	}
; 7636 : #ifdef CRYWOLF_NPC_WORK_20050912
; 7637 : 	if( lpObj->Type == OBJTYPE_CHARACTER )
; 7638 : 	{
; 7639 : 		if( (lpObj->Authority&AUTHORITY_ADMIN) == AUTHORITY_ADMIN )
; 7640 : 		{
; 7641 : 			return FALSE;
; 7642 : 		}
; 7643 : 	}
; 7644 : #endif
; 7645 : 
; 7646 : #ifdef ADD_NEW_MERCENARY_FOR_CASTLE_01_20041214
; 7647 : 	if(lpObj->Class == NPC_INDEX_SPEARMAN || lpObj->Class == NPC_INDEX_BOWMAN )
; 7648 : 		return FALSE;
; 7649 : #endif
; 7650 : 
; 7651 : #ifdef CASTLE_NPC_LIFESTONE_WORK_20041208
; 7652 : 	if(lpObj->Class == NPC_INDEX_LIFESTONE )
; 7653 : 		return FALSE;
; 7654 : #endif
; 7655 : 
; 7656 : #ifdef FOR_BLOODCASTLE
; 7657 : 	if(lpObj->Class >= 131 && lpObj->Class <= 134 )		// ,   

  0007a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007d	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00084	81 f9 83 00 00
	00		 cmp	 ecx, 131		; 00000083H
  0008a	7c 19		 jl	 SHORT $LN6@gObjBackSp
  0008c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008f	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00096	81 f9 86 00 00
	00		 cmp	 ecx, 134		; 00000086H
  0009c	7f 07		 jg	 SHORT $LN6@gObjBackSp

; 7658 : 		return FALSE;

  0009e	33 c0		 xor	 eax, eax
  000a0	e9 ac 01 00 00	 jmp	 $LN1@gObjBackSp
$LN6@gObjBackSp:

; 7659 : #endif
; 7660 : 	
; 7661 : #ifdef CASTLE_MAIN_SCHEDULER_20041111					//  NPC - ,    
; 7662 : 	if ((lpObj->Class == 277)||			// 
; 7663 : 		(lpObj->Class == 283)||			// 
; 7664 : 		(lpObj->Class == 288)||			// 
; 7665 : 		(lpObj->Class == 278)||			// 
; 7666 : 		(lpObj->Class == 215)||			// 
; 7667 : 		(lpObj->Class == 216)||			// 
; 7668 : 		(lpObj->Class == 217)||			// 
; 7669 : 		(lpObj->Class == 218)||			// 
; 7670 : 		(lpObj->Class == 219)			// 
; 7671 : 		)
; 7672 : 	{
; 7673 : 		return FALSE;
; 7674 : 	}
; 7675 : 
; 7676 : #ifdef MODIFY_CASTLESIEGE_GUILDMASTER_BACKSPRING_20051018
; 7677 : 	//        .
; 7678 : 	if( g_CastleSiege.GetCrownUserIndex() == lpObj->m_Index )
; 7679 : 	{
; 7680 : 		if( lpObj->pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,4) )
; 7681 : 		{
; 7682 : 			return FALSE;
; 7683 : 		}
; 7684 : 
; 7685 : 	}
; 7686 : #endif // MODIFY_CASTLESIEGE_GUILDMASTER_BACKSPRING_20051018
; 7687 : 
; 7688 : #endif // CASTLE_MAIN_SCHEDULER_20041111
; 7689 : 
; 7690 : 
; 7691 : #ifdef CRYWOLF_NPC_WORK_20050912
; 7692 : 	//      .
; 7693 : 	if( g_Crywolf.GetCrywolfState() == CRYWOLF_STATE_START
; 7694 : 		|| g_Crywolf.GetCrywolfState() == CRYWOLF_STATE_READY )
; 7695 : 	{
; 7696 : 		if( lpObj->Type == OBJTYPE_CHARACTER )
; 7697 : 		{		
; 7698 : 			for( int i=CRYWOLF_NPC_ALTAR1; i<=CRYWOLF_NPC_ALTAR5; i++ )
; 7699 : 			{
; 7700 : 				int iUserIndex = g_CrywolfNPC_Altar.GetAltarUserIndex(i);
; 7701 : 				if( iUserIndex != _INVALID && iUserIndex == lpObj->m_Index )
; 7702 : 				{
; 7703 : 					return FALSE;
; 7704 : 				}
; 7705 : 					
; 7706 : 			}
; 7707 : 		}
; 7708 : 		
; 7709 : 	}
; 7710 : #endif // CRYWOLF_MAIN_SCHEDULER_20050505
; 7711 : 
; 7712 : 
; 7713 : #ifdef CRYWOLF_NPC_WORK_20050912
; 7714 : 	//  ,   .
; 7715 : 	if(	CHECK_CRYWOLF_NPC_ALTAR(lpObj->Class) || CHECK_CRYWOLF_NPC_STATUE(lpObj->Class)	)
; 7716 : 	{
; 7717 : 		return FALSE;
; 7718 : 	}
; 7719 : #endif // CRYWOLF_NPC_WORK_20050912
; 7720 : 
; 7721 : #ifdef CRYWOLF_MONSTER_WORK_20050914
; 7722 : 	if( lpObj->Class == CRYWOLF_MON_TANKER )
; 7723 : 	{
; 7724 : 		return FALSE;
; 7725 : 	}
; 7726 : #endif // CRYWOLF_MONSTER_WORK_20050914
; 7727 : 
; 7728 : #ifdef MODIFY_0708_BUFFIX_20070820	//   
; 7729 : 	if( lpObj->Class == 275)

  000a5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a8	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000af	81 f9 13 01 00
	00		 cmp	 ecx, 275		; 00000113H
  000b5	75 07		 jne	 SHORT $LN7@gObjBackSp

; 7730 : 	{
; 7731 : 		return FALSE;

  000b7	33 c0		 xor	 eax, eax
  000b9	e9 93 01 00 00	 jmp	 $LN1@gObjBackSp
$LN7@gObjBackSp:

; 7732 : 	}
; 7733 : #endif	// MODIFY_0708_BUFFIX_20070820
; 7734 : 
; 7735 : #ifdef ADD_RAKLION_20080408			//  ,   
; 7736 : 	if( lpObj->Class == 459 || lpObj->Class == 460 || lpObj->Class == 461 || lpObj->Class == 462 )
; 7737 : 	{
; 7738 : 		return FALSE;
; 7739 : 	}
; 7740 : #endif // ADD_RAKLION_20080408
; 7741 : 
; 7742 : #ifdef MODIFY_BACK_SPRING_SKILL_BUGFIX_20080716		//     
; 7743 : 	INT iBuffIndex = -1;
; 7744 : 	for( INT iCount=0; iCount<lpObj->m_BuffEffectCount; ++iCount )
; 7745 : 	{
; 7746 : 		iBuffIndex = lpObj->m_BuffEffectList[iCount].BuffIndex;
; 7747 : 		
; 7748 : 		//    
; 7749 : 		if( iBuffIndex==BUFFTYPE_STONE			// 
; 7750 : 			|| iBuffIndex==BUFFTYPE_STUN			// 
; 7751 : 			|| iBuffIndex==BUFFTYPE_RESTRICTION )	// 
; 7752 : 		{
; 7753 : 			return FALSE;							//    .
; 7754 : 		}
; 7755 : 	}
; 7756 : #endif // MODIFY_BACK_SPRING_SKILL_BUGFIX_20080716
; 7757 : 
; 7758 : 	tdir = GetPathPacketDirPos( lpObj->X-lpTargetObj->X, lpObj->Y-lpTargetObj->Y)*2;

  000be	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c1	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  000c8	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  000cb	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  000d2	2b c8		 sub	 ecx, eax
  000d4	51		 push	 ecx
  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000d8	0f bf 91 04 01
	00 00		 movsx	 edx, WORD PTR [ecx+260]
  000df	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000e2	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  000e9	2b d1		 sub	 edx, ecx
  000eb	52		 push	 edx
  000ec	e8 00 00 00 00	 call	 ?GetPathPacketDirPos@@YAEHH@Z ; GetPathPacketDirPos
  000f1	83 c4 08	 add	 esp, 8
  000f4	0f b6 d0	 movzx	 edx, al
  000f7	d1 e2		 shl	 edx, 1
  000f9	89 55 fc	 mov	 DWORD PTR _tdir$[ebp], edx

; 7759 : 		
; 7760 : 	int x, y;
; 7761 : 
; 7762 : 	x = lpObj->X;

  000fc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ff	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00106	89 4d f8	 mov	 DWORD PTR _x$[ebp], ecx

; 7763 : 	y = lpObj->Y;

  00109	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010c	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00113	89 4d f4	 mov	 DWORD PTR _y$[ebp], ecx

; 7764 : 
; 7765 : 	for( int n=0; n<count; n++)

  00116	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0011d	eb 09		 jmp	 SHORT $LN4@gObjBackSp
$LN2@gObjBackSp:
  0011f	8b 45 f0	 mov	 eax, DWORD PTR _n$1[ebp]
  00122	83 c0 01	 add	 eax, 1
  00125	89 45 f0	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjBackSp:
  00128	8b 45 f0	 mov	 eax, DWORD PTR _n$1[ebp]
  0012b	3b 45 10	 cmp	 eax, DWORD PTR _count$[ebp]
  0012e	7d 78		 jge	 SHORT $LN3@gObjBackSp

; 7766 : 	{
; 7767 : 		if( n >= 2 )

  00130	83 7d f0 02	 cmp	 DWORD PTR _n$1[ebp], 2
  00134	7c 4e		 jl	 SHORT $LN8@gObjBackSp

; 7768 : 		{
; 7769 : #ifdef DARKLORD_WORK
; 7770 : 			if( lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA || lpObj->Class == CLASS_KNIGHT )	

  00136	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00139	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00140	83 f9 04	 cmp	 ecx, 4
  00143	74 1e		 je	 SHORT $LN11@gObjBackSp
  00145	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00148	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0014f	83 f9 03	 cmp	 ecx, 3
  00152	74 0f		 je	 SHORT $LN11@gObjBackSp
  00154	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00157	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0015e	83 f9 01	 cmp	 ecx, 1
  00161	75 1f		 jne	 SHORT $LN10@gObjBackSp
$LN11@gObjBackSp:

; 7771 : #else
; 7772 : 			if( lpObj->Class == CLASS_KNIGHT || lpObj->Class == CLASS_MAGUMSA )
; 7773 : #endif
; 7774 : 				BackSpringCheck(x, y, tdir, lpObj->MapNumber);

  00163	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00166	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0016d	51		 push	 ecx
  0016e	8d 55 fc	 lea	 edx, DWORD PTR _tdir$[ebp]
  00171	52		 push	 edx
  00172	8d 45 f4	 lea	 eax, DWORD PTR _y$[ebp]
  00175	50		 push	 eax
  00176	8d 4d f8	 lea	 ecx, DWORD PTR _x$[ebp]
  00179	51		 push	 ecx
  0017a	e8 00 00 00 00	 call	 ?BackSpringCheck@@YAHAAH00E@Z ; BackSpringCheck
  0017f	83 c4 10	 add	 esp, 16			; 00000010H
$LN10@gObjBackSp:

; 7775 : 		}

  00182	eb 1f		 jmp	 SHORT $LN9@gObjBackSp
$LN8@gObjBackSp:

; 7776 : 		else BackSpringCheck(x, y, tdir, lpObj->MapNumber);

  00184	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00187	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0018e	51		 push	 ecx
  0018f	8d 55 fc	 lea	 edx, DWORD PTR _tdir$[ebp]
  00192	52		 push	 edx
  00193	8d 45 f4	 lea	 eax, DWORD PTR _y$[ebp]
  00196	50		 push	 eax
  00197	8d 4d f8	 lea	 ecx, DWORD PTR _x$[ebp]
  0019a	51		 push	 ecx
  0019b	e8 00 00 00 00	 call	 ?BackSpringCheck@@YAHAAH00E@Z ; BackSpringCheck
  001a0	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@gObjBackSp:

; 7777 : 	}	

  001a3	e9 77 ff ff ff	 jmp	 $LN2@gObjBackSp
$LN3@gObjBackSp:

; 7778 : 	
; 7779 : 	PMSG_POSISTION_SET	pMove;
; 7780 : 	pMove.h.c		 = PMHC_BYTE;

  001a8	c6 45 e8 c1	 mov	 BYTE PTR _pMove$[ebp], 193 ; 000000c1H

; 7781 : 
; 7782 : #ifdef PACKET_CHANGE	
; 7783 : 	pMove.h.headcode = PACKET_POSITION;

  001ac	c6 45 ea d0	 mov	 BYTE PTR _pMove$[ebp+2], 208 ; 000000d0H

; 7784 : #else
; 7785 : 	pMove.h.headcode = 0x11;
; 7786 : #endif
; 7787 : 	pMove.h.size     = sizeof( pMove );

  001b0	c6 45 e9 05	 mov	 BYTE PTR _pMove$[ebp+1], 5

; 7788 : 	pMove.X          = (BYTE)x;

  001b4	8a 45 f8	 mov	 al, BYTE PTR _x$[ebp]
  001b7	88 45 eb	 mov	 BYTE PTR _pMove$[ebp+3], al

; 7789 : 	pMove.Y			 = (BYTE)y;

  001ba	8a 45 f4	 mov	 al, BYTE PTR _y$[ebp]
  001bd	88 45 ec	 mov	 BYTE PTR _pMove$[ebp+4], al

; 7790 : 	lpObj->m_Rest = 0;

  001c0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c3	c6 80 bd 01 00
	00 00		 mov	 BYTE PTR [eax+445], 0

; 7791 : 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  001ca	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001cd	0f bf 88 1e 01
	00 00		 movsx	 ecx, WORD PTR [eax+286]
  001d4	51		 push	 ecx
  001d5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001d8	0f bf 82 1c 01
	00 00		 movsx	 eax, WORD PTR [edx+284]
  001df	50		 push	 eax
  001e0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001e3	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  001ea	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  001f0	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  001f6	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 7792 : 	MapC[lpObj->MapNumber].SetStandAttr(x, y);

  001fb	8b 45 f4	 mov	 eax, DWORD PTR _y$[ebp]
  001fe	50		 push	 eax
  001ff	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  00202	51		 push	 ecx
  00203	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00206	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0020d	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00213	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00219	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 7793 : 	lpObj->m_OldX = x;

  0021e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00221	66 8b 4d f8	 mov	 cx, WORD PTR _x$[ebp]
  00225	66 89 88 1c 01
	00 00		 mov	 WORD PTR [eax+284], cx

; 7794 : 	lpObj->m_OldY = y;

  0022c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0022f	66 8b 4d f4	 mov	 cx, WORD PTR _y$[ebp]
  00233	66 89 88 1e 01
	00 00		 mov	 WORD PTR [eax+286], cx

; 7795 : 	RecvPositionSetProc(&pMove, lpObj->m_Index);

  0023a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0023d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023f	51		 push	 ecx
  00240	8d 55 e8	 lea	 edx, DWORD PTR _pMove$[ebp]
  00243	52		 push	 edx
  00244	e8 00 00 00 00	 call	 ?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ; RecvPositionSetProc
  00249	83 c4 08	 add	 esp, 8

; 7796 : 	return TRUE;

  0024c	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjBackSp:

; 7797 : }

  00251	5f		 pop	 edi
  00252	5e		 pop	 esi
  00253	5b		 pop	 ebx
  00254	8b e5		 mov	 esp, ebp
  00256	5d		 pop	 ebp
  00257	c3		 ret	 0
?gObjBackSpring2@@YAHPAVOBJECTSTRUCT@@0H@Z ENDP		; gObjBackSpring2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMonsterCallKill@@YAXH@Z
_TEXT	SEGMENT
_callmon$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjMonsterCallKill@@YAXH@Z PROC			; gObjMonsterCallKill, COMDAT

; 29567: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29568: 	LogAddTD("[Summon Monster] [%s][%s] Try to Kill Summoned Monster", 

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0001a	52		 push	 edx
  0001b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00028	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0002c	52		 push	 edx
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@LJCMNCCO@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5t@
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 29569: 		gObj[aIndex].AccountID, 
; 29570: 		gObj[aIndex].Name
; 29571: 		);
; 29572: 
; 29573: 	int callmon;
; 29574: 	if( gObj[aIndex].m_RecallMon < 0 ) return;	

  0003b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00048	83 bc 01 a4 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+676], 0
  00050	7d 05		 jge	 SHORT $LN2@gObjMonste
  00052	e9 6b 01 00 00	 jmp	 $LN1@gObjMonste
$LN2@gObjMonste:

; 29575: 
; 29576: 	callmon = gObj[aIndex].m_RecallMon;

  00057	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00064	8b 94 01 a4 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+676]
  0006b	89 55 fc	 mov	 DWORD PTR _callmon$[ebp], edx

; 29577: 
; 29578: 	if( callmon < 0 || callmon > MAX_OBJECT-1 ) return;

  0006e	83 7d fc 00	 cmp	 DWORD PTR _callmon$[ebp], 0
  00072	7c 09		 jl	 SHORT $LN4@gObjMonste
  00074	81 7d fc e7 1c
	00 00		 cmp	 DWORD PTR _callmon$[ebp], 7399 ; 00001ce7H
  0007b	7e 05		 jle	 SHORT $LN3@gObjMonste
$LN4@gObjMonste:
  0007d	e9 40 01 00 00	 jmp	 $LN1@gObjMonste
$LN3@gObjMonste:

; 29579: 	if( gObj[callmon].Type != OBJTYPE_MONSTER ) return;

  00082	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _callmon$[ebp], 7072
  00089	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008f	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00094	83 fa 02	 cmp	 edx, 2
  00097	74 05		 je	 SHORT $LN5@gObjMonste
  00099	e9 24 01 00 00	 jmp	 $LN1@gObjMonste
$LN5@gObjMonste:

; 29580: 	if( gObj[callmon].m_RecallMon != aIndex ) return;

  0009e	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _callmon$[ebp], 7072
  000a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ab	8b 94 01 a4 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+676]
  000b2	3b 55 08	 cmp	 edx, DWORD PTR _aIndex$[ebp]
  000b5	74 05		 je	 SHORT $LN6@gObjMonste
  000b7	e9 06 01 00 00	 jmp	 $LN1@gObjMonste
$LN6@gObjMonste:

; 29581: 	
; 29582: 	if( gObj[aIndex].m_RecallMon >= 0 )

  000bc	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c9	83 bc 01 a4 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+676], 0
  000d1	0f 8c 91 00 00
	00		 jl	 $LN7@gObjMonste

; 29583: 	{
; 29584: 		if( gObjIsConnected(gObj[aIndex].m_RecallMon)== TRUE)

  000d7	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e4	8b 94 01 a4 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+676]
  000eb	52		 push	 edx
  000ec	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000f1	83 c4 04	 add	 esp, 4
  000f4	83 f8 01	 cmp	 eax, 1
  000f7	75 6f		 jne	 SHORT $LN7@gObjMonste

; 29585: 		{
; 29586: 			LogAddTD("[Summon Monster] [%s][%s] Try to Kill Summoned Monster - Found Summoned Monster (SummonIndex:%d)", 

  000f9	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00100	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00106	8b 94 01 a4 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+676]
  0010d	52		 push	 edx
  0010e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00115	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011b	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0011f	52		 push	 edx
  00120	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00127	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0012d	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00131	52		 push	 edx
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_0GB@CGCBNNKJ@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5t@
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0013d	83 c4 10	 add	 esp, 16			; 00000010H

; 29587: 				gObj[aIndex].AccountID, 
; 29588: 				gObj[aIndex].Name,
; 29589: 				gObj[aIndex].m_RecallMon
; 29590: 				);
; 29591: 
; 29592: 			gObj[gObj[aIndex].m_RecallMon].m_RecallMon = -1;

  00140	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0014d	69 94 01 a4 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax+676], 7072
  00158	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0015d	c7 84 10 a4 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [eax+edx+676], -1
$LN7@gObjMonste:

; 29593: 		}
; 29594: 	}
; 29595: 	gObj[aIndex].m_RecallMon = -1;

  00168	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0016f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00175	c7 84 01 a4 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+676], -1

; 29596: 	gObjDel(callmon);

  00180	8b 45 fc	 mov	 eax, DWORD PTR _callmon$[ebp]
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00189	83 c4 04	 add	 esp, 4

; 29597: 
; 29598: 	LogAddTD("[Summon Monster] [%s][%s] Try to Kill Summoned Monster - Finished to Kill Summoned Monster (SummonIndex:%d)", 

  0018c	8b 45 fc	 mov	 eax, DWORD PTR _callmon$[ebp]
  0018f	50		 push	 eax
  00190	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00197	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019d	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  001a1	50		 push	 eax
  001a2	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001af	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  001b3	50		 push	 eax
  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_0GM@NPKLGGJP@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5t@
  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001bf	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@gObjMonste:

; 29599: 		gObj[aIndex].AccountID, 
; 29600: 		gObj[aIndex].Name,
; 29601: 		callmon
; 29602: 		);
; 29603: }

  001c2	5f		 pop	 edi
  001c3	5e		 pop	 esi
  001c4	5b		 pop	 ebx
  001c5	8b e5		 mov	 esp, ebp
  001c7	5d		 pop	 ebp
  001c8	c3		 ret	 0
?gObjMonsterCallKill@@YAXH@Z ENDP			; gObjMonsterCallKill
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMonsterCall@@YAHHHHH@Z
_TEXT	SEGMENT
_result$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_MonsterType$ = 12					; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?gObjMonsterCall@@YAHHHHH@Z PROC			; gObjMonsterCall, COMDAT

; 29513: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29514: 	int result;
; 29515: 
; 29516: #ifdef NEW_SKILL_FORSKYLAND
; 29517: 	if( gObj[aIndex].MapNumber == 10 )

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0001e	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00021	75 07		 jne	 SHORT $LN2@gObjMonste

; 29518: 	{	//   		
; 29519: 		return FALSE;

  00023	33 c0		 xor	 eax, eax
  00025	e9 a1 02 00 00	 jmp	 $LN1@gObjMonste
$LN2@gObjMonste:

; 29520: 	}
; 29521: #endif
; 29522: 	if( gObj[aIndex].m_RecallMon >= 0 ) 

  0002a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00037	83 bc 01 a4 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax+676], 0
  0003f	7c 23		 jl	 SHORT $LN3@gObjMonste

; 29523: 	{
; 29524: 		GCRecallMonLife(aIndex, 60, 0);

  00041	6a 00		 push	 0
  00043	6a 3c		 push	 60			; 0000003cH
  00045	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 29525: 		gObjMonsterCallKill(aIndex);

  00051	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  0005a	83 c4 04	 add	 esp, 4

; 29526: 		return FALSE;

  0005d	33 c0		 xor	 eax, eax
  0005f	e9 67 02 00 00	 jmp	 $LN1@gObjMonste
$LN3@gObjMonste:

; 29527: 		//return;
; 29528: 	}
; 29529: 	result = gObjAddCallMon();

  00064	e8 00 00 00 00	 call	 ?gObjAddCallMon@@YAFXZ	; gObjAddCallMon
  00069	98		 cwde
  0006a	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax

; 29530: 		
; 29531: 	if( result >= 0 )

  0006d	83 7d fc 00	 cmp	 DWORD PTR _result$[ebp], 0
  00071	0f 8c 52 02 00
	00		 jl	 $LN4@gObjMonste

; 29532: 	{
; 29533: 		gObj[result].X = x;

  00077	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00084	66 8b 55 10	 mov	 dx, WORD PTR _x$[ebp]
  00088	66 89 94 01 04
	01 00 00	 mov	 WORD PTR [ecx+eax+260], dx

; 29534: 		gObj[result].Y = y;

  00090	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  00097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009d	66 8b 55 14	 mov	 dx, WORD PTR _y$[ebp]
  000a1	66 89 94 01 06
	01 00 00	 mov	 WORD PTR [ecx+eax+262], dx

; 29535: 		gObj[result].MTX = x;

  000a9	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  000b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b6	66 8b 55 10	 mov	 dx, WORD PTR _x$[ebp]
  000ba	66 89 94 01 24
	01 00 00	 mov	 WORD PTR [ecx+eax+292], dx

; 29536: 		gObj[result].MTY = y;

  000c2	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  000c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cf	66 8b 55 14	 mov	 dx, WORD PTR _y$[ebp]
  000d3	66 89 94 01 26
	01 00 00	 mov	 WORD PTR [ecx+eax+294], dx

; 29537: 		gObj[result].Dir = 2;

  000db	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  000e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e8	c6 84 01 08 01
	00 00 02	 mov	 BYTE PTR [ecx+eax+264], 2

; 29538: 		gObj[result].MapNumber = gObj[aIndex].MapNumber;

  000f0	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f7	69 4d fc a0 1b
	00 00		 imul	 ecx, DWORD PTR _result$[ebp], 7072
  000fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00104	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010a	8a 84 06 09 01
	00 00		 mov	 al, BYTE PTR [esi+eax+265]
  00111	88 84 0a 09 01
	00 00		 mov	 BYTE PTR [edx+ecx+265], al

; 29539: 		
; 29540: 		gObjSetMonster(result, MonsterType);

  00118	8b 45 0c	 mov	 eax, DWORD PTR _MonsterType$[ebp]
  0011b	50		 push	 eax
  0011c	8b 4d fc	 mov	 ecx, DWORD PTR _result$[ebp]
  0011f	51		 push	 ecx
  00120	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  00125	83 c4 08	 add	 esp, 8

; 29541: 		gObj[result].m_RecallMon = aIndex;

  00128	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  0012f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00135	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00138	89 94 01 a4 02
	00 00		 mov	 DWORD PTR [ecx+eax+676], edx

; 29542: 
; 29543: 		gObj[result].m_Attribute	= 100;

  0013f	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  00146	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0014b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00151	66 89 8c 02 fe
	02 00 00	 mov	 WORD PTR [edx+eax+766], cx

; 29544: 		//gObj[result].m_MoveSpeed	= 100;
; 29545: 		gObj[result].TargetNumber	= -1;

  00159	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  00160	83 c9 ff	 or	 ecx, -1
  00163	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00169	66 89 8c 02 ac
	02 00 00	 mov	 WORD PTR [edx+eax+684], cx

; 29546: 		gObj[result].m_ActState.Emotion = 0;

  00171	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  00178	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017e	8b 94 01 b0 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+432]
  00185	81 e2 0f ff ff
	ff		 and	 edx, -241		; ffffff0fH
  0018b	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  00192	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00198	89 94 01 b0 01
	00 00		 mov	 DWORD PTR [ecx+eax+432], edx

; 29547: 		gObj[result].m_ActState.Attack = 0;

  0019f	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  001a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ac	8b 94 01 b0 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+432]
  001b3	83 e2 fd	 and	 edx, -3			; fffffffdH
  001b6	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  001bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c3	89 94 01 b0 01
	00 00		 mov	 DWORD PTR [ecx+eax+432], edx

; 29548: 		gObj[result].m_ActState.EmotionCount = 0;

  001ca	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  001d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d7	8b 94 01 b0 01
	00 00		 mov	 edx, DWORD PTR [ecx+eax+432]
  001de	81 e2 ff 00 ff
	ff		 and	 edx, -65281		; ffff00ffH
  001e4	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  001eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f1	89 94 01 b0 01
	00 00		 mov	 DWORD PTR [ecx+eax+432], edx

; 29549: 		gObj[result].PathCount		= 0;				

  001f8	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  001ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00205	c7 84 01 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+296], 0

; 29550: 		gObj[aIndex].m_RecallMon	= result;

  00210	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00217	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0021d	8b 55 fc	 mov	 edx, DWORD PTR _result$[ebp]
  00220	89 94 01 a4 02
	00 00		 mov	 DWORD PTR [ecx+eax+676], edx

; 29551: 		
; 29552: 		gObj[result].m_MoveRange = 15;

  00227	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  0022e	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00233	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00239	66 89 8c 02 f6
	02 00 00	 mov	 WORD PTR [edx+eax+758], cx

; 29553: 
; 29554: 		GCRecallMonLife(gObj[result].m_RecallMon, (int)gObj[result].MaxLife, (int)gObj[result].Life);

  00241	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  00248	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0024e	f3 0f 2c 94 01
	bc 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+188]
  00257	52		 push	 edx
  00258	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  0025f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00265	f3 0f 2c 94 01
	c0 00 00 00	 cvttss2si edx, DWORD PTR [ecx+eax+192]
  0026e	52		 push	 edx
  0026f	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _result$[ebp], 7072
  00276	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0027c	8b 94 01 a4 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+676]
  00283	52		 push	 edx
  00284	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife
  00289	83 c4 0c	 add	 esp, 12			; 0000000cH

; 29555: 
; 29556: 		LogAddTD("[Summon Monster] [%s][%s] Try to Summon Monster - Succeed (SummonIndex:%d)", 

  0028c	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
  0028f	50		 push	 eax
  00290	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00297	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0029d	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  002a1	50		 push	 eax
  002a2	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  002a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002af	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  002b3	50		 push	 eax
  002b4	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@FIMACGK@?$FLSummon?5Monster?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5t@
  002b9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002bf	83 c4 10	 add	 esp, 16			; 00000010H

; 29557: 			gObj[aIndex].AccountID, 
; 29558: 			gObj[aIndex].Name,
; 29559: 			result
; 29560: 			);
; 29561: 		return TRUE;

  002c2	b8 01 00 00 00	 mov	 eax, 1
  002c7	eb 02		 jmp	 SHORT $LN1@gObjMonste
$LN4@gObjMonste:

; 29562: 	}
; 29563: 	return FALSE;

  002c9	33 c0		 xor	 eax, eax
$LN1@gObjMonste:

; 29564: }

  002cb	5f		 pop	 edi
  002cc	5e		 pop	 esi
  002cd	5b		 pop	 ebx
  002ce	8b e5		 mov	 esp, ebp
  002d0	5d		 pop	 ebp
  002d1	c3		 ret	 0
?gObjMonsterCall@@YAHHHHH@Z ENDP			; gObjMonsterCall
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjWarehouseItemSet@@YAXHHE@Z
_TEXT	SEGMENT
_height$ = -8						; size = 4
_width$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_itempos$ = 12						; size = 4
_set_byte$ = 16						; size = 1
?gObjWarehouseItemSet@@YAXHHE@Z PROC			; gObjWarehouseItemSet, COMDAT

; 16320: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 16321: 	if( itempos < 0 ) return;

  00009	83 7d 0c 00	 cmp	 DWORD PTR _itempos$[ebp], 0
  0000d	7d 02		 jge	 SHORT $LN2@gObjWareho
  0000f	eb 7a		 jmp	 SHORT $LN1@gObjWareho
$LN2@gObjWareho:

; 16322: 	if( itempos > MAX_WAREHOUSEITEMS-1 ) return;

  00011	83 7d 0c 77	 cmp	 DWORD PTR _itempos$[ebp], 119 ; 00000077H
  00015	7e 02		 jle	 SHORT $LN3@gObjWareho
  00017	eb 72		 jmp	 SHORT $LN1@gObjWareho
$LN3@gObjWareho:

; 16323: 	
; 16324: 	int width, height;
; 16325: 
; 16326: 	if( gObj[aIndex].pWarehouse[itempos].GetSize( width, height ) == FALSE ) 

  00019	8d 45 f8	 lea	 eax, DWORD PTR _height$[ebp]
  0001c	50		 push	 eax
  0001d	8d 4d fc	 lea	 ecx, DWORD PTR _width$[ebp]
  00020	51		 push	 ecx
  00021	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00028	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _itempos$[ebp], 168
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00034	03 8c 10 94 0c
	00 00		 add	 ecx, DWORD PTR [eax+edx+3220]
  0003b	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  00040	85 c0		 test	 eax, eax
  00042	75 2a		 jne	 SHORT $LN4@gObjWareho

; 16327: 	{
; 16328: 		LogAdd(lMsg.Get(527), __FILE__, __LINE__);

  00044	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjWarehouseItemSet@@YAXHHE@Z@4JA
  00049	83 c0 08	 add	 eax, 8
  0004c	50		 push	 eax
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00052	68 0f 02 00 00	 push	 527			; 0000020fH
  00057	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00062	50		 push	 eax
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16329: 		return;

  0006c	eb 1d		 jmp	 SHORT $LN1@gObjWareho
$LN4@gObjWareho:

; 16330: 	}
; 16331: 	gObjWarehouseItemBoxSet(aIndex, itempos, width, height, set_byte);	

  0006e	0f b6 45 10	 movzx	 eax, BYTE PTR _set_byte$[ebp]
  00072	50		 push	 eax
  00073	8b 4d f8	 mov	 ecx, DWORD PTR _height$[ebp]
  00076	51		 push	 ecx
  00077	8b 55 fc	 mov	 edx, DWORD PTR _width$[ebp]
  0007a	52		 push	 edx
  0007b	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 ?gObjWarehouseItemBoxSet@@YAXHHHHE@Z ; gObjWarehouseItemBoxSet
  00088	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@gObjWareho:

; 16332: }

  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?gObjWarehouseItemSet@@YAXHHE@Z ENDP			; gObjWarehouseItemSet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z
_TEXT	SEGMENT
_useClass$ = -152					; size = 4
_blank$ = -148						; size = 4
_iheight$ = -144					; size = 4
_iwidth$ = -140						; size = 4
_h$ = -136						; size = 4
_w$ = -132						; size = 4
_TempMap$ = -128					; size = 120
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_item$ = 12						; size = 168
_pos$ = 180						; size = 4
_source$ = 184						; size = 4
?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z PROC	; gObjWarehouseInsertItemPos, COMDAT

; 16442: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 16443: 	if( pos < 0 || pos > MAX_WAREHOUSEITEMS-1 )

  00016	83 bd b4 00 00
	00 00		 cmp	 DWORD PTR _pos$[ebp], 0
  0001d	7c 09		 jl	 SHORT $LN3@gObjWareho
  0001f	83 bd b4 00 00
	00 77		 cmp	 DWORD PTR _pos$[ebp], 119 ; 00000077H
  00026	7e 07		 jle	 SHORT $LN2@gObjWareho
$LN3@gObjWareho:

; 16444: 	{
; 16445: 		return 0xFF;

  00028	0c ff		 or	 al, 255			; 000000ffH
  0002a	e9 d7 01 00 00	 jmp	 $LN1@gObjWareho
$LN2@gObjWareho:

; 16446: 	}
; 16447: 	
; 16448: 	LPOBJECTSTRUCT	lpObj;
; 16449: 
; 16450: 	BYTE			TempMap[MAX_WAREHOUSEITEMS];				//   
; 16451: 	int				w, h, iwidth, iheight;
; 16452: 	int				blank;
; 16453: 	BOOL			useClass=FALSE;

  0002f	c7 85 68 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _useClass$[ebp], 0

; 16454: 
; 16455: 	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  00039	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00040	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00046	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 16456: 
; 16457: 	//    ?
; 16458: 	if( lpObj->pWarehouse[pos].IsItem() == TRUE ) return 0xFF;

  00049	69 8d b4 00 00
	00 a8 00 00 00	 imul	 ecx, DWORD PTR _pos$[ebp], 168
  00053	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00056	03 88 94 0c 00
	00		 add	 ecx, DWORD PTR [eax+3220]
  0005c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00061	83 f8 01	 cmp	 eax, 1
  00064	75 07		 jne	 SHORT $LN4@gObjWareho
  00066	0c ff		 or	 al, 255			; 000000ffH
  00068	e9 99 01 00 00	 jmp	 $LN1@gObjWareho
$LN4@gObjWareho:

; 16459: 
; 16460: 	//   ?
; 16461: 	if( item.IsItem() == FALSE ) return 0xFF;

  0006d	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  00070	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00075	85 c0		 test	 eax, eax
  00077	75 07		 jne	 SHORT $LN5@gObjWareho
  00079	0c ff		 or	 al, 255			; 000000ffH
  0007b	e9 86 01 00 00	 jmp	 $LN1@gObjWareho
$LN5@gObjWareho:

; 16462: 	
; 16463: 	w = pos%8;

  00080	8b 85 b4 00 00
	00		 mov	 eax, DWORD PTR _pos$[ebp]
  00086	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0008b	79 05		 jns	 SHORT $LN13@gObjWareho
  0008d	48		 dec	 eax
  0008e	83 c8 f8	 or	 eax, -8			; fffffff8H
  00091	40		 inc	 eax
$LN13@gObjWareho:
  00092	89 85 7c ff ff
	ff		 mov	 DWORD PTR _w$[ebp], eax

; 16464: 	h = pos/8;

  00098	8b 85 b4 00 00
	00		 mov	 eax, DWORD PTR _pos$[ebp]
  0009e	99		 cdq
  0009f	83 e2 07	 and	 edx, 7
  000a2	03 c2		 add	 eax, edx
  000a4	c1 f8 03	 sar	 eax, 3
  000a7	89 85 78 ff ff
	ff		 mov	 DWORD PTR _h$[ebp], eax

; 16465: 		
; 16466: 	if( ExtentCheck(w, h, 8, 15) == FALSE) return 0xFF;

  000ad	6a 0f		 push	 15			; 0000000fH
  000af	6a 08		 push	 8
  000b1	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _h$[ebp]
  000b7	50		 push	 eax
  000b8	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _w$[ebp]
  000be	51		 push	 ecx
  000bf	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  000c4	83 c4 10	 add	 esp, 16			; 00000010H
  000c7	85 c0		 test	 eax, eax
  000c9	75 07		 jne	 SHORT $LN6@gObjWareho
  000cb	0c ff		 or	 al, 255			; 000000ffH
  000cd	e9 34 01 00 00	 jmp	 $LN1@gObjWareho
$LN6@gObjWareho:

; 16467: 	item.GetSize(iwidth, iheight);

  000d2	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _iheight$[ebp]
  000d8	50		 push	 eax
  000d9	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _iwidth$[ebp]
  000df	51		 push	 ecx
  000e0	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  000e3	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 16468: 
; 16469: 	if( source >= 0 )

  000e8	83 bd b8 00 00
	00 00		 cmp	 DWORD PTR _source$[ebp], 0
  000ef	7c 40		 jl	 SHORT $LN7@gObjWareho

; 16470: 	{
; 16471: 		memcpy(TempMap, lpObj->pWarehouseMap, MAX_WAREHOUSEITEMS);

  000f1	6a 78		 push	 120			; 00000078H
  000f3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f6	8b 88 98 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3224]
  000fc	51		 push	 ecx
  000fd	8d 55 80	 lea	 edx, DWORD PTR _TempMap$[ebp]
  00100	52		 push	 edx
  00101	e8 00 00 00 00	 call	 _memcpy
  00106	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16472: 		gObjWarehouseItemBoxSet(lpObj->m_Index, source, iwidth, iheight, 0xFF);

  00109	68 ff 00 00 00	 push	 255			; 000000ffH
  0010e	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _iheight$[ebp]
  00114	50		 push	 eax
  00115	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _iwidth$[ebp]
  0011b	51		 push	 ecx
  0011c	8b 95 b8 00 00
	00		 mov	 edx, DWORD PTR _source$[ebp]
  00122	52		 push	 edx
  00123	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00126	8b 08		 mov	 ecx, DWORD PTR [eax]
  00128	51		 push	 ecx
  00129	e8 00 00 00 00	 call	 ?gObjWarehouseItemBoxSet@@YAXHHHHE@Z ; gObjWarehouseItemBoxSet
  0012e	83 c4 14	 add	 esp, 20			; 00000014H
$LN7@gObjWareho:

; 16473: 	}
; 16474: 	// .. ..
; 16475: 	if( *(lpObj->pWarehouseMap+(h*8)+w) != 0xFF ) 

  00131	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00134	8b 88 98 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3224]
  0013a	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _h$[ebp]
  00140	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00143	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _w$[ebp]
  00149	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  0014d	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00153	74 28		 je	 SHORT $LN8@gObjWareho

; 16476: 	{
; 16477: 		if( source >= 0 )

  00155	83 bd b8 00 00
	00 00		 cmp	 DWORD PTR _source$[ebp], 0
  0015c	7c 18		 jl	 SHORT $LN9@gObjWareho

; 16478: 		{
; 16479: 			memcpy(lpObj->pWarehouseMap, TempMap, MAX_WAREHOUSEITEMS);

  0015e	6a 78		 push	 120			; 00000078H
  00160	8d 45 80	 lea	 eax, DWORD PTR _TempMap$[ebp]
  00163	50		 push	 eax
  00164	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00167	8b 91 98 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3224]
  0016d	52		 push	 edx
  0016e	e8 00 00 00 00	 call	 _memcpy
  00173	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@gObjWareho:

; 16480: 		}
; 16481: 		return 0xFF;

  00176	0c ff		 or	 al, 255			; 000000ffH
  00178	e9 89 00 00 00	 jmp	 $LN1@gObjWareho
$LN8@gObjWareho:

; 16482: 	}
; 16483: 
; 16484: 	blank = gObjWerehouseRectCheck(lpObj->m_Index, w, h, iwidth, iheight);

  0017d	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _iheight$[ebp]
  00183	50		 push	 eax
  00184	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _iwidth$[ebp]
  0018a	51		 push	 ecx
  0018b	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR _h$[ebp]
  00191	52		 push	 edx
  00192	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _w$[ebp]
  00198	50		 push	 eax
  00199	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0019c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ?gObjWerehouseRectCheck@@YAEHHHHH@Z ; gObjWerehouseRectCheck
  001a4	83 c4 14	 add	 esp, 20			; 00000014H
  001a7	0f b6 c0	 movzx	 eax, al
  001aa	89 85 6c ff ff
	ff		 mov	 DWORD PTR _blank$[ebp], eax

; 16485: 	
; 16486: 	if( blank == 0xFF )

  001b0	81 bd 6c ff ff
	ff ff 00 00 00	 cmp	 DWORD PTR _blank$[ebp], 255 ; 000000ffH
  001ba	75 25		 jne	 SHORT $LN10@gObjWareho

; 16487: 	{
; 16488: 		if( source >= 0 )

  001bc	83 bd b8 00 00
	00 00		 cmp	 DWORD PTR _source$[ebp], 0
  001c3	7c 18		 jl	 SHORT $LN11@gObjWareho

; 16489: 		{
; 16490: 			memcpy(lpObj->pWarehouseMap, TempMap, MAX_WAREHOUSEITEMS);

  001c5	6a 78		 push	 120			; 00000078H
  001c7	8d 45 80	 lea	 eax, DWORD PTR _TempMap$[ebp]
  001ca	50		 push	 eax
  001cb	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001ce	8b 91 98 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3224]
  001d4	52		 push	 edx
  001d5	e8 00 00 00 00	 call	 _memcpy
  001da	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@gObjWareho:

; 16491: 		}
; 16492: 		return 0xFF;

  001dd	0c ff		 or	 al, 255			; 000000ffH
  001df	eb 25		 jmp	 SHORT $LN1@gObjWareho
$LN10@gObjWareho:

; 16493: 	}
; 16494: 	lpObj->pWarehouse[pos] = item;

  001e1	69 85 b4 00 00
	00 a8 00 00 00	 imul	 eax, DWORD PTR _pos$[ebp], 168
  001eb	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001ee	8b b9 94 0c 00
	00		 mov	 edi, DWORD PTR [ecx+3220]
  001f4	03 f8		 add	 edi, eax
  001f6	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  001fb	8d 75 0c	 lea	 esi, DWORD PTR _item$[ebp]
  001fe	f3 a5		 rep movsd

; 16495: 	return pos;

  00200	8a 85 b4 00 00
	00		 mov	 al, BYTE PTR _pos$[ebp]
$LN1@gObjWareho:

; 16496: }

  00206	5f		 pop	 edi
  00207	5e		 pop	 esi
  00208	5b		 pop	 ebx
  00209	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020c	33 cd		 xor	 ecx, ebp
  0020e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00213	8b e5		 mov	 esp, ebp
  00215	5d		 pop	 ebp
  00216	c3		 ret	 0
?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z ENDP	; gObjWarehouseInsertItemPos
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjWarehouseTextSave@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_n$1 = -16						; size = 4
_NewOption$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjWarehouseTextSave@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjWarehouseTextSave, COMDAT

; 4401 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 4402 : 	BYTE NewOption[8];
; 4403 : 	for(int n=0; n<MAX_WAREHOUSEITEMS; n++)

  00013	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0001a	eb 09		 jmp	 SHORT $LN4@gObjWareho
$LN2@gObjWareho:
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _n$1[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 f0	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjWareho:
  00025	83 7d f0 78	 cmp	 DWORD PTR _n$1[ebp], 120 ; 00000078H
  00029	0f 8d 9f 01 00
	00		 jge	 $LN3@gObjWareho

; 4404 : 	{
; 4405 : 		if( lpObj->pWarehouse[n].IsItem() == TRUE )

  0002f	69 4d f0 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00036	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00039	03 88 94 0c 00
	00		 add	 ecx, DWORD PTR [eax+3220]
  0003f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00044	83 f8 01	 cmp	 eax, 1
  00047	0f 85 7c 01 00
	00		 jne	 $LN6@gObjWareho

; 4406 : 		{
; 4407 : #ifndef EXTEND_LOG_SYSTEM_05_20060823
; 4408 : 			if( lpObj->pWarehouse[n].m_serial )

  0004d	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00057	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  0005d	0f be 44 02 04	 movsx	 eax, BYTE PTR [edx+eax+4]
  00062	85 c0		 test	 eax, eax
  00064	0f 84 5f 01 00
	00		 je	 $LN6@gObjWareho

; 4409 : #endif // EXTEND_LOG_SYSTEM_05_20060823
; 4410 : 			{
; 4411 : 				ItemIsBufExOption(NewOption, &lpObj->pWarehouse[n]);

  0006a	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00074	03 81 94 0c 00
	00		 add	 eax, DWORD PTR [ecx+3220]
  0007a	50		 push	 eax
  0007b	8d 55 f4	 lea	 edx, DWORD PTR _NewOption$[ebp]
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  00084	83 c4 08	 add	 esp, 8

; 4412 : 
; 4413 : #ifdef EXTEND_LOG_SYSTEM_03_20060816
; 4414 : 				LogAddTD(lMsg.Get(506), 
; 4415 : 					lpObj->AccountID, 
; 4416 : 					lpObj->Name, 
; 4417 : 					n, 
; 4418 : 					lpObj->pWarehouse[n].GetName(), 
; 4419 : 					lpObj->pWarehouse[n].m_Level, 
; 4420 : 					lpObj->pWarehouse[n].m_Option1, 
; 4421 : 					lpObj->pWarehouse[n].m_Option2, 
; 4422 : 					lpObj->pWarehouse[n].m_Option3, 
; 4423 : 					lpObj->pWarehouse[n].m_Number, 
; 4424 : 					(BYTE)lpObj->pWarehouse[n].m_Durability,
; 4425 : 					NewOption[0],
; 4426 : 					NewOption[1],
; 4427 : 					NewOption[2],
; 4428 : 					NewOption[3],
; 4429 : 					NewOption[4],
; 4430 : 					NewOption[5],
; 4431 : 					NewOption[6],
; 4432 : 					lpObj->pWarehouse[n].m_SetOption,
; 4433 : 	#ifdef MODIFY_LOG_SYSTEM_2_3_20060828
; 4434 : 					lpObj->pWarehouse[n].m_ItemOptionEx>>7,
; 4435 : 					g_kJewelOfHarmonySystem.GetItemStrengthenOption( &lpObj->pWarehouse[n] ),
; 4436 : 					g_kJewelOfHarmonySystem.GetItemOptionLevel( &lpObj->pWarehouse[n] )
; 4437 : 	#else
; 4438 : 					lpObj->pInventory[n].m_ItemOptionEx>>7,
; 4439 : 					g_kJewelOfHarmonySystem.GetItemStrengthenOption( &lpObj->pInventory[n] ),
; 4440 : 					g_kJewelOfHarmonySystem.GetItemOptionLevel( &lpObj->pInventory[n] )
; 4441 : 	#endif // MODIFY_LOG_SYSTEM_2_3_20060828
; 4442 : 	#ifdef ADD_SOCKET_OPTION_LOG_02_20080821
; 4443 : 					, lpObj->pWarehouse[n].m_SocketOption[0],
; 4444 : 					lpObj->pWarehouse[n].m_SocketOption[1],
; 4445 : 					lpObj->pWarehouse[n].m_SocketOption[2],
; 4446 : 					lpObj->pWarehouse[n].m_SocketOption[3],
; 4447 : 					lpObj->pWarehouse[n].m_SocketOption[4]
; 4448 : 	#endif // ADD_SOCKET_OPTION_LOG_02_20080821
; 4449 : 	//#ifdef MODIFY_BUGFIX_20081119
; 4450 : 	#ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 4451 : 					, lpObj->pWarehouse[n].m_BonusSocketOption
; 4452 : 	#endif
; 4453 : 	//#endif	// MODIFY_BUGFIX_20081119
; 4454 : 					);
; 4455 : #else // EXTEND_LOG_SYSTEM_03_20060816
; 4456 : 				LogAddTD(lMsg.Get(506), 

  00087	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00091	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  00097	0f b6 84 02 92
	00 00 00	 movzx	 eax, BYTE PTR [edx+eax+146]
  0009f	50		 push	 eax
  000a0	b9 01 00 00 00	 mov	 ecx, 1
  000a5	6b d1 06	 imul	 edx, ecx, 6
  000a8	0f b6 44 15 f4	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  000ad	50		 push	 eax
  000ae	b9 01 00 00 00	 mov	 ecx, 1
  000b3	6b d1 05	 imul	 edx, ecx, 5
  000b6	0f b6 44 15 f4	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  000bb	50		 push	 eax
  000bc	b9 01 00 00 00	 mov	 ecx, 1
  000c1	c1 e1 02	 shl	 ecx, 2
  000c4	0f b6 54 0d f4	 movzx	 edx, BYTE PTR _NewOption$[ebp+ecx]
  000c9	52		 push	 edx
  000ca	b8 01 00 00 00	 mov	 eax, 1
  000cf	6b c8 03	 imul	 ecx, eax, 3
  000d2	0f b6 54 0d f4	 movzx	 edx, BYTE PTR _NewOption$[ebp+ecx]
  000d7	52		 push	 edx
  000d8	b8 01 00 00 00	 mov	 eax, 1
  000dd	d1 e0		 shl	 eax, 1
  000df	0f b6 4c 05 f4	 movzx	 ecx, BYTE PTR _NewOption$[ebp+eax]
  000e4	51		 push	 ecx
  000e5	ba 01 00 00 00	 mov	 edx, 1
  000ea	c1 e2 00	 shl	 edx, 0
  000ed	0f b6 44 15 f4	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  000f2	50		 push	 eax
  000f3	b9 01 00 00 00	 mov	 ecx, 1
  000f8	6b d1 00	 imul	 edx, ecx, 0
  000fb	0f b6 44 15 f4	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  00100	50		 push	 eax
  00101	69 4d f0 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00108	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0010b	8b 82 94 0c 00
	00		 mov	 eax, DWORD PTR [edx+3220]
  00111	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  00117	0f b6 d1	 movzx	 edx, cl
  0011a	52		 push	 edx
  0011b	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00122	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00125	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  0012b	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0012e	50		 push	 eax
  0012f	69 4d f0 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00136	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00139	8b 82 94 0c 00
	00		 mov	 eax, DWORD PTR [edx+3220]
  0013f	0f b6 4c 08 7a	 movzx	 ecx, BYTE PTR [eax+ecx+122]
  00144	51		 push	 ecx
  00145	69 55 f0 a8 00
	00 00		 imul	 edx, DWORD PTR _n$1[ebp], 168
  0014c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014f	8b 88 94 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3220]
  00155	0f b6 54 11 79	 movzx	 edx, BYTE PTR [ecx+edx+121]
  0015a	52		 push	 edx
  0015b	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00162	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00165	8b 91 94 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3220]
  0016b	0f b6 44 02 78	 movzx	 eax, BYTE PTR [edx+eax+120]
  00170	50		 push	 eax
  00171	69 4d f0 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00178	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0017b	8b 82 94 0c 00
	00		 mov	 eax, DWORD PTR [edx+3220]
  00181	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  00186	51		 push	 ecx
  00187	69 4d f0 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  0018e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00191	03 8a 94 0c 00
	00		 add	 ecx, DWORD PTR [edx+3220]
  00197	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0019c	50		 push	 eax
  0019d	8b 45 f0	 mov	 eax, DWORD PTR _n$1[ebp]
  001a0	50		 push	 eax
  001a1	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001a4	83 c1 73	 add	 ecx, 115		; 00000073H
  001a7	51		 push	 ecx
  001a8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001ab	83 c2 68	 add	 edx, 104		; 00000068H
  001ae	52		 push	 edx
  001af	68 fa 01 00 00	 push	 506			; 000001faH
  001b4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001bf	50		 push	 eax
  001c0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001c6	83 c4 4c	 add	 esp, 76			; 0000004cH
$LN6@gObjWareho:

; 4457 : 					lpObj->AccountID, 
; 4458 : 					lpObj->Name, 
; 4459 : 					n, 
; 4460 : 					lpObj->pWarehouse[n].GetName(), 
; 4461 : 					lpObj->pWarehouse[n].m_Level, 
; 4462 : 					lpObj->pWarehouse[n].m_Option1, 
; 4463 : 					lpObj->pWarehouse[n].m_Option2, 
; 4464 : 					lpObj->pWarehouse[n].m_Option3, 
; 4465 : 					lpObj->pWarehouse[n].m_Number, 
; 4466 : 					(BYTE)lpObj->pWarehouse[n].m_Durability,
; 4467 : 					NewOption[0],
; 4468 : 					NewOption[1],
; 4469 : 					NewOption[2],
; 4470 : 					NewOption[3],
; 4471 : 					NewOption[4],
; 4472 : 					NewOption[5],
; 4473 : 					NewOption[6],
; 4474 : 					lpObj->pWarehouse[n].m_SetOption
; 4475 : 					);
; 4476 : #endif // EXTEND_LOG_SYSTEM_03_20060816
; 4477 : 
; 4478 : 			}
; 4479 : 		}
; 4480 : 	}

  001c9	e9 4e fe ff ff	 jmp	 $LN2@gObjWareho
$LN3@gObjWareho:

; 4481 : 	LogAddTD(lMsg.Get(507), lpObj->AccountID, lpObj->Name, lpObj->WarehouseMoney);

  001ce	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d1	8b 88 a4 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3236]
  001d7	51		 push	 ecx
  001d8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001db	83 c2 73	 add	 edx, 115		; 00000073H
  001de	52		 push	 edx
  001df	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e2	83 c0 68	 add	 eax, 104		; 00000068H
  001e5	50		 push	 eax
  001e6	68 fb 01 00 00	 push	 507			; 000001fbH
  001eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001f6	50		 push	 eax
  001f7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001fd	83 c4 10	 add	 esp, 16			; 00000010H

; 4482 : }

  00200	5f		 pop	 edi
  00201	5e		 pop	 esi
  00202	5b		 pop	 ebx
  00203	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00206	33 cd		 xor	 ecx, ebp
  00208	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020d	8b e5		 mov	 esp, ebp
  0020f	5d		 pop	 ebp
  00210	c3		 ret	 0
?gObjWarehouseTextSave@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjWarehouseTextSave
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjItemTextSave@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_n$1 = -16						; size = 4
_NewOption$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjItemTextSave@@YAXPAVOBJECTSTRUCT@@@Z PROC		; gObjItemTextSave, COMDAT

; 4317 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 4318 : 	BYTE NewOption[8];
; 4319 : 	
; 4320 : #ifdef PERSONAL_SHOP_20040113
; 4321 : 	for(int n=0; n<MAX_INVENTORY_EXTEND; n++)

  00013	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0001a	eb 09		 jmp	 SHORT $LN4@gObjItemTe
$LN2@gObjItemTe:
  0001c	8b 45 f0	 mov	 eax, DWORD PTR _n$1[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 f0	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjItemTe:
  00025	83 7d f0 6c	 cmp	 DWORD PTR _n$1[ebp], 108 ; 0000006cH
  00029	0f 8d 9f 01 00
	00		 jge	 $LN3@gObjItemTe

; 4322 : #else
; 4323 : 	for(int n=0; n<MAX_INVENTORY; n++)
; 4324 : #endif
; 4325 : 	{
; 4326 : 		if( lpObj->pInventory[n].IsItem() == TRUE )

  0002f	69 4d f0 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00036	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00039	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0003f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00044	83 f8 01	 cmp	 eax, 1
  00047	0f 85 7c 01 00
	00		 jne	 $LN6@gObjItemTe

; 4327 : 		{
; 4328 : #ifndef EXTEND_LOG_SYSTEM_05_20060823
; 4329 : 			// ,       
; 4330 : 			if( lpObj->pInventory[n].m_serial )

  0004d	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00057	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0005d	0f be 44 02 04	 movsx	 eax, BYTE PTR [edx+eax+4]
  00062	85 c0		 test	 eax, eax
  00064	0f 84 5f 01 00
	00		 je	 $LN6@gObjItemTe

; 4331 : #endif // EXTEND_LOG_SYSTEM_05_20060823
; 4332 : 			{
; 4333 : 				ItemIsBufExOption(NewOption, &lpObj->pInventory[n]);

  0006a	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00074	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  0007a	50		 push	 eax
  0007b	8d 55 f4	 lea	 edx, DWORD PTR _NewOption$[ebp]
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  00084	83 c4 08	 add	 esp, 8

; 4334 : 
; 4335 : #ifdef EXTEND_LOG_SYSTEM_03_20060816
; 4336 : 				LogAddTD(lMsg.Get(504), 
; 4337 : 					lpObj->AccountID, 
; 4338 : 					lpObj->Name, 
; 4339 : 					n, 
; 4340 : 					lpObj->pInventory[n].GetName(), 
; 4341 : 					lpObj->pInventory[n].m_Level, 
; 4342 : 					lpObj->pInventory[n].m_Option1, 
; 4343 : 					lpObj->pInventory[n].m_Option2, 
; 4344 : 					lpObj->pInventory[n].m_Option3, 
; 4345 : 					lpObj->pInventory[n].m_Number, 
; 4346 : 					(BYTE)lpObj->pInventory[n].m_Durability,
; 4347 : 					NewOption[0],
; 4348 : 					NewOption[1],
; 4349 : 					NewOption[2],
; 4350 : 					NewOption[3],
; 4351 : 					NewOption[4],
; 4352 : 					NewOption[5],
; 4353 : 					NewOption[6],
; 4354 : 					lpObj->pInventory[n].m_SetOption,
; 4355 : 					lpObj->pInventory[n].m_ItemOptionEx>>7,
; 4356 : 					g_kJewelOfHarmonySystem.GetItemStrengthenOption( &lpObj->pInventory[n] ),
; 4357 : 					g_kJewelOfHarmonySystem.GetItemOptionLevel( &lpObj->pInventory[n])
; 4358 : 	#ifdef ADD_SOCKET_OPTION_LOG_02_20080821
; 4359 : 					, lpObj->pInventory[n].m_SocketOption[0],
; 4360 : 					lpObj->pInventory[n].m_SocketOption[1],
; 4361 : 					lpObj->pInventory[n].m_SocketOption[2],
; 4362 : 					lpObj->pInventory[n].m_SocketOption[3],
; 4363 : 					lpObj->pInventory[n].m_SocketOption[4]
; 4364 : 	#endif // ADD_SOCKET_OPTION_LOG_02_20080821
; 4365 : 	//#ifdef MODIFY_BUGFIX_20081119
; 4366 : 	#ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 4367 : 					, lpObj->pInventory[n].m_BonusSocketOption
; 4368 : 	#endif
; 4369 : 	//#endif	// MODIFY_BUGFIX_20081119
; 4370 : 					);
; 4371 : #else // EXTEND_LOG_SYSTEM_03_20060816
; 4372 : 				LogAddTD(lMsg.Get(504), 

  00087	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00091	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00097	0f b6 84 02 92
	00 00 00	 movzx	 eax, BYTE PTR [edx+eax+146]
  0009f	50		 push	 eax
  000a0	b9 01 00 00 00	 mov	 ecx, 1
  000a5	6b d1 06	 imul	 edx, ecx, 6
  000a8	0f b6 44 15 f4	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  000ad	50		 push	 eax
  000ae	b9 01 00 00 00	 mov	 ecx, 1
  000b3	6b d1 05	 imul	 edx, ecx, 5
  000b6	0f b6 44 15 f4	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  000bb	50		 push	 eax
  000bc	b9 01 00 00 00	 mov	 ecx, 1
  000c1	c1 e1 02	 shl	 ecx, 2
  000c4	0f b6 54 0d f4	 movzx	 edx, BYTE PTR _NewOption$[ebp+ecx]
  000c9	52		 push	 edx
  000ca	b8 01 00 00 00	 mov	 eax, 1
  000cf	6b c8 03	 imul	 ecx, eax, 3
  000d2	0f b6 54 0d f4	 movzx	 edx, BYTE PTR _NewOption$[ebp+ecx]
  000d7	52		 push	 edx
  000d8	b8 01 00 00 00	 mov	 eax, 1
  000dd	d1 e0		 shl	 eax, 1
  000df	0f b6 4c 05 f4	 movzx	 ecx, BYTE PTR _NewOption$[ebp+eax]
  000e4	51		 push	 ecx
  000e5	ba 01 00 00 00	 mov	 edx, 1
  000ea	c1 e2 00	 shl	 edx, 0
  000ed	0f b6 44 15 f4	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  000f2	50		 push	 eax
  000f3	b9 01 00 00 00	 mov	 ecx, 1
  000f8	6b d1 00	 imul	 edx, ecx, 0
  000fb	0f b6 44 15 f4	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  00100	50		 push	 eax
  00101	69 4d f0 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00108	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0010b	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00111	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  00117	0f b6 d1	 movzx	 edx, cl
  0011a	52		 push	 edx
  0011b	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00122	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00125	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0012b	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0012e	50		 push	 eax
  0012f	69 4d f0 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00136	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00139	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0013f	0f b6 4c 08 7a	 movzx	 ecx, BYTE PTR [eax+ecx+122]
  00144	51		 push	 ecx
  00145	69 55 f0 a8 00
	00 00		 imul	 edx, DWORD PTR _n$1[ebp], 168
  0014c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014f	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00155	0f b6 54 11 79	 movzx	 edx, BYTE PTR [ecx+edx+121]
  0015a	52		 push	 edx
  0015b	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00162	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00165	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0016b	0f b6 44 02 78	 movzx	 eax, BYTE PTR [edx+eax+120]
  00170	50		 push	 eax
  00171	69 4d f0 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  00178	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0017b	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00181	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  00186	51		 push	 ecx
  00187	69 4d f0 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  0018e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00191	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00197	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0019c	50		 push	 eax
  0019d	8b 45 f0	 mov	 eax, DWORD PTR _n$1[ebp]
  001a0	50		 push	 eax
  001a1	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001a4	83 c1 73	 add	 ecx, 115		; 00000073H
  001a7	51		 push	 ecx
  001a8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001ab	83 c2 68	 add	 edx, 104		; 00000068H
  001ae	52		 push	 edx
  001af	68 f8 01 00 00	 push	 504			; 000001f8H
  001b4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001bf	50		 push	 eax
  001c0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001c6	83 c4 4c	 add	 esp, 76			; 0000004cH
$LN6@gObjItemTe:

; 4373 : 					lpObj->AccountID, 
; 4374 : 					lpObj->Name, 
; 4375 : 					n, 
; 4376 : 					lpObj->pInventory[n].GetName(), 
; 4377 : 					lpObj->pInventory[n].m_Level, 
; 4378 : 					lpObj->pInventory[n].m_Option1, 
; 4379 : 					lpObj->pInventory[n].m_Option2, 
; 4380 : 					lpObj->pInventory[n].m_Option3, 
; 4381 : 					lpObj->pInventory[n].m_Number, 
; 4382 : 					(BYTE)lpObj->pInventory[n].m_Durability,
; 4383 : 					NewOption[0],
; 4384 : 					NewOption[1],
; 4385 : 					NewOption[2],
; 4386 : 					NewOption[3],
; 4387 : 					NewOption[4],
; 4388 : 					NewOption[5],
; 4389 : 					NewOption[6],
; 4390 : 					lpObj->pInventory[n].m_SetOption
; 4391 : 					);
; 4392 : #endif // EXTEND_LOG_SYSTEM_03_20060816
; 4393 : 
; 4394 : 			}
; 4395 : 		}
; 4396 : 	}

  001c9	e9 4e fe ff ff	 jmp	 $LN2@gObjItemTe
$LN3@gObjItemTe:

; 4397 : 	LogAddTD(lMsg.Get(505), lpObj->AccountID, lpObj->Name, lpObj->Money);

  001ce	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d1	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  001d7	51		 push	 ecx
  001d8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001db	83 c2 73	 add	 edx, 115		; 00000073H
  001de	52		 push	 edx
  001df	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e2	83 c0 68	 add	 eax, 104		; 00000068H
  001e5	50		 push	 eax
  001e6	68 f9 01 00 00	 push	 505			; 000001f9H
  001eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001f6	50		 push	 eax
  001f7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001fd	83 c4 10	 add	 esp, 16			; 00000010H

; 4398 : }

  00200	5f		 pop	 edi
  00201	5e		 pop	 esi
  00202	5b		 pop	 ebx
  00203	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00206	33 cd		 xor	 ecx, ebp
  00208	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0020d	8b e5		 mov	 esp, ebp
  0020f	5d		 pop	 ebp
  00210	c3		 ret	 0
?gObjItemTextSave@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; gObjItemTextSave
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMagicTextSave@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_n$1 = -8						; size = 4
_total$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjMagicTextSave@@YAXPAVOBJECTSTRUCT@@@Z PROC		; gObjMagicTextSave, COMDAT

; 4267 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4268 : 	int total=0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _total$[ebp], 0

; 4269 : 
; 4270 : 	for(int n=0; n<MAX_MAGIC; n++)

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN4@gObjMagicT
$LN2@gObjMagicT:
  00019	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjMagicT:
  00022	83 7d f8 3c	 cmp	 DWORD PTR _n$1[ebp], 60	; 0000003cH
  00026	7d 65		 jge	 SHORT $LN1@gObjMagicT

; 4271 : 	{
; 4272 : 		if( lpObj->Magic[n].IsMagic() == TRUE )

  00028	8b 4d f8	 mov	 ecx, DWORD PTR _n$1[ebp]
  0002b	c1 e1 04	 shl	 ecx, 4
  0002e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00031	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  00037	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  0003c	83 f8 01	 cmp	 eax, 1
  0003f	75 4a		 jne	 SHORT $LN5@gObjMagicT

; 4273 : 		{
; 4274 : 			LogAddTD(lMsg.Get(503), lpObj->AccountID, lpObj->Name, n, lpObj->Magic[n].m_Skill);

  00041	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  00044	c1 e0 04	 shl	 eax, 4
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0004a	8b 91 10 03 00
	00		 mov	 edx, DWORD PTR [ecx+784]
  00050	0f b6 44 02 05	 movzx	 eax, BYTE PTR [edx+eax+5]
  00055	50		 push	 eax
  00056	8b 4d f8	 mov	 ecx, DWORD PTR _n$1[ebp]
  00059	51		 push	 ecx
  0005a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0005d	83 c2 73	 add	 edx, 115		; 00000073H
  00060	52		 push	 edx
  00061	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00064	83 c0 68	 add	 eax, 104		; 00000068H
  00067	50		 push	 eax
  00068	68 f7 01 00 00	 push	 503			; 000001f7H
  0006d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00078	50		 push	 eax
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0007f	83 c4 14	 add	 esp, 20			; 00000014H

; 4275 : 			total++;

  00082	8b 45 fc	 mov	 eax, DWORD PTR _total$[ebp]
  00085	83 c0 01	 add	 eax, 1
  00088	89 45 fc	 mov	 DWORD PTR _total$[ebp], eax
$LN5@gObjMagicT:

; 4276 : 		}
; 4277 : 	}

  0008b	eb 8c		 jmp	 SHORT $LN2@gObjMagicT
$LN1@gObjMagicT:

; 4278 : 	//LogAddTD(lMsg.Get(503), lpObj->AccountID, lpObj->Name, total);
; 4279 : }

  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?gObjMagicTextSave@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; gObjMagicTextSave
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjStatTextSave@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjStatTextSave@@YAXPAVOBJECTSTRUCT@@@Z PROC		; gObjStatTextSave, COMDAT

; 4295 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4296 : #ifdef DARKLORD_WORK
; 4297 : 	LogAddTD("[%s][%s] CharInfoSave : Class=%d Level=%d LVPoint=%d Exp=%u Str=%d Dex=%d Vit=%d Energy=%d Leadership:%d Map=%d Pk=%d", 

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00017	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0001e	50		 push	 eax
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00022	0f b7 91 d8 00
	00 00		 movzx	 edx, WORD PTR [ecx+216]
  00029	52		 push	 edx
  0002a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002d	0f b7 88 ba 00
	00 00		 movzx	 ecx, WORD PTR [eax+186]
  00034	51		 push	 ecx
  00035	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00038	0f b7 82 b8 00
	00 00		 movzx	 eax, WORD PTR [edx+184]
  0003f	50		 push	 eax
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00043	0f b7 91 b6 00
	00 00		 movzx	 edx, WORD PTR [ecx+182]
  0004a	52		 push	 edx
  0004b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004e	0f b7 88 b4 00
	00 00		 movzx	 ecx, WORD PTR [eax+180]
  00055	51		 push	 ecx
  00056	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00059	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  0005f	50		 push	 eax
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00063	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  00069	52		 push	 edx
  0006a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006d	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00074	51		 push	 ecx
  00075	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00078	0f b6 82 9e 00
	00 00		 movzx	 eax, BYTE PTR [edx+158]
  0007f	50		 push	 eax
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00083	83 c1 73	 add	 ecx, 115		; 00000073H
  00086	51		 push	 ecx
  00087	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0008a	83 c2 68	 add	 edx, 104		; 00000068H
  0008d	52		 push	 edx
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0HG@OJODFIFG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CharInfoSave?5?3?5Class?$DN?$CF@
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00099	83 c4 38	 add	 esp, 56			; 00000038H

; 4298 : 			 lpObj->AccountID, lpObj->Name, 
; 4299 : 			 lpObj->DbClass, lpObj->Level, 
; 4300 : 			 lpObj->LevelUpPoint, lpObj->Experience, 
; 4301 : 			 lpObj->Strength, lpObj->Dexterity, 
; 4302 : 			 lpObj->Vitality, lpObj->Energy, 
; 4303 : 			 lpObj->Leadership,
; 4304 : 			 lpObj->MapNumber, lpObj->m_PK_Level);
; 4305 : #else
; 4306 : 	LogAddTD("[%s][%s] CharInfoSave : Class=%d Level=%d LVPoint=%d Exp=%u Str=%d Dex=%d Vit=%d Energy=%d Map=%d Pk=%d", 
; 4307 : 			 lpObj->AccountID, lpObj->Name, 
; 4308 : 			 lpObj->DbClass, lpObj->Level, 
; 4309 : 			 lpObj->LevelUpPoint, lpObj->Experience, 
; 4310 : 			 lpObj->Strength, lpObj->Dexterity, 
; 4311 : 			 lpObj->Vitality, lpObj->Energy, 
; 4312 : 			 lpObj->MapNumber, lpObj->m_PK_Level);
; 4313 : #endif
; 4314 : }

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
?gObjStatTextSave@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; gObjStatTextSave
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSetInventory1Pointer@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjSetInventory1Pointer@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjSetInventory1Pointer, COMDAT

; 7064 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7065 : 	lpObj->pInventory		= (CItem*)lpObj->Inventory1;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0000f	8b 91 6c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3180]
  00015	89 90 5c 0c 00
	00		 mov	 DWORD PTR [eax+3164], edx

; 7066 : 	lpObj->pInventoryMap	= lpObj->InventoryMap1;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00021	8b 91 70 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3184]
  00027	89 90 60 0c 00
	00		 mov	 DWORD PTR [eax+3168], edx

; 7067 : 	lpObj->pInventoryCount	= (char*)&lpObj->InventoryCount1;

  0002d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00030	05 74 0c 00 00	 add	 eax, 3188		; 00000c74H
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00038	89 81 64 0c 00
	00		 mov	 DWORD PTR [ecx+3172], eax

; 7068 : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?gObjSetInventory1Pointer@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjSetInventory1Pointer
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventorySearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z
_TEXT	SEGMENT
_n$ = -12						; size = 4
_count$ = -8						; size = 4
_s_num$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_serial$ = 12						; size = 4
?gObjInventorySearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z PROC ; gObjInventorySearchSerialNumber, COMDAT

; 16664: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 16665: 	DWORD s_num;
; 16666: 	int   count=0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 16667: 	int   n;
; 16668: 
; 16669: 	if(gItemSerialCheck==FALSE) return TRUE;

  00010	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gItemSerialCheck@@3HA, 0 ; gItemSerialCheck
  00017	75 0a		 jne	 SHORT $LN8@gObjInvent
  00019	b8 01 00 00 00	 mov	 eax, 1
  0001e	e9 27 01 00 00	 jmp	 $LN1@gObjInvent
$LN8@gObjInvent:

; 16670: 
; 16671: #if (TESTSERVER==1 && LOCALCONNECT==1)
; 16672: 	return TRUE;
; 16673: #endif
; 16674: 
; 16675: 	if( serial == 0 ) return TRUE;

  00023	83 7d 0c 00	 cmp	 DWORD PTR _serial$[ebp], 0
  00027	75 0a		 jne	 SHORT $LN9@gObjInvent
  00029	b8 01 00 00 00	 mov	 eax, 1
  0002e	e9 17 01 00 00	 jmp	 $LN1@gObjInvent
$LN9@gObjInvent:

; 16676: 
; 16677: #ifdef PERSONAL_SHOP_20040113		
; 16678: 	for( n=0; n<MAX_INVENTORY_EXTEND; n++)

  00033	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  0003a	eb 09		 jmp	 SHORT $LN4@gObjInvent
$LN2@gObjInvent:
  0003c	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  0003f	83 c0 01	 add	 eax, 1
  00042	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjInvent:
  00045	83 7d f4 6c	 cmp	 DWORD PTR _n$[ebp], 108	; 0000006cH
  00049	7d 31		 jge	 SHORT $LN3@gObjInvent

; 16679: #else
; 16680: 	for( n=0; n<MAX_INVENTORY; n++)
; 16681: #endif
; 16682: 	{
; 16683: 		s_num = lpObj->pInventory[n].GetNumber();

  0004b	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 168
  00052	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00055	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0005b	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  00060	89 45 fc	 mov	 DWORD PTR _s_num$[ebp], eax

; 16684: 
; 16685: 		if( s_num != 0 && s_num == serial )	// 0      

  00063	83 7d fc 00	 cmp	 DWORD PTR _s_num$[ebp], 0
  00067	74 11		 je	 SHORT $LN10@gObjInvent
  00069	8b 45 fc	 mov	 eax, DWORD PTR _s_num$[ebp]
  0006c	3b 45 0c	 cmp	 eax, DWORD PTR _serial$[ebp]
  0006f	75 09		 jne	 SHORT $LN10@gObjInvent

; 16686: 		{			
; 16687: 			count++;

  00071	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  00074	83 c0 01	 add	 eax, 1
  00077	89 45 f8	 mov	 DWORD PTR _count$[ebp], eax
$LN10@gObjInvent:

; 16688: 		}
; 16689: 	}

  0007a	eb c0		 jmp	 SHORT $LN2@gObjInvent
$LN3@gObjInvent:

; 16690: 	
; 16691: 	if( count <= 1 ) return TRUE;

  0007c	83 7d f8 01	 cmp	 DWORD PTR _count$[ebp], 1
  00080	7f 0a		 jg	 SHORT $LN11@gObjInvent
  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	e9 be 00 00 00	 jmp	 $LN1@gObjInvent
$LN11@gObjInvent:

; 16692: 	
; 16693: #ifdef PERSONAL_SHOP_20040113		
; 16694: 	for( n=0; n<MAX_INVENTORY_EXTEND; n++)

  0008c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00093	eb 09		 jmp	 SHORT $LN7@gObjInvent
$LN5@gObjInvent:
  00095	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00098	83 c0 01	 add	 eax, 1
  0009b	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
$LN7@gObjInvent:
  0009e	83 7d f4 6c	 cmp	 DWORD PTR _n$[ebp], 108	; 0000006cH
  000a2	0f 8d a0 00 00
	00		 jge	 $LN6@gObjInvent

; 16695: #else
; 16696: 	for( n=0; n<MAX_INVENTORY; n++)
; 16697: #endif
; 16698: 	{
; 16699: 		s_num = lpObj->pInventory[n].GetNumber();

  000a8	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 168
  000af	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b2	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  000b8	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  000bd	89 45 fc	 mov	 DWORD PTR _s_num$[ebp], eax

; 16700: 		if( s_num != 0 && s_num == serial )	// 0      

  000c0	83 7d fc 00	 cmp	 DWORD PTR _s_num$[ebp], 0
  000c4	74 7d		 je	 SHORT $LN12@gObjInvent
  000c6	8b 45 fc	 mov	 eax, DWORD PTR _s_num$[ebp]
  000c9	3b 45 0c	 cmp	 eax, DWORD PTR _serial$[ebp]
  000cc	75 75		 jne	 SHORT $LN12@gObjInvent

; 16701: 		{
; 16702: 			LogAddTD(lMsg.Get(529),lpObj->AccountID, lpObj->Name, lpObj->pInventory[n].GetName(), n, s_num);

  000ce	8b 45 fc	 mov	 eax, DWORD PTR _s_num$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  000d5	51		 push	 ecx
  000d6	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 168
  000dd	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e0	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  000e6	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000eb	50		 push	 eax
  000ec	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ef	83 c0 73	 add	 eax, 115		; 00000073H
  000f2	50		 push	 eax
  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000f6	83 c1 68	 add	 ecx, 104		; 00000068H
  000f9	51		 push	 ecx
  000fa	68 11 02 00 00	 push	 529			; 00000211H
  000ff	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0010a	50		 push	 eax
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00111	83 c4 18	 add	 esp, 24			; 00000018H

; 16703: //			LogAddC(LOGC_RED,lMsg.Get(529),lpObj->AccountID, lpObj->Name, lpObj->pInventory[n].GetName(), n, s_num);
; 16704: 			GCServerMsgStringSend(lMsg.Get(1102), lpObj->m_Index, 1);

  00114	6a 01		 push	 1
  00116	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00119	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011b	51		 push	 ecx
  0011c	68 4e 04 00 00	 push	 1102			; 0000044eH
  00121	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16705: 			gObjUserKill(lpObj->m_Index);

  00135	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00138	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013a	51		 push	 ecx
  0013b	e8 00 00 00 00	 call	 ?gObjUserKill@@YAXH@Z	; gObjUserKill
  00140	83 c4 04	 add	 esp, 4
$LN12@gObjInvent:

; 16706: 			//gObjInventoryDeleteItem(lpObj->m_Index, n);
; 16707: 			/*ItemMovePathSave(lpObj->AccountID, lpObj->Name, lpObj->pInventory[n].m_Level, lpObj->MapNumber, 
; 16708: 						lpObj->X, lpObj->Y, lpObj->pInventory[n].GetName(), 
; 16709: 						lpObj->pInventory[n].m_Option1, 
; 16710: 						lpObj->pInventory[n].m_Option2,
; 16711: 						lpObj->pInventory[n].m_Option3, 
; 16712: 						lpObj->pInventory[n].m_serial);*/
; 16713: 		}
; 16714: 	}

  00143	e9 4d ff ff ff	 jmp	 $LN5@gObjInvent
$LN6@gObjInvent:

; 16715: 	return FALSE;

  00148	33 c0		 xor	 eax, eax
$LN1@gObjInvent:

; 16716: }

  0014a	5f		 pop	 edi
  0014b	5e		 pop	 esi
  0014c	5b		 pop	 ebx
  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c3		 ret	 0
?gObjInventorySearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z ENDP ; gObjInventorySearchSerialNumber
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGetPkTime@@YAHPAVOBJECTSTRUCT@@AAH1@Z
_TEXT	SEGMENT
_pktime$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_hour$ = 12						; size = 4
_min$ = 16						; size = 4
?gObjGetPkTime@@YAHPAVOBJECTSTRUCT@@AAH1@Z PROC		; gObjGetPkTime, COMDAT

; 29452: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29453: 	int  pktime=0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pktime$[ebp], 0

; 29454: 
; 29455: 	if( lpObj->m_PK_Time > 0 )

  00010	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00013	83 b8 00 01 00
	00 00		 cmp	 DWORD PTR [eax+256], 0
  0001a	7e 14		 jle	 SHORT $LN2@gObjGetPkT

; 29456: 	{
; 29457: 		pktime = lpObj->m_PK_Time/60;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [eax+256]
  00025	99		 cdq
  00026	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0002b	f7 f9		 idiv	 ecx
  0002d	89 45 fc	 mov	 DWORD PTR _pktime$[ebp], eax
$LN2@gObjGetPkT:

; 29458: 	}
; 29459: #ifdef HERO_SYSTEM_MODIFY
; 29460: 	else {
; 29461: 		hour = 0;
; 29462: 		min = 0;
; 29463: 		return TRUE;
; 29464: 	}
; 29465: 
; 29466: 	if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT+1  )
; 29467: 	{
; 29468: 		hour = (PK_COUNT_1_TIME/60-pktime)/60;
; 29469: 		min  = (PK_COUNT_1_TIME/60-pktime)%60;
; 29470: 		return TRUE;	
; 29471: 	}
; 29472: 	else if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT+2  )
; 29473: 	{
; 29474: 		hour = (PK_COUNT_2_TIME/60-pktime)/60;
; 29475: 		min  = (PK_COUNT_2_TIME/60-pktime)%60;
; 29476: 		return TRUE;
; 29477: 	}
; 29478: 	else if( lpObj->m_PK_Level >= PK_LEVEL_DEFAULT+3  )
; 29479: 	{
; 29480: 		hour = (((PK_COUNT_3_TIME/60)+((lpObj->m_PK_Count-3)*60))-pktime)/60;
; 29481: 		min  = (((PK_COUNT_3_TIME/60)+((lpObj->m_PK_Count-3)*60))-pktime)%60;
; 29482: 		return TRUE;
; 29483: 	}
; 29484: #else
; 29485: 	if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT+1  )

  00030	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00033	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  0003a	83 f9 04	 cmp	 ecx, 4
  0003d	75 39		 jne	 SHORT $LN3@gObjGetPkT

; 29486: 	{
; 29487: 		hour = ((60*3)-pktime)/60;

  0003f	b8 b4 00 00 00	 mov	 eax, 180		; 000000b4H
  00044	2b 45 fc	 sub	 eax, DWORD PTR _pktime$[ebp]
  00047	99		 cdq
  00048	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0004d	f7 f9		 idiv	 ecx
  0004f	8b 55 0c	 mov	 edx, DWORD PTR _hour$[ebp]
  00052	89 02		 mov	 DWORD PTR [edx], eax

; 29488: 		min  = ((60*3)-pktime)%60;

  00054	b8 b4 00 00 00	 mov	 eax, 180		; 000000b4H
  00059	2b 45 fc	 sub	 eax, DWORD PTR _pktime$[ebp]
  0005c	99		 cdq
  0005d	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00062	f7 f9		 idiv	 ecx
  00064	8b 45 10	 mov	 eax, DWORD PTR _min$[ebp]
  00067	89 10		 mov	 DWORD PTR [eax], edx

; 29489: 		return TRUE;	

  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	e9 a9 00 00 00	 jmp	 $LN1@gObjGetPkT

; 29490: 	}

  00073	e9 a2 00 00 00	 jmp	 $LN4@gObjGetPkT
$LN3@gObjGetPkT:

; 29491: 	else if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT+2  )

  00078	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007b	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  00082	83 f9 05	 cmp	 ecx, 5
  00085	75 33		 jne	 SHORT $LN5@gObjGetPkT

; 29492: 	{
; 29493: 		hour = (((60*3)*2)-pktime)/60;

  00087	b8 68 01 00 00	 mov	 eax, 360		; 00000168H
  0008c	2b 45 fc	 sub	 eax, DWORD PTR _pktime$[ebp]
  0008f	99		 cdq
  00090	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00095	f7 f9		 idiv	 ecx
  00097	8b 55 0c	 mov	 edx, DWORD PTR _hour$[ebp]
  0009a	89 02		 mov	 DWORD PTR [edx], eax

; 29494: 		min  = (((60*3)*2)-pktime)%60;

  0009c	b8 68 01 00 00	 mov	 eax, 360		; 00000168H
  000a1	2b 45 fc	 sub	 eax, DWORD PTR _pktime$[ebp]
  000a4	99		 cdq
  000a5	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  000aa	f7 f9		 idiv	 ecx
  000ac	8b 45 10	 mov	 eax, DWORD PTR _min$[ebp]
  000af	89 10		 mov	 DWORD PTR [eax], edx

; 29495: 		return TRUE;

  000b1	b8 01 00 00 00	 mov	 eax, 1
  000b6	eb 64		 jmp	 SHORT $LN1@gObjGetPkT

; 29496: 	}

  000b8	eb 60		 jmp	 SHORT $LN4@gObjGetPkT
$LN5@gObjGetPkT:

; 29497: 	else if( lpObj->m_PK_Level >= PK_LEVEL_DEFAULT+3  )

  000ba	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bd	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  000c4	83 f9 06	 cmp	 ecx, 6
  000c7	7c 51		 jl	 SHORT $LN4@gObjGetPkT

; 29498: 	{
; 29499: 		hour = ((((60*3)*3)+((lpObj->m_PK_Count-3)*60))-pktime)/60;

  000c9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000cc	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  000d3	83 e9 03	 sub	 ecx, 3
  000d6	6b c1 3c	 imul	 eax, ecx, 60
  000d9	05 1c 02 00 00	 add	 eax, 540		; 0000021cH
  000de	2b 45 fc	 sub	 eax, DWORD PTR _pktime$[ebp]
  000e1	99		 cdq
  000e2	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  000e7	f7 f9		 idiv	 ecx
  000e9	8b 55 0c	 mov	 edx, DWORD PTR _hour$[ebp]
  000ec	89 02		 mov	 DWORD PTR [edx], eax

; 29500: 		min  = ((((60*3)*3)+((lpObj->m_PK_Count-3)*60))-pktime)%60;

  000ee	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f1	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  000f8	83 e9 03	 sub	 ecx, 3
  000fb	6b c1 3c	 imul	 eax, ecx, 60
  000fe	05 1c 02 00 00	 add	 eax, 540		; 0000021cH
  00103	2b 45 fc	 sub	 eax, DWORD PTR _pktime$[ebp]
  00106	99		 cdq
  00107	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0010c	f7 f9		 idiv	 ecx
  0010e	8b 45 10	 mov	 eax, DWORD PTR _min$[ebp]
  00111	89 10		 mov	 DWORD PTR [eax], edx

; 29501: 		return TRUE;

  00113	b8 01 00 00 00	 mov	 eax, 1
  00118	eb 02		 jmp	 SHORT $LN1@gObjGetPkT
$LN4@gObjGetPkT:

; 29502: 	}
; 29503: 
; 29504: 
; 29505: 
; 29506: #endif	
; 29507: 
; 29508: 	return FALSE;

  0011a	33 c0		 xor	 eax, eax
$LN1@gObjGetPkT:

; 29509: }

  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
?gObjGetPkTime@@YAHPAVOBJECTSTRUCT@@AAH1@Z ENDP		; gObjGetPkTime
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z
_TEXT	SEGMENT
_lpTguild$1 = -4					; size = 4
_lpGuild$ = 8						; size = 4
_lpTargetGuild$ = 12					; size = 4
?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z PROC	; gObjGuildWarEnd, COMDAT

; 29055: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29056: 	if( lpGuild == NULL || lpTargetGuild == NULL ) 

  00009	83 7d 08 00	 cmp	 DWORD PTR _lpGuild$[ebp], 0
  0000d	74 06		 je	 SHORT $LN3@gObjGuildW
  0000f	83 7d 0c 00	 cmp	 DWORD PTR _lpTargetGuild$[ebp], 0
  00013	75 02		 jne	 SHORT $LN2@gObjGuildW
$LN3@gObjGuildW:

; 29057: 	{
; 29058: 		//LogAddTD("error-L3 :    %s %d", __FILE__, __LINE__);
; 29059: 		return;

  00015	eb 6f		 jmp	 SHORT $LN1@gObjGuildW
$LN2@gObjGuildW:

; 29060: 	}
; 29061: 
; 29062: 	lpGuild->WarDeclareState = 0;

  00017	8b 45 08	 mov	 eax, DWORD PTR _lpGuild$[ebp]
  0001a	c6 80 90 05 00
	00 00		 mov	 BYTE PTR [eax+1424], 0

; 29063: 	lpGuild->WarState		 = 0;

  00021	8b 45 08	 mov	 eax, DWORD PTR _lpGuild$[ebp]
  00024	c6 80 91 05 00
	00 00		 mov	 BYTE PTR [eax+1425], 0

; 29064: 	
; 29065: 	//LogAddTD("    : %s", lpGuild->Name);
; 29066: 	
; 29067: 	if( lpTargetGuild != NULL )

  0002b	83 7d 0c 00	 cmp	 DWORD PTR _lpTargetGuild$[ebp], 0
  0002f	74 48		 je	 SHORT $LN4@gObjGuildW

; 29068: 	{
; 29069: 		lpTargetGuild->WarDeclareState	= 0;

  00031	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetGuild$[ebp]
  00034	c6 80 90 05 00
	00 00		 mov	 BYTE PTR [eax+1424], 0

; 29070: 		lpTargetGuild->WarState			= 0;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetGuild$[ebp]
  0003e	c6 80 91 05 00
	00 00		 mov	 BYTE PTR [eax+1425], 0

; 29071: 		//LogAdd("    : %s", lpTargetGuild->Name);
; 29072: 		LPGUILD_INFO	lpTguild;
; 29073: 		
; 29074: 		if (lpGuild->lpTargetGuildNode != NULL) {		//#BUGFIX_20040831		(MEMORY ACCESS VIOLATION , b4nfter)

  00045	8b 45 08	 mov	 eax, DWORD PTR _lpGuild$[ebp]
  00048	83 b8 8c 05 00
	00 00		 cmp	 DWORD PTR [eax+1420], 0
  0004f	74 26		 je	 SHORT $LN6@gObjGuildW

; 29075: 			lpTguild = lpGuild->lpTargetGuildNode;

  00051	8b 45 08	 mov	 eax, DWORD PTR _lpGuild$[ebp]
  00054	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  0005a	89 4d fc	 mov	 DWORD PTR _lpTguild$1[ebp], ecx

; 29076: 			lpGuild->lpTargetGuildNode = NULL;

  0005d	8b 45 08	 mov	 eax, DWORD PTR _lpGuild$[ebp]
  00060	c7 80 8c 05 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1420], 0

; 29077: 			lpTguild->lpTargetGuildNode = NULL;

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _lpTguild$1[ebp]
  0006d	c7 80 8c 05 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1420], 0
$LN6@gObjGuildW:

; 29078: 		}
; 29079: 	}

  00077	eb 0d		 jmp	 SHORT $LN1@gObjGuildW
$LN4@gObjGuildW:

; 29080: 	else 
; 29081: 	{
; 29082: 		lpGuild->lpTargetGuildNode = NULL;

  00079	8b 45 08	 mov	 eax, DWORD PTR _lpGuild$[ebp]
  0007c	c7 80 8c 05 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1420], 0
$LN1@gObjGuildW:

; 29083: 	}
; 29084: }

  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?gObjGuildWarEnd@@YAXPAU_GUILD_INFO_STRUCT@@0@Z ENDP	; gObjGuildWarEnd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGuildWarProc@@YAHPAU_GUILD_INFO_STRUCT@@0H@Z
_TEXT	SEGMENT
_szTemp$ = -272						; size = 256
_maxscore$ = -16					; size = 4
_n$ = -12						; size = 4
_totalscore$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
_lpGuild1$ = 8						; size = 4
_lpGuild2$ = 12						; size = 4
_score$ = 16						; size = 4
?gObjGuildWarProc@@YAHPAU_GUILD_INFO_STRUCT@@0H@Z PROC	; gObjGuildWarProc, COMDAT

; 29087: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 29088: 	if( lpGuild1 == NULL || lpGuild2 == NULL ) return 0;

  00016	83 7d 08 00	 cmp	 DWORD PTR _lpGuild1$[ebp], 0
  0001a	74 06		 je	 SHORT $LN9@gObjGuildW
  0001c	83 7d 0c 00	 cmp	 DWORD PTR _lpGuild2$[ebp], 0
  00020	75 07		 jne	 SHORT $LN8@gObjGuildW
$LN9@gObjGuildW:
  00022	33 c0		 xor	 eax, eax
  00024	e9 56 02 00 00	 jmp	 $LN1@gObjGuildW
$LN8@gObjGuildW:

; 29089: 
; 29090: 	int totalscore=g_GlobalConfig.m_iGuildWarScore;

  00029	a1 e8 00 00 00	 mov	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+232
  0002e	89 45 f8	 mov	 DWORD PTR _totalscore$[ebp], eax

; 29091: 	int n;
; 29092: 	int maxscore=20;

  00031	c7 45 f0 14 00
	00 00		 mov	 DWORD PTR _maxscore$[ebp], 20 ; 00000014H

; 29093: 	
; 29094: 	lpGuild1->PlayScore += score;

  00038	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  0003b	0f b6 88 95 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1429]
  00042	03 4d 10	 add	 ecx, DWORD PTR _score$[ebp]
  00045	8b 55 08	 mov	 edx, DWORD PTR _lpGuild1$[ebp]
  00048	88 8a 95 05 00
	00		 mov	 BYTE PTR [edx+1429], cl

; 29095: 
; 29096: 	char szTemp[256];
; 29097: 	wsprintf(szTemp, "%s ( %u ) VS %s ( %u )",lpGuild1->Name, (DWORD)lpGuild1->PlayScore, lpGuild2->Name, (DWORD)lpGuild2->PlayScore);

  0004e	8b 45 0c	 mov	 eax, DWORD PTR _lpGuild2$[ebp]
  00051	0f b6 88 95 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1429]
  00058	51		 push	 ecx
  00059	8b 55 0c	 mov	 edx, DWORD PTR _lpGuild2$[ebp]
  0005c	83 c2 04	 add	 edx, 4
  0005f	52		 push	 edx
  00060	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  00063	0f b6 88 95 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1429]
  0006a	51		 push	 ecx
  0006b	8b 55 08	 mov	 edx, DWORD PTR _lpGuild1$[ebp]
  0006e	83 c2 04	 add	 edx, 4
  00071	52		 push	 edx
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@NCOFCPCB@?$CFs?5?$CI?5?$CFu?5?$CJ?5VS?5?$CFs?5?$CI?5?$CFu?5?$CJ@
  00077	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0007d	50		 push	 eax
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00084	83 c4 18	 add	 esp, 24			; 00000018H

; 29098: 	LogAddTD(szTemp);

  00087	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0008d	50		 push	 eax
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00094	83 c4 04	 add	 esp, 4

; 29099: //	cManager.ManagerSendData(szTemp, 1);
; 29100: 
; 29101: 	if( lpGuild1->WarType == BTT_SOCCER )

  00097	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  0009a	0f b6 88 92 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1426]
  000a1	83 f9 01	 cmp	 ecx, 1
  000a4	75 32		 jne	 SHORT $LN10@gObjGuildW

; 29102: 	{
; 29103: 		SetBattleTeamScore(lpGuild1->BattleGroundIndex, lpGuild1->BattleTeamCode, lpGuild1->PlayScore);

  000a6	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  000a9	0f b6 88 95 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1429]
  000b0	51		 push	 ecx
  000b1	8b 55 08	 mov	 edx, DWORD PTR _lpGuild1$[ebp]
  000b4	0f b6 82 94 05
	00 00		 movzx	 eax, BYTE PTR [edx+1428]
  000bb	50		 push	 eax
  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _lpGuild1$[ebp]
  000bf	0f b6 91 93 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1427]
  000c6	52		 push	 edx
  000c7	e8 00 00 00 00	 call	 ?SetBattleTeamScore@@YAXHHH@Z ; SetBattleTeamScore
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 29104: #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 29105: 		maxscore = 100;
; 29106: #else
; 29107: 		maxscore = 100;

  000cf	c7 45 f0 64 00
	00 00		 mov	 DWORD PTR _maxscore$[ebp], 100 ; 00000064H

; 29108: #endif
; 29109: 		//maxscore = 4;
; 29110: 	}

  000d6	eb 07		 jmp	 SHORT $LN11@gObjGuildW
$LN10@gObjGuildW:

; 29111: 	else 
; 29112: 	{
; 29113: 		maxscore = 20;

  000d8	c7 45 f0 14 00
	00 00		 mov	 DWORD PTR _maxscore$[ebp], 20 ; 00000014H
$LN11@gObjGuildW:

; 29114: 		//maxscore = 4;
; 29115: 	}
; 29116: 
; 29117: 	cManager.BattleInfoSend(GetBattleTeamName(0, 0), GetBattleTeamScore(0, 0), GetBattleTeamName(0, 1), GetBattleTeamScore(0, 1));

  000df	6a 01		 push	 1
  000e1	6a 00		 push	 0
  000e3	e8 00 00 00 00	 call	 ?GetBattleTeamScore@@YAHHH@Z ; GetBattleTeamScore
  000e8	83 c4 08	 add	 esp, 8
  000eb	50		 push	 eax
  000ec	6a 01		 push	 1
  000ee	6a 00		 push	 0
  000f0	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  000f5	83 c4 08	 add	 esp, 8
  000f8	50		 push	 eax
  000f9	6a 00		 push	 0
  000fb	6a 00		 push	 0
  000fd	e8 00 00 00 00	 call	 ?GetBattleTeamScore@@YAHHH@Z ; GetBattleTeamScore
  00102	83 c4 08	 add	 esp, 8
  00105	50		 push	 eax
  00106	6a 00		 push	 0
  00108	6a 00		 push	 0
  0010a	e8 00 00 00 00	 call	 ?GetBattleTeamName@@YAPADHH@Z ; GetBattleTeamName
  0010f	83 c4 08	 add	 esp, 8
  00112	50		 push	 eax
  00113	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  00118	e8 00 00 00 00	 call	 ?BattleInfoSend@CGMMng@@QAEXPADE0E@Z ; CGMMng::BattleInfoSend

; 29118: 
; 29119: 	if( lpGuild1->PlayScore >= maxscore  ) //  

  0011d	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  00120	0f b6 88 95 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1429]
  00127	3b 4d f0	 cmp	 ecx, DWORD PTR _maxscore$[ebp]
  0012a	0f 8c a5 00 00
	00		 jl	 $LN12@gObjGuildW

; 29120: 	{
; 29121: 		if( lpGuild1->PlayScore > maxscore &&		// 20:0 ..

  00130	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  00133	0f b6 88 95 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1429]
  0013a	3b 4d f0	 cmp	 ecx, DWORD PTR _maxscore$[ebp]
  0013d	7e 19		 jle	 SHORT $LN14@gObjGuildW
  0013f	8b 45 0c	 mov	 eax, DWORD PTR _lpGuild2$[ebp]
  00142	0f b6 88 95 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1429]
  00149	85 c9		 test	 ecx, ecx
  0014b	75 0b		 jne	 SHORT $LN14@gObjGuildW

; 29122: 			lpGuild2->PlayScore == 0 )
; 29123: 		{
; 29124: 			totalscore += 2;

  0014d	8b 45 f8	 mov	 eax, DWORD PTR _totalscore$[ebp]
  00150	83 c0 02	 add	 eax, 2
  00153	89 45 f8	 mov	 DWORD PTR _totalscore$[ebp], eax

; 29125: 		}

  00156	eb 27		 jmp	 SHORT $LN15@gObjGuildW
$LN14@gObjGuildW:

; 29126: 		else if( lpGuild1->PlayScore > maxscore &&	// 20 10  

  00158	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  0015b	0f b6 88 95 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1429]
  00162	3b 4d f0	 cmp	 ecx, DWORD PTR _maxscore$[ebp]
  00165	7e 18		 jle	 SHORT $LN15@gObjGuildW
  00167	8b 45 0c	 mov	 eax, DWORD PTR _lpGuild2$[ebp]
  0016a	0f b6 88 95 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1429]
  00171	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00174	7f 09		 jg	 SHORT $LN15@gObjGuildW

; 29127: 			lpGuild2->PlayScore <= 10 )
; 29128: 		{
; 29129: 			totalscore += 1;

  00176	8b 45 f8	 mov	 eax, DWORD PTR _totalscore$[ebp]
  00179	83 c0 01	 add	 eax, 1
  0017c	89 45 f8	 mov	 DWORD PTR _totalscore$[ebp], eax
$LN15@gObjGuildW:

; 29130: 		}		
; 29131: 		lpGuild1->TotalScore += totalscore;

  0017f	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  00182	8b 88 98 05 00
	00		 mov	 ecx, DWORD PTR [eax+1432]
  00188	03 4d f8	 add	 ecx, DWORD PTR _totalscore$[ebp]
  0018b	8b 55 08	 mov	 edx, DWORD PTR _lpGuild1$[ebp]
  0018e	89 8a 98 05 00
	00		 mov	 DWORD PTR [edx+1432], ecx

; 29132: 
; 29133: 		DGGuildScoreUpdate(lpGuild1->Name, lpGuild1->TotalScore);

  00194	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  00197	8b 88 98 05 00
	00		 mov	 ecx, DWORD PTR [eax+1432]
  0019d	51		 push	 ecx
  0019e	8b 55 08	 mov	 edx, DWORD PTR _lpGuild1$[ebp]
  001a1	83 c2 04	 add	 edx, 4
  001a4	52		 push	 edx
  001a5	e8 00 00 00 00	 call	 ?DGGuildScoreUpdate@@YAXPADH@Z ; DGGuildScoreUpdate
  001aa	83 c4 08	 add	 esp, 8

; 29134: 		DGGuildScoreUpdate(lpGuild2->Name, lpGuild2->TotalScore);

  001ad	8b 45 0c	 mov	 eax, DWORD PTR _lpGuild2$[ebp]
  001b0	8b 88 98 05 00
	00		 mov	 ecx, DWORD PTR [eax+1432]
  001b6	51		 push	 ecx
  001b7	8b 55 0c	 mov	 edx, DWORD PTR _lpGuild2$[ebp]
  001ba	83 c2 04	 add	 edx, 4
  001bd	52		 push	 edx
  001be	e8 00 00 00 00	 call	 ?DGGuildScoreUpdate@@YAXPADH@Z ; DGGuildScoreUpdate
  001c3	83 c4 08	 add	 esp, 8

; 29135: 		return 1;

  001c6	b8 01 00 00 00	 mov	 eax, 1
  001cb	e9 af 00 00 00	 jmp	 $LN1@gObjGuildW

; 29136: 	}

  001d0	e9 a8 00 00 00	 jmp	 $LN13@gObjGuildW
$LN12@gObjGuildW:

; 29137: 	else
; 29138: 	{
; 29139: 		for( n=0; n<MAX_GUILD; n++)

  001d5	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  001dc	eb 09		 jmp	 SHORT $LN4@gObjGuildW
$LN2@gObjGuildW:
  001de	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  001e1	83 c0 01	 add	 eax, 1
  001e4	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjGuildW:
  001e7	83 7d f4 50	 cmp	 DWORD PTR _n$[ebp], 80	; 00000050H
  001eb	7d 3c		 jge	 SHORT $LN3@gObjGuildW

; 29140: 		{
; 29141: 			if( lpGuild1->Use[n] )

  001ed	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  001f0	03 45 f4	 add	 eax, DWORD PTR _n$[ebp]
  001f3	0f b6 88 40 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1088]
  001fa	85 c9		 test	 ecx, ecx
  001fc	74 29		 je	 SHORT $LN17@gObjGuildW

; 29142: 			{
; 29143: 				if( lpGuild1->Index[n] >=0 )

  001fe	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00201	8b 4d 08	 mov	 ecx, DWORD PTR _lpGuild1$[ebp]
  00204	0f bf 94 41 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+928]
  0020c	85 d2		 test	 edx, edx
  0020e	7c 17		 jl	 SHORT $LN17@gObjGuildW

; 29144: 				{
; 29145: 					GCGuildWarScore(lpGuild1->Index[n]);

  00210	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00213	8b 4d 08	 mov	 ecx, DWORD PTR _lpGuild1$[ebp]
  00216	0f bf 94 41 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+928]
  0021e	52		 push	 edx
  0021f	e8 00 00 00 00	 call	 ?GCGuildWarScore@@YAXH@Z ; GCGuildWarScore
  00224	83 c4 04	 add	 esp, 4
$LN17@gObjGuildW:

; 29146: 				}
; 29147: 			}
; 29148: 		}

  00227	eb b5		 jmp	 SHORT $LN2@gObjGuildW
$LN3@gObjGuildW:

; 29149: 		for( n=0; n<MAX_GUILD; n++)

  00229	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00230	eb 09		 jmp	 SHORT $LN7@gObjGuildW
$LN5@gObjGuildW:
  00232	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00235	83 c0 01	 add	 eax, 1
  00238	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
$LN7@gObjGuildW:
  0023b	83 7d f4 50	 cmp	 DWORD PTR _n$[ebp], 80	; 00000050H
  0023f	7d 3c		 jge	 SHORT $LN13@gObjGuildW

; 29150: 		{
; 29151: 			if( lpGuild2->Use[n] )

  00241	8b 45 0c	 mov	 eax, DWORD PTR _lpGuild2$[ebp]
  00244	03 45 f4	 add	 eax, DWORD PTR _n$[ebp]
  00247	0f b6 88 40 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1088]
  0024e	85 c9		 test	 ecx, ecx
  00250	74 29		 je	 SHORT $LN19@gObjGuildW

; 29152: 			{
; 29153: 				if( lpGuild2->Index[n] >=0 )

  00252	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00255	8b 4d 0c	 mov	 ecx, DWORD PTR _lpGuild2$[ebp]
  00258	0f bf 94 41 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+928]
  00260	85 d2		 test	 edx, edx
  00262	7c 17		 jl	 SHORT $LN19@gObjGuildW

; 29154: 				{
; 29155: 					GCGuildWarScore(lpGuild2->Index[n]);

  00264	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00267	8b 4d 0c	 mov	 ecx, DWORD PTR _lpGuild2$[ebp]
  0026a	0f bf 94 41 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+928]
  00272	52		 push	 edx
  00273	e8 00 00 00 00	 call	 ?GCGuildWarScore@@YAXH@Z ; GCGuildWarScore
  00278	83 c4 04	 add	 esp, 4
$LN19@gObjGuildW:

; 29156: 				}
; 29157: 			}
; 29158: 		}

  0027b	eb b5		 jmp	 SHORT $LN5@gObjGuildW
$LN13@gObjGuildW:

; 29159: 	}
; 29160: 	return 0;

  0027d	33 c0		 xor	 eax, eax
$LN1@gObjGuildW:

; 29161: }

  0027f	5f		 pop	 edi
  00280	5e		 pop	 esi
  00281	5b		 pop	 ebx
  00282	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00285	33 cd		 xor	 ecx, ebp
  00287	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028c	8b e5		 mov	 esp, ebp
  0028e	5d		 pop	 ebp
  0028f	c3		 ret	 0
?gObjGuildWarProc@@YAHPAU_GUILD_INFO_STRUCT@@0H@Z ENDP	; gObjGuildWarProc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z
_TEXT	SEGMENT
_n$ = -4						; size = 4
_lpGuild1$ = 8						; size = 4
_lpGuild2$ = 12						; size = 4
_Result1$ = 16						; size = 1
_Result2$ = 20						; size = 1
?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z PROC ; gObjGuildWarEndSend, COMDAT

; 29019: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 29020: 	if( lpGuild1 == NULL || lpGuild2 == NULL ) return;

  00009	83 7d 08 00	 cmp	 DWORD PTR _lpGuild1$[ebp], 0
  0000d	74 06		 je	 SHORT $LN9@gObjGuildW
  0000f	83 7d 0c 00	 cmp	 DWORD PTR _lpGuild2$[ebp], 0
  00013	75 05		 jne	 SHORT $LN8@gObjGuildW
$LN9@gObjGuildW:
  00015	e9 27 01 00 00	 jmp	 $LN1@gObjGuildW
$LN8@gObjGuildW:

; 29021: 
; 29022: 	if( lpGuild1->WarState != 1 || lpGuild2->WarState != 1 )

  0001a	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  0001d	0f b6 88 91 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1425]
  00024	83 f9 01	 cmp	 ecx, 1
  00027	75 0f		 jne	 SHORT $LN11@gObjGuildW
  00029	8b 45 0c	 mov	 eax, DWORD PTR _lpGuild2$[ebp]
  0002c	0f b6 88 91 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1425]
  00033	83 f9 01	 cmp	 ecx, 1
  00036	74 05		 je	 SHORT $LN10@gObjGuildW
$LN11@gObjGuildW:

; 29023: 	{
; 29024: 		return;

  00038	e9 04 01 00 00	 jmp	 $LN1@gObjGuildW
$LN10@gObjGuildW:

; 29025: 	}
; 29026: 			
; 29027: 	int n;
; 29028: 	for( n=0; n<MAX_GUILD; n++)

  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00044	eb 09		 jmp	 SHORT $LN4@gObjGuildW
$LN2@gObjGuildW:
  00046	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00049	83 c0 01	 add	 eax, 1
  0004c	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjGuildW:
  0004f	83 7d fc 50	 cmp	 DWORD PTR _n$[ebp], 80	; 00000050H
  00053	7d 6a		 jge	 SHORT $LN3@gObjGuildW

; 29029: 	{
; 29030: 		if( lpGuild1->Use[n] )

  00055	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  00058	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  0005b	0f b6 88 40 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1088]
  00062	85 c9		 test	 ecx, ecx
  00064	74 57		 je	 SHORT $LN12@gObjGuildW

; 29031: 		{
; 29032: 			if( lpGuild1->Index[n] >=0 )

  00066	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _lpGuild1$[ebp]
  0006c	0f bf 94 41 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+928]
  00074	85 d2		 test	 edx, edx
  00076	7c 45		 jl	 SHORT $LN12@gObjGuildW

; 29033: 			{
; 29034: 				gObj[lpGuild1->Index[n]].IsInBattleGround = 0;

  00078	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0007b	8b 4d 08	 mov	 ecx, DWORD PTR _lpGuild1$[ebp]
  0007e	0f bf 94 41 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+928]
  00086	69 c2 a0 1b 00
	00		 imul	 eax, edx, 7072
  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00092	c6 84 01 7a 0e
	00 00 00	 mov	 BYTE PTR [ecx+eax+3706], 0

; 29035: 				
; 29036: 				GCGuildWarEnd(lpGuild1->Index[n], Result1, lpGuild2->Name);

  0009a	8b 45 0c	 mov	 eax, DWORD PTR _lpGuild2$[ebp]
  0009d	83 c0 04	 add	 eax, 4
  000a0	50		 push	 eax
  000a1	0f b6 4d 10	 movzx	 ecx, BYTE PTR _Result1$[ebp]
  000a5	51		 push	 ecx
  000a6	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  000a9	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  000ac	0f bf 8c 50 a0
	03 00 00	 movsx	 ecx, WORD PTR [eax+edx*2+928]
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 ?GCGuildWarEnd@@YAXHEPAD@Z ; GCGuildWarEnd
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@gObjGuildW:

; 29037: 			}
; 29038: 		}
; 29039: 	}

  000bd	eb 87		 jmp	 SHORT $LN2@gObjGuildW
$LN3@gObjGuildW:

; 29040: 	for( n=0; n<MAX_GUILD; n++)

  000bf	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  000c6	eb 09		 jmp	 SHORT $LN7@gObjGuildW
$LN5@gObjGuildW:
  000c8	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000cb	83 c0 01	 add	 eax, 1
  000ce	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN7@gObjGuildW:
  000d1	83 7d fc 50	 cmp	 DWORD PTR _n$[ebp], 80	; 00000050H
  000d5	7d 6a		 jge	 SHORT $LN1@gObjGuildW

; 29041: 	{
; 29042: 		if( lpGuild2->Use[n] )

  000d7	8b 45 0c	 mov	 eax, DWORD PTR _lpGuild2$[ebp]
  000da	03 45 fc	 add	 eax, DWORD PTR _n$[ebp]
  000dd	0f b6 88 40 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1088]
  000e4	85 c9		 test	 ecx, ecx
  000e6	74 57		 je	 SHORT $LN14@gObjGuildW

; 29043: 		{
; 29044: 			if( lpGuild2->Index[n] >=0 )

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000eb	8b 4d 0c	 mov	 ecx, DWORD PTR _lpGuild2$[ebp]
  000ee	0f bf 94 41 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+928]
  000f6	85 d2		 test	 edx, edx
  000f8	7c 45		 jl	 SHORT $LN14@gObjGuildW

; 29045: 			{
; 29046: 				gObj[lpGuild2->Index[n]].IsInBattleGround = 0;

  000fa	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000fd	8b 4d 0c	 mov	 ecx, DWORD PTR _lpGuild2$[ebp]
  00100	0f bf 94 41 a0
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax*2+928]
  00108	69 c2 a0 1b 00
	00		 imul	 eax, edx, 7072
  0010e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00114	c6 84 01 7a 0e
	00 00 00	 mov	 BYTE PTR [ecx+eax+3706], 0

; 29047: 
; 29048: 				GCGuildWarEnd(lpGuild2->Index[n], Result2, lpGuild1->Name);

  0011c	8b 45 08	 mov	 eax, DWORD PTR _lpGuild1$[ebp]
  0011f	83 c0 04	 add	 eax, 4
  00122	50		 push	 eax
  00123	0f b6 4d 14	 movzx	 ecx, BYTE PTR _Result2$[ebp]
  00127	51		 push	 ecx
  00128	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  0012b	8b 45 0c	 mov	 eax, DWORD PTR _lpGuild2$[ebp]
  0012e	0f bf 8c 50 a0
	03 00 00	 movsx	 ecx, WORD PTR [eax+edx*2+928]
  00136	51		 push	 ecx
  00137	e8 00 00 00 00	 call	 ?GCGuildWarEnd@@YAXHEPAD@Z ; GCGuildWarEnd
  0013c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@gObjGuildW:

; 29049: 			}
; 29050: 		}
; 29051: 	}

  0013f	eb 87		 jmp	 SHORT $LN5@gObjGuildW
$LN1@gObjGuildW:

; 29052: }

  00141	5f		 pop	 edi
  00142	5e		 pop	 esi
  00143	5b		 pop	 ebx
  00144	8b e5		 mov	 esp, ebp
  00146	5d		 pop	 ebp
  00147	c3		 ret	 0
?gObjGuildWarEndSend@@YAXPAU_GUILD_INFO_STRUCT@@0EE@Z ENDP ; gObjGuildWarEndSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGuildWarEndSend@@YAXPAVOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_n$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_Result1$ = 12						; size = 1
_Result2$ = 16						; size = 1
?gObjGuildWarEndSend@@YAXPAVOBJECTSTRUCT@@EE@Z PROC	; gObjGuildWarEndSend, COMDAT

; 28947: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 28948: 	if( lpObj == NULL ) 

  00009	83 7d 08 00	 cmp	 DWORD PTR _lpObj$[ebp], 0
  0000d	75 21		 jne	 SHORT $LN8@gObjGuildW

; 28949: 	{
; 28950: 		LogAdd("error-L3 : %s %d", __FILE__, __LINE__);

  0000f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjGuildWarEndSend@@YAXPAVOBJECTSTRUCT@@EE@Z@4JA
  00014	83 c0 03	 add	 eax, 3
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd@
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28951: 		return;

  0002b	e9 8c 02 00 00	 jmp	 $LN1@gObjGuildW
$LN8@gObjGuildW:

; 28952: 	}
; 28953: 
; 28954: 	if( lpObj->lpGuild == NULL ) 

  00030	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00033	83 b8 94 02 00
	00 00		 cmp	 DWORD PTR [eax+660], 0
  0003a	75 21		 jne	 SHORT $LN9@gObjGuildW

; 28955: 	{
; 28956: 		LogAdd("error-L3 : %s %d", __FILE__, __LINE__);

  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjGuildWarEndSend@@YAXPAVOBJECTSTRUCT@@EE@Z@4JA
  00041	83 c0 09	 add	 eax, 9
  00044	50		 push	 eax
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd@
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28957: 		return;

  00058	e9 5f 02 00 00	 jmp	 $LN1@gObjGuildW
$LN9@gObjGuildW:

; 28958: 	}
; 28959: 
; 28960: 	if( lpObj->lpGuild->WarState != 1 )

  0005d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00060	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00066	0f b6 91 91 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1425]
  0006d	83 fa 01	 cmp	 edx, 1
  00070	74 21		 je	 SHORT $LN10@gObjGuildW

; 28961: 	{
; 28962: 		LogAdd("error-L3 : %s %d", __FILE__, __LINE__);

  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjGuildWarEndSend@@YAXPAVOBJECTSTRUCT@@EE@Z@4JA
  00077	83 c0 0f	 add	 eax, 15			; 0000000fH
  0007a	50		 push	 eax
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd@
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28963: 		return;

  0008e	e9 29 02 00 00	 jmp	 $LN1@gObjGuildW
$LN10@gObjGuildW:

; 28964: 	}
; 28965: 	
; 28966: 	if (lpObj->lpGuild->lpTargetGuildNode == NULL)			//#BUGFIX_20040831		(MEMORY ACCESS VIOLATION , b4nfter)

  00093	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00096	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  0009c	83 b9 8c 05 00
	00 00		 cmp	 DWORD PTR [ecx+1420], 0
  000a3	75 21		 jne	 SHORT $LN11@gObjGuildW

; 28967: 	{
; 28968: 		LogAdd("error-L3 : %s %d", __FILE__, __LINE__);

  000a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjGuildWarEndSend@@YAXPAVOBJECTSTRUCT@@EE@Z@4JA
  000aa	83 c0 15	 add	 eax, 21			; 00000015H
  000ad	50		 push	 eax
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd@
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28969: 		return;

  000c1	e9 f6 01 00 00	 jmp	 $LN1@gObjGuildW
$LN11@gObjGuildW:

; 28970: 	}
; 28971: 
; 28972: 		
; 28973: 	//    ..
; 28974: 	if( Result1 == 0x01 )

  000c6	0f b6 45 0c	 movzx	 eax, BYTE PTR _Result1$[ebp]
  000ca	83 f8 01	 cmp	 eax, 1
  000cd	75 24		 jne	 SHORT $LN12@gObjGuildW

; 28975: 	{		
; 28976: 		gObjGuildWarItemGive(lpObj->lpGuild, lpObj->lpGuild->lpTargetGuildNode);

  000cf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d2	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  000d8	8b 91 8c 05 00
	00		 mov	 edx, DWORD PTR [ecx+1420]
  000de	52		 push	 edx
  000df	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e2	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 ?gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarItemGive
  000ee	83 c4 08	 add	 esp, 8

; 28977: 	}

  000f1	eb 58		 jmp	 SHORT $LN13@gObjGuildW
$LN12@gObjGuildW:

; 28978: 	else if( Result1 == 0x03 )

  000f3	0f b6 45 0c	 movzx	 eax, BYTE PTR _Result1$[ebp]
  000f7	83 f8 03	 cmp	 eax, 3
  000fa	75 24		 jne	 SHORT $LN14@gObjGuildW

; 28979: 	{
; 28980: 		gObjGuildWarItemGive(lpObj->lpGuild->lpTargetGuildNode, lpObj->lpGuild);

  000fc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ff	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00105	51		 push	 ecx
  00106	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00109	8b 82 94 02 00
	00		 mov	 eax, DWORD PTR [edx+660]
  0010f	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  00115	51		 push	 ecx
  00116	e8 00 00 00 00	 call	 ?gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarItemGive
  0011b	83 c4 08	 add	 esp, 8

; 28981: 	}

  0011e	eb 2b		 jmp	 SHORT $LN13@gObjGuildW
$LN14@gObjGuildW:

; 28982: 	else if( Result1 == 0x01 )

  00120	0f b6 45 0c	 movzx	 eax, BYTE PTR _Result1$[ebp]
  00124	83 f8 01	 cmp	 eax, 1
  00127	75 22		 jne	 SHORT $LN13@gObjGuildW

; 28983: 	{		
; 28984: 		gObjGuildWarItemGive(lpObj->lpGuild->lpTargetGuildNode, lpObj->lpGuild);

  00129	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012c	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00132	51		 push	 ecx
  00133	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00136	8b 82 94 02 00
	00		 mov	 eax, DWORD PTR [edx+660]
  0013c	8b 88 8c 05 00
	00		 mov	 ecx, DWORD PTR [eax+1420]
  00142	51		 push	 ecx
  00143	e8 00 00 00 00	 call	 ?gObjGuildWarItemGive@@YAHPAU_GUILD_INFO_STRUCT@@0@Z ; gObjGuildWarItemGive
  00148	83 c4 08	 add	 esp, 8
$LN13@gObjGuildW:

; 28985: 	}
; 28986: 
; 28987: 	int n;
; 28988: 	for( n=0; n<MAX_GUILD; n++)

  0014b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00152	eb 09		 jmp	 SHORT $LN4@gObjGuildW
$LN2@gObjGuildW:
  00154	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00157	83 c0 01	 add	 eax, 1
  0015a	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjGuildW:
  0015d	83 7d fc 50	 cmp	 DWORD PTR _n$[ebp], 80	; 00000050H
  00161	0f 8d 92 00 00
	00		 jge	 $LN3@gObjGuildW

; 28989: 	{
; 28990: 		if( lpObj->lpGuild->Use[n] )

  00167	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016a	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00170	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  00173	0f b6 84 11 40
	04 00 00	 movzx	 eax, BYTE PTR [ecx+edx+1088]
  0017b	85 c0		 test	 eax, eax
  0017d	74 75		 je	 SHORT $LN17@gObjGuildW

; 28991: 		{
; 28992: 			if( lpObj->lpGuild->Index[n] >=0 )

  0017f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00182	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00188	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  0018b	0f bf 84 51 a0
	03 00 00	 movsx	 eax, WORD PTR [ecx+edx*2+928]
  00193	85 c0		 test	 eax, eax
  00195	7c 5d		 jl	 SHORT $LN17@gObjGuildW

; 28993: 			{
; 28994: 				gObj[lpObj->lpGuild->Index[n]].IsInBattleGround = 0;

  00197	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019a	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  001a0	8b 55 fc	 mov	 edx, DWORD PTR _n$[ebp]
  001a3	0f bf 84 51 a0
	03 00 00	 movsx	 eax, WORD PTR [ecx+edx*2+928]
  001ab	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  001b1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b7	c6 84 0a 7a 0e
	00 00 00	 mov	 BYTE PTR [edx+ecx+3706], 0

; 28995: 				GCGuildWarEnd(lpObj->lpGuild->Index[n], Result1, lpObj->lpGuild->lpTargetGuildNode->Name);

  001bf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c2	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  001c8	8b 91 8c 05 00
	00		 mov	 edx, DWORD PTR [ecx+1420]
  001ce	83 c2 04	 add	 edx, 4
  001d1	52		 push	 edx
  001d2	0f b6 45 0c	 movzx	 eax, BYTE PTR _Result1$[ebp]
  001d6	50		 push	 eax
  001d7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001da	8b 91 94 02 00
	00		 mov	 edx, DWORD PTR [ecx+660]
  001e0	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  001e3	0f bf 8c 42 a0
	03 00 00	 movsx	 ecx, WORD PTR [edx+eax*2+928]
  001eb	51		 push	 ecx
  001ec	e8 00 00 00 00	 call	 ?GCGuildWarEnd@@YAXHEPAD@Z ; GCGuildWarEnd
  001f1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN17@gObjGuildW:

; 28996: 				//LogAdd("   : %s", lpObj->lpGuild->Names[n]);
; 28997: 			}
; 28998: 		}
; 28999: 	}

  001f4	e9 5b ff ff ff	 jmp	 $LN2@gObjGuildW
$LN3@gObjGuildW:

; 29000: 	for( n=0; n<MAX_GUILD; n++)

  001f9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00200	eb 09		 jmp	 SHORT $LN7@gObjGuildW
$LN5@gObjGuildW:
  00202	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00205	83 c0 01	 add	 eax, 1
  00208	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN7@gObjGuildW:
  0020b	83 7d fc 50	 cmp	 DWORD PTR _n$[ebp], 80	; 00000050H
  0020f	0f 8d a7 00 00
	00		 jge	 $LN1@gObjGuildW

; 29001: 	{
; 29002: 		if( lpObj->lpGuild->lpTargetGuildNode->Use[n] )

  00215	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00218	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  0021e	8b 91 8c 05 00
	00		 mov	 edx, DWORD PTR [ecx+1420]
  00224	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00227	0f b6 8c 02 40
	04 00 00	 movzx	 ecx, BYTE PTR [edx+eax+1088]
  0022f	85 c9		 test	 ecx, ecx
  00231	0f 84 80 00 00
	00		 je	 $LN19@gObjGuildW

; 29003: 		{
; 29004: 			
; 29005: 			if( lpObj->lpGuild->lpTargetGuildNode->Index[n] >=0 )

  00237	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0023a	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00240	8b 91 8c 05 00
	00		 mov	 edx, DWORD PTR [ecx+1420]
  00246	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00249	0f bf 8c 42 a0
	03 00 00	 movsx	 ecx, WORD PTR [edx+eax*2+928]
  00251	85 c9		 test	 ecx, ecx
  00253	7c 62		 jl	 SHORT $LN19@gObjGuildW

; 29006: 			{
; 29007: 				gObj[lpObj->lpGuild->lpTargetGuildNode->Index[n]].IsInBattleGround = 0;

  00255	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00258	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  0025e	8b 91 8c 05 00
	00		 mov	 edx, DWORD PTR [ecx+1420]
  00264	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00267	0f bf 8c 42 a0
	03 00 00	 movsx	 ecx, WORD PTR [edx+eax*2+928]
  0026f	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  00275	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0027a	c6 84 10 7a 0e
	00 00 00	 mov	 BYTE PTR [eax+edx+3706], 0

; 29008: 
; 29009: 				GCGuildWarEnd(lpObj->lpGuild->lpTargetGuildNode->Index[n], Result2, lpObj->lpGuild->Name);

  00282	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00285	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  0028b	83 c1 04	 add	 ecx, 4
  0028e	51		 push	 ecx
  0028f	0f b6 55 10	 movzx	 edx, BYTE PTR _Result2$[ebp]
  00293	52		 push	 edx
  00294	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00297	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  0029d	8b 91 8c 05 00
	00		 mov	 edx, DWORD PTR [ecx+1420]
  002a3	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  002a6	0f bf 8c 42 a0
	03 00 00	 movsx	 ecx, WORD PTR [edx+eax*2+928]
  002ae	51		 push	 ecx
  002af	e8 00 00 00 00	 call	 ?GCGuildWarEnd@@YAXHEPAD@Z ; GCGuildWarEnd
  002b4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@gObjGuildW:

; 29010: 				//LogAdd("   : %s", lpObj->lpGuild->lpTargetGuildNode->Names[n]);
; 29011: 			}
; 29012: 		}
; 29013: 	}	

  002b7	e9 46 ff ff ff	 jmp	 $LN5@gObjGuildW
$LN1@gObjGuildW:

; 29014: 	
; 29015: }

  002bc	5f		 pop	 edi
  002bd	5e		 pop	 esi
  002be	5b		 pop	 ebx
  002bf	8b e5		 mov	 esp, ebp
  002c1	5d		 pop	 ebp
  002c2	c3		 ret	 0
?gObjGuildWarEndSend@@YAXPAVOBJECTSTRUCT@@EE@Z ENDP	; gObjGuildWarEndSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGuildMasterCapacityTest@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjGuildMasterCapacityTest@@YAHPAVOBJECTSTRUCT@@@Z PROC ; gObjGuildMasterCapacityTest, COMDAT

; 8608 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 8609 : 	if( lpObj->Level < gGuildCreateLevel )

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00013	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gGuildCreateLevel@@3HA ; gGuildCreateLevel
  00019	7d 04		 jge	 SHORT $LN2@gObjGuildM

; 8610 : 	{
; 8611 : 		return 0;

  0001b	33 c0		 xor	 eax, eax
  0001d	eb 05		 jmp	 SHORT $LN1@gObjGuildM
$LN2@gObjGuildM:

; 8612 : 	}
; 8613 : 	/*
; 8614 : 	int itype;
; 8615 : 	if( (lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].m_Level < 7) &&
; 8616 : 		(lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].m_Level < 7) ) return FALSE;
; 8617 : 	if( lpObj->pInventory[EQUIPMENT_HELM].m_Level < 7 ) return FALSE;
; 8618 : 	if( lpObj->pInventory[EQUIPMENT_ARMOR].m_Level < 7 ) return FALSE;
; 8619 : 	if( lpObj->pInventory[EQUIPMENT_PANTS].m_Level < 7 ) return FALSE;
; 8620 : 	if( lpObj->pInventory[EQUIPMENT_GLOVES].m_Level < 7 ) return FALSE;
; 8621 : 	if( lpObj->pInventory[EQUIPMENT_BOOTS].m_Level < 7 ) return FALSE;
; 8622 : 	*/
; 8623 : 	return 1;

  0001f	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjGuildM:

; 8624 : }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?gObjGuildMasterCapacityTest@@YAHPAVOBJECTSTRUCT@@@Z ENDP ; gObjGuildMasterCapacityTest
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCheckTileArea@@YAHHHHH@Z
_TEXT	SEGMENT
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_dis$ = 20						; size = 4
?gObjCheckTileArea@@YAHHHHH@Z PROC			; gObjCheckTileArea, COMDAT

; 7038 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7039 : 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 7040 : 			//    ..
; 7041 : 
; 7042 : 	if( (x < (lpObj->X-dis)) || (x > (lpObj->X+dis)) ||
; 7043 : 		(y < (lpObj->Y-dis)) || (y > (lpObj->Y+dis)) )

  00019	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00023	2b 4d 14	 sub	 ecx, DWORD PTR _dis$[ebp]
  00026	39 4d 0c	 cmp	 DWORD PTR _x$[ebp], ecx
  00029	7c 36		 jl	 SHORT $LN3@gObjCheckT
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002e	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00035	03 4d 14	 add	 ecx, DWORD PTR _dis$[ebp]
  00038	39 4d 0c	 cmp	 DWORD PTR _x$[ebp], ecx
  0003b	7f 24		 jg	 SHORT $LN3@gObjCheckT
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00040	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00047	2b 4d 14	 sub	 ecx, DWORD PTR _dis$[ebp]
  0004a	39 4d 10	 cmp	 DWORD PTR _y$[ebp], ecx
  0004d	7c 12		 jl	 SHORT $LN3@gObjCheckT
  0004f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00052	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00059	03 4d 14	 add	 ecx, DWORD PTR _dis$[ebp]
  0005c	39 4d 10	 cmp	 DWORD PTR _y$[ebp], ecx
  0005f	7e 04		 jle	 SHORT $LN2@gObjCheckT
$LN3@gObjCheckT:

; 7044 : 	{
; 7045 : 		return FALSE;

  00061	33 c0		 xor	 eax, eax
  00063	eb 05		 jmp	 SHORT $LN1@gObjCheckT
$LN2@gObjCheckT:

; 7046 : 	}
; 7047 : 	return TRUE;

  00065	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjCheckT:

; 7048 : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?gObjCheckTileArea@@YAHHHHH@Z ENDP			; gObjCheckTileArea
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjPositionCheck@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iy$ = -8						; size = 4
_ix$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjPositionCheck@@YAHPAVOBJECTSTRUCT@@@Z PROC		; gObjPositionCheck, COMDAT

; 7026 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7027 : 	int ix = lpObj->m_OldX-lpObj->TX;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f bf 88 1c 01
	00 00		 movsx	 ecx, WORD PTR [eax+284]
  00013	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00016	0f bf 82 20 01
	00 00		 movsx	 eax, WORD PTR [edx+288]
  0001d	2b c8		 sub	 ecx, eax
  0001f	89 4d fc	 mov	 DWORD PTR _ix$[ebp], ecx

; 7028 : 	int iy = lpObj->m_OldY-lpObj->TY;

  00022	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00025	0f bf 88 1e 01
	00 00		 movsx	 ecx, WORD PTR [eax+286]
  0002c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0002f	0f bf 82 22 01
	00 00		 movsx	 eax, WORD PTR [edx+290]
  00036	2b c8		 sub	 ecx, eax
  00038	89 4d f8	 mov	 DWORD PTR _iy$[ebp], ecx

; 7029 : 		
; 7030 : 	if( ix <= -15 || ix >= 15 ) return FALSE;

  0003b	83 7d fc f1	 cmp	 DWORD PTR _ix$[ebp], -15 ; fffffff1H
  0003f	7e 06		 jle	 SHORT $LN3@gObjPositi
  00041	83 7d fc 0f	 cmp	 DWORD PTR _ix$[ebp], 15	; 0000000fH
  00045	7c 04		 jl	 SHORT $LN2@gObjPositi
$LN3@gObjPositi:
  00047	33 c0		 xor	 eax, eax
  00049	eb 15		 jmp	 SHORT $LN1@gObjPositi
$LN2@gObjPositi:

; 7031 : 	if( iy <= -15 || iy >= 15 ) return FALSE;

  0004b	83 7d f8 f1	 cmp	 DWORD PTR _iy$[ebp], -15 ; fffffff1H
  0004f	7e 06		 jle	 SHORT $LN5@gObjPositi
  00051	83 7d f8 0f	 cmp	 DWORD PTR _iy$[ebp], 15	; 0000000fH
  00055	7c 04		 jl	 SHORT $LN4@gObjPositi
$LN5@gObjPositi:
  00057	33 c0		 xor	 eax, eax
  00059	eb 05		 jmp	 SHORT $LN1@gObjPositi
$LN4@gObjPositi:

; 7032 : 
; 7033 : 	return TRUE;

  0005b	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjPositi:

; 7034 : }

  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?gObjPositionCheck@@YAHPAVOBJECTSTRUCT@@@Z ENDP		; gObjPositionCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCheckViewport@@YAHHHH@Z
_TEXT	SEGMENT
_d$1 = -16						; size = 4
_i$2 = -12						; size = 4
_j$ = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?gObjCheckViewport@@YAHHHH@Z PROC			; gObjCheckViewport, COMDAT

; 20514: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 20515: 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 20516: 			//    ..
; 20517: 
; 20518: //#ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 20519: 	//return TRUE;
; 20520: //#endif
; 20521: 
; 20522: #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 20523: 	if( (x < (lpObj->X-30)) || (x > (lpObj->X+30)) ||
; 20524: 		(y < (lpObj->Y-30)) || (y > (lpObj->Y+30)) )
; 20525: #else
; 20526: 	if( (x < (lpObj->X-15)) || (x > (lpObj->X+15)) ||
; 20527: 		(y < (lpObj->Y-15)) || (y > (lpObj->Y+15)) )

  00019	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00023	83 e9 0f	 sub	 ecx, 15			; 0000000fH
  00026	39 4d 0c	 cmp	 DWORD PTR _x$[ebp], ecx
  00029	7c 36		 jl	 SHORT $LN6@gObjCheckV
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002e	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00035	83 c1 0f	 add	 ecx, 15			; 0000000fH
  00038	39 4d 0c	 cmp	 DWORD PTR _x$[ebp], ecx
  0003b	7f 24		 jg	 SHORT $LN6@gObjCheckV
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00040	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00047	83 e9 0f	 sub	 ecx, 15			; 0000000fH
  0004a	39 4d 10	 cmp	 DWORD PTR _y$[ebp], ecx
  0004d	7c 12		 jl	 SHORT $LN6@gObjCheckV
  0004f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00052	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00059	83 c1 0f	 add	 ecx, 15			; 0000000fH
  0005c	39 4d 10	 cmp	 DWORD PTR _y$[ebp], ecx
  0005f	7e 04		 jle	 SHORT $LN5@gObjCheckV
$LN6@gObjCheckV:

; 20528: #endif
; 20529: 	{
; 20530: 		return FALSE;

  00061	33 c0		 xor	 eax, eax
  00063	eb 7d		 jmp	 SHORT $LN1@gObjCheckV
$LN5@gObjCheckV:

; 20531: 	}
; 20532: 	
; 20533: 	int j = 3;

  00065	c7 45 f8 03 00
	00 00		 mov	 DWORD PTR _j$[ebp], 3

; 20534: 	for(int i=0;i<4;j=i,i++)

  0006c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00073	eb 0f		 jmp	 SHORT $LN4@gObjCheckV
$LN2@gObjCheckV:
  00075	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  00078	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR _i$2[ebp]
  0007e	83 c1 01	 add	 ecx, 1
  00081	89 4d f4	 mov	 DWORD PTR _i$2[ebp], ecx
$LN4@gObjCheckV:
  00084	83 7d f4 04	 cmp	 DWORD PTR _i$2[ebp], 4
  00088	7d 53		 jge	 SHORT $LN3@gObjCheckV

; 20535: 	{
; 20536: 		int d = (lpObj->FrustrumX[i]-x) * (lpObj->FrustrumY[j]-y) -

  0008a	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  0008d	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00090	8b 94 81 44 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+836]
  00097	2b 55 0c	 sub	 edx, DWORD PTR _x$[ebp]
  0009a	8b 45 f8	 mov	 eax, DWORD PTR _j$[ebp]
  0009d	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a0	8b 84 81 54 03
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+852]
  000a7	2b 45 10	 sub	 eax, DWORD PTR _y$[ebp]
  000aa	0f af d0	 imul	 edx, eax
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR _j$[ebp]
  000b0	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b3	8b 8c 88 44 03
	00 00		 mov	 ecx, DWORD PTR [eax+ecx*4+836]
  000ba	2b 4d 0c	 sub	 ecx, DWORD PTR _x$[ebp]
  000bd	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  000c0	8b 75 fc	 mov	 esi, DWORD PTR _lpObj$[ebp]
  000c3	8b 84 86 54 03
	00 00		 mov	 eax, DWORD PTR [esi+eax*4+852]
  000ca	2b 45 10	 sub	 eax, DWORD PTR _y$[ebp]
  000cd	0f af c8	 imul	 ecx, eax
  000d0	2b d1		 sub	 edx, ecx
  000d2	89 55 f0	 mov	 DWORD PTR _d$1[ebp], edx

; 20537: 			(lpObj->FrustrumX[j]-x) * (lpObj->FrustrumY[i]-y);
; 20538: 		if(d < 0) return FALSE;

  000d5	79 04		 jns	 SHORT $LN7@gObjCheckV
  000d7	33 c0		 xor	 eax, eax
  000d9	eb 07		 jmp	 SHORT $LN1@gObjCheckV
$LN7@gObjCheckV:

; 20539: 	}

  000db	eb 98		 jmp	 SHORT $LN2@gObjCheckV
$LN3@gObjCheckV:

; 20540: 		
; 20541: 	return TRUE;

  000dd	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjCheckV:

; 20542: }

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
?gObjCheckViewport@@YAHHHH@Z ENDP			; gObjCheckViewport
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCloseSet@@YAXHH@Z
_TEXT	SEGMENT
tv79 = -76						; size = 4
tv163 = -72						; size = 4
tv80 = -72						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_Flag$ = 12						; size = 4
?gObjCloseSet@@YAXHH@Z PROC				; gObjCloseSet, COMDAT

; 1278 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1279 : 	if( aIndex < 0 || aIndex > MAX_OBJECT-1 ) return ;

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN5@gObjCloseS
  0000f	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00016	7e 05		 jle	 SHORT $LN4@gObjCloseS
$LN5@gObjCloseS:
  00018	e9 26 02 00 00	 jmp	 $LN1@gObjCloseS
$LN4@gObjCloseS:

; 1280 : 	LPOBJECTSTRUCT	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  0001d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00024	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002a	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 1281 : 	
; 1282 : 	if( lpObj->CloseCount > 0 ) return;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00030	0f be 48 0a	 movsx	 ecx, BYTE PTR [eax+10]
  00034	85 c9		 test	 ecx, ecx
  00036	7e 05		 jle	 SHORT $LN6@gObjCloseS
  00038	e9 06 02 00 00	 jmp	 $LN1@gObjCloseS
$LN6@gObjCloseS:

; 1283 : 
; 1284 : 	if( lpObj->Connected == CSS_GAMEPLAYING )

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00040	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00044	0f 85 da 01 00
	00		 jne	 $LN7@gObjCloseS

; 1285 : 	{
; 1286 : #ifdef FOR_BLOODCASTLE
; 1287 : 		if (CHECK_BLOODCASTLE(lpObj->MapNumber)) {				//      .

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004d	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00054	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00057	7d 09		 jge	 SHORT $LN19@gObjCloseS
  00059	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  00060	eb 25		 jmp	 SHORT $LN20@gObjCloseS
$LN19@gObjCloseS:
  00062	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00065	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0006c	83 f8 11	 cmp	 eax, 17			; 00000011H
  0006f	7e 09		 jle	 SHORT $LN17@gObjCloseS
  00071	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  00078	eb 07		 jmp	 SHORT $LN18@gObjCloseS
$LN17@gObjCloseS:
  0007a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
$LN18@gObjCloseS:
  00081	8b 4d b4	 mov	 ecx, DWORD PTR tv79[ebp]
  00084	89 4d b8	 mov	 DWORD PTR tv80[ebp], ecx
$LN20@gObjCloseS:
  00087	83 7d b8 00	 cmp	 DWORD PTR tv80[ebp], 0
  0008b	74 0e		 je	 SHORT $LN8@gObjCloseS

; 1288 : 			g_BloodCastle.SearchUserDropQuestItem(aIndex);

  0008d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00090	50		 push	 eax
  00091	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00096	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem
$LN8@gObjCloseS:

; 1289 : 		}
; 1290 : #endif
; 1291 : 
; 1292 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328		//    
; 1293 : 		if(CHECK_ILLUSION_TEMPLE(lpObj->MapNumber))
; 1294 : 		{
; 1295 : 			g_IllusionTempleEvent.DropRelicsItem(lpObj->MapNumber, lpObj->m_Index);
; 1296 : 			g_IllusionTempleEvent.LeaveIllusionTemple(lpObj->m_Index, lpObj->MapNumber);
; 1297 : 		}
; 1298 : #endif
; 1299 : 
; 1300 : 		//       .
; 1301 : #ifdef MODIFY_SELFDEFENSETIME_MAXSELFDEFIENSE_20071221	//   60
; 1302 : 		if( GetTickCount()-lpObj->MySelfDefenseTime  < (1000*60) )

  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000a1	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a4	2b 81 78 02 00
	00		 sub	 eax, DWORD PTR [ecx+632]
  000aa	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  000af	73 37		 jae	 SHORT $LN9@gObjCloseS

; 1303 : #else	// MODIFY_SELFDEFENSETIME_MAXSELFDEFIENSE_20071221
; 1304 : #ifdef UPDATE_PK_SYSTEM_20070302	//   
; 1305 : 
; 1306 : 		if( GetTickCount()-lpObj->MySelfDefenseTime  < (1000*90) )
; 1307 : #else
; 1308 : 		if( GetTickCount()-lpObj->MySelfDefenseTime  < (1000*30) )
; 1309 : #endif
; 1310 : #endif	// MODIFY_SELFDEFENSETIME_MAXSELFDEFIENSE_20071221
; 1311 : 		{
; 1312 : 			GCServerMsgStringSend(lMsg.Get(1133), lpObj->m_Index, 1);

  000b1	6a 01		 push	 1
  000b3	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b8	51		 push	 ecx
  000b9	68 6d 04 00 00	 push	 1133			; 0000046dH
  000be	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1313 : #ifdef MODIFY_SELFDEFENSE_CLOSE_20070321
; 1314 : 			GCCloseMsgSend(aIndex, 0xFF);

  000d2	68 ff 00 00 00	 push	 255			; 000000ffH
  000d7	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  000e0	83 c4 08	 add	 esp, 8

; 1315 : #endif
; 1316 : 			return;

  000e3	e9 5b 01 00 00	 jmp	 $LN1@gObjCloseS
$LN9@gObjCloseS:

; 1317 : 		}
; 1318 : 		if( lpObj->m_IfState.use && 

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000eb	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000f1	80 e1 03	 and	 cl, 3
  000f4	0f b6 d1	 movzx	 edx, cl
  000f7	85 d2		 test	 edx, edx
  000f9	0f 84 25 01 00
	00		 je	 $LN7@gObjCloseS
  000ff	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00102	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00108	c0 e9 04	 shr	 cl, 4
  0010b	80 e1 0f	 and	 cl, 15			; 0000000fH
  0010e	0f b6 d1	 movzx	 edx, cl
  00111	83 fa 01	 cmp	 edx, 1
  00114	74 49		 je	 SHORT $LN11@gObjCloseS
  00116	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00119	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0011f	c0 e9 04	 shr	 cl, 4
  00122	80 e1 0f	 and	 cl, 15			; 0000000fH
  00125	0f b6 d1	 movzx	 edx, cl
  00128	83 fa 06	 cmp	 edx, 6
  0012b	74 32		 je	 SHORT $LN11@gObjCloseS
  0012d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00130	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00136	c0 e9 04	 shr	 cl, 4
  00139	80 e1 0f	 and	 cl, 15			; 0000000fH
  0013c	0f b6 d1	 movzx	 edx, cl
  0013f	83 fa 0d	 cmp	 edx, 13			; 0000000dH
  00142	74 1b		 je	 SHORT $LN11@gObjCloseS
  00144	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00147	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0014d	c0 e9 04	 shr	 cl, 4
  00150	80 e1 0f	 and	 cl, 15			; 0000000fH
  00153	0f b6 d1	 movzx	 edx, cl
  00156	83 fa 07	 cmp	 edx, 7
  00159	0f 85 c5 00 00
	00		 jne	 $LN7@gObjCloseS
$LN11@gObjCloseS:

; 1319 : 			(lpObj->m_IfState.type == I_TRADE || 
; 1320 : 			lpObj->m_IfState.type == I_WAREHOUSE||
; 1321 : #ifdef DARKLORD_WORK
; 1322 : 			lpObj->m_IfState.type == I_DARK_TRAINER||
; 1323 : #endif
; 1324 : 			lpObj->m_IfState.type == I_CHAOSBOX))
; 1325 : 		{
; 1326 : #ifdef MODIFY_SAVE_CHAOSBOX_ITEMLIST_AT_LOGOUT_20070328
; 1327 : 			gObjSaveChaosBoxItemList( lpObj );
; 1328 : #endif // MODIFY_SAVE_CHAOSBOX_ITEMLIST_AT_LOGOUT_20070328
; 1329 : 			switch( lpObj->m_IfState.type )

  0015f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00162	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00168	c0 e9 04	 shr	 cl, 4
  0016b	80 e1 0f	 and	 cl, 15			; 0000000fH
  0016e	0f b6 d1	 movzx	 edx, cl
  00171	89 55 b8	 mov	 DWORD PTR tv163[ebp], edx
  00174	8b 45 b8	 mov	 eax, DWORD PTR tv163[ebp]
  00177	83 e8 01	 sub	 eax, 1
  0017a	89 45 b8	 mov	 DWORD PTR tv163[ebp], eax
  0017d	83 7d b8 0c	 cmp	 DWORD PTR tv163[ebp], 12 ; 0000000cH
  00181	0f 87 9b 00 00
	00		 ja	 $LN2@gObjCloseS
  00187	8b 4d b8	 mov	 ecx, DWORD PTR tv163[ebp]
  0018a	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN21@gObjCloseS[ecx]
  00191	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN22@gObjCloseS[edx*4]
$LN12@gObjCloseS:

; 1330 : 			{
; 1331 : 			case I_TRADE :
; 1332 : 				GCServerMsgStringSend(lMsg.Get(1134), lpObj->m_Index, 1);

  00198	6a 01		 push	 1
  0019a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019f	51		 push	 ecx
  001a0	68 6e 04 00 00	 push	 1134			; 0000046eH
  001a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001b0	50		 push	 eax
  001b1	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1333 : 				break;

  001b9	eb 67		 jmp	 SHORT $LN2@gObjCloseS
$LN13@gObjCloseS:

; 1334 : 			case I_WAREHOUSE :
; 1335 : 				GCServerMsgStringSend(lMsg.Get(1135), lpObj->m_Index, 1);

  001bb	6a 01		 push	 1
  001bd	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c2	51		 push	 ecx
  001c3	68 6f 04 00 00	 push	 1135			; 0000046fH
  001c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001d3	50		 push	 eax
  001d4	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1336 : 				break;

  001dc	eb 44		 jmp	 SHORT $LN2@gObjCloseS
$LN14@gObjCloseS:

; 1337 : 			case I_CHAOSBOX :
; 1338 : 				GCServerMsgStringSend(lMsg.Get(1151), lpObj->m_Index, 1);	//     .

  001de	6a 01		 push	 1
  001e0	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e5	51		 push	 ecx
  001e6	68 7f 04 00 00	 push	 1151			; 0000047fH
  001eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001f6	50		 push	 eax
  001f7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1339 : 				break;

  001ff	eb 21		 jmp	 SHORT $LN2@gObjCloseS
$LN15@gObjCloseS:

; 1340 : #ifdef DARKLORD_WORK
; 1341 : 			case I_DARK_TRAINER :
; 1342 : 				GCServerMsgStringSend(lMsg.Get(1253), lpObj->m_Index, 1);	//     

  00201	6a 01		 push	 1
  00203	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00206	8b 08		 mov	 ecx, DWORD PTR [eax]
  00208	51		 push	 ecx
  00209	68 e5 04 00 00	 push	 1253			; 000004e5H
  0020e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00213	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00219	50		 push	 eax
  0021a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0021f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@gObjCloseS:

; 1343 : 				break;
; 1344 : #endif
; 1345 : 			}
; 1346 : 			return;

  00222	eb 1f		 jmp	 SHORT $LN1@gObjCloseS
$LN7@gObjCloseS:

; 1347 : 		}
; 1348 : 	}
; 1349 : 
; 1350 : 	lpObj->CloseCount	= g_GlobalConfig.CloseCountTime;

  00224	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00227	8a 0d 08 04 00
	00		 mov	 cl, BYTE PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+1032
  0022d	88 48 0a	 mov	 BYTE PTR [eax+10], cl

; 1351 : 	lpObj->CloseType	= Flag;

  00230	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00233	8a 4d 0c	 mov	 cl, BYTE PTR _Flag$[ebp]
  00236	88 48 0b	 mov	 BYTE PTR [eax+11], cl

; 1352 : 
; 1353 : #ifndef MODIFY_PERIODITEM_EFFECT_DURING_CLOSETIME_20070416
; 1354 : 	#ifdef ADD_PARTIALY_CHARGE_PERIOD_SYSTEM_20070205
; 1355 : 	g_CashItemPeriodSystem.GDReqPeriodItemUpdate( lpObj );
; 1356 : 	g_CashItemPeriodSystem.ClearPeriodItemEffect( lpObj );
; 1357 : 	#endif // ADD_PARTIALY_CHARGE_PERIOD_SYSTEM_20070205
; 1358 : #endif // MODIFY_PERIODITEM_EFFECT_DURING_CLOSETIME_20070416
; 1359 : 
; 1360 : #ifdef BLOCK_INVALID_CHARACTER_DELETE_01_20060327
; 1361 : 	lpObj->bEnableDelCharacter = TRUE;

  00239	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0023c	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1
$LN1@gObjCloseS:

; 1362 : #endif
; 1363 : 	
; 1364 : 	/*switch( Flag )
; 1365 : 	{
; 1366 : 	case CL_SERVERLIST :
; 1367 : 	case CL_EXIT :	//  
; 1368 : 		if( lpObj->Connected == CSS_GAMEPLAYING )
; 1369 : 		{
; 1370 : 			if( lpObj->CloseCount < 1 )
; 1371 : 			{
; 1372 : 				lpObj->CloseCount = 6;
; 1373 : 				if( Flag == CL_SERVERLIST )
; 1374 : 					lpObj->CloseType = CL_SERVERLIST;
; 1375 : 				else lpObj->CloseType = CL_EXIT;
; 1376 : 			}
; 1377 : 		}
; 1378 : 		break;
; 1379 : 	
; 1380 : 	case CL_BACK :
; 1381 : 		//        .
; 1382 : 		if( lpObj->m_IfState.use == 1 && 
; 1383 : 			(lpObj->m_IfState.type == I_TRADE || 
; 1384 : 			lpObj->m_IfState.type == I_WAREHOUSE))
; 1385 : 		{
; 1386 : 			switch( lpObj->m_IfState.type )
; 1387 : 			{
; 1388 : 			case I_TRADE :
; 1389 : 				GCServerMsgStringSend("    .", lpObj->m_Index, 1);
; 1390 : 				break;
; 1391 : 			case I_WAREHOUSE :
; 1392 : 				GCServerMsgStringSend("    .", lpObj->m_Index, 1);
; 1393 : 				break;
; 1394 : 			}
; 1395 : 			return;
; 1396 : 		}
; 1397 : 		if( lpObj->Connected == CSS_GAMEPLAYING )
; 1398 : 		{
; 1399 : 			if( lpObj->CloseCount < 1 )
; 1400 : 			{
; 1401 : 				lpObj->CloseCount = 6;
; 1402 : 				lpObj->CloseType = CL_BACK;
; 1403 : 			}
; 1404 : 		}
; 1405 : 		else if( lpObj->Connected == CSS_CHARACTERVIEW )
; 1406 : 		{
; 1407 : 			GCCloseMsgSend(aIndex, 0x02);	// 
; 1408 : 		}
; 1409 : 		break;
; 1410 : 	}
; 1411 : 	*/
; 1412 : }

  00243	5f		 pop	 edi
  00244	5e		 pop	 esi
  00245	5b		 pop	 ebx
  00246	8b e5		 mov	 esp, ebp
  00248	5d		 pop	 ebp
  00249	c3		 ret	 0
  0024a	66 90		 npad	 2
$LN22@gObjCloseS:
  0024c	00 00 00 00	 DD	 $LN12@gObjCloseS
  00250	00 00 00 00	 DD	 $LN13@gObjCloseS
  00254	00 00 00 00	 DD	 $LN14@gObjCloseS
  00258	00 00 00 00	 DD	 $LN15@gObjCloseS
  0025c	00 00 00 00	 DD	 $LN2@gObjCloseS
$LN21@gObjCloseS:
  00260	00		 DB	 0
  00261	04		 DB	 4
  00262	04		 DB	 4
  00263	04		 DB	 4
  00264	04		 DB	 4
  00265	01		 DB	 1
  00266	02		 DB	 2
  00267	04		 DB	 4
  00268	04		 DB	 4
  00269	04		 DB	 4
  0026a	04		 DB	 4
  0026b	04		 DB	 4
  0026c	03		 DB	 3
?gObjCloseSet@@YAXHH@Z ENDP				; gObjCloseSet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjAllLogOut@@YAXXZ
_TEXT	SEGMENT
?gObjAllLogOut@@YAXXZ PROC				; gObjAllLogOut, COMDAT

; 5632 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5633 : 	static int OneMsg=0;
; 5634 : 	
; 5635 : 	if( OneMsg == 0 )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?OneMsg@?1??gObjAllLogOut@@YAXXZ@4HA, 0
  00010	75 36		 jne	 SHORT $LN1@gObjAllLog

; 5636 : 	{
; 5637 : 		OneMsg = 1;

  00012	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?OneMsg@?1??gObjAllLogOut@@YAXXZ@4HA, 1

; 5638 : 		gObjAllDisconnect();

  0001c	e8 00 00 00 00	 call	 ?gObjAllDisconnect@@YAXXZ ; gObjAllDisconnect

; 5639 : 		/*for( n=0; n<MAX_OBJECT; n++)
; 5640 : 		{
; 5641 : 			if( gObj[n].Connected > 0 && (gObj[n].Type == OBJTYPE_CHARACTER) )
; 5642 : 			{
; 5643 : 				if( gObj[n].Connected == CSS_GAMEPLAYING )
; 5644 : 				{
; 5645 : 					gObjTradeSave(&gObj[n], n);
; 5646 : 					GJSetCharacterInfo(&gObj[n], n);
; 5647 : 					Sleep(300);
; 5648 : 				}
; 5649 : 				if( gObj[n].Connected > CSS_LOGIN ) GJPUserClose(gObj[n].AccountID);		//    .
; 5650 : 				Sleep(100);
; 5651 : 			}
; 5652 : 		}
; 5653 : 		*/
; 5654 : 		Sleep(1000);

  00021	68 e8 03 00 00	 push	 1000			; 000003e8H
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 5655 : 		LogAddC(LOGC_RED, lMsg.Get(512));

  0002c	68 00 02 00 00	 push	 512			; 00000200H
  00031	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0003c	50		 push	 eax
  0003d	6a 02		 push	 2
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00045	83 c4 08	 add	 esp, 8
$LN1@gObjAllLog:

; 5656 : 		//SendMessage(ghWnd, WM_CLOSE, NULL , NULL);
; 5657 : 	}
; 5658 : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?gObjAllLogOut@@YAXXZ ENDP				; gObjAllLogOut
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjAllDisconnect@@YAXXZ
_TEXT	SEGMENT
_n$1 = -4						; size = 4
?gObjAllDisconnect@@YAXXZ PROC				; gObjAllDisconnect, COMDAT

; 5661 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5662 : 	gDisconnect = 1;

  00009	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?gDisconnect@@3HA, 1 ; gDisconnect

; 5663 : 	for(int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  00013	c7 45 fc 00 19
	00 00		 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  0001a	eb 09		 jmp	 SHORT $LN4@gObjAllDis
$LN2@gObjAllDis:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 fc	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjAllDis:
  00025	81 7d fc e8 1c
	00 00		 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  0002c	7d 39		 jge	 SHORT $LN1@gObjAllDis

; 5664 : 	{
; 5665 : 		if( gObj[n].Connected > 0 && (gObj[n].Type == OBJTYPE_CHARACTER) )

  0002e	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003b	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  00040	7e 23		 jle	 SHORT $LN5@gObjAllDis
  00042	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004f	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00054	83 fa 01	 cmp	 edx, 1
  00057	75 0c		 jne	 SHORT $LN5@gObjAllDis

; 5666 : 		{
; 5667 : 			//wsGServer.Close(gObj[n].m_socket);
; 5668 : 			CloseClient(n);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00062	83 c4 04	 add	 esp, 4
$LN5@gObjAllDis:

; 5669 : 		}
; 5670 : 	}

  00065	eb b5		 jmp	 SHORT $LN2@gObjAllDis
$LN1@gObjAllDis:

; 5671 : 
; 5672 : }

  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?gObjAllDisconnect@@YAXXZ ENDP				; gObjAllDisconnect
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gPlusItemNumber@@YAXXZ
_TEXT	SEGMENT
?gPlusItemNumber@@YAXXZ PROC				; gPlusItemNumber, COMDAT

; 14984: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14985: 	//gItemNumberCount++;
; 14986: 	//gItemNumberCount = 0;
; 14987: 	//LogAdd("   : %d",gItemNumberCount);
; 14988: }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?gPlusItemNumber@@YAXXZ ENDP				; gPlusItemNumber
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gGetItemNumber@@YAKXZ
_TEXT	SEGMENT
?gGetItemNumber@@YAKXZ PROC				; gGetItemNumber, COMDAT

; 14979: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14980: 	return gItemNumberCount;

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gItemNumberCount@@3KA ; gItemNumberCount

; 14981: }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?gGetItemNumber@@YAKXZ ENDP				; gGetItemNumber
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjAbilityReSet@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjAbilityReSet@@YAXPAVOBJECTSTRUCT@@@Z PROC		; gObjAbilityReSet, COMDAT

; 28897: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 28898: 	lpObj->LevelUpPoint = (lpObj->Level-1)*5;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00013	83 e9 01	 sub	 ecx, 1
  00016	6b d1 05	 imul	 edx, ecx, 5
  00019	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	89 90 a4 00 00
	00		 mov	 DWORD PTR [eax+164], edx

; 28899: 	
; 28900: 	lpObj->Strength		= DCInfo.DefClass[lpObj->Class].Strength;

  00022	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00025	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0002c	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  00032	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00035	66 8b 8a 08 00
	00 00		 mov	 cx, WORD PTR ?DCInfo@@3Vclassdef@@A[edx+8]
  0003c	66 89 88 b4 00
	00 00		 mov	 WORD PTR [eax+180], cx

; 28901: 	lpObj->Dexterity	= DCInfo.DefClass[lpObj->Class].Dexterity;

  00043	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00046	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0004d	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  00053	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00056	66 8b 8a 0a 00
	00 00		 mov	 cx, WORD PTR ?DCInfo@@3Vclassdef@@A[edx+10]
  0005d	66 89 88 b6 00
	00 00		 mov	 WORD PTR [eax+182], cx

; 28902: 	lpObj->Vitality		= DCInfo.DefClass[lpObj->Class].Vitality;

  00064	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00067	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0006e	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  00074	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00077	66 8b 8a 0c 00
	00 00		 mov	 cx, WORD PTR ?DCInfo@@3Vclassdef@@A[edx+12]
  0007e	66 89 88 b8 00
	00 00		 mov	 WORD PTR [eax+184], cx

; 28903: 	lpObj->Energy		= DCInfo.DefClass[lpObj->Class].Energy;

  00085	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00088	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0008f	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  00095	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00098	66 8b 8a 0e 00
	00 00		 mov	 cx, WORD PTR ?DCInfo@@3Vclassdef@@A[edx+14]
  0009f	66 89 88 ba 00
	00 00		 mov	 WORD PTR [eax+186], cx

; 28904: 		
; 28905: 	lpObj->MaxLife		= DCInfo.DefClass[lpObj->Class].MaxLife;

  000a6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a9	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000b0	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  000b6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b9	8b 8a 18 00 00
	00		 mov	 ecx, DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+24]
  000bf	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx

; 28906: 	lpObj->MaxMana		= DCInfo.DefClass[lpObj->Class].MaxMana;	

  000c5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c8	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000cf	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  000d5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d8	8b 8a 24 00 00
	00		 mov	 ecx, DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+36]
  000de	89 88 d4 00 00
	00		 mov	 DWORD PTR [eax+212], ecx

; 28907: 
; 28908: 	if( lpObj->Class == 0 )

  000e4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e7	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000ee	85 c9		 test	 ecx, ecx
  000f0	0f 85 87 00 00
	00		 jne	 $LN2@gObjAbilit

; 28909: 	{
; 28910: 		lpObj->MaxLife		+= (float)(lpObj->Level-1)*0.5f;

  000f6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f9	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00100	83 e9 01	 sub	 ecx, 1
  00103	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00107	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0010f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00112	f3 0f 58 82 c0
	00 00 00	 addss	 xmm0, DWORD PTR [edx+192]
  0011a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011d	f3 0f 11 80 c0
	00 00 00	 movss	 DWORD PTR [eax+192], xmm0

; 28911: 		lpObj->MaxMana		+= (float)(lpObj->Level-1)*2;

  00125	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00128	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0012f	83 e9 01	 sub	 ecx, 1
  00132	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00136	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  0013e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00141	f3 0f 58 82 d4
	00 00 00	 addss	 xmm0, DWORD PTR [edx+212]
  00149	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014c	f3 0f 11 80 d4
	00 00 00	 movss	 DWORD PTR [eax+212], xmm0

; 28912: 		lpObj->Life			= lpObj->MaxLife;

  00154	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00157	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0015a	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  00160	89 90 bc 00 00
	00		 mov	 DWORD PTR [eax+188], edx

; 28913: 		lpObj->Mana			= lpObj->MaxMana;

  00166	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00169	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0016c	8b 91 d4 00 00
	00		 mov	 edx, DWORD PTR [ecx+212]
  00172	89 90 d0 00 00
	00		 mov	 DWORD PTR [eax+208], edx

; 28914: 	}

  00178	e9 82 00 00 00	 jmp	 $LN3@gObjAbilit
$LN2@gObjAbilit:

; 28915: 	else
; 28916: 	{
; 28917: 		lpObj->MaxLife		+= (float)(lpObj->Level-1)*2;

  0017d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00180	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00187	83 e9 01	 sub	 ecx, 1
  0018a	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0018e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00196	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00199	f3 0f 58 82 c0
	00 00 00	 addss	 xmm0, DWORD PTR [edx+192]
  001a1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a4	f3 0f 11 80 c0
	00 00 00	 movss	 DWORD PTR [eax+192], xmm0

; 28918: 		lpObj->MaxMana		+= (float)(lpObj->Level-1)*0.5f;

  001ac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001af	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  001b6	83 e9 01	 sub	 ecx, 1
  001b9	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  001bd	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  001c5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001c8	f3 0f 58 82 d4
	00 00 00	 addss	 xmm0, DWORD PTR [edx+212]
  001d0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d3	f3 0f 11 80 d4
	00 00 00	 movss	 DWORD PTR [eax+212], xmm0

; 28919: 		lpObj->Life			= lpObj->MaxLife;

  001db	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001de	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001e1	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  001e7	89 90 bc 00 00
	00		 mov	 DWORD PTR [eax+188], edx

; 28920: 		lpObj->Mana			= lpObj->MaxMana;

  001ed	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001f3	8b 91 d4 00 00
	00		 mov	 edx, DWORD PTR [ecx+212]
  001f9	89 90 d0 00 00
	00		 mov	 DWORD PTR [eax+208], edx
$LN3@gObjAbilit:

; 28921: 	}
; 28922: 	CloseClient ( lpObj->m_Index );

  001ff	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00202	8b 08		 mov	 ecx, DWORD PTR [eax]
  00204	51		 push	 ecx
  00205	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  0020a	83 c4 04	 add	 esp, 4

; 28923: }

  0020d	5f		 pop	 edi
  0020e	5e		 pop	 esi
  0020f	5b		 pop	 ebx
  00210	8b e5		 mov	 esp, ebp
  00212	5d		 pop	 ebp
  00213	c3		 ret	 0
?gObjAbilityReSet@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; gObjAbilityReSet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjUseDrink@@YAXPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_time$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_level$ = 12						; size = 4
?gObjUseDrink@@YAXPAVOBJECTSTRUCT@@H@Z PROC		; gObjUseDrink, COMDAT

; 23567: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 23568: 	int time;
; 23569: 	if( level == 2 )

  00009	83 7d 0c 02	 cmp	 DWORD PTR _level$[ebp], 2
  0000d	75 34		 jne	 SHORT $LN2@gObjUseDri

; 23570: 	{	//  
; 23571: 		time = 90;

  0000f	c7 45 fc 5a 00
	00 00		 mov	 DWORD PTR _time$[ebp], 90 ; 0000005aH

; 23572: 		GCItemUseSpecialTimeSend(lpObj->m_Index, 1, time);

  00016	8b 45 fc	 mov	 eax, DWORD PTR _time$[ebp]
  00019	50		 push	 eax
  0001a	6a 01		 push	 1
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 ?GCItemUseSpecialTimeSend@@YAXHEH@Z ; GCItemUseSpecialTimeSend
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23573: 		lpObj->m_SkillAttack2 = 1;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002d	c7 80 80 02 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+640], 1

; 23574: 		lpObj->m_SkillAttackTime2 = 90;

  00037	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003a	c6 80 84 02 00
	00 5a		 mov	 BYTE PTR [eax+644], 90	; 0000005aH

; 23575: 	}

  00041	eb 3e		 jmp	 SHORT $LN1@gObjUseDri
$LN2@gObjUseDri:

; 23576: 	else if( level == 1 )

  00043	83 7d 0c 01	 cmp	 DWORD PTR _level$[ebp], 1
  00047	75 1d		 jne	 SHORT $LN4@gObjUseDri

; 23577: 	{	//  	
; 23578: 		time = 180;

  00049	c7 45 fc b4 00
	00 00		 mov	 DWORD PTR _time$[ebp], 180 ; 000000b4H

; 23579: 		GCItemUseSpecialTimeSend(lpObj->m_Index, 0, time);

  00050	8b 45 fc	 mov	 eax, DWORD PTR _time$[ebp]
  00053	50		 push	 eax
  00054	6a 00		 push	 0
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 ?GCItemUseSpecialTimeSend@@YAXHEH@Z ; GCItemUseSpecialTimeSend
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH

; 23580: 	}

  00064	eb 1b		 jmp	 SHORT $LN1@gObjUseDri
$LN4@gObjUseDri:

; 23581: #ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116
; 23582: 	//   
; 23583: 	else if( level == 77 )
; 23584: 	{
; 23585: 		time = CASTLE_SOULPOTION_ACTIVETIME;
; 23586: 		//    .
; 23587: 		GCItemUseSpecialTimeSend(lpObj->m_Index, 2, time);
; 23588: 	}
; 23589: #endif
; 23590: 	else
; 23591: 	{	//  
; 23592: 		time = 80;

  00066	c7 45 fc 50 00
	00 00		 mov	 DWORD PTR _time$[ebp], 80 ; 00000050H

; 23593: 		GCItemUseSpecialTimeSend(lpObj->m_Index, 0, time);

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _time$[ebp]
  00070	50		 push	 eax
  00071	6a 00		 push	 0
  00073	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00076	8b 11		 mov	 edx, DWORD PTR [ecx]
  00078	52		 push	 edx
  00079	e8 00 00 00 00	 call	 ?GCItemUseSpecialTimeSend@@YAXHEH@Z ; GCItemUseSpecialTimeSend
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjUseDri:

; 23594: 	}
; 23595: }

  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
?gObjUseDrink@@YAXPAVOBJECTSTRUCT@@H@Z ENDP		; gObjUseDrink
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjItemRandomOption3Up@@YAHPAVOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_NewOption$ = -20					; size = 8
_levelitemdur$ = -12					; size = 4
__r$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_source$ = 12						; size = 4
_target$ = 16						; size = 4
?gObjItemRandomOption3Up@@YAHPAVOBJECTSTRUCT@@HH@Z PROC	; gObjItemRandomOption3Up, COMDAT

; 28707: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 28708: 	if( source < 0 || source > MAX_INVENTORY-1 ) return FALSE;

  00013	83 7d 0c 00	 cmp	 DWORD PTR _source$[ebp], 0
  00017	7c 06		 jl	 SHORT $LN3@gObjItemRa
  00019	83 7d 0c 4b	 cmp	 DWORD PTR _source$[ebp], 75 ; 0000004bH
  0001d	7e 07		 jle	 SHORT $LN2@gObjItemRa
$LN3@gObjItemRa:
  0001f	33 c0		 xor	 eax, eax
  00021	e9 c9 05 00 00	 jmp	 $LN1@gObjItemRa
$LN2@gObjItemRa:

; 28709: 	if( target < 0 || target > MAX_INVENTORY-1 ) return FALSE;

  00026	83 7d 10 00	 cmp	 DWORD PTR _target$[ebp], 0
  0002a	7c 06		 jl	 SHORT $LN5@gObjItemRa
  0002c	83 7d 10 4b	 cmp	 DWORD PTR _target$[ebp], 75 ; 0000004bH
  00030	7e 07		 jle	 SHORT $LN4@gObjItemRa
$LN5@gObjItemRa:
  00032	33 c0		 xor	 eax, eax
  00034	e9 b6 05 00 00	 jmp	 $LN1@gObjItemRa
$LN4@gObjItemRa:

; 28710: 
; 28711: 	//   
; 28712: 	if( lpObj->pInventory[source].IsItem() == FALSE ) return FALSE;

  00039	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _source$[ebp], 168
  00040	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00043	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00049	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0004e	85 c0		 test	 eax, eax
  00050	75 07		 jne	 SHORT $LN6@gObjItemRa
  00052	33 c0		 xor	 eax, eax
  00054	e9 96 05 00 00	 jmp	 $LN1@gObjItemRa
$LN6@gObjItemRa:

; 28713: 	if( lpObj->pInventory[target].IsItem() == FALSE ) return FALSE;

  00059	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00060	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00063	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00069	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0006e	85 c0		 test	 eax, eax
  00070	75 07		 jne	 SHORT $LN7@gObjItemRa
  00072	33 c0		 xor	 eax, eax
  00074	e9 76 05 00 00	 jmp	 $LN1@gObjItemRa
$LN7@gObjItemRa:

; 28714: 
; 28715: #ifdef ADD_THIRD_WING_20070525	// 3   
; 28716: 	if( ( lpObj->pInventory[target].m_Type >= MAKE_ITEMNUM( 12, 7 ) && lpObj->pInventory[target].m_Type < MAKE_ITEMNUM( 12, 36 ) ) || 
; 28717: #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//  1    
; 28718: 		( lpObj->pInventory[target].m_Type > MAKE_ITEMNUM( 12, 43 ) && lpObj->pInventory[target].m_Type != MAKE_ITEMNUM( 13, 30 ) ) || 		
; 28719: #else	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 28720: 		( lpObj->pInventory[target].m_Type > MAKE_ITEMNUM( 12, 40 ) && lpObj->pInventory[target].m_Type != MAKE_ITEMNUM( 13, 30 ) ) || 		
; 28721: #endif	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 28722: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 4, 7 ) ||
; 28723: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 4, 15 ) )
; 28724: 		return FALSE;			//    	
; 28725: #else
; 28726: #ifdef DARKLORD_WORK
; 28727: 	if( (lpObj->pInventory[target].m_Type >= MAKE_ITEMNUM(12,7) && lpObj->pInventory[target].m_Type != MAKE_ITEMNUM(13,30)) || 
; 28728: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(4, 7) ||

  00079	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00080	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00083	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00089	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  0008e	6a 07		 push	 7
  00090	6a 0c		 push	 12			; 0000000cH
  00092	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00097	83 c4 08	 add	 esp, 8
  0009a	3b f0		 cmp	 esi, eax
  0009c	7c 25		 jl	 SHORT $LN10@gObjItemRa
  0009e	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a8	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000ae	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000b3	6a 1e		 push	 30			; 0000001eH
  000b5	6a 0d		 push	 13			; 0000000dH
  000b7	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000bc	83 c4 08	 add	 esp, 8
  000bf	3b f0		 cmp	 esi, eax
  000c1	75 4a		 jne	 SHORT $LN9@gObjItemRa
$LN10@gObjItemRa:
  000c3	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000cd	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000d3	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000d8	6a 07		 push	 7
  000da	6a 04		 push	 4
  000dc	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000e1	83 c4 08	 add	 esp, 8
  000e4	3b f0		 cmp	 esi, eax
  000e6	74 25		 je	 SHORT $LN9@gObjItemRa
  000e8	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  000ef	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000f2	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000f8	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000fd	6a 0f		 push	 15			; 0000000fH
  000ff	6a 04		 push	 4
  00101	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00106	83 c4 08	 add	 esp, 8
  00109	3b f0		 cmp	 esi, eax
  0010b	75 07		 jne	 SHORT $LN8@gObjItemRa
$LN9@gObjItemRa:

; 28729: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(4, 15) )
; 28730: 		return FALSE;			//    

  0010d	33 c0		 xor	 eax, eax
  0010f	e9 db 04 00 00	 jmp	 $LN1@gObjItemRa
$LN8@gObjItemRa:

; 28731: #else
; 28732: 	if( lpObj->pInventory[target].m_Type >= MAKE_ITEMNUM(12,7) || 
; 28733: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(4, 7) ||
; 28734: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(4, 15) )
; 28735: 		return FALSE;			//    
; 28736: #endif
; 28737: #endif	// ADD_THIRD_WING_20070525
; 28738: 
; 28739: 	LogAddTD(lMsg.Get(576), lpObj->AccountID, lpObj->Name, lpObj->pInventory[target].GetName(), lpObj->pInventory[target].m_Number, lpObj->pInventory[target].m_Option3);

  00114	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  0011b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0011e	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00124	0f b6 44 02 7a	 movzx	 eax, BYTE PTR [edx+eax+122]
  00129	50		 push	 eax
  0012a	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00131	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00134	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0013a	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0013d	51		 push	 ecx
  0013e	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00145	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00148	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0014e	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00153	50		 push	 eax
  00154	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00157	83 c0 73	 add	 eax, 115		; 00000073H
  0015a	50		 push	 eax
  0015b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0015e	83 c1 68	 add	 ecx, 104		; 00000068H
  00161	51		 push	 ecx
  00162	68 40 02 00 00	 push	 576			; 00000240H
  00167	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00172	50		 push	 eax
  00173	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00179	83 c4 18	 add	 esp, 24			; 00000018H

; 28740: 	
; 28741: 	int _r = rand()%100;

  0017c	e8 00 00 00 00	 call	 _rand
  00181	99		 cdq
  00182	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00187	f7 f9		 idiv	 ecx
  00189	89 55 f8	 mov	 DWORD PTR __r$[ebp], edx

; 28742: 
; 28743: 	if( lpObj->pInventory[target].m_Option3 == 0 )

  0018c	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00193	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00196	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0019c	0f b6 44 02 7a	 movzx	 eax, BYTE PTR [edx+eax+122]
  001a1	85 c0		 test	 eax, eax
  001a3	0f 85 bb 00 00
	00		 jne	 $LN13@gObjItemRa

; 28744: 	{	//  , 
; 28745: #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130
; 28746: 		if( (lpObj->pInventory[target].m_Type>=MAKE_ITEMNUM(12,3) && lpObj->pInventory[target].m_Type<=MAKE_ITEMNUM(12,6) )
; 28747: 			|| lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(12,42))	//  
; 28748: #else
; 28749: 		if( lpObj->pInventory[target].m_Type>=MAKE_ITEMNUM(12,3) && lpObj->pInventory[target].m_Type<=MAKE_ITEMNUM(12,6) )

  001a9	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  001b0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001b3	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  001b9	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  001be	6a 03		 push	 3
  001c0	6a 0c		 push	 12			; 0000000cH
  001c2	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001c7	83 c4 08	 add	 esp, 8
  001ca	3b f0		 cmp	 esi, eax
  001cc	0f 8c 92 00 00
	00		 jl	 $LN13@gObjItemRa
  001d2	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  001d9	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001dc	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  001e2	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  001e7	6a 06		 push	 6
  001e9	6a 0c		 push	 12			; 0000000cH
  001eb	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001f0	83 c4 08	 add	 esp, 8
  001f3	3b f0		 cmp	 esi, eax
  001f5	7f 6d		 jg	 SHORT $LN13@gObjItemRa

; 28750: #endif
; 28751: 		{	//   					
; 28752: 			lpObj->pInventory[target].m_NewOption &= ~PLUS_WING_OP1_TYPE;			

  001f7	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  001fe	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00201	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00207	0f b6 44 02 7b	 movzx	 eax, BYTE PTR [edx+eax+123]
  0020c	83 e0 df	 and	 eax, -33		; ffffffdfH
  0020f	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00216	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00219	8b 92 5c 0c 00
	00		 mov	 edx, DWORD PTR [edx+3164]
  0021f	88 44 0a 7b	 mov	 BYTE PTR [edx+ecx+123], al

; 28753: 			if( rand()%2 )

  00223	e8 00 00 00 00	 call	 _rand
  00228	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0022d	79 05		 jns	 SHORT $LN19@gObjItemRa
  0022f	48		 dec	 eax
  00230	83 c8 fe	 or	 eax, -2			; fffffffeH
  00233	40		 inc	 eax
$LN19@gObjItemRa:
  00234	85 c0		 test	 eax, eax
  00236	74 2c		 je	 SHORT $LN13@gObjItemRa

; 28754: 			{
; 28755: 				lpObj->pInventory[target].m_NewOption |= PLUS_WING_OP1_TYPE;

  00238	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  0023f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00242	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00248	0f b6 44 02 7b	 movzx	 eax, BYTE PTR [edx+eax+123]
  0024d	83 c8 20	 or	 eax, 32			; 00000020H
  00250	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00257	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0025a	8b 92 5c 0c 00
	00		 mov	 edx, DWORD PTR [edx+3164]
  00260	88 44 0a 7b	 mov	 BYTE PTR [edx+ecx+123], al
$LN13@gObjItemRa:

; 28756: 			}
; 28757: 		}
; 28758: 	}
; 28759: 
; 28760: 	//  0  4    . (m_Option3  *4 )
; 28761: 	
; 28762: /*/if( lpObj->pInventory[target].m_Option3 < 2 )
; 28763: 	{
; 28764: 		lpObj->pInventory[target].m_Option3++;
; 28765: 	}
; 28766: 	else */
; 28767: 	/*if( lpObj->pInventory[target].m_Option3 == 2 )	// Op = 8
; 28768: 	{
; 28769: 		if( _r < 50 ) lpObj->pInventory[target].m_Option3 = 1;
; 28770: 		else lpObj->pInventory[target].m_Option3++;
; 28771: 	}
; 28772: 	else 
; 28773: 	*/if( lpObj->pInventory[target].m_Option3 < 7 ) // Op = 12

  00264	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  0026b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0026e	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00274	0f b6 44 02 7a	 movzx	 eax, BYTE PTR [edx+eax+122]
  00279	83 f8 07	 cmp	 eax, 7
  0027c	7d 53		 jge	 SHORT $LN14@gObjItemRa

; 28774: 	{
; 28775: #ifdef ADD_THIRD_WING_20070525	// 3   
; 28776: 		if( _r < (100 - g_GlobalConfig.m_iLifeRate) ) 
; 28777: 		{
; 28778: 			lpObj->pInventory[target].m_Option3 = 0;
; 28779: 		}
; 28780: 		else 
; 28781: 		{			
; 28782: 			if( lpObj->pInventory[target].m_Option3 == 0 )
; 28783: 			{
; 28784: 				// 3   .
; 28785: #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130
; 28786: 				if( ( lpObj->pInventory[target].m_Type >= MAKE_ITEMNUM( 12, 36 ) 
; 28787: 					&& lpObj->pInventory[target].m_Type <= MAKE_ITEMNUM( 12, 40 ) )
; 28788: 					|| lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 12, 43 ))
; 28789: #else
; 28790: 				if( lpObj->pInventory[target].m_Type >= MAKE_ITEMNUM( 12, 36 ) 
; 28791: 					&& lpObj->pInventory[target].m_Type <= MAKE_ITEMNUM( 12, 40 ) )
; 28792: #endif
; 28793: 				{		
; 28794: 					//   
; 28795: 					lpObj->pInventory[target].m_NewOption &= ~PLUS_THIRD_WING_RAND_OPT_1;			
; 28796: 					lpObj->pInventory[target].m_NewOption &= ~PLUS_THIRD_WING_RAND_OPT_2;	
; 28797: 
; 28798: 					int iOpt3TypeRand = rand()%2;
; 28799: 					int iOpt3RandRate;
; 28800: 					switch( iOpt3TypeRand )
; 28801: 					{
; 28802: 					case 0:
; 28803: 						iOpt3RandRate = rand()%1000;
; 28804: 						if( iOpt3RandRate < 400 ) 
; 28805: 							lpObj->pInventory[target].m_NewOption |= PLUS_THIRD_WING_RAND_OPT_1;
; 28806: 						break;
; 28807: 					case 1:
; 28808: 						iOpt3RandRate = rand()%1000;
; 28809: 						if( iOpt3TypeRand < 300 ) 
; 28810: 							lpObj->pInventory[target].m_NewOption |= PLUS_THIRD_WING_RAND_OPT_2;
; 28811: 						break;			
; 28812: 					}
; 28813: 				}
; 28814: 			}
; 28815: 			lpObj->pInventory[target].m_Option3++;
; 28816: 		}
; 28817: #else
; 28818: 		if( _r < (100 - g_GlobalConfig.m_iLifeRate) ) lpObj->pInventory[target].m_Option3 = 0;

  0027e	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00283	2b 05 58 00 00
	00		 sub	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+88
  00289	39 45 f8	 cmp	 DWORD PTR __r$[ebp], eax
  0028c	7d 17		 jge	 SHORT $LN16@gObjItemRa
  0028e	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00295	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00298	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0029e	c6 44 02 7a 00	 mov	 BYTE PTR [edx+eax+122], 0
  002a3	eb 2a		 jmp	 SHORT $LN17@gObjItemRa
$LN16@gObjItemRa:

; 28819: 		else lpObj->pInventory[target].m_Option3++;

  002a5	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  002ac	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002af	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  002b5	8a 44 02 7a	 mov	 al, BYTE PTR [edx+eax+122]
  002b9	04 01		 add	 al, 1
  002bb	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  002c2	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002c5	8b 92 5c 0c 00
	00		 mov	 edx, DWORD PTR [edx+3164]
  002cb	88 44 0a 7a	 mov	 BYTE PTR [edx+ecx+122], al
$LN17@gObjItemRa:

; 28820: #endif
; 28821: 	}

  002cf	eb 07		 jmp	 SHORT $LN15@gObjItemRa
$LN14@gObjItemRa:

; 28822: 	else // Op = 16
; 28823: 	{
; 28824: 		return FALSE;

  002d1	33 c0		 xor	 eax, eax
  002d3	e9 17 03 00 00	 jmp	 $LN1@gObjItemRa
$LN15@gObjItemRa:

; 28825: 	}
; 28826: 
; 28827: 	gObjMakePreviewCharSet(lpObj->m_Index);

  002d8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002db	8b 08		 mov	 ecx, DWORD PTR [eax]
  002dd	51		 push	 ecx
  002de	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  002e3	83 c4 04	 add	 esp, 4

; 28828: 
; 28829: 	float levelitemdur =  (float)ItemGetDurability(lpObj->pInventory[target].m_Type, 

  002e6	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  002ed	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002f0	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  002f6	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  002fb	50		 push	 eax
  002fc	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00303	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00306	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0030c	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  00311	50		 push	 eax
  00312	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00319	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0031c	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00322	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00327	50		 push	 eax
  00328	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  0032f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00332	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00338	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  0033d	51		 push	 ecx
  0033e	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  00343	83 c4 10	 add	 esp, 16			; 00000010H
  00346	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0034a	f3 0f 11 45 f4	 movss	 DWORD PTR _levelitemdur$[ebp], xmm0

; 28830: 												   lpObj->pInventory[target].m_Level, 
; 28831: 												   lpObj->pInventory[target].IsExtItem(),
; 28832: 												   lpObj->pInventory[target].IsSetItem());
; 28833: 	
; 28834: 	
; 28835: 	lpObj->pInventory[target].m_Durability = levelitemdur*lpObj->pInventory[target].m_Durability/lpObj->pInventory[target].m_BaseDurability;

  0034f	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00356	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00359	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0035f	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _levelitemdur$[ebp]
  00364	f3 0f 59 44 02
	24		 mulss	 xmm0, DWORD PTR [edx+eax+36]
  0036a	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00371	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00374	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0037a	f3 0f 5e 44 02
	2c		 divss	 xmm0, DWORD PTR [edx+eax+44]
  00380	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00387	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0038a	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00390	f3 0f 11 44 02
	24		 movss	 DWORD PTR [edx+eax+36], xmm0

; 28836: 	//   
; 28837: 	#ifdef ADD_380ITEM_NEWOPTION_20060711
; 28838: 		lpObj->pInventory[target].Convert(lpObj->pInventory[target].m_Type, 
; 28839: 										  lpObj->pInventory[target].m_Option1, 
; 28840: 										  lpObj->pInventory[target].m_Option2,
; 28841: 										  lpObj->pInventory[target].m_Option3,
; 28842: 										  lpObj->pInventory[target].m_NewOption,
; 28843: 										  lpObj->pInventory[target].m_SetOption, 
; 28844: 										  lpObj->pInventory[target].m_ItemOptionEx);
; 28845: 	#else
; 28846: 		lpObj->pInventory[target].Convert(lpObj->pInventory[target].m_Type, 

  00396	6a 01		 push	 1
  00398	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  0039f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003a2	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  003a8	0f b6 84 02 92
	00 00 00	 movzx	 eax, BYTE PTR [edx+eax+146]
  003b0	50		 push	 eax
  003b1	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  003b8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003bb	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  003c1	0f b6 4c 08 7b	 movzx	 ecx, BYTE PTR [eax+ecx+123]
  003c6	51		 push	 ecx
  003c7	69 55 10 a8 00
	00 00		 imul	 edx, DWORD PTR _target$[ebp], 168
  003ce	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003d1	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  003d7	0f b6 54 11 7a	 movzx	 edx, BYTE PTR [ecx+edx+122]
  003dc	52		 push	 edx
  003dd	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  003e4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003e7	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  003ed	0f b6 44 02 79	 movzx	 eax, BYTE PTR [edx+eax+121]
  003f2	50		 push	 eax
  003f3	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  003fa	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003fd	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00403	0f b6 4c 08 78	 movzx	 ecx, BYTE PTR [eax+ecx+120]
  00408	51		 push	 ecx
  00409	69 55 10 a8 00
	00 00		 imul	 edx, DWORD PTR _target$[ebp], 168
  00410	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00413	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00419	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  0041e	52		 push	 edx
  0041f	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00426	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00429	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0042f	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 28847: 										  lpObj->pInventory[target].m_Option1, 
; 28848: 										  lpObj->pInventory[target].m_Option2,
; 28849: 										  lpObj->pInventory[target].m_Option3,
; 28850: 										  lpObj->pInventory[target].m_NewOption,
; 28851: 										  lpObj->pInventory[target].m_SetOption);
; 28852: 	#endif // ADD_380ITEM_NEWOPTION_20060711
; 28853: 
; 28854: 	LogAddTD(lMsg.Get(577),  

  00434	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  0043b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0043e	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00444	0f b6 44 02 7a	 movzx	 eax, BYTE PTR [edx+eax+122]
  00449	50		 push	 eax
  0044a	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00451	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00454	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0045a	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0045d	51		 push	 ecx
  0045e	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00465	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00468	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0046e	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00473	50		 push	 eax
  00474	69 45 0c a8 00
	00 00		 imul	 eax, DWORD PTR _source$[ebp], 168
  0047b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0047e	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00484	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00487	50		 push	 eax
  00488	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0048b	83 c1 73	 add	 ecx, 115		; 00000073H
  0048e	51		 push	 ecx
  0048f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00492	83 c2 68	 add	 edx, 104		; 00000068H
  00495	52		 push	 edx
  00496	68 41 02 00 00	 push	 577			; 00000241H
  0049b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  004a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  004a6	50		 push	 eax
  004a7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004ad	83 c4 1c	 add	 esp, 28			; 0000001cH

; 28855: 			 lpObj->AccountID, 
; 28856: 			 lpObj->Name, 
; 28857: 			 lpObj->pInventory[source].m_Number,
; 28858: 			 lpObj->pInventory[target].GetName(), 
; 28859: 			 lpObj->pInventory[target].m_Number, 
; 28860: 			 lpObj->pInventory[target].m_Option3);
; 28861: 
; 28862: 	BYTE NewOption[8];
; 28863: 
; 28864: 	ItemIsBufExOption(NewOption, &lpObj->pInventory[target]);

  004b0	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  004b7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004ba	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  004c0	50		 push	 eax
  004c1	8d 55 ec	 lea	 edx, DWORD PTR _NewOption$[ebp]
  004c4	52		 push	 edx
  004c5	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption
  004ca	83 c4 08	 add	 esp, 8

; 28865: #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 28866: 	LogAddTD("[%s][%s] JewelofLife Result [%d,%s,%d,%d,%d,%d]serial:[%u] dur:[%d] Ex:[%d,%d,%d,%d,%d,%d,%d]", 
; 28867: #else
; 28868: 	LogAddTD("[%s][%s] JewelofLife Result [%d,%s,%d,%d,%d,%d]serial:[%d] dur:[%d] Ex:[%d,%d,%d,%d,%d,%d,%d]", 

  004cd	b8 01 00 00 00	 mov	 eax, 1
  004d2	6b c8 06	 imul	 ecx, eax, 6
  004d5	0f b6 54 0d ec	 movzx	 edx, BYTE PTR _NewOption$[ebp+ecx]
  004da	52		 push	 edx
  004db	b8 01 00 00 00	 mov	 eax, 1
  004e0	6b c8 05	 imul	 ecx, eax, 5
  004e3	0f b6 54 0d ec	 movzx	 edx, BYTE PTR _NewOption$[ebp+ecx]
  004e8	52		 push	 edx
  004e9	b8 01 00 00 00	 mov	 eax, 1
  004ee	c1 e0 02	 shl	 eax, 2
  004f1	0f b6 4c 05 ec	 movzx	 ecx, BYTE PTR _NewOption$[ebp+eax]
  004f6	51		 push	 ecx
  004f7	ba 01 00 00 00	 mov	 edx, 1
  004fc	6b c2 03	 imul	 eax, edx, 3
  004ff	0f b6 4c 05 ec	 movzx	 ecx, BYTE PTR _NewOption$[ebp+eax]
  00504	51		 push	 ecx
  00505	ba 01 00 00 00	 mov	 edx, 1
  0050a	d1 e2		 shl	 edx, 1
  0050c	0f b6 44 15 ec	 movzx	 eax, BYTE PTR _NewOption$[ebp+edx]
  00511	50		 push	 eax
  00512	b9 01 00 00 00	 mov	 ecx, 1
  00517	c1 e1 00	 shl	 ecx, 0
  0051a	0f b6 54 0d ec	 movzx	 edx, BYTE PTR _NewOption$[ebp+ecx]
  0051f	52		 push	 edx
  00520	b8 01 00 00 00	 mov	 eax, 1
  00525	6b c8 00	 imul	 ecx, eax, 0
  00528	0f b6 54 0d ec	 movzx	 edx, BYTE PTR _NewOption$[ebp+ecx]
  0052d	52		 push	 edx
  0052e	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00535	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00538	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0053e	f3 0f 2c 44 02
	24		 cvttss2si eax, DWORD PTR [edx+eax+36]
  00544	0f b6 c8	 movzx	 ecx, al
  00547	51		 push	 ecx
  00548	69 55 10 a8 00
	00 00		 imul	 edx, DWORD PTR _target$[ebp], 168
  0054f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00552	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00558	8b 14 11	 mov	 edx, DWORD PTR [ecx+edx]
  0055b	52		 push	 edx
  0055c	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00563	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00566	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0056c	0f b6 44 02 7a	 movzx	 eax, BYTE PTR [edx+eax+122]
  00571	50		 push	 eax
  00572	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00579	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0057c	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00582	0f b6 4c 08 79	 movzx	 ecx, BYTE PTR [eax+ecx+121]
  00587	51		 push	 ecx
  00588	69 55 10 a8 00
	00 00		 imul	 edx, DWORD PTR _target$[ebp], 168
  0058f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00592	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00598	0f b6 54 11 78	 movzx	 edx, BYTE PTR [ecx+edx+120]
  0059d	52		 push	 edx
  0059e	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  005a5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005a8	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  005ae	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  005b3	50		 push	 eax
  005b4	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  005bb	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005be	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  005c4	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  005c9	50		 push	 eax
  005ca	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  005cd	50		 push	 eax
  005ce	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005d1	83 c1 73	 add	 ecx, 115		; 00000073H
  005d4	51		 push	 ecx
  005d5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005d8	83 c2 68	 add	 edx, 104		; 00000068H
  005db	52		 push	 edx
  005dc	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@HEPLMOKF@?$FL?$CFs?$FN?$FL?$CFs?$FN?5JewelofLife?5Result?5?$FL?$CFd@
  005e1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  005e7	83 c4 48	 add	 esp, 72			; 00000048H

; 28869: #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 28870: 			 lpObj->AccountID, 
; 28871: 			 lpObj->Name, 
; 28872: 			 target, 
; 28873: 			 lpObj->pInventory[target].GetName(), 
; 28874: 			 lpObj->pInventory[target].m_Level, 
; 28875: 			 lpObj->pInventory[target].m_Option1, 
; 28876: 			 lpObj->pInventory[target].m_Option2, 
; 28877: 			 lpObj->pInventory[target].m_Option3, 
; 28878: 			 lpObj->pInventory[target].m_Number, 
; 28879: 			 (BYTE)lpObj->pInventory[target].m_Durability,
; 28880: 			 NewOption[0],
; 28881: 			 NewOption[1],
; 28882: 			 NewOption[2],
; 28883: 			 NewOption[3],
; 28884: 			 NewOption[4],
; 28885: 			 NewOption[5],
; 28886: 			 NewOption[6]
; 28887: 			);
; 28888: 	
; 28889: 	return TRUE;

  005ea	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjItemRa:

; 28890: }

  005ef	5f		 pop	 edi
  005f0	5e		 pop	 esi
  005f1	5b		 pop	 ebx
  005f2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005f5	33 cd		 xor	 ecx, ebp
  005f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005fc	8b e5		 mov	 esp, ebp
  005fe	5d		 pop	 ebp
  005ff	c3		 ret	 0
?gObjItemRandomOption3Up@@YAHPAVOBJECTSTRUCT@@HH@Z ENDP	; gObjItemRandomOption3Up
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjItemRandomLevelUp@@YAHPAVOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_levelitemdur$ = -8					; size = 4
__r$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_source$ = 12						; size = 4
_target$ = 16						; size = 4
?gObjItemRandomLevelUp@@YAHPAVOBJECTSTRUCT@@HH@Z PROC	; gObjItemRandomLevelUp, COMDAT

; 28505: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 28506: 	if( source < 0 || source > MAX_INVENTORY-1 ) return FALSE;

  00009	83 7d 0c 00	 cmp	 DWORD PTR _source$[ebp], 0
  0000d	7c 06		 jl	 SHORT $LN3@gObjItemRa
  0000f	83 7d 0c 4b	 cmp	 DWORD PTR _source$[ebp], 75 ; 0000004bH
  00013	7e 07		 jle	 SHORT $LN2@gObjItemRa
$LN3@gObjItemRa:
  00015	33 c0		 xor	 eax, eax
  00017	e9 5b 05 00 00	 jmp	 $LN1@gObjItemRa
$LN2@gObjItemRa:

; 28507: 	if( target < 0 || target > MAX_INVENTORY-1 ) return FALSE;

  0001c	83 7d 10 00	 cmp	 DWORD PTR _target$[ebp], 0
  00020	7c 06		 jl	 SHORT $LN5@gObjItemRa
  00022	83 7d 10 4b	 cmp	 DWORD PTR _target$[ebp], 75 ; 0000004bH
  00026	7e 07		 jle	 SHORT $LN4@gObjItemRa
$LN5@gObjItemRa:
  00028	33 c0		 xor	 eax, eax
  0002a	e9 48 05 00 00	 jmp	 $LN1@gObjItemRa
$LN4@gObjItemRa:

; 28508: 
; 28509: 	//   
; 28510: 	if( lpObj->pInventory[source].IsItem() == FALSE ) return FALSE;

  0002f	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _source$[ebp], 168
  00036	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00039	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0003f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00044	85 c0		 test	 eax, eax
  00046	75 07		 jne	 SHORT $LN6@gObjItemRa
  00048	33 c0		 xor	 eax, eax
  0004a	e9 28 05 00 00	 jmp	 $LN1@gObjItemRa
$LN6@gObjItemRa:

; 28511: 	if( lpObj->pInventory[target].IsItem() == FALSE ) return FALSE;

  0004f	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00056	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00059	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0005f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00064	85 c0		 test	 eax, eax
  00066	75 07		 jne	 SHORT $LN7@gObjItemRa
  00068	33 c0		 xor	 eax, eax
  0006a	e9 08 05 00 00	 jmp	 $LN1@gObjItemRa
$LN7@gObjItemRa:

; 28512: 
; 28513: #ifdef ADD_THIRD_WING_20070525	// 3   
; 28514: 	if( ( lpObj->pInventory[target].m_Type >= MAKE_ITEMNUM( 12, 7 ) && lpObj->pInventory[target].m_Type < MAKE_ITEMNUM( 12, 36 ) ) || 
; 28515: #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//  1    
; 28516: 		( lpObj->pInventory[target].m_Type > MAKE_ITEMNUM( 12, 43 ) && lpObj->pInventory[target].m_Type != MAKE_ITEMNUM( 13, 30 ) ) || 		
; 28517: #else	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 28518: 		( lpObj->pInventory[target].m_Type > MAKE_ITEMNUM( 12, 40 ) && lpObj->pInventory[target].m_Type != MAKE_ITEMNUM( 13, 30 ) ) || 		
; 28519: #endif	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 28520: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 4, 7 ) ||
; 28521: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 4, 15 ) )
; 28522: 		return FALSE;			//    
; 28523: #else
; 28524: #ifdef DARKLORD_WORK
; 28525: 	if( (lpObj->pInventory[target].m_Type >= MAKE_ITEMNUM(12,7) && lpObj->pInventory[target].m_Type != MAKE_ITEMNUM(13,30)) || 
; 28526: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(4, 7) ||

  0006f	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00076	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00079	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0007f	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00084	6a 07		 push	 7
  00086	6a 0c		 push	 12			; 0000000cH
  00088	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0008d	83 c4 08	 add	 esp, 8
  00090	3b f0		 cmp	 esi, eax
  00092	7c 25		 jl	 SHORT $LN10@gObjItemRa
  00094	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0009e	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000a4	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000a9	6a 1e		 push	 30			; 0000001eH
  000ab	6a 0d		 push	 13			; 0000000dH
  000ad	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b2	83 c4 08	 add	 esp, 8
  000b5	3b f0		 cmp	 esi, eax
  000b7	75 4a		 jne	 SHORT $LN9@gObjItemRa
$LN10@gObjItemRa:
  000b9	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  000c0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000c3	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000c9	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000ce	6a 07		 push	 7
  000d0	6a 04		 push	 4
  000d2	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000d7	83 c4 08	 add	 esp, 8
  000da	3b f0		 cmp	 esi, eax
  000dc	74 25		 je	 SHORT $LN9@gObjItemRa
  000de	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  000e5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000e8	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000ee	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000f3	6a 0f		 push	 15			; 0000000fH
  000f5	6a 04		 push	 4
  000f7	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000fc	83 c4 08	 add	 esp, 8
  000ff	3b f0		 cmp	 esi, eax
  00101	75 07		 jne	 SHORT $LN8@gObjItemRa
$LN9@gObjItemRa:

; 28527: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(4, 15) )
; 28528: 		return FALSE;			//    

  00103	33 c0		 xor	 eax, eax
  00105	e9 6d 04 00 00	 jmp	 $LN1@gObjItemRa
$LN8@gObjItemRa:

; 28529: #else
; 28530: 	if( lpObj->pInventory[target].m_Type >= MAKE_ITEMNUM(12,7) || 
; 28531: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(4, 7) ||
; 28532: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(4, 15) )
; 28533: 		return FALSE;			//    
; 28534: #endif
; 28535: #endif	// ADD_THIRD_WING_20070525
; 28536: 
; 28537: 	//  +9 
; 28538: 	if( lpObj->pInventory[target].m_Level >= 9 ) 

  0010a	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00111	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00114	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0011a	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  0011f	83 f8 09	 cmp	 eax, 9
  00122	7c 07		 jl	 SHORT $LN11@gObjItemRa

; 28539: 	{
; 28540: 		return FALSE;

  00124	33 c0		 xor	 eax, eax
  00126	e9 4c 04 00 00	 jmp	 $LN1@gObjItemRa
$LN11@gObjItemRa:

; 28541: 	}
; 28542: 
; 28543: 	LogAddTD(lMsg.Get(558), lpObj->AccountID, lpObj->Name, lpObj->pInventory[target].GetName(), lpObj->pInventory[target].m_Number, lpObj->pInventory[target].m_Level);

  0012b	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00132	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00135	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0013b	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00140	50		 push	 eax
  00141	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00148	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0014b	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00151	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00154	51		 push	 ecx
  00155	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  0015c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0015f	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00165	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0016a	50		 push	 eax
  0016b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016e	83 c0 73	 add	 eax, 115		; 00000073H
  00171	50		 push	 eax
  00172	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00175	83 c1 68	 add	 ecx, 104		; 00000068H
  00178	51		 push	 ecx
  00179	68 2e 02 00 00	 push	 558			; 0000022eH
  0017e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00183	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00189	50		 push	 eax
  0018a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00190	83 c4 18	 add	 esp, 24			; 00000018H

; 28544: 	
; 28545: 	int _r=rand()%100;

  00193	e8 00 00 00 00	 call	 _rand
  00198	99		 cdq
  00199	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0019e	f7 f9		 idiv	 ecx
  001a0	89 55 fc	 mov	 DWORD PTR __r$[ebp], edx

; 28546: 	
; 28547: #ifdef MODIFY_ITEM_UPGRADE_MIX_RATE_FIX_20080627
; 28548: 	bool bSuccessUpgrade = false;
; 28549: 
; 28550: 	if( lpObj->pInventory[target].m_Option2 )
; 28551: 	{
; 28552: 		//     20% 
; 28553: #ifdef MODIFY_SEASON4_UPDATE_BUGFIX_01_20080722
; 28554: 		_r += g_GlobalConfig.m_iSoulRate-g_GlobalConfig.m_iSoulRateWithLuck;
; 28555: #else
; 28556: 		_r += g_GlobalConfig.m_iSoulRate-g_GlobalConfig.m_iSoulRateWithLuck;
; 28557: #endif // MODIFY_SEASON4_UPDATE_BUGFIX_01_20080722
; 28558: 	}
; 28559: 
; 28560: 	//         .
; 28561: 	// , , 380   50% 
; 28562: 	if( lpObj->pInventory[target].IsExtItem() == TRUE
; 28563: 		|| lpObj->pInventory[target].IsSetItem() == TRUE
; 28564: 		|| g_kItemSystemFor380.Is380OptionItem( &lpObj->pInventory[target] ) == TRUE 
; 28565: 	  )
; 28566: 	{
; 28567: 		if( _r < g_GlobalConfig.m_iSoulRate+10 )
; 28568: 		{
; 28569: 			bSuccessUpgrade = true;
; 28570: 		}
; 28571: 	}
; 28572: 	//    40%  
; 28573: #ifdef MODIFY_ITEM_SOCKET_OPTION_BUGFIX_02_20080630
; 28574: 	else if( g_SocketOptionSystem.IsSocketItem( &lpObj->pInventory[target] ) == true )
; 28575: #else
; 28576: 	else if( g_SocketOptionSystem.IsEnableSocketItem( &lpObj->pInventory[target] ) == true )
; 28577: #endif // MODIFY_ITEM_SOCKET_OPTION_BUGFIX_02_20080630
; 28578: 	{
; 28579: 		if( _r < g_GlobalConfig.m_iSoulRate )
; 28580: 		{
; 28581: 			bSuccessUpgrade = true;
; 28582: 		}
; 28583: 	}
; 28584: 	//    60%  
; 28585: 	else
; 28586: 	{
; 28587: 		if( _r < g_GlobalConfig.m_iSoulRate+20 )
; 28588: 		{
; 28589: 			bSuccessUpgrade = true;
; 28590: 		}
; 28591: 	}
; 28592: 
; 28593: 	if( bSuccessUpgrade == true )
; 28594: 	{
; 28595: 		lpObj->pInventory[target].m_Level++;
; 28596: 	}
; 28597: 	else
; 28598: 	{
; 28599: 		if( lpObj->pInventory[target].m_Level >= 7 )
; 28600: 		{
; 28601: 			lpObj->pInventory[target].m_Level = 0;
; 28602: 		}
; 28603: 		else
; 28604: 		{
; 28605: 			lpObj->pInventory[target].m_Level--;
; 28606: 			if( lpObj->pInventory[target].m_Level < 0 )
; 28607: 			{
; 28608: 				lpObj->pInventory[target].m_Level = 0;
; 28609: 			}
; 28610: 		}
; 28611: 	}
; 28612: #else
; 28613: 	
; 28614: 	if( lpObj->pInventory[target].m_Option2 )	//     ..

  001a3	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  001aa	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001ad	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  001b3	0f b6 44 02 79	 movzx	 eax, BYTE PTR [edx+eax+121]
  001b8	85 c0		 test	 eax, eax
  001ba	0f 84 d4 00 00
	00		 je	 $LN12@gObjItemRa

; 28615: 	{
; 28616: 		if( _r < g_GlobalConfig.m_iSoulRateWithLuck ) //  25%  20% 

  001c0	8b 45 fc	 mov	 eax, DWORD PTR __r$[ebp]
  001c3	3b 05 54 00 00
	00		 cmp	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+84
  001c9	7d 33		 jge	 SHORT $LN14@gObjItemRa

; 28617: 		{
; 28618: 			lpObj->pInventory[target].m_Level++;	

  001cb	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  001d2	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001d5	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  001db	66 8b 44 02 08	 mov	 ax, WORD PTR [edx+eax+8]
  001e0	66 83 c0 01	 add	 ax, 1
  001e4	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  001eb	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001ee	8b 92 5c 0c 00
	00		 mov	 edx, DWORD PTR [edx+3164]
  001f4	66 89 44 0a 08	 mov	 WORD PTR [edx+ecx+8], ax

; 28619: 		}		

  001f9	e9 91 00 00 00	 jmp	 $LN18@gObjItemRa
$LN14@gObjItemRa:

; 28620: 		else 
; 28621: 		{
; 28622: 			if( lpObj->pInventory[target].m_Level >= 7 )

  001fe	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00205	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00208	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0020e	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00213	83 f8 07	 cmp	 eax, 7
  00216	7c 19		 jl	 SHORT $LN16@gObjItemRa

; 28623: 			{
; 28624: 				lpObj->pInventory[target].m_Level = 0;

  00218	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  0021f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00222	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00228	33 c9		 xor	 ecx, ecx
  0022a	66 89 4c 02 08	 mov	 WORD PTR [edx+eax+8], cx

; 28625: 			}

  0022f	eb 5e		 jmp	 SHORT $LN18@gObjItemRa
$LN16@gObjItemRa:

; 28626: 			else
; 28627: 			{
; 28628: 
; 28629: 				lpObj->pInventory[target].m_Level--;

  00231	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00238	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0023b	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00241	66 8b 44 02 08	 mov	 ax, WORD PTR [edx+eax+8]
  00246	66 83 e8 01	 sub	 ax, 1
  0024a	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00251	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00254	8b 92 5c 0c 00
	00		 mov	 edx, DWORD PTR [edx+3164]
  0025a	66 89 44 0a 08	 mov	 WORD PTR [edx+ecx+8], ax

; 28630: 				if( lpObj->pInventory[target].m_Level < 0 ) 

  0025f	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00266	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00269	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0026f	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00274	85 c0		 test	 eax, eax
  00276	7d 17		 jge	 SHORT $LN18@gObjItemRa

; 28631: 					lpObj->pInventory[target].m_Level = 0;

  00278	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  0027f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00282	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00288	33 c9		 xor	 ecx, ecx
  0028a	66 89 4c 02 08	 mov	 WORD PTR [edx+eax+8], cx
$LN18@gObjItemRa:

; 28632: 			}
; 28633: 		}
; 28634: 	}

  0028f	e9 d0 00 00 00	 jmp	 $LN20@gObjItemRa
$LN12@gObjItemRa:

; 28635: 	else	// 
; 28636: 	{		
; 28637: 		if( _r >= g_GlobalConfig.m_iSoulRate )	// 55% 

  00294	8b 45 fc	 mov	 eax, DWORD PTR __r$[ebp]
  00297	3b 05 50 00 00
	00		 cmp	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+80
  0029d	0f 8c 93 00 00
	00		 jl	 $LN19@gObjItemRa

; 28638: 		{
; 28639: 			if( lpObj->pInventory[target].m_Level >= 7 )

  002a3	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  002aa	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002ad	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  002b3	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  002b8	83 f8 07	 cmp	 eax, 7
  002bb	7c 19		 jl	 SHORT $LN21@gObjItemRa

; 28640: 			{
; 28641: 				lpObj->pInventory[target].m_Level = 0;

  002bd	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  002c4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002c7	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  002cd	33 c9		 xor	 ecx, ecx
  002cf	66 89 4c 02 08	 mov	 WORD PTR [edx+eax+8], cx

; 28642: 			}

  002d4	eb 5e		 jmp	 SHORT $LN23@gObjItemRa
$LN21@gObjItemRa:

; 28643: 			else
; 28644: 			{
; 28645: 				lpObj->pInventory[target].m_Level--;

  002d6	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  002dd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002e0	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  002e6	66 8b 44 02 08	 mov	 ax, WORD PTR [edx+eax+8]
  002eb	66 83 e8 01	 sub	 ax, 1
  002ef	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  002f6	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002f9	8b 92 5c 0c 00
	00		 mov	 edx, DWORD PTR [edx+3164]
  002ff	66 89 44 0a 08	 mov	 WORD PTR [edx+ecx+8], ax

; 28646: 				if( lpObj->pInventory[target].m_Level < 0 ) 

  00304	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  0030b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0030e	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00314	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00319	85 c0		 test	 eax, eax
  0031b	7d 17		 jge	 SHORT $LN23@gObjItemRa

; 28647: 					lpObj->pInventory[target].m_Level = 0;

  0031d	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00324	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00327	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0032d	33 c9		 xor	 ecx, ecx
  0032f	66 89 4c 02 08	 mov	 WORD PTR [edx+eax+8], cx
$LN23@gObjItemRa:

; 28648: 			}
; 28649: 		}

  00334	eb 2e		 jmp	 SHORT $LN20@gObjItemRa
$LN19@gObjItemRa:

; 28650: 		else lpObj->pInventory[target].m_Level++;

  00336	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  0033d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00340	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00346	66 8b 44 02 08	 mov	 ax, WORD PTR [edx+eax+8]
  0034b	66 83 c0 01	 add	 ax, 1
  0034f	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00356	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00359	8b 92 5c 0c 00
	00		 mov	 edx, DWORD PTR [edx+3164]
  0035f	66 89 44 0a 08	 mov	 WORD PTR [edx+ecx+8], ax
$LN20@gObjItemRa:

; 28651: 	}
; 28652: #endif // MODIFY_ITEM_UPGRADE_MIX_RATE_FIX_20080627
; 28653: 	
; 28654: 	if( lpObj->pInventory[target].m_Level > 9 ) 

  00364	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  0036b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0036e	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00374	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00379	83 f8 09	 cmp	 eax, 9
  0037c	7e 1c		 jle	 SHORT $LN24@gObjItemRa

; 28655: 		lpObj->pInventory[target].m_Level = 9;

  0037e	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00385	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00388	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0038e	b9 09 00 00 00	 mov	 ecx, 9
  00393	66 89 4c 02 08	 mov	 WORD PTR [edx+eax+8], cx
  00398	eb 0e		 jmp	 SHORT $LN25@gObjItemRa
$LN24@gObjItemRa:

; 28656: 	else gObjMakePreviewCharSet(lpObj->m_Index);

  0039a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0039f	51		 push	 ecx
  003a0	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  003a5	83 c4 04	 add	 esp, 4
$LN25@gObjItemRa:

; 28657: 
; 28658: 	float levelitemdur =  (float)ItemGetDurability(lpObj->pInventory[target].m_Type, 

  003a8	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  003af	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003b2	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  003b8	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  003bd	50		 push	 eax
  003be	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  003c5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003c8	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  003ce	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  003d3	50		 push	 eax
  003d4	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  003db	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003de	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  003e4	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  003e9	50		 push	 eax
  003ea	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  003f1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003f4	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  003fa	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  003ff	51		 push	 ecx
  00400	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  00405	83 c4 10	 add	 esp, 16			; 00000010H
  00408	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0040c	f3 0f 11 45 f8	 movss	 DWORD PTR _levelitemdur$[ebp], xmm0

; 28659: 												   lpObj->pInventory[target].m_Level, 
; 28660: 												   lpObj->pInventory[target].IsExtItem(),
; 28661: 												   lpObj->pInventory[target].IsSetItem());
; 28662: 	
; 28663: 	lpObj->pInventory[target].m_Durability = levelitemdur*lpObj->pInventory[target].m_Durability/lpObj->pInventory[target].m_BaseDurability;

  00411	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00418	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0041b	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00421	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _levelitemdur$[ebp]
  00426	f3 0f 59 44 02
	24		 mulss	 xmm0, DWORD PTR [edx+eax+36]
  0042c	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00433	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00436	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0043c	f3 0f 5e 44 02
	2c		 divss	 xmm0, DWORD PTR [edx+eax+44]
  00442	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00449	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0044c	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00452	f3 0f 11 44 02
	24		 movss	 DWORD PTR [edx+eax+36], xmm0

; 28664: 
; 28665: 	//   	
; 28666: 	#ifdef ADD_380ITEM_NEWOPTION_20060711
; 28667: 		lpObj->pInventory[target].Convert(lpObj->pInventory[target].m_Type, 
; 28668: 										  lpObj->pInventory[target].m_Option1, 
; 28669: 										  lpObj->pInventory[target].m_Option2,
; 28670: 										  lpObj->pInventory[target].m_Option3,
; 28671: 										  lpObj->pInventory[target].m_NewOption,
; 28672: 										  lpObj->pInventory[target].m_SetOption,
; 28673: 										  lpObj->pInventory[target].m_ItemOptionEx);
; 28674: 	#else
; 28675: 		lpObj->pInventory[target].Convert(lpObj->pInventory[target].m_Type, 

  00458	6a 01		 push	 1
  0045a	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00461	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00464	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0046a	0f b6 84 02 92
	00 00 00	 movzx	 eax, BYTE PTR [edx+eax+146]
  00472	50		 push	 eax
  00473	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  0047a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0047d	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00483	0f b6 4c 08 7b	 movzx	 ecx, BYTE PTR [eax+ecx+123]
  00488	51		 push	 ecx
  00489	69 55 10 a8 00
	00 00		 imul	 edx, DWORD PTR _target$[ebp], 168
  00490	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00493	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00499	0f b6 54 11 7a	 movzx	 edx, BYTE PTR [ecx+edx+122]
  0049e	52		 push	 edx
  0049f	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  004a6	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004a9	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  004af	0f b6 44 02 79	 movzx	 eax, BYTE PTR [edx+eax+121]
  004b4	50		 push	 eax
  004b5	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  004bc	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004bf	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  004c5	0f b6 4c 08 78	 movzx	 ecx, BYTE PTR [eax+ecx+120]
  004ca	51		 push	 ecx
  004cb	69 55 10 a8 00
	00 00		 imul	 edx, DWORD PTR _target$[ebp], 168
  004d2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004d5	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  004db	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  004e0	52		 push	 edx
  004e1	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  004e8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004eb	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  004f1	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 28676: 										  lpObj->pInventory[target].m_Option1, 
; 28677: 										  lpObj->pInventory[target].m_Option2,
; 28678: 										  lpObj->pInventory[target].m_Option3,
; 28679: 										  lpObj->pInventory[target].m_NewOption,
; 28680: 										  lpObj->pInventory[target].m_SetOption);
; 28681: 	#endif // ADD_380ITEM_NEWOPTION_20060711
; 28682: 
; 28683: 	LogAddTD(lMsg.Get(559),  

  004f6	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  004fd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00500	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00506	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  0050b	50		 push	 eax
  0050c	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00513	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00516	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0051c	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0051f	51		 push	 ecx
  00520	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00527	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0052a	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00530	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00535	50		 push	 eax
  00536	69 45 0c a8 00
	00 00		 imul	 eax, DWORD PTR _source$[ebp], 168
  0053d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00540	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00546	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00549	50		 push	 eax
  0054a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0054d	83 c1 73	 add	 ecx, 115		; 00000073H
  00550	51		 push	 ecx
  00551	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00554	83 c2 68	 add	 edx, 104		; 00000068H
  00557	52		 push	 edx
  00558	68 2f 02 00 00	 push	 559			; 0000022fH
  0055d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00562	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00568	50		 push	 eax
  00569	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0056f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 28684: 			 lpObj->AccountID, 
; 28685: 			 lpObj->Name, 
; 28686: 			 lpObj->pInventory[source].m_Number,
; 28687: 			 lpObj->pInventory[target].GetName(), 
; 28688: 			 lpObj->pInventory[target].m_Number, 
; 28689: 			 lpObj->pInventory[target].m_Level);
; 28690: 
; 28691: #ifdef ADD_JEWEL_OF_HARMONY_WTFMESSAGE_20060818
; 28692: 	//      ,  
; 28693: 	if ( g_kJewelOfHarmonySystem.IsStrengthenByJewelOfHarmony( &lpObj->pInventory[target] ) == TRUE )
; 28694: 	{
; 28695: 		if ( g_kJewelOfHarmonySystem.IsActive( &lpObj->pInventory[target] ) == FALSE )
; 28696: 		{
; 28697: 			GCServerMsgStringSend(lMsg.Get(3370), lpObj->m_Index, 1); //          .
; 28698: 		}
; 28699: 	}
; 28700: #endif
; 28701: 
; 28702: 	return TRUE;

  00572	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjItemRa:

; 28703: }

  00577	5f		 pop	 edi
  00578	5e		 pop	 esi
  00579	5b		 pop	 ebx
  0057a	8b e5		 mov	 esp, ebp
  0057c	5d		 pop	 ebp
  0057d	c3		 ret	 0
?gObjItemRandomLevelUp@@YAHPAVOBJECTSTRUCT@@HH@Z ENDP	; gObjItemRandomLevelUp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjItemLevelUp@@YAHPAVOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_levelitemdur$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_source$ = 12						; size = 4
_target$ = 16						; size = 4
?gObjItemLevelUp@@YAHPAVOBJECTSTRUCT@@HH@Z PROC		; gObjItemLevelUp, COMDAT

; 28388: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 28389: 	if( source < 0 || source > MAX_INVENTORY-1 ) return FALSE;

  00009	83 7d 0c 00	 cmp	 DWORD PTR _source$[ebp], 0
  0000d	7c 06		 jl	 SHORT $LN3@gObjItemLe
  0000f	83 7d 0c 4b	 cmp	 DWORD PTR _source$[ebp], 75 ; 0000004bH
  00013	7e 07		 jle	 SHORT $LN2@gObjItemLe
$LN3@gObjItemLe:
  00015	33 c0		 xor	 eax, eax
  00017	e9 94 03 00 00	 jmp	 $LN1@gObjItemLe
$LN2@gObjItemLe:

; 28390: 	if( target < 0 || target > MAX_INVENTORY-1 ) return FALSE;

  0001c	83 7d 10 00	 cmp	 DWORD PTR _target$[ebp], 0
  00020	7c 06		 jl	 SHORT $LN5@gObjItemLe
  00022	83 7d 10 4b	 cmp	 DWORD PTR _target$[ebp], 75 ; 0000004bH
  00026	7e 07		 jle	 SHORT $LN4@gObjItemLe
$LN5@gObjItemLe:
  00028	33 c0		 xor	 eax, eax
  0002a	e9 81 03 00 00	 jmp	 $LN1@gObjItemLe
$LN4@gObjItemLe:

; 28391: 
; 28392: 	//   
; 28393: 	if( lpObj->pInventory[source].IsItem() == FALSE ) return FALSE;

  0002f	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _source$[ebp], 168
  00036	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00039	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0003f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00044	85 c0		 test	 eax, eax
  00046	75 07		 jne	 SHORT $LN6@gObjItemLe
  00048	33 c0		 xor	 eax, eax
  0004a	e9 61 03 00 00	 jmp	 $LN1@gObjItemLe
$LN6@gObjItemLe:

; 28394: 	if( lpObj->pInventory[target].IsItem() == FALSE ) return FALSE;

  0004f	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00056	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00059	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0005f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00064	85 c0		 test	 eax, eax
  00066	75 07		 jne	 SHORT $LN7@gObjItemLe
  00068	33 c0		 xor	 eax, eax
  0006a	e9 41 03 00 00	 jmp	 $LN1@gObjItemLe
$LN7@gObjItemLe:

; 28395: 
; 28396: #ifdef ADD_ITEM_FENRIR_01_20051110
; 28397: 	//    ,   .
; 28398: 	if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(13,37) )
; 28399: 	{
; 28400: 		CItem &ItemFenrir = lpObj->pInventory[target];
; 28401: 		
; 28402: 		if( ItemFenrir.m_Durability >= 255 )
; 28403: 			return FALSE;
; 28404: 
; 28405: 		if( rand()%10000 < g_iFenrirRepairRate )
; 28406: 		{
; 28407: 			int iAddDur = 50 + rand()%150;
; 28408: 
; 28409: 			if( iAddDur + ItemFenrir.m_Durability > 255 )
; 28410: 				ItemFenrir.m_Durability = 255;
; 28411: 			else
; 28412: 				ItemFenrir.m_Durability += iAddDur;
; 28413: 
; 28414: 			// MODIFY_LOCALIZING_WTF_20060309  wtf   0.99.60 - 0.99.94
; 28415: 			MsgOutput( lpObj->m_Index, lMsg.Get(3342) , (int)ItemFenrir.m_Durability );			// "  %d  ."
; 28416: #ifdef EXTEND_LOG_SYSTEM_20060202
; 28417: 			LogAddTD("[FENRIR REPAIR][SUCCESS] [%s][%s] - %d/255 (+%d)",
; 28418: 				lpObj->AccountID, lpObj->Name, ItemFenrir.m_Durability, iAddDur);
; 28419: #endif
; 28420: 		}
; 28421: 		else
; 28422: 		{
; 28423: 			// MODIFY_LOCALIZING_WTF_20060309  wtf   0.99.60 - 0.99.94
; 28424: 			MsgOutput( lpObj->m_Index, lMsg.Get(3343) );			// "    ."
; 28425: #ifdef EXTEND_LOG_SYSTEM_20060202
; 28426: 			LogAddTD("[FENRIR REPAIR][FAILED] [%s][%s] - %d/255 (+%d)",
; 28427: 				lpObj->AccountID, lpObj->Name, ItemFenrir.m_Durability);
; 28428: #endif
; 28429: 		}
; 28430: 		
; 28431: 		return TRUE;
; 28432: 	}
; 28433: #endif // ADD_ITEM_FENRIR_01_20051110
; 28434: 
; 28435: #ifdef ADD_THIRD_WING_20070525	// 3   
; 28436: 	if( ( lpObj->pInventory[target].m_Type >= MAKE_ITEMNUM( 12, 7 ) && lpObj->pInventory[target].m_Type < MAKE_ITEMNUM( 12, 36 ) ) || 
; 28437: #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//  1    
; 28438: 		( lpObj->pInventory[target].m_Type > MAKE_ITEMNUM( 12, 43 ) && lpObj->pInventory[target].m_Type != MAKE_ITEMNUM( 13, 30 ) ) || 		
; 28439: #else	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912		
; 28440: 		( lpObj->pInventory[target].m_Type > MAKE_ITEMNUM( 12, 40 ) && lpObj->pInventory[target].m_Type != MAKE_ITEMNUM( 13, 30 ) ) || 		
; 28441: #endif	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 28442: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 4, 7 ) ||
; 28443: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 4, 15 ) )
; 28444: 		return FALSE;			//    
; 28445: #else
; 28446: #ifdef DARKLORD_WORK
; 28447: 	if( (lpObj->pInventory[target].m_Type >= MAKE_ITEMNUM(12,7) && lpObj->pInventory[target].m_Type != MAKE_ITEMNUM(13,30)) || 
; 28448: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(4, 7) ||

  0006f	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00076	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00079	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0007f	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00084	6a 07		 push	 7
  00086	6a 0c		 push	 12			; 0000000cH
  00088	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0008d	83 c4 08	 add	 esp, 8
  00090	3b f0		 cmp	 esi, eax
  00092	7c 25		 jl	 SHORT $LN10@gObjItemLe
  00094	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0009e	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000a4	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000a9	6a 1e		 push	 30			; 0000001eH
  000ab	6a 0d		 push	 13			; 0000000dH
  000ad	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b2	83 c4 08	 add	 esp, 8
  000b5	3b f0		 cmp	 esi, eax
  000b7	75 4a		 jne	 SHORT $LN9@gObjItemLe
$LN10@gObjItemLe:
  000b9	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  000c0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000c3	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000c9	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000ce	6a 07		 push	 7
  000d0	6a 04		 push	 4
  000d2	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000d7	83 c4 08	 add	 esp, 8
  000da	3b f0		 cmp	 esi, eax
  000dc	74 25		 je	 SHORT $LN9@gObjItemLe
  000de	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  000e5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000e8	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000ee	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000f3	6a 0f		 push	 15			; 0000000fH
  000f5	6a 04		 push	 4
  000f7	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000fc	83 c4 08	 add	 esp, 8
  000ff	3b f0		 cmp	 esi, eax
  00101	75 07		 jne	 SHORT $LN8@gObjItemLe
$LN9@gObjItemLe:

; 28449: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(4, 15) )
; 28450: 		return FALSE;			//    

  00103	33 c0		 xor	 eax, eax
  00105	e9 a6 02 00 00	 jmp	 $LN1@gObjItemLe
$LN8@gObjItemLe:

; 28451: #else
; 28452: 	if( lpObj->pInventory[target].m_Type >= MAKE_ITEMNUM(12,7) || 
; 28453: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(4, 7) ||
; 28454: 		lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(4, 15) )
; 28455: 		return FALSE;			//    
; 28456: #endif
; 28457: #endif	// ADD_THIRD_WING_20070525	
; 28458: 
; 28459: 	LogAddTD(lMsg.Get(556), lpObj->AccountID, lpObj->Name, lpObj->pInventory[target].GetName(), lpObj->pInventory[target].m_Number, lpObj->pInventory[target].m_Level);

  0010a	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00111	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00114	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0011a	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  0011f	50		 push	 eax
  00120	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00127	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0012a	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00130	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00133	51		 push	 ecx
  00134	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  0013b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0013e	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00144	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00149	50		 push	 eax
  0014a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014d	83 c0 73	 add	 eax, 115		; 00000073H
  00150	50		 push	 eax
  00151	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00154	83 c1 68	 add	 ecx, 104		; 00000068H
  00157	51		 push	 ecx
  00158	68 2c 02 00 00	 push	 556			; 0000022cH
  0015d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00162	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00168	50		 push	 eax
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0016f	83 c4 18	 add	 esp, 24			; 00000018H

; 28460: 
; 28461: 	lpObj->pInventory[target].m_Level+=1;

  00172	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00179	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0017c	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00182	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00187	83 c0 01	 add	 eax, 1
  0018a	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00191	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00194	8b 92 5c 0c 00
	00		 mov	 edx, DWORD PTR [edx+3164]
  0019a	66 89 44 0a 08	 mov	 WORD PTR [edx+ecx+8], ax

; 28462: 	if( lpObj->pInventory[target].m_Level > 6 ) 

  0019f	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  001a6	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001a9	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  001af	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  001b4	83 f8 06	 cmp	 eax, 6
  001b7	7e 1a		 jle	 SHORT $LN11@gObjItemLe

; 28463: 	{
; 28464: 		lpObj->pInventory[target].m_Level = 6;

  001b9	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  001c0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001c3	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  001c9	b9 06 00 00 00	 mov	 ecx, 6
  001ce	66 89 4c 02 08	 mov	 WORD PTR [edx+eax+8], cx
$LN11@gObjItemLe:

; 28465: 	}
; 28466: 	gObjMakePreviewCharSet(lpObj->m_Index);

  001d3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d8	51		 push	 ecx
  001d9	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  001de	83 c4 04	 add	 esp, 4

; 28467: 
; 28468: 	float levelitemdur =  (float)ItemGetDurability(lpObj->pInventory[target].m_Type, 

  001e1	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  001e8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001eb	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  001f1	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  001f6	50		 push	 eax
  001f7	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  001fe	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00201	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00207	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  0020c	50		 push	 eax
  0020d	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00214	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00217	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0021d	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00222	50		 push	 eax
  00223	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  0022a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0022d	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00233	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  00238	51		 push	 ecx
  00239	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  0023e	83 c4 10	 add	 esp, 16			; 00000010H
  00241	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00245	f3 0f 11 45 fc	 movss	 DWORD PTR _levelitemdur$[ebp], xmm0

; 28469: 												   lpObj->pInventory[target].m_Level, 
; 28470: 												   lpObj->pInventory[target].IsExtItem(),
; 28471: 												   lpObj->pInventory[target].IsSetItem());
; 28472: 	
; 28473: 	lpObj->pInventory[target].m_Durability = levelitemdur*lpObj->pInventory[target].m_Durability/lpObj->pInventory[target].m_BaseDurability;

  0024a	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00251	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00254	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0025a	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _levelitemdur$[ebp]
  0025f	f3 0f 59 44 02
	24		 mulss	 xmm0, DWORD PTR [edx+eax+36]
  00265	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  0026c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0026f	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00275	f3 0f 5e 44 02
	2c		 divss	 xmm0, DWORD PTR [edx+eax+44]
  0027b	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00282	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00285	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0028b	f3 0f 11 44 02
	24		 movss	 DWORD PTR [edx+eax+36], xmm0

; 28474: 	//   	
; 28475: 
; 28476: 	#ifdef ADD_380ITEM_NEWOPTION_20060711
; 28477: 		lpObj->pInventory[target].Convert(lpObj->pInventory[target].m_Type, 
; 28478: 										  lpObj->pInventory[target].m_Option1, 
; 28479: 										  lpObj->pInventory[target].m_Option2,
; 28480: 										  lpObj->pInventory[target].m_Option3,
; 28481: 										  lpObj->pInventory[target].m_NewOption,
; 28482: 										  lpObj->pInventory[target].m_SetOption,
; 28483: 										  lpObj->pInventory[target].m_ItemOptionEx);
; 28484: 	#else
; 28485: 		lpObj->pInventory[target].Convert(lpObj->pInventory[target].m_Type, 

  00291	6a 01		 push	 1
  00293	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  0029a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0029d	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  002a3	0f b6 84 02 92
	00 00 00	 movzx	 eax, BYTE PTR [edx+eax+146]
  002ab	50		 push	 eax
  002ac	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  002b3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002b6	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  002bc	0f b6 4c 08 7b	 movzx	 ecx, BYTE PTR [eax+ecx+123]
  002c1	51		 push	 ecx
  002c2	69 55 10 a8 00
	00 00		 imul	 edx, DWORD PTR _target$[ebp], 168
  002c9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002cc	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  002d2	0f b6 54 11 7a	 movzx	 edx, BYTE PTR [ecx+edx+122]
  002d7	52		 push	 edx
  002d8	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  002df	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002e2	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  002e8	0f b6 44 02 79	 movzx	 eax, BYTE PTR [edx+eax+121]
  002ed	50		 push	 eax
  002ee	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  002f5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002f8	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  002fe	0f b6 4c 08 78	 movzx	 ecx, BYTE PTR [eax+ecx+120]
  00303	51		 push	 ecx
  00304	69 55 10 a8 00
	00 00		 imul	 edx, DWORD PTR _target$[ebp], 168
  0030b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030e	8b 88 5c 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3164]
  00314	0f bf 54 11 06	 movsx	 edx, WORD PTR [ecx+edx+6]
  00319	52		 push	 edx
  0031a	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00321	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00324	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0032a	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 28486: 										  lpObj->pInventory[target].m_Option1, 
; 28487: 										  lpObj->pInventory[target].m_Option2,
; 28488: 										  lpObj->pInventory[target].m_Option3,
; 28489: 										  lpObj->pInventory[target].m_NewOption,
; 28490: 										  lpObj->pInventory[target].m_SetOption);
; 28491: 	#endif // ADD_380ITEM_NEWOPTION_20060711
; 28492: 
; 28493: 	LogAddTD(lMsg.Get(557),

  0032f	69 45 10 a8 00
	00 00		 imul	 eax, DWORD PTR _target$[ebp], 168
  00336	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00339	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0033f	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00344	50		 push	 eax
  00345	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  0034c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0034f	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00355	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00358	51		 push	 ecx
  00359	69 4d 10 a8 00
	00 00		 imul	 ecx, DWORD PTR _target$[ebp], 168
  00360	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00363	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00369	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  0036e	50		 push	 eax
  0036f	69 45 0c a8 00
	00 00		 imul	 eax, DWORD PTR _source$[ebp], 168
  00376	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00379	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0037f	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00382	50		 push	 eax
  00383	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00386	83 c1 73	 add	 ecx, 115		; 00000073H
  00389	51		 push	 ecx
  0038a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0038d	83 c2 68	 add	 edx, 104		; 00000068H
  00390	52		 push	 edx
  00391	68 2d 02 00 00	 push	 557			; 0000022dH
  00396	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0039b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  003a1	50		 push	 eax
  003a2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003a8	83 c4 1c	 add	 esp, 28			; 0000001cH

; 28494: 			 lpObj->AccountID, 
; 28495: 			 lpObj->Name, 
; 28496: 			 lpObj->pInventory[source].m_Number,
; 28497: 			 lpObj->pInventory[target].GetName(), 
; 28498: 			 lpObj->pInventory[target].m_Number, 
; 28499: 			 lpObj->pInventory[target].m_Level);
; 28500: 	return TRUE;

  003ab	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjItemLe:

; 28501: }

  003b0	5f		 pop	 edi
  003b1	5e		 pop	 esi
  003b2	5b		 pop	 ebx
  003b3	8b e5		 mov	 esp, ebp
  003b5	5d		 pop	 ebp
  003b6	c3		 ret	 0
?gObjItemLevelUp@@YAHPAVOBJECTSTRUCT@@HH@Z ENDP		; gObjItemLevelUp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryCommit@@YAHH@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv67 = -72						; size = 4
_n$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjInventoryCommit@@YAHH@Z PROC			; gObjInventoryCommit, COMDAT

; 14605: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14606: 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT) )

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN10@gObjInvent
  0000f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN11@gObjInvent
$LN10@gObjInvent:
  00018	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN8@gObjInvent
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN9@gObjInvent
$LN8@gObjInvent:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN9@gObjInvent:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN11@gObjInvent:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 23		 jne	 SHORT $LN5@gObjInvent

; 14607: 	{
; 14608: 		LogAddTD("error : gObjInventoryCommit() - aIndex out of bound %s %d",__FILE__, __LINE__);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryCommit@@YAHH@Z@4JA
  00042	83 c0 03	 add	 eax, 3
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@NFIOKOGL@error?5?3?5gObjInventoryCommit?$CI?$CJ?5?9@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14609: 		return FALSE;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 70 01 00 00	 jmp	 $LN1@gObjInvent
$LN5@gObjInvent:

; 14610: 	}
; 14611: 	int n;
; 14612: 
; 14613: #ifdef INVENTORY_CLEAR_BUGFIX_20050226
; 14614: 	if( gObj[aIndex].pTransaction != 1 )	//      

  00060	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006d	0f be 94 01 68
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3176]
  00075	83 fa 01	 cmp	 edx, 1
  00078	74 4f		 je	 SHORT $LN6@gObjInvent

; 14615: 	{
; 14616: 		LogAddTD("[%s][%s] error-L3 : pTransaction(%d) status2", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].pTransaction);

  0007a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00087	0f be 94 01 68
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3176]
  0008f	52		 push	 edx
  00090	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009d	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000a1	52		 push	 edx
  000a2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000af	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000b3	52		 push	 edx
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@FHLLPNOD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransactio@
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000bf	83 c4 10	 add	 esp, 16			; 00000010H

; 14617: 		return FALSE;

  000c2	33 c0		 xor	 eax, eax
  000c4	e9 07 01 00 00	 jmp	 $LN1@gObjInvent
$LN6@gObjInvent:

; 14618: 	}
; 14619: #else
; 14620: 	if( gObj[aIndex].pTransaction == 0 ) 
; 14621: 	{
; 14622: 		LogAddTD("[%s][%s] error-L3 : pTransaction(%d) status error %s %d", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].pTransaction, __FILE__, __LINE__);
; 14623: 		return FALSE;
; 14624: 	}
; 14625: 	if( gObj[aIndex].pTransaction == 2 )
; 14626: 	{
; 14627: 		LogAddTD("[%s][%s] error-L3 : pTransaction(%d) status2", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].pTransaction);
; 14628: 		return TRUE;
; 14629: 	}
; 14630: #endif	
; 14631: 
; 14632: #ifdef PERSONAL_SHOP_20040113		//       ->    
; 14633: //	for( n=0; n<MAX_INVENTORY_EXTEND; n++)
; 14634: 	for( n=0; n<MAX_INVENTORY; n++)

  000c9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN4@gObjInvent
$LN2@gObjInvent:
  000d2	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjInvent:
  000db	83 7d fc 4c	 cmp	 DWORD PTR _n$[ebp], 76	; 0000004cH
  000df	7d 43		 jge	 SHORT $LN3@gObjInvent

; 14635: #else
; 14636: 	for( n=0; n<MAX_INVENTORY; n++)
; 14637: #endif
; 14638: 	{
; 14639: 		gObj[aIndex].Inventory1[n] = gObj[aIndex].Inventory2[n];

  000e1	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e8	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 168
  000ef	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f5	8b b4 02 78 0c
	00 00		 mov	 esi, DWORD PTR [edx+eax+3192]
  000fc	03 f1		 add	 esi, ecx
  000fe	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00105	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 168
  0010c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00112	8b bc 02 6c 0c
	00 00		 mov	 edi, DWORD PTR [edx+eax+3180]
  00119	03 f9		 add	 edi, ecx
  0011b	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00120	f3 a5		 rep movsd

; 14640: 	}

  00122	eb ae		 jmp	 SHORT $LN2@gObjInvent
$LN3@gObjInvent:

; 14641: 	memcpy(gObj[aIndex].InventoryMap1, gObj[aIndex].InventoryMap2, MAX_INVENTORYMAP);

  00124	6a 40		 push	 64			; 00000040H
  00126	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0012d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00133	8b 94 01 7c 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3196]
  0013a	52		 push	 edx
  0013b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00142	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00148	8b 94 01 70 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3184]
  0014f	52		 push	 edx
  00150	e8 00 00 00 00	 call	 _memcpy
  00155	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14642: 	gObj[aIndex].InventoryCount1 = gObj[aIndex].InventoryCount2;

  00158	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0015f	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00166	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00172	8a 84 06 80 0c
	00 00		 mov	 al, BYTE PTR [esi+eax+3200]
  00179	88 84 0a 74 0c
	00 00		 mov	 BYTE PTR [edx+ecx+3188], al

; 14643: 	gObjSetInventory1Pointer(&gObj[aIndex]);

  00180	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00187	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018d	50		 push	 eax
  0018e	e8 00 00 00 00	 call	 ?gObjSetInventory1Pointer@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer
  00193	83 c4 04	 add	 esp, 4

; 14644: 	gObj[aIndex].pTransaction = 2;

  00196	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0019d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001a3	c6 84 01 68 0c
	00 00 02	 mov	 BYTE PTR [ecx+eax+3176], 2

; 14645: 	
; 14646: 	LogAddL("Trade Commit (%s)", gObj[aIndex].Name );

  001ab	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b8	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  001bc	52		 push	 edx
  001bd	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PKOGNFCH@Trade?5Commit?5?$CI?$CFs?$CJ@
  001c2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  001c8	83 c4 08	 add	 esp, 8

; 14647: 
; 14648: 	return TRUE;

  001cb	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjInvent:

; 14649: }

  001d0	5f		 pop	 edi
  001d1	5e		 pop	 esi
  001d2	5b		 pop	 ebx
  001d3	8b e5		 mov	 esp, ebp
  001d5	5d		 pop	 ebp
  001d6	c3		 ret	 0
?gObjInventoryCommit@@YAHH@Z ENDP			; gObjInventoryCommit
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryTrans@@YAHH@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv67 = -72						; size = 4
_n$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjInventoryTrans@@YAHH@Z PROC			; gObjInventoryTrans, COMDAT

; 14559: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14560: 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT) )

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN13@gObjInvent
  0000f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN14@gObjInvent
$LN13@gObjInvent:
  00018	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN11@gObjInvent
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN12@gObjInvent
$LN11@gObjInvent:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN12@gObjInvent:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN14@gObjInvent:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 23		 jne	 SHORT $LN8@gObjInvent

; 14561: 	{
; 14562: 		LogAdd("error : %s %d",__FILE__, __LINE__);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryTrans@@YAHH@Z@4JA
  00042	83 c0 03	 add	 eax, 3
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14563: 		return FALSE;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 d2 01 00 00	 jmp	 $LN1@gObjInvent
$LN8@gObjInvent:

; 14564: 	}
; 14565: 	int n;
; 14566: 
; 14567: 	if( gObj[aIndex].pTransaction == 1 )	//  .  

  00060	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006d	0f be 94 01 68
	0c 00 00	 movsx	 edx, BYTE PTR [ecx+eax+3176]
  00075	83 fa 01	 cmp	 edx, 1
  00078	75 5d		 jne	 SHORT $LN9@gObjInvent

; 14568: 	{
; 14569: 		LogAddTD("[%s][%s] error-L3 : pTransaction(%d) status error %s %d", gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].pTransaction, __FILE__, __LINE__);

  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryTrans@@YAHH@Z@4JA
  0007f	83 c0 0a	 add	 eax, 10			; 0000000aH
  00082	50		 push	 eax
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00088	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0008f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00095	0f be 84 0a 68
	0c 00 00	 movsx	 eax, BYTE PTR [edx+ecx+3176]
  0009d	50		 push	 eax
  0009e	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  000a5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ab	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  000af	50		 push	 eax
  000b0	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  000b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bd	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  000c1	50		 push	 eax
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@CKMLLKAG@?$FL?$CFs?$FN?$FL?$CFs?$FN?5error?9L3?5?3?5pTransactio@
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000cd	83 c4 18	 add	 esp, 24			; 00000018H

; 14570: #ifdef ITEMCOPY_BUGFIX_20040112
; 14571: //		gObj[aIndex].pTransaction = 0;
; 14572: 		//gObjInventoryRollback(aIndex);
; 14573: 		return FALSE;

  000d0	33 c0		 xor	 eax, eax
  000d2	e9 5b 01 00 00	 jmp	 $LN1@gObjInvent
$LN9@gObjInvent:

; 14574: #endif
; 14575: 	}
; 14576: 	
; 14577: 	for( n=0; n<MAX_MAGIC; n++)

  000d7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  000de	eb 09		 jmp	 SHORT $LN4@gObjInvent
$LN2@gObjInvent:
  000e0	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000e3	83 c0 01	 add	 eax, 1
  000e6	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjInvent:
  000e9	83 7d fc 3c	 cmp	 DWORD PTR _n$[ebp], 60	; 0000003cH
  000ed	7d 3c		 jge	 SHORT $LN3@gObjInvent

; 14578: 	{
; 14579: 		gObj[aIndex].m_lpMagicBack[n] = gObj[aIndex].Magic[n];

  000ef	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f6	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  000f9	c1 e1 04	 shl	 ecx, 4
  000fc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00102	03 8c 02 10 03
	00 00		 add	 ecx, DWORD PTR [edx+eax+784]
  00109	51		 push	 ecx
  0010a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00111	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  00114	c1 e1 04	 shl	 ecx, 4
  00117	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011d	03 8c 02 0c 03
	00 00		 add	 ecx, DWORD PTR [edx+eax+780]
  00124	e8 00 00 00 00	 call	 ??4CMagicInf@@QAEAAV0@ABV0@@Z

; 14580: 	}

  00129	eb b5		 jmp	 SHORT $LN2@gObjInvent
$LN3@gObjInvent:

; 14581: #ifdef PERSONAL_SHOP_20040113		//       ->     (   )
; 14582: #ifdef CHAOS_MIX_TRANSACTION_BUXFIX_20040610		//       .
; 14583: 	for( n=0; n<MAX_INVENTORY; n++)

  0012b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00132	eb 09		 jmp	 SHORT $LN7@gObjInvent
$LN5@gObjInvent:
  00134	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00137	83 c0 01	 add	 eax, 1
  0013a	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN7@gObjInvent:
  0013d	83 7d fc 4c	 cmp	 DWORD PTR _n$[ebp], 76	; 0000004cH
  00141	7d 43		 jge	 SHORT $LN6@gObjInvent

; 14584: #else
; 14585: 	for( n=0; n<MAX_INVENTORY_EXTEND; n++)
; 14586: #endif	
; 14587: #else
; 14588: 	for( n=0; n<MAX_INVENTORY; n++)
; 14589: #endif
; 14590: 	{
; 14591: 		gObj[aIndex].Inventory2[n] = gObj[aIndex].Inventory1[n];

  00143	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0014a	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 168
  00151	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00157	8b b4 02 6c 0c
	00 00		 mov	 esi, DWORD PTR [edx+eax+3180]
  0015e	03 f1		 add	 esi, ecx
  00160	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00167	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 168
  0016e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00174	8b bc 02 78 0c
	00 00		 mov	 edi, DWORD PTR [edx+eax+3192]
  0017b	03 f9		 add	 edi, ecx
  0017d	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00182	f3 a5		 rep movsd

; 14592: 	}

  00184	eb ae		 jmp	 SHORT $LN5@gObjInvent
$LN6@gObjInvent:

; 14593: 	memcpy(gObj[aIndex].InventoryMap2, gObj[aIndex].InventoryMap1, MAX_INVENTORYMAP);

  00186	6a 40		 push	 64			; 00000040H
  00188	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0018f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00195	8b 94 01 70 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3184]
  0019c	52		 push	 edx
  0019d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001aa	8b 94 01 7c 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3196]
  001b1	52		 push	 edx
  001b2	e8 00 00 00 00	 call	 _memcpy
  001b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14594: 	gObj[aIndex].InventoryCount2 = gObj[aIndex].InventoryCount1;

  001ba	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001c1	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001c8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ce	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d4	8a 84 06 74 0c
	00 00		 mov	 al, BYTE PTR [esi+eax+3188]
  001db	88 84 0a 80 0c
	00 00		 mov	 BYTE PTR [edx+ecx+3200], al

; 14595: 	gObjSetInventory2Pointer(&gObj[aIndex]);

  001e2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001e9	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 ?gObjSetInventory2Pointer@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSetInventory2Pointer
  001f5	83 c4 04	 add	 esp, 4

; 14596: 	gObj[aIndex].pTransaction = 1;

  001f8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00205	c6 84 01 68 0c
	00 00 01	 mov	 BYTE PTR [ecx+eax+3176], 1

; 14597: 	
; 14598: 	LogAddL("Trade Transaction (%s)", gObj[aIndex].Name );

  0020d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00214	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0021a	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0021e	52		 push	 edx
  0021f	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@NHBCKBPB@Trade?5Transaction?5?$CI?$CFs?$CJ@
  00224	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  0022a	83 c4 08	 add	 esp, 8

; 14599: 	return TRUE;

  0022d	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjInvent:

; 14600: }

  00232	5f		 pop	 edi
  00233	5e		 pop	 esi
  00234	5b		 pop	 ebx
  00235	8b e5		 mov	 esp, ebp
  00237	5d		 pop	 ebp
  00238	c3		 ret	 0
?gObjInventoryTrans@@YAHH@Z ENDP			; gObjInventoryTrans
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_itembuf$1 = -36					; size = 5
_blank$ = -28						; size = 4
_s_num$ = -24						; size = 4
_iheight$ = -20						; size = 4
_iwidth$ = -16						; size = 4
_w$ = -12						; size = 4
_h$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_source$ = 12						; size = 1
_target$ = 16						; size = 1
?gObjInventoryTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z PROC	; gObjInventoryTradeMove, COMDAT

; 18723: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 18724: 	int h, w;
; 18725: 	int iwidth, iheight;
; 18726: 
; 18727: 	if( source > MAX_INVENTORY )

  00013	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00017	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  0001a	7e 23		 jle	 SHORT $LN2@gObjInvent

; 18728: 	{
; 18729: 		LogAdd("error : %s %d", __FILE__, __LINE__);

  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z@4JA
  00021	83 c0 06	 add	 eax, 6
  00024	50		 push	 eax
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18730: 		return 0xFF;

  00038	0c ff		 or	 al, 255			; 000000ffH
  0003a	e9 68 04 00 00	 jmp	 $LN1@gObjInvent
$LN2@gObjInvent:

; 18731: 	}
; 18732: 	
; 18733: 	//   ?
; 18734: 	if( lpObj->pInventory[source].IsItem() == FALSE )

  0003f	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00043	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  00049	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0004c	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00052	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00057	85 c0		 test	 eax, eax
  00059	75 07		 jne	 SHORT $LN3@gObjInvent

; 18735: 	{
; 18736: 		return 0xFF;

  0005b	0c ff		 or	 al, 255			; 000000ffH
  0005d	e9 45 04 00 00	 jmp	 $LN1@gObjInvent
$LN3@gObjInvent:

; 18737: 	}
; 18738: 
; 18739: 	if(g_GlobalConfig.m_bLimitTrade == TRUE && lpObj->pInventory[source].CheckExcOption(g_GlobalConfig.m_iLimitOption) == TRUE)

  00062	83 3d 3c 00 00
	00 01		 cmp	 DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+60, 1
  00069	75 2a		 jne	 SHORT $LN4@gObjInvent
  0006b	a1 cc 00 00 00	 mov	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+204
  00070	50		 push	 eax
  00071	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _source$[ebp]
  00075	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  0007b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0007e	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00084	e8 00 00 00 00	 call	 ?CheckExcOption@CItem@@QAEHH@Z ; CItem::CheckExcOption
  00089	83 f8 01	 cmp	 eax, 1
  0008c	75 07		 jne	 SHORT $LN4@gObjInvent

; 18740: 	{
; 18741: 		return 0xFF;

  0008e	0c ff		 or	 al, 255			; 000000ffH
  00090	e9 12 04 00 00	 jmp	 $LN1@gObjInvent
$LN4@gObjInvent:

; 18742: 	}
; 18743: 	
; 18744: 	if( lpObj->TargetNumber < 0 ) return 0xFF;

  00095	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00098	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  0009f	85 c9		 test	 ecx, ecx
  000a1	7d 07		 jge	 SHORT $LN5@gObjInvent
  000a3	0c ff		 or	 al, 255			; 000000ffH
  000a5	e9 fd 03 00 00	 jmp	 $LN1@gObjInvent
$LN5@gObjInvent:

; 18745: 	//       .
; 18746: 	if( (lpObj->m_IfState.use == 0) || ( lpObj->m_IfState.type != I_TRADE ))

  000aa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ad	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000b3	80 e1 03	 and	 cl, 3
  000b6	0f b6 d1	 movzx	 edx, cl
  000b9	85 d2		 test	 edx, edx
  000bb	74 17		 je	 SHORT $LN7@gObjInvent
  000bd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c0	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000c6	c0 e9 04	 shr	 cl, 4
  000c9	80 e1 0f	 and	 cl, 15			; 0000000fH
  000cc	0f b6 d1	 movzx	 edx, cl
  000cf	83 fa 01	 cmp	 edx, 1
  000d2	74 07		 je	 SHORT $LN6@gObjInvent
$LN7@gObjInvent:

; 18747: 	{
; 18748: 		return 0xFF;

  000d4	0c ff		 or	 al, 255			; 000000ffH
  000d6	e9 cc 03 00 00	 jmp	 $LN1@gObjInvent
$LN6@gObjInvent:

; 18749: 	}
; 18750: 	
; 18751: #ifdef MODIFY_MAGICIARINGRING_TRADE_BUGFIX_20070328		//      
; 18752: 	if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM(13,20) &&

  000db	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  000df	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  000e5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e8	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  000ee	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  000f3	6a 14		 push	 20			; 00000014H
  000f5	6a 0d		 push	 13			; 0000000dH
  000f7	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000fc	83 c4 08	 add	 esp, 8
  000ff	3b f0		 cmp	 esi, eax
  00101	75 24		 jne	 SHORT $LN8@gObjInvent
  00103	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00107	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0010d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00110	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00116	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  0011b	83 f9 01	 cmp	 ecx, 1
  0011e	75 07		 jne	 SHORT $LN8@gObjInvent

; 18753: 		lpObj->pInventory[source].m_Level == 1			//    .
; 18754: 		)
; 18755: 	{	//    
; 18756: 		return 0xFF;

  00120	0c ff		 or	 al, 255			; 000000ffH
  00122	e9 80 03 00 00	 jmp	 $LN1@gObjInvent
$LN8@gObjInvent:

; 18757: 	}
; 18758: #else	// MODIFY_MAGICIARINGRING_TRADE_BUGFIX_20070328
; 18759: #ifdef RING_EVENT_ITEMBOX_20031124		//  -  
; 18760: 	if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM(13,20) &&
; 18761: 		(lpObj->pInventory[source].m_Level == 0 ||		//    .
; 18762: 		lpObj->pInventory[source].m_Level == 1			//    .
; 18763: 		) )
; 18764: 	{	//    
; 18765: 		return 0xFF;
; 18766: 	}
; 18767: #endif
; 18768: #endif	// MODIFY_MAGICIARINGRING_TRADE_BUGFIX_20070328
; 18769: 
; 18770: #ifdef FRIENDSHIP_EVENT_RING_BOX_20040211	// (  )   -  
; 18771: 	if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM(13,20) &&

  00127	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0012b	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  00131	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00134	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0013a	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0013f	6a 14		 push	 20			; 00000014H
  00141	6a 0d		 push	 13			; 0000000dH
  00143	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00148	83 c4 08	 add	 esp, 8
  0014b	3b f0		 cmp	 esi, eax
  0014d	75 24		 jne	 SHORT $LN9@gObjInvent
  0014f	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00153	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  00159	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0015c	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00162	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  00167	83 f9 02	 cmp	 ecx, 2
  0016a	75 07		 jne	 SHORT $LN9@gObjInvent

; 18772: 		lpObj->pInventory[source].m_Level == 2			//    .
; 18773: 		)
; 18774: 	{	//    
; 18775: 		return 0xFF;

  0016c	0c ff		 or	 al, 255			; 000000ffH
  0016e	e9 34 03 00 00	 jmp	 $LN1@gObjInvent
$LN9@gObjInvent:

; 18776: 	}
; 18777: #endif
; 18778: 
; 18779: #ifdef DARK_LORD_HEART_EVENT_20040810		//     .
; 18780: 	if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM(14,11) &&

  00173	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00177	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0017d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00180	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00186	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0018b	6a 0b		 push	 11			; 0000000bH
  0018d	6a 0e		 push	 14			; 0000000eH
  0018f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00194	83 c4 08	 add	 esp, 8
  00197	3b f0		 cmp	 esi, eax
  00199	75 24		 jne	 SHORT $LN10@gObjInvent
  0019b	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0019f	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  001a5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001a8	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  001ae	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  001b3	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  001b6	75 07		 jne	 SHORT $LN10@gObjInvent

; 18781: 		lpObj->pInventory[source].m_Level == 13
; 18782: 		)
; 18783: 	{
; 18784: 		return 0xFF;

  001b8	0c ff		 or	 al, 255			; 000000ffH
  001ba	e9 e8 02 00 00	 jmp	 $LN1@gObjInvent
$LN10@gObjInvent:

; 18785: 	}
; 18786: #endif
; 18787: 
; 18788: #ifdef UPDATE_GM_FUNCTION_20070228	//  GM    
; 18789: 	if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 42 ) )
; 18790: 	{
; 18791: 		return 0xFF;
; 18792: 	}
; 18793: #endif 
; 18794: 
; 18795: #ifdef UPDATE_GM_FUNCTION_20070228			// GM    
; 18796: 	if( ( (lpObj->Authority&AUTHORITY_EVENT_GM) != AUTHORITY_EVENT_GM )
; 18797: 		&& ( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 14, 52 ) ) )
; 18798: 	{
; 18799: 		return 0xFF;
; 18800: 	}
; 18801: #endif
; 18802: 
; 18803: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328		//  
; 18804: 	//  0   
; 18805: 	if(lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 51 ) 
; 18806: 		&& lpObj->pInventory[source].m_Durability == 0)
; 18807: 	{
; 18808: 		return 0xFF;
; 18809: 	}
; 18810: 
; 18811: 	//   
; 18812: 	if(lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 14, 64 ))
; 18813: 	{
; 18814: 		return 0xFF;
; 18815: 	}
; 18816: #endif
; 18817: 
; 18818: #ifdef HIDDEN_TREASUREBOX_EVENT_20050804	//       
; 18819: 	if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM(12,26) &&
; 18820: 		(lpObj->pInventory[source].m_Level == 1 ||		// 
; 18821: 		lpObj->pInventory[source].m_Level == 2 ||		// 
; 18822: 		lpObj->pInventory[source].m_Level == 3 ||		// 
; 18823: 		lpObj->pInventory[source].m_Level == 4 ||		//  
; 18824: 		lpObj->pInventory[source].m_Level == 5			//  ( )
; 18825: 		))
; 18826: 	{
; 18827: 		return 0xFF;
; 18828: 	}
; 18829: #endif
; 18830: 
; 18831: #ifdef KANTURU_MOONSTONEPENDANT_20060804	//  -  	20060823
; 18832: 	if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 38 ) )
; 18833: 	{	
; 18834: 		return 0xFF;
; 18835: 	}
; 18836: #endif
; 18837: 
; 18838: #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	//  
; 18839: 	if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 39 ) )
; 18840: 	{	
; 18841: 		return 0xFF;
; 18842: 	}
; 18843: #endif
; 18844: 
; 18845: #ifdef ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 18846: 	if( IsCashItem( lpObj->pInventory[source].m_Type ) == TRUE )
; 18847: 	{
; 18848: #ifdef ADD_PARTIALY_CHARGE_SYSTEM_06_20090129
; 18849: 		switch(lpObj->pInventory[source].m_Type)
; 18850: 		{
; 18851: 			//         2009/04/07 by natinda
; 18852: 			case MAKE_ITEMNUM2(13, 83):  //  
; 18853: 				break;
; 18854: 			case MAKE_ITEMNUM2(13, 84):  //  
; 18855: 				break;
; 18856: 			case MAKE_ITEMNUM2(13, 85):  //  
; 18857: 				break;
; 18858: 			case MAKE_ITEMNUM2(13, 86):  //  
; 18859: 				break;
; 18860: 			case MAKE_ITEMNUM2(13, 87):  //  
; 18861: 				break;
; 18862: 			case MAKE_ITEMNUM2(13, 88):  //  
; 18863: 				break;
; 18864: 			case MAKE_ITEMNUM2(13, 89):  //  
; 18865: 				break;
; 18866: 			case MAKE_ITEMNUM2(13, 90):  //  
; 18867: 				break;
; 18868: 			case MAKE_ITEMNUM2(13, 91):  //  
; 18869: 				break;
; 18870: 			case MAKE_ITEMNUM2(13, 92):  //   
; 18871: 				break;
; 18872: 			default:
; 18873: 				return 0xFF;
; 18874: 		}
; 18875: #else
; 18876: 		return 0xFF;
; 18877: #endif //ADD_PARTIALY_CHARGE_SYSTEM_06_20090129
; 18878: 	}
; 18879: #endif // ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 18880: 
; 18881: #ifdef PREMIUMITEM_20090106
; 18882: 	//   
; 18883: 	if( IsPremiumItem( lpObj->pInventory[source].m_Type ) == TRUE )
; 18884: 	{
; 18885: 		return 0xFF;
; 18886: 	}
; 18887: #endif // ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 18888: 
; 18889: 
; 18890: #ifdef PCBANG_POINT_SYSTEM_20070206	//  
; 18891: 	if( g_PCBangPointSystem.CheckPCBangPointItem( lpObj->pInventory[source].m_Type ) )
; 18892: 	{	
; 18893: 		return 0xFF;
; 18894: 	}
; 18895: #endif
; 18896: 
; 18897: #ifdef MODIFY_QUEST_SYSTEM_20070525	//   
; 18898: 	if( lpObj->pInventory[source].m_QuestItem )
; 18899: 	{
; 18900: 		return 0xFF;
; 18901: 	}
; 18902: #endif
; 18903: 
; 18904: 
; 18905: 	lpObj->pInventory[source].GetSize(iwidth, iheight);

  001bf	8d 45 ec	 lea	 eax, DWORD PTR _iheight$[ebp]
  001c2	50		 push	 eax
  001c3	8d 4d f0	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  001c6	51		 push	 ecx
  001c7	0f b6 55 0c	 movzx	 edx, BYTE PTR _source$[ebp]
  001cb	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  001d1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d4	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  001da	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 18906: 	
; 18907: 	DWORD s_num = lpObj->pInventory[source].GetNumber();

  001df	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  001e3	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  001e9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001ec	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  001f2	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  001f7	89 45 e8	 mov	 DWORD PTR _s_num$[ebp], eax

; 18908: 
; 18909: #ifdef ANTIHACKING_SERIAL_0_ITEM_20051202	
; 18910: 	if( gObjCheckSerial0ItemList(&lpObj->pInventory[source]) )

  001fa	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  001fe	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  00204	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00207	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0020d	51		 push	 ecx
  0020e	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  00213	83 c4 04	 add	 esp, 4
  00216	85 c0		 test	 eax, eax
  00218	74 60		 je	 SHORT $LN11@gObjInvent

; 18911: 	{
; 18912: 		// MODIFY_LOCALIZING_WTF_20060309  wtf   0.99.60 - 0.99.94
; 18913: 		MsgOutput( lpObj->m_Index, lMsg.Get(3354) );			// "  .  ."

  0021a	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  0021f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00224	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0022a	50		 push	 eax
  0022b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0022e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00230	51		 push	 ecx
  00231	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00236	83 c4 08	 add	 esp, 8

; 18914: 		LogAddTD( "[ANTI-HACK][Serial 0 Item] [Trade] (%s)(%s) Item(%s) Pos(%d)",

  00239	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0023d	50		 push	 eax
  0023e	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _source$[ebp]
  00242	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00248	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0024b	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00251	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00256	50		 push	 eax
  00257	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0025a	83 c0 73	 add	 eax, 115		; 00000073H
  0025d	50		 push	 eax
  0025e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00261	83 c1 68	 add	 ecx, 104		; 00000068H
  00264	51		 push	 ecx
  00265	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@CJKEGDHI@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLTra@
  0026a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00270	83 c4 14	 add	 esp, 20			; 00000014H

; 18915: 				lpObj->AccountID, lpObj->Name, lpObj->pInventory[source].GetName(), source );
; 18916: 		return 0xFF;

  00273	0c ff		 or	 al, 255			; 000000ffH
  00275	e9 2d 02 00 00	 jmp	 $LN1@gObjInvent
$LN11@gObjInvent:

; 18917: 	}
; 18918: #endif
; 18919: 	
; 18920: 	if( gObjInventorySearchSerialNumber(lpObj, s_num) == FALSE )

  0027a	8b 45 e8	 mov	 eax, DWORD PTR _s_num$[ebp]
  0027d	50		 push	 eax
  0027e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00281	51		 push	 ecx
  00282	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  00287	83 c4 08	 add	 esp, 8
  0028a	85 c0		 test	 eax, eax
  0028c	75 07		 jne	 SHORT $LN12@gObjInvent

; 18921: 	{
; 18922: 		return 0xFF;

  0028e	0c ff		 or	 al, 255			; 000000ffH
  00290	e9 12 02 00 00	 jmp	 $LN1@gObjInvent
$LN12@gObjInvent:

; 18923: 	}
; 18924: 
; 18925: 	//   .
; 18926: 	//    .
; 18927: 	
; 18928: 	int blank;
; 18929: 
; 18930: 	w = target%8;

  00295	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  00299	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0029e	79 05		 jns	 SHORT $LN22@gObjInvent
  002a0	48		 dec	 eax
  002a1	83 c8 f8	 or	 eax, -8			; fffffff8H
  002a4	40		 inc	 eax
$LN22@gObjInvent:
  002a5	89 45 f4	 mov	 DWORD PTR _w$[ebp], eax

; 18931: 	h = target/8;

  002a8	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  002ac	99		 cdq
  002ad	83 e2 07	 and	 edx, 7
  002b0	03 c2		 add	 eax, edx
  002b2	c1 f8 03	 sar	 eax, 3
  002b5	89 45 f8	 mov	 DWORD PTR _h$[ebp], eax

; 18932: 
; 18933: 	if( ExtentCheck(w, h, 8, 4) == FALSE ) return 0xFF;

  002b8	6a 04		 push	 4
  002ba	6a 08		 push	 8
  002bc	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  002bf	50		 push	 eax
  002c0	8b 4d f4	 mov	 ecx, DWORD PTR _w$[ebp]
  002c3	51		 push	 ecx
  002c4	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  002c9	83 c4 10	 add	 esp, 16			; 00000010H
  002cc	85 c0		 test	 eax, eax
  002ce	75 07		 jne	 SHORT $LN13@gObjInvent
  002d0	0c ff		 or	 al, 255			; 000000ffH
  002d2	e9 d0 01 00 00	 jmp	 $LN1@gObjInvent
$LN13@gObjInvent:

; 18934: 
; 18935: 	//  
; 18936: 	if( *(lpObj->TradeMap+(h*8)+w) == 0xFF )

  002d7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002da	8b 88 88 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3208]
  002e0	8b 55 f8	 mov	 edx, DWORD PTR _h$[ebp]
  002e3	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  002e6	8b 4d f4	 mov	 ecx, DWORD PTR _w$[ebp]
  002e9	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  002ed	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  002f3	0f 85 ac 01 00
	00		 jne	 $LN14@gObjInvent

; 18937: 	{
; 18938: 		blank = gObjTradeRectCheck(lpObj->m_Index, w, h, iwidth,iheight);

  002f9	8b 45 ec	 mov	 eax, DWORD PTR _iheight$[ebp]
  002fc	50		 push	 eax
  002fd	8b 4d f0	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  00300	51		 push	 ecx
  00301	8b 55 f8	 mov	 edx, DWORD PTR _h$[ebp]
  00304	52		 push	 edx
  00305	8b 45 f4	 mov	 eax, DWORD PTR _w$[ebp]
  00308	50		 push	 eax
  00309	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0030c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0030e	52		 push	 edx
  0030f	e8 00 00 00 00	 call	 ?gObjTradeRectCheck@@YAEHHHHH@Z ; gObjTradeRectCheck
  00314	83 c4 14	 add	 esp, 20			; 00000014H
  00317	0f b6 c0	 movzx	 eax, al
  0031a	89 45 e4	 mov	 DWORD PTR _blank$[ebp], eax

; 18939: 		
; 18940: 		if( blank == 0xFF ) return 0xFF;

  0031d	81 7d e4 ff 00
	00 00		 cmp	 DWORD PTR _blank$[ebp], 255 ; 000000ffH
  00324	75 0c		 jne	 SHORT $LN15@gObjInvent
  00326	0c ff		 or	 al, 255			; 000000ffH
  00328	e9 7a 01 00 00	 jmp	 $LN1@gObjInvent
  0032d	e9 73 01 00 00	 jmp	 $LN14@gObjInvent
$LN15@gObjInvent:

; 18941: 		else 	//   
; 18942: 		{	
; 18943: 			lpObj->Trade[blank] = lpObj->pInventory[source];

  00332	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00336	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0033c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0033f	8b b2 5c 0c 00
	00		 mov	 esi, DWORD PTR [edx+3164]
  00345	03 f1		 add	 esi, ecx
  00347	69 45 e4 a8 00
	00 00		 imul	 eax, DWORD PTR _blank$[ebp], 168
  0034e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00351	8b b9 84 0c 00
	00		 mov	 edi, DWORD PTR [ecx+3204]
  00357	03 f8		 add	 edi, eax
  00359	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0035e	f3 a5		 rep movsd

; 18944: 			
; 18945: //			LogAdd("Trade : %d inventory:%d", lpObj->Trade[blank].m_Number, lpObj->pInventory[source].m_Number);
; 18946: 
; 18947: 			gObjInventoryDeleteItem(lpObj->m_Index, source);

  00360	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00364	50		 push	 eax
  00365	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00368	8b 11		 mov	 edx, DWORD PTR [ecx]
  0036a	52		 push	 edx
  0036b	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00370	83 c4 08	 add	 esp, 8

; 18948: 			//gObjInventoryItemSet(lpObj->m_Index, source, 0xFF);
; 18949: 			//lpObj->pInventory[source].Clear();
; 18950: 
; 18951: 			gObjTradeItemBoxSet(lpObj->m_Index, blank, iwidth, iheight, (BYTE)lpObj->Trade[blank].m_Type);

  00373	69 45 e4 a8 00
	00 00		 imul	 eax, DWORD PTR _blank$[ebp], 168
  0037a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0037d	8b 91 84 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3204]
  00383	0f b6 44 02 06	 movzx	 eax, BYTE PTR [edx+eax+6]
  00388	50		 push	 eax
  00389	8b 4d ec	 mov	 ecx, DWORD PTR _iheight$[ebp]
  0038c	51		 push	 ecx
  0038d	8b 55 f0	 mov	 edx, DWORD PTR _iwidth$[ebp]
  00390	52		 push	 edx
  00391	8b 45 e4	 mov	 eax, DWORD PTR _blank$[ebp]
  00394	50		 push	 eax
  00395	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00398	8b 11		 mov	 edx, DWORD PTR [ecx]
  0039a	52		 push	 edx
  0039b	e8 00 00 00 00	 call	 ?gObjTradeItemBoxSet@@YAHHHHHE@Z ; gObjTradeItemBoxSet
  003a0	83 c4 14	 add	 esp, 20			; 00000014H

; 18952: 		
; 18953: 			BYTE itembuf[ITEM_BUFFER_SIZE];
; 18954: 
; 18955: 			ItemByteConvert(itembuf, lpObj->Trade[blank]);

  003a3	69 45 e4 a8 00
	00 00		 imul	 eax, DWORD PTR _blank$[ebp], 168
  003aa	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003ad	8b b1 84 0c 00
	00		 mov	 esi, DWORD PTR [ecx+3204]
  003b3	03 f0		 add	 esi, eax
  003b5	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  003bb	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  003c0	8b fc		 mov	 edi, esp
  003c2	f3 a5		 rep movsd
  003c4	8d 55 dc	 lea	 edx, DWORD PTR _itembuf$1[ebp]
  003c7	52		 push	 edx
  003c8	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  003cd	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 18956: 			
; 18957: #ifdef ITEM_INDEX_EXTEND_20050706
; 18958: 			GCTradeOtherAdd(lpObj->TargetNumber, blank, itembuf);			
; 18959: #else
; 18960: 			GCTradeOtherAdd(lpObj->TargetNumber, blank, itembuf[0],itembuf[1],itembuf[2], itembuf[3], itembuf[4]);			

  003d3	b8 01 00 00 00	 mov	 eax, 1
  003d8	c1 e0 02	 shl	 eax, 2
  003db	0f b6 4c 05 dc	 movzx	 ecx, BYTE PTR _itembuf$1[ebp+eax]
  003e0	51		 push	 ecx
  003e1	ba 01 00 00 00	 mov	 edx, 1
  003e6	6b c2 03	 imul	 eax, edx, 3
  003e9	0f b6 4c 05 dc	 movzx	 ecx, BYTE PTR _itembuf$1[ebp+eax]
  003ee	51		 push	 ecx
  003ef	ba 01 00 00 00	 mov	 edx, 1
  003f4	d1 e2		 shl	 edx, 1
  003f6	0f b6 44 15 dc	 movzx	 eax, BYTE PTR _itembuf$1[ebp+edx]
  003fb	50		 push	 eax
  003fc	b9 01 00 00 00	 mov	 ecx, 1
  00401	c1 e1 00	 shl	 ecx, 0
  00404	0f b6 54 0d dc	 movzx	 edx, BYTE PTR _itembuf$1[ebp+ecx]
  00409	52		 push	 edx
  0040a	b8 01 00 00 00	 mov	 eax, 1
  0040f	6b c8 00	 imul	 ecx, eax, 0
  00412	0f b6 54 0d dc	 movzx	 edx, BYTE PTR _itembuf$1[ebp+ecx]
  00417	52		 push	 edx
  00418	0f b6 45 e4	 movzx	 eax, BYTE PTR _blank$[ebp]
  0041c	50		 push	 eax
  0041d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00420	0f bf 91 ac 02
	00 00		 movsx	 edx, WORD PTR [ecx+684]
  00427	52		 push	 edx
  00428	e8 00 00 00 00	 call	 ?GCTradeOtherAdd@@YAHHEEEEEE@Z ; GCTradeOtherAdd
  0042d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 18961: #endif
; 18962: 
; 18963: 
; 18964: #ifdef MODEFY_CHAGNE_RING_TRADE_INVENTORY_20070213
; 18965: 			if( source < MAX_EQUIPMENT ) 
; 18966: 			{				
; 18967: 				if( source == EQUIPMENT_RING_RIGHT || source == EQUIPMENT_RING_LEFT)
; 18968: 				{
; 18969: 					if( lpObj->Trade[blank].m_Type == MAKE_ITEMNUM(13,10)
; 18970: 						|| lpObj->Trade[blank].m_Type == MAKE_ITEMNUM(13,39)
; 18971: 						|| lpObj->Trade[blank].m_Type == MAKE_ITEMNUM(13,40)
; 18972: 						|| lpObj->Trade[blank].m_Type == MAKE_ITEMNUM(13,41)
; 18973: #ifdef MODIFY_SNOW_MAN_PANDA_POLYMORPH_RING_BUGFIX_20090715
; 18974: 						|| lpObj->Trade[blank].m_Type == MAKE_ITEMNUM(13,68)
; 18975: 						|| lpObj->Trade[blank].m_Type == MAKE_ITEMNUM(13,76)
; 18976: #endif // MODIFY_SNOW_MAN_PANDA_POLYMORPH_RING_BUGFIX_20090715
; 18977: 						)
; 18978: 					{						
; 18979: 						gObjUseSkill.SkillChangeUse(lpObj->m_Index);
; 18980: 					}
; 18981: 				}				
; 18982: 				gObjMakePreviewCharSet(lpObj->m_Index);
; 18983: 				GCEquipmentChange(lpObj->m_Index, source);
; 18984: 			}
; 18985: #else	// MODEFY_CHAGNE_RING_TRADE_INVENTORY_20070213
; 18986: 			if( source < MAX_EQUIPMENT ) 

  00430	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00434	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00437	7d 68		 jge	 SHORT $LN17@gObjInvent

; 18987: 			{				
; 18988: 				if( source == EQUIPMENT_RING_RIGHT || source == EQUIPMENT_RING_LEFT)

  00439	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0043d	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00440	74 09		 je	 SHORT $LN19@gObjInvent
  00442	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00446	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00449	75 35		 jne	 SHORT $LN18@gObjInvent
$LN19@gObjInvent:

; 18989: 				{
; 18990: 					if( lpObj->Trade[blank].m_Type == MAKE_ITEMNUM(13,10) )

  0044b	69 45 e4 a8 00
	00 00		 imul	 eax, DWORD PTR _blank$[ebp], 168
  00452	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00455	8b 91 84 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3204]
  0045b	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00460	6a 0a		 push	 10			; 0000000aH
  00462	6a 0d		 push	 13			; 0000000dH
  00464	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00469	83 c4 08	 add	 esp, 8
  0046c	3b f0		 cmp	 esi, eax
  0046e	75 10		 jne	 SHORT $LN18@gObjInvent

; 18991: 					{						
; 18992: 						gObjUseSkill.SkillChangeUse(lpObj->m_Index);

  00470	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00473	8b 08		 mov	 ecx, DWORD PTR [eax]
  00475	51		 push	 ecx
  00476	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0047b	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN18@gObjInvent:

; 18993: 					}
; 18994: 				}				
; 18995: 				gObjMakePreviewCharSet(lpObj->m_Index);

  00480	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00483	8b 08		 mov	 ecx, DWORD PTR [eax]
  00485	51		 push	 ecx
  00486	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  0048b	83 c4 04	 add	 esp, 4

; 18996: 				GCEquipmentChange(lpObj->m_Index, source);

  0048e	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00492	50		 push	 eax
  00493	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00496	8b 11		 mov	 edx, DWORD PTR [ecx]
  00498	52		 push	 edx
  00499	e8 00 00 00 00	 call	 ?GCEquipmentChange@@YAXHH@Z ; GCEquipmentChange
  0049e	83 c4 08	 add	 esp, 8
$LN17@gObjInvent:

; 18997: 			}
; 18998: #endif	// MODEFY_CHAGNE_RING_TRADE_INVENTORY_20070213
; 18999: 			return 0x01;

  004a1	b0 01		 mov	 al, 1
  004a3	eb 02		 jmp	 SHORT $LN1@gObjInvent
$LN14@gObjInvent:

; 19000: 		}			
; 19001: 	}
; 19002: 	return 0xFF;

  004a5	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjInvent:

; 19003: }

  004a7	5f		 pop	 edi
  004a8	5e		 pop	 esi
  004a9	5b		 pop	 ebx
  004aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004ad	33 cd		 xor	 ecx, ebp
  004af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004b4	8b e5		 mov	 esp, ebp
  004b6	5d		 pop	 ebp
  004b7	c3		 ret	 0
?gObjInventoryTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z ENDP	; gObjInventoryTradeMove
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjTradeTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_itembuf$1 = -64					; size = 5
_blank$ = -56						; size = 4
_TempTradeMap$ = -52					; size = 32
_iheight$ = -20						; size = 4
_iwidth$ = -16						; size = 4
_w$ = -12						; size = 4
_h$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_source$ = 12						; size = 1
_target$ = 16						; size = 1
?gObjTradeTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z PROC	; gObjTradeTradeMove, COMDAT

; 19007: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 19008: 	int h, w;
; 19009: 	int iwidth, iheight;
; 19010: 
; 19011: 	BYTE	TempTradeMap[4*8];				//   
; 19012: 
; 19013: 	if( source > MAX_TRADEITEM )

  00016	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0001a	83 f8 20	 cmp	 eax, 32			; 00000020H
  0001d	7e 23		 jle	 SHORT $LN2@gObjTradeT

; 19014: 	{
; 19015: 		LogAdd("error : %s %d", __FILE__, __LINE__);

  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjTradeTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z@4JA
  00024	83 c0 08	 add	 eax, 8
  00027	50		 push	 eax
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19016: 		return 0xFF;

  0003b	0c ff		 or	 al, 255			; 000000ffH
  0003d	e9 1a 03 00 00	 jmp	 $LN1@gObjTradeT
$LN2@gObjTradeT:

; 19017: 	}
; 19018: 	if( source == target ) 

  00042	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00046	0f b6 4d 10	 movzx	 ecx, BYTE PTR _target$[ebp]
  0004a	3b c1		 cmp	 eax, ecx
  0004c	75 23		 jne	 SHORT $LN3@gObjTradeT

; 19019: 	{
; 19020: 		LogAdd("error : %s %d", __FILE__, __LINE__);

  0004e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjTradeTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z@4JA
  00053	83 c0 0d	 add	 eax, 13			; 0000000dH
  00056	50		 push	 eax
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19021: 		return 0xFF;

  0006a	0c ff		 or	 al, 255			; 000000ffH
  0006c	e9 eb 02 00 00	 jmp	 $LN1@gObjTradeT
$LN3@gObjTradeT:

; 19022: 	}
; 19023: 	//   ?
; 19024: 	if( lpObj->Trade[source].IsItem() == FALSE )

  00071	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00075	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0007b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0007e	03 8a 84 0c 00
	00		 add	 ecx, DWORD PTR [edx+3204]
  00084	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00089	85 c0		 test	 eax, eax
  0008b	75 07		 jne	 SHORT $LN4@gObjTradeT

; 19025: 	{
; 19026: 		return 0xFF;

  0008d	0c ff		 or	 al, 255			; 000000ffH
  0008f	e9 c8 02 00 00	 jmp	 $LN1@gObjTradeT
$LN4@gObjTradeT:

; 19027: 	}
; 19028: 	//    ?
; 19029: 	if( lpObj->Trade[target].IsItem() == TRUE )

  00094	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  00098	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0009e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000a1	03 8a 84 0c 00
	00		 add	 ecx, DWORD PTR [edx+3204]
  000a7	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000ac	83 f8 01	 cmp	 eax, 1
  000af	75 07		 jne	 SHORT $LN5@gObjTradeT

; 19030: 	{
; 19031: 		return 0xFF;

  000b1	0c ff		 or	 al, 255			; 000000ffH
  000b3	e9 a4 02 00 00	 jmp	 $LN1@gObjTradeT
$LN5@gObjTradeT:

; 19032: 	}
; 19033: 	if( lpObj->TargetNumber < 0 ) return 0xFF;

  000b8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bb	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  000c2	85 c9		 test	 ecx, ecx
  000c4	7d 07		 jge	 SHORT $LN6@gObjTradeT
  000c6	0c ff		 or	 al, 255			; 000000ffH
  000c8	e9 8f 02 00 00	 jmp	 $LN1@gObjTradeT
$LN6@gObjTradeT:

; 19034: 	
; 19035: 	//       .
; 19036: 	if( (lpObj->m_IfState.use == 0) || ( lpObj->m_IfState.type != I_TRADE ))

  000cd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d0	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000d6	80 e1 03	 and	 cl, 3
  000d9	0f b6 d1	 movzx	 edx, cl
  000dc	85 d2		 test	 edx, edx
  000de	74 17		 je	 SHORT $LN8@gObjTradeT
  000e0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e3	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000e9	c0 e9 04	 shr	 cl, 4
  000ec	80 e1 0f	 and	 cl, 15			; 0000000fH
  000ef	0f b6 d1	 movzx	 edx, cl
  000f2	83 fa 01	 cmp	 edx, 1
  000f5	74 07		 je	 SHORT $LN7@gObjTradeT
$LN8@gObjTradeT:

; 19037: 	{
; 19038: 		return 0xFF;

  000f7	0c ff		 or	 al, 255			; 000000ffH
  000f9	e9 5e 02 00 00	 jmp	 $LN1@gObjTradeT
$LN7@gObjTradeT:

; 19039: 	}
; 19040: 	
; 19041: 	lpObj->Trade[source].GetSize(iwidth, iheight);

  000fe	8d 45 ec	 lea	 eax, DWORD PTR _iheight$[ebp]
  00101	50		 push	 eax
  00102	8d 4d f0	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00105	51		 push	 ecx
  00106	0f b6 55 0c	 movzx	 edx, BYTE PTR _source$[ebp]
  0010a	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  00110	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00113	03 88 84 0c 00
	00		 add	 ecx, DWORD PTR [eax+3204]
  00119	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 19042: 
; 19043: 	memcpy(TempTradeMap, lpObj->TradeMap, 4*8);

  0011e	6a 20		 push	 32			; 00000020H
  00120	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00123	8b 88 88 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3208]
  00129	51		 push	 ecx
  0012a	8d 55 cc	 lea	 edx, DWORD PTR _TempTradeMap$[ebp]
  0012d	52		 push	 edx
  0012e	e8 00 00 00 00	 call	 _memcpy
  00133	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19044: 	//  .
; 19045: 	
; 19046: 	gObjTradeItemBoxSet(lpObj->m_Index, source, iwidth, iheight, 0xFF);

  00136	68 ff 00 00 00	 push	 255			; 000000ffH
  0013b	8b 45 ec	 mov	 eax, DWORD PTR _iheight$[ebp]
  0013e	50		 push	 eax
  0013f	8b 4d f0	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  00142	51		 push	 ecx
  00143	0f b6 55 0c	 movzx	 edx, BYTE PTR _source$[ebp]
  00147	52		 push	 edx
  00148	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014d	51		 push	 ecx
  0014e	e8 00 00 00 00	 call	 ?gObjTradeItemBoxSet@@YAHHHHHE@Z ; gObjTradeItemBoxSet
  00153	83 c4 14	 add	 esp, 20			; 00000014H

; 19047: 
; 19048: 	//   .
; 19049: 	//    .
; 19050: 	int blank;
; 19051: 
; 19052: 	w = target%8;

  00156	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  0015a	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0015f	79 05		 jns	 SHORT $LN14@gObjTradeT
  00161	48		 dec	 eax
  00162	83 c8 f8	 or	 eax, -8			; fffffff8H
  00165	40		 inc	 eax
$LN14@gObjTradeT:
  00166	89 45 f4	 mov	 DWORD PTR _w$[ebp], eax

; 19053: 	h = target/8;

  00169	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  0016d	99		 cdq
  0016e	83 e2 07	 and	 edx, 7
  00171	03 c2		 add	 eax, edx
  00173	c1 f8 03	 sar	 eax, 3
  00176	89 45 f8	 mov	 DWORD PTR _h$[ebp], eax

; 19054: 
; 19055: 	if( ExtentCheck(w, h, 8, 4) == FALSE ) {

  00179	6a 04		 push	 4
  0017b	6a 08		 push	 8
  0017d	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  00180	50		 push	 eax
  00181	8b 4d f4	 mov	 ecx, DWORD PTR _w$[ebp]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  0018a	83 c4 10	 add	 esp, 16			; 00000010H
  0018d	85 c0		 test	 eax, eax
  0018f	75 1f		 jne	 SHORT $LN9@gObjTradeT

; 19056: 		memcpy(lpObj->TradeMap, TempTradeMap, 4*8);

  00191	6a 20		 push	 32			; 00000020H
  00193	8d 45 cc	 lea	 eax, DWORD PTR _TempTradeMap$[ebp]
  00196	50		 push	 eax
  00197	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0019a	8b 91 88 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3208]
  001a0	52		 push	 edx
  001a1	e8 00 00 00 00	 call	 _memcpy
  001a6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19057: 		return 0xFF;

  001a9	0c ff		 or	 al, 255			; 000000ffH
  001ab	e9 ac 01 00 00	 jmp	 $LN1@gObjTradeT
$LN9@gObjTradeT:

; 19058: 	}
; 19059: 
; 19060: 	//  
; 19061: 	if( *(lpObj->TradeMap+(h*8)+w) == 0xFF )

  001b0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b3	8b 88 88 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3208]
  001b9	8b 55 f8	 mov	 edx, DWORD PTR _h$[ebp]
  001bc	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  001bf	8b 4d f4	 mov	 ecx, DWORD PTR _w$[ebp]
  001c2	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  001c6	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  001cc	0f 85 70 01 00
	00		 jne	 $LN10@gObjTradeT

; 19062: 	{
; 19063: 		blank = gObjTradeRectCheck(lpObj->m_Index, w, h, iwidth,iheight);

  001d2	8b 45 ec	 mov	 eax, DWORD PTR _iheight$[ebp]
  001d5	50		 push	 eax
  001d6	8b 4d f0	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  001d9	51		 push	 ecx
  001da	8b 55 f8	 mov	 edx, DWORD PTR _h$[ebp]
  001dd	52		 push	 edx
  001de	8b 45 f4	 mov	 eax, DWORD PTR _w$[ebp]
  001e1	50		 push	 eax
  001e2	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001e5	8b 11		 mov	 edx, DWORD PTR [ecx]
  001e7	52		 push	 edx
  001e8	e8 00 00 00 00	 call	 ?gObjTradeRectCheck@@YAEHHHHH@Z ; gObjTradeRectCheck
  001ed	83 c4 14	 add	 esp, 20			; 00000014H
  001f0	0f b6 c0	 movzx	 eax, al
  001f3	89 45 c8	 mov	 DWORD PTR _blank$[ebp], eax

; 19064: 		
; 19065: 		if( blank == 0xFF ) {

  001f6	81 7d c8 ff 00
	00 00		 cmp	 DWORD PTR _blank$[ebp], 255 ; 000000ffH
  001fd	75 24		 jne	 SHORT $LN11@gObjTradeT

; 19066: 			memcpy(lpObj->TradeMap, TempTradeMap, 4*8);

  001ff	6a 20		 push	 32			; 00000020H
  00201	8d 45 cc	 lea	 eax, DWORD PTR _TempTradeMap$[ebp]
  00204	50		 push	 eax
  00205	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00208	8b 91 88 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3208]
  0020e	52		 push	 edx
  0020f	e8 00 00 00 00	 call	 _memcpy
  00214	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19067: 			return 0xFF;

  00217	0c ff		 or	 al, 255			; 000000ffH
  00219	e9 3e 01 00 00	 jmp	 $LN1@gObjTradeT

; 19068: 		}

  0021e	e9 1f 01 00 00	 jmp	 $LN10@gObjTradeT
$LN11@gObjTradeT:

; 19069: 		else 	//   
; 19070: 		{	
; 19071: 			lpObj->Trade[blank] = lpObj->Trade[source];

  00223	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00227	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0022d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00230	8b b2 84 0c 00
	00		 mov	 esi, DWORD PTR [edx+3204]
  00236	03 f1		 add	 esi, ecx
  00238	69 45 c8 a8 00
	00 00		 imul	 eax, DWORD PTR _blank$[ebp], 168
  0023f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00242	8b b9 84 0c 00
	00		 mov	 edi, DWORD PTR [ecx+3204]
  00248	03 f8		 add	 edi, eax
  0024a	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0024f	f3 a5		 rep movsd

; 19072: 			
; 19073: 			//   .			
; 19074: 			lpObj->Trade[source].Clear();

  00251	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00255	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0025b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0025e	03 8a 84 0c 00
	00		 add	 ecx, DWORD PTR [edx+3204]
  00264	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 19075: 			GCTradeOtherDel(lpObj->TargetNumber, source);

  00269	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0026d	50		 push	 eax
  0026e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00271	0f bf 91 ac 02
	00 00		 movsx	 edx, WORD PTR [ecx+684]
  00278	52		 push	 edx
  00279	e8 00 00 00 00	 call	 ?GCTradeOtherDel@@YAHHE@Z ; GCTradeOtherDel
  0027e	83 c4 08	 add	 esp, 8

; 19076: 			gObjTradeItemBoxSet(lpObj->m_Index, blank, iwidth, iheight, (BYTE)lpObj->Trade[blank].m_Type);

  00281	69 45 c8 a8 00
	00 00		 imul	 eax, DWORD PTR _blank$[ebp], 168
  00288	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0028b	8b 91 84 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3204]
  00291	0f b6 44 02 06	 movzx	 eax, BYTE PTR [edx+eax+6]
  00296	50		 push	 eax
  00297	8b 4d ec	 mov	 ecx, DWORD PTR _iheight$[ebp]
  0029a	51		 push	 ecx
  0029b	8b 55 f0	 mov	 edx, DWORD PTR _iwidth$[ebp]
  0029e	52		 push	 edx
  0029f	8b 45 c8	 mov	 eax, DWORD PTR _blank$[ebp]
  002a2	50		 push	 eax
  002a3	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002a6	8b 11		 mov	 edx, DWORD PTR [ecx]
  002a8	52		 push	 edx
  002a9	e8 00 00 00 00	 call	 ?gObjTradeItemBoxSet@@YAHHHHHE@Z ; gObjTradeItemBoxSet
  002ae	83 c4 14	 add	 esp, 20			; 00000014H

; 19077: 
; 19078: 			BYTE itembuf[ITEM_BUFFER_SIZE];			
; 19079: 
; 19080: 			ItemByteConvert(itembuf, lpObj->Trade[blank]);

  002b1	69 45 c8 a8 00
	00 00		 imul	 eax, DWORD PTR _blank$[ebp], 168
  002b8	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002bb	8b b1 84 0c 00
	00		 mov	 esi, DWORD PTR [ecx+3204]
  002c1	03 f0		 add	 esi, eax
  002c3	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  002c9	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  002ce	8b fc		 mov	 edi, esp
  002d0	f3 a5		 rep movsd
  002d2	8d 55 c0	 lea	 edx, DWORD PTR _itembuf$1[ebp]
  002d5	52		 push	 edx
  002d6	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  002db	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 19081: 
; 19082: #ifdef ITEM_INDEX_EXTEND_20050706
; 19083: 			GCTradeOtherAdd(lpObj->TargetNumber, blank, itembuf);
; 19084: #else
; 19085: 			GCTradeOtherAdd(lpObj->TargetNumber, blank, itembuf[0],itembuf[1],itembuf[2], itembuf[3], itembuf[4]);

  002e1	b8 01 00 00 00	 mov	 eax, 1
  002e6	c1 e0 02	 shl	 eax, 2
  002e9	0f b6 4c 05 c0	 movzx	 ecx, BYTE PTR _itembuf$1[ebp+eax]
  002ee	51		 push	 ecx
  002ef	ba 01 00 00 00	 mov	 edx, 1
  002f4	6b c2 03	 imul	 eax, edx, 3
  002f7	0f b6 4c 05 c0	 movzx	 ecx, BYTE PTR _itembuf$1[ebp+eax]
  002fc	51		 push	 ecx
  002fd	ba 01 00 00 00	 mov	 edx, 1
  00302	d1 e2		 shl	 edx, 1
  00304	0f b6 44 15 c0	 movzx	 eax, BYTE PTR _itembuf$1[ebp+edx]
  00309	50		 push	 eax
  0030a	b9 01 00 00 00	 mov	 ecx, 1
  0030f	c1 e1 00	 shl	 ecx, 0
  00312	0f b6 54 0d c0	 movzx	 edx, BYTE PTR _itembuf$1[ebp+ecx]
  00317	52		 push	 edx
  00318	b8 01 00 00 00	 mov	 eax, 1
  0031d	6b c8 00	 imul	 ecx, eax, 0
  00320	0f b6 54 0d c0	 movzx	 edx, BYTE PTR _itembuf$1[ebp+ecx]
  00325	52		 push	 edx
  00326	0f b6 45 c8	 movzx	 eax, BYTE PTR _blank$[ebp]
  0032a	50		 push	 eax
  0032b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0032e	0f bf 91 ac 02
	00 00		 movsx	 edx, WORD PTR [ecx+684]
  00335	52		 push	 edx
  00336	e8 00 00 00 00	 call	 ?GCTradeOtherAdd@@YAHHEEEEEE@Z ; GCTradeOtherAdd
  0033b	83 c4 1c	 add	 esp, 28			; 0000001cH

; 19086: #endif
; 19087: 
; 19088: 
; 19089: 			return 0x01;

  0033e	b0 01		 mov	 al, 1
  00340	eb 1a		 jmp	 SHORT $LN1@gObjTradeT
$LN10@gObjTradeT:

; 19090: 		}
; 19091: 	}
; 19092: 	memcpy(lpObj->TradeMap, TempTradeMap, 4*8);

  00342	6a 20		 push	 32			; 00000020H
  00344	8d 45 cc	 lea	 eax, DWORD PTR _TempTradeMap$[ebp]
  00347	50		 push	 eax
  00348	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0034b	8b 91 88 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3208]
  00351	52		 push	 edx
  00352	e8 00 00 00 00	 call	 _memcpy
  00357	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19093: 	return 0xFF;

  0035a	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjTradeT:

; 19094: }

  0035c	5f		 pop	 edi
  0035d	5e		 pop	 esi
  0035e	5b		 pop	 ebx
  0035f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00362	33 cd		 xor	 ecx, ebp
  00364	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00369	8b e5		 mov	 esp, ebp
  0036b	5d		 pop	 ebp
  0036c	c3		 ret	 0
?gObjTradeTradeMove@@YAEPAVOBJECTSTRUCT@@EE@Z ENDP	; gObjTradeTradeMove
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjTradeInventoryMove@@YAEPAVOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_itembuf$ = -24						; size = 5
_s_num$ = -16						; size = 4
_iheight$ = -12						; size = 4
_iwidth$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_source$ = 12						; size = 1
_target$ = 16						; size = 1
?gObjTradeInventoryMove@@YAEPAVOBJECTSTRUCT@@EE@Z PROC	; gObjTradeInventoryMove, COMDAT

; 18611: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 18612: 	int iwidth, iheight;
; 18613: 
; 18614: 	if( source > MAX_TRADEITEM )

  00013	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00017	83 f8 20	 cmp	 eax, 32			; 00000020H
  0001a	7e 23		 jle	 SHORT $LN2@gObjTradeI

; 18615: 	{
; 18616: 		LogAdd("error : %s %d", __FILE__, __LINE__);

  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjTradeInventoryMove@@YAEPAVOBJECTSTRUCT@@EE@Z@4JA
  00021	83 c0 05	 add	 eax, 5
  00024	50		 push	 eax
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18617: 		return 0xFF;

  00038	0c ff		 or	 al, 255			; 000000ffH
  0003a	e9 ff 02 00 00	 jmp	 $LN1@gObjTradeI
$LN2@gObjTradeI:

; 18618: 	}
; 18619: 	
; 18620: 	if( target > MAX_INVENTORY )

  0003f	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  00043	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  00046	7e 23		 jle	 SHORT $LN3@gObjTradeI

; 18621: 	{
; 18622: 		LogAdd("error : %s %d", __FILE__, __LINE__);

  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjTradeInventoryMove@@YAEPAVOBJECTSTRUCT@@EE@Z@4JA
  0004d	83 c0 0b	 add	 eax, 11			; 0000000bH
  00050	50		 push	 eax
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18623: 		return 0xFF;

  00064	0c ff		 or	 al, 255			; 000000ffH
  00066	e9 d3 02 00 00	 jmp	 $LN1@gObjTradeI
$LN3@gObjTradeI:

; 18624: 	}
; 18625: 
; 18626: 	if( lpObj->TargetNumber < 0 ) return 0xFF;

  0006b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006e	0f bf 88 ac 02
	00 00		 movsx	 ecx, WORD PTR [eax+684]
  00075	85 c9		 test	 ecx, ecx
  00077	7d 07		 jge	 SHORT $LN4@gObjTradeI
  00079	0c ff		 or	 al, 255			; 000000ffH
  0007b	e9 be 02 00 00	 jmp	 $LN1@gObjTradeI
$LN4@gObjTradeI:

; 18627: 
; 18628: 	//   ?
; 18629: 	if( lpObj->Trade[source].IsItem() == FALSE )

  00080	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00084	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0008a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0008d	03 8a 84 0c 00
	00		 add	 ecx, DWORD PTR [edx+3204]
  00093	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00098	85 c0		 test	 eax, eax
  0009a	75 07		 jne	 SHORT $LN5@gObjTradeI

; 18630: 	{
; 18631: 		return 0xFF;

  0009c	0c ff		 or	 al, 255			; 000000ffH
  0009e	e9 9b 02 00 00	 jmp	 $LN1@gObjTradeI
$LN5@gObjTradeI:

; 18632: 	}
; 18633: 	
; 18634: 	//       .
; 18635: 	if( (lpObj->m_IfState.use == 0) || ( lpObj->m_IfState.type != I_TRADE ))

  000a3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a6	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000ac	80 e1 03	 and	 cl, 3
  000af	0f b6 d1	 movzx	 edx, cl
  000b2	85 d2		 test	 edx, edx
  000b4	74 17		 je	 SHORT $LN7@gObjTradeI
  000b6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b9	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000bf	c0 e9 04	 shr	 cl, 4
  000c2	80 e1 0f	 and	 cl, 15			; 0000000fH
  000c5	0f b6 d1	 movzx	 edx, cl
  000c8	83 fa 01	 cmp	 edx, 1
  000cb	74 07		 je	 SHORT $LN6@gObjTradeI
$LN7@gObjTradeI:

; 18636: 	{
; 18637: 		return 0xFF;

  000cd	0c ff		 or	 al, 255			; 000000ffH
  000cf	e9 6a 02 00 00	 jmp	 $LN1@gObjTradeI
$LN6@gObjTradeI:

; 18638: 	}	
; 18639: 	if( gObjInventoryInsertItemPos(lpObj->m_Index, lpObj->Trade[source], target, 1) == 0xFF ) return 0xFF;

  000d4	6a 01		 push	 1
  000d6	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  000da	50		 push	 eax
  000db	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _source$[ebp]
  000df	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  000e5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e8	8b b0 84 0c 00
	00		 mov	 esi, DWORD PTR [eax+3204]
  000ee	03 f2		 add	 esi, edx
  000f0	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  000f6	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  000fb	8b fc		 mov	 edi, esp
  000fd	f3 a5		 rep movsd
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00102	8b 11		 mov	 edx, DWORD PTR [ecx]
  00104	52		 push	 edx
  00105	e8 00 00 00 00	 call	 ?gObjInventoryInsertItemPos@@YAEHVCItem@@HH@Z ; gObjInventoryInsertItemPos
  0010a	81 c4 b4 00 00
	00		 add	 esp, 180		; 000000b4H
  00110	0f b6 c0	 movzx	 eax, al
  00113	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00118	75 07		 jne	 SHORT $LN8@gObjTradeI
  0011a	0c ff		 or	 al, 255			; 000000ffH
  0011c	e9 1d 02 00 00	 jmp	 $LN1@gObjTradeI
$LN8@gObjTradeI:

; 18640: 	
; 18641: 	DWORD s_num=0;

  00121	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _s_num$[ebp], 0

; 18642: 	s_num = lpObj->Trade[source].m_Number;

  00128	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0012c	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  00132	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00135	8b 82 84 0c 00
	00		 mov	 eax, DWORD PTR [edx+3204]
  0013b	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0013e	89 4d f0	 mov	 DWORD PTR _s_num$[ebp], ecx

; 18643: 	lpObj->Trade[source].GetSize(iwidth, iheight);

  00141	8d 45 f4	 lea	 eax, DWORD PTR _iheight$[ebp]
  00144	50		 push	 eax
  00145	8d 4d f8	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00148	51		 push	 ecx
  00149	0f b6 55 0c	 movzx	 edx, BYTE PTR _source$[ebp]
  0014d	69 ca a8 00 00
	00		 imul	 ecx, edx, 168
  00153	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00156	03 88 84 0c 00
	00		 add	 ecx, DWORD PTR [eax+3204]
  0015c	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 18644: 	
; 18645: 	gObjTradeItemBoxSet(lpObj->m_Index, source, iwidth, iheight, 0xFF);

  00161	68 ff 00 00 00	 push	 255			; 000000ffH
  00166	8b 45 f4	 mov	 eax, DWORD PTR _iheight$[ebp]
  00169	50		 push	 eax
  0016a	8b 4d f8	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  0016d	51		 push	 ecx
  0016e	0f b6 55 0c	 movzx	 edx, BYTE PTR _source$[ebp]
  00172	52		 push	 edx
  00173	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00176	8b 08		 mov	 ecx, DWORD PTR [eax]
  00178	51		 push	 ecx
  00179	e8 00 00 00 00	 call	 ?gObjTradeItemBoxSet@@YAHHHHHE@Z ; gObjTradeItemBoxSet
  0017e	83 c4 14	 add	 esp, 20			; 00000014H

; 18646: 	
; 18647: 	lpObj->Trade[source].Clear();

  00181	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00185	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0018b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0018e	03 8a 84 0c 00
	00		 add	 ecx, DWORD PTR [edx+3204]
  00194	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 18648: 
; 18649: 	BYTE itembuf[ITEM_BUFFER_SIZE];
; 18650: 
; 18651: 	ItemByteConvert(itembuf, lpObj->Trade[source]);	

  00199	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0019d	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  001a3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001a6	8b b2 84 0c 00
	00		 mov	 esi, DWORD PTR [edx+3204]
  001ac	03 f1		 add	 esi, ecx
  001ae	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  001b4	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  001b9	8b fc		 mov	 edi, esp
  001bb	f3 a5		 rep movsd
  001bd	8d 45 e8	 lea	 eax, DWORD PTR _itembuf$[ebp]
  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  001c6	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 18652: 	GCTradeOtherDel(lpObj->TargetNumber, source);

  001cc	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  001d0	50		 push	 eax
  001d1	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001d4	0f bf 91 ac 02
	00 00		 movsx	 edx, WORD PTR [ecx+684]
  001db	52		 push	 edx
  001dc	e8 00 00 00 00	 call	 ?GCTradeOtherDel@@YAHHE@Z ; GCTradeOtherDel
  001e1	83 c4 08	 add	 esp, 8

; 18653: 
; 18654: #ifdef ANTIHACKING_SERIAL_0_ITEM_20051202	
; 18655: 	if( gObjCheckSerial0ItemList(&lpObj->Trade[source]) )

  001e4	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  001e8	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  001ee	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001f1	03 8a 84 0c 00
	00		 add	 ecx, DWORD PTR [edx+3204]
  001f7	51		 push	 ecx
  001f8	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  001fd	83 c4 04	 add	 esp, 4
  00200	85 c0		 test	 eax, eax
  00202	74 60		 je	 SHORT $LN9@gObjTradeI

; 18656: 	{
; 18657: 		// MODIFY_LOCALIZING_WTF_20060309  wtf   0.99.60 - 0.99.94
; 18658: 		MsgOutput( lpObj->m_Index, lMsg.Get(3354) );			// "  .  ."

  00204	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  00209	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0020e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00214	50		 push	 eax
  00215	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00218	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021a	51		 push	 ecx
  0021b	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00220	83 c4 08	 add	 esp, 8

; 18659: 		LogAddTD( "[ANTI-HACK][Serial 0 Item] [Trade] (%s)(%s) Item(%s) Pos(%d)",

  00223	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00227	50		 push	 eax
  00228	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _source$[ebp]
  0022c	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00232	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00235	03 8a 84 0c 00
	00		 add	 ecx, DWORD PTR [edx+3204]
  0023b	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00240	50		 push	 eax
  00241	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00244	83 c0 73	 add	 eax, 115		; 00000073H
  00247	50		 push	 eax
  00248	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0024b	83 c1 68	 add	 ecx, 104		; 00000068H
  0024e	51		 push	 ecx
  0024f	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@CJKEGDHI@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLTra@
  00254	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0025a	83 c4 14	 add	 esp, 20			; 00000014H

; 18660: 				lpObj->AccountID, lpObj->Name, lpObj->Trade[source].GetName(), source );
; 18661: 		return 0xFF;

  0025d	0c ff		 or	 al, 255			; 000000ffH
  0025f	e9 da 00 00 00	 jmp	 $LN1@gObjTradeI
$LN9@gObjTradeI:

; 18662: 	}
; 18663: #endif
; 18664: 	
; 18665: 	if( gObjInventorySearchSerialNumber(lpObj, s_num) == FALSE )

  00264	8b 45 f0	 mov	 eax, DWORD PTR _s_num$[ebp]
  00267	50		 push	 eax
  00268	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0026b	51		 push	 ecx
  0026c	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  00271	83 c4 08	 add	 esp, 8
  00274	85 c0		 test	 eax, eax
  00276	75 07		 jne	 SHORT $LN10@gObjTradeI

; 18666: 	{
; 18667: 		return 0xFF;

  00278	0c ff		 or	 al, 255			; 000000ffH
  0027a	e9 bf 00 00 00	 jmp	 $LN1@gObjTradeI
$LN10@gObjTradeI:

; 18668: 	}
; 18669: 
; 18670: 	if( target < MAX_EQUIPMENT ) 

  0027f	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  00283	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00286	0f 8d b0 00 00
	00		 jge	 $LN11@gObjTradeI

; 18671: 	{
; 18672: 		if( lpObj->pInventory[target].IsItem()== TRUE)

  0028c	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  00290	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  00296	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00299	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0029f	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  002a4	83 f8 01	 cmp	 eax, 1
  002a7	75 72		 jne	 SHORT $LN12@gObjTradeI

; 18673: 		{
; 18674: 			if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(13,10) )

  002a9	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  002ad	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  002b3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002b6	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  002bc	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  002c1	6a 0a		 push	 10			; 0000000aH
  002c3	6a 0d		 push	 13			; 0000000dH
  002c5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  002ca	83 c4 08	 add	 esp, 8
  002cd	3b f0		 cmp	 esi, eax
  002cf	75 4a		 jne	 SHORT $LN12@gObjTradeI

; 18675: 			{
; 18676: 				gObjUseSkill.SkillChangeUse(lpObj->m_Index);				

  002d1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d6	51		 push	 ecx
  002d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  002dc	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 18677: 				LogAdd(lMsg.Get(534), lpObj->Name, lpObj->pInventory[target].m_Level);

  002e1	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  002e5	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  002eb	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002ee	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  002f4	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  002f9	51		 push	 ecx
  002fa	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002fd	83 c2 73	 add	 edx, 115		; 00000073H
  00300	52		 push	 edx
  00301	68 16 02 00 00	 push	 534			; 00000216H
  00306	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0030b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00311	50		 push	 eax
  00312	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00318	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@gObjTradeI:

; 18678: 			}
; 18679: #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	//   
; 18680: 			if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 39 ) )
; 18681: 			{
; 18682: 				gObjUseSkill.SkillChangeUse(lpObj->m_Index);				
; 18683: 				LogAdd(lMsg.Get(534), lpObj->Name, lpObj->pInventory[target].m_Level);
; 18684: 			}
; 18685: #endif
; 18686: 
; 18687: #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 18688: 			if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 40 ) )
; 18689: 			{
; 18690: 				gObjUseSkill.SkillChangeUse(lpObj->m_Index);				
; 18691: 				LogAdd(lMsg.Get(534), lpObj->Name, lpObj->pInventory[target].m_Level);
; 18692: 			}
; 18693: #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 18694: 
; 18695: #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 18696: 			if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 41 ) )
; 18697: 			{
; 18698: 				gObjUseSkill.SkillChangeUse( lpObj->m_Index );
; 18699: 				LogAdd( lMsg.Get( 534 ), lpObj->Name, lpObj->pInventory[target].m_Level );
; 18700: 			}
; 18701: #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 18702: #ifdef MODIFY_SNOW_MAN_PANDA_POLYMORPH_RING_BUGFIX_20090715
; 18703: 			if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 68 ) )
; 18704: 			{
; 18705: 				gObjUseSkill.SkillChangeUse( lpObj->m_Index );
; 18706: 				LogAdd( lMsg.Get( 534 ), lpObj->Name, lpObj->pInventory[target].m_Level );
; 18707: 			}
; 18708: 			if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 76 ) )
; 18709: 			{
; 18710: 				gObjUseSkill.SkillChangeUse( lpObj->m_Index );
; 18711: 				LogAdd( lMsg.Get( 534 ), lpObj->Name, lpObj->pInventory[target].m_Level );
; 18712: 			}
; 18713: #endif // MODIFY_SNOW_MAN_PANDA_POLYMORPH_RING_BUGFIX_20090715			
; 18714: 		}
; 18715: 		gObjMakePreviewCharSet(lpObj->m_Index);

  0031b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0031e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00320	51		 push	 ecx
  00321	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  00326	83 c4 04	 add	 esp, 4

; 18716: 		GCEquipmentChange(lpObj->m_Index, target);

  00329	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  0032d	50		 push	 eax
  0032e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00331	8b 11		 mov	 edx, DWORD PTR [ecx]
  00333	52		 push	 edx
  00334	e8 00 00 00 00	 call	 ?GCEquipmentChange@@YAXHH@Z ; GCEquipmentChange
  00339	83 c4 08	 add	 esp, 8
$LN11@gObjTradeI:

; 18717: 	}
; 18718: 	return 0x00;

  0033c	32 c0		 xor	 al, al
$LN1@gObjTradeI:

; 18719: }

  0033e	5f		 pop	 edi
  0033f	5e		 pop	 esi
  00340	5b		 pop	 ebx
  00341	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00344	33 cd		 xor	 ecx, ebp
  00346	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034b	8b e5		 mov	 esp, ebp
  0034d	5d		 pop	 ebp
  0034e	c3		 ret	 0
?gObjTradeInventoryMove@@YAEPAVOBJECTSTRUCT@@EE@Z ENDP	; gObjTradeInventoryMove
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z
_TEXT	SEGMENT
tv1130 = -244						; size = 4
tv1100 = -244						; size = 4
tv1042 = -244						; size = 4
tv965 = -244						; size = 4
tv859 = -244						; size = 4
tv817 = -244						; size = 4
tv753 = -244						; size = 4
tv738 = -244						; size = 4
tv361 = -244						; size = 4
tv131 = -244						; size = 4
_ret$2 = -174						; size = 1
_ret$3 = -173						; size = 1
_addskill$4 = -172					; size = 4
_lpItem$5 = -168					; size = 4
_sdur$6 = -164						; size = 4
_total$7 = -160						; size = 4
_max_count$8 = -156					; size = 4
_type$9 = -152						; size = 4
_dur$10 = -146						; size = 1
_op3$11 = -145						; size = 1
_op2$12 = -144						; size = 1
_op1$13 = -143						; size = 1
_level$14 = -142					; size = 1
_sp_ret$ = -141						; size = 1
_useClass$ = -140					; size = 4
_bSourceIsPShop$ = -136					; size = 4
_bPersonalShopTrans$ = -132				; size = 4
_titem$ = -128						; size = 4
_sitem$ = -124						; size = 4
_s_num$ = -120						; size = 4
_blank$ = -116						; size = 4
_iheight$ = -112					; size = 4
_iwidth$ = -108						; size = 4
_h$ = -104						; size = 4
_w$ = -100						; size = 4
_TempInventoryMap$ = -96				; size = 64
_lpObj$ = -32						; size = 4
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_aIndex$ = 8						; size = 4
_source$ = 12						; size = 1
_target$ = 16						; size = 1
_durSsend$ = 20						; size = 4
_durTsend$ = 24						; size = 4
_sFlag$ = 28						; size = 1
_tFlag$ = 32						; size = 1
_siteminfo$ = 36					; size = 4
?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z PROC		; gObjInventoryMoveItem, COMDAT

; 16776: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	81 c4 1c ff ff
	ff		 add	 esp, -228		; ffffff1cH
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	53		 push	 ebx
  0002a	56		 push	 esi
  0002b	57		 push	 edi
  0002c	50		 push	 eax
  0002d	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 16777: 	LPOBJECTSTRUCT	lpObj;
; 16778: 	BYTE			TempInventoryMap[8*8];				//   
; 16779: 	int				w, h, iwidth, iheight;
; 16780: 	int				blank;
; 16781: 	DWORD			s_num;
; 16782: 	CItem*			sitem;
; 16783: 	CItem*			titem;
; 16784: 
; 16785: #ifdef PERSONAL_SHOP_20040113 
; 16786: 	BOOL			bPersonalShopTrans	= FALSE;

  00036	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _bPersonalShopTrans$[ebp], 0

; 16787: 	BOOL			bSourceIsPShop		= FALSE;		//  ->        

  00040	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _bSourceIsPShop$[ebp], 0

; 16788: #endif
; 16789: 	
; 16790: 	durSsend = 0;

  0004a	8b 45 14	 mov	 eax, DWORD PTR _durSsend$[ebp]
  0004d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 16791: 	durTsend = 0;

  00053	8b 45 18	 mov	 eax, DWORD PTR _durTsend$[ebp]
  00056	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 16792: 
; 16793: 	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  0005c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00063	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00069	89 45 e0	 mov	 DWORD PTR _lpObj$[ebp], eax

; 16794: 
; 16795: 	BOOL useClass=FALSE;

  0006c	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _useClass$[ebp], 0

; 16796: 
; 16797: 	BYTE sp_ret = 0x00;

  00076	c6 85 73 ff ff
	ff 00		 mov	 BYTE PTR _sp_ret$[ebp], 0

; 16798: 
; 16799: #define LEAVE_SET(x) {sp_ret = x; __leave;}
; 16800: 
; 16801: 	__try {

  0007d	9b		 fwait
  0007e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 16802: 		if( sFlag == ITEMMOVE_WAREHOUSE || tFlag == ITEMMOVE_WAREHOUSE )

  00085	0f b6 45 1c	 movzx	 eax, BYTE PTR _sFlag$[ebp]
  00089	83 f8 02	 cmp	 eax, 2
  0008c	74 0d		 je	 SHORT $LN24@gObjInvent
  0008e	0f b6 45 20	 movzx	 eax, BYTE PTR _tFlag$[ebp]
  00092	83 f8 02	 cmp	 eax, 2
  00095	0f 85 97 00 00
	00		 jne	 $LN27@gObjInvent
$LN24@gObjInvent:

; 16803: 		{
; 16804: 			//  ..    ..   .
; 16805: 			if( lpObj->m_IfState.type != I_WAREHOUSE ) 

  0009b	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009e	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000a4	c0 e9 04	 shr	 cl, 4
  000a7	80 e1 0f	 and	 cl, 15			; 0000000fH
  000aa	0f b6 d1	 movzx	 edx, cl
  000ad	83 fa 06	 cmp	 edx, 6
  000b0	74 36		 je	 SHORT $LN25@gObjInvent

; 16806: 			{
; 16807: 				LogAdd(lMsg.Get(531), lpObj->AccountID, lpObj->Name);

  000b2	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b5	83 c0 73	 add	 eax, 115		; 00000073H
  000b8	50		 push	 eax
  000b9	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000bc	83 c1 68	 add	 ecx, 104		; 00000068H
  000bf	51		 push	 ecx
  000c0	68 13 02 00 00	 push	 531			; 00000213H
  000c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000d0	50		 push	 eax
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16808: 				LEAVE_SET(0xFF);

  000da	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  000e1	e9 c2 19 00 00	 jmp	 $LN181@gObjInvent

; 16809: 			}

  000e6	eb 4a		 jmp	 SHORT $LN27@gObjInvent
$LN25@gObjInvent:

; 16810: 			else if( lpObj->m_IfState.state == 0 ) 

  000e8	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000eb	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000f1	c0 e9 02	 shr	 cl, 2
  000f4	80 e1 03	 and	 cl, 3
  000f7	0f b6 d1	 movzx	 edx, cl
  000fa	85 d2		 test	 edx, edx
  000fc	75 34		 jne	 SHORT $LN27@gObjInvent

; 16811: 			{
; 16812: 				LogAdd(lMsg.Get(531), lpObj->AccountID, lpObj->Name);

  000fe	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00101	83 c0 73	 add	 eax, 115		; 00000073H
  00104	50		 push	 eax
  00105	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00108	83 c1 68	 add	 ecx, 104		; 00000068H
  0010b	51		 push	 ecx
  0010c	68 13 02 00 00	 push	 531			; 00000213H
  00111	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0011c	50		 push	 eax
  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00123	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16813: 				LEAVE_SET(0xFF);

  00126	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  0012d	e9 76 19 00 00	 jmp	 $LN181@gObjInvent
$LN27@gObjInvent:

; 16814: 			}
; 16815: 		}
; 16816: 
; 16817: 		//    
; 16818: 		switch( sFlag )

  00132	0f b6 45 1c	 movzx	 eax, BYTE PTR _sFlag$[ebp]
  00136	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv131[ebp], eax
  0013c	83 bd 0c ff ff
	ff 05		 cmp	 DWORD PTR tv131[ebp], 5
  00143	0f 87 34 04 00
	00		 ja	 $LN54@gObjInvent
  00149	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv131[ebp]
  0014f	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN190@gObjInvent[ecx*4]
$LN28@gObjInvent:

; 16819: 		{
; 16820: 		case ITEMMOVE_INVENTORY :
; 16821: 			if( source < 0 || source > MAX_INVENTORY-1 )

  00156	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0015a	85 c0		 test	 eax, eax
  0015c	7c 09		 jl	 SHORT $LN30@gObjInvent
  0015e	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00162	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  00165	7e 28		 jle	 SHORT $LN29@gObjInvent
$LN30@gObjInvent:

; 16822: 			{
; 16823: 				LogAdd("error-L1 : %s %d", __FILE__, __LINE__);

  00167	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z@4JA
  0016c	83 c0 2f	 add	 eax, 47			; 0000002fH
  0016f	50		 push	 eax
  00170	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00175	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd@
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00180	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16824: 				LEAVE_SET(0xFF);

  00183	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  0018a	e9 19 19 00 00	 jmp	 $LN181@gObjInvent
$LN29@gObjInvent:

; 16825: 			}
; 16826: 			if( lpObj->pInventory[source].IsItem() == FALSE ) 

  0018f	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00193	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  00199	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0019c	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  001a2	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  001a7	85 c0		 test	 eax, eax
  001a9	75 3d		 jne	 SHORT $LN31@gObjInvent

; 16827: 			{
; 16828: 				LogAdd(lMsg.Get(532), lpObj->AccountID, lpObj->Name, __LINE__);

  001ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z@4JA
  001b0	83 c0 34	 add	 eax, 52			; 00000034H
  001b3	50		 push	 eax
  001b4	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001b7	83 c1 73	 add	 ecx, 115		; 00000073H
  001ba	51		 push	 ecx
  001bb	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001be	83 c2 68	 add	 edx, 104		; 00000068H
  001c1	52		 push	 edx
  001c2	68 14 02 00 00	 push	 532			; 00000214H
  001c7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001d2	50		 push	 eax
  001d3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001d9	83 c4 10	 add	 esp, 16			; 00000010H

; 16829: 				LEAVE_SET(0xFF);

  001dc	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  001e3	e9 c0 18 00 00	 jmp	 $LN181@gObjInvent
$LN31@gObjInvent:

; 16830: 			}
; 16831: 			sitem = &lpObj->pInventory[source];

  001e8	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  001ec	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  001f2	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001f5	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  001fb	89 4d 84	 mov	 DWORD PTR _sitem$[ebp], ecx

; 16832: 
; 16833: #ifdef NEW_SKILL_FORSKYLAND
; 16834: 			if( lpObj->MapNumber == 10 )

  001fe	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00201	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00208	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0020b	0f 85 83 00 00
	00		 jne	 $LN38@gObjInvent

; 16835: 			{	//   
; 16836: 				if( source == EQUIPMENT_HELPER  )

  00211	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00215	83 f8 08	 cmp	 eax, 8
  00218	75 3f		 jne	 SHORT $LN33@gObjInvent

; 16837: 				{
; 16838: 					if( sitem->m_Type == MAKE_ITEMNUM(13,3) )

  0021a	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  0021d	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00221	6a 03		 push	 3
  00223	6a 0d		 push	 13			; 0000000dH
  00225	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0022a	83 c4 08	 add	 esp, 8
  0022d	3b f0		 cmp	 esi, eax
  0022f	75 26		 jne	 SHORT $LN36@gObjInvent

; 16839: 					{	//   
; 16840: 						if( !lpObj->pInventory[EQUIPMENT_WING].IsItem() )

  00231	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00236	6b c8 07	 imul	 ecx, eax, 7
  00239	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0023c	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00242	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00247	85 c0		 test	 eax, eax
  00249	75 0c		 jne	 SHORT $LN36@gObjInvent

; 16841: 						{	//     
; 16842: 							LEAVE_SET(0xFF);

  0024b	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00252	e9 51 18 00 00	 jmp	 $LN181@gObjInvent
$LN36@gObjInvent:

; 16843: 						}
; 16844: 					}
; 16845: 	#ifdef ADD_ITEM_FENRIR_01_20051110
; 16846: 					else if( sitem->m_Type == MAKE_ITEMNUM(13,37) )
; 16847: 					{	//   
; 16848: 						if( !lpObj->pInventory[EQUIPMENT_WING].IsItem() )
; 16849: 						{	//     
; 16850: 							LEAVE_SET(0xFF);
; 16851: 						}
; 16852: 					}
; 16853: 	#endif
; 16854: 	#ifdef MODIFY_SKYLAND_FENRIR_AND_WING_BUGFIX_20080730
; 16855: 					else if( sitem->m_Type == MAKE_ITEMNUM(13,4) )
; 16856: 					{	//   
; 16857: 						if( !lpObj->pInventory[EQUIPMENT_WING].IsItem() )
; 16858: 						{	//     
; 16859: 							LEAVE_SET(0xFF);
; 16860: 						}
; 16861: 					}
; 16862: 	#endif // MODIFY_SKYLAND_FENRIR_AND_WING_BUGFIX_20080730
; 16863: 				}

  00257	eb 3b		 jmp	 SHORT $LN38@gObjInvent
$LN33@gObjInvent:

; 16864: 				else if( source == EQUIPMENT_WING )

  00259	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0025d	83 f8 07	 cmp	 eax, 7
  00260	75 32		 jne	 SHORT $LN38@gObjInvent

; 16865: 				{
; 16866: 	#ifdef MODIFY_SKYLAND_FENRIR_AND_WING_BUGFIX_20080730
; 16867: 					//   
; 16868: 					if( lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,3)	//  
; 16869: 						&& lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,37)	//  
; 16870: 						&& lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,4) )	//  
; 16871: 					{	//   .
; 16872: 						LEAVE_SET(0xFF);
; 16873: 					}
; 16874: 	#else
; 16875: 					if( lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,3) )

  00262	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00267	c1 e0 03	 shl	 eax, 3
  0026a	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0026d	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00273	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00278	6a 03		 push	 3
  0027a	6a 0d		 push	 13			; 0000000dH
  0027c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00281	83 c4 08	 add	 esp, 8
  00284	3b f0		 cmp	 esi, eax
  00286	74 0c		 je	 SHORT $LN38@gObjInvent

; 16876: 					{	//     
; 16877: 						LEAVE_SET(0xFF);

  00288	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  0028f	e9 14 18 00 00	 jmp	 $LN181@gObjInvent
$LN38@gObjInvent:

; 16878: 					}
; 16879: 	#endif // MODIFY_SKYLAND_FENRIR_AND_WING_BUGFIX_20080730
; 16880: 				}			
; 16881: 			}
; 16882: #endif
; 16883: 
; 16884: 			break;

  00294	e9 f0 02 00 00	 jmp	 $LN2@gObjInvent
$LN39@gObjInvent:

; 16885: 		case ITEMMOVE_WAREHOUSE :	//  
; 16886: 			if( source < 0 || source > MAX_WAREHOUSEITEMS-1 )

  00299	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0029d	85 c0		 test	 eax, eax
  0029f	7c 09		 jl	 SHORT $LN41@gObjInvent
  002a1	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  002a5	83 f8 77	 cmp	 eax, 119		; 00000077H
  002a8	7e 28		 jle	 SHORT $LN40@gObjInvent
$LN41@gObjInvent:

; 16887: 			{
; 16888: 				LogAdd("error-L1 : %s %d", __FILE__, __LINE__);

  002aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z@4JA
  002af	83 c0 70	 add	 eax, 112		; 00000070H
  002b2	50		 push	 eax
  002b3	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  002b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd@
  002bd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002c3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16889: 				LEAVE_SET(0xFF);

  002c6	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  002cd	e9 d6 17 00 00	 jmp	 $LN181@gObjInvent
$LN40@gObjInvent:

; 16890: 			}
; 16891: 			if( lpObj->pWarehouse[source].IsItem() == FALSE ) 

  002d2	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  002d6	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  002dc	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002df	03 8a 94 0c 00
	00		 add	 ecx, DWORD PTR [edx+3220]
  002e5	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  002ea	85 c0		 test	 eax, eax
  002ec	75 3d		 jne	 SHORT $LN42@gObjInvent

; 16892: 			{
; 16893: 				LogAdd(lMsg.Get(532), lpObj->AccountID, lpObj->Name, __LINE__);

  002ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z@4JA
  002f3	83 c0 75	 add	 eax, 117		; 00000075H
  002f6	50		 push	 eax
  002f7	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002fa	83 c1 73	 add	 ecx, 115		; 00000073H
  002fd	51		 push	 ecx
  002fe	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00301	83 c2 68	 add	 edx, 104		; 00000068H
  00304	52		 push	 edx
  00305	68 14 02 00 00	 push	 532			; 00000214H
  0030a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0030f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00315	50		 push	 eax
  00316	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0031c	83 c4 10	 add	 esp, 16			; 00000010H

; 16894: 				LEAVE_SET(0xFF);

  0031f	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00326	e9 7d 17 00 00	 jmp	 $LN181@gObjInvent
$LN42@gObjInvent:

; 16895: 			}
; 16896: 			sitem = &lpObj->pWarehouse[source];

  0032b	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0032f	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  00335	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00338	03 8a 94 0c 00
	00		 add	 ecx, DWORD PTR [edx+3220]
  0033e	89 4d 84	 mov	 DWORD PTR _sitem$[ebp], ecx

; 16897: 			break;

  00341	e9 43 02 00 00	 jmp	 $LN2@gObjInvent
$LN43@gObjInvent:

; 16898: #ifdef DARKLORD_WORK
; 16899: 		case ITEMMOVE_DARK_TRAINER :	// 2()
; 16900: #endif
; 16901: #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 16902: 		case ITEMMOVE_JEWELOFHARMONY_PURITY:	// 
; 16903: 		case ITEMMOVE_JEWELOFHARMONY_SMELT:		//  
; 16904: 		case ITEMMOVE_JEWELOFHARMONY_RESTORE:	// 
; 16905: #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 16906: #ifdef ADD_PCS_LOTTERY_SYSTEM_20070117
; 16907: 		case ITEMMOVE_LOTTERY_MIX:
; 16908: #endif // ADD_PCS_LOTTERY_SYSTEM_20070117
; 16909: #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312
; 16910: 		case ITEMMOVE_CHERRYBLOSSOM:
; 16911: #endif // ADD_EVENT_CHERRYBLOSSOM_20080312
; 16912: #ifdef ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 16913: 		case ITEMMOVE_SOCKET_ITEM_EXTRACT:		//  
; 16914: 		case ITEMMOVE_SOCKET_ITEM_COMPOSIT:		//  
; 16915: 		case ITEMMOVE_SOCKET_ITEM_EQUIP:		//  
; 16916: 		case ITEMMOVE_SOCKET_ITEM_REMOVE:		//  
; 16917: #endif // ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 16918: 		case ITEMMOVE_CHAOSBOX :	// 
; 16919: 			if( source < 0 || source > MAX_CHAOSBOXITEMS-1 )

  00346	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0034a	85 c0		 test	 eax, eax
  0034c	7c 09		 jl	 SHORT $LN45@gObjInvent
  0034e	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00352	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00355	7e 2a		 jle	 SHORT $LN44@gObjInvent
$LN45@gObjInvent:

; 16920: 			{
; 16921: 				LogAdd("error-L1 : %s %d", __FILE__, __LINE__);

  00357	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z@4JA
  0035c	05 91 00 00 00	 add	 eax, 145		; 00000091H
  00361	50		 push	 eax
  00362	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00367	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd@
  0036c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00372	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16922: 				LEAVE_SET(0xFF);

  00375	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  0037c	e9 27 17 00 00	 jmp	 $LN181@gObjInvent
$LN44@gObjInvent:

; 16923: 			}
; 16924: 			if( lpObj->pChaosBox[source].IsItem() == FALSE ) 

  00381	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00385	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0038b	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0038e	03 8a ac 0c 00
	00		 add	 ecx, DWORD PTR [edx+3244]
  00394	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00399	85 c0		 test	 eax, eax
  0039b	75 3f		 jne	 SHORT $LN46@gObjInvent

; 16925: 			{
; 16926: 				LogAdd(lMsg.Get(532), lpObj->AccountID, lpObj->Name, __LINE__);

  0039d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z@4JA
  003a2	05 96 00 00 00	 add	 eax, 150		; 00000096H
  003a7	50		 push	 eax
  003a8	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003ab	83 c1 73	 add	 ecx, 115		; 00000073H
  003ae	51		 push	 ecx
  003af	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003b2	83 c2 68	 add	 edx, 104		; 00000068H
  003b5	52		 push	 edx
  003b6	68 14 02 00 00	 push	 532			; 00000214H
  003bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  003c6	50		 push	 eax
  003c7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  003cd	83 c4 10	 add	 esp, 16			; 00000010H

; 16927: 				LEAVE_SET(0xFF);

  003d0	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  003d7	e9 cc 16 00 00	 jmp	 $LN181@gObjInvent
$LN46@gObjInvent:

; 16928: 			}
; 16929: 			sitem = &lpObj->pChaosBox[source];

  003dc	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  003e0	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  003e6	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003e9	03 8a ac 0c 00
	00		 add	 ecx, DWORD PTR [edx+3244]
  003ef	89 4d 84	 mov	 DWORD PTR _sitem$[ebp], ecx

; 16930: 			//lpObj->ChaosSuccessRate -= (sitem->m_BuyMoney/20000);
; 16931: 			//lpObj->ChaosMoney -= lpObj->ChaosSuccessRate*100000;
; 16932: 			//LogAdd("[%s][%s]   : %d  : %d",lpObj->AccountID, lpObj->Name, lpObj->ChaosMoney, lpObj->ChaosSuccessRate);
; 16933: 			break;

  003f2	e9 92 01 00 00	 jmp	 $LN2@gObjInvent
$LN47@gObjInvent:

; 16934: #ifdef PERSONAL_SHOP_20040113
; 16935: 		case ITEMMOVE_PSHOPWND :	// 
; 16936: //			if (gDoPShopOpen == 0) {
; 16937: //				return 0xFF;
; 16938: //			}
; 16939: 
; 16940: 			if (gObj[aIndex].m_bPShopOpen == true) {

  003f7	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00404	0f b6 94 01 f8
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3320]
  0040c	83 fa 01	 cmp	 edx, 1
  0040f	75 0c		 jne	 SHORT $LN48@gObjInvent

; 16941: 				//       
; 16942: 				LEAVE_SET(0xFF);

  00411	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00418	e9 8b 16 00 00	 jmp	 $LN181@gObjInvent
$LN48@gObjInvent:

; 16943: 			}
; 16944: 
; 16945: 			//---------------------------------------
; 16946: 			//    .
; 16947: 			EnterCriticalSection(&gObj[aIndex].m_critPShopTrade);

  0041d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00424	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0042a	8d 94 01 34 0d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+3380]
  00431	52		 push	 edx
  00432	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 16948: 			if (gObj[aIndex].m_bPShopTransaction == true) {

  00438	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0043f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00445	0f b6 94 01 f9
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3321]
  0044d	83 fa 01	 cmp	 edx, 1
  00450	75 4f		 jne	 SHORT $LN49@gObjInvent

; 16949: 				LogAddTD("[PShop] [%s][%s] PShop Item Move Request Failed : Already Trade With Other",

  00452	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00459	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0045f	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00463	52		 push	 edx
  00464	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0046b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00471	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00475	52		 push	 edx
  00476	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@PCJJPCHK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Mov@
  0047b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00481	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16950: 					gObj[aIndex].AccountID,
; 16951: 					gObj[aIndex].Name
; 16952: 					);
; 16953: 				
; 16954: 				LeaveCriticalSection(&lpObj->m_critPShopTrade);

  00484	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00487	05 34 0d 00 00	 add	 eax, 3380		; 00000d34H
  0048c	50		 push	 eax
  0048d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 16955: 				LEAVE_SET(0xFF);

  00493	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  0049a	e9 09 16 00 00	 jmp	 $LN181@gObjInvent

; 16956: 			}

  0049f	eb 1e		 jmp	 SHORT $LN50@gObjInvent
$LN49@gObjInvent:

; 16957: 			else  {
; 16958: 				lpObj->m_bPShopTransaction	= true;

  004a1	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004a4	c6 80 f9 0c 00
	00 01		 mov	 BYTE PTR [eax+3321], 1

; 16959: 				bPersonalShopTrans			= TRUE;

  004ab	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _bPersonalShopTrans$[ebp], 1

; 16960: 				bSourceIsPShop				= TRUE;

  004b5	c7 85 78 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _bSourceIsPShop$[ebp], 1
$LN50@gObjInvent:

; 16961: 			}
; 16962: 			LeaveCriticalSection(&lpObj->m_critPShopTrade);

  004bf	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004c2	05 34 0d 00 00	 add	 eax, 3380		; 00000d34H
  004c7	50		 push	 eax
  004c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 16963: 			//---------------------------------------
; 16964: 
; 16965: 			if( source < MAX_INVENTORY || source > MAX_INVENTORY_EXTEND-1 )

  004ce	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  004d2	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  004d5	7c 09		 jl	 SHORT $LN52@gObjInvent
  004d7	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  004db	83 f8 6b	 cmp	 eax, 107		; 0000006bH
  004de	7e 2a		 jle	 SHORT $LN51@gObjInvent
$LN52@gObjInvent:

; 16966: 			{
; 16967: 				LogAdd("error-L1 : %s %d", __FILE__, __LINE__);

  004e0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z@4JA
  004e5	05 bf 00 00 00	 add	 eax, 191		; 000000bfH
  004ea	50		 push	 eax
  004eb	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  004f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd@
  004f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  004fb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 16968: 				LEAVE_SET(0xFF);

  004fe	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00505	e9 9e 15 00 00	 jmp	 $LN181@gObjInvent
$LN51@gObjInvent:

; 16969: 			}
; 16970: 			if( lpObj->pInventory[source].IsItem() == FALSE ) 

  0050a	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0050e	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  00514	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00517	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0051d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00522	85 c0		 test	 eax, eax
  00524	75 3f		 jne	 SHORT $LN53@gObjInvent

; 16971: 			{
; 16972: 				LogAdd(lMsg.Get(532), lpObj->AccountID, lpObj->Name, __LINE__);

  00526	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z@4JA
  0052b	05 c4 00 00 00	 add	 eax, 196		; 000000c4H
  00530	50		 push	 eax
  00531	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00534	83 c1 73	 add	 ecx, 115		; 00000073H
  00537	51		 push	 ecx
  00538	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0053b	83 c2 68	 add	 edx, 104		; 00000068H
  0053e	52		 push	 edx
  0053f	68 14 02 00 00	 push	 532			; 00000214H
  00544	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00549	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0054f	50		 push	 eax
  00550	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00556	83 c4 10	 add	 esp, 16			; 00000010H

; 16973: 				LEAVE_SET(0xFF);

  00559	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00560	e9 43 15 00 00	 jmp	 $LN181@gObjInvent
$LN53@gObjInvent:

; 16974: 			}
; 16975: 			sitem = &lpObj->pInventory[source];

  00565	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00569	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0056f	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00572	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00578	89 4d 84	 mov	 DWORD PTR _sitem$[ebp], ecx

; 16976: 			break;

  0057b	eb 0c		 jmp	 SHORT $LN2@gObjInvent
$LN54@gObjInvent:

; 16977: #endif
; 16978: 		default :
; 16979: 			LEAVE_SET(0xFF);

  0057d	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00584	e9 1f 15 00 00	 jmp	 $LN181@gObjInvent
$LN2@gObjInvent:

; 16980: 		}
; 16981: 		
; 16982: 		BYTE level, op1, op2, op3, dur;
; 16983: 		int  type;
; 16984: 		
; 16985: 		BufferItemtoConvert3(siteminfo, type, level, op1, op2, op3, dur);

  00589	8d 85 6e ff ff
	ff		 lea	 eax, DWORD PTR _dur$10[ebp]
  0058f	50		 push	 eax
  00590	8d 8d 6f ff ff
	ff		 lea	 ecx, DWORD PTR _op3$11[ebp]
  00596	51		 push	 ecx
  00597	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _op2$12[ebp]
  0059d	52		 push	 edx
  0059e	8d 85 71 ff ff
	ff		 lea	 eax, DWORD PTR _op1$13[ebp]
  005a4	50		 push	 eax
  005a5	8d 8d 72 ff ff
	ff		 lea	 ecx, DWORD PTR _level$14[ebp]
  005ab	51		 push	 ecx
  005ac	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR _type$9[ebp]
  005b2	52		 push	 edx
  005b3	8b 45 24	 mov	 eax, DWORD PTR _siteminfo$[ebp]
  005b6	50		 push	 eax
  005b7	e8 00 00 00 00	 call	 ?BufferItemtoConvert3@@YAXPAEAAHAAE2222@Z ; BufferItemtoConvert3
  005bc	83 c4 1c	 add	 esp, 28			; 0000001cH

; 16986: 		
; 16987: 		if( (sitem->m_Type    != type  ) ||
; 16988: 			(sitem->m_Level   != level ) ||
; 16989: 			(sitem->m_Option1 != op1   ) ||
; 16990: 			(sitem->m_Option2 != op2   ) ||

  005bf	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  005c2	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  005c6	3b 8d 68 ff ff
	ff		 cmp	 ecx, DWORD PTR _type$9[ebp]
  005cc	75 48		 jne	 SHORT $LN56@gObjInvent
  005ce	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  005d1	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  005d5	0f b6 95 72 ff
	ff ff		 movzx	 edx, BYTE PTR _level$14[ebp]
  005dc	3b ca		 cmp	 ecx, edx
  005de	75 36		 jne	 SHORT $LN56@gObjInvent
  005e0	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  005e3	0f b6 48 78	 movzx	 ecx, BYTE PTR [eax+120]
  005e7	0f b6 95 71 ff
	ff ff		 movzx	 edx, BYTE PTR _op1$13[ebp]
  005ee	3b ca		 cmp	 ecx, edx
  005f0	75 24		 jne	 SHORT $LN56@gObjInvent
  005f2	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  005f5	0f b6 48 79	 movzx	 ecx, BYTE PTR [eax+121]
  005f9	0f b6 95 70 ff
	ff ff		 movzx	 edx, BYTE PTR _op2$12[ebp]
  00600	3b ca		 cmp	 ecx, edx
  00602	75 12		 jne	 SHORT $LN56@gObjInvent
  00604	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00607	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  0060b	0f b6 95 6f ff
	ff ff		 movzx	 edx, BYTE PTR _op3$11[ebp]
  00612	3b ca		 cmp	 ecx, edx
  00614	74 77		 je	 SHORT $LN55@gObjInvent
$LN56@gObjInvent:

; 16991: 			(sitem->m_Option3 != op3   ) )
; 16992: 		{
; 16993: 			LogAddC(LOGC_RED,lMsg.Get(533), type, level, op1, op2, op3, sitem->m_Type, sitem->m_Level, sitem->m_Option1, sitem->m_Option2, sitem->m_Option3);

  00616	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00619	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  0061d	51		 push	 ecx
  0061e	8b 55 84	 mov	 edx, DWORD PTR _sitem$[ebp]
  00621	0f b6 42 79	 movzx	 eax, BYTE PTR [edx+121]
  00625	50		 push	 eax
  00626	8b 4d 84	 mov	 ecx, DWORD PTR _sitem$[ebp]
  00629	0f b6 51 78	 movzx	 edx, BYTE PTR [ecx+120]
  0062d	52		 push	 edx
  0062e	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00631	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00635	51		 push	 ecx
  00636	8b 55 84	 mov	 edx, DWORD PTR _sitem$[ebp]
  00639	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  0063d	50		 push	 eax
  0063e	0f b6 8d 6f ff
	ff ff		 movzx	 ecx, BYTE PTR _op3$11[ebp]
  00645	51		 push	 ecx
  00646	0f b6 95 70 ff
	ff ff		 movzx	 edx, BYTE PTR _op2$12[ebp]
  0064d	52		 push	 edx
  0064e	0f b6 85 71 ff
	ff ff		 movzx	 eax, BYTE PTR _op1$13[ebp]
  00655	50		 push	 eax
  00656	0f b6 8d 72 ff
	ff ff		 movzx	 ecx, BYTE PTR _level$14[ebp]
  0065d	51		 push	 ecx
  0065e	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR _type$9[ebp]
  00664	52		 push	 edx
  00665	68 15 02 00 00	 push	 533			; 00000215H
  0066a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0066f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00675	50		 push	 eax
  00676	6a 02		 push	 2
  00678	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0067e	83 c4 30	 add	 esp, 48			; 00000030H

; 16994: 			LEAVE_SET(0xFF);

  00681	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00688	e9 1b 14 00 00	 jmp	 $LN181@gObjInvent
$LN55@gObjInvent:

; 16995: 		}
; 16996: 
; 16997: 		//    .
; 16998: 		switch( tFlag )

  0068d	0f b6 45 20	 movzx	 eax, BYTE PTR _tFlag$[ebp]
  00691	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv361[ebp], eax
  00697	83 bd 0c ff ff
	ff 05		 cmp	 DWORD PTR tv361[ebp], 5
  0069e	0f 87 fa 04 00
	00		 ja	 $LN100@gObjInvent
  006a4	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv361[ebp]
  006aa	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN191@gObjInvent[ecx*4]
$LN57@gObjInvent:

; 16999: 		{
; 17000: 		case ITEMMOVE_INVENTORY : 
; 17001: 			if( target< 0 || target > MAX_INVENTORY-1 )

  006b1	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  006b5	85 c0		 test	 eax, eax
  006b7	7c 09		 jl	 SHORT $LN59@gObjInvent
  006b9	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  006bd	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  006c0	7e 2a		 jle	 SHORT $LN58@gObjInvent
$LN59@gObjInvent:

; 17002: 			{
; 17003: 				LogAdd("error-L1 : %s %d", __FILE__, __LINE__);

  006c2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z@4JA
  006c7	05 e3 00 00 00	 add	 eax, 227		; 000000e3H
  006cc	50		 push	 eax
  006cd	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  006d2	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd@
  006d7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  006dd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17004: 				LEAVE_SET(0xFF);

  006e0	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  006e7	e9 bc 13 00 00	 jmp	 $LN181@gObjInvent
$LN58@gObjInvent:

; 17005: 			}
; 17006: 			titem = &lpObj->pInventory[target];

  006ec	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  006f0	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  006f6	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  006f9	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  006ff	89 4d 80	 mov	 DWORD PTR _titem$[ebp], ecx

; 17007: 			break;

  00702	e9 a3 04 00 00	 jmp	 $LN4@gObjInvent
$LN60@gObjInvent:

; 17008: 		case ITEMMOVE_WAREHOUSE :
; 17009: 			if( target< 0 || target > MAX_WAREHOUSEITEMS-1 )

  00707	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  0070b	85 c0		 test	 eax, eax
  0070d	7c 09		 jl	 SHORT $LN62@gObjInvent
  0070f	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  00713	83 f8 77	 cmp	 eax, 119		; 00000077H
  00716	7e 2a		 jle	 SHORT $LN61@gObjInvent
$LN62@gObjInvent:

; 17010: 			{
; 17011: 				LogAdd("error-L1 : %s %d", __FILE__, __LINE__);

  00718	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z@4JA
  0071d	05 eb 00 00 00	 add	 eax, 235		; 000000ebH
  00722	50		 push	 eax
  00723	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00728	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd@
  0072d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00733	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17012: 				LEAVE_SET(0xFF);

  00736	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  0073d	e9 66 13 00 00	 jmp	 $LN181@gObjInvent
$LN61@gObjInvent:

; 17013: 			}
; 17014: 			titem = &lpObj->pWarehouse[target];

  00742	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  00746	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0074c	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0074f	03 8a 94 0c 00
	00		 add	 ecx, DWORD PTR [edx+3220]
  00755	89 4d 80	 mov	 DWORD PTR _titem$[ebp], ecx

; 17015: 			break;

  00758	e9 4d 04 00 00	 jmp	 $LN4@gObjInvent
$LN63@gObjInvent:

; 17016: #ifdef DARKLORD_WORK
; 17017: 		case ITEMMOVE_DARK_TRAINER :
; 17018: #endif
; 17019: #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 17020: 		case ITEMMOVE_JEWELOFHARMONY_PURITY:
; 17021: 		case ITEMMOVE_JEWELOFHARMONY_SMELT:
; 17022: 		case ITEMMOVE_JEWELOFHARMONY_RESTORE:
; 17023: #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 17024: #ifdef ADD_PCS_LOTTERY_SYSTEM_20070117
; 17025: 		case ITEMMOVE_LOTTERY_MIX:
; 17026: #endif // ADD_PCS_LOTTERY_SYSTEM_20070117
; 17027: #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312
; 17028: 		case ITEMMOVE_CHERRYBLOSSOM:
; 17029: #endif	// ADD_EVENT_CHERRYBLOSSOM_20080312	
; 17030: #ifdef ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 17031: 		case ITEMMOVE_SOCKET_ITEM_EXTRACT:			//  
; 17032: 		case ITEMMOVE_SOCKET_ITEM_COMPOSIT:			//  
; 17033: 		case ITEMMOVE_SOCKET_ITEM_EQUIP:			//  
; 17034: 		case ITEMMOVE_SOCKET_ITEM_REMOVE:			//  
; 17035: #endif // ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 17036: 		case ITEMMOVE_CHAOSBOX :
; 17037: 			if( target< 0 || target > MAX_CHAOSBOXITEMS-1 )

  0075d	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  00761	85 c0		 test	 eax, eax
  00763	7c 09		 jl	 SHORT $LN65@gObjInvent
  00765	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  00769	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0076c	7e 2a		 jle	 SHORT $LN64@gObjInvent
$LN65@gObjInvent:

; 17038: 			{
; 17039: 				LogAdd("error-L1 : %s %d", __FILE__, __LINE__);

  0076e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z@4JA
  00773	05 07 01 00 00	 add	 eax, 263		; 00000107H
  00778	50		 push	 eax
  00779	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0077e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd@
  00783	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00789	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17040: 				LEAVE_SET(0xFF);

  0078c	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00793	e9 10 13 00 00	 jmp	 $LN181@gObjInvent
$LN64@gObjInvent:

; 17041: 			}
; 17042: 			titem = &lpObj->pChaosBox[target];

  00798	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  0079c	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  007a2	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  007a5	03 8a ac 0c 00
	00		 add	 ecx, DWORD PTR [edx+3244]
  007ab	89 4d 80	 mov	 DWORD PTR _titem$[ebp], ecx

; 17043: 		
; 17044: 			if( sFlag == ITEMMOVE_INVENTORY )

  007ae	0f b6 45 1c	 movzx	 eax, BYTE PTR _sFlag$[ebp]
  007b2	85 c0		 test	 eax, eax
  007b4	0f 85 20 02 00
	00		 jne	 $LN87@gObjInvent

; 17045: 			{
; 17046: 
; 17047: #ifdef DARKLORD_WORK
; 17048: 				if( tFlag == ITEMMOVE_DARK_TRAINER )

  007ba	0f b6 45 20	 movzx	 eax, BYTE PTR _tFlag$[ebp]
  007be	83 f8 05	 cmp	 eax, 5
  007c1	0f 85 86 00 00
	00		 jne	 $LN67@gObjInvent

; 17049: 				{	//       
; 17050: 					if( sitem->m_Type == MAKE_ITEMNUM(12,15) ||	// 
; 17051: 						sitem->m_Type == MAKE_ITEMNUM(14,13) ||	// 
; 17052: 						sitem->m_Type == MAKE_ITEMNUM(14,14) ||	// 
; 17053: 						sitem->m_Type == MAKE_ITEMNUM(14,22) ||	// 

  007c7	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  007ca	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  007ce	6a 0f		 push	 15			; 0000000fH
  007d0	6a 0c		 push	 12			; 0000000cH
  007d2	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  007d7	83 c4 08	 add	 esp, 8
  007da	3b f0		 cmp	 esi, eax
  007dc	74 5c		 je	 SHORT $LN71@gObjInvent
  007de	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  007e1	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  007e5	6a 0d		 push	 13			; 0000000dH
  007e7	6a 0e		 push	 14			; 0000000eH
  007e9	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  007ee	83 c4 08	 add	 esp, 8
  007f1	3b f0		 cmp	 esi, eax
  007f3	74 45		 je	 SHORT $LN71@gObjInvent
  007f5	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  007f8	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  007fc	6a 0e		 push	 14			; 0000000eH
  007fe	6a 0e		 push	 14			; 0000000eH
  00800	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00805	83 c4 08	 add	 esp, 8
  00808	3b f0		 cmp	 esi, eax
  0080a	74 2e		 je	 SHORT $LN71@gObjInvent
  0080c	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  0080f	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00813	6a 16		 push	 22			; 00000016H
  00815	6a 0e		 push	 14			; 0000000eH
  00817	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0081c	83 c4 08	 add	 esp, 8
  0081f	3b f0		 cmp	 esi, eax
  00821	74 17		 je	 SHORT $LN71@gObjInvent
  00823	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00826	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0082a	6a 1f		 push	 31			; 0000001fH
  0082c	6a 0d		 push	 13			; 0000000dH
  0082e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00833	83 c4 08	 add	 esp, 8
  00836	3b f0		 cmp	 esi, eax
  00838	75 02		 jne	 SHORT $LN69@gObjInvent
$LN71@gObjInvent:

; 17054: 						sitem->m_Type == MAKE_ITEMNUM(13, 31) 	//  
; 17055: #ifdef ADD_PCS_CHAOSMIX_SUCCESS_RATE_UPGRADE_CHARM_20070111
; 17056: 						|| sitem->m_Type == MAKE_ITEMNUM( 14, 53 )	//  
; 17057: #endif // ADD_PCS_CHAOSMIX_SUCCESS_RATE_UPGRADE_CHARM_20070111
; 17058: #ifdef ADD_PARTIALY_CHARGE_SYSTEM_06_20090129
; 17059: 						|| sitem->m_Type == MAKE_ITEMNUM( 13, 83) || sitem->m_Type == MAKE_ITEMNUM( 13, 84)
; 17060: 						|| sitem->m_Type == MAKE_ITEMNUM( 13, 85) || sitem->m_Type == MAKE_ITEMNUM( 13, 86) 
; 17061: 						|| sitem->m_Type == MAKE_ITEMNUM( 13, 87) || sitem->m_Type == MAKE_ITEMNUM( 13, 88)
; 17062: 						|| sitem->m_Type == MAKE_ITEMNUM( 13, 89) || sitem->m_Type == MAKE_ITEMNUM( 13, 90)
; 17063: 						|| sitem->m_Type == MAKE_ITEMNUM( 13, 91) || sitem->m_Type == MAKE_ITEMNUM( 13, 92) 
; 17064: #endif //ADD_PARTIALY_CHARGE_SYSTEM_06_20090129
; 17065: 						)
; 17066: 					{
; 17067: 					}

  0083a	eb 0c		 jmp	 SHORT $LN70@gObjInvent
$LN69@gObjInvent:

; 17068: 					else 
; 17069: 						LEAVE_SET(0xFF);

  0083c	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00843	e9 60 12 00 00	 jmp	 $LN181@gObjInvent
$LN70@gObjInvent:

; 17070: 
; 17071: 				}else

  00848	e9 8d 01 00 00	 jmp	 $LN87@gObjInvent
$LN67@gObjInvent:

; 17072: #endif
; 17073: #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 17074: 				//   :    
; 17075: 				if ( tFlag == ITEMMOVE_JEWELOFHARMONY_PURITY )
; 17076: 				{
; 17077: 					if ( g_kJewelOfHarmonySystem.IsJewelOfHarmonyOriginal( sitem->m_Type ) == FALSE )
; 17078: 					{
; 17079: 						LEAVE_SET(0xFF);
; 17080: 					}
; 17081: 
; 17082: 				} 
; 17083: 				else if ( tFlag == ITEMMOVE_JEWELOFHARMONY_SMELT )
; 17084: 				{
; 17085: 					//   :   /    ( )
; 17086: 					if ( g_kJewelOfHarmonySystem.IsEnableToMakeSmeltingStoneItem( sitem ) == FALSE )
; 17087: 					{
; 17088: #ifdef ADD_JEWEL_OF_HARMONY_WTFMESSAGE_20060818
; 17089: 						GCServerMsgStringSend( lMsg.Get(3377), lpObj->m_Index, 1); // "     "
; 17090: #endif
; 17091: 						LEAVE_SET(0xFF);
; 17092: 					}
; 17093: 				}
; 17094: 				else if ( tFlag == ITEMMOVE_JEWELOFHARMONY_RESTORE )
; 17095: 				{
; 17096: 					//  
; 17097: 					if ( g_kJewelOfHarmonySystem.IsStrengthenByJewelOfHarmony( sitem ) == FALSE )
; 17098: 					{
; 17099: 						LEAVE_SET(0xFF);
; 17100: 					}
; 17101: 				}
; 17102: 				else 
; 17103: #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 17104: 
; 17105: #ifdef ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 17106: 				//       
; 17107: 				if( tFlag == ITEMMOVE_SOCKET_ITEM_EXTRACT )
; 17108: 				{
; 17109: 				}
; 17110: 				else if( tFlag == ITEMMOVE_SOCKET_ITEM_COMPOSIT )
; 17111: 				{
; 17112: 				}
; 17113: 				else if( tFlag == ITEMMOVE_SOCKET_ITEM_EQUIP )
; 17114: 				{
; 17115: 				}
; 17116: 				else if( tFlag == ITEMMOVE_SOCKET_ITEM_REMOVE )
; 17117: 				{
; 17118: 				}
; 17119: 				else
; 17120: #endif // ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 17121: 
; 17122: #ifdef ADD_PCS_LOTTERY_SYSTEM_20070117
; 17123: 				if( tFlag == ITEMMOVE_LOTTERY_MIX )
; 17124: 				{
; 17125: #ifdef MODIFY_EXPEND_CHAOSCARD_SYSTEM_20080326
; 17126: 					if( sitem->m_Type == MAKE_ITEMNUM( 14, 54 )
; 17127: 						|| sitem->m_Type == MAKE_ITEMNUM( 14, 92 )
; 17128: 						|| sitem->m_Type == MAKE_ITEMNUM( 14, 93 )
; 17129: 						|| sitem->m_Type == MAKE_ITEMNUM( 14, 95 )
; 17130: 						)
; 17131: 					{
; 17132: 					}
; 17133: 					else
; 17134: #else
; 17135: 					if( sitem->m_Type != MAKE_ITEMNUM( 14, 54 ) )
; 17136: 	#endif // MODIFY_EXPEND_CHAOSCARD_SYSTEM_20080326
; 17137: 					{
; 17138: 						LEAVE_SET(0xFF);
; 17139: 					}
; 17140: 				}
; 17141: 				else
; 17142: #endif // ADD_PCS_LOTTERY_SYSTEM_20070117
; 17143: 
; 17144: #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312
; 17145: 					if( tFlag == ITEMMOVE_CHERRYBLOSSOM )
; 17146: 					{
; 17147: 						if( sitem->m_Type != MAKE_ITEMNUM( 14, 88 ) 
; 17148: 							&& sitem->m_Type != MAKE_ITEMNUM( 14, 89 ) 
; 17149: 							&& sitem->m_Type != MAKE_ITEMNUM( 14, 90 ) 
; 17150: 							)
; 17151: 						{
; 17152: 							LEAVE_SET(0xFF);
; 17153: 						}
; 17154: 					}
; 17155: 					else
; 17156: #endif // ADD_EVENT_CHERRYBLOSSOM_20080312
; 17157: 
; 17158: 				if(sitem->m_Level < 4 && (sitem->m_Option3*4) < 4) 

  0084d	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00850	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00854	83 f9 04	 cmp	 ecx, 4
  00857	0f 8d 5a 01 00
	00		 jge	 $LN72@gObjInvent
  0085d	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00860	0f b6 48 7a	 movzx	 ecx, BYTE PTR [eax+122]
  00864	c1 e1 02	 shl	 ecx, 2
  00867	83 f9 04	 cmp	 ecx, 4
  0086a	0f 8d 47 01 00
	00		 jge	 $LN72@gObjInvent

; 17159: 				{
; 17160: 					//    
; 17161: 
; 17162: 					if( sitem->m_Type == MAKE_ITEMNUM(12,15) ||
; 17163: 						sitem->m_Type == MAKE_ITEMNUM(14,13) ||
; 17164: 						sitem->m_Type == MAKE_ITEMNUM(14,14) || 
; 17165: 						sitem->m_Type == MAKE_ITEMNUM(14,22) || //  

  00870	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00873	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00877	6a 0f		 push	 15			; 0000000fH
  00879	6a 0c		 push	 12			; 0000000cH
  0087b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00880	83 c4 08	 add	 esp, 8
  00883	3b f0		 cmp	 esi, eax
  00885	74 5c		 je	 SHORT $LN76@gObjInvent
  00887	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  0088a	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0088e	6a 0d		 push	 13			; 0000000dH
  00890	6a 0e		 push	 14			; 0000000eH
  00892	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00897	83 c4 08	 add	 esp, 8
  0089a	3b f0		 cmp	 esi, eax
  0089c	74 45		 je	 SHORT $LN76@gObjInvent
  0089e	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  008a1	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  008a5	6a 0e		 push	 14			; 0000000eH
  008a7	6a 0e		 push	 14			; 0000000eH
  008a9	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  008ae	83 c4 08	 add	 esp, 8
  008b1	3b f0		 cmp	 esi, eax
  008b3	74 2e		 je	 SHORT $LN76@gObjInvent
  008b5	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  008b8	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  008bc	6a 16		 push	 22			; 00000016H
  008be	6a 0e		 push	 14			; 0000000eH
  008c0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  008c5	83 c4 08	 add	 esp, 8
  008c8	3b f0		 cmp	 esi, eax
  008ca	74 17		 je	 SHORT $LN76@gObjInvent
  008cc	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  008cf	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  008d3	6a 0e		 push	 14			; 0000000eH
  008d5	6a 0d		 push	 13			; 0000000dH
  008d7	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  008dc	83 c4 08	 add	 esp, 8
  008df	3b f0		 cmp	 esi, eax
  008e1	75 05		 jne	 SHORT $LN74@gObjInvent
$LN76@gObjInvent:

; 17166: 						sitem->m_Type == MAKE_ITEMNUM(13,14) )
; 17167: 					{
; 17168: 
; 17169: 					}

  008e3	e9 cd 00 00 00	 jmp	 $LN85@gObjInvent
$LN74@gObjInvent:

; 17170: 					else if( sitem->m_Type >= MAKE_ITEMNUM(12,0) && sitem->m_Type <= MAKE_ITEMNUM(12,2) )

  008e8	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  008eb	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  008ef	6a 00		 push	 0
  008f1	6a 0c		 push	 12			; 0000000cH
  008f3	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  008f8	83 c4 08	 add	 esp, 8
  008fb	3b f0		 cmp	 esi, eax
  008fd	7c 1c		 jl	 SHORT $LN77@gObjInvent
  008ff	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00902	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00906	6a 02		 push	 2
  00908	6a 0c		 push	 12			; 0000000cH
  0090a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0090f	83 c4 08	 add	 esp, 8
  00912	3b f0		 cmp	 esi, eax
  00914	7f 05		 jg	 SHORT $LN77@gObjInvent

; 17171: 					{	//  
; 17172: 					}

  00916	e9 9a 00 00 00	 jmp	 $LN85@gObjInvent
$LN77@gObjInvent:

; 17173: #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//  1( )  
; 17174: 					else if( sitem->m_Type == MAKE_ITEMNUM(12, 41) )
; 17175: 					{
; 17176: 					}
; 17177: #endif
; 17178: 					else if( sitem->m_Type == MAKE_ITEMNUM(14,17) || 

  0091b	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  0091e	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00922	6a 11		 push	 17			; 00000011H
  00924	6a 0e		 push	 14			; 0000000eH
  00926	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0092b	83 c4 08	 add	 esp, 8
  0092e	3b f0		 cmp	 esi, eax
  00930	74 17		 je	 SHORT $LN81@gObjInvent
  00932	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00935	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00939	6a 12		 push	 18			; 00000012H
  0093b	6a 0e		 push	 14			; 0000000eH
  0093d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00942	83 c4 08	 add	 esp, 8
  00945	3b f0		 cmp	 esi, eax
  00947	75 02		 jne	 SHORT $LN79@gObjInvent
$LN81@gObjInvent:

; 17179: 							 sitem->m_Type == MAKE_ITEMNUM(14,18) )
; 17180: 					{	//   (, )
; 17181: 					}

  00949	eb 6a		 jmp	 SHORT $LN85@gObjInvent
$LN79@gObjInvent:

; 17182: 					else if( sitem->m_Type == MAKE_ITEMNUM(13,2) &&		//    255      .

  0094b	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  0094e	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00952	6a 02		 push	 2
  00954	6a 0d		 push	 13			; 0000000dH
  00956	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0095b	83 c4 08	 add	 esp, 8
  0095e	3b f0		 cmp	 esi, eax
  00960	75 17		 jne	 SHORT $LN82@gObjInvent
  00962	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00965	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  0096a	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@437f0000
  00971	9f		 lahf
  00972	f6 c4 44	 test	 ah, 68			; 00000044H
  00975	7a 02		 jp	 SHORT $LN82@gObjInvent

; 17183: 						sitem->m_Durability == 0xFF
; 17184: 						)
; 17185: 					{	//    - 
; 17186: 					}

  00977	eb 3c		 jmp	 SHORT $LN85@gObjInvent
$LN82@gObjInvent:

; 17187: #ifdef FOR_BLOODCASTLE
; 17188: 					else if( sitem->m_Type == MAKE_ITEMNUM(13,16) || 

  00979	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  0097c	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00980	6a 10		 push	 16			; 00000010H
  00982	6a 0d		 push	 13			; 0000000dH
  00984	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00989	83 c4 08	 add	 esp, 8
  0098c	3b f0		 cmp	 esi, eax
  0098e	74 17		 je	 SHORT $LN86@gObjInvent
  00990	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00993	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00997	6a 11		 push	 17			; 00000011H
  00999	6a 0d		 push	 13			; 0000000dH
  0099b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  009a0	83 c4 08	 add	 esp, 8
  009a3	3b f0		 cmp	 esi, eax
  009a5	75 02		 jne	 SHORT $LN84@gObjInvent
$LN86@gObjInvent:

; 17189: 							 sitem->m_Type == MAKE_ITEMNUM(13,17) )
; 17190: 					{	//   (, )
; 17191: 					}

  009a7	eb 0c		 jmp	 SHORT $LN85@gObjInvent
$LN84@gObjInvent:

; 17192: #endif
; 17193: #ifdef THIRD_CHANGEUP_SYSTEM_20070507	// ,    
; 17194: //#ifdef CASTLE_SPECIAL_ITEMMIX_20050425	- 
; 17195: 					else if( sitem->m_Type == MAKE_ITEMNUM(12,30) || 
; 17196: 							 sitem->m_Type == MAKE_ITEMNUM(12,31) )
; 17197: 					{	//   (, )
; 17198: 					}
; 17199: //#endif
; 17200: #endif	// THIRD_CHANGEUP_SYSTEM_20070507	
; 17201: #ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116
; 17202: 					else if( sitem->m_Type == MAKE_ITEMNUM(14,31) )
; 17203: 					{
; 17204: 						//  
; 17205: 					}
; 17206: #endif
; 17207: #ifdef HIDDEN_TREASUREBOX_EVENT_20050804
; 17208: 					else if( sitem->m_Type == MAKE_ITEMNUM(12,26) )
; 17209: 					{
; 17210: 						//   
; 17211: 					}
; 17212: #endif
; 17213: #ifdef ADD_ITEM_FENRIR_01_20051110
; 17214: 					else if(	sitem->m_Type == MAKE_ITEMNUM(13,32)
; 17215: 							||	sitem->m_Type == MAKE_ITEMNUM(13,33)	
; 17216: 							||	sitem->m_Type == MAKE_ITEMNUM(13,34)
; 17217: 							||	sitem->m_Type == MAKE_ITEMNUM(13,35)
; 17218: 							||	sitem->m_Type == MAKE_ITEMNUM(13,36)
; 17219: 							||	sitem->m_Type == MAKE_ITEMNUM(13,37)
; 17220: 
; 17221: 							||  sitem->m_Type == MAKE_ITEMNUM(14,16)
; 17222: 						   )
; 17223: 					{
; 17224: 						//    
; 17225: 					}
; 17226: #endif
; 17227: #ifdef ADD_SHIELD_POINT_01_20060403
; 17228: 					else if(	sitem->m_Type == MAKE_ITEMNUM(14,3)		//  
; 17229: 							||	sitem->m_Type == MAKE_ITEMNUM(14,38)	// 
; 17230: 							||	sitem->m_Type == MAKE_ITEMNUM(14,39)	// 
; 17231: 							)
; 17232: 					{
; 17233: 						//    
; 17234: 					}
; 17235: #endif
; 17236: #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 17237: 	#ifdef ADD_380ITEM_NEWOPTION_20060711
; 17238: 					else if ( g_kJewelOfHarmonySystem.IsJewelOfHarmonyPurity(sitem->m_Type) == TRUE ) 
; 17239: 					{
; 17240: 						//  (380  )
; 17241: 					}
; 17242: 					else if ( sitem->m_Type == MAKE_ITEMNUM(14,31) )
; 17243: 					{
; 17244: 						//  (380  )
; 17245: 					}
; 17246: 	#endif // ADD_380ITEM_NEWOPTION_20060711
; 17247: #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 17248: #ifdef ADD_PCS_CHAOSMIX_SUCCESS_RATE_UPGRADE_CHARM_20070111
; 17249: 					else if( sitem->m_Type == MAKE_ITEMNUM( 14, 53 ) )
; 17250: 					{
; 17251: 						//  
; 17252: 					}
; 17253: #endif // ADD_PCS_CHAOSMIX_SUCCESS_RATE_UPGRADE_CHARM_20070111
; 17254: #ifdef ADD_CHAOSMIXCHARM_ITEM_20080702
; 17255: 					else if( sitem->m_Type == MAKE_ITEMNUM( 14, 96 ) )
; 17256: 					{
; 17257: 						//   
; 17258: 					}					
; 17259: #endif // ADD_CHAOSMIXCHARM_ITEM_20080702
; 17260: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//    
; 17261: 					else if( sitem->m_Type == MAKE_ITEMNUM(13, 49)		//  
; 17262: 						|| sitem->m_Type == MAKE_ITEMNUM(13, 50)			//   
; 17263: 						)
; 17264: 					{
; 17265: 					}
; 17266: #endif	
; 17267: #ifdef ADD_THIRD_WING_20070525	//  3    
; 17268: 					else if( g_MixSystem.IsMixPossibleItem( sitem->m_Type ) == TRUE )
; 17269: 					{
; 17270: 						//      ...
; 17271: 					}
; 17272: #endif
; 17273: #ifdef ADD_PARTIALY_CHARGE_SYSTEM_06_20090129
; 17274: 					else if( sitem->m_Type == MAKE_ITEMNUM( 13, 83) || sitem->m_Type == MAKE_ITEMNUM( 13, 84)
; 17275: 						|| sitem->m_Type == MAKE_ITEMNUM( 13, 85) || sitem->m_Type == MAKE_ITEMNUM( 13, 86) 
; 17276: 						|| sitem->m_Type == MAKE_ITEMNUM( 13, 87) || sitem->m_Type == MAKE_ITEMNUM( 13, 88)
; 17277: 						|| sitem->m_Type == MAKE_ITEMNUM( 13, 89) || sitem->m_Type == MAKE_ITEMNUM( 13, 90)
; 17278: 						|| sitem->m_Type == MAKE_ITEMNUM( 13, 91) || sitem->m_Type == MAKE_ITEMNUM( 13, 92)) 
; 17279: 					{						
; 17280: 					}
; 17281: #endif //ADD_PARTIALY_CHARGE_SYSTEM_06_20090129
; 17282: 					else LEAVE_SET(0xFF);

  009a9	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  009b0	e9 f3 10 00 00	 jmp	 $LN181@gObjInvent
$LN85@gObjInvent:

; 17283: 				}

  009b5	eb 23		 jmp	 SHORT $LN87@gObjInvent
$LN72@gObjInvent:

; 17284: //	MU_CHN_THANKS_COOKIE_EVENT_20040908		->     
; 17285: 				else 
; 17286: 				{
; 17287: 					//     .
; 17288: 					if (sitem->m_Type == MAKE_ITEMNUM(14,11))

  009b7	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  009ba	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  009be	6a 0b		 push	 11			; 0000000bH
  009c0	6a 0e		 push	 14			; 0000000eH
  009c2	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  009c7	83 c4 08	 add	 esp, 8
  009ca	3b f0		 cmp	 esi, eax
  009cc	75 0c		 jne	 SHORT $LN87@gObjInvent

; 17289: 						LEAVE_SET(0xFF);

  009ce	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  009d5	e9 ce 10 00 00	 jmp	 $LN181@gObjInvent
$LN87@gObjInvent:

; 17290: 				}
; 17291: //	MU_CHN_THANKS_COOKIE_EVENT_20040908
; 17292: 				
; 17293: 			}
; 17294: 
; 17295: 			//lpObj->ChaosSuccessRate += (titem->m_BuyMoney/20000);
; 17296: 			//lpObj->ChaosMoney += lpObj->ChaosSuccessRate*100000;
; 17297: 			//LogAdd("[%s][%s]   : %d  : %d",lpObj->AccountID, lpObj->Name, lpObj->ChaosMoney, lpObj->ChaosSuccessRate);
; 17298: 			break;

  009da	e9 cb 01 00 00	 jmp	 $LN4@gObjInvent
$LN88@gObjInvent:

; 17299: #ifdef PERSONAL_SHOP_20040113
; 17300: 		case ITEMMOVE_PSHOPWND :	// 
; 17301: 			if (gDoPShopOpen == 0) 

  009df	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  009e6	75 0c		 jne	 SHORT $LN89@gObjInvent

; 17302: 			{
; 17303: 				LEAVE_SET(0xFF);

  009e8	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  009ef	e9 b4 10 00 00	 jmp	 $LN181@gObjInvent
$LN89@gObjInvent:

; 17304: 			}
; 17305: 
; 17306: 			if (gObj[aIndex].m_bPShopOpen == true) {

  009f4	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  009fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a01	0f b6 94 01 f8
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3320]
  00a09	83 fa 01	 cmp	 edx, 1
  00a0c	75 0c		 jne	 SHORT $LN90@gObjInvent

; 17307: 				//       
; 17308: 				LEAVE_SET(0xFF);

  00a0e	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00a15	e9 8e 10 00 00	 jmp	 $LN181@gObjInvent
$LN90@gObjInvent:

; 17309: 			}
; 17310: 
; 17311: 			//--------------------------------------------
; 17312: 			//      .
; 17313: #ifdef DARK_LORD_HEART_EVENT_20040810
; 17314: 			if (sitem->m_Type == MAKE_ITEMNUM (14, 11) &&		//     .

  00a1a	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00a1d	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00a21	6a 0b		 push	 11			; 0000000bH
  00a23	6a 0e		 push	 14			; 0000000eH
  00a25	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00a2a	83 c4 08	 add	 esp, 8
  00a2d	3b f0		 cmp	 esi, eax
  00a2f	75 18		 jne	 SHORT $LN91@gObjInvent
  00a31	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00a34	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00a38	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00a3b	75 0c		 jne	 SHORT $LN91@gObjInvent

; 17315: 				sitem->m_Level == 13
; 17316: 				)
; 17317: 			{
; 17318: 				LEAVE_SET(0xFF);

  00a3d	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00a44	e9 5f 10 00 00	 jmp	 $LN181@gObjInvent
$LN91@gObjInvent:

; 17319: 			}
; 17320: #endif
; 17321: 
; 17322: #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 17323: 			//      
; 17324: 			if ( g_kJewelOfHarmonySystem.IsStrengthenByJewelOfHarmony( sitem ) == TRUE )
; 17325: 			{
; 17326: #ifdef ADD_JEWEL_OF_HARMONY_WTFMESSAGE_20060818
; 17327: 				GCServerMsgStringSend(lMsg.Get(3367), lpObj->m_Index, 1); //      .
; 17328: #endif // ADD_JEWEL_OF_HARMONY_WTFMESSAGE_20060818
; 17329: 				LEAVE_SET(0xFF);
; 17330: 			}
; 17331: #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 17332: 
; 17333: #ifdef ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 17334: 			if( IsCashItem( sitem->m_Type ) == TRUE )
; 17335: 			{
; 17336: #ifdef ADD_PARTIALY_CHARGE_SYSTEM_06_20090129
; 17337: 				switch(sitem->m_Type)
; 17338: 				{
; 17339: 					//       .  
; 17340: 					case MAKE_ITEMNUM2(13, 83):  //  
; 17341: 					case MAKE_ITEMNUM2(13, 84):  //  
; 17342: 					case MAKE_ITEMNUM2(13, 85):  //  
; 17343: 					case MAKE_ITEMNUM2(13, 86):  //  
; 17344: 					case MAKE_ITEMNUM2(13, 87):  //  
; 17345: 					case MAKE_ITEMNUM2(13, 88):  //  
; 17346: 					case MAKE_ITEMNUM2(13, 89):  //  
; 17347: 					case MAKE_ITEMNUM2(13, 90):  //  
; 17348: 					case MAKE_ITEMNUM2(13, 91):  //  
; 17349: 					case MAKE_ITEMNUM2(13, 92):  //   
; 17350: 						break;
; 17351: 					default:
; 17352: 						LEAVE_SET(0xFF);
; 17353: 				}
; 17354: #else
; 17355: 				LEAVE_SET(0xFF);
; 17356: #endif //ADD_PARTIALY_CHARGE_SYSTEM_06_20090129
; 17357: 			}
; 17358: #endif // ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 17359: 
; 17360: #ifdef PREMIUMITEM_20090106
; 17361: 			//     
; 17362: 			if( IsPremiumItem( sitem->m_Type ) == TRUE )
; 17363: 			{
; 17364: 				LEAVE_SET(0xFF);
; 17365: 			}
; 17366: #endif // PREMIUMITEM_20090106
; 17367: 			
; 17368: #ifdef KANTURU_MOONSTONEPENDANT_20060804	//   
; 17369: 			if( sitem->m_Type == MAKE_ITEMNUM( 13, 38 ) )
; 17370: 			{
; 17371: 				GCServerMsgStringSend( lMsg.Get( 3390 ), lpObj->m_Index, 1 ); //    .
; 17372: 				LEAVE_SET(0xFF);
; 17373: 			}
; 17374: #endif
; 17375: 
; 17376: #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	//   
; 17377: 			// ()   
; 17378: 			if( sitem->m_Type == MAKE_ITEMNUM( 13, 39 ) )
; 17379: 			{				
; 17380: 				LEAVE_SET(0xFF);
; 17381: 			}						
; 17382: #endif
; 17383: 
; 17384: #ifdef PCBANG_POINT_SYSTEM_20070206	//   
; 17385: 			// , ,      
; 17386: 			if( g_PCBangPointSystem.CheckPCBangPointItem( sitem->m_Type ) )
; 17387: 			{				
; 17388: 				LEAVE_SET(0xFF);
; 17389: 			}	
; 17390: #endif
; 17391: 
; 17392: #ifdef MODIFY_MAGICIARINGRING_TRADE_BUGFIX_20070328		//       
; 17393: 			if( sitem->m_Type == MAKE_ITEMNUM( 13, 20 ) 
; 17394: 				&& (sitem->m_Level == 1 || sitem->m_Level == 2) )

  00a49	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00a4c	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00a50	6a 14		 push	 20			; 00000014H
  00a52	6a 0d		 push	 13			; 0000000dH
  00a54	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00a59	83 c4 08	 add	 esp, 8
  00a5c	3b f0		 cmp	 esi, eax
  00a5e	75 24		 jne	 SHORT $LN92@gObjInvent
  00a60	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00a63	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00a67	83 f9 01	 cmp	 ecx, 1
  00a6a	74 0c		 je	 SHORT $LN93@gObjInvent
  00a6c	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00a6f	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00a73	83 f9 02	 cmp	 ecx, 2
  00a76	75 0c		 jne	 SHORT $LN92@gObjInvent
$LN93@gObjInvent:

; 17395: 			{
; 17396: 				LEAVE_SET(0xFF);

  00a78	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00a7f	e9 24 10 00 00	 jmp	 $LN181@gObjInvent
$LN92@gObjInvent:

; 17397: 			}
; 17398: #endif
; 17399: 
; 17400: #ifdef MODIFY_QUEST_SYSTEM_20070525	//    
; 17401: 			if( sitem->m_QuestItem )
; 17402: 			{
; 17403: 				LEAVE_SET(0xFF);
; 17404: 			}
; 17405: #endif
; 17406: 			
; 17407: #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_1_20070723	//  0    
; 17408: 			if(lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 51 ) 
; 17409: 				&& lpObj->pInventory[source].m_Durability == 0)
; 17410: 			{
; 17411: 				LEAVE_SET(0xFF);
; 17412: 			}
; 17413: #endif
; 17414: 			//--------------------------------------------
; 17415: 
; 17416: 			//---------------------------------------
; 17417: 			//    .
; 17418: 			EnterCriticalSection(&gObj[aIndex].m_critPShopTrade);

  00a84	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a8b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a91	8d 94 01 34 0d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+3380]
  00a98	52		 push	 edx
  00a99	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 17419: 			if (gObj[aIndex].m_bPShopTransaction == true) {

  00a9f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00aa6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00aac	0f b6 94 01 f9
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3321]
  00ab4	83 fa 01	 cmp	 edx, 1
  00ab7	75 6e		 jne	 SHORT $LN94@gObjInvent

; 17420: 				if (bSourceIsPShop == TRUE) {

  00ab9	83 bd 78 ff ff
	ff 01		 cmp	 DWORD PTR _bSourceIsPShop$[ebp], 1
  00ac0	75 16		 jne	 SHORT $LN96@gObjInvent

; 17421: 					//   .
; 17422: 					lpObj->m_bPShopTransaction = true;

  00ac2	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ac5	c6 80 f9 0c 00
	00 01		 mov	 BYTE PTR [eax+3321], 1

; 17423: 					bPersonalShopTrans = TRUE;

  00acc	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _bPersonalShopTrans$[ebp], 1

; 17424: 				}

  00ad6	eb 4d		 jmp	 SHORT $LN97@gObjInvent
$LN96@gObjInvent:

; 17425: 				else {
; 17426: 					LogAddTD("[PShop] [%s][%s] PShop Item Move Request Failed : Already Trade With Other",

  00ad8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00adf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ae5	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00ae9	52		 push	 edx
  00aea	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00af1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00af7	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00afb	52		 push	 edx
  00afc	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@PCJJPCHK@?$FLPShop?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5PShop?5Item?5Mov@
  00b01	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00b07	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17427: 						gObj[aIndex].AccountID,
; 17428: 						gObj[aIndex].Name
; 17429: 						);
; 17430: 					
; 17431: 					LeaveCriticalSection(&lpObj->m_critPShopTrade);

  00b0a	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b0d	05 34 0d 00 00	 add	 eax, 3380		; 00000d34H
  00b12	50		 push	 eax
  00b13	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 17432: 					LEAVE_SET(0xFF);

  00b19	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00b20	e9 83 0f 00 00	 jmp	 $LN181@gObjInvent
$LN97@gObjInvent:

; 17433: 				}
; 17434: 			}

  00b25	eb 14		 jmp	 SHORT $LN95@gObjInvent
$LN94@gObjInvent:

; 17435: 			else {
; 17436: 				lpObj->m_bPShopTransaction = true;

  00b27	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b2a	c6 80 f9 0c 00
	00 01		 mov	 BYTE PTR [eax+3321], 1

; 17437: 				bPersonalShopTrans = TRUE;

  00b31	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _bPersonalShopTrans$[ebp], 1
$LN95@gObjInvent:

; 17438: 			}
; 17439: 			LeaveCriticalSection(&lpObj->m_critPShopTrade);

  00b3b	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b3e	05 34 0d 00 00	 add	 eax, 3380		; 00000d34H
  00b43	50		 push	 eax
  00b44	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 17440: 			//---------------------------------------
; 17441: 			
; 17442: 			if( target< MAX_INVENTORY || target > MAX_INVENTORY_EXTEND-1 )

  00b4a	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  00b4e	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  00b51	7c 09		 jl	 SHORT $LN99@gObjInvent
  00b53	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  00b57	83 f8 6b	 cmp	 eax, 107		; 0000006bH
  00b5a	7e 2a		 jle	 SHORT $LN98@gObjInvent
$LN99@gObjInvent:

; 17443: 			{
; 17444: 				LogAdd("error-L1 : %s %d", __FILE__, __LINE__);

  00b5c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z@4JA
  00b61	05 9c 02 00 00	 add	 eax, 668		; 0000029cH
  00b66	50		 push	 eax
  00b67	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00b6c	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LFCMHNCJ@error?9L1?5?3?5?$CFs?5?$CFd@
  00b71	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00b77	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17445: 				LEAVE_SET(0xFF);

  00b7a	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00b81	e9 22 0f 00 00	 jmp	 $LN181@gObjInvent
$LN98@gObjInvent:

; 17446: 			}
; 17447: 			titem = &lpObj->pInventory[target];

  00b86	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  00b8a	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  00b90	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b93	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00b99	89 4d 80	 mov	 DWORD PTR _titem$[ebp], ecx

; 17448: 			break;

  00b9c	eb 0c		 jmp	 SHORT $LN4@gObjInvent
$LN100@gObjInvent:

; 17449: #endif
; 17450: 		default :
; 17451: 			LEAVE_SET(0xFF);

  00b9e	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00ba5	e9 fe 0e 00 00	 jmp	 $LN181@gObjInvent
$LN4@gObjInvent:

; 17452: 		}	
; 17453: 
; 17454: 		s_num = sitem->GetNumber();

  00baa	8b 4d 84	 mov	 ecx, DWORD PTR _sitem$[ebp]
  00bad	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  00bb2	89 45 88	 mov	 DWORD PTR _s_num$[ebp], eax

; 17455: 
; 17456: #ifdef ANTIHACKING_SERIAL_0_ITEM_20051202	
; 17457: 		if( gObjCheckSerial0ItemList(sitem) )

  00bb5	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00bb8	50		 push	 eax
  00bb9	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  00bbe	83 c4 04	 add	 esp, 4
  00bc1	85 c0		 test	 eax, eax
  00bc3	74 55		 je	 SHORT $LN101@gObjInvent

; 17458: 		{
; 17459: 			// MODIFY_LOCALIZING_WTF_20060309  wtf   0.99.60 - 0.99.94
; 17460: 			MsgOutput( lpObj->m_Index, lMsg.Get(3354) );			// "  .  ."

  00bc5	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  00bca	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00bcf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00bd5	50		 push	 eax
  00bd6	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bd9	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bdb	51		 push	 ecx
  00bdc	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00be1	83 c4 08	 add	 esp, 8

; 17461: 			LogAddTD( "[ANTI-HACK][Serial 0 Item] [MoveItem] (%s)(%s) Item(%s) Pos(%d)",

  00be4	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00be8	50		 push	 eax
  00be9	8b 4d 84	 mov	 ecx, DWORD PTR _sitem$[ebp]
  00bec	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  00bf1	50		 push	 eax
  00bf2	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bf5	83 c1 73	 add	 ecx, 115		; 00000073H
  00bf8	51		 push	 ecx
  00bf9	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00bfc	83 c2 68	 add	 edx, 104		; 00000068H
  00bff	52		 push	 edx
  00c00	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@MOKNMDJN@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$FLMov@
  00c05	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00c0b	83 c4 14	 add	 esp, 20			; 00000014H

; 17462: 				lpObj->AccountID, lpObj->Name, sitem->GetName(), source );
; 17463: 			LEAVE_SET(0xFF);

  00c0e	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00c15	e9 8e 0e 00 00	 jmp	 $LN181@gObjInvent
$LN101@gObjInvent:

; 17464: 		}
; 17465: #endif
; 17466: 		
; 17467: 		if( gObjInventorySearchSerialNumber(lpObj, s_num) == FALSE )

  00c1a	8b 45 88	 mov	 eax, DWORD PTR _s_num$[ebp]
  00c1d	50		 push	 eax
  00c1e	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c21	51		 push	 ecx
  00c22	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  00c27	83 c4 08	 add	 esp, 8
  00c2a	85 c0		 test	 eax, eax
  00c2c	75 0c		 jne	 SHORT $LN102@gObjInvent

; 17468: 		{
; 17469: 			LEAVE_SET(0xFF);

  00c2e	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00c35	e9 6e 0e 00 00	 jmp	 $LN181@gObjInvent
$LN102@gObjInvent:

; 17470: 		}
; 17471: 		if( gObjWarehouseSearchSerialNumber(lpObj, s_num) == FALSE )

  00c3a	8b 45 88	 mov	 eax, DWORD PTR _s_num$[ebp]
  00c3d	50		 push	 eax
  00c3e	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c41	51		 push	 ecx
  00c42	e8 00 00 00 00	 call	 ?gObjWarehouseSearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z ; gObjWarehouseSearchSerialNumber
  00c47	83 c4 08	 add	 esp, 8
  00c4a	85 c0		 test	 eax, eax
  00c4c	75 0c		 jne	 SHORT $LN103@gObjInvent

; 17472: 		{
; 17473: 			LEAVE_SET(0xFF);

  00c4e	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00c55	e9 4e 0e 00 00	 jmp	 $LN181@gObjInvent
$LN103@gObjInvent:

; 17474: 		}	
; 17475: 
; 17476: 		//    .. 
; 17477: 		if( titem->IsItem() == TRUE  ) 

  00c5a	8b 4d 80	 mov	 ecx, DWORD PTR _titem$[ebp]
  00c5d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00c62	83 f8 01	 cmp	 eax, 1
  00c65	0f 85 50 03 00
	00		 jne	 $LN104@gObjInvent

; 17478: 		{
; 17479: 			int max_count=0;

  00c6b	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _max_count$8[ebp], 0

; 17480: 			
; 17481: #ifdef ADD_ITEM_FENRIR_01_20051110	//     .
; 17482: 
; 17483: 			if( sitem->m_Type == MAKE_ITEMNUM(13, 32) )	//  
; 17484: 			{
; 17485: 				if( titem->m_Durability < MAX_OVERLAP_FENRIR_MIX_STUFF_01 ) 
; 17486: 					max_count = MAX_OVERLAP_FENRIR_MIX_STUFF_01;
; 17487: 			}
; 17488: 
; 17489: 			if( sitem->m_Type == MAKE_ITEMNUM(13, 33) )	//  
; 17490: 			{
; 17491: 				if( titem->m_Durability < MAX_OVERLAP_FENRIR_MIX_STUFF_02 ) 
; 17492: 					max_count = MAX_OVERLAP_FENRIR_MIX_STUFF_02;
; 17493: 			}
; 17494: 
; 17495: 			if( sitem->m_Type == MAKE_ITEMNUM(13, 34) )	//  
; 17496: 			{
; 17497: 				if( titem->m_Durability < MAX_OVERLAP_FENRIR_MIX_STUFF_03 ) 
; 17498: 					max_count = MAX_OVERLAP_FENRIR_MIX_STUFF_03;
; 17499: 			}
; 17500: #endif
; 17501: 
; 17502: #ifdef ADD_SHIELD_POINT_01_20060403	// SD     1
; 17503: 			if( sitem->m_Type >= MAKE_ITEMNUM(14, 35)
; 17504: 				|| sitem->m_Type >= MAKE_ITEMNUM(14, 36)
; 17505: 				|| sitem->m_Type >= MAKE_ITEMNUM(14, 37)
; 17506: 				)
; 17507: 			{
; 17508: 				if ( titem->m_Durability < 1 )
; 17509: 					max_count = 1;
; 17510: 			}
; 17511: #endif // ADD_SHIELD_POINT_01_20060403
; 17512: 
; 17513: #ifdef ADD_PCS_FULL_RECOVERY_POTION_20070508
; 17514: 			if( sitem->m_Type == MAKE_ITEMNUM( 14, 63 )
; 17515: 				|| sitem->m_Type == MAKE_ITEMNUM( 14, 64 )
; 17516: 			  )
; 17517: 			{
; 17518: 				if( titem->m_Durability < MAX_OVERLAP_FULL_RECOVERY_POTION )
; 17519: 				{
; 17520: 					max_count = MAX_OVERLAP_FULL_RECOVERY_POTION;
; 17521: 				}
; 17522: 			}
; 17523: #endif // ADD_PCS_FULL_RECOVERY_POTION_20070508
; 17524: 
; 17525: #ifdef ITEM_ADD_OPTION_20061019
; 17526: #ifdef HALLOWINDAY_JACK_O_LANTERN_EVENT_20061017
; 17527: 			//        3 
; 17528: 			if( sitem->m_Type >= ITEM_POTION+46 &&
; 17529: 				sitem->m_Type <= ITEM_POTION+50
; 17530: 				)
; 17531: 			{
; 17532: 				if( titem->m_Durability < MAX_OVERLAP_JACK_O_LANTERN_POTION )
; 17533: 				{
; 17534: 					max_count = MAX_OVERLAP_JACK_O_LANTERN_POTION;
; 17535: 				}
; 17536: 			}
; 17537: #endif
; 17538: #endif 
; 17539: 
; 17540: #ifdef ADD_NEW_MAP_KALIMA_20040518						//    .
; 17541: 			if (sitem->m_Type == MAKE_ITEMNUM(14, 29)
; 17542: #ifdef MODIFY_KALIMA_KUNDUNMARK_DROP_01_20040906
; 17543: 				&& sitem->m_Level == titem->m_Level		//     

  00c75	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00c78	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00c7c	6a 1d		 push	 29			; 0000001dH
  00c7e	6a 0e		 push	 14			; 0000000eH
  00c80	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00c85	83 c4 08	 add	 esp, 8
  00c88	3b f0		 cmp	 esi, eax
  00c8a	75 1c		 jne	 SHORT $LN105@gObjInvent
  00c8c	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00c8f	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00c93	8b 55 80	 mov	 edx, DWORD PTR _titem$[ebp]
  00c96	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  00c9a	3b c8		 cmp	 ecx, eax
  00c9c	75 0a		 jne	 SHORT $LN105@gObjInvent

; 17544: #endif
; 17545: 				) 
; 17546: 			{
; 17547: 				max_count = MAX_KALIMAGATE_STONE_OVERLAP;

  00c9e	c7 85 64 ff ff
	ff 05 00 00 00	 mov	 DWORD PTR _max_count$8[ebp], 5
$LN105@gObjInvent:

; 17548: 			}
; 17549: #endif
; 17550: 
; 17551: #ifdef UPDATE_LUCKY_COIN_EVENT_20081029	//    
; 17552: 			if (sitem->m_Type == MAKE_ITEMNUM(14, 100))
; 17553: 			{
; 17554: 				if( titem->m_Durability < MAX_OVERLAP_LUCKY_COIN )
; 17555: 				{
; 17556: 					max_count = MAX_OVERLAP_LUCKY_COIN;
; 17557: 				}
; 17558: 			}
; 17559: #endif	// UPDATE_LUCKY_COIN_EVENT_20081029
; 17560: 
; 17561: #ifdef ADD_NEW_ITEM_FOR_CASTLE_01_20041116
; 17562: 			//  ,    
; 17563: 			if( sitem->m_Type == MAKE_ITEMNUM(14,7) )
; 17564: 			{
; 17565: 				if( titem->m_Durability < MAX_SPECIAL_POTION_OVERLAP_COUNT ) 
; 17566: 					max_count = MAX_SPECIAL_POTION_OVERLAP_COUNT;
; 17567: 			}
; 17568: 			else
; 17569: #endif
; 17570: 			//  ..
; 17571: 			if( sitem->m_Type >= ITEM_POTION && 

  00ca8	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00cab	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00caf	81 f9 c0 01 00
	00		 cmp	 ecx, 448		; 000001c0H
  00cb5	7c 2d		 jl	 SHORT $LN106@gObjInvent
  00cb7	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00cba	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00cbe	81 f9 c8 01 00
	00		 cmp	 ecx, 456		; 000001c8H
  00cc4	7f 1e		 jg	 SHORT $LN106@gObjInvent

; 17572: 				sitem->m_Type <= ITEM_POTION+8
; 17573: #ifdef ADD_SHIELD_POINT_01_20060403
; 17574: 				|| ( sitem->m_Type >= ITEM_POTION+38 && sitem->m_Type <= ITEM_POTION+40 ) //   3
; 17575: #endif
; 17576: 				) 
; 17577: 			{
; 17578: 				if( titem->m_Durability < g_GlobalConfig.m_iMaxPotionDurability ) max_count = g_GlobalConfig.m_iMaxPotionDurability;

  00cc6	f3 0f 2a 05 b8
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+184
  00cce	8b 45 80	 mov	 eax, DWORD PTR _titem$[ebp]
  00cd1	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  00cd5	76 0b		 jbe	 SHORT $LN108@gObjInvent
  00cd7	a1 b8 00 00 00	 mov	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+184
  00cdc	89 85 64 ff ff
	ff		 mov	 DWORD PTR _max_count$8[ebp], eax
$LN108@gObjInvent:

; 17579: 			}

  00ce2	eb 49		 jmp	 SHORT $LN111@gObjInvent
$LN106@gObjInvent:

; 17580: 			else if( (sitem->m_Type == MAKE_ITEMNUM(4,15)) ||

  00ce4	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00ce7	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00ceb	6a 0f		 push	 15			; 0000000fH
  00ced	6a 04		 push	 4
  00cef	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00cf4	83 c4 08	 add	 esp, 8
  00cf7	3b f0		 cmp	 esi, eax
  00cf9	74 17		 je	 SHORT $LN110@gObjInvent
  00cfb	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00cfe	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00d02	6a 07		 push	 7
  00d04	6a 04		 push	 4
  00d06	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00d0b	83 c4 08	 add	 esp, 8
  00d0e	3b f0		 cmp	 esi, eax
  00d10	75 1b		 jne	 SHORT $LN111@gObjInvent
$LN110@gObjInvent:

; 17581:     				 (sitem->m_Type == MAKE_ITEMNUM(4,7 )) )
; 17582: 			{
; 17583: 				if( titem->m_Durability < 255 ) max_count = 255;

  00d12	8b 45 80	 mov	 eax, DWORD PTR _titem$[ebp]
  00d15	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  00d1d	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  00d21	76 0a		 jbe	 SHORT $LN111@gObjInvent
  00d23	c7 85 64 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR _max_count$8[ebp], 255 ; 000000ffH
$LN111@gObjInvent:

; 17584: 			}
; 17585: 
; 17586: #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 17587: 			else if ( (sitem->m_Type == MAKE_ITEMNUM(14, 70) 
; 17588: 				||  sitem->m_Type == MAKE_ITEMNUM(14, 71) || sitem->m_Type >= MAKE_ITEMNUM(14, 94) )
; 17589: 				&& titem->m_Durability < MAX_OVERLAP_ELITE_POTION )
; 17590: 			{
; 17591: 				max_count = MAX_OVERLAP_ELITE_POTION;
; 17592: 			}
; 17593: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 17594: 
; 17595: #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318		//  SD  
; 17596: 			else if ( (sitem->m_Type == MAKE_ITEMNUM(14, 133))
; 17597: 				&& titem->m_Durability < MAX_OVERLAP_ELITE_POTION )
; 17598: 			{
; 17599: 				max_count = MAX_OVERLAP_ELITE_POTION;
; 17600: 			}
; 17601: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_CASHSHOP_20080318
; 17602: 
; 17603: #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312		//  
; 17604: #ifdef MODIFY_ITEMDURABILITY_BUGFIX_20080408	//    
; 17605: 			else if ( sitem->m_Type == MAKE_ITEMNUM(14, 88) 
; 17606: 				&& titem->m_Durability < MAX_OVERLAP_CHERRYBLOSSOM_WHITE )	//  
; 17607: 			{
; 17608: 				max_count = MAX_OVERLAP_CHERRYBLOSSOM_WHITE;
; 17609: 			}
; 17610: 			else if ( sitem->m_Type == MAKE_ITEMNUM(14, 89) 
; 17611: 				&& titem->m_Durability < MAX_OVERLAP_CHERRYBLOSSOM_RED)		//  
; 17612: 			{
; 17613: 				max_count = MAX_OVERLAP_CHERRYBLOSSOM_RED;
; 17614: 			}
; 17615: 			else if ( sitem->m_Type == MAKE_ITEMNUM(14, 90) 
; 17616: 				&& titem->m_Durability < MAX_OVERLAP_CHERRYBLOSSOM_GOLD)	//  
; 17617: 			{
; 17618: 				max_count = MAX_OVERLAP_CHERRYBLOSSOM_GOLD;
; 17619: 			}
; 17620: 			else if ( sitem->m_Type == MAKE_ITEMNUM(14, 85) 
; 17621: 				&& titem->m_Durability < MAX_OVERLAP_CHERRYBLOSSOM_ITEM_DEFAULT)	// 
; 17622: 			{
; 17623: 				max_count = MAX_OVERLAP_CHERRYBLOSSOM_ITEM_DEFAULT;
; 17624: 			}
; 17625: 			else if ( sitem->m_Type == MAKE_ITEMNUM(14, 86) 
; 17626: 				&& titem->m_Durability < MAX_OVERLAP_CHERRYBLOSSOM_ITEM_DEFAULT)	// 
; 17627: 			{
; 17628: 				max_count = MAX_OVERLAP_CHERRYBLOSSOM_ITEM_DEFAULT;
; 17629: 			}
; 17630: 			else if ( sitem->m_Type == MAKE_ITEMNUM(14, 87) 
; 17631: 				&& titem->m_Durability < MAX_OVERLAP_CHERRYBLOSSOM_ITEM_DEFAULT)	// 
; 17632: 			{
; 17633: 				max_count = MAX_OVERLAP_CHERRYBLOSSOM_ITEM_DEFAULT;
; 17634: 			}			
; 17635: #else	// MODIFY_ITEMDURABILITY_BUGFIX_20080408			
; 17636: 			else if ( sitem->m_Type >= MAKE_ITEMNUM(14, 88) 
; 17637: 				&& titem->m_Durability < MAX_OVERLAP_CHERRYBLOSSOM_WHITE )	//  
; 17638: 			{
; 17639: 				max_count = MAX_OVERLAP_CHERRYBLOSSOM_WHITE;
; 17640: 			}
; 17641: 			else if ( sitem->m_Type >= MAKE_ITEMNUM(14, 89) 
; 17642: 				&& titem->m_Durability < MAX_OVERLAP_CHERRYBLOSSOM_RED)		//  
; 17643: 			{
; 17644: 				max_count = MAX_OVERLAP_CHERRYBLOSSOM_RED;
; 17645: 			}
; 17646: 			else if ( sitem->m_Type <= MAKE_ITEMNUM(14, 90) 
; 17647: 				&& titem->m_Durability < MAX_OVERLAP_CHERRYBLOSSOM_GOLD)	//  
; 17648: 			{
; 17649: 				max_count = MAX_OVERLAP_CHERRYBLOSSOM_GOLD;
; 17650: 			}
; 17651: 			else if ( sitem->m_Type <= MAKE_ITEMNUM(14, 85) 
; 17652: 				&& titem->m_Durability < MAX_OVERLAP_CHERRYBLOSSOM_ITEM_DEFAULT)	// 
; 17653: 			{
; 17654: 				max_count = MAX_OVERLAP_CHERRYBLOSSOM_ITEM_DEFAULT;
; 17655: 			}
; 17656: 			else if ( sitem->m_Type <= MAKE_ITEMNUM(14, 86) 
; 17657: 				&& titem->m_Durability < MAX_OVERLAP_CHERRYBLOSSOM_ITEM_DEFAULT)	// 
; 17658: 			{
; 17659: 				max_count = MAX_OVERLAP_CHERRYBLOSSOM_ITEM_DEFAULT;
; 17660: 			}
; 17661: 			else if ( sitem->m_Type <= MAKE_ITEMNUM(14, 87) 
; 17662: 				&& titem->m_Durability < MAX_OVERLAP_CHERRYBLOSSOM_ITEM_DEFAULT)	// 
; 17663: 			{
; 17664: 				max_count = MAX_OVERLAP_CHERRYBLOSSOM_ITEM_DEFAULT;
; 17665: 			}			
; 17666: #endif	// MODIFY_ITEMDURABILITY_BUGFIX_20080408
; 17667: #endif // ADD_EVENT_CHERRYBLOSSOM_20080312
; 17668: 
; 17669: #ifdef MODIFY_MARKOFLORD_OVERLAPPED_20050530		//   .
; 17670: 			if (sitem->m_Type == MAKE_ITEMNUM(14, 21) &&
; 17671: 				sitem->m_Level == 3
; 17672: 				)
; 17673: 			{
; 17674: 				max_count = MAX_CS_SYNC_MARKS_OVERLAP;
; 17675: 			}
; 17676: #endif
; 17677: 
; 17678: 			if( max_count )

  00d2d	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _max_count$8[ebp], 0
  00d34	0f 84 75 02 00
	00		 je	 $LN121@gObjInvent

; 17679: 			{			
; 17680: 				if( sFlag != ITEMMOVE_INVENTORY )	//   .. 

  00d3a	0f b6 45 1c	 movzx	 eax, BYTE PTR _sFlag$[ebp]
  00d3e	85 c0		 test	 eax, eax
  00d40	74 0c		 je	 SHORT $LN113@gObjInvent

; 17681: 					LEAVE_SET(0xFF);

  00d42	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00d49	e9 5a 0d 00 00	 jmp	 $LN181@gObjInvent
$LN113@gObjInvent:

; 17682: 
; 17683: 				//  ..
; 17684: 				if( titem->m_Type == sitem->m_Type && 

  00d4e	8b 45 80	 mov	 eax, DWORD PTR _titem$[ebp]
  00d51	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00d55	8b 55 84	 mov	 edx, DWORD PTR _sitem$[ebp]
  00d58	0f bf 42 06	 movsx	 eax, WORD PTR [edx+6]
  00d5c	3b c8		 cmp	 ecx, eax
  00d5e	0f 85 4b 02 00
	00		 jne	 $LN121@gObjInvent
  00d64	8b 45 80	 mov	 eax, DWORD PTR _titem$[ebp]
  00d67	0f bf 48 08	 movsx	 ecx, WORD PTR [eax+8]
  00d6b	8b 55 84	 mov	 edx, DWORD PTR _sitem$[ebp]
  00d6e	0f bf 42 08	 movsx	 eax, WORD PTR [edx+8]
  00d72	3b c8		 cmp	 ecx, eax
  00d74	0f 85 35 02 00
	00		 jne	 $LN121@gObjInvent

; 17685: 					titem->m_Level == sitem->m_Level )
; 17686: 				{
; 17687: 					//    .
; 17688: 					int total = (int)titem->m_Durability;

  00d7a	8b 45 80	 mov	 eax, DWORD PTR _titem$[ebp]
  00d7d	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  00d82	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _total$7[ebp], ecx

; 17689: 					if( total < max_count )

  00d88	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _total$7[ebp]
  00d8e	3b 85 64 ff ff
	ff		 cmp	 eax, DWORD PTR _max_count$8[ebp]
  00d94	0f 8d 15 02 00
	00		 jge	 $LN121@gObjInvent

; 17690: 					{
; 17691: 						int sdur = (int)max_count-(int)titem->m_Durability;

  00d9a	8b 45 80	 mov	 eax, DWORD PTR _titem$[ebp]
  00d9d	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  00da2	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _max_count$8[ebp]
  00da8	2b d1		 sub	 edx, ecx
  00daa	89 95 5c ff ff
	ff		 mov	 DWORD PTR _sdur$6[ebp], edx

; 17692: 						if( sitem->m_Durability < sdur )

  00db0	f3 0f 2a 85 5c
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _sdur$6[ebp]
  00db8	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00dbb	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  00dbf	76 0e		 jbe	 SHORT $LN116@gObjInvent

; 17693: 						{
; 17694: 							sdur = (int)sitem->m_Durability;

  00dc1	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00dc4	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  00dc9	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _sdur$6[ebp], ecx
$LN116@gObjInvent:

; 17695: 						}
; 17696: 						titem->m_Durability += sdur;

  00dcf	f3 0f 2a 85 5c
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _sdur$6[ebp]
  00dd7	8b 45 80	 mov	 eax, DWORD PTR _titem$[ebp]
  00dda	f3 0f 58 40 24	 addss	 xmm0, DWORD PTR [eax+36]
  00ddf	8b 4d 80	 mov	 ecx, DWORD PTR _titem$[ebp]
  00de2	f3 0f 11 41 24	 movss	 DWORD PTR [ecx+36], xmm0

; 17697: 						sitem->m_Durability -= sdur;

  00de7	f3 0f 2a 85 5c
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _sdur$6[ebp]
  00def	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00df2	f3 0f 10 48 24	 movss	 xmm1, DWORD PTR [eax+36]
  00df7	f3 0f 5c c8	 subss	 xmm1, xmm0
  00dfb	8b 4d 84	 mov	 ecx, DWORD PTR _sitem$[ebp]
  00dfe	f3 0f 11 49 24	 movss	 DWORD PTR [ecx+36], xmm1

; 17698: 
; 17699: #ifdef ADD_NEW_MAP_KALIMA_20040518					//       20  (  20)   .
; 17700: //######BUGFIX_CAT, Some codes in '20050204_001_bak' is changed as follows.   ,    .
; 17701: 						if (titem->m_Type == MAKE_ITEMNUM(14, 29) && titem->m_Durability >= max_count) {

  00e03	8b 45 80	 mov	 eax, DWORD PTR _titem$[ebp]
  00e06	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00e0a	6a 1d		 push	 29			; 0000001dH
  00e0c	6a 0e		 push	 14			; 0000000eH
  00e0e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00e13	83 c4 08	 add	 esp, 8
  00e16	3b f0		 cmp	 esi, eax
  00e18	0f 85 0e 01 00
	00		 jne	 $LN117@gObjInvent
  00e1e	f3 0f 2a 85 64
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _max_count$8[ebp]
  00e26	8b 45 80	 mov	 eax, DWORD PTR _titem$[ebp]
  00e29	f3 0f 10 48 24	 movss	 xmm1, DWORD PTR [eax+36]
  00e2e	0f 2f c8	 comiss	 xmm1, xmm0
  00e31	0f 82 f5 00 00
	00		 jb	 $LN117@gObjInvent

; 17702: 							//   .
; 17703: 
; 17704: 							// MAX_KALIMAGATE_STONE_OVERLAP  ,
; 17705: 							titem->m_Durability -= max_count;

  00e37	f3 0f 2a 85 64
	ff ff ff	 cvtsi2ss xmm0, DWORD PTR _max_count$8[ebp]
  00e3f	8b 45 80	 mov	 eax, DWORD PTR _titem$[ebp]
  00e42	f3 0f 10 48 24	 movss	 xmm1, DWORD PTR [eax+36]
  00e47	f3 0f 5c c8	 subss	 xmm1, xmm0
  00e4b	8b 4d 80	 mov	 ecx, DWORD PTR _titem$[ebp]
  00e4e	f3 0f 11 49 24	 movss	 DWORD PTR [ecx+36], xmm1

; 17706: 
; 17707: 							if (titem->m_Durability == 0)

  00e53	8b 45 80	 mov	 eax, DWORD PTR _titem$[ebp]
  00e56	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00e5b	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00e62	9f		 lahf
  00e63	f6 c4 44	 test	 ah, 68			; 00000044H
  00e66	7a 57		 jp	 SHORT $LN118@gObjInvent

; 17708: 							{
; 17709: 								gObjInventoryItemSet(aIndex, target, 0xFF);

  00e68	68 ff 00 00 00	 push	 255			; 000000ffH
  00e6d	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  00e71	50		 push	 eax
  00e72	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00e75	51		 push	 ecx
  00e76	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00e7b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17710: 								gObj[aIndex].pInventory[target].Clear();

  00e7e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00e85	0f b6 4d 10	 movzx	 ecx, BYTE PTR _target$[ebp]
  00e89	69 c9 a8 00 00
	00		 imul	 ecx, ecx, 168
  00e8f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e95	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  00e9c	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 17711: 								GCInventoryItemDeleteSend(aIndex, target, 1);

  00ea1	6a 01		 push	 1
  00ea3	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  00ea7	50		 push	 eax
  00ea8	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00eab	51		 push	 ecx
  00eac	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00eb1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17712: 								durTsend = 0;

  00eb4	8b 45 18	 mov	 eax, DWORD PTR _durTsend$[ebp]
  00eb7	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 17713: 							}

  00ebd	eb 09		 jmp	 SHORT $LN119@gObjInvent
$LN118@gObjInvent:

; 17714: 							else //  .
; 17715: 							{
; 17716: 								durTsend = 1;

  00ebf	8b 45 18	 mov	 eax, DWORD PTR _durTsend$[ebp]
  00ec2	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
$LN119@gObjInvent:

; 17717: 							}
; 17718: 
; 17719: 							//   .
; 17720: 							ItemSerialCreateSend(

  00ec8	6a 00		 push	 0
  00eca	6a 00		 push	 0
  00ecc	6a 00		 push	 0
  00ece	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00ed1	50		 push	 eax
  00ed2	6a 00		 push	 0
  00ed4	6a 00		 push	 0
  00ed6	6a 00		 push	 0
  00ed8	6a 00		 push	 0
  00eda	8b 4d 84	 mov	 ecx, DWORD PTR _sitem$[ebp]
  00edd	0f b6 51 08	 movzx	 edx, BYTE PTR [ecx+8]
  00ee1	52		 push	 edx
  00ee2	6a 1c		 push	 28			; 0000001cH
  00ee4	6a 0e		 push	 14			; 0000000eH
  00ee6	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00eeb	83 c4 08	 add	 esp, 8
  00eee	50		 push	 eax
  00eef	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00ef6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00efc	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00f04	52		 push	 edx
  00f05	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00f0c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f12	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  00f1a	52		 push	 edx
  00f1b	68 eb 00 00 00	 push	 235			; 000000ebH
  00f20	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00f23	50		 push	 eax
  00f24	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00f29	83 c4 38	 add	 esp, 56			; 00000038H
$LN117@gObjInvent:

; 17721: 								aIndex, 
; 17722: 								ITEMMAKE_INVENTORY_1CELL, 
; 17723: 								(BYTE)gObj[aIndex].X, 
; 17724: 								(BYTE)gObj[aIndex].Y, 
; 17725: 								ItemGetNumberMake(14, 28), 
; 17726: 								sitem->m_Level, (BYTE)0, 0, 0, 0, aIndex);
; 17727: 						}						
; 17728: //BUGFIX_CAT001########
; 17729: #endif
; 17730: 						if( sitem->m_Durability > 0 )

  00f2c	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  00f2f	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00f34	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00f3b	76 14		 jbe	 SHORT $LN120@gObjInvent

; 17731: 						{
; 17732: 							durSsend = 1;

  00f3d	8b 45 14	 mov	 eax, DWORD PTR _durSsend$[ebp]
  00f40	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 17733: #ifdef MODIFY_MOVE_KUNDUN_MARK_20070307	//        
; 17734: 							if( sitem->m_Type != MAKE_ITEMNUM(14, 29))	//    
; 17735: 								durTsend = 1;
; 17736: #else	// MODIFY_MOVE_KUNDUN_MARK_20070307
; 17737: 							durTsend = 1;

  00f46	8b 45 18	 mov	 eax, DWORD PTR _durTsend$[ebp]
  00f49	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 17738: #endif	// MODIFY_MOVE_KUNDUN_MARK_20070307
; 17739: 						}

  00f4f	eb 5e		 jmp	 SHORT $LN121@gObjInvent
$LN120@gObjInvent:

; 17740: 						else 
; 17741: 						{
; 17742: 							switch( sFlag )

  00f51	8a 45 1c	 mov	 al, BYTE PTR _sFlag$[ebp]
  00f54	88 85 0c ff ff
	ff		 mov	 BYTE PTR tv738[ebp], al
  00f5a	80 bd 0c ff ff
	ff 00		 cmp	 BYTE PTR tv738[ebp], 0
  00f61	74 02		 je	 SHORT $LN122@gObjInvent
  00f63	eb 3e		 jmp	 SHORT $LN6@gObjInvent
$LN122@gObjInvent:

; 17743: 							{
; 17744: 							case ITEMMOVE_INVENTORY :
; 17745: 								gObjInventoryItemSet(lpObj->m_Index, source, 0xFF);

  00f65	68 ff 00 00 00	 push	 255			; 000000ffH
  00f6a	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00f6e	50		 push	 eax
  00f6f	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00f72	8b 11		 mov	 edx, DWORD PTR [ecx]
  00f74	52		 push	 edx
  00f75	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00f7a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17746: 								sitem->Clear();

  00f7d	8b 4d 84	 mov	 ecx, DWORD PTR _sitem$[ebp]
  00f80	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 17747: 								GCInventoryItemDeleteSend(lpObj->m_Index, source, 0);

  00f85	6a 00		 push	 0
  00f87	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  00f8b	50		 push	 eax
  00f8c	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00f8f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00f91	52		 push	 edx
  00f92	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00f97	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17748: 								durTsend = 1;

  00f9a	8b 45 18	 mov	 eax, DWORD PTR _durTsend$[ebp]
  00f9d	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
$LN6@gObjInvent:

; 17749: 								break;
; 17750: 							}
; 17751: 							LEAVE_SET(0x00);

  00fa3	c6 85 73 ff ff
	ff 00		 mov	 BYTE PTR _sp_ret$[ebp], 0
  00faa	e9 f9 0a 00 00	 jmp	 $LN181@gObjInvent
$LN121@gObjInvent:

; 17752: 						}
; 17753: 					}
; 17754: 				}
; 17755: 			}
; 17756: 			LEAVE_SET(0xFF);

  00faf	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  00fb6	e9 ed 0a 00 00	 jmp	 $LN181@gObjInvent
$LN104@gObjInvent:

; 17757: 		}
; 17758: 		//  ..  .
; 17759: 
; 17760: #ifdef UPDATE_GM_FUNCTION_20070228	// GM      
; 17761: 		//  
; 17762: 		switch( tFlag )
; 17763: 		{
; 17764: 			case ITEMMOVE_PSHOPWND :	//  
; 17765: 			case ITEMMOVE_DARK_TRAINER :
; 17766: 			case ITEMMOVE_JEWELOFHARMONY_PURITY:
; 17767: 			case ITEMMOVE_JEWELOFHARMONY_SMELT:
; 17768: 			case ITEMMOVE_JEWELOFHARMONY_RESTORE:
; 17769: 			case ITEMMOVE_CHAOSBOX :
; 17770: 				if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM(13, 42) )
; 17771: 				{
; 17772: 					LEAVE_SET(0xFF);
; 17773: 				}
; 17774: 
; 17775: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328		//  
; 17776: 				if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM(14, 64) )
; 17777: 				{
; 17778: 					LEAVE_SET(0xFF);
; 17779: 				}
; 17780: #endif	
; 17781: 				break;
; 17782: 
; 17783: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//    
; 17784: 			case ITEMMOVE_INVENTORY:			//    
; 17785: 				if( CHECK_ILLUSION_TEMPLE(lpObj->MapNumber) && lpObj->pInventory[source].m_Type == MAKE_ITEMNUM(14, 64) )
; 17786: 				{
; 17787: 					g_IllusionTempleEvent.SetInventoryPos(lpObj->MapNumber, aIndex, target);
; 17788: 				}
; 17789: 				break;
; 17790: #endif	
; 17791: 		}
; 17792: #endif
; 17793: 
; 17794: 		//  
; 17795: 		switch( tFlag )

  00fbb	0f b6 45 20	 movzx	 eax, BYTE PTR _tFlag$[ebp]
  00fbf	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv753[ebp], eax
  00fc5	83 bd 0c ff ff
	ff 05		 cmp	 DWORD PTR tv753[ebp], 5
  00fcc	0f 87 0f 09 00
	00		 ja	 $LN8@gObjInvent
  00fd2	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv753[ebp]
  00fd8	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN192@gObjInvent[ecx*4]
$LN123@gObjInvent:

; 17796: 		{
; 17797: 		case ITEMMOVE_INVENTORY :	//  
; 17798: #ifdef PERSONAL_SHOP_20040113		
; 17799: 		case ITEMMOVE_PSHOPWND :	//  
; 17800: #endif
; 17801: 			//    		
; 17802: 			if( target < MAX_EQUIPMENT )

  00fdf	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  00fe3	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00fe6	0f 8d ee 00 00
	00		 jge	 $LN124@gObjInvent

; 17803: 			{
; 17804: 				if( lpObj->MapNumber == 10 )

  00fec	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00fef	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00ff6	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00ff9	75 7c		 jne	 SHORT $LN131@gObjInvent

; 17805: 				{	//   
; 17806: 					if( target == EQUIPMENT_RING_RIGHT )

  00ffb	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  00fff	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  01002	75 36		 jne	 SHORT $LN127@gObjInvent

; 17807: 					{	//    
; 17808: 						if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM(13,10) )

  01004	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01008	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0100e	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01011	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  01017	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0101c	6a 0a		 push	 10			; 0000000aH
  0101e	6a 0d		 push	 13			; 0000000dH
  01020	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01025	83 c4 08	 add	 esp, 8
  01028	3b f0		 cmp	 esi, eax
  0102a	75 0c		 jne	 SHORT $LN129@gObjInvent

; 17809: 						{	//  
; 17810: 							LEAVE_SET(0xFF);

  0102c	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  01033	e9 70 0a 00 00	 jmp	 $LN181@gObjInvent
$LN129@gObjInvent:

; 17811: 						}
; 17812: 					}

  01038	eb 3d		 jmp	 SHORT $LN131@gObjInvent
$LN127@gObjInvent:

; 17813: 					else if( target == EQUIPMENT_RING_LEFT )

  0103a	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  0103e	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  01041	75 34		 jne	 SHORT $LN131@gObjInvent

; 17814: 					{	//    
; 17815: 						if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM(13,10) )

  01043	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01047	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0104d	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01050	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  01056	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0105b	6a 0a		 push	 10			; 0000000aH
  0105d	6a 0d		 push	 13			; 0000000dH
  0105f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01064	83 c4 08	 add	 esp, 8
  01067	3b f0		 cmp	 esi, eax
  01069	75 0c		 jne	 SHORT $LN131@gObjInvent

; 17816: 						{	//  
; 17817: 							LEAVE_SET(0xFF);

  0106b	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  01072	e9 31 0a 00 00	 jmp	 $LN181@gObjInvent
$LN131@gObjInvent:

; 17818: 						}
; 17819: 					}
; 17820: 				}
; 17821: #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	// ,    
; 17822: 			if( target < MAX_EQUIPMENT )
; 17823: 			{
; 17824: 				if( lpObj->MapNumber == MAP_INDEX_ICARUS || lpObj->MapNumber == MAP_INDEX_KANTURU_BOSS ) 
; 17825: 				{	
; 17826: 					if( target == EQUIPMENT_RING_RIGHT )
; 17827: 					{	
; 17828: 						if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 39 ) ||
; 17829: #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 17830: 							lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 40 ) ||
; 17831: #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 17832: #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 17833: 							lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 41 ) ||
; 17834: #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 17835: #ifdef MODIFY_WEARING_PENDA_SNOWMAN_IN_ICARUS_AND_CANTUR_20090914
; 17836: 							lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 68 ) ||	//  
; 17837: 							lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 76 ) ||	//  
; 17838: #endif //MODIFY_WEARING_PENDA_SNOWMAN_IN_ICARUS_AND_CANTUR_20090914
; 17839: 							lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 10 ) )
; 17840: 						{	
; 17841: 							LEAVE_SET(0xFF);
; 17842: 						}
; 17843: 					}
; 17844: 					else if( target == EQUIPMENT_RING_LEFT )
; 17845: 					{	
; 17846: 						if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 39 ) ||
; 17847: #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 17848: 							lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 40 ) ||
; 17849: #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 17850: #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 17851: 							lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 41 ) ||
; 17852: #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 17853: #ifdef MODIFY_WEARING_PENDA_SNOWMAN_IN_ICARUS_AND_CANTUR_20090914
; 17854: 							lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 68 ) ||	//  
; 17855: 							lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 76 ) ||	//  
; 17856: #endif //MODIFY_WEARING_PENDA_SNOWMAN_IN_ICARUS_AND_CANTUR_20090914
; 17857: 							lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 10 ) )
; 17858: 						{	
; 17859: 							LEAVE_SET(0xFF);
; 17860: 						}
; 17861: 					}
; 17862: 				}	
; 17863: 
; 17864: #ifdef UPDATE_GM_FUNCTION_20070228	// GM   GM   
; 17865: 				if( target == EQUIPMENT_RING_RIGHT )
; 17866: 				{
; 17867: 					if( (lpObj->Authority&AUTHORITY_EVENT_GM) != AUTHORITY_EVENT_GM )
; 17868: 					{
; 17869: 						if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 42 ) )
; 17870: 							LEAVE_SET(0xFF);
; 17871: 					}
; 17872: 				}
; 17873: 				else if( target == EQUIPMENT_RING_LEFT )
; 17874: 				{
; 17875: 					if( (lpObj->Authority&AUTHORITY_EVENT_GM) != AUTHORITY_EVENT_GM )
; 17876: 					{
; 17877: 						if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 42 ) )
; 17878: 							LEAVE_SET(0xFF);
; 17879: 					}
; 17880: 				}
; 17881: #endif // UPDATE_GM_FUNCTION_20070228
; 17882: 			}
; 17883: #endif
; 17884: 			
; 17885: #ifdef ADD_THIRD_WING_20070525	// IsClass 
; 17886: 				useClass = sitem->IsClass( lpObj->Class, lpObj->ChangeUP, lpObj->ThirdChangeUp );
; 17887: #else
; 17888: 	#ifdef NEW_SKILL_FORSKYLAND
; 17889: 				useClass = sitem->IsClass(lpObj->Class, lpObj->ChangeUP);

  01077	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0107a	0f b6 88 9f 00
	00 00		 movzx	 ecx, BYTE PTR [eax+159]
  01081	51		 push	 ecx
  01082	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01085	0f b6 82 9c 00
	00 00		 movzx	 eax, BYTE PTR [edx+156]
  0108c	50		 push	 eax
  0108d	8b 4d 84	 mov	 ecx, DWORD PTR _sitem$[ebp]
  01090	e8 00 00 00 00	 call	 ?IsClass@CItem@@QAEHDH@Z ; CItem::IsClass
  01095	89 85 74 ff ff
	ff		 mov	 DWORD PTR _useClass$[ebp], eax

; 17890: 	#else
; 17891: 				useClass = sitem->IsClass(lpObj->Class);
; 17892: 	#endif
; 17893: #endif	// ADD_THIRD_WING_20070525
; 17894: 				
; 17895: 				//     
; 17896: 				if( useClass == FALSE )	LEAVE_SET(0xFF);

  0109b	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _useClass$[ebp], 0
  010a2	75 0c		 jne	 SHORT $LN132@gObjInvent
  010a4	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  010ab	e9 f8 09 00 00	 jmp	 $LN181@gObjInvent
$LN132@gObjInvent:

; 17897: 
; 17898: 				if( gObjIsItemPut(lpObj, sitem, target) == FALSE ) LEAVE_SET(0xFF);

  010b0	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  010b4	50		 push	 eax
  010b5	8b 4d 84	 mov	 ecx, DWORD PTR _sitem$[ebp]
  010b8	51		 push	 ecx
  010b9	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  010bc	52		 push	 edx
  010bd	e8 00 00 00 00	 call	 ?gObjIsItemPut@@YAHPAVOBJECTSTRUCT@@PAVCItem@@H@Z ; gObjIsItemPut
  010c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  010c5	85 c0		 test	 eax, eax
  010c7	75 0c		 jne	 SHORT $LN133@gObjInvent
  010c9	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  010d0	e9 d3 09 00 00	 jmp	 $LN181@gObjInvent
$LN133@gObjInvent:

; 17899: 			}

  010d5	e9 58 01 00 00	 jmp	 $LN139@gObjInvent
$LN124@gObjInvent:

; 17900: 			else //  ..
; 17901: 			{
; 17902: #ifdef HIDDEN_TREASUREBOX_EVENT_20050804	//       
; 17903: 				if(target >= MAX_INVENTORY) {
; 17904: 					if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM(12,26) &&
; 17905: 						(lpObj->pInventory[source].m_Level == 1 ||	// 
; 17906: 						lpObj->pInventory[source].m_Level == 2 ||	// 
; 17907: 						lpObj->pInventory[source].m_Level == 3 ||	// 
; 17908: 						lpObj->pInventory[source].m_Level == 4 ||	//  
; 17909: 						lpObj->pInventory[source].m_Level == 5		//  ( )
; 17910: 						))
; 17911: 					{
; 17912: 						LEAVE_SET(0xFF);
; 17913: 					}
; 17914: 				}
; 17915: #endif
; 17916: 				
; 17917: 				// gObjInventoryInsertItemPos() ->    
; 17918: 				w = (target-MAX_EQUIPMENT)%8;

  010da	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  010de	83 e8 0c	 sub	 eax, 12			; 0000000cH
  010e1	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  010e6	79 05		 jns	 SHORT $LN194@gObjInvent
  010e8	48		 dec	 eax
  010e9	83 c8 f8	 or	 eax, -8			; fffffff8H
  010ec	40		 inc	 eax
$LN194@gObjInvent:
  010ed	89 45 9c	 mov	 DWORD PTR _w$[ebp], eax

; 17919: 				h = (target-MAX_EQUIPMENT)/8;

  010f0	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  010f4	83 e8 0c	 sub	 eax, 12			; 0000000cH
  010f7	99		 cdq
  010f8	83 e2 07	 and	 edx, 7
  010fb	03 c2		 add	 eax, edx
  010fd	c1 f8 03	 sar	 eax, 3
  01100	89 45 98	 mov	 DWORD PTR _h$[ebp], eax

; 17920: #ifdef PERSONAL_SHOP_20040113		
; 17921: 				if( ExtentCheck(w, h, 8, 12) == FALSE ) LEAVE_SET(0xFF);

  01103	6a 0c		 push	 12			; 0000000cH
  01105	6a 08		 push	 8
  01107	8b 45 98	 mov	 eax, DWORD PTR _h$[ebp]
  0110a	50		 push	 eax
  0110b	8b 4d 9c	 mov	 ecx, DWORD PTR _w$[ebp]
  0110e	51		 push	 ecx
  0110f	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  01114	83 c4 10	 add	 esp, 16			; 00000010H
  01117	85 c0		 test	 eax, eax
  01119	75 0c		 jne	 SHORT $LN134@gObjInvent
  0111b	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  01122	e9 81 09 00 00	 jmp	 $LN181@gObjInvent
$LN134@gObjInvent:

; 17922: #else
; 17923: 				if( ExtentCheck(w, h, 8, 8) == FALSE ) LEAVE_SET(0xFF);
; 17924: #endif			
; 17925: 				sitem->GetSize(iwidth, iheight);

  01127	8d 45 90	 lea	 eax, DWORD PTR _iheight$[ebp]
  0112a	50		 push	 eax
  0112b	8d 4d 94	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  0112e	51		 push	 ecx
  0112f	8b 4d 84	 mov	 ecx, DWORD PTR _sitem$[ebp]
  01132	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize

; 17926: 				
; 17927: 				memcpy(TempInventoryMap, lpObj->pInventoryMap, 8*8);

  01137	6a 40		 push	 64			; 00000040H
  01139	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0113c	8b 88 60 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3168]
  01142	51		 push	 ecx
  01143	8d 55 a0	 lea	 edx, DWORD PTR _TempInventoryMap$[ebp]
  01146	52		 push	 edx
  01147	e8 00 00 00 00	 call	 _memcpy
  0114c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17928: 				switch( sFlag )

  0114f	8a 45 1c	 mov	 al, BYTE PTR _sFlag$[ebp]
  01152	88 85 0c ff ff
	ff		 mov	 BYTE PTR tv817[ebp], al
  01158	80 bd 0c ff ff
	ff 00		 cmp	 BYTE PTR tv817[ebp], 0
  0115f	74 0b		 je	 SHORT $LN135@gObjInvent
  01161	80 bd 0c ff ff
	ff 04		 cmp	 BYTE PTR tv817[ebp], 4
  01168	74 02		 je	 SHORT $LN135@gObjInvent
  0116a	eb 29		 jmp	 SHORT $LN10@gObjInvent
$LN135@gObjInvent:

; 17929: 				{
; 17930: 				case ITEMMOVE_INVENTORY :	//   ( )
; 17931: #ifdef PERSONAL_SHOP_20040113		
; 17932: 				case ITEMMOVE_PSHOPWND :	//   ( )
; 17933: #endif
; 17934: 					if( source > MAX_EQUIPMENT-1 )

  0116c	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01170	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  01173	7e 20		 jle	 SHORT $LN136@gObjInvent

; 17935: 					{
; 17936: 						gObjInventoryItemBoxSet(lpObj->m_Index, source, iwidth, iheight, 0xFF);	

  01175	68 ff 00 00 00	 push	 255			; 000000ffH
  0117a	8b 45 90	 mov	 eax, DWORD PTR _iheight$[ebp]
  0117d	50		 push	 eax
  0117e	8b 4d 94	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  01181	51		 push	 ecx
  01182	0f b6 55 0c	 movzx	 edx, BYTE PTR _source$[ebp]
  01186	52		 push	 edx
  01187	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0118a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0118c	51		 push	 ecx
  0118d	e8 00 00 00 00	 call	 ?gObjInventoryItemBoxSet@@YAXHHHHE@Z ; gObjInventoryItemBoxSet
  01192	83 c4 14	 add	 esp, 20			; 00000014H
$LN136@gObjInvent:
$LN10@gObjInvent:

; 17937: 					}
; 17938: 					break;
; 17939: 				case ITEMMOVE_WAREHOUSE :	//   
; 17940: 					break;
; 17941: 				}
; 17942: 				
; 17943: 				// .. ..
; 17944: 				if( *(gObj[aIndex].pInventoryMap+(h*8)+w) != 0xFF ) {

  01195	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0119c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  011a2	8b 94 01 60 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3168]
  011a9	8b 45 98	 mov	 eax, DWORD PTR _h$[ebp]
  011ac	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  011af	8b 55 9c	 mov	 edx, DWORD PTR _w$[ebp]
  011b2	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  011b6	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  011bb	74 24		 je	 SHORT $LN138@gObjInvent

; 17945: 					memcpy(lpObj->pInventoryMap, TempInventoryMap, 8*8);

  011bd	6a 40		 push	 64			; 00000040H
  011bf	8d 45 a0	 lea	 eax, DWORD PTR _TempInventoryMap$[ebp]
  011c2	50		 push	 eax
  011c3	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  011c6	8b 91 60 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3168]
  011cc	52		 push	 edx
  011cd	e8 00 00 00 00	 call	 _memcpy
  011d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17946: 					LEAVE_SET(0xFF);

  011d5	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  011dc	e9 c7 08 00 00	 jmp	 $LN181@gObjInvent
$LN138@gObjInvent:

; 17947: 				}
; 17948: 				blank = gObjInventoryRectCheck(lpObj->m_Index, w, h, iwidth,iheight);

  011e1	8b 45 90	 mov	 eax, DWORD PTR _iheight$[ebp]
  011e4	50		 push	 eax
  011e5	8b 4d 94	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  011e8	51		 push	 ecx
  011e9	8b 55 98	 mov	 edx, DWORD PTR _h$[ebp]
  011ec	52		 push	 edx
  011ed	8b 45 9c	 mov	 eax, DWORD PTR _w$[ebp]
  011f0	50		 push	 eax
  011f1	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  011f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  011f6	52		 push	 edx
  011f7	e8 00 00 00 00	 call	 ?gObjInventoryRectCheck@@YAEHHHHH@Z ; gObjInventoryRectCheck
  011fc	83 c4 14	 add	 esp, 20			; 00000014H
  011ff	0f b6 c0	 movzx	 eax, al
  01202	89 45 8c	 mov	 DWORD PTR _blank$[ebp], eax

; 17949: 				if( blank >= 0xFE )

  01205	81 7d 8c fe 00
	00 00		 cmp	 DWORD PTR _blank$[ebp], 254 ; 000000feH
  0120c	7c 24		 jl	 SHORT $LN139@gObjInvent

; 17950: 				{
; 17951: 					memcpy(lpObj->pInventoryMap, TempInventoryMap, 8*8);

  0120e	6a 40		 push	 64			; 00000040H
  01210	8d 45 a0	 lea	 eax, DWORD PTR _TempInventoryMap$[ebp]
  01213	50		 push	 eax
  01214	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01217	8b 91 60 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3168]
  0121d	52		 push	 edx
  0121e	e8 00 00 00 00	 call	 _memcpy
  01223	83 c4 0c	 add	 esp, 12			; 0000000cH

; 17952: 					LEAVE_SET(0xFF);

  01226	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  0122d	e9 76 08 00 00	 jmp	 $LN181@gObjInvent
$LN139@gObjInvent:

; 17953: 				}
; 17954: 			}
; 17955: 
; 17956: 			s_num = sitem->GetNumber();

  01232	8b 4d 84	 mov	 ecx, DWORD PTR _sitem$[ebp]
  01235	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  0123a	89 45 88	 mov	 DWORD PTR _s_num$[ebp], eax

; 17957: 
; 17958: 			//  
; 17959: 			titem = sitem;

  0123d	8b 45 84	 mov	 eax, DWORD PTR _sitem$[ebp]
  01240	89 45 80	 mov	 DWORD PTR _titem$[ebp], eax

; 17960: 
; 17961: 			switch( sFlag )

  01243	0f b6 45 1c	 movzx	 eax, BYTE PTR _sFlag$[ebp]
  01247	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv859[ebp], eax
  0124d	83 bd 0c ff ff
	ff 05		 cmp	 DWORD PTR tv859[ebp], 5
  01254	0f 87 da 00 00
	00		 ja	 $LN12@gObjInvent
  0125a	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv859[ebp]
  01260	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN193@gObjInvent[ecx*4]
$LN140@gObjInvent:

; 17962: 			{
; 17963: 			case ITEMMOVE_INVENTORY :	//  
; 17964: #ifdef PERSONAL_SHOP_20040113		
; 17965: 			case ITEMMOVE_PSHOPWND :	//  
; 17966: #endif
; 17967: 				lpObj->pInventory[target] = lpObj->pInventory[source];	//    

  01267	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0126b	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  01271	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01274	8b b2 5c 0c 00
	00		 mov	 esi, DWORD PTR [edx+3164]
  0127a	03 f1		 add	 esi, ecx
  0127c	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  01280	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  01286	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01289	8b ba 5c 0c 00
	00		 mov	 edi, DWORD PTR [edx+3164]
  0128f	03 f9		 add	 edi, ecx
  01291	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  01296	f3 a5		 rep movsd

; 17968: #ifdef MU_CHN_THANKS_RING_EVENT_20040908				//   -  
; 17969: 				{
; 17970: 					BOOL bSendEquip = FALSE;
; 17971: 					if(((
; 17972: 						source == EQUIPMENT_RING_LEFT || 
; 17973: 						source == EQUIPMENT_RING_RIGHT
; 17974: 						) &&
; 17975: 						sitem->m_Type == MAKE_ITEMNUM(13,20) &&
; 17976: 						sitem->m_Level == 3
; 17977: 						) ||
; 17978: 						((
; 17979: 						target == EQUIPMENT_RING_LEFT || 
; 17980: 						target == EQUIPMENT_RING_RIGHT
; 17981: 						) &&
; 17982: 						titem->m_Type == MAKE_ITEMNUM(13,20) &&
; 17983: 						sitem->m_Level == 3
; 17984: 						))
; 17985: 					{
; 17986: 						bSendEquip = TRUE;
; 17987: 					}
; 17988: #endif
; 17989: 				gObjInventoryDeleteItem(aIndex, source);

  01298	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0129c	50		 push	 eax
  0129d	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  012a0	51		 push	 ecx
  012a1	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  012a6	83 c4 08	 add	 esp, 8

; 17990: #ifdef MU_CHN_THANKS_RING_EVENT_20040908				//   -  
; 17991: 					if (bSendEquip) {
; 17992: 						GCEquipmentSend (aIndex);		//       .
; 17993: 					}
; 17994: 				}
; 17995: #endif
; 17996: 				break;

  012a9	e9 86 00 00 00	 jmp	 $LN12@gObjInvent
$LN141@gObjInvent:

; 17997: 			case ITEMMOVE_WAREHOUSE :
; 17998: 				lpObj->pInventory[target] = lpObj->pWarehouse[source];

  012ae	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  012b2	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  012b8	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  012bb	8b b2 94 0c 00
	00		 mov	 esi, DWORD PTR [edx+3220]
  012c1	03 f1		 add	 esi, ecx
  012c3	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  012c7	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  012cd	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  012d0	8b ba 5c 0c 00
	00		 mov	 edi, DWORD PTR [edx+3164]
  012d6	03 f9		 add	 edi, ecx
  012d8	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  012dd	f3 a5		 rep movsd

; 17999: 				gObjWarehouseDeleteItem(aIndex, source);

  012df	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  012e3	50		 push	 eax
  012e4	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  012e7	51		 push	 ecx
  012e8	e8 00 00 00 00	 call	 ?gObjWarehouseDeleteItem@@YAEHH@Z ; gObjWarehouseDeleteItem
  012ed	83 c4 08	 add	 esp, 8

; 18000: 				break;

  012f0	eb 42		 jmp	 SHORT $LN12@gObjInvent
$LN142@gObjInvent:

; 18001: 
; 18002: #ifdef DARKLORD_WORK
; 18003: 			case ITEMMOVE_DARK_TRAINER: 
; 18004: #endif
; 18005: #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 18006: 			case ITEMMOVE_JEWELOFHARMONY_PURITY:
; 18007: 			case ITEMMOVE_JEWELOFHARMONY_SMELT:
; 18008: 			case ITEMMOVE_JEWELOFHARMONY_RESTORE:
; 18009: #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 18010: #ifdef ADD_PCS_LOTTERY_SYSTEM_20070117
; 18011: 			case ITEMMOVE_LOTTERY_MIX:
; 18012: #endif // ADD_PCS_LOTTERY_SYSTEM_20070117
; 18013: #ifdef ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 18014: 			case ITEMMOVE_SOCKET_ITEM_EXTRACT:				//  
; 18015: 			case ITEMMOVE_SOCKET_ITEM_COMPOSIT:				//  
; 18016: 			case ITEMMOVE_SOCKET_ITEM_EQUIP:				//  
; 18017: 			case ITEMMOVE_SOCKET_ITEM_REMOVE:				//  
; 18018: #endif // ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 18019: #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312
; 18020: 			case ITEMMOVE_CHERRYBLOSSOM:
; 18021: #endif // ADD_EVENT_CHERRYBLOSSOM_20080312
; 18022: 			case ITEMMOVE_CHAOSBOX : 
; 18023: 				lpObj->pInventory[target] = lpObj->pChaosBox[source];

  012f2	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  012f6	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  012fc	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  012ff	8b b2 ac 0c 00
	00		 mov	 esi, DWORD PTR [edx+3244]
  01305	03 f1		 add	 esi, ecx
  01307	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  0130b	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  01311	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01314	8b ba 5c 0c 00
	00		 mov	 edi, DWORD PTR [edx+3164]
  0131a	03 f9		 add	 edi, ecx
  0131c	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  01321	f3 a5		 rep movsd

; 18024: 				gObjChaosBoxDeleteItem(aIndex, source);

  01323	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01327	50		 push	 eax
  01328	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0132b	51		 push	 ecx
  0132c	e8 00 00 00 00	 call	 ?gObjChaosBoxDeleteItem@@YAEHH@Z ; gObjChaosBoxDeleteItem
  01331	83 c4 08	 add	 esp, 8
$LN12@gObjInvent:

; 18025: 				break;
; 18026: 			}
; 18027: 			
; 18028: 			//     .
; 18029: 			if( target > MAX_EQUIPMENT-1 )

  01334	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  01338	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0133b	7e 13		 jle	 SHORT $LN143@gObjInvent

; 18030: 			{
; 18031: 				gObjInventoryItemSet(aIndex, target, 1);

  0133d	6a 01		 push	 1
  0133f	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  01343	50		 push	 eax
  01344	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01347	51		 push	 ecx
  01348	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  0134d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN143@gObjInvent:

; 18032: 			}	
; 18033: 			//      .
; 18034: 			if( target < MAX_EQUIPMENT )

  01350	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  01354	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  01357	0f 8d a0 00 00
	00		 jge	 $LN146@gObjInvent

; 18035: 			{
; 18036: 				CItem *lpItem;
; 18037: 				lpItem = (CItem*)&lpObj->pInventory[target];

  0135d	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  01361	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  01367	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0136a	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  01370	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _lpItem$5[ebp], ecx

; 18038: 				if( lpItem->m_Option1 )

  01376	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _lpItem$5[ebp]
  0137c	0f b6 48 78	 movzx	 ecx, BYTE PTR [eax+120]
  01380	85 c9		 test	 ecx, ecx
  01382	74 79		 je	 SHORT $LN146@gObjInvent

; 18039: 				{
; 18040: 					int addskill = gObjWeaponMagicAdd(&gObj[aIndex], lpItem->m_Special[0], (BYTE)lpItem->m_Level);

  01384	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _lpItem$5[ebp]
  0138a	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  0138e	51		 push	 ecx
  0138f	ba 01 00 00 00	 mov	 edx, 1
  01394	6b c2 00	 imul	 eax, edx, 0
  01397	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _lpItem$5[ebp]
  0139d	0f b6 54 01 31	 movzx	 edx, BYTE PTR [ecx+eax+49]
  013a2	52		 push	 edx
  013a3	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  013aa	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  013b0	50		 push	 eax
  013b1	e8 00 00 00 00	 call	 ?gObjWeaponMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjWeaponMagicAdd
  013b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  013b9	89 85 54 ff ff
	ff		 mov	 DWORD PTR _addskill$4[ebp], eax

; 18041: 					if( addskill >= 0 ) {

  013bf	83 bd 54 ff ff
	ff 00		 cmp	 DWORD PTR _addskill$4[ebp], 0
  013c6	7c 35		 jl	 SHORT $LN146@gObjInvent

; 18042: 						GCMagicListOneSend(aIndex, addskill, lpItem->m_Special[0], (BYTE)lpItem->m_Level, 0);

  013c8	6a 00		 push	 0
  013ca	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _lpItem$5[ebp]
  013d0	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  013d4	51		 push	 ecx
  013d5	ba 01 00 00 00	 mov	 edx, 1
  013da	6b c2 00	 imul	 eax, edx, 0
  013dd	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _lpItem$5[ebp]
  013e3	0f b6 54 01 31	 movzx	 edx, BYTE PTR [ecx+eax+49]
  013e8	52		 push	 edx
  013e9	0f b6 85 54 ff
	ff ff		 movzx	 eax, BYTE PTR _addskill$4[ebp]
  013f0	50		 push	 eax
  013f1	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  013f4	51		 push	 ecx
  013f5	e8 00 00 00 00	 call	 ?GCMagicListOneSend@@YAXHDEEE@Z ; GCMagicListOneSend
  013fa	83 c4 14	 add	 esp, 20			; 00000014H
$LN146@gObjInvent:

; 18043: 					}
; 18044: 				}
; 18045: 			}
; 18046: 			break;

  013fd	e9 df 04 00 00	 jmp	 $LN8@gObjInvent
$LN147@gObjInvent:

; 18047: 		case ITEMMOVE_WAREHOUSE : //  ..		
; 18048: 			{		
; 18049: 			BYTE ret;
; 18050: 			switch( sFlag )

  01402	8a 45 1c	 mov	 al, BYTE PTR _sFlag$[ebp]
  01405	88 85 0c ff ff
	ff		 mov	 BYTE PTR tv965[ebp], al
  0140b	80 bd 0c ff ff
	ff 00		 cmp	 BYTE PTR tv965[ebp], 0
  01412	74 12		 je	 SHORT $LN148@gObjInvent
  01414	80 bd 0c ff ff
	ff 02		 cmp	 BYTE PTR tv965[ebp], 2
  0141b	0f 84 22 01 00
	00		 je	 $LN152@gObjInvent
  01421	e9 60 01 00 00	 jmp	 $LN14@gObjInvent
$LN148@gObjInvent:

; 18051: 			{
; 18052: 			case ITEMMOVE_INVENTORY :
; 18053: #ifdef RING_EVENT_ITEMBOX_20031124		//  -  
; 18054: #ifdef MODIFY_MAGICIARINGRING_TRADE_BUGFIX_20070328		//     
; 18055: if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM(13,20) &&

  01426	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0142a	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  01430	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01433	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  01439	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0143e	6a 14		 push	 20			; 00000014H
  01440	6a 0d		 push	 13			; 0000000dH
  01442	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01447	83 c4 08	 add	 esp, 8
  0144a	3b f0		 cmp	 esi, eax
  0144c	75 62		 jne	 SHORT $LN149@gObjInvent
  0144e	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01452	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  01458	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0145b	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  01461	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  01466	85 c9		 test	 ecx, ecx
  01468	74 3a		 je	 SHORT $LN150@gObjInvent
  0146a	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0146e	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  01474	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01477	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0147d	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  01482	83 f9 01	 cmp	 ecx, 1
  01485	74 1d		 je	 SHORT $LN150@gObjInvent
  01487	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0148b	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  01491	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01494	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0149a	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  0149f	83 f9 02	 cmp	 ecx, 2
  014a2	75 0c		 jne	 SHORT $LN149@gObjInvent
$LN150@gObjInvent:

; 18056: 					(lpObj->pInventory[source].m_Level == 0	||	//  
; 18057: 					 lpObj->pInventory[source].m_Level == 1	||	//  
; 18058: 					 lpObj->pInventory[source].m_Level == 2		//  
; 18059: 					) )
; 18060: 
; 18061: #else
; 18062: 				if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM(13,20) &&
; 18063: 					(lpObj->pInventory[source].m_Level == 0	||	//  
; 18064: 					 lpObj->pInventory[source].m_Level == 1		//  
; 18065: 					))
; 18066: #endif	// MODIFY_MAGICIARINGRING_TRADE_BUGFIX_20070328
; 18067: 				{	//      .
; 18068: 					LEAVE_SET(0xFF);

  014a4	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  014ab	e9 f8 05 00 00	 jmp	 $LN181@gObjInvent
$LN149@gObjInvent:

; 18069: 				}
; 18070: #endif
; 18071: #ifdef DARK_LORD_HEART_EVENT_20040810	//     .
; 18072: 				if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM(14,11) &&

  014b0	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  014b4	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  014ba	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  014bd	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  014c3	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  014c8	6a 0b		 push	 11			; 0000000bH
  014ca	6a 0e		 push	 14			; 0000000eH
  014cc	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  014d1	83 c4 08	 add	 esp, 8
  014d4	3b f0		 cmp	 esi, eax
  014d6	75 29		 jne	 SHORT $LN151@gObjInvent
  014d8	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  014dc	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  014e2	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  014e5	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  014eb	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  014f0	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  014f3	75 0c		 jne	 SHORT $LN151@gObjInvent

; 18073: 					lpObj->pInventory[source].m_Level == 13
; 18074: 					)
; 18075: 				{
; 18076: 					LEAVE_SET(0xFF);

  014f5	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  014fc	e9 a7 05 00 00	 jmp	 $LN181@gObjInvent
$LN151@gObjInvent:

; 18077: 				}
; 18078: #endif
; 18079: #ifdef HIDDEN_TREASUREBOX_EVENT_20050804	//       
; 18080: 				if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM(12,26) &&
; 18081: 					(lpObj->pInventory[source].m_Level == 1 ||	// 
; 18082: 					lpObj->pInventory[source].m_Level == 2 ||	// 
; 18083: 					lpObj->pInventory[source].m_Level == 3 ||	// 
; 18084: 					lpObj->pInventory[source].m_Level == 4 ||	//  
; 18085: 					lpObj->pInventory[source].m_Level == 5		//  ( )
; 18086: 					))
; 18087: 				{
; 18088: 					LEAVE_SET(0xFF);
; 18089: 				}
; 18090: #endif
; 18091: #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830			//   
; 18092: 				if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 39 ) )
; 18093: 				{
; 18094: 					LEAVE_SET(0xFF);
; 18095: 				}				
; 18096: #endif
; 18097: #ifdef UPDATE_GM_FUNCTION_20070228			// GM     
; 18098: 				if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 42 ) )
; 18099: 				{
; 18100: 					LEAVE_SET(0xFF);
; 18101: 				}	
; 18102: #endif	
; 18103: #ifdef PCBANG_POINT_SYSTEM_20070206				//   
; 18104: 				if( g_PCBangPointSystem.CheckPCBangPointItem( lpObj->pInventory[source].m_Type ) )
; 18105: 				{
; 18106: 					LEAVE_SET(0xFF);
; 18107: 				}
; 18108: #endif
; 18109: #ifdef MODIFY_QUEST_SYSTEM_20070525			//    
; 18110: 				if( lpObj->pInventory[source].m_QuestItem )
; 18111: 				{
; 18112: 					LEAVE_SET(0xFF);
; 18113: 				}
; 18114: #endif
; 18115: 				ret = gObjWarehouseInsertItemPos(aIndex, lpObj->pInventory[source], target, -1);

  01501	6a ff		 push	 -1
  01503	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  01507	50		 push	 eax
  01508	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _source$[ebp]
  0150c	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  01512	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01515	8b b0 5c 0c 00
	00		 mov	 esi, DWORD PTR [eax+3164]
  0151b	03 f2		 add	 esi, edx
  0151d	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  01523	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  01528	8b fc		 mov	 edi, esp
  0152a	f3 a5		 rep movsd
  0152c	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0152f	51		 push	 ecx
  01530	e8 00 00 00 00	 call	 ?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z ; gObjWarehouseInsertItemPos
  01535	81 c4 b4 00 00
	00		 add	 esp, 180		; 000000b4H
  0153b	88 85 53 ff ff
	ff		 mov	 BYTE PTR _ret$3[ebp], al

; 18116: 				break;

  01541	eb 43		 jmp	 SHORT $LN14@gObjInvent
$LN152@gObjInvent:

; 18117: 			case ITEMMOVE_WAREHOUSE :
; 18118: 				ret = gObjWarehouseInsertItemPos(aIndex, lpObj->pWarehouse[source], target, source);

  01543	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01547	50		 push	 eax
  01548	0f b6 4d 10	 movzx	 ecx, BYTE PTR _target$[ebp]
  0154c	51		 push	 ecx
  0154d	0f b6 55 0c	 movzx	 edx, BYTE PTR _source$[ebp]
  01551	69 c2 a8 00 00
	00		 imul	 eax, edx, 168
  01557	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0155a	8b b1 94 0c 00
	00		 mov	 esi, DWORD PTR [ecx+3220]
  01560	03 f0		 add	 esi, eax
  01562	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  01568	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0156d	8b fc		 mov	 edi, esp
  0156f	f3 a5		 rep movsd
  01571	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01574	52		 push	 edx
  01575	e8 00 00 00 00	 call	 ?gObjWarehouseInsertItemPos@@YAEHVCItem@@HH@Z ; gObjWarehouseInsertItemPos
  0157a	81 c4 b4 00 00
	00		 add	 esp, 180		; 000000b4H
  01580	88 85 53 ff ff
	ff		 mov	 BYTE PTR _ret$3[ebp], al
$LN14@gObjInvent:

; 18119: 				break;
; 18120: 			}
; 18121: 			
; 18122: 			if( ret == 0xFF )

  01586	0f b6 85 53 ff
	ff ff		 movzx	 eax, BYTE PTR _ret$3[ebp]
  0158d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  01592	75 0c		 jne	 SHORT $LN153@gObjInvent

; 18123: 			{
; 18124: 				LEAVE_SET(0xFF);

  01594	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  0159b	e9 08 05 00 00	 jmp	 $LN181@gObjInvent
$LN153@gObjInvent:

; 18125: 			}
; 18126: 			}
; 18127: 
; 18128: 			switch( sFlag )

  015a0	8a 45 1c	 mov	 al, BYTE PTR _sFlag$[ebp]
  015a3	88 85 0c ff ff
	ff		 mov	 BYTE PTR tv1042[ebp], al
  015a9	80 bd 0c ff ff
	ff 00		 cmp	 BYTE PTR tv1042[ebp], 0
  015b0	74 0e		 je	 SHORT $LN154@gObjInvent
  015b2	80 bd 0c ff ff
	ff 02		 cmp	 BYTE PTR tv1042[ebp], 2
  015b9	74 49		 je	 SHORT $LN155@gObjInvent
  015bb	e9 86 00 00 00	 jmp	 $LN16@gObjInvent
$LN154@gObjInvent:

; 18129: 			{
; 18130: 			case ITEMMOVE_INVENTORY :	//  ..
; 18131: 				lpObj->pWarehouse[target] = lpObj->pInventory[source];

  015c0	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  015c4	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  015ca	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  015cd	8b b2 5c 0c 00
	00		 mov	 esi, DWORD PTR [edx+3164]
  015d3	03 f1		 add	 esi, ecx
  015d5	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  015d9	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  015df	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  015e2	8b ba 94 0c 00
	00		 mov	 edi, DWORD PTR [edx+3220]
  015e8	03 f9		 add	 edi, ecx
  015ea	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  015ef	f3 a5		 rep movsd

; 18132: 				gObjInventoryDeleteItem(aIndex, source);

  015f1	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  015f5	50		 push	 eax
  015f6	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  015f9	51		 push	 ecx
  015fa	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  015ff	83 c4 08	 add	 esp, 8

; 18133: 				break;

  01602	eb 42		 jmp	 SHORT $LN16@gObjInvent
$LN155@gObjInvent:

; 18134: 			case ITEMMOVE_WAREHOUSE :	//  
; 18135: 				lpObj->pWarehouse[target] = lpObj->pWarehouse[source];

  01604	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01608	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0160e	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01611	8b b2 94 0c 00
	00		 mov	 esi, DWORD PTR [edx+3220]
  01617	03 f1		 add	 esi, ecx
  01619	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  0161d	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  01623	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01626	8b ba 94 0c 00
	00		 mov	 edi, DWORD PTR [edx+3220]
  0162c	03 f9		 add	 edi, ecx
  0162e	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  01633	f3 a5		 rep movsd

; 18136: 				gObjWarehouseDeleteItem(aIndex, source);

  01635	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01639	50		 push	 eax
  0163a	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0163d	51		 push	 ecx
  0163e	e8 00 00 00 00	 call	 ?gObjWarehouseDeleteItem@@YAEHH@Z ; gObjWarehouseDeleteItem
  01643	83 c4 08	 add	 esp, 8
$LN16@gObjInvent:

; 18137: 				break;
; 18138: 			}		
; 18139: 
; 18140: 			//     .
; 18141: 			gObjWarehouseItemSet(aIndex, target, 1);

  01646	6a 01		 push	 1
  01648	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  0164c	50		 push	 eax
  0164d	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01650	51		 push	 ecx
  01651	e8 00 00 00 00	 call	 ?gObjWarehouseItemSet@@YAXHHE@Z ; gObjWarehouseItemSet
  01656	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18142: 			if( sFlag == 0 )

  01659	0f b6 45 1c	 movzx	 eax, BYTE PTR _sFlag$[ebp]
  0165d	85 c0		 test	 eax, eax
  0165f	75 6e		 jne	 SHORT $LN157@gObjInvent

; 18143: 			{
; 18144: 				//   CharSet  .
; 18145: 				if( source < MAX_EQUIPMENT )

  01661	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01665	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  01668	7d 65		 jge	 SHORT $LN157@gObjInvent

; 18146: 				{
; 18147: 					if( source == EQUIPMENT_RING_RIGHT || source == EQUIPMENT_RING_LEFT)

  0166a	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0166e	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  01671	74 09		 je	 SHORT $LN159@gObjInvent
  01673	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01677	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  0167a	75 36		 jne	 SHORT $LN160@gObjInvent
$LN159@gObjInvent:

; 18148: 					{
; 18149: 						if( lpObj->pWarehouse[target].m_Type == MAKE_ITEMNUM(13,10) )

  0167c	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  01680	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  01686	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01689	8b 82 94 0c 00
	00		 mov	 eax, DWORD PTR [edx+3220]
  0168f	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  01694	6a 0a		 push	 10			; 0000000aH
  01696	6a 0d		 push	 13			; 0000000dH
  01698	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0169d	83 c4 08	 add	 esp, 8
  016a0	3b f0		 cmp	 esi, eax
  016a2	75 0e		 jne	 SHORT $LN160@gObjInvent

; 18150: 						{
; 18151: 							gObjUseSkill.SkillChangeUse(aIndex);						

  016a4	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  016a7	50		 push	 eax
  016a8	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  016ad	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN160@gObjInvent:

; 18152: 						}
; 18153: 
; 18154: #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 18155: 						if( lpObj->pWarehouse[target].m_Type == MAKE_ITEMNUM( 13, 40 ) )
; 18156: 						{
; 18157: 							gObjUseSkill.SkillChangeUse( aIndex );
; 18158: 						}
; 18159: #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 18160: 
; 18161: #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 18162: 						if( lpObj->pWarehouse[target].m_Type == MAKE_ITEMNUM( 13, 41 ) )
; 18163: 						{
; 18164: 							gObjUseSkill.SkillChangeUse( aIndex );
; 18165: 						}
; 18166: #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 18167: 
; 18168: #ifdef MODIFY_SNOW_MAN_POLYMORPH_RING_BUGFIX_20090414
; 18169: 						if( lpObj->pWarehouse[target].m_Type == MAKE_ITEMNUM( 13, 68 ) )
; 18170: 						{
; 18171: 							gObjUseSkill.SkillChangeUse( aIndex );
; 18172: 						}
; 18173: #else // MODIFY_SNOW_MAN_POLYMORPH_RING_BUGFIX_20090414
; 18174: 	//------------->
; 18175: 	//20081013    - (grooving)
; 18176: 	#ifdef ADD_XMASEVENT_POLYMORPH_RING_20080930
; 18177: 						if( lpObj->pWarehouse[target].m_Type == MAKE_ITEMNUM( 13, 68 ) )
; 18178: 						{
; 18179: 							gObjUseSkill.SkillChangeUse( aIndex );
; 18180: 						}
; 18181: 	#endif // ADD_XMASEVENT_POLYMORPH_RING_20080930
; 18182: 	//<-------------
; 18183: #endif // MODIFY_SNOW_MAN_POLYMORPH_RING_BUGFIX_20090414
; 18184: 
; 18185: #ifdef ADD_PREMIUMITEM_PANDA
; 18186: 						if( lpObj->pWarehouse[target].m_Type == MAKE_ITEMNUM( 13, 76 ) )
; 18187: 						{
; 18188: 							gObjUseSkill.SkillChangeUse( aIndex );
; 18189: 						}
; 18190: #endif // ADD_PREMIUMITEM_PANDA
; 18191: 					}
; 18192: 					gObjMakePreviewCharSet(aIndex);

  016b2	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  016b5	50		 push	 eax
  016b6	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  016bb	83 c4 04	 add	 esp, 4

; 18193: 					GCEquipmentChange(aIndex, source);

  016be	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  016c2	50		 push	 eax
  016c3	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  016c6	51		 push	 ecx
  016c7	e8 00 00 00 00	 call	 ?GCEquipmentChange@@YAXHH@Z ; GCEquipmentChange
  016cc	83 c4 08	 add	 esp, 8
$LN157@gObjInvent:

; 18194: 				}
; 18195: 			}
; 18196: 			LEAVE_SET(0x02);

  016cf	c6 85 73 ff ff
	ff 02		 mov	 BYTE PTR _sp_ret$[ebp], 2
  016d6	e9 cd 03 00 00	 jmp	 $LN181@gObjInvent
$LN161@gObjInvent:

; 18197: #ifdef DARKLORD_WORK
; 18198: 		case ITEMMOVE_DARK_TRAINER :
; 18199: #endif
; 18200: #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 18201: 		case ITEMMOVE_JEWELOFHARMONY_PURITY:
; 18202: 		case ITEMMOVE_JEWELOFHARMONY_SMELT:
; 18203: 		case ITEMMOVE_JEWELOFHARMONY_RESTORE:
; 18204: #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 18205: #ifdef ADD_PCS_LOTTERY_SYSTEM_20070117
; 18206: 		case ITEMMOVE_LOTTERY_MIX:
; 18207: #endif // ADD_PCS_LOTTERY_SYSTEM_20070117
; 18208: #ifdef ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 18209: 		case ITEMMOVE_SOCKET_ITEM_EXTRACT:
; 18210: 		case ITEMMOVE_SOCKET_ITEM_COMPOSIT:
; 18211: 		case ITEMMOVE_SOCKET_ITEM_EQUIP:
; 18212: 		case ITEMMOVE_SOCKET_ITEM_REMOVE:
; 18213: #endif // ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 18214: #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312
; 18215: 		case ITEMMOVE_CHERRYBLOSSOM:
; 18216: #endif // ADD_EVENT_CHERRYBLOSSOM_20080312
; 18217: 		case ITEMMOVE_CHAOSBOX :
; 18218: 			{		
; 18219: 			BYTE ret;
; 18220: 			switch( sFlag )

  016db	8a 45 1c	 mov	 al, BYTE PTR _sFlag$[ebp]
  016de	88 85 0c ff ff
	ff		 mov	 BYTE PTR tv1100[ebp], al
  016e4	80 bd 0c ff ff
	ff 00		 cmp	 BYTE PTR tv1100[ebp], 0
  016eb	74 17		 je	 SHORT $LN162@gObjInvent
  016ed	80 bd 0c ff ff
	ff 03		 cmp	 BYTE PTR tv1100[ebp], 3
  016f4	74 50		 je	 SHORT $LN163@gObjInvent
  016f6	80 bd 0c ff ff
	ff 05		 cmp	 BYTE PTR tv1100[ebp], 5
  016fd	74 47		 je	 SHORT $LN163@gObjInvent
  016ff	e9 85 00 00 00	 jmp	 $LN18@gObjInvent
$LN162@gObjInvent:

; 18221: 			{
; 18222: 			case ITEMMOVE_INVENTORY :
; 18223: 				ret = gObjChaosBoxInsertItemPos(aIndex, lpObj->pInventory[source], target, -1);

  01704	6a ff		 push	 -1
  01706	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  0170a	50		 push	 eax
  0170b	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _source$[ebp]
  0170f	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  01715	8b 45 e0	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01718	8b b0 5c 0c 00
	00		 mov	 esi, DWORD PTR [eax+3164]
  0171e	03 f2		 add	 esi, edx
  01720	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  01726	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0172b	8b fc		 mov	 edi, esp
  0172d	f3 a5		 rep movsd
  0172f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01732	51		 push	 ecx
  01733	e8 00 00 00 00	 call	 ?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z ; gObjChaosBoxInsertItemPos
  01738	81 c4 b4 00 00
	00		 add	 esp, 180		; 000000b4H
  0173e	88 85 52 ff ff
	ff		 mov	 BYTE PTR _ret$2[ebp], al

; 18224: 				break;

  01744	eb 43		 jmp	 SHORT $LN18@gObjInvent
$LN163@gObjInvent:

; 18225: #ifdef DARKLORD_WORK
; 18226: 			case ITEMMOVE_DARK_TRAINER :
; 18227: #endif
; 18228: #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 18229: 		case ITEMMOVE_JEWELOFHARMONY_PURITY:
; 18230: 		case ITEMMOVE_JEWELOFHARMONY_SMELT:
; 18231: 		case ITEMMOVE_JEWELOFHARMONY_RESTORE:
; 18232: #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530		
; 18233: #ifdef ADD_PCS_LOTTERY_SYSTEM_20070117
; 18234: 		case ITEMMOVE_LOTTERY_MIX:
; 18235: #endif // ADD_PCS_LOTTERY_SYSTEM_20070117
; 18236: #ifdef ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 18237: 		case ITEMMOVE_SOCKET_ITEM_EXTRACT:
; 18238: 		case ITEMMOVE_SOCKET_ITEM_COMPOSIT:
; 18239: 		case ITEMMOVE_SOCKET_ITEM_EQUIP:
; 18240: 		case ITEMMOVE_SOCKET_ITEM_REMOVE:
; 18241: #endif // ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 18242: #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312
; 18243: 		case ITEMMOVE_CHERRYBLOSSOM:
; 18244: #endif // ADD_EVENT_CHERRYBLOSSOM_20080312
; 18245: 			case ITEMMOVE_CHAOSBOX :
; 18246: 				ret = gObjChaosBoxInsertItemPos(aIndex, lpObj->pChaosBox[source], target, source);

  01746	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0174a	50		 push	 eax
  0174b	0f b6 4d 10	 movzx	 ecx, BYTE PTR _target$[ebp]
  0174f	51		 push	 ecx
  01750	0f b6 55 0c	 movzx	 edx, BYTE PTR _source$[ebp]
  01754	69 c2 a8 00 00
	00		 imul	 eax, edx, 168
  0175a	8b 4d e0	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0175d	8b b1 ac 0c 00
	00		 mov	 esi, DWORD PTR [ecx+3244]
  01763	03 f0		 add	 esi, eax
  01765	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0176b	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  01770	8b fc		 mov	 edi, esp
  01772	f3 a5		 rep movsd
  01774	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  01777	52		 push	 edx
  01778	e8 00 00 00 00	 call	 ?gObjChaosBoxInsertItemPos@@YAEHVCItem@@HH@Z ; gObjChaosBoxInsertItemPos
  0177d	81 c4 b4 00 00
	00		 add	 esp, 180		; 000000b4H
  01783	88 85 52 ff ff
	ff		 mov	 BYTE PTR _ret$2[ebp], al
$LN18@gObjInvent:

; 18247: 				break;
; 18248: 			}
; 18249: 			
; 18250: 			if( ret == 0xFF )

  01789	0f b6 85 52 ff
	ff ff		 movzx	 eax, BYTE PTR _ret$2[ebp]
  01790	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  01795	75 0c		 jne	 SHORT $LN164@gObjInvent

; 18251: 			{
; 18252: 				LEAVE_SET(0xFF);

  01797	c6 85 73 ff ff
	ff ff		 mov	 BYTE PTR _sp_ret$[ebp], 255 ; 000000ffH
  0179e	e9 05 03 00 00	 jmp	 $LN181@gObjInvent
$LN164@gObjInvent:

; 18253: 			}
; 18254: 			}
; 18255: 
; 18256: 			switch( sFlag )

  017a3	8a 45 1c	 mov	 al, BYTE PTR _sFlag$[ebp]
  017a6	88 85 0c ff ff
	ff		 mov	 BYTE PTR tv1130[ebp], al
  017ac	80 bd 0c ff ff
	ff 00		 cmp	 BYTE PTR tv1130[ebp], 0
  017b3	74 17		 je	 SHORT $LN165@gObjInvent
  017b5	80 bd 0c ff ff
	ff 03		 cmp	 BYTE PTR tv1130[ebp], 3
  017bc	74 52		 je	 SHORT $LN166@gObjInvent
  017be	80 bd 0c ff ff
	ff 05		 cmp	 BYTE PTR tv1130[ebp], 5
  017c5	74 49		 je	 SHORT $LN166@gObjInvent
  017c7	e9 86 00 00 00	 jmp	 $LN20@gObjInvent
$LN165@gObjInvent:

; 18257: 			{
; 18258: 			case ITEMMOVE_INVENTORY :	//  ..
; 18259: 				lpObj->pChaosBox[target] = lpObj->pInventory[source];

  017cc	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  017d0	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  017d6	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  017d9	8b b2 5c 0c 00
	00		 mov	 esi, DWORD PTR [edx+3164]
  017df	03 f1		 add	 esi, ecx
  017e1	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  017e5	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  017eb	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  017ee	8b ba ac 0c 00
	00		 mov	 edi, DWORD PTR [edx+3244]
  017f4	03 f9		 add	 edi, ecx
  017f6	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  017fb	f3 a5		 rep movsd

; 18260: 				gObjInventoryDeleteItem(aIndex, source);

  017fd	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01801	50		 push	 eax
  01802	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01805	51		 push	 ecx
  01806	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  0180b	83 c4 08	 add	 esp, 8

; 18261: 				break;

  0180e	eb 42		 jmp	 SHORT $LN20@gObjInvent
$LN166@gObjInvent:

; 18262: 
; 18263: #ifdef DARKLORD_WORK
; 18264: 			case ITEMMOVE_DARK_TRAINER :	// 2  2 ().
; 18265: #endif
; 18266: #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 18267: 			case ITEMMOVE_JEWELOFHARMONY_PURITY:
; 18268: 			case ITEMMOVE_JEWELOFHARMONY_SMELT:
; 18269: 			case ITEMMOVE_JEWELOFHARMONY_RESTORE:
; 18270: #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 18271: #ifdef ADD_PCS_LOTTERY_SYSTEM_20070117
; 18272: 			case ITEMMOVE_LOTTERY_MIX:
; 18273: #endif // ADD_PCS_LOTTERY_SYSTEM_20070117
; 18274: #ifdef ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 18275: 			case ITEMMOVE_SOCKET_ITEM_EXTRACT:
; 18276: 			case ITEMMOVE_SOCKET_ITEM_COMPOSIT:
; 18277: 			case ITEMMOVE_SOCKET_ITEM_EQUIP:
; 18278: 			case ITEMMOVE_SOCKET_ITEM_REMOVE:
; 18279: #endif // ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 18280: #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312
; 18281: 			case ITEMMOVE_CHERRYBLOSSOM:
; 18282: #endif // ADD_EVENT_CHERRYBLOSSOM_20080312
; 18283: 			case ITEMMOVE_CHAOSBOX :	//   .
; 18284: 				lpObj->pChaosBox[target] = lpObj->pChaosBox[source];

  01810	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01814	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0181a	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0181d	8b b2 ac 0c 00
	00		 mov	 esi, DWORD PTR [edx+3244]
  01823	03 f1		 add	 esi, ecx
  01825	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  01829	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0182f	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01832	8b ba ac 0c 00
	00		 mov	 edi, DWORD PTR [edx+3244]
  01838	03 f9		 add	 edi, ecx
  0183a	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0183f	f3 a5		 rep movsd

; 18285: 				gObjChaosBoxDeleteItem(aIndex, source);

  01841	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01845	50		 push	 eax
  01846	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01849	51		 push	 ecx
  0184a	e8 00 00 00 00	 call	 ?gObjChaosBoxDeleteItem@@YAEHH@Z ; gObjChaosBoxDeleteItem
  0184f	83 c4 08	 add	 esp, 8
$LN20@gObjInvent:

; 18286: 				break;
; 18287: 			}		
; 18288: 
; 18289: 			//     .
; 18290: 			gObjChaosItemSet(aIndex, target, 1);

  01852	6a 01		 push	 1
  01854	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  01858	50		 push	 eax
  01859	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0185c	51		 push	 ecx
  0185d	e8 00 00 00 00	 call	 ?gObjChaosItemSet@@YAXHHE@Z ; gObjChaosItemSet
  01862	83 c4 0c	 add	 esp, 12			; 0000000cH

; 18291: 			if( sFlag == ITEMMOVE_INVENTORY )

  01865	0f b6 45 1c	 movzx	 eax, BYTE PTR _sFlag$[ebp]
  01869	85 c0		 test	 eax, eax
  0186b	75 66		 jne	 SHORT $LN168@gObjInvent

; 18292: 			{
; 18293: 				//   CharSet  .
; 18294: 				if( source < MAX_EQUIPMENT )

  0186d	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01871	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  01874	7d 5d		 jge	 SHORT $LN168@gObjInvent

; 18295: 				{
; 18296: 					if( source == EQUIPMENT_RING_RIGHT || source == EQUIPMENT_RING_LEFT)

  01876	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0187a	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0187d	74 09		 je	 SHORT $LN170@gObjInvent
  0187f	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01883	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  01886	75 2e		 jne	 SHORT $LN171@gObjInvent
$LN170@gObjInvent:

; 18297: 					{
; 18298: #ifdef ITEM_INDEX_EXTEND_20050706
; 18299: 						if( lpObj->pChaosBox[target].m_Type == MAKE_ITEMNUM(13,10) )
; 18300: #else
; 18301: 						if( lpObj->pChaosBox[target].m_Type == ((13<<ITEM_BITSHIFT)+10) )

  01888	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  0188c	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  01892	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01895	8b 82 ac 0c 00
	00		 mov	 eax, DWORD PTR [edx+3244]
  0189b	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  018a0	81 f9 aa 01 00
	00		 cmp	 ecx, 426		; 000001aaH
  018a6	75 0e		 jne	 SHORT $LN171@gObjInvent

; 18302: #endif
; 18303: 						{
; 18304: 							gObjUseSkill.SkillChangeUse(aIndex);						

  018a8	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  018ab	50		 push	 eax
  018ac	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  018b1	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN171@gObjInvent:

; 18305: 						}
; 18306: 
; 18307: #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	//   
; 18308: 						if( lpObj->pChaosBox[target].m_Type == MAKE_ITEMNUM( 13, 39 ) )
; 18309: 						{
; 18310: 							gObjUseSkill.SkillChangeUse( aIndex );						
; 18311: 						}							
; 18312: #endif
; 18313: 
; 18314: #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 18315: 						if( lpObj->pChaosBox[target].m_Type == MAKE_ITEMNUM( 13, 40 ) )
; 18316: 						{
; 18317: 							gObjUseSkill.SkillChangeUse( aIndex );
; 18318: 						}
; 18319: #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 18320: 
; 18321: #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 18322: 						if( lpObj->pChaosBox[target].m_Type == MAKE_ITEMNUM( 13, 41 ) )
; 18323: 						{
; 18324: 							gObjUseSkill.SkillChangeUse( aIndex );
; 18325: 						}
; 18326: #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 18327: 					}
; 18328: 					gObjMakePreviewCharSet(aIndex);

  018b6	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  018b9	50		 push	 eax
  018ba	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  018bf	83 c4 04	 add	 esp, 4

; 18329: 					GCEquipmentChange(aIndex, source);

  018c2	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  018c6	50		 push	 eax
  018c7	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  018ca	51		 push	 ecx
  018cb	e8 00 00 00 00	 call	 ?GCEquipmentChange@@YAXHH@Z ; GCEquipmentChange
  018d0	83 c4 08	 add	 esp, 8
$LN168@gObjInvent:

; 18330: 				}
; 18331: 			}
; 18332: 
; 18333: #ifdef DARKLORD_WORK
; 18334: 			LEAVE_SET(tFlag);

  018d3	8a 45 20	 mov	 al, BYTE PTR _tFlag$[ebp]
  018d6	88 85 73 ff ff
	ff		 mov	 BYTE PTR _sp_ret$[ebp], al
  018dc	e9 c7 01 00 00	 jmp	 $LN181@gObjInvent
$LN8@gObjInvent:

; 18335: #else
; 18336: 			LEAVE_SET(0x03);
; 18337: #endif
; 18338: 		}
; 18339: 
; 18340: 		if( sFlag == ITEMMOVE_INVENTORY )

  018e1	0f b6 45 1c	 movzx	 eax, BYTE PTR _sFlag$[ebp]
  018e5	85 c0		 test	 eax, eax
  018e7	0f 85 0b 01 00
	00		 jne	 $LN173@gObjInvent

; 18341: 		{
; 18342: 			//   CharSet  .
; 18343: 			if( source < MAX_EQUIPMENT )

  018ed	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  018f1	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  018f4	0f 8d fe 00 00
	00		 jge	 $LN173@gObjInvent

; 18344: 			{
; 18345: 				if( lpObj->pInventory[source].IsItem()== TRUE)

  018fa	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  018fe	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  01904	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01907	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0190d	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  01912	83 f8 01	 cmp	 eax, 1
  01915	75 7c		 jne	 SHORT $LN174@gObjInvent

; 18346: 				{
; 18347: 					if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM(13,10) )

  01917	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  0191b	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  01921	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01924	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0192a	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0192f	6a 0a		 push	 10			; 0000000aH
  01931	6a 0d		 push	 13			; 0000000dH
  01933	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01938	83 c4 08	 add	 esp, 8
  0193b	3b f0		 cmp	 esi, eax
  0193d	75 52		 jne	 SHORT $LN176@gObjInvent

; 18348: 					{
; 18349: 						gObjUseSkill.SkillChangeUse(aIndex);

  0193f	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01942	50		 push	 eax
  01943	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  01948	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 18350: 						LogAdd(lMsg.Get(534), gObj[aIndex].Name, lpObj->pInventory[source].m_Level);

  0194d	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01951	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  01957	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0195a	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  01960	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  01965	51		 push	 ecx
  01966	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0196d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01972	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  01976	51		 push	 ecx
  01977	68 16 02 00 00	 push	 534			; 00000216H
  0197c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01981	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  01987	50		 push	 eax
  01988	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0198e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN176@gObjInvent:

; 18351: 					}
; 18352: #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	//   
; 18353: 					if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 39 ) )
; 18354: 					{
; 18355: 						gObjUseSkill.SkillChangeUse( aIndex );
; 18356: 						LogAdd( lMsg.Get( 534 ), gObj[aIndex].Name, lpObj->pInventory[source].m_Level );
; 18357: 					}
; 18358: #endif
; 18359: 					
; 18360: #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 18361: 					if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 40 ) )
; 18362: 					{
; 18363: 						gObjUseSkill.SkillChangeUse( aIndex );
; 18364: 						LogAdd( lMsg.Get( 534 ), gObj[aIndex].Name, lpObj->pInventory[source].m_Level );
; 18365: 					}
; 18366: #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 18367: 
; 18368: #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 18369: 					if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 41 ) )
; 18370: 					{
; 18371: 						gObjUseSkill.SkillChangeUse( aIndex );
; 18372: 						LogAdd( lMsg.Get( 534 ), gObj[aIndex].Name, lpObj->pInventory[source].m_Level );
; 18373: 					}
; 18374: #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 18375: #ifdef MODIFY_SNOW_MAN_PANDA_POLYMORPH_RING_BUGFIX_20090715
; 18376: 					if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 68 ) )
; 18377: 					{
; 18378: 						gObjUseSkill.SkillChangeUse( aIndex );
; 18379: 						LogAdd( lMsg.Get( 534 ), gObj[aIndex].Name, lpObj->pInventory[source].m_Level );
; 18380: 					}
; 18381: 					if( lpObj->pInventory[source].m_Type == MAKE_ITEMNUM( 13, 76 ) )
; 18382: 					{
; 18383: 						gObjUseSkill.SkillChangeUse( aIndex );
; 18384: 						LogAdd( lMsg.Get( 534 ), gObj[aIndex].Name, lpObj->pInventory[source].m_Level );
; 18385: 					}
; 18386: #endif // MODIFY_SNOW_MAN_PANDA_POLYMORPH_RING_BUGFIX_20090715
; 18387: 				}

  01991	eb 48		 jmp	 SHORT $LN179@gObjInvent
$LN174@gObjInvent:

; 18388: 				else if( source == EQUIPMENT_RING_RIGHT || source == EQUIPMENT_RING_LEFT)

  01993	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  01997	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0199a	74 09		 je	 SHORT $LN178@gObjInvent
  0199c	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  019a0	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  019a3	75 36		 jne	 SHORT $LN179@gObjInvent
$LN178@gObjInvent:

; 18389: 				{
; 18390: 					if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(13,10) )

  019a5	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  019a9	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  019af	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  019b2	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  019b8	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  019bd	6a 0a		 push	 10			; 0000000aH
  019bf	6a 0d		 push	 13			; 0000000dH
  019c1	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  019c6	83 c4 08	 add	 esp, 8
  019c9	3b f0		 cmp	 esi, eax
  019cb	75 0e		 jne	 SHORT $LN179@gObjInvent

; 18391: 					{
; 18392: 						gObjUseSkill.SkillChangeUse(aIndex);

  019cd	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  019d0	50		 push	 eax
  019d1	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  019d6	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse
$LN179@gObjInvent:

; 18393: 					}
; 18394: #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	//   
; 18395: 					if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 39 ) )
; 18396: 					{
; 18397: 						gObjUseSkill.SkillChangeUse( aIndex );
; 18398: 					}
; 18399: #endif
; 18400: 
; 18401: #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 18402: 					if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 40 ) )
; 18403: 					{
; 18404: 						gObjUseSkill.SkillChangeUse( aIndex );
; 18405: 					}
; 18406: #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 18407: 
; 18408: #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 18409: 					if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 41 ) )
; 18410: 					{
; 18411: 						gObjUseSkill.SkillChangeUse( aIndex );
; 18412: 					}
; 18413: #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 18414: 
; 18415: #ifdef UPDATE_GM_FUNCTION_20070228
; 18416: 					if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 42 ) )
; 18417: 					{
; 18418: 						gObjUseSkill.SkillChangeUse( aIndex );
; 18419: 						LogAdd( lMsg.Get( 534 ), gObj[aIndex].Name, lpObj->pInventory[target].m_Level );
; 18420: 					}
; 18421: #endif // UPDATE_GM_FUNCTION_20070228	
; 18422: //------------->
; 18423: //20081013    - (grooving)
; 18424: #ifdef ADD_XMASEVENT_POLYMORPH_RING_20080930
; 18425: 					if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 68 ) )
; 18426: 					{
; 18427: 						gObjUseSkill.SkillChangeUse( aIndex );
; 18428: 						LogAdd( lMsg.Get( 534 ), gObj[aIndex].Name, lpObj->pInventory[target].m_Level );
; 18429: 					}
; 18430: #endif // ADD_XMASEVENT_POLYMORPH_RING_20080930
; 18431: //<-------------
; 18432: #ifdef ADD_PREMIUMITEM_PANDA
; 18433: 					if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 76 ) )
; 18434: 					{
; 18435: 						gObjUseSkill.SkillChangeUse( aIndex );
; 18436: 						LogAdd( lMsg.Get( 534 ), gObj[aIndex].Name, lpObj->pInventory[target].m_Level );
; 18437: 					}
; 18438: #endif // ADD_PREMIUMITEM_PANDA
; 18439: 				}
; 18440: 				gObjMakePreviewCharSet(aIndex);

  019db	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  019de	50		 push	 eax
  019df	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  019e4	83 c4 04	 add	 esp, 4

; 18441: 				GCEquipmentChange(aIndex, source);

  019e7	0f b6 45 0c	 movzx	 eax, BYTE PTR _source$[ebp]
  019eb	50		 push	 eax
  019ec	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  019ef	51		 push	 ecx
  019f0	e8 00 00 00 00	 call	 ?GCEquipmentChange@@YAXHH@Z ; GCEquipmentChange
  019f5	83 c4 08	 add	 esp, 8
$LN173@gObjInvent:

; 18442: 			}
; 18443: 		}
; 18444: 
; 18445: 		if( tFlag == ITEMMOVE_INVENTORY )

  019f8	0f b6 45 20	 movzx	 eax, BYTE PTR _tFlag$[ebp]
  019fc	85 c0		 test	 eax, eax
  019fe	0f 85 a4 00 00
	00		 jne	 $LN181@gObjInvent

; 18446: 		{
; 18447: 			//   CharSet  .
; 18448: 			if( target < MAX_EQUIPMENT )

  01a04	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  01a08	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  01a0b	0f 8d 97 00 00
	00		 jge	 $LN181@gObjInvent

; 18449: 			{
; 18450: 				if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM(13,10) )

  01a11	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  01a15	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  01a1b	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01a1e	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  01a24	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  01a29	6a 0a		 push	 10			; 0000000aH
  01a2b	6a 0d		 push	 13			; 0000000dH
  01a2d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  01a32	83 c4 08	 add	 esp, 8
  01a35	3b f0		 cmp	 esi, eax
  01a37	75 52		 jne	 SHORT $LN182@gObjInvent

; 18451: 				{
; 18452: 					gObjUseSkill.SkillChangeUse(aIndex);

  01a39	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01a3c	50		 push	 eax
  01a3d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  01a42	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 18453: 					LogAdd(lMsg.Get(534), gObj[aIndex].Name, lpObj->pInventory[target].m_Level);

  01a47	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  01a4b	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  01a51	8b 55 e0	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01a54	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  01a5a	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  01a5f	51		 push	 ecx
  01a60	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  01a67	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01a6c	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  01a70	51		 push	 ecx
  01a71	68 16 02 00 00	 push	 534			; 00000216H
  01a76	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01a7b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  01a81	50		 push	 eax
  01a82	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  01a88	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN182@gObjInvent:

; 18454: 				}
; 18455: #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	//   
; 18456: 				if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 39 ) )
; 18457: 				{
; 18458: 					gObjUseSkill.SkillChangeUse( aIndex );
; 18459: 					LogAdd( lMsg.Get( 534 ), gObj[aIndex].Name, lpObj->pInventory[target].m_Level );
; 18460: 				}
; 18461: #endif
; 18462: #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 18463: 				if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 40 ) )
; 18464: 				{
; 18465: 					gObjUseSkill.SkillChangeUse( aIndex );
; 18466: 					LogAdd( lMsg.Get( 534 ), gObj[aIndex].Name, lpObj->pInventory[target].m_Level );
; 18467: 				}
; 18468: #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 18469: 
; 18470: #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 18471: 				if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 41 ) )
; 18472: 				{
; 18473: 					gObjUseSkill.SkillChangeUse( aIndex );
; 18474: 					LogAdd( lMsg.Get( 534 ), gObj[aIndex].Name, lpObj->pInventory[target].m_Level );
; 18475: 				}
; 18476: #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 18477: 
; 18478: #ifdef UPDATE_GM_FUNCTION_20070228	//     
; 18479: 				if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 42 ) )
; 18480: 				{
; 18481: 					gObjUseSkill.SkillChangeUse( aIndex );
; 18482: 					LogAdd( lMsg.Get( 534 ), gObj[aIndex].Name, lpObj->pInventory[target].m_Level );
; 18483: 				}
; 18484: #endif // UPDATE_GM_FUNCTION_20070228
; 18485: //------------->
; 18486: //20081013    - (grooving)
; 18487: #ifdef ADD_XMASEVENT_POLYMORPH_RING_20080930
; 18488: 				if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 68 ) )
; 18489: 				{
; 18490: 					gObjUseSkill.SkillChangeUse( aIndex );
; 18491: 					LogAdd( lMsg.Get( 534 ), gObj[aIndex].Name, lpObj->pInventory[target].m_Level );
; 18492: 				}
; 18493: #endif // ADD_XMASEVENT_POLYMORPH_RING_20080930
; 18494: //<-------------
; 18495: #ifdef ADD_PREMIUMITEM_PANDA
; 18496: 				if( lpObj->pInventory[target].m_Type == MAKE_ITEMNUM( 13, 76 ) )
; 18497: 				{
; 18498: 					gObjUseSkill.SkillChangeUse( aIndex );
; 18499: 					LogAdd( lMsg.Get( 534 ), gObj[aIndex].Name, lpObj->pInventory[target].m_Level );
; 18500: 				}
; 18501: #endif // ADD_PREMIUMITEM_PANDA
; 18502: 				gObjMakePreviewCharSet(aIndex);

  01a8b	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  01a8e	50		 push	 eax
  01a8f	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  01a94	83 c4 04	 add	 esp, 4

; 18503: 				GCEquipmentChange(aIndex, target);

  01a97	0f b6 45 10	 movzx	 eax, BYTE PTR _target$[ebp]
  01a9b	50		 push	 eax
  01a9c	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01a9f	51		 push	 ecx
  01aa0	e8 00 00 00 00	 call	 ?GCEquipmentChange@@YAXHH@Z ; GCEquipmentChange
  01aa5	83 c4 08	 add	 esp, 8
$LN181@gObjInvent:

; 18504: 			}
; 18505: 		}
; 18506: 		
; 18507: 		//if( target < MAX_EQUIPMENT ) GCEquipmentChange(aIndex, target);
; 18508: 		//if( source < MAX_EQUIPMENT ) GCEquipmentChange(aIndex, source);
; 18509: 
; 18510: 	}

  01aa8	9b		 fwait
  01aa9	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  01ab0	e8 02 00 00 00	 call	 $LN188@gObjInvent
  01ab5	eb 1f		 jmp	 SHORT $LN189@gObjInvent
$LN186@gObjInvent:
$LN196@gObjInvent:
$LN188@gObjInvent:

; 18511: 	__finally {
; 18512: #ifdef PERSONAL_SHOP_20040113
; 18513: 		if (bPersonalShopTrans == TRUE) {

  01ab7	83 bd 7c ff ff
	ff 01		 cmp	 DWORD PTR _bPersonalShopTrans$[ebp], 1
  01abe	75 15		 jne	 SHORT $LN187@gObjInvent

; 18514: 			//           .
; 18515: 			gObj[aIndex].m_bPShopTransaction = false;

  01ac0	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01ac7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  01acd	c6 84 01 f9 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3321], 0
$LN187@gObjInvent:
$LN195@gObjInvent:
  01ad5	c3		 ret	 0
$LN189@gObjInvent:

; 18516: 		}
; 18517: #endif
; 18518: 	}
; 18519: 
; 18520: 	return sp_ret;

  01ad6	8a 85 73 ff ff
	ff		 mov	 al, BYTE PTR _sp_ret$[ebp]

; 18521: }

  01adc	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  01adf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01ae6	59		 pop	 ecx
  01ae7	5f		 pop	 edi
  01ae8	5e		 pop	 esi
  01ae9	5b		 pop	 ebx
  01aea	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01aed	33 cd		 xor	 ecx, ebp
  01aef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01af4	8b e5		 mov	 esp, ebp
  01af6	5d		 pop	 ebp
  01af7	c3		 ret	 0
$LN190@gObjInvent:
  01af8	00 00 00 00	 DD	 $LN28@gObjInvent
  01afc	00 00 00 00	 DD	 $LN54@gObjInvent
  01b00	00 00 00 00	 DD	 $LN39@gObjInvent
  01b04	00 00 00 00	 DD	 $LN43@gObjInvent
  01b08	00 00 00 00	 DD	 $LN47@gObjInvent
  01b0c	00 00 00 00	 DD	 $LN43@gObjInvent
$LN191@gObjInvent:
  01b10	00 00 00 00	 DD	 $LN57@gObjInvent
  01b14	00 00 00 00	 DD	 $LN100@gObjInvent
  01b18	00 00 00 00	 DD	 $LN60@gObjInvent
  01b1c	00 00 00 00	 DD	 $LN63@gObjInvent
  01b20	00 00 00 00	 DD	 $LN88@gObjInvent
  01b24	00 00 00 00	 DD	 $LN63@gObjInvent
$LN192@gObjInvent:
  01b28	00 00 00 00	 DD	 $LN123@gObjInvent
  01b2c	00 00 00 00	 DD	 $LN8@gObjInvent
  01b30	00 00 00 00	 DD	 $LN147@gObjInvent
  01b34	00 00 00 00	 DD	 $LN161@gObjInvent
  01b38	00 00 00 00	 DD	 $LN123@gObjInvent
  01b3c	00 00 00 00	 DD	 $LN161@gObjInvent
$LN193@gObjInvent:
  01b40	00 00 00 00	 DD	 $LN140@gObjInvent
  01b44	00 00 00 00	 DD	 $LN12@gObjInvent
  01b48	00 00 00 00	 DD	 $LN141@gObjInvent
  01b4c	00 00 00 00	 DD	 $LN142@gObjInvent
  01b50	00 00 00 00	 DD	 $LN140@gObjInvent
  01b54	00 00 00 00	 DD	 $LN142@gObjInvent
?gObjInventoryMoveItem@@YAEHEEAAH0EEPAE@Z ENDP		; gObjInventoryMoveItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjTradeOkButton@@YAXH@Z
_TEXT	SEGMENT
_n$1 = -12						; size = 4
_number$ = -8						; size = 4
_result$ = -1						; size = 1
_aIndex$ = 8						; size = 4
?gObjTradeOkButton@@YAXH@Z PROC				; gObjTradeOkButton, COMDAT

; 19430: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19431: 	BYTE result=0x01;

  00009	c6 45 ff 01	 mov	 BYTE PTR _result$[ebp], 1

; 19432: 
; 19433: 	int number = gObj[aIndex].TargetNumber;

  0000d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0001a	0f bf 94 01 ac
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+684]
  00022	89 55 f8	 mov	 DWORD PTR _number$[ebp], edx

; 19434: 	if( number < 0 ) 

  00025	83 7d f8 00	 cmp	 DWORD PTR _number$[ebp], 0
  00029	7d 05		 jge	 SHORT $LN5@gObjTradeO

; 19435: 	{
; 19436: 		return;

  0002b	e9 13 06 00 00	 jmp	 $LN1@gObjTradeO
$LN5@gObjTradeO:

; 19437: 	}
; 19438: 	if( gObjIsConnected(number) == FALSE ) return;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00039	83 c4 04	 add	 esp, 4
  0003c	85 c0		 test	 eax, eax
  0003e	75 05		 jne	 SHORT $LN6@gObjTradeO
  00040	e9 fe 05 00 00	 jmp	 $LN1@gObjTradeO
$LN6@gObjTradeO:

; 19439: 
; 19440: 	if( gObj[number].TargetNumber != aIndex )

  00045	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00052	0f bf 94 01 ac
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+684]
  0005a	3b 55 08	 cmp	 edx, DWORD PTR _aIndex$[ebp]
  0005d	74 6f		 je	 SHORT $LN7@gObjTradeO

; 19441: 	{
; 19442: 		LogAdd(lMsg.Get(539), gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[number].TargetNumber, gObj[number].TargetNumber);

  0005f	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006c	0f bf 94 01 ac
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+684]
  00074	52		 push	 edx
  00075	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00082	0f bf 94 01 ac
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+684]
  0008a	52		 push	 edx
  0008b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00092	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00098	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0009c	52		 push	 edx
  0009d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000aa	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000ae	52		 push	 edx
  000af	68 1b 02 00 00	 push	 539			; 0000021bH
  000b4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000bf	50		 push	 eax
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000c6	83 c4 14	 add	 esp, 20			; 00000014H

; 19443: 		return;

  000c9	e9 75 05 00 00	 jmp	 $LN1@gObjTradeO
$LN7@gObjTradeO:

; 19444: 	}
; 19445: 
; 19446: 	//    OK .. 
; 19447: 	if( gObj[aIndex].TradeOk != 1 || gObj[number].TradeOk != 1 )

  000ce	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000db	0f b6 94 01 90
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3216]
  000e3	83 fa 01	 cmp	 edx, 1
  000e6	75 1a		 jne	 SHORT $LN9@gObjTradeO
  000e8	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  000ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f5	0f b6 94 01 90
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3216]
  000fd	83 fa 01	 cmp	 edx, 1
  00100	74 05		 je	 SHORT $LN8@gObjTradeO
$LN9@gObjTradeO:

; 19448: 	{
; 19449: 		return;

  00102	e9 3c 05 00 00	 jmp	 $LN1@gObjTradeO
$LN8@gObjTradeO:

; 19450: 	}
; 19451: 
; 19452: 	if( TradeItemInventoryPutTest(aIndex) == TRUE )

  00107	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 ?TradeItemInventoryPutTest@@YAHH@Z ; TradeItemInventoryPutTest
  00110	83 c4 04	 add	 esp, 4
  00113	83 f8 01	 cmp	 eax, 1
  00116	75 1d		 jne	 SHORT $LN10@gObjTradeO

; 19453: 	{
; 19454: 		if( TradeItemInventoryPutTest(number) == TRUE )

  00118	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ?TradeItemInventoryPutTest@@YAHH@Z ; TradeItemInventoryPutTest
  00121	83 c4 04	 add	 esp, 4
  00124	83 f8 01	 cmp	 eax, 1
  00127	75 06		 jne	 SHORT $LN12@gObjTradeO

; 19455: 		{			
; 19456: 			result = 0x01;

  00129	c6 45 ff 01	 mov	 BYTE PTR _result$[ebp], 1

; 19457: 		}

  0012d	eb 04		 jmp	 SHORT $LN13@gObjTradeO
$LN12@gObjTradeO:

; 19458: 		else result = 0x02;

  0012f	c6 45 ff 02	 mov	 BYTE PTR _result$[ebp], 2
$LN13@gObjTradeO:

; 19459: 	}

  00133	eb 04		 jmp	 SHORT $LN11@gObjTradeO
$LN10@gObjTradeO:

; 19460: 	else result = 0x02;

  00135	c6 45 ff 02	 mov	 BYTE PTR _result$[ebp], 2
$LN11@gObjTradeO:

; 19461: 
; 19462: #ifdef MODIFY_ZEN_MAX_20040414
; 19463: 	//  MAX  !
; 19464: 	if( !gObjCheckMaxZen( aIndex, gObj[number].TradeMoney ) )

  00139	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00146	8b 94 01 8c 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3212]
  0014d	52		 push	 edx
  0014e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  00157	83 c4 08	 add	 esp, 8
  0015a	85 c0		 test	 eax, eax
  0015c	75 04		 jne	 SHORT $LN14@gObjTradeO

; 19465: 	{
; 19466: 		result = 0x02;

  0015e	c6 45 ff 02	 mov	 BYTE PTR _result$[ebp], 2
$LN14@gObjTradeO:

; 19467: 	}
; 19468: 
; 19469: 	if( !gObjCheckMaxZen( number, gObj[aIndex].TradeMoney ) )

  00162	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00169	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016f	8b 94 01 8c 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3212]
  00176	52		 push	 edx
  00177	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  0017a	50		 push	 eax
  0017b	e8 00 00 00 00	 call	 ?gObjCheckMaxZen@@YAHHH@Z ; gObjCheckMaxZen
  00180	83 c4 08	 add	 esp, 8
  00183	85 c0		 test	 eax, eax
  00185	75 04		 jne	 SHORT $LN15@gObjTradeO

; 19470: 	{
; 19471: 		result = 0x02;

  00187	c6 45 ff 02	 mov	 BYTE PTR _result$[ebp], 2
$LN15@gObjTradeO:

; 19472: 	}
; 19473: #endif
; 19474: 
; 19475: #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 19476: 	//     .
; 19477: 	if ( g_kJewelOfHarmonySystem.IsEnableToTrade( &gObj[number] ) == FALSE 
; 19478: 		|| g_kJewelOfHarmonySystem.IsEnableToTrade( &gObj[aIndex] ) == FALSE )
; 19479: 	{
; 19480: 		result = 0x04;				//      0x04
; 19481: 		gObjTradeCancel(aIndex);
; 19482: 		gObjTradeCancel(number);
; 19483: 		CGTradeResult(aIndex, result);
; 19484: 		CGTradeResult(number, result);
; 19485: 		return;
; 19486: 	}
; 19487: #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 19488: 	
; 19489: 	//   
; 19490: 	if( result == 0x01 )

  0018b	0f b6 45 ff	 movzx	 eax, BYTE PTR _result$[ebp]
  0018f	83 f8 01	 cmp	 eax, 1
  00192	0f 85 5c 02 00
	00		 jne	 $LN16@gObjTradeO

; 19491: 	{
; 19492: 		TradeitemInventoryPut(aIndex);

  00198	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ?TradeitemInventoryPut@@YAHH@Z ; TradeitemInventoryPut
  001a1	83 c4 04	 add	 esp, 4

; 19493: 		TradeitemInventoryPut(number);

  001a4	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 ?TradeitemInventoryPut@@YAHH@Z ; TradeitemInventoryPut
  001ad	83 c4 04	 add	 esp, 4

; 19494: 		gObjInventoryCommit(aIndex);

  001b0	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001b3	50		 push	 eax
  001b4	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  001b9	83 c4 04	 add	 esp, 4

; 19495: 		gObjInventoryCommit(number);

  001bc	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  001c5	83 c4 04	 add	 esp, 4

; 19496: 
; 19497: 		gObjMakePreviewCharSet(aIndex);

  001c8	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001cb	50		 push	 eax
  001cc	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  001d1	83 c4 04	 add	 esp, 4

; 19498: 		gObjMakePreviewCharSet(number);

  001d4	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  001dd	83 c4 04	 add	 esp, 4

; 19499: 
; 19500: 		gObj[aIndex].Money -= gObj[aIndex].TradeMoney;

  001e0	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001e7	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001ee	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001fa	8b 84 02 b0 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+176]
  00201	2b 84 0e 8c 0c
	00 00		 sub	 eax, DWORD PTR [esi+ecx+3212]
  00208	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0020f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00215	89 84 0a b0 00
	00 00		 mov	 DWORD PTR [edx+ecx+176], eax

; 19501: 		if( gObj[aIndex].Money < 0 ) gObj[aIndex].Money = 0;

  0021c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00223	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00229	83 bc 01 b0 00
	00 00 00	 cmp	 DWORD PTR [ecx+eax+176], 0
  00231	7d 18		 jge	 SHORT $LN18@gObjTradeO
  00233	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0023a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00240	c7 84 01 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+176], 0
$LN18@gObjTradeO:

; 19502: 		gObj[number].Money -= gObj[number].TradeMoney;

  0024b	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00252	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  00259	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0025f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00265	8b 84 02 b0 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+176]
  0026c	2b 84 0e 8c 0c
	00 00		 sub	 eax, DWORD PTR [esi+ecx+3212]
  00273	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  0027a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00280	89 84 0a b0 00
	00 00		 mov	 DWORD PTR [edx+ecx+176], eax

; 19503: 		if( gObj[number].Money < 0 ) gObj[number].Money = 0;

  00287	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0028e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00294	83 bc 01 b0 00
	00 00 00	 cmp	 DWORD PTR [ecx+eax+176], 0
  0029c	7d 18		 jge	 SHORT $LN19@gObjTradeO
  0029e	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  002a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ab	c7 84 01 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+176], 0
$LN19@gObjTradeO:

; 19504: 		gObj[aIndex].Money += gObj[number].TradeMoney;

  002b6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002bd	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  002c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ca	8b 84 02 b0 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+176]
  002d1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002d7	03 84 0a 8c 0c
	00 00		 add	 eax, DWORD PTR [edx+ecx+3212]
  002de	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  002e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002eb	89 84 0a b0 00
	00 00		 mov	 DWORD PTR [edx+ecx+176], eax

; 19505: 		gObj[number].Money += gObj[aIndex].TradeMoney;

  002f2	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  002f9	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00300	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00306	8b 84 02 b0 00
	00 00		 mov	 eax, DWORD PTR [edx+eax+176]
  0030d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00313	03 84 0a 8c 0c
	00 00		 add	 eax, DWORD PTR [edx+ecx+3212]
  0031a	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  00321	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00327	89 84 0a b0 00
	00 00		 mov	 DWORD PTR [edx+ecx+176], eax

; 19506: 		LogAddTD(lMsg.Get(540), gObj[aIndex].AccountID,gObj[aIndex].Name, gObj[number].AccountID, gObj[number].Name, gObj[aIndex].TradeMoney, gObj[number].TradeMoney);

  0032e	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00335	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0033b	8b 94 01 8c 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3212]
  00342	52		 push	 edx
  00343	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0034a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00350	8b 94 01 8c 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3212]
  00357	52		 push	 edx
  00358	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  0035f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00365	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00369	52		 push	 edx
  0036a	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00371	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00377	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0037b	52		 push	 edx
  0037c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00383	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00389	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0038d	52		 push	 edx
  0038e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00395	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0039b	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0039f	52		 push	 edx
  003a0	68 1c 02 00 00	 push	 540			; 0000021cH
  003a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  003b0	50		 push	 eax
  003b1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003b7	83 c4 1c	 add	 esp, 28			; 0000001cH

; 19507: 		GJSetCharacterInfo(&gObj[aIndex], aIndex);

  003ba	6a 00		 push	 0
  003bc	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003bf	50		 push	 eax
  003c0	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  003c7	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003cd	51		 push	 ecx
  003ce	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAVOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo
  003d3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19508: 		GJSetCharacterInfo(&gObj[number], number);

  003d6	6a 00		 push	 0
  003d8	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  003db	50		 push	 eax
  003dc	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _number$[ebp], 7072
  003e3	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003e9	51		 push	 ecx
  003ea	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAVOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo
  003ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19509: 	}

  003f2	eb 43		 jmp	 SHORT $LN17@gObjTradeO
$LN16@gObjTradeO:

; 19510: 	else {
; 19511: 		result = 0x02;

  003f4	c6 45 ff 02	 mov	 BYTE PTR _result$[ebp], 2

; 19512: 		gObjTradeCancel(aIndex);

  003f8	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003fb	50		 push	 eax
  003fc	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel
  00401	83 c4 04	 add	 esp, 4

; 19513: 		gObjTradeCancel(number);

  00404	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  00407	50		 push	 eax
  00408	e8 00 00 00 00	 call	 ?gObjTradeCancel@@YAXH@Z ; gObjTradeCancel
  0040d	83 c4 04	 add	 esp, 4

; 19514: 		CGTradeResult(aIndex, result);

  00410	0f b6 45 ff	 movzx	 eax, BYTE PTR _result$[ebp]
  00414	50		 push	 eax
  00415	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00418	51		 push	 ecx
  00419	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  0041e	83 c4 08	 add	 esp, 8

; 19515: 		CGTradeResult(number, result);

  00421	0f b6 45 ff	 movzx	 eax, BYTE PTR _result$[ebp]
  00425	50		 push	 eax
  00426	8b 4d f8	 mov	 ecx, DWORD PTR _number$[ebp]
  00429	51		 push	 ecx
  0042a	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  0042f	83 c4 08	 add	 esp, 8

; 19516: 		return;

  00432	e9 0c 02 00 00	 jmp	 $LN1@gObjTradeO
$LN17@gObjTradeO:

; 19517: 	}
; 19518: 
; 19519: 	gObj[aIndex].TargetNumber  = -1;

  00437	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0043e	83 c9 ff	 or	 ecx, -1
  00441	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00447	66 89 8c 02 ac
	02 00 00	 mov	 WORD PTR [edx+eax+684], cx

; 19520: 	gObj[aIndex].m_IfState.use = 0;

  0044f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00456	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0045c	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00463	80 e2 fc	 and	 dl, 252			; 000000fcH
  00466	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0046d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00473	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 19521: 	gObj[number].TargetNumber  = -1;

  0047a	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00481	83 c9 ff	 or	 ecx, -1
  00484	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0048a	66 89 8c 02 ac
	02 00 00	 mov	 WORD PTR [edx+eax+684], cx

; 19522: 	gObj[number].m_IfState.use = 0;

  00492	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00499	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0049f	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  004a6	80 e2 fc	 and	 dl, 252			; 000000fcH
  004a9	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  004b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004b6	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 19523: 	gObj[aIndex].TradeOk = 0;

  004bd	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  004c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004ca	c6 84 01 90 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3216], 0

; 19524: 	gObj[number].TradeOk = 0;

  004d2	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  004d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004df	c6 84 01 90 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3216], 0

; 19525: 	gObj[aIndex].TradeMoney = 0;

  004e7	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  004ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004f4	c7 84 01 8c 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+3212], 0

; 19526: 	gObj[number].TradeMoney = 0;

  004ff	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00506	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0050c	c7 84 01 8c 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+3212], 0

; 19527: 
; 19528: #ifdef MODIFY_SOCKET_CHAOSMIX_ITEM_MOVE_BUGFIX_200801021
; 19529: 	gObj[aIndex].m_IfState.state = 0;

  00517	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0051e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00524	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0052b	80 e2 f3	 and	 dl, 243			; 000000f3H
  0052e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00535	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0053b	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 19530: 	gObj[number].m_IfState.state = 0;

  00542	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00549	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0054f	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00556	80 e2 f3	 and	 dl, 243			; 000000f3H
  00559	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00560	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00566	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 19531: #endif	// MODIFY_SOCKET_CHAOSMIX_ITEM_MOVE_BUGFIX_200801021
; 19532: 
; 19533: 	GCMoneySend(aIndex, gObj[aIndex].Money);

  0056d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00574	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0057a	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  00581	52		 push	 edx
  00582	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00585	50		 push	 eax
  00586	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0058b	83 c4 08	 add	 esp, 8

; 19534: 	GCMoneySend(number, gObj[number].Money);

  0058e	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00595	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0059b	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  005a2	52		 push	 edx
  005a3	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  005a6	50		 push	 eax
  005a7	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  005ac	83 c4 08	 add	 esp, 8

; 19535: 
; 19536: 	CGTradeResult(aIndex, result);

  005af	0f b6 45 ff	 movzx	 eax, BYTE PTR _result$[ebp]
  005b3	50		 push	 eax
  005b4	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  005b7	51		 push	 ecx
  005b8	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  005bd	83 c4 08	 add	 esp, 8

; 19537: 	CGTradeResult(number, result);

  005c0	0f b6 45 ff	 movzx	 eax, BYTE PTR _result$[ebp]
  005c4	50		 push	 eax
  005c5	8b 4d f8	 mov	 ecx, DWORD PTR _number$[ebp]
  005c8	51		 push	 ecx
  005c9	e8 00 00 00 00	 call	 ?CGTradeResult@@YAXHE@Z	; CGTradeResult
  005ce	83 c4 08	 add	 esp, 8

; 19538: 
; 19539: 	GCItemListSend(aIndex);

  005d1	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  005d4	50		 push	 eax
  005d5	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend
  005da	83 c4 04	 add	 esp, 4

; 19540: 	GCItemListSend(number);

  005dd	8b 45 f8	 mov	 eax, DWORD PTR _number$[ebp]
  005e0	50		 push	 eax
  005e1	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend
  005e6	83 c4 04	 add	 esp, 4

; 19541: 	
; 19542: 	for( int n=0; n<MAX_TRADEITEM; n++)

  005e9	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  005f0	eb 09		 jmp	 SHORT $LN4@gObjTradeO
$LN2@gObjTradeO:
  005f2	8b 45 f4	 mov	 eax, DWORD PTR _n$1[ebp]
  005f5	83 c0 01	 add	 eax, 1
  005f8	89 45 f4	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjTradeO:
  005fb	83 7d f4 20	 cmp	 DWORD PTR _n$1[ebp], 32	; 00000020H
  005ff	7d 42		 jge	 SHORT $LN1@gObjTradeO

; 19543: 	{
; 19544: 		gObj[aIndex].Trade[n].Clear();

  00601	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00608	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  0060f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00615	03 8c 02 84 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3204]
  0061c	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 19545: 		gObj[number].Trade[n].Clear();

  00621	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$[ebp], 7072
  00628	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  0062f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00635	03 8c 02 84 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3204]
  0063c	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 19546: 	}

  00641	eb af		 jmp	 SHORT $LN2@gObjTradeO
$LN1@gObjTradeO:

; 19547: 
; 19548: #ifdef MODIFY_NEW_UNION_02_20041201
; 19549: 	gObjNotifyUpdateUnionV1( &gObj[aIndex] );
; 19550: 	gObjNotifyUpdateUnionV2( &gObj[aIndex] );
; 19551: #endif
; 19552: 	
; 19553: }

  00643	5f		 pop	 edi
  00644	5e		 pop	 esi
  00645	5b		 pop	 ebx
  00646	8b e5		 mov	 esp, ebp
  00648	5d		 pop	 ebp
  00649	c3		 ret	 0
?gObjTradeOkButton@@YAXH@Z ENDP				; gObjTradeOkButton
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjTradeCancel@@YAXH@Z
_TEXT	SEGMENT
tv66 = -72						; size = 4
tv67 = -68						; size = 4
_aIndex$ = 8						; size = 4
?gObjTradeCancel@@YAXH@Z PROC				; gObjTradeCancel, COMDAT

; 19173: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19174: 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT)  )

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN11@gObjTradeC
  0000f	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN12@gObjTradeC
$LN11@gObjTradeC:
  00018	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN9@gObjTradeC
  00021	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN10@gObjTradeC
$LN9@gObjTradeC:
  0002a	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN10@gObjTradeC:
  00031	8b 45 b8	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 bc	 mov	 DWORD PTR tv67[ebp], eax
$LN12@gObjTradeC:
  00037	83 7d bc 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 21		 jne	 SHORT $LN2@gObjTradeC

; 19175: 	{
; 19176: 		LogAdd("error : index error %s %d",__FILE__, __LINE__);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjTradeCancel@@YAXH@Z@4JA
  00042	83 c0 03	 add	 eax, 3
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CICIFNII@error?5?3?5index?5error?5?$CFs?5?$CFd@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19177: 		return;

  00059	e9 60 02 00 00	 jmp	 $LN1@gObjTradeC
$LN2@gObjTradeC:

; 19178: 	}
; 19179: 	//   ..  ..
; 19180: 	if( gObj[aIndex].Type != OBJTYPE_CHARACTER || gObj[aIndex].Connected != CSS_GAMEPLAYING ) 

  0005e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006b	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00070	83 fa 01	 cmp	 edx, 1
  00073	75 14		 jne	 SHORT $LN4@gObjTradeC
  00075	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00082	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00087	74 43		 je	 SHORT $LN3@gObjTradeC
$LN4@gObjTradeC:

; 19181: 	{
; 19182: 		LogAdd(lMsg.Get(535), gObj[aIndex].AccountID, gObj[aIndex].Name);

  00089	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00090	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00096	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0009a	52		 push	 edx
  0009b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a8	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000ac	52		 push	 edx
  000ad	68 17 02 00 00	 push	 535			; 00000217H
  000b2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000bd	50		 push	 eax
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19183: 		return ;

  000c7	e9 f2 01 00 00	 jmp	 $LN1@gObjTradeC
$LN3@gObjTradeC:

; 19184: 	}	
; 19185: 	
; 19186: #ifndef TRADE_SKILLBUG_FIX
; 19187: 	gObjInventoryRollback(aIndex);
; 19188: #endif
; 19189: 
; 19190: 	if( gObj[aIndex].m_IfState.use != 1 ) 

  000cc	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d9	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  000e0	80 e2 03	 and	 dl, 3
  000e3	0f b6 c2	 movzx	 eax, dl
  000e6	83 f8 01	 cmp	 eax, 1
  000e9	74 43		 je	 SHORT $LN5@gObjTradeC

; 19191: 	{
; 19192: 		LogAdd(lMsg.Get(536), gObj[aIndex].AccountID, gObj[aIndex].Name);

  000eb	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f8	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000fc	52		 push	 edx
  000fd	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00104	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010a	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0010e	52		 push	 edx
  0010f	68 18 02 00 00	 push	 536			; 00000218H
  00114	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0011f	50		 push	 eax
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00126	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19193: 		//  Cancel  [1]   [%s][%s]
; 19194: 		//    ..     .
; 19195: 		return;

  00129	e9 90 01 00 00	 jmp	 $LN1@gObjTradeC
$LN5@gObjTradeC:

; 19196: 	}
; 19197: 	if( gObj[aIndex].m_IfState.type != I_TRADE ) 

  0012e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00135	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013b	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00142	c0 ea 04	 shr	 dl, 4
  00145	80 e2 0f	 and	 dl, 15			; 0000000fH
  00148	0f b6 c2	 movzx	 eax, dl
  0014b	83 f8 01	 cmp	 eax, 1
  0014e	74 43		 je	 SHORT $LN6@gObjTradeC

; 19198: 	{
; 19199: 		LogAdd(lMsg.Get(537),gObj[aIndex].AccountID, gObj[aIndex].Name);

  00150	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00157	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0015d	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00161	52		 push	 edx
  00162	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00169	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016f	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00173	52		 push	 edx
  00174	68 19 02 00 00	 push	 537			; 00000219H
  00179	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0017e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00184	50		 push	 eax
  00185	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0018b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19200: 		//  Cancel  [2]   [%s][%s]
; 19201: 		return;	//   ..

  0018e	e9 2b 01 00 00	 jmp	 $LN1@gObjTradeC
$LN6@gObjTradeC:

; 19202: 	}
; 19203: 
; 19204: #ifdef TRADE_SKILLBUG_FIX
; 19205: 	gObjInventoryRollback(aIndex);

  00193	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 ?gObjInventoryRollback@@YAHH@Z ; gObjInventoryRollback
  0019c	83 c4 04	 add	 esp, 4

; 19206: #endif
; 19207: 
; 19208: 	//   .
; 19209: 	gObj[aIndex].TargetNumber  = -1;

  0019f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001a6	83 c9 ff	 or	 ecx, -1
  001a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001af	66 89 8c 02 ac
	02 00 00	 mov	 WORD PTR [edx+eax+684], cx

; 19210: 	gObj[aIndex].m_IfState.use = 0;

  001b7	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c4	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  001cb	80 e2 fc	 and	 dl, 252			; 000000fcH
  001ce	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001db	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 19211: 
; 19212: #ifdef MODIFY_SOCKET_CHAOSMIX_ITEM_MOVE_BUGFIX_200801021
; 19213: 	gObj[aIndex].m_IfState.state = 0;

  001e2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ef	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  001f6	80 e2 f3	 and	 dl, 243			; 000000f3H
  001f9	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00200	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00206	88 94 01 56 0c
	00 00		 mov	 BYTE PTR [ecx+eax+3158], dl

; 19214: #endif	// MODIFY_SOCKET_CHAOSMIX_ITEM_MOVE_BUGFIX_200801021
; 19215: 	
; 19216: 	//int n;
; 19217: 	/*for( n=0; n<MAX_MAGIC; n++)
; 19218: 	{		
; 19219: 		gObj[aIndex].Magic[n] = gObj[aIndex].m_lpMagicBack[n];
; 19220: 	}
; 19221: 	*/
; 19222: 	gObjCharTradeClear(&gObj[aIndex]);

  0020d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00214	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0021a	50		 push	 eax
  0021b	e8 00 00 00 00	 call	 ?gObjCharTradeClear@@YAXPAVOBJECTSTRUCT@@@Z ; gObjCharTradeClear
  00220	83 c4 04	 add	 esp, 4

; 19223: 	//gObjSetInventory1Pointer(&gObj[aIndex]);
; 19224: 	GCMoneySend(aIndex, gObj[aIndex].Money);

  00223	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0022a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00230	8b 94 01 b0 00
	00 00		 mov	 edx, DWORD PTR [ecx+eax+176]
  00237	52		 push	 edx
  00238	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0023b	50		 push	 eax
  0023c	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  00241	83 c4 08	 add	 esp, 8

; 19225: 
; 19226: 	GCItemListSend(aIndex);

  00244	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 ?GCItemListSend@@YAXH@Z	; GCItemListSend
  0024d	83 c4 04	 add	 esp, 4

; 19227: 	GCEquipmentSend(aIndex);

  00250	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00253	50		 push	 eax
  00254	e8 00 00 00 00	 call	 ?GCEquipmentSend@@YAXH@Z ; GCEquipmentSend
  00259	83 c4 04	 add	 esp, 4

; 19228: 
; 19229: 	if( gObj[aIndex].Class == CLASS_KNIGHT )
; 19230: 	{
; 19231: 	}
; 19232: 
; 19233: 	GCMagicListMultiSend(&gObj[aIndex]);

  0025c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00263	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00269	50		 push	 eax
  0026a	e8 00 00 00 00	 call	 ?GCMagicListMultiSend@@YAXPAVOBJECTSTRUCT@@@Z ; GCMagicListMultiSend
  0026f	83 c4 04	 add	 esp, 4

; 19234: 	gObjUseSkill.SkillChangeUse(aIndex);

  00272	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00275	50		 push	 eax
  00276	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  0027b	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 19235: 
; 19236: #ifdef MODIFY_NEW_UNION_01_20041122
; 19237: 	//  ..
; 19238: 	if( gObj[aIndex].GuildNumber > 0 )
; 19239: 	{
; 19240: 		GCGuildViewportNowPaint( aIndex, gObj[aIndex].GuildName, NULL, FALSE);
; 19241: 
; 19242: #ifdef MODIFY_NEW_UNION_02_20041201
; 19243: 		gObjNotifyUpdateUnionV1( &gObj[aIndex] );
; 19244: 		gObjNotifyUpdateUnionV2( &gObj[aIndex] );
; 19245: #endif
; 19246: 		
; 19247: 	}
; 19248: #endif
; 19249: 
; 19250: 	LogAddTD(lMsg.Get(514),gObj[aIndex].AccountID, gObj[aIndex].Name);	// 

  00280	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00287	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0028d	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00291	52		 push	 edx
  00292	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00299	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0029f	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  002a3	52		 push	 edx
  002a4	68 02 02 00 00	 push	 514			; 00000202H
  002a9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002b4	50		 push	 eax
  002b5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002bb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjTradeC:

; 19251: }

  002be	5f		 pop	 edi
  002bf	5e		 pop	 esi
  002c0	5b		 pop	 ebx
  002c1	8b e5		 mov	 esp, ebp
  002c3	5d		 pop	 ebp
  002c4	c3		 ret	 0
?gObjTradeCancel@@YAXH@Z ENDP				; gObjTradeCancel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?MoveMonsterProc@@YAXXZ
_TEXT	SEGMENT
tv79 = -100						; size = 4
tv80 = -96						; size = 4
_attr$1 = -26						; size = 1
_mapnumber$2 = -25					; size = 1
_nextY$3 = -24						; size = 4
_nextX$4 = -20						; size = 4
_n$5 = -16						; size = 4
_lpObj$ = -12						; size = 4
_DelayTime$ = -8					; size = 4
_MoveTime$ = -4						; size = 4
?MoveMonsterProc@@YAXXZ PROC				; MoveMonsterProc, COMDAT

; 837  : {		

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 838  : 	DWORD MoveTime;
; 839  : 	int   DelayTime;
; 840  : 	LPOBJECTSTRUCT	lpObj;
; 841  : 	
; 842  : 	for( int n=0; n<MAX_OBJECT; n++)

  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$5[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@MoveMonste
$LN2@MoveMonste:
  00012	8b 45 f0	 mov	 eax, DWORD PTR _n$5[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 f0	 mov	 DWORD PTR _n$5[ebp], eax
$LN4@MoveMonste:
  0001b	81 7d f0 e8 1c
	00 00		 cmp	 DWORD PTR _n$5[ebp], 7400 ; 00001ce8H
  00022	0f 8d 29 04 00
	00		 jge	 $LN3@MoveMonste

; 843  : 	{		
; 844  : 		lpObj = (LPOBJECTSTRUCT)&gObj[n];

  00028	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$5[ebp], 7072
  0002f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00035	89 45 f4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 845  : 
; 846  : #ifdef ADD_NEW_MONSTER_SYSTEM_02_20050725
; 847  : 		// Monster AI    OBJECT     .
; 848  : 		//    100ms   .
; 849  : 		if( lpObj->m_iCurrentAI && (lpObj->Type==OBJTYPE_MONSTER||lpObj->Type==OBJTYPE_NPC) )
; 850  : 		{
; 851  : 			//TMonsterAI::MonsterMoveProc( n );
; 852  : 			continue;
; 853  : 		}
; 854  : #endif
; 855  : 		
; 856  : 		//   ..
; 857  : 		if( lpObj->Connected == CSS_GAMEPLAYING )

  00038	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003b	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  0003f	0f 85 07 04 00
	00		 jne	 $LN10@MoveMonste

; 858  : 		{
; 859  : #ifdef ADD_NEW_MAP_KALIMA_20040518
; 860  : 			if (lpObj->Type == OBJTYPE_MONSTER &&

  00045	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00048	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0004c	83 f9 02	 cmp	 ecx, 2
  0004f	75 6a		 jne	 SHORT $LN9@MoveMonste
  00051	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00054	0f bf 88 fe 02
	00 00		 movsx	 ecx, WORD PTR [eax+766]
  0005b	83 f9 33	 cmp	 ecx, 51			; 00000033H
  0005e	7d 09		 jge	 SHORT $LN33@MoveMonste
  00060	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  00067	eb 25		 jmp	 SHORT $LN34@MoveMonste
$LN33@MoveMonste:
  00069	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0006c	0f bf 82 fe 02
	00 00		 movsx	 eax, WORD PTR [edx+766]
  00073	83 f8 38	 cmp	 eax, 56			; 00000038H
  00076	7e 09		 jle	 SHORT $LN31@MoveMonste
  00078	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
  0007f	eb 07		 jmp	 SHORT $LN32@MoveMonste
$LN31@MoveMonste:
  00081	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
$LN32@MoveMonste:
  00088	8b 4d 9c	 mov	 ecx, DWORD PTR tv79[ebp]
  0008b	89 4d a0	 mov	 DWORD PTR tv80[ebp], ecx
$LN34@MoveMonste:
  0008e	83 7d a0 00	 cmp	 DWORD PTR tv80[ebp], 0
  00092	74 27		 je	 SHORT $LN9@MoveMonste

; 861  : 				(CHECK_KALIMAGATE(lpObj->m_Attribute)	//   .
; 862  : #ifdef CASTLE_MAIN_SCHEDULER_20041111					//   NPC    
; 863  : 				|| (lpObj->Class == 277)	// 
; 864  : 				|| (lpObj->Class == 283)	// 
; 865  : 				|| (lpObj->Class == 288)	// 
; 866  : 				|| (lpObj->Class == 278)	// 
; 867  : 				|| (lpObj->Class == 216)	// 
; 868  : 				|| (lpObj->Class == 217)	// 
; 869  : 				|| (lpObj->Class == 218)	// 
; 870  : 				|| (lpObj->Class == 219)	// 
; 871  : #endif
; 872  : 
; 873  : #ifdef CRYWOLF_NPC_WORK_20050912
; 874  : 				|| CHECK_CRYWOLF_NPC_ALTAR(lpObj->Class)		//  
; 875  : 				|| CHECK_CRYWOLF_NPC_STATUE(lpObj->Class)		//  
; 876  : #endif
; 877  : 				))
; 878  : 			{
; 879  : 				CreateFrustrum(lpObj->X,lpObj->Y, n);

  00094	8b 45 f0	 mov	 eax, DWORD PTR _n$5[ebp]
  00097	50		 push	 eax
  00098	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0009b	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  000a2	52		 push	 edx
  000a3	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a6	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  000ad	51		 push	 ecx
  000ae	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 880  : 				continue;

  000b6	e9 57 ff ff ff	 jmp	 $LN2@MoveMonste
$LN9@MoveMonste:

; 881  : 			}
; 882  : #endif
; 883  : 
; 884  : 			if( lpObj->m_State == OBJST_PLAYING )

  000bb	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000be	83 b8 b8 01 00
	00 02		 cmp	 DWORD PTR [eax+440], 2
  000c5	0f 85 81 03 00
	00		 jne	 $LN10@MoveMonste

; 885  : 			{
; 886  : 				
; 887  : #ifdef ADD_NEW_SKILL_FOR_CASTLE_02_20050531
; 888  : 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 889  : 				if( lpObj->PathCount != 0 &&
; 890  : 					( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_STONE ) == false ) &&
; 891  : 					( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_STUN ) == false )
; 892  : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 893  : 					&& ( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_SLEEP ) == false )
; 894  : #endif					
; 895  : 				  )
; 896  : 	#else
; 897  : 				if( lpObj->PathCount && !lpObj->m_SkillHarden && !lpObj->m_iSkillStunTime)
; 898  : 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 899  : #else
; 900  : 
; 901  : 	#ifdef NEW_SKILL_FORSKYLAND
; 902  : 				if( lpObj->PathCount && !lpObj->m_SkillHarden )

  000cb	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ce	83 b8 28 01 00
	00 00		 cmp	 DWORD PTR [eax+296], 0
  000d5	0f 84 4f 03 00
	00		 je	 $LN28@MoveMonste
  000db	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000de	83 b8 fc 19 00
	00 00		 cmp	 DWORD PTR [eax+6652], 0
  000e5	0f 85 3f 03 00
	00		 jne	 $LN28@MoveMonste

; 903  : 	#else
; 904  : 				if( lpObj->PathCount )
; 905  : 	#endif
; 906  : 
; 907  : #endif
; 908  : 				{
; 909  : 					//      480ms
; 910  : 					if( lpObj->DelayLevel )

  000eb	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ee	0f be 88 20 02
	00 00		 movsx	 ecx, BYTE PTR [eax+544]
  000f5	85 c9		 test	 ecx, ecx
  000f7	74 09		 je	 SHORT $LN12@MoveMonste

; 911  : 					{
; 912  : 						DelayTime = 300;

  000f9	c7 45 f8 2c 01
	00 00		 mov	 DWORD PTR _DelayTime$[ebp], 300 ; 0000012cH

; 913  : 					}

  00100	eb 07		 jmp	 SHORT $LN13@MoveMonste
$LN12@MoveMonste:

; 914  : 					else DelayTime = 0;

  00102	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _DelayTime$[ebp], 0
$LN13@MoveMonste:

; 915  : 					
; 916  : 					if( lpObj->Type == OBJTYPE_MONSTER && lpObj->m_RecallMon >= 100 )

  00109	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00110	83 f9 02	 cmp	 ecx, 2
  00113	75 1d		 jne	 SHORT $LN14@MoveMonste
  00115	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00118	83 b8 a4 02 00
	00 64		 cmp	 DWORD PTR [eax+676], 100 ; 00000064H
  0011f	7c 11		 jl	 SHORT $LN14@MoveMonste

; 917  : 						lpObj->m_MoveSpeed = 200;

  00121	b8 c8 00 00 00	 mov	 eax, 200		; 000000c8H
  00126	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00129	66 89 81 f4 02
	00 00		 mov	 WORD PTR [ecx+756], ax
  00130	eb 0f		 jmp	 SHORT $LN15@MoveMonste
$LN14@MoveMonste:

; 918  : 
; 919  : 					else lpObj->m_MoveSpeed = 400;

  00132	b8 90 01 00 00	 mov	 eax, 400		; 00000190H
  00137	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0013a	66 89 81 f4 02
	00 00		 mov	 WORD PTR [ecx+756], ax
$LN15@MoveMonste:

; 920  : 
; 921  : 					if( (lpObj->PathDir[lpObj->PathCur]%2) == 0 )

  00141	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00144	8b 88 2c 01 00
	00		 mov	 ecx, DWORD PTR [eax+300]
  0014a	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0014d	0f be 84 0a 8c
	01 00 00	 movsx	 eax, BYTE PTR [edx+ecx+396]
  00155	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0015a	79 05		 jns	 SHORT $LN35@MoveMonste
  0015c	48		 dec	 eax
  0015d	83 c8 fe	 or	 eax, -2			; fffffffeH
  00160	40		 inc	 eax
$LN35@MoveMonste:
  00161	85 c0		 test	 eax, eax
  00163	75 23		 jne	 SHORT $LN16@MoveMonste

; 922  : 					{
; 923  : 						MoveTime = (DWORD)((lpObj->m_MoveSpeed+DelayTime)*1.3);//sqrt((200*200)+(200*200));

  00165	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00168	0f bf 88 f4 02
	00 00		 movsx	 ecx, WORD PTR [eax+756]
  0016f	03 4d f8	 add	 ecx, DWORD PTR _DelayTime$[ebp]
  00172	f2 0f 2a c1	 cvtsi2sd xmm0, ecx
  00176	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3ff4cccccccccccd
  0017e	e8 00 00 00 00	 call	 __dtoui3
  00183	89 45 fc	 mov	 DWORD PTR _MoveTime$[ebp], eax

; 924  : 					}

  00186	eb 10		 jmp	 SHORT $LN17@MoveMonste
$LN16@MoveMonste:

; 925  : 					else MoveTime = (lpObj->m_MoveSpeed+DelayTime); //400

  00188	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0018b	0f bf 88 f4 02
	00 00		 movsx	 ecx, WORD PTR [eax+756]
  00192	03 4d f8	 add	 ecx, DWORD PTR _DelayTime$[ebp]
  00195	89 4d fc	 mov	 DWORD PTR _MoveTime$[ebp], ecx
$LN17@MoveMonste:

; 926  : 					
; 927  : 					
; 928  : 					if( (GetTickCount()-lpObj->PathTime) > MoveTime )  

  00198	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0019e	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001a1	2b 81 9c 01 00
	00		 sub	 eax, DWORD PTR [ecx+412]
  001a7	3b 45 fc	 cmp	 eax, DWORD PTR _MoveTime$[ebp]
  001aa	0f 86 7a 02 00
	00		 jbe	 $LN28@MoveMonste

; 929  : 					{ 
; 930  : 						if( lpObj->PathCur < MAX_ROADPATH-1 ) 

  001b0	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b3	83 b8 2c 01 00
	00 0e		 cmp	 DWORD PTR [eax+300], 14	; 0000000eH
  001ba	0f 8d 6a 02 00
	00		 jge	 $LN28@MoveMonste

; 931  : 						{
; 932  : #ifdef MODIFY_FORCEMOVE_TO_LORENCIA_20060515
; 933  : 							//     ,   .
; 934  : 							int nextX = lpObj->PathX[lpObj->PathCur];

  001c0	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c3	8b 88 2c 01 00
	00		 mov	 ecx, DWORD PTR [eax+300]
  001c9	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001cc	0f bf 84 4a 50
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx*2+336]
  001d4	89 45 ec	 mov	 DWORD PTR _nextX$4[ebp], eax

; 935  : 							int nextY = lpObj->PathY[lpObj->PathCur];

  001d7	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001da	8b 88 2c 01 00
	00		 mov	 ecx, DWORD PTR [eax+300]
  001e0	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001e3	0f bf 84 4a 6e
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx*2+366]
  001eb	89 45 e8	 mov	 DWORD PTR _nextY$3[ebp], eax

; 936  : 							BYTE mapnumber;
; 937  : 							mapnumber	= lpObj->MapNumber;

  001ee	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f1	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  001f7	88 4d e7	 mov	 BYTE PTR _mapnumber$2[ebp], cl

; 938  : 							if ( mapnumber > g_TerrainManager.Size() - 1 )

  001fa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  001ff	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size

; 939  : 							{
; 940  : 								//  ;;;
; 941  : 							}
; 942  : 							BYTE attr =  MapC[mapnumber].GetAttr(nextX, nextY);

  00204	8b 45 e8	 mov	 eax, DWORD PTR _nextY$3[ebp]
  00207	50		 push	 eax
  00208	8b 4d ec	 mov	 ecx, DWORD PTR _nextX$4[ebp]
  0020b	51		 push	 ecx
  0020c	0f b6 55 e7	 movzx	 edx, BYTE PTR _mapnumber$2[ebp]
  00210	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00216	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0021c	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00221	88 45 e6	 mov	 BYTE PTR _attr$1[ebp], al

; 943  : 							if( lpObj->Type == OBJTYPE_CHARACTER &&

  00224	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00227	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0022b	83 f9 01	 cmp	 ecx, 1
  0022e	0f 85 2a 01 00
	00		 jne	 $LN21@MoveMonste
  00234	0f b6 45 e6	 movzx	 eax, BYTE PTR _attr$1[ebp]
  00238	83 e0 04	 and	 eax, 4
  0023b	75 0d		 jne	 SHORT $LN23@MoveMonste
  0023d	0f b6 45 e6	 movzx	 eax, BYTE PTR _attr$1[ebp]
  00241	83 e0 08	 and	 eax, 8
  00244	0f 84 14 01 00
	00		 je	 $LN21@MoveMonste
$LN23@MoveMonste:

; 944  : 								( (attr&MAP_ATTR_BLOCK) == MAP_ATTR_BLOCK || 
; 945  : 								(attr&MAP_ATTR_HOLLOW) == MAP_ATTR_HOLLOW
; 946  : 								) )
; 947  : 							{
; 948  : 								//   								
; 949  : 								LogAddTD( "[ CHECK POSITION ] MoveMosterProc [%s][%s] Map[%d]-(%d,%d) User(%d,%d) Can not Move Position Attr[%d]", 

  0024a	0f b6 45 e6	 movzx	 eax, BYTE PTR _attr$1[ebp]
  0024e	50		 push	 eax
  0024f	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00252	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00259	52		 push	 edx
  0025a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0025d	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00264	51		 push	 ecx
  00265	8b 55 e8	 mov	 edx, DWORD PTR _nextY$3[ebp]
  00268	52		 push	 edx
  00269	8b 45 ec	 mov	 eax, DWORD PTR _nextX$4[ebp]
  0026c	50		 push	 eax
  0026d	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00270	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00277	52		 push	 edx
  00278	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0027b	83 c0 73	 add	 eax, 115		; 00000073H
  0027e	50		 push	 eax
  0027f	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00282	83 c1 68	 add	 ecx, 104		; 00000068H
  00285	51		 push	 ecx
  00286	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@GPEABMHM@?$FL?5CHECK?5POSITION?5?$FN?5MoveMosterPr@
  0028b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00291	83 c4 24	 add	 esp, 36			; 00000024H

; 950  : 									lpObj->AccountID, lpObj->Name, 
; 951  : 									lpObj->MapNumber, nextX, nextY, 
; 952  : 									lpObj->X, lpObj->Y,
; 953  : 									attr );							
; 954  : 								
; 955  : 								//    .
; 956  : 								for( n=0; n<MAX_ROADPATH; n++)

  00294	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$5[ebp], 0
  0029b	eb 09		 jmp	 SHORT $LN7@MoveMonste
$LN5@MoveMonste:
  0029d	8b 45 f0	 mov	 eax, DWORD PTR _n$5[ebp]
  002a0	83 c0 01	 add	 eax, 1
  002a3	89 45 f0	 mov	 DWORD PTR _n$5[ebp], eax
$LN7@MoveMonste:
  002a6	83 7d f0 0f	 cmp	 DWORD PTR _n$5[ebp], 15	; 0000000fH
  002aa	7d 32		 jge	 SHORT $LN6@MoveMonste

; 957  : 								{
; 958  : 									lpObj->PathX[n] = 0;

  002ac	33 c0		 xor	 eax, eax
  002ae	8b 4d f0	 mov	 ecx, DWORD PTR _n$5[ebp]
  002b1	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002b4	66 89 84 4a 50
	01 00 00	 mov	 WORD PTR [edx+ecx*2+336], ax

; 959  : 									lpObj->PathY[n] = 0;

  002bc	33 c0		 xor	 eax, eax
  002be	8b 4d f0	 mov	 ecx, DWORD PTR _n$5[ebp]
  002c1	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002c4	66 89 84 4a 6e
	01 00 00	 mov	 WORD PTR [edx+ecx*2+366], ax

; 960  : 									lpObj->PathOri[n] = 0;

  002cc	33 c0		 xor	 eax, eax
  002ce	8b 4d f0	 mov	 ecx, DWORD PTR _n$5[ebp]
  002d1	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002d4	66 89 84 4a 32
	01 00 00	 mov	 WORD PTR [edx+ecx*2+306], ax

; 961  : 								}

  002dc	eb bf		 jmp	 SHORT $LN5@MoveMonste
$LN6@MoveMonste:

; 962  : 								lpObj->PathCount = 0;

  002de	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002e1	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0

; 963  : 								lpObj->PathCur = 0;

  002eb	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ee	c7 80 2c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+300], 0

; 964  : 								lpObj->PathTime = GetTickCount();

  002f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  002fe	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00301	89 81 9c 01 00
	00		 mov	 DWORD PTR [ecx+412], eax

; 965  : 								if( lpObj->Type == OBJTYPE_MONSTER || lpObj->Type == OBJTYPE_NPC )

  00307	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030a	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0030e	83 f9 02	 cmp	 ecx, 2
  00311	74 0c		 je	 SHORT $LN25@MoveMonste
  00313	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00316	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0031a	83 f9 03	 cmp	 ecx, 3
  0031d	75 0a		 jne	 SHORT $LN24@MoveMonste
$LN25@MoveMonste:

; 966  : 								{
; 967  : 									lpObj->PathStartEnd = 0;

  0031f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00322	c6 80 30 01 00
	00 00		 mov	 BYTE PTR [eax+304], 0
$LN24@MoveMonste:

; 968  : 								}			
; 969  : 								// 0524  
; 970  : 								if ( lpObj->Type == OBJTYPE_CHARACTER )

  00329	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0032c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00330	83 f9 01	 cmp	 ecx, 1
  00333	75 24		 jne	 SHORT $LN26@MoveMonste

; 971  : 								{
; 972  : 									gObjSetPosition(lpObj->m_Index, lpObj->X, lpObj->Y);

  00335	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00338	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0033f	51		 push	 ecx
  00340	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00343	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  0034a	50		 push	 eax
  0034b	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0034e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00350	52		 push	 edx
  00351	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  00356	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@MoveMonste:

; 973  : 								}
; 974  : 							}

  00359	e9 cc 00 00 00	 jmp	 $LN28@MoveMonste
$LN21@MoveMonste:

; 975  : 							else
; 976  : 							{							
; 977  : #endif //MODIFY_FORCEMOVE_TO_LORENCIA_20060515							
; 978  : 								
; 979  : 							lpObj->X   = lpObj->PathX[lpObj->PathCur];

  0035e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00361	8b 88 2c 01 00
	00		 mov	 ecx, DWORD PTR [eax+300]
  00367	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0036a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0036d	66 8b 8c 48 50
	01 00 00	 mov	 cx, WORD PTR [eax+ecx*2+336]
  00375	66 89 8a 04 01
	00 00		 mov	 WORD PTR [edx+260], cx

; 980  : 							lpObj->Y   = lpObj->PathY[lpObj->PathCur];

  0037c	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0037f	8b 88 2c 01 00
	00		 mov	 ecx, DWORD PTR [eax+300]
  00385	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00388	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0038b	66 8b 8c 48 6e
	01 00 00	 mov	 cx, WORD PTR [eax+ecx*2+366]
  00393	66 89 8a 06 01
	00 00		 mov	 WORD PTR [edx+262], cx

; 981  : 							lpObj->Dir = lpObj->PathDir[lpObj->PathCur];

  0039a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039d	8b 88 2c 01 00
	00		 mov	 ecx, DWORD PTR [eax+300]
  003a3	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003a6	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003a9	8a 8c 08 8c 01
	00 00		 mov	 cl, BYTE PTR [eax+ecx+396]
  003b0	88 8a 08 01 00
	00		 mov	 BYTE PTR [edx+264], cl

; 982  : 
; 983  : 							lpObj->PathTime = GetTickCount();

  003b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  003bc	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003bf	89 81 9c 01 00
	00		 mov	 DWORD PTR [ecx+412], eax

; 984  : 							lpObj->PathCur++;

  003c5	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003c8	8b 88 2c 01 00
	00		 mov	 ecx, DWORD PTR [eax+300]
  003ce	83 c1 01	 add	 ecx, 1
  003d1	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003d4	89 8a 2c 01 00
	00		 mov	 DWORD PTR [edx+300], ecx

; 985  : 						
; 986  : 							if( lpObj->PathCur >= lpObj->PathCount ) //  ..

  003da	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003dd	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003e0	8b 90 2c 01 00
	00		 mov	 edx, DWORD PTR [eax+300]
  003e6	3b 91 28 01 00
	00		 cmp	 edx, DWORD PTR [ecx+296]
  003ec	7c 3c		 jl	 SHORT $LN28@MoveMonste

; 987  : 							{
; 988  : 								lpObj->PathCur = 0;

  003ee	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003f1	c7 80 2c 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+300], 0

; 989  : 								lpObj->PathCount = 0;

  003fb	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003fe	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0

; 990  : 								if( lpObj->Type == OBJTYPE_MONSTER || lpObj->Type == OBJTYPE_NPC )

  00408	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0040b	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0040f	83 f9 02	 cmp	 ecx, 2
  00412	74 0c		 je	 SHORT $LN29@MoveMonste
  00414	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00417	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0041b	83 f9 03	 cmp	 ecx, 3
  0041e	75 0a		 jne	 SHORT $LN28@MoveMonste
$LN29@MoveMonste:

; 991  : 								{
; 992  : 									lpObj->PathStartEnd = 0;

  00420	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00423	c6 80 30 01 00
	00 00		 mov	 BYTE PTR [eax+304], 0
$LN28@MoveMonste:

; 993  : 								}
; 994  : 							}
; 995  : #ifdef MODIFY_FORCEMOVE_TO_LORENCIA_20060515
; 996  : 							}	// else{
; 997  : #endif
; 998  : 						}
; 999  : 					}
; 1000 : 					
; 1001 : 				}				
; 1002 : 				CreateFrustrum(lpObj->X,lpObj->Y, n);

  0042a	8b 45 f0	 mov	 eax, DWORD PTR _n$5[ebp]
  0042d	50		 push	 eax
  0042e	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00431	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00438	52		 push	 edx
  00439	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0043c	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00443	51		 push	 ecx
  00444	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  00449	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@MoveMonste:

; 1003 : 			}	
; 1004 : 		}
; 1005 : 		
; 1006 : 	} // for( n )

  0044c	e9 c1 fb ff ff	 jmp	 $LN2@MoveMonste
$LN3@MoveMonste:

; 1007 : }

  00451	5f		 pop	 edi
  00452	5e		 pop	 esi
  00453	5b		 pop	 ebx
  00454	8b e5		 mov	 esp, ebp
  00456	5d		 pop	 ebp
  00457	c3		 ret	 0
?MoveMonsterProc@@YAXXZ ENDP				; MoveMonsterProc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?MonsterAndMsgProc@@YAXXZ
_TEXT	SEGMENT
_k$1 = -20						; size = 4
_n$2 = -16						; size = 4
_aIndex$ = -12						; size = 4
_n$3 = -8						; size = 4
_lpObj$ = -4						; size = 4
?MonsterAndMsgProc@@YAXXZ PROC				; MonsterAndMsgProc, COMDAT

; 717  : {		

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 718  : 	LPOBJECTSTRUCT	lpObj;
; 719  : 
; 720  : 	for( int n=0; n<MAX_OBJECT; n++)

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$3[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@MonsterAnd
$LN2@MonsterAnd:
  00012	8b 45 f8	 mov	 eax, DWORD PTR _n$3[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 f8	 mov	 DWORD PTR _n$3[ebp], eax
$LN4@MonsterAnd:
  0001b	81 7d f8 e8 1c
	00 00		 cmp	 DWORD PTR _n$3[ebp], 7400 ; 00001ce8H
  00022	0f 8d fc 00 00
	00		 jge	 $LN3@MonsterAnd

; 721  : 	{
; 722  : 		lpObj = (LPOBJECTSTRUCT)&gObj[n];

  00028	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$3[ebp], 7072
  0002f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00035	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 723  : 		
; 724  : 		//   ..
; 725  : 		if( lpObj->Connected == CSS_GAMEPLAYING )

  00038	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003b	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  0003f	0f 85 8e 00 00
	00		 jne	 $LN11@MonsterAnd

; 726  : 		{
; 727  : 			if( lpObj->Type == OBJTYPE_MONSTER || lpObj->Type ==  OBJTYPE_NPC )

  00045	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00048	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0004c	83 f9 02	 cmp	 ecx, 2
  0004f	74 0c		 je	 SHORT $LN15@MonsterAnd
  00051	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00054	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00058	83 f9 03	 cmp	 ecx, 3
  0005b	75 0e		 jne	 SHORT $LN13@MonsterAnd
$LN15@MonsterAnd:

; 728  : 			{
; 729  : #ifdef ADD_NEW_MONSTER_SYSTEM_02_20050725
; 730  : 				// AI    Continue
; 731  : 				if( lpObj->m_iCurrentAI )
; 732  : 				{
; 733  : 					continue;
; 734  : 				}
; 735  : 				else
; 736  : #endif
; 737  : 				gObjMonsterProcess(lpObj);

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ?gObjMonsterProcess@@YAXPAVOBJECTSTRUCT@@@Z ; gObjMonsterProcess
  00066	83 c4 04	 add	 esp, 4

; 738  : 			}

  00069	eb 4b		 jmp	 SHORT $LN14@MonsterAnd
$LN13@MonsterAnd:

; 739  : 			else 
; 740  : 			{
; 741  : #ifdef ADD_SKILL_WITH_COMBO
; 742  : 				gObjSkillUseProcTime500(lpObj);

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?gObjSkillUseProcTime500@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSkillUseProcTime500
  00074	83 c4 04	 add	 esp, 4

; 743  : #endif
; 744  : 				if(lpObj->m_bShell == true)

  00077	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007a	0f b6 88 7d 1a
	00 00		 movzx	 ecx, BYTE PTR [eax+6781]
  00081	83 f9 01	 cmp	 ecx, 1
  00084	75 02		 jne	 SHORT $LN16@MonsterAnd

; 745  : 					continue;

  00086	eb 8a		 jmp	 SHORT $LN2@MonsterAnd
$LN16@MonsterAnd:

; 746  : 				gObjMsgProc(lpObj);

  00088	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ?gObjMsgProc@@YAXPAVOBJECTSTRUCT@@@Z ; gObjMsgProc
  00091	83 c4 04	 add	 esp, 4

; 747  : 				CreateFrustrum(lpObj->X,lpObj->Y, n);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _n$3[ebp]
  00097	50		 push	 eax
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0009b	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  000a2	52		 push	 edx
  000a3	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a6	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  000ad	51		 push	 ecx
  000ae	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@MonsterAnd:

; 748  : 			}
; 749  : 
; 750  : #ifdef DARKLORD_WORK	//  
; 751  : 			if( lpObj->Type == OBJTYPE_CHARACTER )

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b9	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  000bd	83 f9 01	 cmp	 ecx, 1
  000c0	75 0f		 jne	 SHORT $LN17@MonsterAnd

; 752  : 				gDarkSpirit[n].Run();

  000c2	6b 4d f8 28	 imul	 ecx, DWORD PTR _n$3[ebp], 40
  000c6	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  000cc	e8 00 00 00 00	 call	 ?Run@CDarkSpirit@@QAEXXZ ; CDarkSpirit::Run
$LN17@MonsterAnd:

; 753  : #endif
; 754  : 		}

  000d1	eb 4c		 jmp	 SHORT $LN12@MonsterAnd
$LN11@MonsterAnd:

; 755  : 		else if( lpObj->Connected >= CSS_LOGINOK )

  000d3	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d6	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  000da	7c 43		 jl	 SHORT $LN12@MonsterAnd

; 756  : 		{
; 757  : 			if( lpObj->Type == OBJTYPE_CHARACTER )

  000dc	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000df	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  000e3	83 f9 01	 cmp	 ecx, 1
  000e6	75 37		 jne	 SHORT $LN12@MonsterAnd

; 758  : 			{
; 759  : 				gObjMsgProc(lpObj);

  000e8	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 ?gObjMsgProc@@YAXPAVOBJECTSTRUCT@@@Z ; gObjMsgProc
  000f1	83 c4 04	 add	 esp, 4

; 760  : 				if( lpObj->Connected == CSS_GAMEPLAYING )

  000f4	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f7	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  000fb	75 22		 jne	 SHORT $LN12@MonsterAnd

; 761  : 				{
; 762  : 					CreateFrustrum(lpObj->X,lpObj->Y, n);

  000fd	8b 45 f8	 mov	 eax, DWORD PTR _n$3[ebp]
  00100	50		 push	 eax
  00101	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00104	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  0010b	52		 push	 edx
  0010c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010f	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00116	51		 push	 ecx
  00117	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  0011c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@MonsterAnd:

; 763  : 				}
; 764  : 			}				
; 765  : 		}
; 766  : 
; 767  : 		
; 768  : 	} // for( n )

  0011f	e9 ee fe ff ff	 jmp	 $LN2@MonsterAnd
$LN3@MonsterAnd:

; 769  : 
; 770  : #ifdef ADD_SKILL_WITH_COMBO		//    
; 771  : 	int aIndex;
; 772  : 	for( int n=0; n<MAX_USER; n++)

  00124	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$2[ebp], 0
  0012b	eb 09		 jmp	 SHORT $LN7@MonsterAnd
$LN5@MonsterAnd:
  0012d	8b 45 f0	 mov	 eax, DWORD PTR _n$2[ebp]
  00130	83 c0 01	 add	 eax, 1
  00133	89 45 f0	 mov	 DWORD PTR _n$2[ebp], eax
$LN7@MonsterAnd:
  00136	81 7d f0 e8 03
	00 00		 cmp	 DWORD PTR _n$2[ebp], 1000 ; 000003e8H
  0013d	0f 8d f3 00 00
	00		 jge	 $LN1@MonsterAnd

; 773  : 	{
; 774  : 		lpObj = (LPOBJECTSTRUCT)&gObj[n+ALLOC_USEROBJECTSTART];

  00143	8b 45 f0	 mov	 eax, DWORD PTR _n$2[ebp]
  00146	05 00 19 00 00	 add	 eax, 6400		; 00001900H
  0014b	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00151	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00157	89 4d fc	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 775  : 
; 776  : 		if( lpObj->Connected == CSS_GAMEPLAYING )

  0015a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0015d	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00161	0f 85 ca 00 00
	00		 jne	 $LN21@MonsterAnd

; 777  : 		{		
; 778  : 			aIndex = lpObj->m_Index;

  00167	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016c	89 4d f4	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 779  : 
; 780  : 			for( int k=0; k<MAXATTACKMESSAGE; k++)

  0016f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _k$1[ebp], 0
  00176	eb 09		 jmp	 SHORT $LN10@MonsterAnd
$LN8@MonsterAnd:
  00178	8b 45 ec	 mov	 eax, DWORD PTR _k$1[ebp]
  0017b	83 c0 01	 add	 eax, 1
  0017e	89 45 ec	 mov	 DWORD PTR _k$1[ebp], eax
$LN10@MonsterAnd:
  00181	83 7d ec 32	 cmp	 DWORD PTR _k$1[ebp], 50	; 00000032H
  00185	0f 8d a6 00 00
	00		 jge	 $LN21@MonsterAnd

; 781  : 			{
; 782  : 				if( gSMAttackProcMsg[n][k].MsgCode >= 0 )

  0018b	69 45 f0 e8 03
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 1000
  00192	6b 4d ec 14	 imul	 ecx, DWORD PTR _k$1[ebp], 20
  00196	83 bc 08 00 00
	00 00 00	 cmp	 DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[eax+ecx], 0
  0019e	0f 8c 88 00 00
	00		 jl	 $LN22@MonsterAnd

; 783  : 				{
; 784  : 					if( GetTickCount() > gSMAttackProcMsg[n][k].MsgTime )

  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001aa	69 4d f0 e8 03
	00 00		 imul	 ecx, DWORD PTR _n$2[ebp], 1000
  001b1	6b 55 ec 14	 imul	 edx, DWORD PTR _k$1[ebp], 20
  001b5	3b 84 11 08 00
	00 00		 cmp	 eax, DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[ecx+edx+8]
  001bc	76 6e		 jbe	 SHORT $LN22@MonsterAnd

; 785  : 					{					
; 786  : 						gObjStateAttackProc(lpObj, 

  001be	69 45 f0 e8 03
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 1000
  001c5	6b 4d ec 14	 imul	 ecx, DWORD PTR _k$1[ebp], 20
  001c9	8b 94 08 10 00
	00 00		 mov	 edx, DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[eax+ecx+16]
  001d0	52		 push	 edx
  001d1	69 45 f0 e8 03
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 1000
  001d8	6b 4d ec 14	 imul	 ecx, DWORD PTR _k$1[ebp], 20
  001dc	8b 94 08 0c 00
	00 00		 mov	 edx, DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[eax+ecx+12]
  001e3	52		 push	 edx
  001e4	69 45 f0 e8 03
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 1000
  001eb	6b 4d ec 14	 imul	 ecx, DWORD PTR _k$1[ebp], 20
  001ef	8b 94 08 04 00
	00 00		 mov	 edx, DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[eax+ecx+4]
  001f6	52		 push	 edx
  001f7	69 45 f0 e8 03
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 1000
  001fe	6b 4d ec 14	 imul	 ecx, DWORD PTR _k$1[ebp], 20
  00202	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[eax+ecx]
  00209	52		 push	 edx
  0020a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0020d	50		 push	 eax
  0020e	e8 00 00 00 00	 call	 ?gObjStateAttackProc@@YAXPAVOBJECTSTRUCT@@HHHH@Z ; gObjStateAttackProc
  00213	83 c4 14	 add	 esp, 20			; 00000014H

; 787  : 											gSMAttackProcMsg[n][k].MsgCode, 
; 788  : 											gSMAttackProcMsg[n][k].SendUser, 
; 789  : 											gSMAttackProcMsg[n][k].SubCode,
; 790  : 											gSMAttackProcMsg[n][k].SubCode2);
; 791  : 
; 792  : 						gSMAttackProcMsg[n][k].MsgCode = -1;

  00216	69 45 f0 e8 03
	00 00		 imul	 eax, DWORD PTR _n$2[ebp], 1000
  0021d	6b 4d ec 14	 imul	 ecx, DWORD PTR _k$1[ebp], 20
  00221	c7 84 08 00 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[eax+ecx], -1
$LN22@MonsterAnd:

; 793  : 					}
; 794  : 				}
; 795  : 			}

  0022c	e9 47 ff ff ff	 jmp	 $LN8@MonsterAnd
$LN21@MonsterAnd:

; 796  : 		}
; 797  : 	}

  00231	e9 f7 fe ff ff	 jmp	 $LN5@MonsterAnd
$LN1@MonsterAnd:

; 798  : #elif defined(NEW_ATTACK_PROC)
; 799  : 	int aIndex;
; 800  : 	for( int n=0; n<MAX_USER; n++)
; 801  : 	{
; 802  : 		lpObj = (LPOBJECTSTRUCT)&gObj[n+ALLOC_USEROBJECTSTART];
; 803  : 
; 804  : 		if( lpObj->Connected == CSS_GAMEPLAYING )
; 805  : 		{		
; 806  : 			aIndex = lpObj->m_Index;
; 807  : 
; 808  : 			for( int k=0; k<MAXATTACKMESSAGE; k++)
; 809  : 			{
; 810  : 				if( gSMAttackProcMsg[n][k].MsgCode >= 0 )
; 811  : 				{
; 812  : 					if( GetTickCount() > gSMAttackProcMsg[n][k].MsgTime )
; 813  : 					{					
; 814  : 						gObjStateAttackProc(lpObj, 
; 815  : 							gSMAttackProcMsg[n][k].MsgCode, 
; 816  : 							gSMAttackProcMsg[n][k].SendUser, 
; 817  : 							gSMAttackProcMsg[n][k].SubCode,
; 818  : 							gSMAttackProcMsg[n][k].SubCode2);
; 819  : 
; 820  : 						gSMAttackProcMsg[n][k].MsgCode = -1;
; 821  : 					}
; 822  : 				}
; 823  : 			}
; 824  : 		}
; 825  : 	}
; 826  : #endif
; 827  : 	
; 828  : #ifdef ADD_NEW_MONSTER_SYSTEM_01_20050714
; 829  : 	//      
; 830  : 	TMonsterSkillManager::MonsterSkillProc();
; 831  : #endif
; 832  : 
; 833  : }

  00236	5f		 pop	 edi
  00237	5e		 pop	 esi
  00238	5b		 pop	 ebx
  00239	8b e5		 mov	 esp, ebp
  0023b	5d		 pop	 ebp
  0023c	c3		 ret	 0
?MonsterAndMsgProc@@YAXXZ ENDP				; MonsterAndMsgProc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@E@Z
_TEXT	SEGMENT
_n$1 = -4						; size = 4
_lpObj$ = 8						; size = 4
_skillnumber$ = 12					; size = 1
?gObjGetMagicSearch@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@E@Z PROC ; gObjGetMagicSearch, COMDAT

; 27839: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 27840: 	/*int reqeng = MagicDamageC.SkillGetRequireEnergy(skillnumber);
; 27841: 	if( reqeng < 0 ) return NULL;
; 27842: 
; 27843: 	if( lpObj->Energy < reqeng ) return NULL;
; 27844: 	*/
; 27845: #ifdef ADD_SKILL_WITH_COMBO
; 27846: 	if( skillnumber == AT_SKILL_EXPHELL_START )

  00009	0f b6 45 0c	 movzx	 eax, BYTE PTR _skillnumber$[ebp]
  0000d	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00010	75 04		 jne	 SHORT $LN5@gObjGetMag

; 27847: 	{
; 27848: 		skillnumber = AT_SKILL_EXPHELL;

  00012	c6 45 0c 28	 mov	 BYTE PTR _skillnumber$[ebp], 40 ; 00000028H
$LN5@gObjGetMag:

; 27849: 	}
; 27850: #endif
; 27851: 
; 27852: 	for( int n=0; n<MAX_MAGIC; n++)

  00016	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0001d	eb 09		 jmp	 SHORT $LN4@gObjGetMag
$LN2@gObjGetMag:
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  00022	83 c0 01	 add	 eax, 1
  00025	89 45 fc	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjGetMag:
  00028	83 7d fc 3c	 cmp	 DWORD PTR _n$1[ebp], 60	; 0000003cH
  0002c	0f 8d 95 00 00
	00		 jge	 $LN3@gObjGetMag

; 27853: 	{
; 27854: 		if( lpObj->Magic[n].IsMagic() == TRUE )

  00032	8b 4d fc	 mov	 ecx, DWORD PTR _n$1[ebp]
  00035	c1 e1 04	 shl	 ecx, 4
  00038	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003b	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  00041	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  00046	83 f8 01	 cmp	 eax, 1
  00049	75 77		 jne	 SHORT $LN6@gObjGetMag

; 27855: 		{
; 27856: 			if( lpObj->Magic[n].m_Skill == skillnumber )

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  0004e	c1 e0 04	 shl	 eax, 4
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00054	8b 91 10 03 00
	00		 mov	 edx, DWORD PTR [ecx+784]
  0005a	0f b6 44 02 05	 movzx	 eax, BYTE PTR [edx+eax+5]
  0005f	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _skillnumber$[ebp]
  00063	3b c1		 cmp	 eax, ecx
  00065	75 5b		 jne	 SHORT $LN6@gObjGetMag

; 27857: 			{
; 27858: 				if( !gObjMagicEnergyCheck(lpObj, lpObj->Magic[n].m_Skill) )

  00067	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  0006a	c1 e0 04	 shl	 eax, 4
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00070	8b 91 10 03 00
	00		 mov	 edx, DWORD PTR [ecx+784]
  00076	0f b6 44 02 05	 movzx	 eax, BYTE PTR [edx+eax+5]
  0007b	50		 push	 eax
  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0007f	51		 push	 ecx
  00080	e8 00 00 00 00	 call	 ?gObjMagicEnergyCheck@@YAHPAVOBJECTSTRUCT@@E@Z ; gObjMagicEnergyCheck
  00085	83 c4 08	 add	 esp, 8
  00088	85 c0		 test	 eax, eax
  0008a	75 25		 jne	 SHORT $LN8@gObjGetMag

; 27859: 				{					
; 27860: 					GCServerMsgStringSend(lMsg.Get(1255), lpObj->m_Index, 1);	//   

  0008c	6a 01		 push	 1
  0008e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00091	8b 08		 mov	 ecx, DWORD PTR [eax]
  00093	51		 push	 ecx
  00094	68 e7 04 00 00	 push	 1255			; 000004e7H
  00099	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 27861: 					return NULL;

  000ad	33 c0		 xor	 eax, eax
  000af	eb 18		 jmp	 SHORT $LN1@gObjGetMag
$LN8@gObjGetMag:

; 27862: 				}
; 27863: 				return (CMagicInf*)&lpObj->Magic[n];

  000b1	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  000b4	c1 e0 04	 shl	 eax, 4
  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ba	03 81 10 03 00
	00		 add	 eax, DWORD PTR [ecx+784]
  000c0	eb 07		 jmp	 SHORT $LN1@gObjGetMag
$LN6@gObjGetMag:

; 27864: 			}
; 27865: 		}
; 27866: 	}	

  000c2	e9 58 ff ff ff	 jmp	 $LN2@gObjGetMag
$LN3@gObjGetMag:

; 27867: 	return NULL;

  000c7	33 c0		 xor	 eax, eax
$LN1@gObjGetMag:

; 27868: }

  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
?gObjGetMagicSearch@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@E@Z ENDP ; gObjGetMagicSearch
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGetMagic@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_mIndex$ = 12						; size = 4
?gObjGetMagic@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@H@Z PROC ; gObjGetMagic, COMDAT

; 27806: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 27807: 	if( mIndex < 0 || mIndex > MAX_MAGIC-1 )

  00009	83 7d 0c 00	 cmp	 DWORD PTR _mIndex$[ebp], 0
  0000d	7c 06		 jl	 SHORT $LN3@gObjGetMag
  0000f	83 7d 0c 3b	 cmp	 DWORD PTR _mIndex$[ebp], 59 ; 0000003bH
  00013	7e 2c		 jle	 SHORT $LN2@gObjGetMag
$LN3@gObjGetMag:

; 27808: 	{
; 27809: 		LogAdd(lMsg.Get(546), __FILE__, __LINE__);

  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjGetMagic@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@H@Z@4JA
  0001a	83 c0 03	 add	 eax, 3
  0001d	50		 push	 eax
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00023	68 22 02 00 00	 push	 546			; 00000222H
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00033	50		 push	 eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 27810: 		return NULL;

  0003d	33 c0		 xor	 eax, eax
  0003f	eb 2b		 jmp	 SHORT $LN1@gObjGetMag
$LN2@gObjGetMag:

; 27811: 	}
; 27812: 	
; 27813: //	if( lpObj->Type != OBJTYPE_CHARACTER ) return NULL;
; 27814: 
; 27815: 	/*
; 27816: 	if( lpObj->m_Change >= 0 )
; 27817: 	{
; 27818: 		if( lpObj->m_Change == 9 && mIndex == 2 )	
; 27819: 		{
; 27820: 			return &DefMagicInf[3];
; 27821: 		}
; 27822: 	}
; 27823: 	*/
; 27824: 	if( lpObj->Magic[mIndex].IsMagic() == FALSE ) return NULL;

  00041	8b 4d 0c	 mov	 ecx, DWORD PTR _mIndex$[ebp]
  00044	c1 e1 04	 shl	 ecx, 4
  00047	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004a	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  00050	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  00055	85 c0		 test	 eax, eax
  00057	75 04		 jne	 SHORT $LN4@gObjGetMag
  00059	33 c0		 xor	 eax, eax
  0005b	eb 0f		 jmp	 SHORT $LN1@gObjGetMag
$LN4@gObjGetMag:

; 27825: 	
; 27826: 	/*reqeng = MagicDamageC.SkillGetRequireEnergy(lpObj->Magic[mIndex].m_Skill);
; 27827: 	if( reqeng < 0 ) return NULL;
; 27828: 	if( lpObj->Energy < reqeng ) return NULL;
; 27829: 	*/	
; 27830: 	return (CMagicInf*)(&lpObj->Magic[mIndex]);

  0005d	8b 45 0c	 mov	 eax, DWORD PTR _mIndex$[ebp]
  00060	c1 e0 04	 shl	 eax, 4
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00066	03 81 10 03 00
	00		 add	 eax, DWORD PTR [ecx+784]
$LN1@gObjGetMag:

; 27831: }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?gObjGetMagic@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@H@Z ENDP ; gObjGetMagic
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_reqeng$ = -12						; size = 4
_n$ = -8						; size = 4
_skill$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_aSkill$ = 12						; size = 1
_Level$ = 16						; size = 1
?gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z PROC		; gObjMagicAdd, COMDAT

; 28181: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 28182: 	int skill=-1;

  00009	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _skill$[ebp], -1

; 28183: 	int n;
; 28184: 
; 28185: 	skill = -1;

  00010	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _skill$[ebp], -1

; 28186: 
; 28187: 	int reqeng;
; 28188: 
; 28189: 	if( g_EnergyCheckOff == TRUE )

  00017	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_EnergyCheckOff@@3HA, 1 ; g_EnergyCheckOff
  0001e	0f 85 a7 00 00
	00		 jne	 $LN8@gObjMagicA

; 28190: 	{
; 28191: 		reqeng = MagicDamageC.SkillGetRequireEnergy(aSkill);

  00024	0f b6 45 0c	 movzx	 eax, BYTE PTR _aSkill$[ebp]
  00028	50		 push	 eax
  00029	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0002e	e8 00 00 00 00	 call	 ?SkillGetRequireEnergy@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetRequireEnergy
  00033	89 45 f4	 mov	 DWORD PTR _reqeng$[ebp], eax

; 28192: 		if( reqeng < 0 ) 

  00036	83 7d f4 00	 cmp	 DWORD PTR _reqeng$[ebp], 0
  0003a	7d 22		 jge	 SHORT $LN9@gObjMagicA

; 28193: 		{
; 28194: 			LogAdd(lMsg.Get(549));

  0003c	68 25 02 00 00	 push	 549			; 00000225H
  00041	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00053	83 c4 04	 add	 esp, 4

; 28195: 			return -1;

  00056	83 c8 ff	 or	 eax, -1
  00059	e9 19 02 00 00	 jmp	 $LN1@gObjMagicA
$LN9@gObjMagicA:

; 28196: 		}
; 28197: 
; 28198: #ifdef MODIFY_SKILL_REQUIREENERGY_20080423
; 28199: 	if (lpObj->Class == CLASS_KNIGHT)	reqeng -= 10;

  0005e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00061	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00068	83 f9 01	 cmp	 ecx, 1
  0006b	75 09		 jne	 SHORT $LN10@gObjMagicA
  0006d	8b 45 f4	 mov	 eax, DWORD PTR _reqeng$[ebp]
  00070	83 e8 0a	 sub	 eax, 10			; 0000000aH
  00073	89 45 f4	 mov	 DWORD PTR _reqeng$[ebp], eax
$LN10@gObjMagicA:

; 28200: 	if (lpObj->Class == CLASS_ELF)		reqeng -= 5;

  00076	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00079	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00080	83 f9 02	 cmp	 ecx, 2
  00083	75 09		 jne	 SHORT $LN11@gObjMagicA
  00085	8b 45 f4	 mov	 eax, DWORD PTR _reqeng$[ebp]
  00088	83 e8 05	 sub	 eax, 5
  0008b	89 45 f4	 mov	 DWORD PTR _reqeng$[ebp], eax
$LN11@gObjMagicA:

; 28201: #endif // MODIFY_SKILL_REQUIREENERGY_20080423
; 28202: 
; 28203: 		if( (lpObj->Energy+lpObj->AddEnergy) < reqeng ) 

  0008e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00091	0f b7 88 ba 00
	00 00		 movzx	 ecx, WORD PTR [eax+186]
  00098	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0009b	0f b7 82 e6 00
	00 00		 movzx	 eax, WORD PTR [edx+230]
  000a2	03 c8		 add	 ecx, eax
  000a4	3b 4d f4	 cmp	 ecx, DWORD PTR _reqeng$[ebp]
  000a7	7d 22		 jge	 SHORT $LN8@gObjMagicA

; 28204: 		{
; 28205: 			LogAdd(lMsg.Get(549));

  000a9	68 25 02 00 00	 push	 549			; 00000225H
  000ae	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000b9	50		 push	 eax
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000c0	83 c4 04	 add	 esp, 4

; 28206: 			return -1;

  000c3	83 c8 ff	 or	 eax, -1
  000c6	e9 ac 01 00 00	 jmp	 $LN1@gObjMagicA
$LN8@gObjMagicA:

; 28207: 		}
; 28208: 	}
; 28209: 	
; 28210: #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122	// SkillGetRequireClass(...) 3 
; 28211: 	if( MagicDamageC.SkillGetRequireClass(lpObj->Class, lpObj->ChangeUP, lpObj->ThirdChangeUp, aSkill) < 1 )
; 28212: #else
; 28213: #ifdef NEW_SKILL_FORSKYLAND
; 28214: 	if( MagicDamageC.SkillGetRequireClass(lpObj->Class, lpObj->ChangeUP, aSkill) < 1 ) 

  000cb	0f b6 45 0c	 movzx	 eax, BYTE PTR _aSkill$[ebp]
  000cf	50		 push	 eax
  000d0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000d3	0f b6 91 9f 00
	00 00		 movzx	 edx, BYTE PTR [ecx+159]
  000da	52		 push	 edx
  000db	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000de	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000e5	51		 push	 ecx
  000e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  000eb	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHH@Z ; CMagicDamage::SkillGetRequireClass
  000f0	83 f8 01	 cmp	 eax, 1
  000f3	7d 22		 jge	 SHORT $LN13@gObjMagicA

; 28215: #else
; 28216: 	if( MagicDamageC.SkillGetRequireClass(lpObj->Class, aSkill) < 1 ) 
; 28217: #endif
; 28218: #endif	// MASTER_LEVEL_SKILL_SYSTEM_20071122
; 28219: 	{
; 28220: 		LogAdd(lMsg.Get(550));

  000f5	68 26 02 00 00	 push	 550			; 00000226H
  000fa	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00105	50		 push	 eax
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0010c	83 c4 04	 add	 esp, 4

; 28221: 		return -1;

  0010f	83 c8 ff	 or	 eax, -1
  00112	e9 60 01 00 00	 jmp	 $LN1@gObjMagicA
$LN13@gObjMagicA:

; 28222: 	}
; 28223: 
; 28224: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//      .
; 28225: 	if( g_MasterSkillSystem.IsExistMLSBasedSkill( lpObj, skill ) == TRUE )
; 28226: 	{		
; 28227: 		return -1;
; 28228: 	}
; 28229: #endif
; 28230: 
; 28231: 	//         .
; 28232: 	for( n=0; n<MAX_MAGIC; n++)

  00117	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  0011e	eb 09		 jmp	 SHORT $LN4@gObjMagicA
$LN2@gObjMagicA:
  00120	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00123	83 c0 01	 add	 eax, 1
  00126	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjMagicA:
  00129	83 7d f8 3c	 cmp	 DWORD PTR _n$[ebp], 60	; 0000003cH
  0012d	7d 76		 jge	 SHORT $LN3@gObjMagicA

; 28233: 	{
; 28234: 		if( lpObj->Magic[n].IsMagic() == TRUE )

  0012f	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00132	c1 e1 04	 shl	 ecx, 4
  00135	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00138	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  0013e	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  00143	83 f8 01	 cmp	 eax, 1
  00146	75 58		 jne	 SHORT $LN14@gObjMagicA

; 28235: 		{			
; 28236: 			if( lpObj->Magic[n].m_Skill == aSkill)

  00148	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0014b	c1 e0 04	 shl	 eax, 4
  0014e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00151	8b 91 10 03 00
	00		 mov	 edx, DWORD PTR [ecx+784]
  00157	0f b6 44 02 05	 movzx	 eax, BYTE PTR [edx+eax+5]
  0015c	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _aSkill$[ebp]
  00160	3b c1		 cmp	 eax, ecx
  00162	75 3c		 jne	 SHORT $LN14@gObjMagicA

; 28237: 			{
; 28238: 				LogAdd(lMsg.Get(555), lpObj->Magic[n].m_Skill , aSkill);

  00164	0f b6 45 0c	 movzx	 eax, BYTE PTR _aSkill$[ebp]
  00168	50		 push	 eax
  00169	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  0016c	c1 e1 04	 shl	 ecx, 4
  0016f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00172	8b 82 10 03 00
	00		 mov	 eax, DWORD PTR [edx+784]
  00178	0f b6 4c 08 05	 movzx	 ecx, BYTE PTR [eax+ecx+5]
  0017d	51		 push	 ecx
  0017e	68 2b 02 00 00	 push	 555			; 0000022bH
  00183	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0018e	50		 push	 eax
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00195	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28239: 				return -1;

  00198	83 c8 ff	 or	 eax, -1
  0019b	e9 d7 00 00 00	 jmp	 $LN1@gObjMagicA
$LN14@gObjMagicA:

; 28240: 			}
; 28241: 		}
; 28242: 	}

  001a0	e9 7b ff ff ff	 jmp	 $LN2@gObjMagicA
$LN3@gObjMagicA:

; 28243: 	for( n=0; n<MAX_MAGIC; n++)

  001a5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  001ac	eb 09		 jmp	 SHORT $LN7@gObjMagicA
$LN5@gObjMagicA:
  001ae	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  001b1	83 c0 01	 add	 eax, 1
  001b4	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN7@gObjMagicA:
  001b7	83 7d f8 3c	 cmp	 DWORD PTR _n$[ebp], 60	; 0000003cH
  001bb	0f 8d 8b 00 00
	00		 jge	 $LN6@gObjMagicA

; 28244: 	{
; 28245: 		if( lpObj->Magic[n].IsMagic() == FALSE )

  001c1	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  001c4	c1 e1 04	 shl	 ecx, 4
  001c7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ca	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  001d0	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  001d5	85 c0		 test	 eax, eax
  001d7	75 6e		 jne	 SHORT $LN16@gObjMagicA

; 28246: 		{
; 28247: 			skill = lpObj->Magic[n].Set(aSkill, Level);

  001d9	0f b6 45 10	 movzx	 eax, BYTE PTR _Level$[ebp]
  001dd	50		 push	 eax
  001de	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _aSkill$[ebp]
  001e2	51		 push	 ecx
  001e3	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  001e6	c1 e1 04	 shl	 ecx, 4
  001e9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001ec	03 8a 10 03 00
	00		 add	 ecx, DWORD PTR [edx+784]
  001f2	e8 00 00 00 00	 call	 ?Set@CMagicInf@@QAEHEE@Z ; CMagicInf::Set
  001f7	89 45 fc	 mov	 DWORD PTR _skill$[ebp], eax

; 28248: 			if( skill < 0 ) 

  001fa	83 7d fc 00	 cmp	 DWORD PTR _skill$[ebp], 0
  001fe	7d 2d		 jge	 SHORT $LN17@gObjMagicA

; 28249: 			{
; 28250: 				LogAdd(lMsg.Get(553), __FILE__, __LINE__);

  00200	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z@4JA
  00205	83 c0 45	 add	 eax, 69			; 00000045H
  00208	50		 push	 eax
  00209	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0020e	68 29 02 00 00	 push	 553			; 00000229H
  00213	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0021e	50		 push	 eax
  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00225	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28251: 				return -1;

  00228	83 c8 ff	 or	 eax, -1
  0022b	eb 4a		 jmp	 SHORT $LN1@gObjMagicA
$LN17@gObjMagicA:

; 28252: 			}			
; 28253: 			lpObj->MagicCount++;

  0022d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00230	8a 88 14 03 00
	00		 mov	 cl, BYTE PTR [eax+788]
  00236	80 c1 01	 add	 cl, 1
  00239	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0023c	88 8a 14 03 00
	00		 mov	 BYTE PTR [edx+788], cl

; 28254: 			return n;

  00242	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00245	eb 30		 jmp	 SHORT $LN1@gObjMagicA
$LN16@gObjMagicA:

; 28255: 		}
; 28256: 	}

  00247	e9 62 ff ff ff	 jmp	 $LN5@gObjMagicA
$LN6@gObjMagicA:

; 28257: 
; 28258: 	LogAdd(lMsg.Get(554), __FILE__, __LINE__);

  0024c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z@4JA
  00251	83 c0 4d	 add	 eax, 77			; 0000004dH
  00254	50		 push	 eax
  00255	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0025a	68 2a 02 00 00	 push	 554			; 0000022aH
  0025f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00264	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0026a	50		 push	 eax
  0026b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00271	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28259: 	return -1;

  00274	83 c8 ff	 or	 eax, -1
$LN1@gObjMagicA:

; 28260: }

  00277	5f		 pop	 edi
  00278	5e		 pop	 esi
  00279	5b		 pop	 ebx
  0027a	8b e5		 mov	 esp, ebp
  0027c	5d		 pop	 ebp
  0027d	c3		 ret	 0
?gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ENDP		; gObjMagicAdd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EEEAAE@Z
_TEXT	SEGMENT
_reqleadership$ = -16					; size = 4
_reqeng$ = -12						; size = 4
_n$ = -8						; size = 4
_skill$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_Type$ = 12						; size = 1
_Index$ = 16						; size = 1
_Level$ = 20						; size = 1
_SkillNumber$ = 24					; size = 4
?gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EEEAAE@Z PROC	; gObjMagicAdd, COMDAT

; 28029: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 28030: 	int skill=-1;

  00009	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _skill$[ebp], -1

; 28031: 	int n;
; 28032: 		
; 28033: 	int reqeng;
; 28034: 	
; 28035: 	skill = GetSkillNumberInex(Type, Index, Level);

  00010	0f b6 45 14	 movzx	 eax, BYTE PTR _Level$[ebp]
  00014	50		 push	 eax
  00015	0f b6 4d 10	 movzx	 ecx, BYTE PTR _Index$[ebp]
  00019	51		 push	 ecx
  0001a	0f b6 55 0c	 movzx	 edx, BYTE PTR _Type$[ebp]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 ?GetSkillNumberInex@@YAHHHH@Z ; GetSkillNumberInex
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	89 45 fc	 mov	 DWORD PTR _skill$[ebp], eax

; 28036: 	if( skill < 0 ) {

  0002a	83 7d fc 00	 cmp	 DWORD PTR _skill$[ebp], 0
  0002e	7d 22		 jge	 SHORT $LN8@gObjMagicA

; 28037: 		LogAdd(lMsg.Get(548));

  00030	68 24 02 00 00	 push	 548			; 00000224H
  00035	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00040	50		 push	 eax
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00047	83 c4 04	 add	 esp, 4

; 28038: 		return -1;

  0004a	83 c8 ff	 or	 eax, -1
  0004d	e9 0d 03 00 00	 jmp	 $LN1@gObjMagicA
$LN8@gObjMagicA:

; 28039: 	}
; 28040: 	if( g_EnergyCheckOff == TRUE )

  00052	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_EnergyCheckOff@@3HA, 1 ; g_EnergyCheckOff
  00059	0f 85 a6 00 00
	00		 jne	 $LN9@gObjMagicA

; 28041: 	{
; 28042: 		reqeng = MagicDamageC.SkillGetRequireEnergy(skill);

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _skill$[ebp]
  00062	50		 push	 eax
  00063	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00068	e8 00 00 00 00	 call	 ?SkillGetRequireEnergy@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetRequireEnergy
  0006d	89 45 f4	 mov	 DWORD PTR _reqeng$[ebp], eax

; 28043: 		if( reqeng < 0 ) 

  00070	83 7d f4 00	 cmp	 DWORD PTR _reqeng$[ebp], 0
  00074	7d 22		 jge	 SHORT $LN10@gObjMagicA

; 28044: 		{
; 28045: 			LogAdd(lMsg.Get(549));

  00076	68 25 02 00 00	 push	 549			; 00000225H
  0007b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00086	50		 push	 eax
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0008d	83 c4 04	 add	 esp, 4

; 28046: 			return -1;

  00090	83 c8 ff	 or	 eax, -1
  00093	e9 c7 02 00 00	 jmp	 $LN1@gObjMagicA
$LN10@gObjMagicA:

; 28047: 		}
; 28048: 
; 28049: #ifdef MODIFY_SKILL_REQUIREENERGY_20080423
; 28050: 	if (lpObj->Class == CLASS_KNIGHT)	reqeng -= 10;

  00098	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009b	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000a2	83 f9 01	 cmp	 ecx, 1
  000a5	75 09		 jne	 SHORT $LN11@gObjMagicA
  000a7	8b 45 f4	 mov	 eax, DWORD PTR _reqeng$[ebp]
  000aa	83 e8 0a	 sub	 eax, 10			; 0000000aH
  000ad	89 45 f4	 mov	 DWORD PTR _reqeng$[ebp], eax
$LN11@gObjMagicA:

; 28051: 	if (lpObj->Class == CLASS_ELF)		reqeng -= 5;

  000b0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b3	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000ba	83 f9 02	 cmp	 ecx, 2
  000bd	75 09		 jne	 SHORT $LN12@gObjMagicA
  000bf	8b 45 f4	 mov	 eax, DWORD PTR _reqeng$[ebp]
  000c2	83 e8 05	 sub	 eax, 5
  000c5	89 45 f4	 mov	 DWORD PTR _reqeng$[ebp], eax
$LN12@gObjMagicA:

; 28052: #endif // MODIFY_SKILL_REQUIREENERGY_20080423
; 28053: 	
; 28054: 		if( lpObj->Energy+lpObj->AddEnergy < reqeng ) 

  000c8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000cb	0f b7 88 ba 00
	00 00		 movzx	 ecx, WORD PTR [eax+186]
  000d2	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000d5	0f b7 82 e6 00
	00 00		 movzx	 eax, WORD PTR [edx+230]
  000dc	03 c8		 add	 ecx, eax
  000de	3b 4d f4	 cmp	 ecx, DWORD PTR _reqeng$[ebp]
  000e1	7d 22		 jge	 SHORT $LN9@gObjMagicA

; 28055: 		{
; 28056: 			
; 28057: 			LogAdd(lMsg.Get(549));

  000e3	68 25 02 00 00	 push	 549			; 00000225H
  000e8	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000f3	50		 push	 eax
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000fa	83 c4 04	 add	 esp, 4

; 28058: 			return -1;

  000fd	83 c8 ff	 or	 eax, -1
  00100	e9 5a 02 00 00	 jmp	 $LN1@gObjMagicA
$LN9@gObjMagicA:

; 28059: 		}		
; 28060: 	}
; 28061: 	
; 28062: #ifdef DARKLORD_WORK
; 28063: 		int reqleadership = MagicDamageC.GetskillRequireLeadership(skill);

  00105	8b 45 fc	 mov	 eax, DWORD PTR _skill$[ebp]
  00108	50		 push	 eax
  00109	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0010e	e8 00 00 00 00	 call	 ?GetskillRequireLeadership@CMagicDamage@@QAEHH@Z ; CMagicDamage::GetskillRequireLeadership
  00113	89 45 f0	 mov	 DWORD PTR _reqleadership$[ebp], eax

; 28064: 		if( reqleadership < 0 ) 

  00116	83 7d f0 00	 cmp	 DWORD PTR _reqleadership$[ebp], 0
  0011a	7d 16		 jge	 SHORT $LN14@gObjMagicA

; 28065: 		{
; 28066: 			LogAdd("error-L2: Skill Leadership not enough");

  0011c	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@HFCELOAC@error?9L2?3?5Skill?5Leadership?5not?5@
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00127	83 c4 04	 add	 esp, 4

; 28067: 			return -1;

  0012a	83 c8 ff	 or	 eax, -1
  0012d	e9 2d 02 00 00	 jmp	 $LN1@gObjMagicA
$LN14@gObjMagicA:

; 28068: 		}
; 28069: 
; 28070: 		if( (lpObj->Leadership+lpObj->AddLeadership) < reqleadership ) 

  00132	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00135	0f b7 88 d8 00
	00 00		 movzx	 ecx, WORD PTR [eax+216]
  0013c	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0013f	0f b7 82 da 00
	00 00		 movzx	 eax, WORD PTR [edx+218]
  00146	03 c8		 add	 ecx, eax
  00148	3b 4d f0	 cmp	 ecx, DWORD PTR _reqleadership$[ebp]
  0014b	7d 16		 jge	 SHORT $LN15@gObjMagicA

; 28071: 		{			
; 28072: 			LogAdd("error-L2: Skill Leadership not enough");

  0014d	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@HFCELOAC@error?9L2?3?5Skill?5Leadership?5not?5@
  00152	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00158	83 c4 04	 add	 esp, 4

; 28073: 			return -1;

  0015b	83 c8 ff	 or	 eax, -1
  0015e	e9 fc 01 00 00	 jmp	 $LN1@gObjMagicA
$LN15@gObjMagicA:

; 28074: 		}		
; 28075: #endif
; 28076: 
; 28077: #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122	// SkillGetRequireClass(...) 3 
; 28078: 	if( MagicDamageC.SkillGetRequireClass(lpObj->Class, lpObj->ChangeUP, lpObj->ThirdChangeUp, skill) < 1 )
; 28079: #else
; 28080: #ifdef NEW_SKILL_FORSKYLAND
; 28081: 	if( MagicDamageC.SkillGetRequireClass(lpObj->Class, lpObj->ChangeUP, skill) < 1 ) 

  00163	8b 45 fc	 mov	 eax, DWORD PTR _skill$[ebp]
  00166	50		 push	 eax
  00167	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0016a	0f b6 91 9f 00
	00 00		 movzx	 edx, BYTE PTR [ecx+159]
  00171	52		 push	 edx
  00172	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00175	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0017c	51		 push	 ecx
  0017d	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00182	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHH@Z ; CMagicDamage::SkillGetRequireClass
  00187	83 f8 01	 cmp	 eax, 1
  0018a	7d 22		 jge	 SHORT $LN16@gObjMagicA

; 28082: #else
; 28083: 	if( MagicDamageC.SkillGetRequireClass(lpObj->Class, skill) < 1 ) 
; 28084: #endif
; 28085: #endif	// MASTER_LEVEL_SKILL_SYSTEM_20071122
; 28086: 	{
; 28087: 		LogAdd(lMsg.Get(550));

  0018c	68 26 02 00 00	 push	 550			; 00000226H
  00191	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00196	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0019c	50		 push	 eax
  0019d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001a3	83 c4 04	 add	 esp, 4

; 28088: 		return -1;

  001a6	83 c8 ff	 or	 eax, -1
  001a9	e9 b1 01 00 00	 jmp	 $LN1@gObjMagicA
$LN16@gObjMagicA:

; 28089: 	}	
; 28090: 
; 28091: #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//      .
; 28092: 	if( g_MasterSkillSystem.IsExistMLSBasedSkill( lpObj, skill ) == TRUE )
; 28093: 	{		
; 28094: 		return -1;
; 28095: 	}
; 28096: #endif
; 28097: 
; 28098: 	//         .
; 28099: 	for( n=0; n<MAX_MAGIC; n++)

  001ae	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  001b5	eb 09		 jmp	 SHORT $LN4@gObjMagicA
$LN2@gObjMagicA:
  001b7	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  001ba	83 c0 01	 add	 eax, 1
  001bd	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjMagicA:
  001c0	83 7d f8 3c	 cmp	 DWORD PTR _n$[ebp], 60	; 0000003cH
  001c4	0f 8d af 00 00
	00		 jge	 $LN3@gObjMagicA

; 28100: 	{
; 28101: 		if( lpObj->Magic[n].IsMagic() == TRUE )

  001ca	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  001cd	c1 e1 04	 shl	 ecx, 4
  001d0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d3	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  001d9	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  001de	83 f8 01	 cmp	 eax, 1
  001e1	0f 85 8d 00 00
	00		 jne	 $LN17@gObjMagicA

; 28102: 		{
; 28103: 			skill = GetSkillNumberInex(Type, Index, Level);

  001e7	0f b6 45 14	 movzx	 eax, BYTE PTR _Level$[ebp]
  001eb	50		 push	 eax
  001ec	0f b6 4d 10	 movzx	 ecx, BYTE PTR _Index$[ebp]
  001f0	51		 push	 ecx
  001f1	0f b6 55 0c	 movzx	 edx, BYTE PTR _Type$[ebp]
  001f5	52		 push	 edx
  001f6	e8 00 00 00 00	 call	 ?GetSkillNumberInex@@YAHHHH@Z ; GetSkillNumberInex
  001fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  001fe	89 45 fc	 mov	 DWORD PTR _skill$[ebp], eax

; 28104: 			if( skill < 0 ) 

  00201	83 7d fc 00	 cmp	 DWORD PTR _skill$[ebp], 0
  00205	7d 32		 jge	 SHORT $LN18@gObjMagicA

; 28105: 			{
; 28106: 				LogAdd(lMsg.Get(551),__FILE__, __LINE__);

  00207	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EEEAAE@Z@4JA
  0020c	83 c0 4d	 add	 eax, 77			; 0000004dH
  0020f	50		 push	 eax
  00210	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00215	68 27 02 00 00	 push	 551			; 00000227H
  0021a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00225	50		 push	 eax
  00226	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0022c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28107: 				return -1;

  0022f	83 c8 ff	 or	 eax, -1
  00232	e9 28 01 00 00	 jmp	 $LN1@gObjMagicA

; 28108: 			}

  00237	eb 3b		 jmp	 SHORT $LN17@gObjMagicA
$LN18@gObjMagicA:

; 28109: 			else {
; 28110: 				if( lpObj->Magic[n].m_Skill == skill )

  00239	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0023c	c1 e0 04	 shl	 eax, 4
  0023f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00242	8b 91 10 03 00
	00		 mov	 edx, DWORD PTR [ecx+784]
  00248	0f b6 44 02 05	 movzx	 eax, BYTE PTR [edx+eax+5]
  0024d	3b 45 fc	 cmp	 eax, DWORD PTR _skill$[ebp]
  00250	75 22		 jne	 SHORT $LN17@gObjMagicA

; 28111: 				{
; 28112: 					LogAdd(lMsg.Get(552));

  00252	68 28 02 00 00	 push	 552			; 00000228H
  00257	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0025c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00262	50		 push	 eax
  00263	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00269	83 c4 04	 add	 esp, 4

; 28113: 					return -1;

  0026c	83 c8 ff	 or	 eax, -1
  0026f	e9 eb 00 00 00	 jmp	 $LN1@gObjMagicA
$LN17@gObjMagicA:

; 28114: 				}
; 28115: 			}
; 28116: 		}
; 28117: 	}

  00274	e9 3e ff ff ff	 jmp	 $LN2@gObjMagicA
$LN3@gObjMagicA:

; 28118: 	skill = -1;

  00279	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _skill$[ebp], -1

; 28119: 	for( n=0; n<MAX_MAGIC; n++)

  00280	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00287	eb 09		 jmp	 SHORT $LN7@gObjMagicA
$LN5@gObjMagicA:
  00289	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0028c	83 c0 01	 add	 eax, 1
  0028f	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN7@gObjMagicA:
  00292	83 7d f8 3c	 cmp	 DWORD PTR _n$[ebp], 60	; 0000003cH
  00296	0f 8d 98 00 00
	00		 jge	 $LN6@gObjMagicA

; 28120: 	{
; 28121: 		if( lpObj->Magic[n].IsMagic() == FALSE )

  0029c	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  0029f	c1 e1 04	 shl	 ecx, 4
  002a2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a5	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  002ab	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  002b0	85 c0		 test	 eax, eax
  002b2	75 7b		 jne	 SHORT $LN21@gObjMagicA

; 28122: 		{
; 28123: 			skill = lpObj->Magic[n].Set(Type, Index, Level);

  002b4	0f b6 45 14	 movzx	 eax, BYTE PTR _Level$[ebp]
  002b8	50		 push	 eax
  002b9	0f b6 4d 10	 movzx	 ecx, BYTE PTR _Index$[ebp]
  002bd	51		 push	 ecx
  002be	0f b6 55 0c	 movzx	 edx, BYTE PTR _Type$[ebp]
  002c2	52		 push	 edx
  002c3	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  002c6	c1 e1 04	 shl	 ecx, 4
  002c9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002cc	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  002d2	e8 00 00 00 00	 call	 ?Set@CMagicInf@@QAEHEEE@Z ; CMagicInf::Set
  002d7	89 45 fc	 mov	 DWORD PTR _skill$[ebp], eax

; 28124: 			if( skill < 0 ) 

  002da	83 7d fc 00	 cmp	 DWORD PTR _skill$[ebp], 0
  002de	7d 2d		 jge	 SHORT $LN22@gObjMagicA

; 28125: 			{
; 28126: 				LogAdd(lMsg.Get(553),__FILE__, __LINE__);

  002e0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EEEAAE@Z@4JA
  002e5	83 c0 61	 add	 eax, 97			; 00000061H
  002e8	50		 push	 eax
  002e9	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  002ee	68 29 02 00 00	 push	 553			; 00000229H
  002f3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002fe	50		 push	 eax
  002ff	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00305	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28127: 				return -1;

  00308	83 c8 ff	 or	 eax, -1
  0030b	eb 52		 jmp	 SHORT $LN1@gObjMagicA
$LN22@gObjMagicA:

; 28128: 			}			
; 28129: 			lpObj->MagicCount++;

  0030d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00310	8a 88 14 03 00
	00		 mov	 cl, BYTE PTR [eax+788]
  00316	80 c1 01	 add	 cl, 1
  00319	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0031c	88 8a 14 03 00
	00		 mov	 BYTE PTR [edx+788], cl

; 28130: 			SkillNumber = (BYTE)skill;

  00322	8b 45 18	 mov	 eax, DWORD PTR _SkillNumber$[ebp]
  00325	8a 4d fc	 mov	 cl, BYTE PTR _skill$[ebp]
  00328	88 08		 mov	 BYTE PTR [eax], cl

; 28131: 			return n;

  0032a	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0032d	eb 30		 jmp	 SHORT $LN1@gObjMagicA
$LN21@gObjMagicA:

; 28132: 		}
; 28133: 	}

  0032f	e9 55 ff ff ff	 jmp	 $LN5@gObjMagicA
$LN6@gObjMagicA:

; 28134: 
; 28135: 	LogAdd(lMsg.Get(554), __FILE__, __LINE__);

  00334	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EEEAAE@Z@4JA
  00339	83 c0 6a	 add	 eax, 106		; 0000006aH
  0033c	50		 push	 eax
  0033d	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00342	68 2a 02 00 00	 push	 554			; 0000022aH
  00347	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0034c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00352	50		 push	 eax
  00353	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00359	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28136: 	return -1;

  0035c	83 c8 ff	 or	 eax, -1
$LN1@gObjMagicA:

; 28137: }

  0035f	5f		 pop	 edi
  00360	5e		 pop	 esi
  00361	5b		 pop	 ebx
  00362	8b e5		 mov	 esp, ebp
  00364	5d		 pop	 ebp
  00365	c3		 ret	 0
?gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EEEAAE@Z ENDP	; gObjMagicAdd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjTeleport@@YAXHHHH@Z
_TEXT	SEGMENT
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_map$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?gObjTeleport@@YAXHHHH@Z PROC				; gObjTeleport, COMDAT

; 27697: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 27698: 	if( aIndex < 0 || aIndex > MAX_OBJECT-1 ) return;

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@gObjTelepo
  0000f	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00016	7e 05		 jle	 SHORT $LN2@gObjTelepo
$LN3@gObjTelepo:
  00018	e9 59 02 00 00	 jmp	 $LN1@gObjTelepo
$LN2@gObjTelepo:

; 27699: 	
; 27700: 	LPOBJECTSTRUCT lpObj;
; 27701: 	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  0001d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00024	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002a	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 27702: 
; 27703: 	if( !MapNumberCheck(map) ) 

  0002d	8b 45 0c	 mov	 eax, DWORD PTR _map$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?MapNumberCheck@@YAHH@Z	; MapNumberCheck
  00036	83 c4 04	 add	 esp, 4
  00039	85 c0		 test	 eax, eax
  0003b	75 21		 jne	 SHORT $LN4@gObjTelepo

; 27704: 	{
; 27705: 		LogAdd("error-L3 : %s %d", __FILE__, __LINE__);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjTeleport@@YAXHHHH@Z@4JA
  00042	83 c0 08	 add	 eax, 8
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LBNJKNBE@error?9L3?5?3?5?$CFs?5?$CFd@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 27706: 		return;

  00059	e9 18 02 00 00	 jmp	 $LN1@gObjTelepo
$LN4@gObjTelepo:

; 27707: 	}
; 27708: 
; 27709: #ifdef MAP_SERVER_WORK_20041030		//   
; 27710: 
; 27711: 	if (gObj[aIndex].MapNumber != map) {
; 27712: 		//        .
; 27713: 		SHORT sSvrCode	= g_MapServerManager.CheckMoveMapSvr(lpObj->m_Index, map, lpObj->m_sPrevMapSvrCode);
; 27714: 		if (sSvrCode != gGameServerCode) {
; 27715: 			if (sSvrCode == -1) {
; 27716: 				//   ->  
; 27717: 				LogAddC(LOGC_RED, "[MapServerMng] Map Server Move Fail : CheckMoveMapSvr() == -1 [%s][%s] (%d)",
; 27718: 					lpObj->AccountID,
; 27719: 					lpObj->Name,
; 27720: 					lpObj->m_Index
; 27721: 					);
; 27722: 				return;
; 27723: 			}
; 27724: 
; 27725: 			//     .
; 27726: 			GJReqMapSvrMove (lpObj->m_Index, sSvrCode, map, x, y);
; 27727: 			LogAddTD("[MapServerMng] Request to Move Map Server : (%d) - [%s][%s] (%d)",
; 27728: 				sSvrCode,
; 27729: 				lpObj->AccountID,
; 27730: 				lpObj->Name,
; 27731: 				lpObj->m_Index
; 27732: 				);
; 27733: 				return;
; 27734: 		}
; 27735: 	}
; 27736: 	
; 27737: #endif
; 27738: 
; 27739: 	if( lpObj->m_IfState.use==1 && lpObj->m_IfState.type == I_TRADE)

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00061	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00067	80 e1 03	 and	 cl, 3
  0006a	0f b6 d1	 movzx	 edx, cl
  0006d	83 fa 01	 cmp	 edx, 1
  00070	75 25		 jne	 SHORT $LN5@gObjTelepo
  00072	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00075	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0007b	c0 e9 04	 shr	 cl, 4
  0007e	80 e1 0f	 and	 cl, 15			; 0000000fH
  00081	0f b6 d1	 movzx	 edx, cl
  00084	83 fa 01	 cmp	 edx, 1
  00087	75 0e		 jne	 SHORT $LN5@gObjTelepo

; 27740: 	{
; 27741: 		CGTradeCancelButtonRecv(lpObj->m_Index);

  00089	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 ?CGTradeCancelButtonRecv@@YAXH@Z ; CGTradeCancelButtonRecv
  00094	83 c4 04	 add	 esp, 4
$LN5@gObjTelepo:

; 27742: 		//LogAddL(" ");
; 27743: 	}
; 27744: 	if( lpObj->m_IfState.use==1 && lpObj->m_IfState.type == I_WAREHOUSE)

  00097	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009a	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000a0	80 e1 03	 and	 cl, 3
  000a3	0f b6 d1	 movzx	 edx, cl
  000a6	83 fa 01	 cmp	 edx, 1
  000a9	75 25		 jne	 SHORT $LN6@gObjTelepo
  000ab	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ae	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000b4	c0 e9 04	 shr	 cl, 4
  000b7	80 e1 0f	 and	 cl, 15			; 0000000fH
  000ba	0f b6 d1	 movzx	 edx, cl
  000bd	83 fa 06	 cmp	 edx, 6
  000c0	75 0e		 jne	 SHORT $LN6@gObjTelepo

; 27745: 	{
; 27746: 		CGWarehouseUseEnd(lpObj->m_Index);

  000c2	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 ?CGWarehouseUseEnd@@YAXH@Z ; CGWarehouseUseEnd
  000cd	83 c4 04	 add	 esp, 4
$LN6@gObjTelepo:

; 27747: 		//LogAddL(" ");
; 27748: 	}
; 27749: 	//if( lpObj->m_IfState.use==1 && lpObj->m_IfState.type == I_GUILDCREATE )
; 27750: 	//if( lpObj->m_IfState.use==1 && lpObj->m_IfState.type == I_CHAOSBOX )
; 27751: 	//{
; 27752: 	//}
; 27753: 	
; 27754: 	//gObjViewportListProtocolDestroy(&gObj[aIndex]);
; 27755: 	lpObj->m_State = OBJST_DELCMD;

  000d0	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d3	c7 80 b8 01 00
	00 20 00 00 00	 mov	 DWORD PTR [eax+440], 32	; 00000020H

; 27756: 	gObj[aIndex].X = x;

  000dd	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ea	66 8b 55 10	 mov	 dx, WORD PTR _x$[ebp]
  000ee	66 89 94 01 04
	01 00 00	 mov	 WORD PTR [ecx+eax+260], dx

; 27757: 	gObj[aIndex].Y = y;

  000f6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00103	66 8b 55 14	 mov	 dx, WORD PTR _y$[ebp]
  00107	66 89 94 01 06
	01 00 00	 mov	 WORD PTR [ecx+eax+262], dx

; 27758: 	gObj[aIndex].TX = x;

  0010f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00116	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011c	66 8b 55 10	 mov	 dx, WORD PTR _x$[ebp]
  00120	66 89 94 01 20
	01 00 00	 mov	 WORD PTR [ecx+eax+288], dx

; 27759: #ifdef MODIFY_TELEPORT_TARGETPOSITION_BUGFIX
; 27760: 	gObj[aIndex].TY = y;

  00128	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0012f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00135	66 8b 55 14	 mov	 dx, WORD PTR _y$[ebp]
  00139	66 89 94 01 22
	01 00 00	 mov	 WORD PTR [ecx+eax+290], dx

; 27761: #else
; 27762: 	gObj[aIndex].TX = y;
; 27763: #endif // MODIFY_TELEPORT_TARGETPOSITION_BUGFIX
; 27764: 	gObj[aIndex].MapNumber = map;

  00141	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00148	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0014e	8a 55 0c	 mov	 dl, BYTE PTR _map$[ebp]
  00151	88 94 01 09 01
	00 00		 mov	 BYTE PTR [ecx+eax+265], dl

; 27765: 	gObj[aIndex].PathCount = 0;

  00158	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0015f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00165	c7 84 01 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+296], 0

; 27766: 	gObj[aIndex].Teleport  = 0;

  00170	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00177	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017d	c6 84 01 fc 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+508], 0

; 27767: 
; 27768: 	
; 27769: 	//gObjViewportListProtocolDestroy(&gObj[aIndex]);		
; 27770: 	//gObjClearViewport(&gObj[aIndex]);
; 27771: 	//gObjViewportClose(&gObj[aIndex]);
; 27772: 	gObjClearViewport(&gObj[aIndex]);

  00185	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0018c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00192	50		 push	 eax
  00193	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  00198	83 c4 04	 add	 esp, 4

; 27773: 	GCTeleportSend(&gObj[aIndex], 1, map, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);

  0019b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001a8	0f b6 94 01 08
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+264]
  001b0	52		 push	 edx
  001b1	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001be	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  001c6	52		 push	 edx
  001c7	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001d4	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  001dc	52		 push	 edx
  001dd	0f b6 45 0c	 movzx	 eax, BYTE PTR _map$[ebp]
  001e1	50		 push	 eax
  001e2	6a 01		 push	 1
  001e4	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  001eb	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f1	51		 push	 ecx
  001f2	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  001f7	83 c4 18	 add	 esp, 24			; 00000018H

; 27774: 	
; 27775: 	if( lpObj->m_Change >= 0 )

  001fa	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001fd	83 b8 a8 02 00
	00 00		 cmp	 DWORD PTR [eax+680], 0
  00204	7c 16		 jl	 SHORT $LN7@gObjTelepo

; 27776: 	{
; 27777: 		gObjViewportListProtocolCreate(&gObj[aIndex]);

  00206	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0020d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00213	50		 push	 eax
  00214	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00219	83 c4 04	 add	 esp, 4
$LN7@gObjTelepo:

; 27778: 	}
; 27779: 	gObj[aIndex].RegenMapNumber = map;

  0021c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00223	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00229	8a 55 0c	 mov	 dl, BYTE PTR _map$[ebp]
  0022c	88 94 01 00 02
	00 00		 mov	 BYTE PTR [ecx+eax+512], dl

; 27780: 	gObj[aIndex].RegenMapX = (BYTE)x;

  00233	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0023a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00240	8a 55 10	 mov	 dl, BYTE PTR _x$[ebp]
  00243	88 94 01 01 02
	00 00		 mov	 BYTE PTR [ecx+eax+513], dl

; 27781: 	gObj[aIndex].RegenMapY = (BYTE)y;		

  0024a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00251	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00257	8a 55 14	 mov	 dl, BYTE PTR _y$[ebp]
  0025a	88 94 01 02 02
	00 00		 mov	 BYTE PTR [ecx+eax+514], dl

; 27782: 	gObj[aIndex].RegenOk   = 1;

  00261	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00268	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0026e	c6 84 01 ff 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+511], 1
$LN1@gObjTelepo:

; 27783: 	//LogAddC(LOGC_RED,"%s  ", gObj[aIndex].Name);
; 27784: 
; 27785: 	//char szTemp[256];
; 27786: 	//wsprintf(szTemp, "%d %d   .", x, y);
; 27787: 	//GCServerMsgStringSend(szTemp, aIndex, 1);
; 27788: }

  00276	5f		 pop	 edi
  00277	5e		 pop	 esi
  00278	5b		 pop	 ebx
  00279	8b e5		 mov	 esp, ebp
  0027b	5d		 pop	 ebp
  0027c	c3		 ret	 0
?gObjTeleport@@YAXHHHH@Z ENDP				; gObjTeleport
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMoveDataLoadingOK@@YAXH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjMoveDataLoadingOK@@YAXH@Z PROC			; gObjMoveDataLoadingOK, COMDAT

; 27797: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 27798: 	if( gObj[aIndex].RegenOk == 1 )

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	0f be 94 01 ff
	01 00 00	 movsx	 edx, BYTE PTR [ecx+eax+511]
  0001e	83 fa 01	 cmp	 edx, 1
  00021	75 15		 jne	 SHORT $LN1@gObjMoveDa

; 27799: 	{
; 27800: 		gObj[aIndex].RegenOk = 2;

  00023	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00030	c6 84 01 ff 01
	00 00 02	 mov	 BYTE PTR [ecx+eax+511], 2
$LN1@gObjMoveDa:

; 27801: 	}
; 27802: }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?gObjMoveDataLoadingOK@@YAXH@Z ENDP			; gObjMoveDataLoadingOK
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMoveGate@@YAHHH@Z
_TEXT	SEGMENT
tv522 = -688						; size = 4
tv513 = -688						; size = 4
tv133 = -688						; size = 4
tv523 = -684						; size = 4
tv514 = -684						; size = 4
tv134 = -684						; size = 4
_szTemp$1 = -552					; size = 256
_iKalimaGateIndex$2 = -296				; size = 4
_msg$3 = -292						; size = 255
_movefail$ = -36					; size = 4
_userlevel$ = -32					; size = 4
_level$ = -28						; size = 2
_dir$ = -22						; size = 1
_mapNumber$ = -21					; size = 1
_y$ = -20						; size = 2
_x$ = -16						; size = 2
_result$ = -12						; size = 4
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_gt$ = 12						; size = 4
?gObjMoveGate@@YAHHH@Z PROC				; gObjMoveGate, COMDAT

; 26768: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 02 00
	00		 sub	 esp, 688		; 000002b0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 26769: 	LPOBJECTSTRUCT lpObj;
; 26770: 	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  00016	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 26771: 
; 26772: 	int  result; 	
; 26773: 	short x, y;
; 26774: 	BYTE  mapNumber=0;

  00026	c6 45 eb 00	 mov	 BYTE PTR _mapNumber$[ebp], 0

; 26775: 	BYTE  dir;
; 26776: 	short level;
; 26777: 	int  userlevel = gObj[aIndex].Level;

  0002a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00037	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  0003f	89 55 e0	 mov	 DWORD PTR _userlevel$[ebp], edx

; 26778: 	int  movefail=0;

  00042	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 0

; 26779: 
; 26780: 
; 26781: #ifdef DARKLORD_WORK	
; 26782: 	if( gObj[aIndex].SkillRecallParty_Time )

  00049	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00050	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00056	0f b7 94 01 7c
	10 00 00	 movzx	 edx, WORD PTR [ecx+eax+4220]
  0005e	85 d2		 test	 edx, edx
  00060	74 4d		 je	 SHORT $LN2@gObjMoveGa

; 26783: 	{
; 26784: 		gObj[aIndex].SkillRecallParty_Time = 0;

  00062	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00069	33 c9		 xor	 ecx, ecx
  0006b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00071	66 89 8c 02 7c
	10 00 00	 mov	 WORD PTR [edx+eax+4220], cx

; 26785: 		char msg[255];
; 26786: 		wsprintf(msg, lMsg.Get(1254));	// ""

  00079	68 e6 04 00 00	 push	 1254			; 000004e6H
  0007e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00089	50		 push	 eax
  0008a	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _msg$3[ebp]
  00090	50		 push	 eax
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00097	83 c4 08	 add	 esp, 8

; 26787: 		GCServerMsgStringSend(msg, aIndex, 1);	

  0009a	6a 01		 push	 1
  0009c	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0009f	50		 push	 eax
  000a0	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _msg$3[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@gObjMoveGa:

; 26788: 	}
; 26789: #endif
; 26790: 
; 26791: #ifdef DARKLORD_WORK
; 26792: 	if( lpObj->Type == OBJTYPE_CHARACTER )

  000af	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b2	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  000b6	83 f9 01	 cmp	 ecx, 1
  000b9	75 15		 jne	 SHORT $LN3@gObjMoveGa

; 26793: 	{	//     
; 26794: 		gDarkSpirit[lpObj->m_Index].SetMode(CDarkSpirit::PetItem_Mode_Normal);

  000bb	6a ff		 push	 -1
  000bd	6a 00		 push	 0
  000bf	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c2	6b 08 28	 imul	 ecx, DWORD PTR [eax], 40
  000c5	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  000cb	e8 00 00 00 00	 call	 ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ; CDarkSpirit::SetMode
$LN3@gObjMoveGa:

; 26795: 	}
; 26796: #endif
; 26797: 
; 26798: #ifdef FOR_BLOODCASTLE
; 26799: 	if( CHECK_BLOODCASTLE(lpObj->MapNumber))

  000d0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d3	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000da	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  000dd	7d 0c		 jge	 SHORT $LN44@gObjMoveGa
  000df	c7 85 54 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv134[ebp], 0
  000e9	eb 31		 jmp	 SHORT $LN45@gObjMoveGa
$LN44@gObjMoveGa:
  000eb	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ee	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  000f5	83 f8 11	 cmp	 eax, 17			; 00000011H
  000f8	7e 0c		 jle	 SHORT $LN42@gObjMoveGa
  000fa	c7 85 50 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv133[ebp], 0
  00104	eb 0a		 jmp	 SHORT $LN43@gObjMoveGa
$LN42@gObjMoveGa:
  00106	c7 85 50 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv133[ebp], 1
$LN43@gObjMoveGa:
  00110	8b 8d 50 fd ff
	ff		 mov	 ecx, DWORD PTR tv133[ebp]
  00116	89 8d 54 fd ff
	ff		 mov	 DWORD PTR tv134[ebp], ecx
$LN45@gObjMoveGa:
  0011c	83 bd 54 fd ff
	ff 00		 cmp	 DWORD PTR tv134[ebp], 0
  00123	74 3f		 je	 SHORT $LN4@gObjMoveGa

; 26800: 	{	
; 26801: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 26802: 		int iBridgeIndex = g_BloodCastle.GetBridgeIndexByMapNum( lpObj->MapNumber );
; 26803: 		if (g_BloodCastle.GetCurrentState(iBridgeIndex) == BLOODCASTLE_STATE_PLAYING) {
; 26804: #else
; 26805: 		if (g_BloodCastle.GetCurrentState(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1) == BLOODCASTLE_STATE_PLAYING) {

  00125	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00128	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0012f	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00132	51		 push	 ecx
  00133	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00138	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  0013d	83 f8 02	 cmp	 eax, 2
  00140	75 12		 jne	 SHORT $LN5@gObjMoveGa

; 26806: #endif
; 26807: 			//         .
; 26808: 			g_BloodCastle.SearchUserDropQuestItem (lpObj->m_Index);

  00142	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00145	8b 08		 mov	 ecx, DWORD PTR [eax]
  00147	51		 push	 ecx
  00148	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0014d	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem

; 26809: 		}

  00152	eb 10		 jmp	 SHORT $LN4@gObjMoveGa
$LN5@gObjMoveGa:

; 26810: 		else {
; 26811: 			//         .
; 26812: 			g_BloodCastle.SearchUserDeleteQuestItem(lpObj->m_Index);

  00154	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00157	8b 08		 mov	 ecx, DWORD PTR [eax]
  00159	51		 push	 ecx
  0015a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0015f	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN4@gObjMoveGa:

; 26813: 		}
; 26814: 	}
; 26815: #endif
; 26816: 
; 26817: 	//if( gObj[aIndex].m_MoveGateNumber>=0 ) return;
; 26818: 	if( gObj[aIndex].RegenOk ) 

  00164	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0016b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00171	0f be 94 01 ff
	01 00 00	 movsx	 edx, BYTE PTR [ecx+eax+511]
  00179	85 d2		 test	 edx, edx
  0017b	0f 84 37 01 00
	00		 je	 $LN7@gObjMoveGa

; 26819: 	{
; 26820: 		LogAdd("Regen OK %s %d", __FILE__, __LINE__);

  00181	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjMoveGate@@YAHHH@Z@4JA
  00186	83 c0 34	 add	 eax, 52			; 00000034H
  00189	50		 push	 eax
  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0018f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EEJEJBPC@Regen?5OK?5?$CFs?5?$CFd@
  00194	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0019a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 26821: 		x = lpObj->X;

  0019d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a0	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  001a7	66 89 4d f0	 mov	 WORD PTR _x$[ebp], cx

; 26822: 		y = lpObj->Y;

  001ab	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ae	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  001b5	66 89 4d ec	 mov	 WORD PTR _y$[ebp], cx

; 26823: 		mapNumber = lpObj->MapNumber;

  001b9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001bc	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  001c2	88 4d eb	 mov	 BYTE PTR _mapNumber$[ebp], cl

; 26824: 		dir  = lpObj->Dir;

  001c5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c8	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  001ce	88 4d ea	 mov	 BYTE PTR _dir$[ebp], cl

; 26825: 		movefail = 1;		

  001d1	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 1

; 26826: 		lpObj->RegenMapNumber = lpObj->MapNumber;

  001d8	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001db	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001de	8a 91 09 01 00
	00		 mov	 dl, BYTE PTR [ecx+265]
  001e4	88 90 00 02 00
	00		 mov	 BYTE PTR [eax+512], dl

; 26827: 		lpObj->RegenMapX = (BYTE)x;

  001ea	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ed	8a 4d f0	 mov	 cl, BYTE PTR _x$[ebp]
  001f0	88 88 01 02 00
	00		 mov	 BYTE PTR [eax+513], cl

; 26828: 		lpObj->RegenMapY = (BYTE)y;		

  001f6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f9	8a 4d ec	 mov	 cl, BYTE PTR _y$[ebp]
  001fc	88 88 02 02 00
	00		 mov	 BYTE PTR [eax+514], cl

; 26829: 		gObjClearViewport(&gObj[aIndex]);

  00202	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00209	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0020f	50		 push	 eax
  00210	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  00215	83 c4 04	 add	 esp, 4

; 26830: 		GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);

  00218	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0021f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00225	0f b6 94 01 08
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+264]
  0022d	52		 push	 edx
  0022e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00235	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0023b	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00243	52		 push	 edx
  00244	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0024b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00251	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  00259	52		 push	 edx
  0025a	0f b6 45 eb	 movzx	 eax, BYTE PTR _mapNumber$[ebp]
  0025e	50		 push	 eax
  0025f	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _gt$[ebp]
  00263	51		 push	 ecx
  00264	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0026b	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00271	52		 push	 edx
  00272	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  00277	83 c4 18	 add	 esp, 24			; 00000018H

; 26831: 
; 26832: 		if( lpObj->m_Change >= 0 )

  0027a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0027d	83 b8 a8 02 00
	00 00		 cmp	 DWORD PTR [eax+680], 0
  00284	7c 16		 jl	 SHORT $LN8@gObjMoveGa

; 26833: 		{
; 26834: 			gObjViewportListProtocolCreate(&gObj[aIndex]);

  00286	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0028d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00293	50		 push	 eax
  00294	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00299	83 c4 04	 add	 esp, 4
$LN8@gObjMoveGa:

; 26835: 		}
; 26836: 		gObj[aIndex].RegenOk   = 1;

  0029c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  002a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002a9	c6 84 01 ff 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+511], 1

; 26837: 		return FALSE;

  002b1	33 c0		 xor	 eax, eax
  002b3	e9 08 0d 00 00	 jmp	 $LN1@gObjMoveGa
$LN7@gObjMoveGa:

; 26838: 	}
; 26839: 
; 26840: 	if( gGateC.IsGate(gt) == FALSE ) 

  002b8	8b 45 0c	 mov	 eax, DWORD PTR _gt$[ebp]
  002bb	50		 push	 eax
  002bc	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  002c1	e8 00 00 00 00	 call	 ?IsGate@CGate@@QAEHH@Z	; CGate::IsGate
  002c6	85 c0		 test	 eax, eax
  002c8	0f 85 47 01 00
	00		 jne	 $LN9@gObjMoveGa

; 26841: 	{
; 26842: 		LogAdd(lMsg.Get(545), gt, __FILE__, __LINE__);

  002ce	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjMoveGate@@YAHHH@Z@4JA
  002d3	83 c0 4a	 add	 eax, 74			; 0000004aH
  002d6	50		 push	 eax
  002d7	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  002dc	8b 4d 0c	 mov	 ecx, DWORD PTR _gt$[ebp]
  002df	51		 push	 ecx
  002e0	68 21 02 00 00	 push	 545			; 00000221H
  002e5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002f0	50		 push	 eax
  002f1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002f7	83 c4 10	 add	 esp, 16			; 00000010H

; 26843: 		x = lpObj->X;

  002fa	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002fd	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  00304	66 89 4d f0	 mov	 WORD PTR _x$[ebp], cx

; 26844: 		y = lpObj->Y;

  00308	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030b	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  00312	66 89 4d ec	 mov	 WORD PTR _y$[ebp], cx

; 26845: 		mapNumber = lpObj->MapNumber;

  00316	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00319	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  0031f	88 4d eb	 mov	 BYTE PTR _mapNumber$[ebp], cl

; 26846: 		dir  = lpObj->Dir;

  00322	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00325	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  0032b	88 4d ea	 mov	 BYTE PTR _dir$[ebp], cl

; 26847: 		movefail = 1;

  0032e	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 1

; 26848: 		lpObj->RegenMapNumber = lpObj->MapNumber;

  00335	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00338	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0033b	8a 91 09 01 00
	00		 mov	 dl, BYTE PTR [ecx+265]
  00341	88 90 00 02 00
	00		 mov	 BYTE PTR [eax+512], dl

; 26849: 		lpObj->RegenMapX = (BYTE)x;

  00347	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0034a	8a 4d f0	 mov	 cl, BYTE PTR _x$[ebp]
  0034d	88 88 01 02 00
	00		 mov	 BYTE PTR [eax+513], cl

; 26850: 		lpObj->RegenMapY = (BYTE)y;		

  00353	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00356	8a 4d ec	 mov	 cl, BYTE PTR _y$[ebp]
  00359	88 88 02 02 00
	00		 mov	 BYTE PTR [eax+514], cl

; 26851: 		gObjClearViewport(&gObj[aIndex]);

  0035f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00366	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0036c	50		 push	 eax
  0036d	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  00372	83 c4 04	 add	 esp, 4

; 26852: 		GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);

  00375	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0037c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00382	0f b6 94 01 08
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+264]
  0038a	52		 push	 edx
  0038b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00392	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00398	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  003a0	52		 push	 edx
  003a1	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003ae	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  003b6	52		 push	 edx
  003b7	0f b6 45 eb	 movzx	 eax, BYTE PTR _mapNumber$[ebp]
  003bb	50		 push	 eax
  003bc	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _gt$[ebp]
  003c0	51		 push	 ecx
  003c1	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  003c8	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003ce	52		 push	 edx
  003cf	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  003d4	83 c4 18	 add	 esp, 24			; 00000018H

; 26853: 
; 26854: 		if( lpObj->m_Change >= 0 )

  003d7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003da	83 b8 a8 02 00
	00 00		 cmp	 DWORD PTR [eax+680], 0
  003e1	7c 16		 jl	 SHORT $LN10@gObjMoveGa

; 26855: 		{
; 26856: 			gObjViewportListProtocolCreate(&gObj[aIndex]);

  003e3	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003ea	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003f0	50		 push	 eax
  003f1	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  003f6	83 c4 04	 add	 esp, 4
$LN10@gObjMoveGa:

; 26857: 		}
; 26858: 		gObj[aIndex].RegenOk   = 1;

  003f9	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00400	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00406	c6 84 01 ff 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+511], 1

; 26859: 		return FALSE;

  0040e	33 c0		 xor	 eax, eax
  00410	e9 ab 0b 00 00	 jmp	 $LN1@gObjMoveGa
$LN9@gObjMoveGa:

; 26860: 	}	
; 26861: 
; 26862: 	if(gt == 58 && gObj[aIndex].m_stateEngagePVP == PVP_USER_PLAYING)

  00415	83 7d 0c 3a	 cmp	 DWORD PTR _gt$[ebp], 58	; 0000003aH
  00419	75 19		 jne	 SHORT $LN11@gObjMoveGa
  0041b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00422	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00428	83 bc 01 80 1a
	00 00 02	 cmp	 DWORD PTR [ecx+eax+6784], 2
  00430	75 02		 jne	 SHORT $LN11@gObjMoveGa

; 26863: 	{
; 26864: 
; 26865: 	}

  00432	eb 73		 jmp	 SHORT $LN12@gObjMoveGa
$LN11@gObjMoveGa:

; 26866: #if TESTSERVER == 0
; 26867: #ifdef ADD_DEVILSQURE_FOR_MASTER_LEVEL_20071010		//    
; 26868: 	else if( ( gt >= 58 && gt <= 61 ) || gt == 111 || gt == 112 || gt == 270 )
; 26869: #else
; 26870: 	else if( gt >= 58 && gt <= 61 )

  00434	83 7d 0c 3a	 cmp	 DWORD PTR _gt$[ebp], 58	; 0000003aH
  00438	7c 6d		 jl	 SHORT $LN12@gObjMoveGa
  0043a	83 7d 0c 3d	 cmp	 DWORD PTR _gt$[ebp], 61	; 0000003dH
  0043e	7f 67		 jg	 SHORT $LN12@gObjMoveGa

; 26871: #endif
; 26872: 	{	//   ..  ,  
; 26873: 		if( gObj[aIndex].m_bDevilSquareAuth == FALSE )

  00440	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00447	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0044d	0f b6 94 01 d1
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3281]
  00455	85 d2		 test	 edx, edx
  00457	75 39		 jne	 SHORT $LN14@gObjMoveGa

; 26874: 		{
; 26875: 			LogAddTD("[DevilSquare] [%s][%s] Not Used DevilSquare Invitation In DevilSquare",

  00459	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00460	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00466	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0046a	52		 push	 edx
  0046b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00472	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00478	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0047c	52		 push	 edx
  0047d	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@IKFPGELB@?$FLDevilSquare?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Not?5Used@
  00482	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00488	83 c4 0c	 add	 esp, 12			; 0000000cH

; 26876: 				gObj[aIndex].AccountID, gObj[aIndex].Name);
; 26877: 			return FALSE;

  0048b	33 c0		 xor	 eax, eax
  0048d	e9 2e 0b 00 00	 jmp	 $LN1@gObjMoveGa
$LN14@gObjMoveGa:

; 26878: 		}
; 26879: 
; 26880: 		gObj[aIndex].m_bDevilSquareAuth = FALSE;

  00492	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00499	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0049f	c6 84 01 d1 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3281], 0
$LN12@gObjMoveGa:

; 26881: 	}
; 26882: #endif
; 26883: 
; 26884: 
; 26885: #ifdef ADD_SEASON_3_NEW_MAP_20070910
; 26886: 	lpObj->m_MoveGateNumber = (short)gt;
; 26887: #else
; 26888: 	lpObj->m_MoveGateNumber = (BYTE)gt;

  004a7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004aa	8a 4d 0c	 mov	 cl, BYTE PTR _gt$[ebp]
  004ad	88 88 a0 01 00
	00		 mov	 BYTE PTR [eax+416], cl

; 26889: #endif	
; 26890: 	result = gGateC.GetGate(gt, x, y, mapNumber, dir, level);

  004b3	8d 45 e4	 lea	 eax, DWORD PTR _level$[ebp]
  004b6	50		 push	 eax
  004b7	8d 4d ea	 lea	 ecx, DWORD PTR _dir$[ebp]
  004ba	51		 push	 ecx
  004bb	8d 55 eb	 lea	 edx, DWORD PTR _mapNumber$[ebp]
  004be	52		 push	 edx
  004bf	8d 45 ec	 lea	 eax, DWORD PTR _y$[ebp]
  004c2	50		 push	 eax
  004c3	8d 4d f0	 lea	 ecx, DWORD PTR _x$[ebp]
  004c6	51		 push	 ecx
  004c7	8b 55 0c	 mov	 edx, DWORD PTR _gt$[ebp]
  004ca	52		 push	 edx
  004cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  004d0	e8 00 00 00 00	 call	 ?GetGate@CGate@@QAEHHAAF0AAE10@Z ; CGate::GetGate
  004d5	89 45 f4	 mov	 DWORD PTR _result$[ebp], eax

; 26891: 	if( result < 0 )	

  004d8	83 7d f4 00	 cmp	 DWORD PTR _result$[ebp], 0
  004dc	7d 5b		 jge	 SHORT $LN15@gObjMoveGa

; 26892: 	{
; 26893: 		LogAdd("error : %d (%s %d)", result, __FILE__, __LINE__);

  004de	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjMoveGate@@YAHHH@Z@4JA
  004e3	83 c0 7d	 add	 eax, 125		; 0000007dH
  004e6	50		 push	 eax
  004e7	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  004ec	8b 4d f4	 mov	 ecx, DWORD PTR _result$[ebp]
  004ef	51		 push	 ecx
  004f0	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DHOELAFE@error?5?3?5?$CFd?5?$CI?$CFs?5?$CFd?$CJ@
  004f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  004fb	83 c4 10	 add	 esp, 16			; 00000010H

; 26894: 		x = lpObj->X;

  004fe	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00501	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  00508	66 89 4d f0	 mov	 WORD PTR _x$[ebp], cx

; 26895: 		y = lpObj->Y;

  0050c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0050f	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  00516	66 89 4d ec	 mov	 WORD PTR _y$[ebp], cx

; 26896: 		mapNumber = lpObj->MapNumber;

  0051a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0051d	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  00523	88 4d eb	 mov	 BYTE PTR _mapNumber$[ebp], cl

; 26897: 		dir  = lpObj->Dir;

  00526	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00529	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  0052f	88 4d ea	 mov	 BYTE PTR _dir$[ebp], cl

; 26898: 		movefail = 1;

  00532	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 1
$LN15@gObjMoveGa:

; 26899: 	}
; 26900: 
; 26901: #ifdef MODIFY_ITEM_DUPLICATION_IN_MAPSERVER_MOVING_20051219
; 26902: 	if( lpObj->m_bPShopOpen == TRUE )
; 26903: 	{
; 26904: 		BOOL bMove = TRUE;
; 26905: 
; 26906: 		//   :  -> 
; 26907: 		if( lpObj->MapNumber == MAP_INDEX_CASTLESIEGE 
; 26908: 			&& mapNumber == MAP_INDEX_RORENCIA )
; 26909: 		{
; 26910: 			bMove = FALSE;
; 26911: 		}
; 26912: 		//   :  -> 
; 26913: 		if( lpObj->MapNumber == MAP_INDEX_RORENCIA
; 26914: 			&& mapNumber == MAP_INDEX_CASTLESIEGE )
; 26915: 		{
; 26916: 			bMove = FALSE;
; 26917: 		}
; 26918: 
; 26919: 		if( bMove == FALSE )
; 26920: 		{
; 26921: 			LogAddTD("[PSHOP ITEM CLONNING] Move Failed : %d (%s %s)", result, lpObj->AccountID, lpObj->Name);
; 26922: 			x = lpObj->X;
; 26923: 			y = lpObj->Y;
; 26924: 			mapNumber = lpObj->MapNumber;
; 26925: 			dir  = lpObj->Dir;
; 26926: 			movefail = 1;
; 26927: 
; 26928: #ifdef MODIFY_MAPMOVE_SET_REGEN_POSITION_20060905
; 26929: 			lpObj->RegenMapX = x;
; 26930: 			lpObj->RegenMapY = y;
; 26931: 			lpObj->RegenMapNumber = mapNumber;
; 26932: #endif // MODIFY_MAPMOVE_SET_REGEN_POSITION_20060905
; 26933: 
; 26934: #ifdef FOR_KOREA
; 26935: 			// MODIFY_LOCALIZING_WTF_20060309  wtf   0.99.60 - 0.99.94
; 26936: 			MsgOutput( lpObj->m_Index, lMsg.Get(3356) );			// "     ."
; 26937: #endif
; 26938: 
; 26939: #ifdef MODIFY_MOVEGATE_CHECK_PERSONALSHOP_OPEN_20060704
; 26940: 			lpObj->RegenMapNumber = lpObj->MapNumber;
; 26941: 			lpObj->RegenMapX = (BYTE)x;
; 26942: 			lpObj->RegenMapY = (BYTE)y;		
; 26943: 			gObjClearViewport(&gObj[aIndex]);
; 26944: 			GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 26945: 
; 26946: 			if( lpObj->m_Change >= 0 )
; 26947: 			{
; 26948: 				gObjViewportListProtocolCreate(&gObj[aIndex]);
; 26949: 			}
; 26950: 
; 26951: 			gObj[aIndex].RegenOk   = 1;
; 26952: 			return FALSE;
; 26953: #endif // MODIFY_MOVEGATE_CHECK_PERSONALSHOP_OPEN_20060704
; 26954: 
; 26955: 		}
; 26956: 	}
; 26957: 
; 26958: #endif // MODIFY_ITEM_DUPLICATION_IN_MAPSERVER_MOVING_20051219
; 26959: 
; 26960: 	// , ,     .(apple)
; 26961: #ifdef MODIFY_NPC_SHADOW_PAHTOM_20050628
; 26962: 	if( CHECK_BLOODCASTLE(mapNumber) 
; 26963: 		|| CHECK_CHAOSCASTLE(mapNumber) 
; 26964: 		|| CHECK_DEVILSQUARE(mapNumber)
; 26965: #ifdef MODIFY_SHADOW_PHANTOM_BUFF_IN_ILLUSION_TEMPLE_BUGFIX_20080731
; 26966: 		|| CHECK_ILLUSION_TEMPLE(mapNumber)
; 26967: #endif // MODIFY_SHADOW_PHANTOM_BUFF_IN_ILLUSION_TEMPLE_BUGFIX_20080731
; 26968: 		)
; 26969: 	{
; 26970: #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 26971: 		if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_ATTDEF_POWER_INC ) == true )
; 26972: 		{
; 26973: 			gObjRemoveBuffEffect( lpObj, BUFFTYPE_ATTDEF_POWER_INC );
; 26974: 		}
; 26975: #else
; 26976: 		if(lpObj->m_iSkillNPCHelpTime > 0)
; 26977: 		{
; 26978: 			lpObj->m_iSkillNPCHelpTime = 0;
; 26979: 			lpObj->m_iSkillNPCDefense = 0; 
; 26980: 			lpObj->m_iSkillNPCAttack = 0;
; 26981: 
; 26982: 			DEL_VIEWSKILLSTATE(lpObj->m_ViewSkillState, STATE_NPC_HELP);
; 26983: 			GCStateInfoSend(lpObj, 0, STATE_NPC_HELP);
; 26984: 		}
; 26985: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 26986: #ifdef ADD_EVENT_MAP_BUFF_EFFECT_DELETE_20090421
; 26987: 		if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_ATTACK_POWER_INC ) == true )
; 26988: 		{	//  
; 26989: 			gObjRemoveBuffEffect( lpObj, BUFFTYPE_ATTACK_POWER_INC );
; 26990: 		}
; 26991: 		if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_DEFENSE_POWER_INC ) == true )
; 26992: 		{	//  
; 26993: 			gObjRemoveBuffEffect( lpObj, BUFFTYPE_DEFENSE_POWER_INC );
; 26994: 		}
; 26995: 		if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_CRITICAL_DMG_INC ) == true )
; 26996: 		{	//   
; 26997: 			gObjRemoveBuffEffect( lpObj, BUFFTYPE_CRITICAL_DMG_INC );
; 26998: 		}
; 26999: 		if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_HP_INC ) == true )
; 27000: 		{	// 
; 27001: 			gObjRemoveBuffEffect( lpObj, BUFFTYPE_HP_INC );
; 27002: 		}
; 27003: 		if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_MELEE_DEFENSE_INC ) == true )
; 27004: 		{	//  
; 27005: 			gObjRemoveBuffEffect( lpObj, BUFFTYPE_MELEE_DEFENSE_INC );
; 27006: 		}
; 27007: #endif // ADD_EVENT_MAP_BUFF_EFFECT_DELETE_20090421
; 27008: 	}
; 27009: #endif
; 27010: 
; 27011: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//    
; 27012: 	if( CHECK_ILLUSION_TEMPLE(lpObj->MapNumber) 
; 27013: 		&& mapNumber != lpObj->MapNumber )
; 27014: 	{
; 27015: 		g_IllusionTempleEvent.DropRelicsItem(lpObj->MapNumber, lpObj->m_Index);
; 27016: 		g_IllusionTempleEvent.LeaveIllusionTemple(lpObj->m_Index, lpObj->MapNumber);
; 27017: 	}
; 27018: #endif
; 27019: 
; 27020: #ifdef CASTLE_MAIN_SCHEDULER_20041111	//   -         .
; 27021: 	if (result == 97) {
; 27022: 		if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE) {
; 27023: 			if (lpObj->m_btCsJoinSide != CS_SIEGESIDE_DEFEND && g_CastleSiege.GetCastleTowerAccessable() == FALSE) {
; 27024: 				//      .
; 27025: 				GCServerMsgStringSend(lMsg.Get(1624), lpObj->m_Index, 1);	// "     ."
; 27026: 				x = lpObj->X;
; 27027: 				y = lpObj->Y;
; 27028: 				mapNumber = lpObj->MapNumber;
; 27029: 				dir  = lpObj->Dir;
; 27030: 				movefail = 1;
; 27031: 				lpObj->RegenMapNumber = lpObj->MapNumber;
; 27032: 				lpObj->RegenMapX = (BYTE)x;
; 27033: 				lpObj->RegenMapY = (BYTE)y;		
; 27034: 				gObjClearViewport(&gObj[aIndex]);
; 27035: 				GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 27036: 
; 27037: 				if( lpObj->m_Change >= 0 )
; 27038: 				{
; 27039: 					gObjViewportListProtocolCreate(&gObj[aIndex]);
; 27040: 				}
; 27041: 
; 27042: 				gObj[aIndex].RegenOk   = 1;
; 27043: 				return FALSE;
; 27044: 			}
; 27045: 			else if (lpObj->m_btCsJoinSide == CS_SIEGESIDE_NONE) {
; 27046: 				//      .
; 27047: 				GCServerMsgStringSend(lMsg.Get(1625), lpObj->m_Index, 1);	// "   ."
; 27048: 				x = lpObj->X;
; 27049: 				y = lpObj->Y;
; 27050: 				mapNumber = lpObj->MapNumber;
; 27051: 				dir  = lpObj->Dir;
; 27052: 				movefail = 1;
; 27053: 				lpObj->RegenMapNumber = lpObj->MapNumber;
; 27054: 				lpObj->RegenMapX = (BYTE)x;
; 27055: 				lpObj->RegenMapY = (BYTE)y;		
; 27056: 				gObjClearViewport(&gObj[aIndex]);
; 27057: 				GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 27058: 
; 27059: 				if( lpObj->m_Change >= 0 )
; 27060: 				{
; 27061: 					gObjViewportListProtocolCreate(&gObj[aIndex]);
; 27062: 				}
; 27063: 
; 27064: 				gObj[aIndex].RegenOk   = 1;
; 27065: 				return FALSE;
; 27066: 			}
; 27067: 		}
; 27068: 		else {
; 27069: 			if (g_CastleSiege.CheckCastleOwnerUnionMember (lpObj->m_Index) == FALSE) {
; 27070: 				//       .
; 27071: 				GCServerMsgStringSend(lMsg.Get(1626), lpObj->m_Index, 1);	// "      ."
; 27072: 				x = lpObj->X;
; 27073: 				y = lpObj->Y;
; 27074: 				mapNumber = lpObj->MapNumber;
; 27075: 				dir  = lpObj->Dir;
; 27076: 				movefail = 1;
; 27077: 				lpObj->RegenMapNumber = lpObj->MapNumber;
; 27078: 				lpObj->RegenMapX = (BYTE)x;
; 27079: 				lpObj->RegenMapY = (BYTE)y;		
; 27080: 				gObjClearViewport(&gObj[aIndex]);
; 27081: 				GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 27082: 
; 27083: 				if( lpObj->m_Change >= 0 )
; 27084: 				{
; 27085: 					gObjViewportListProtocolCreate(&gObj[aIndex]);
; 27086: 				}
; 27087: 
; 27088: 				gObj[aIndex].RegenOk   = 1;
; 27089: 				return FALSE;
; 27090: 			}
; 27091: 		}
; 27092: 	}
; 27093: #endif	
; 27094: 
; 27095: #ifdef NEW_SKILL_FORSKYLAND
; 27096: 	if( mapNumber == MAP_INDEX_ATHLANSE )	//       

  00539	0f b6 45 eb	 movzx	 eax, BYTE PTR _mapNumber$[ebp]
  0053d	83 f8 07	 cmp	 eax, 7
  00540	0f 85 ea 02 00
	00		 jne	 $LN16@gObjMoveGa

; 27097: #else
; 27098: 	if( mapNumber == MAP_INDEX_ATHLANSE )
; 27099: #endif
; 27100: 	{	//       
; 27101: 		if( lpObj->pInventory[EQUIPMENT_HELPER].IsItem())

  00546	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  0054b	c1 e1 03	 shl	 ecx, 3
  0054e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00551	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00557	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0055c	85 c0		 test	 eax, eax
  0055e	0f 84 cc 02 00
	00		 je	 $LN16@gObjMoveGa

; 27102: 		{							
; 27103: 			if( lpObj->pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,2) )

  00564	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00569	c1 e0 03	 shl	 eax, 3
  0056c	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0056f	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00575	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  0057a	6a 02		 push	 2
  0057c	6a 0d		 push	 13			; 0000000dH
  0057e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00583	83 c4 08	 add	 esp, 8
  00586	3b f0		 cmp	 esi, eax
  00588	0f 85 3c 01 00
	00		 jne	 $LN18@gObjMoveGa

; 27104: 			{
; 27105: 				GCServerMsgStringSend(lMsg.Get(702), lpObj->m_Index, 1);

  0058e	6a 01		 push	 1
  00590	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00593	8b 08		 mov	 ecx, DWORD PTR [eax]
  00595	51		 push	 ecx
  00596	68 be 02 00 00	 push	 702			; 000002beH
  0059b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  005a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  005a6	50		 push	 eax
  005a7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  005ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 27106: 				x = lpObj->X;

  005af	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005b2	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  005b9	66 89 4d f0	 mov	 WORD PTR _x$[ebp], cx

; 27107: 				y = lpObj->Y;

  005bd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005c0	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  005c7	66 89 4d ec	 mov	 WORD PTR _y$[ebp], cx

; 27108: 				mapNumber = lpObj->MapNumber;

  005cb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005ce	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  005d4	88 4d eb	 mov	 BYTE PTR _mapNumber$[ebp], cl

; 27109: 				dir  = lpObj->Dir;

  005d7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005da	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  005e0	88 4d ea	 mov	 BYTE PTR _dir$[ebp], cl

; 27110: 				movefail = 1;

  005e3	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 1

; 27111: 				lpObj->RegenMapNumber = lpObj->MapNumber;

  005ea	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005ed	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005f0	8a 91 09 01 00
	00		 mov	 dl, BYTE PTR [ecx+265]
  005f6	88 90 00 02 00
	00		 mov	 BYTE PTR [eax+512], dl

; 27112: 				lpObj->RegenMapX = (BYTE)x;

  005fc	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005ff	8a 4d f0	 mov	 cl, BYTE PTR _x$[ebp]
  00602	88 88 01 02 00
	00		 mov	 BYTE PTR [eax+513], cl

; 27113: 				lpObj->RegenMapY = (BYTE)y;		

  00608	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0060b	8a 4d ec	 mov	 cl, BYTE PTR _y$[ebp]
  0060e	88 88 02 02 00
	00		 mov	 BYTE PTR [eax+514], cl

; 27114: 				gObjClearViewport(&gObj[aIndex]);

  00614	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0061b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00621	50		 push	 eax
  00622	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  00627	83 c4 04	 add	 esp, 4

; 27115: 				GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);

  0062a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00631	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00637	0f b6 94 01 08
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+264]
  0063f	52		 push	 edx
  00640	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00647	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0064d	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00655	52		 push	 edx
  00656	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0065d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00663	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  0066b	52		 push	 edx
  0066c	0f b6 45 eb	 movzx	 eax, BYTE PTR _mapNumber$[ebp]
  00670	50		 push	 eax
  00671	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _gt$[ebp]
  00675	51		 push	 ecx
  00676	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0067d	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00683	52		 push	 edx
  00684	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  00689	83 c4 18	 add	 esp, 24			; 00000018H

; 27116: 
; 27117: 				if( lpObj->m_Change >= 0 )

  0068c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0068f	83 b8 a8 02 00
	00 00		 cmp	 DWORD PTR [eax+680], 0
  00696	7c 16		 jl	 SHORT $LN19@gObjMoveGa

; 27118: 				{
; 27119: 					gObjViewportListProtocolCreate(&gObj[aIndex]);

  00698	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0069f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006a5	50		 push	 eax
  006a6	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  006ab	83 c4 04	 add	 esp, 4
$LN19@gObjMoveGa:

; 27120: 				}
; 27121: 
; 27122: 				gObj[aIndex].RegenOk   = 1;

  006ae	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  006b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006bb	c6 84 01 ff 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+511], 1

; 27123: 				return FALSE;

  006c3	33 c0		 xor	 eax, eax
  006c5	e9 f6 08 00 00	 jmp	 $LN1@gObjMoveGa
$LN18@gObjMoveGa:

; 27124: 			}
; 27125: 
; 27126: 			if( lpObj->pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,3) )

  006ca	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  006cf	c1 e0 03	 shl	 eax, 3
  006d2	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  006d5	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  006db	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  006e0	6a 03		 push	 3
  006e2	6a 0d		 push	 13			; 0000000dH
  006e4	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  006e9	83 c4 08	 add	 esp, 8
  006ec	3b f0		 cmp	 esi, eax
  006ee	0f 85 3c 01 00
	00		 jne	 $LN16@gObjMoveGa

; 27127: 			{
; 27128: 				GCServerMsgStringSend(lMsg.Get(1604), lpObj->m_Index, 1);

  006f4	6a 01		 push	 1
  006f6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  006fb	51		 push	 ecx
  006fc	68 44 06 00 00	 push	 1604			; 00000644H
  00701	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00706	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0070c	50		 push	 eax
  0070d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00712	83 c4 0c	 add	 esp, 12			; 0000000cH

; 27129: 				x = lpObj->X;

  00715	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00718	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  0071f	66 89 4d f0	 mov	 WORD PTR _x$[ebp], cx

; 27130: 				y = lpObj->Y;

  00723	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00726	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  0072d	66 89 4d ec	 mov	 WORD PTR _y$[ebp], cx

; 27131: 				mapNumber = lpObj->MapNumber;

  00731	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00734	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  0073a	88 4d eb	 mov	 BYTE PTR _mapNumber$[ebp], cl

; 27132: 				dir  = lpObj->Dir;

  0073d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00740	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  00746	88 4d ea	 mov	 BYTE PTR _dir$[ebp], cl

; 27133: 				movefail = 1;

  00749	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 1

; 27134: 				lpObj->RegenMapNumber = lpObj->MapNumber;

  00750	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00753	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00756	8a 91 09 01 00
	00		 mov	 dl, BYTE PTR [ecx+265]
  0075c	88 90 00 02 00
	00		 mov	 BYTE PTR [eax+512], dl

; 27135: 				lpObj->RegenMapX = (BYTE)x;

  00762	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00765	8a 4d f0	 mov	 cl, BYTE PTR _x$[ebp]
  00768	88 88 01 02 00
	00		 mov	 BYTE PTR [eax+513], cl

; 27136: 				lpObj->RegenMapY = (BYTE)y;		

  0076e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00771	8a 4d ec	 mov	 cl, BYTE PTR _y$[ebp]
  00774	88 88 02 02 00
	00		 mov	 BYTE PTR [eax+514], cl

; 27137: 				gObjClearViewport(&gObj[aIndex]);

  0077a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00781	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00787	50		 push	 eax
  00788	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  0078d	83 c4 04	 add	 esp, 4

; 27138: 				GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);

  00790	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00797	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0079d	0f b6 94 01 08
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+264]
  007a5	52		 push	 edx
  007a6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  007ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007b3	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  007bb	52		 push	 edx
  007bc	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  007c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007c9	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  007d1	52		 push	 edx
  007d2	0f b6 45 eb	 movzx	 eax, BYTE PTR _mapNumber$[ebp]
  007d6	50		 push	 eax
  007d7	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _gt$[ebp]
  007db	51		 push	 ecx
  007dc	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  007e3	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007e9	52		 push	 edx
  007ea	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  007ef	83 c4 18	 add	 esp, 24			; 00000018H

; 27139: 
; 27140: 				if( lpObj->m_Change >= 0 )

  007f2	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007f5	83 b8 a8 02 00
	00 00		 cmp	 DWORD PTR [eax+680], 0
  007fc	7c 16		 jl	 SHORT $LN21@gObjMoveGa

; 27141: 				{
; 27142: 					gObjViewportListProtocolCreate(&gObj[aIndex]);

  007fe	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00805	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0080b	50		 push	 eax
  0080c	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00811	83 c4 04	 add	 esp, 4
$LN21@gObjMoveGa:

; 27143: 				}
; 27144: 				gObj[aIndex].RegenOk   = 1;

  00814	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0081b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00821	c6 84 01 ff 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+511], 1

; 27145: 				return FALSE;

  00829	33 c0		 xor	 eax, eax
  0082b	e9 90 07 00 00	 jmp	 $LN1@gObjMoveGa
$LN16@gObjMoveGa:

; 27146: 			}
; 27147: 		}
; 27148: 	}
; 27149: 
; 27150: #ifdef NEW_SKILL_FORSKYLAND	
; 27151: 	if( mapNumber == MAP_INDEX_ICARUS )

  00830	0f b6 45 eb	 movzx	 eax, BYTE PTR _mapNumber$[ebp]
  00834	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00837	0f 85 6c 02 00
	00		 jne	 $LN22@gObjMoveGa

; 27152: 	{
; 27153: 		if( (lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,3) && 
; 27154: #ifdef DARKLORD_WORK
; 27155: 			lpObj->pInventory[EQUIPMENT_WING].m_Type != MAKE_ITEMNUM(13,30) &&	// 
; 27156: #endif
; 27157: #ifdef ADD_ITEM_FENRIR_01_20051110
; 27158: 			lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,37) &&	// 
; 27159: #endif
; 27160: #ifdef MODIFY_SKYLAND_FENRIR_AND_WING_BUGFIX_20080730
; 27161: 			lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,4) &&	// 
; 27162: #endif // MODIFY_SKYLAND_FENRIR_AND_WING_BUGFIX_20080730
; 27163: #ifdef ADD_THIRD_WING_20070525	//    3 
; 27164: 			(  lpObj->pInventory[EQUIPMENT_WING].IsItem() == FALSE ))	|| //  
; 27165: #else
; 27166: 			(lpObj->pInventory[EQUIPMENT_WING].m_Type < MAKE_ITEMNUM(12,0) || lpObj->pInventory[EQUIPMENT_WING].m_Type > MAKE_ITEMNUM(12,6) )) ||
; 27167: #endif
; 27168: 			lpObj->pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,2) ||
; 27169: 			lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM(13,10) ||

  0083d	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00842	c1 e0 03	 shl	 eax, 3
  00845	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00848	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0084e	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00853	6a 03		 push	 3
  00855	6a 0d		 push	 13			; 0000000dH
  00857	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0085c	83 c4 08	 add	 esp, 8
  0085f	3b f0		 cmp	 esi, eax
  00861	74 76		 je	 SHORT $LN25@gObjMoveGa
  00863	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00868	6b c8 07	 imul	 ecx, eax, 7
  0086b	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0086e	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00874	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00879	6a 1e		 push	 30			; 0000001eH
  0087b	6a 0d		 push	 13			; 0000000dH
  0087d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00882	83 c4 08	 add	 esp, 8
  00885	3b f0		 cmp	 esi, eax
  00887	74 50		 je	 SHORT $LN25@gObjMoveGa
  00889	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0088e	6b c8 07	 imul	 ecx, eax, 7
  00891	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00894	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0089a	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0089f	6a 00		 push	 0
  008a1	6a 0c		 push	 12			; 0000000cH
  008a3	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  008a8	83 c4 08	 add	 esp, 8
  008ab	3b f0		 cmp	 esi, eax
  008ad	0f 8c 9c 00 00
	00		 jl	 $LN24@gObjMoveGa
  008b3	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  008b8	6b c8 07	 imul	 ecx, eax, 7
  008bb	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008be	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  008c4	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  008c9	6a 06		 push	 6
  008cb	6a 0c		 push	 12			; 0000000cH
  008cd	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  008d2	83 c4 08	 add	 esp, 8
  008d5	3b f0		 cmp	 esi, eax
  008d7	7f 76		 jg	 SHORT $LN24@gObjMoveGa
$LN25@gObjMoveGa:
  008d9	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  008de	c1 e0 03	 shl	 eax, 3
  008e1	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  008e4	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  008ea	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  008ef	6a 02		 push	 2
  008f1	6a 0d		 push	 13			; 0000000dH
  008f3	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  008f8	83 c4 08	 add	 esp, 8
  008fb	3b f0		 cmp	 esi, eax
  008fd	74 50		 je	 SHORT $LN24@gObjMoveGa
  008ff	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00904	6b c8 0b	 imul	 ecx, eax, 11
  00907	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0090a	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00910	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00915	6a 0a		 push	 10			; 0000000aH
  00917	6a 0d		 push	 13			; 0000000dH
  00919	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0091e	83 c4 08	 add	 esp, 8
  00921	3b f0		 cmp	 esi, eax
  00923	74 2a		 je	 SHORT $LN24@gObjMoveGa
  00925	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0092a	6b c8 0a	 imul	 ecx, eax, 10
  0092d	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00930	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00936	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0093b	6a 0a		 push	 10			; 0000000aH
  0093d	6a 0d		 push	 13			; 0000000dH
  0093f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00944	83 c4 08	 add	 esp, 8
  00947	3b f0		 cmp	 esi, eax
  00949	0f 85 32 01 00
	00		 jne	 $LN23@gObjMoveGa
$LN24@gObjMoveGa:

; 27170: 			lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM(13,10) 
; 27171: #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	//   
; 27172: 			|| lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 39 )
; 27173: 			|| lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 39 ) 	
; 27174: #endif	
; 27175: #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 27176: 			|| lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 40 )
; 27177: 			|| lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 40 )
; 27178: #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 27179: #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 27180: 			|| lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 41 )
; 27181: 			|| lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 41 )
; 27182: #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 27183: #ifdef MODIFY_SNOW_MAN_PANDA_POLYMORPH_RING_BUGFIX_20090715
; 27184: 			|| lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 68 )
; 27185: 			|| lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 68 )
; 27186: 			|| lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 76 )
; 27187: 			|| lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 76 )
; 27188: #endif // MODIFY_SNOW_MAN_PANDA_POLYMORPH_RING_BUGFIX_20090715
; 27189: 			)
; 27190: 		{	//       
; 27191: 			GCServerMsgStringSend(lMsg.Get(1604), lpObj->m_Index, 1);

  0094f	6a 01		 push	 1
  00951	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00954	8b 08		 mov	 ecx, DWORD PTR [eax]
  00956	51		 push	 ecx
  00957	68 44 06 00 00	 push	 1604			; 00000644H
  0095c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00961	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00967	50		 push	 eax
  00968	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0096d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 27192: 			x = lpObj->X;

  00970	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00973	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  0097a	66 89 4d f0	 mov	 WORD PTR _x$[ebp], cx

; 27193: 			y = lpObj->Y;

  0097e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00981	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  00988	66 89 4d ec	 mov	 WORD PTR _y$[ebp], cx

; 27194: 			mapNumber = lpObj->MapNumber;

  0098c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0098f	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  00995	88 4d eb	 mov	 BYTE PTR _mapNumber$[ebp], cl

; 27195: 			dir  = lpObj->Dir;

  00998	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0099b	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  009a1	88 4d ea	 mov	 BYTE PTR _dir$[ebp], cl

; 27196: 			movefail = 1;

  009a4	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 1

; 27197: 			lpObj->RegenMapNumber = lpObj->MapNumber;

  009ab	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009ae	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  009b1	8a 91 09 01 00
	00		 mov	 dl, BYTE PTR [ecx+265]
  009b7	88 90 00 02 00
	00		 mov	 BYTE PTR [eax+512], dl

; 27198: 			lpObj->RegenMapX = (BYTE)x;

  009bd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009c0	8a 4d f0	 mov	 cl, BYTE PTR _x$[ebp]
  009c3	88 88 01 02 00
	00		 mov	 BYTE PTR [eax+513], cl

; 27199: 			lpObj->RegenMapY = (BYTE)y;		

  009c9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009cc	8a 4d ec	 mov	 cl, BYTE PTR _y$[ebp]
  009cf	88 88 02 02 00
	00		 mov	 BYTE PTR [eax+514], cl

; 27200: 
; 27201: 			//####### BUGFIX_CAT001    ,     
; 27202: 			//gObjClearViewport(&gObj[aIndex]); //      , 
; 27203: 			GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);

  009d5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  009dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009e2	0f b6 94 01 08
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+264]
  009ea	52		 push	 edx
  009eb	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  009f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009f8	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00a00	52		 push	 edx
  00a01	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a08	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a0e	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  00a16	52		 push	 edx
  00a17	0f b6 45 eb	 movzx	 eax, BYTE PTR _mapNumber$[ebp]
  00a1b	50		 push	 eax
  00a1c	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _gt$[ebp]
  00a20	51		 push	 ecx
  00a21	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00a28	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a2e	52		 push	 edx
  00a2f	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  00a34	83 c4 18	 add	 esp, 24			; 00000018H

; 27204: 
; 27205: 			//    			
; 27206: 			gObjClearViewportOfMine( lpObj );

  00a37	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a3a	50		 push	 eax
  00a3b	e8 00 00 00 00	 call	 ?gObjClearViewportOfMine@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewportOfMine
  00a40	83 c4 04	 add	 esp, 4

; 27207: 
; 27208: 			//BUGFIX_CAT001 ########
; 27209: 
; 27210: 			if( lpObj->m_Change >= 0 )

  00a43	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a46	83 b8 a8 02 00
	00 00		 cmp	 DWORD PTR [eax+680], 0
  00a4d	7c 16		 jl	 SHORT $LN26@gObjMoveGa

; 27211: 			{
; 27212: 				gObjViewportListProtocolCreate(&gObj[aIndex]);

  00a4f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a56	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a5c	50		 push	 eax
  00a5d	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00a62	83 c4 04	 add	 esp, 4
$LN26@gObjMoveGa:

; 27213: 			}
; 27214: 
; 27215: 			gObj[aIndex].RegenOk   = 1;

  00a65	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a6c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a72	c6 84 01 ff 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+511], 1

; 27216: 			return FALSE;

  00a7a	33 c0		 xor	 eax, eax
  00a7c	e9 3f 05 00 00	 jmp	 $LN1@gObjMoveGa
$LN23@gObjMoveGa:

; 27217: 		}
; 27218: 
; 27219: 		if( lpObj->m_RecallMon >= 0 ) 

  00a81	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a84	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  00a8b	7c 1c		 jl	 SHORT $LN22@gObjMoveGa

; 27220: 		{
; 27221: 			GCRecallMonLife(aIndex, 60, 0);

  00a8d	6a 00		 push	 0
  00a8f	6a 3c		 push	 60			; 0000003cH
  00a91	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00a94	50		 push	 eax
  00a95	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife
  00a9a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 27222: 			gObjMonsterCallKill(aIndex);

  00a9d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00aa0	50		 push	 eax
  00aa1	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  00aa6	83 c4 04	 add	 esp, 4
$LN22@gObjMoveGa:

; 27223: 		}
; 27224: 	}
; 27225: #endif
; 27226: 
; 27227: #ifdef ADD_NEW_MAP_KALIMA_20040518					//       .
; 27228: 	if( !CHECK_KALIMAMAP(mapNumber) &&

  00aa9	0f b6 45 eb	 movzx	 eax, BYTE PTR _mapNumber$[ebp]
  00aad	83 f8 18	 cmp	 eax, 24			; 00000018H
  00ab0	7d 0c		 jge	 SHORT $LN48@gObjMoveGa
  00ab2	c7 85 54 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv514[ebp], 0
  00abc	eb 2b		 jmp	 SHORT $LN49@gObjMoveGa
$LN48@gObjMoveGa:
  00abe	0f b6 4d eb	 movzx	 ecx, BYTE PTR _mapNumber$[ebp]
  00ac2	83 f9 1d	 cmp	 ecx, 29			; 0000001dH
  00ac5	7e 0c		 jle	 SHORT $LN46@gObjMoveGa
  00ac7	c7 85 50 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv513[ebp], 0
  00ad1	eb 0a		 jmp	 SHORT $LN47@gObjMoveGa
$LN46@gObjMoveGa:
  00ad3	c7 85 50 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv513[ebp], 1
$LN47@gObjMoveGa:
  00add	8b 95 50 fd ff
	ff		 mov	 edx, DWORD PTR tv513[ebp]
  00ae3	89 95 54 fd ff
	ff		 mov	 DWORD PTR tv514[ebp], edx
$LN49@gObjMoveGa:
  00ae9	83 bd 54 fd ff
	ff 00		 cmp	 DWORD PTR tv514[ebp], 0
  00af0	0f 85 b4 00 00
	00		 jne	 $LN28@gObjMoveGa
  00af6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00af9	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00b00	83 f9 18	 cmp	 ecx, 24			; 00000018H
  00b03	7d 0c		 jge	 SHORT $LN52@gObjMoveGa
  00b05	c7 85 54 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv523[ebp], 0
  00b0f	eb 31		 jmp	 SHORT $LN53@gObjMoveGa
$LN52@gObjMoveGa:
  00b11	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b14	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00b1b	83 f8 1d	 cmp	 eax, 29			; 0000001dH
  00b1e	7e 0c		 jle	 SHORT $LN50@gObjMoveGa
  00b20	c7 85 50 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR tv522[ebp], 0
  00b2a	eb 0a		 jmp	 SHORT $LN51@gObjMoveGa
$LN50@gObjMoveGa:
  00b2c	c7 85 50 fd ff
	ff 01 00 00 00	 mov	 DWORD PTR tv522[ebp], 1
$LN51@gObjMoveGa:
  00b36	8b 8d 50 fd ff
	ff		 mov	 ecx, DWORD PTR tv522[ebp]
  00b3c	89 8d 54 fd ff
	ff		 mov	 DWORD PTR tv523[ebp], ecx
$LN53@gObjMoveGa:
  00b42	83 bd 54 fd ff
	ff 00		 cmp	 DWORD PTR tv523[ebp], 0
  00b49	74 5f		 je	 SHORT $LN28@gObjMoveGa

; 27229: 		CHECK_KALIMAMAP(lpObj->MapNumber)
; 27230: 		) 
; 27231: 	{
; 27232: 		//  .
; 27233: 		INT iKalimaGateIndex = lpObj->m_iKalimaGateIndex;			//    

  00b4b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b4e	8b 88 28 02 00
	00		 mov	 ecx, DWORD PTR [eax+552]
  00b54	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _iKalimaGateIndex$2[ebp], ecx

; 27234: 		if (g_KalimaGate.DeleteKalimaGate(lpObj->m_Index)) {

  00b5a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b5d	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b5f	51		 push	 ecx
  00b60	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  00b65	e8 00 00 00 00	 call	 ?DeleteKalimaGate@CKalimaGate@@QAEHH@Z ; CKalimaGate::DeleteKalimaGate
  00b6a	85 c0		 test	 eax, eax
  00b6c	74 3c		 je	 SHORT $LN28@gObjMoveGa

; 27235: 			LogAddTD("[Kalima] [%s][%s] Kalima Gate Vanished - User MoveGate (SummonIndex:%d, EnterCount:%d)", 

  00b6e	69 85 d8 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iKalimaGateIndex$2[ebp], 7072
  00b78	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b7e	0f be 94 01 2c
	02 00 00	 movsx	 edx, BYTE PTR [ecx+eax+556]
  00b86	52		 push	 edx
  00b87	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _iKalimaGateIndex$2[ebp]
  00b8d	50		 push	 eax
  00b8e	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b91	83 c1 73	 add	 ecx, 115		; 00000073H
  00b94	51		 push	 ecx
  00b95	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b98	83 c2 68	 add	 edx, 104		; 00000068H
  00b9b	52		 push	 edx
  00b9c	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@OIJJJHHH@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@
  00ba1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00ba7	83 c4 14	 add	 esp, 20			; 00000014H
$LN28@gObjMoveGa:

; 27236: 				lpObj->AccountID, 
; 27237: 				lpObj->Name,
; 27238: 				iKalimaGateIndex,
; 27239: 				gObj[iKalimaGateIndex].m_cKalimaGateEnterCount
; 27240: 				);
; 27241: 		}
; 27242: 	}
; 27243: #endif
; 27244: 
; 27245: #ifdef ADD_KANTURU_CONDITION_20060725			
; 27246: 	if( mapNumber == MAP_INDEX_KANTURU_BOSS )
; 27247: 	{
; 27248: 		if( ( lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,3)			// 
; 27249: #ifdef ADD_ITEM_FENRIR_01_20051110
; 27250: 			&& lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,37)			// 
; 27251: #endif			
; 27252: #ifdef MODIFY_KANTURU_ENTERANCE_DARKHORSE_BUGFIX_20080627
; 27253: 			&& lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,4)				// 
; 27254: #endif // MODIFY_KANTURU_ENTERANCE_DARKHORSE_BUGFIX_20080627
; 27255: #ifdef ADD_THIRD_WING_20070525	//    3 	
; 27256: 			&& ( lpObj->pInventory[EQUIPMENT_WING].IsItem() == FALSE ) )	||	//  .
; 27257: #else
; 27258: 			) ||
; 27259: #endif
; 27260: 			lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM(13,10) ||		// 
; 27261: 			lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM(13,10)			// 
; 27262: #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	//   
; 27263: 			|| lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 39 )
; 27264: 			|| lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 39 )	
; 27265: #endif
; 27266: #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 27267: 			|| lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 40 )
; 27268: 			|| lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 40 )
; 27269: #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 27270: #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 27271: 			|| lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 41 )
; 27272: 			|| lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 41 )
; 27273: #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 27274: #ifdef MODIFY_SNOW_MAN_PANDA_POLYMORPH_RING_BUGFIX_20090715
; 27275: 			|| lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 68 )
; 27276: 			|| lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 68 )
; 27277: 			|| lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 76 )
; 27278: 			|| lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 76 )
; 27279: #endif // MODIFY_SNOW_MAN_PANDA_POLYMORPH_RING_BUGFIX_20090715
; 27280: 			)
; 27281: 		{
; 27282: 			//     
; 27283: 			GCServerMsgStringSend(lMsg.Get(1604), lpObj->m_Index, 1);
; 27284: 
; 27285: 			//       .
; 27286: 			x = lpObj->X;
; 27287: 			y = lpObj->Y;
; 27288: 			mapNumber = lpObj->MapNumber;
; 27289: 			dir  = lpObj->Dir;
; 27290: 			movefail = 1;
; 27291: 			lpObj->RegenMapNumber = lpObj->MapNumber;
; 27292: 			lpObj->RegenMapX = (BYTE)x;
; 27293: 			lpObj->RegenMapY = (BYTE)y;
; 27294: 
; 27295: 			//####### BUGFIX_CAT001    ,     
; 27296: 			//gObjClearViewport(&gObj[aIndex]); //      , 
; 27297: 			GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 27298: 
; 27299: 			//    
; 27300: 			gObjClearViewportOfMine( lpObj );
; 27301: 
; 27302: 			//BUGFIX_CAT001 ########
; 27303: 
; 27304: 			if( lpObj->m_Change >= 0 )
; 27305: 			{
; 27306: 				gObjViewportListProtocolCreate(&gObj[aIndex]);
; 27307: 			}
; 27308: 
; 27309: 			gObj[aIndex].RegenOk   = 1;
; 27310: 			return FALSE;	
; 27311: 
; 27312: 		}
; 27313: 	}
; 27314: #endif	// ADD_KANTURU_CONDITION_20060725
; 27315: 
; 27316: 
; 27317: 
; 27318: #ifdef MODIFY_KANTURU_MAPNUMBER_CHECK_20060807
; 27319: 	if( g_iBlockKanturuMapEnter == 1 )
; 27320: 	{
; 27321: 		x			= lpObj->X;
; 27322: 		y			= lpObj->Y;
; 27323: 		mapNumber	= lpObj->MapNumber;
; 27324: 		dir			= lpObj->Dir;
; 27325: 		level		= lpObj->Level;
; 27326: 
; 27327: 		if( gGateC.GetGate(gt, x, y, mapNumber, dir, level ) != -1 )
; 27328: 		{
; 27329: 			if( mapNumber >= MAP_INDEX_KANTURU1 && mapNumber <= MAP_INDEX_KANTURU_BOSS )
; 27330: 			{
; 27331: 				//     
; 27332: 				GCServerMsgStringSend(lMsg.Get(1604), lpObj->m_Index, 1);
; 27333: 
; 27334: 				//       .
; 27335: 				x = lpObj->X;
; 27336: 				y = lpObj->Y;
; 27337: 				mapNumber = lpObj->MapNumber;
; 27338: 				dir  = lpObj->Dir;
; 27339: 				movefail = 1;
; 27340: 				lpObj->RegenMapNumber = lpObj->MapNumber;
; 27341: 				lpObj->RegenMapX = (BYTE)x;
; 27342: 				lpObj->RegenMapY = (BYTE)y;
; 27343: 
; 27344: 				//####### BUGFIX_CAT001    ,     
; 27345: 				//gObjClearViewport(&gObj[aIndex]); //      , 
; 27346: 				GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 27347: 
; 27348: 				//    
; 27349: 				gObjClearViewportOfMine( lpObj );
; 27350: 
; 27351: 				//BUGFIX_CAT001 ########
; 27352: 
; 27353: 				if( lpObj->m_Change >= 0 )
; 27354: 				{
; 27355: 					gObjViewportListProtocolCreate(&gObj[aIndex]);
; 27356: 				}
; 27357: 
; 27358: 				gObj[aIndex].RegenOk   = 1;
; 27359: 				return FALSE;
; 27360: 			}
; 27361: 		}
; 27362: 	}
; 27363: 
; 27364: 	if( g_iBlockCastleSiegeMapEnter == 1 )
; 27365: 	{
; 27366: 		x			= lpObj->X;
; 27367: 		y			= lpObj->Y;
; 27368: 		mapNumber	= lpObj->MapNumber;
; 27369: 		dir			= lpObj->Dir;
; 27370: 		level		= lpObj->Level;
; 27371: 
; 27372: 		if( gGateC.GetGate(gt, x, y, mapNumber, dir, level ) != -1 )
; 27373: 		{
; 27374: 			if( mapNumber == MAP_INDEX_CASTLESIEGE
; 27375: 				|| mapNumber == MAP_INDEX_CASTLEHUNTZONE
; 27376: 				|| mapNumber == MAP_INDEX_CRYWOLF_FIRSTZONE
; 27377: 				|| mapNumber == MAP_INDEX_CRYWOLF_SECONDZONE )
; 27378: 			{
; 27379: 				//     
; 27380: 				GCServerMsgStringSend(lMsg.Get(1604), lpObj->m_Index, 1);
; 27381: 
; 27382: 				//       .
; 27383: 				x = lpObj->X;
; 27384: 				y = lpObj->Y;
; 27385: 				mapNumber = lpObj->MapNumber;
; 27386: 				dir  = lpObj->Dir;
; 27387: 				movefail = 1;
; 27388: 				lpObj->RegenMapNumber = lpObj->MapNumber;
; 27389: 				lpObj->RegenMapX = (BYTE)x;
; 27390: 				lpObj->RegenMapY = (BYTE)y;
; 27391: 
; 27392: 				//####### BUGFIX_CAT001    ,     
; 27393: 				//gObjClearViewport(&gObj[aIndex]); //      , 
; 27394: 				GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 27395: 
; 27396: 				//    
; 27397: 				gObjClearViewportOfMine( lpObj );
; 27398: 
; 27399: 				//BUGFIX_CAT001 ########
; 27400: 
; 27401: 				if( lpObj->m_Change >= 0 )
; 27402: 				{
; 27403: 					gObjViewportListProtocolCreate(&gObj[aIndex]);
; 27404: 				}
; 27405: 
; 27406: 				gObj[aIndex].RegenOk   = 1;
; 27407: 				return FALSE;
; 27408: 			}
; 27409: 		}
; 27410: 	}
; 27411: #endif // MODIFY_KANTURU_MAPNUMBER_CHECK_20060807
; 27412: 
; 27413: #ifdef ADD_RAKLION_20080408
; 27414: 	if( mapNumber == MAP_INDEX_RAKLION_BOSS )
; 27415: 	{
; 27416: 		if( g_Raklion.GetRaklionState() >= RAKLION_STATE_CLOSE_DOOR )
; 27417: 		{
; 27418: 			//     
; 27419: 			GCServerMsgStringSend(lMsg.Get(3415), lpObj->m_Index, 1);
; 27420: 
; 27421: 			//       .
; 27422: 			x = lpObj->X;
; 27423: 			y = lpObj->Y;
; 27424: 			mapNumber = lpObj->MapNumber;
; 27425: 			dir  = lpObj->Dir;
; 27426: 			movefail = 1;
; 27427: 			lpObj->RegenMapNumber = lpObj->MapNumber;
; 27428: 			lpObj->RegenMapX = (BYTE)x;
; 27429: 			lpObj->RegenMapY = (BYTE)y;
; 27430: 
; 27431: 			GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 27432: 
; 27433: 			gObjClearViewportOfMine( lpObj );
; 27434: 
; 27435: 			if( lpObj->m_Change >= 0 )
; 27436: 			{
; 27437: 				gObjViewportListProtocolCreate(&gObj[aIndex]);
; 27438: 			}
; 27439: 
; 27440: 			gObj[aIndex].RegenOk   = 1;
; 27441: 			return FALSE;
; 27442: 		}
; 27443: 		else
; 27444: 		{
; 27445: 			if( gt == 290 )
; 27446: 				g_RaklionBattleUserMng.AddUserData( aIndex );
; 27447: 		}
; 27448: 	}
; 27449: 	if( mapNumber == MAP_INDEX_RAKLION_FIELD )
; 27450: 	{
; 27451: 		if( gt == 292 )	//  ->   
; 27452: 		{
; 27453: 			if( g_Raklion.GetRaklionState() >= RAKLION_STATE_CLOSE_DOOR )	//   
; 27454: 			{
; 27455: 				//     
; 27456: 				GCServerMsgStringSend(lMsg.Get(3416), lpObj->m_Index, 1);
; 27457: 
; 27458: 				//       .
; 27459: 				x = lpObj->X;
; 27460: 				y = lpObj->Y;
; 27461: 				mapNumber = lpObj->MapNumber;
; 27462: 				dir  = lpObj->Dir;
; 27463: 				movefail = 1;
; 27464: 				lpObj->RegenMapNumber = lpObj->MapNumber;
; 27465: 				lpObj->RegenMapX = (BYTE)x;
; 27466: 				lpObj->RegenMapY = (BYTE)y;
; 27467: 
; 27468: 				GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 27469: 
; 27470: 				gObjClearViewportOfMine( lpObj );
; 27471: 
; 27472: 				if( lpObj->m_Change >= 0 )
; 27473: 				{
; 27474: 					gObjViewportListProtocolCreate(&gObj[aIndex]);
; 27475: 				}
; 27476: 
; 27477: 				gObj[aIndex].RegenOk   = 1;
; 27478: 				return FALSE;
; 27479: 			}
; 27480: 			else
; 27481: 			{
; 27482: 				g_RaklionBattleUserMng.DeleteUserData( aIndex );
; 27483: 			}
; 27484: 		}
; 27485: 		else
; 27486: 		{	//  ->  .        .
; 27487: 			g_RaklionUtil.NotifyRaklionCurrentState( aIndex, g_Raklion.GetRaklionState(),
; 27488: 				g_Raklion.GetRaklionStateDetail() );
; 27489: 		}
; 27490: 	}
; 27491: #endif // ADD_RAKLION_20080408
; 27492: 
; 27493: 
; 27494: #ifdef DARKLORD_WORK
; 27495: #ifdef UPDATE_NEWMAP_SWAMP_OF_CALMNESS_20080108	//   ,  Movereq.txt   
; 27496: 	if( mapNumber != MAP_INDEX_SWAMP_OF_CALMNESS )
; 27497: #endif	// UPDATE_NEWMAP_SWAMP_OF_CALMNESS_20080108	
; 27498: 		if( lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA )

  00baa	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bad	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00bb4	83 f9 04	 cmp	 ecx, 4
  00bb7	74 0f		 je	 SHORT $LN31@gObjMoveGa
  00bb9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bbc	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00bc3	83 f9 03	 cmp	 ecx, 3
  00bc6	75 1a		 jne	 SHORT $LN30@gObjMoveGa
$LN31@gObjMoveGa:

; 27499: #else
; 27500: 	if( lpObj->Class == CLASS_MAGUMSA )
; 27501: #endif
; 27502: 	{
; 27503: 		if( level > 0 )

  00bc8	0f bf 45 e4	 movsx	 eax, WORD PTR _level$[ebp]
  00bcc	85 c0		 test	 eax, eax
  00bce	7e 12		 jle	 SHORT $LN30@gObjMoveGa

; 27504: 		{
; 27505: 			level = ((level/3)*2);

  00bd0	0f bf 45 e4	 movsx	 eax, WORD PTR _level$[ebp]
  00bd4	99		 cdq
  00bd5	b9 03 00 00 00	 mov	 ecx, 3
  00bda	f7 f9		 idiv	 ecx
  00bdc	d1 e0		 shl	 eax, 1
  00bde	66 89 45 e4	 mov	 WORD PTR _level$[ebp], ax
$LN30@gObjMoveGa:

; 27506: 		}
; 27507: 	}	
; 27508: 
; 27509: 	if( (level != 0) && ( userlevel < level) ) {

  00be2	0f bf 45 e4	 movsx	 eax, WORD PTR _level$[ebp]
  00be6	85 c0		 test	 eax, eax
  00be8	74 7f		 je	 SHORT $LN33@gObjMoveGa
  00bea	0f bf 45 e4	 movsx	 eax, WORD PTR _level$[ebp]
  00bee	39 45 e0	 cmp	 DWORD PTR _userlevel$[ebp], eax
  00bf1	7d 76		 jge	 SHORT $LN33@gObjMoveGa

; 27510: 		char szTemp[256];
; 27511: 		wsprintf(szTemp, lMsg.Get(1117), level);

  00bf3	0f bf 45 e4	 movsx	 eax, WORD PTR _level$[ebp]
  00bf7	50		 push	 eax
  00bf8	68 5d 04 00 00	 push	 1117			; 0000045dH
  00bfd	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00c02	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00c08	50		 push	 eax
  00c09	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _szTemp$1[ebp]
  00c0f	51		 push	 ecx
  00c10	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00c16	83 c4 0c	 add	 esp, 12			; 0000000cH

; 27512: 		GCServerMsgStringSend(szTemp, aIndex, 1);

  00c19	6a 01		 push	 1
  00c1b	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00c1e	50		 push	 eax
  00c1f	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _szTemp$1[ebp]
  00c25	51		 push	 ecx
  00c26	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00c2b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 27513: 		x = lpObj->X;

  00c2e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c31	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  00c38	66 89 4d f0	 mov	 WORD PTR _x$[ebp], cx

; 27514: 		y = lpObj->Y;

  00c3c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c3f	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  00c46	66 89 4d ec	 mov	 WORD PTR _y$[ebp], cx

; 27515: 		mapNumber = lpObj->MapNumber;

  00c4a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c4d	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  00c53	88 4d eb	 mov	 BYTE PTR _mapNumber$[ebp], cl

; 27516: 		dir  = lpObj->Dir;

  00c56	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c59	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  00c5f	88 4d ea	 mov	 BYTE PTR _dir$[ebp], cl

; 27517: 		movefail = 1;

  00c62	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 1
$LN33@gObjMoveGa:

; 27518: 	}
; 27519: 
; 27520: 	if( gObj[aIndex].m_IfState.use )

  00c69	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00c70	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c76	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  00c7d	80 e2 03	 and	 dl, 3
  00c80	0f b6 c2	 movzx	 eax, dl
  00c83	85 c0		 test	 eax, eax
  00c85	74 3b		 je	 SHORT $LN34@gObjMoveGa

; 27521: 	{
; 27522: 		x = lpObj->X;

  00c87	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c8a	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  00c91	66 89 4d f0	 mov	 WORD PTR _x$[ebp], cx

; 27523: 		y = lpObj->Y;

  00c95	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c98	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  00c9f	66 89 4d ec	 mov	 WORD PTR _y$[ebp], cx

; 27524: 		mapNumber = lpObj->MapNumber;

  00ca3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ca6	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  00cac	88 4d eb	 mov	 BYTE PTR _mapNumber$[ebp], cl

; 27525: 		dir  = lpObj->Dir;

  00caf	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cb2	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  00cb8	88 4d ea	 mov	 BYTE PTR _dir$[ebp], cl

; 27526: 		movefail = 1;

  00cbb	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 1
$LN34@gObjMoveGa:

; 27527: 		//LogAddL("     ");
; 27528: 	}
; 27529: 	if( gObj[aIndex].DieRegen ) 

  00cc2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00cc9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ccf	0f be 94 01 fe
	01 00 00	 movsx	 edx, BYTE PTR [ecx+eax+510]
  00cd7	85 d2		 test	 edx, edx
  00cd9	74 3b		 je	 SHORT $LN35@gObjMoveGa

; 27530: 	{
; 27531: 		x = lpObj->X;

  00cdb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cde	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  00ce5	66 89 4d f0	 mov	 WORD PTR _x$[ebp], cx

; 27532: 		y = lpObj->Y;

  00ce9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cec	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  00cf3	66 89 4d ec	 mov	 WORD PTR _y$[ebp], cx

; 27533: 		mapNumber = lpObj->MapNumber;

  00cf7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cfa	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  00d00	88 4d eb	 mov	 BYTE PTR _mapNumber$[ebp], cl

; 27534: 		dir  = lpObj->Dir;

  00d03	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d06	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  00d0c	88 4d ea	 mov	 BYTE PTR _dir$[ebp], cl

; 27535: 		movefail = 1;

  00d0f	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 1
$LN35@gObjMoveGa:

; 27536: 		//LogAddL("  %d", mapNumber);
; 27537: 	}
; 27538: 
; 27539: 	lpObj->m_State = OBJST_DELCMD;

  00d16	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d19	c7 80 b8 01 00
	00 20 00 00 00	 mov	 DWORD PTR [eax+440], 32	; 00000020H

; 27540: 	if( movefail == 0 )

  00d23	83 7d dc 00	 cmp	 DWORD PTR _movefail$[ebp], 0
  00d27	0f 85 e1 01 00
	00		 jne	 $LN36@gObjMoveGa

; 27541: 	{
; 27542: #ifdef MAP_SERVER_WORK_20041030		//   
; 27543: 		if (gGateC.GetGate(gt, x, y, mapNumber, dir, level) != -1) {
; 27544: 			if (gObj[aIndex].MapNumber != mapNumber) {
; 27545: 				//        .
; 27546: 				if( !MapNumberCheck(mapNumber) ) 
; 27547: 				{
; 27548: 					LogAdd("error-L3 : %s %d", __FILE__, __LINE__);
; 27549: 					return FALSE;
; 27550: 				}
; 27551: 
; 27552: 				SHORT sSvrCode	= g_MapServerManager.CheckMoveMapSvr(lpObj->m_Index, mapNumber, lpObj->m_sPrevMapSvrCode);
; 27553: 				if (sSvrCode != gGameServerCode) {
; 27554: 					if (sSvrCode == -1) {
; 27555: 						//   ->  
; 27556: 						LogAddC(LOGC_RED, "[MapServerMng] Map Server Move Fail : CheckMoveMapSvr() == -1 [%s][%s] (%d)",
; 27557: 							lpObj->AccountID,
; 27558: 							lpObj->Name,
; 27559: 							lpObj->m_Index
; 27560: 							);
; 27561: 						return FALSE;
; 27562: 					}
; 27563: 
; 27564: 					//      . (b4nfter)
; 27565: 					if (gGateC.CheckGateLevel(aIndex, gt) == FALSE) {
; 27566: 						//    
; 27567: 						x = lpObj->X;
; 27568: 						y = lpObj->Y;
; 27569: 						mapNumber = lpObj->MapNumber;
; 27570: 						dir  = lpObj->Dir;
; 27571: 						movefail = 1;
; 27572: 						lpObj->RegenMapNumber = lpObj->MapNumber;
; 27573: 						lpObj->RegenMapX = (BYTE)x;
; 27574: 						lpObj->RegenMapY = (BYTE)y;		
; 27575: 						gObjClearViewport(&gObj[aIndex]);
; 27576: 						GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 27577: 
; 27578: 						if( lpObj->m_Change >= 0 )
; 27579: 						{
; 27580: 							gObjViewportListProtocolCreate(&gObj[aIndex]);
; 27581: 						}
; 27582: 
; 27583: 						gObj[aIndex].RegenOk   = 1;
; 27584: 
; 27585: #ifdef CASTLE_MAIN_SCHEDULER_20041111		//        
; 27586: 						if (gObj[aIndex].MapNumber == MAP_INDEX_CASTLESIEGE &&
; 27587: 							g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE
; 27588: 							)
; 27589: 						{
; 27590: 							g_CastleSiege.NotifySelfCsJoinSide (aIndex);
; 27591: 							g_CastleSiege.NotifyCsSelfLeftTime (aIndex);
; 27592: 						}
; 27593: #endif
; 27594: 						return FALSE;
; 27595: 					}
; 27596: 
; 27597: 					//     .
; 27598: 					GJReqMapSvrMove (lpObj->m_Index, sSvrCode, mapNumber, x, y);
; 27599: 					LogAddTD("[MapServerMng] Request to Move Map Server : (%d) - [%s][%s] (%d)",
; 27600: 						sSvrCode,
; 27601: 						lpObj->AccountID,
; 27602: 						lpObj->Name,
; 27603: 						lpObj->m_Index
; 27604: 						);
; 27605: 					return FALSE;
; 27606: 				}
; 27607: 			}
; 27608: 		}
; 27609: #endif
; 27610: 
; 27611: #ifdef EXTEND_LOG_SYSTEM_20060202
; 27612: 		LogAddTD("[MoveMap][%s][%s] : (Before:Map:%d X:%d Y:%d) -> (New Map:%d X:%d Y:%d)",
; 27613: 			lpObj->AccountID,	lpObj->Name,
; 27614: 			lpObj->MapNumber,	lpObj->X,	lpObj->Y, 
; 27615: 			mapNumber, x, y );
; 27616: #endif
; 27617: 
; 27618: 		gObj[aIndex].X = x;

  00d2d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00d34	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00d3a	66 8b 55 f0	 mov	 dx, WORD PTR _x$[ebp]
  00d3e	66 89 94 01 04
	01 00 00	 mov	 WORD PTR [ecx+eax+260], dx

; 27619: 		gObj[aIndex].Y = y;

  00d46	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00d4d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00d53	66 8b 55 ec	 mov	 dx, WORD PTR _y$[ebp]
  00d57	66 89 94 01 06
	01 00 00	 mov	 WORD PTR [ecx+eax+262], dx

; 27620: 		gObj[aIndex].TX = x;

  00d5f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00d66	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00d6c	66 8b 55 f0	 mov	 dx, WORD PTR _x$[ebp]
  00d70	66 89 94 01 20
	01 00 00	 mov	 WORD PTR [ecx+eax+288], dx

; 27621: #ifdef MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 27622: 		gObj[aIndex].TY = y;

  00d78	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00d7f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00d85	66 8b 55 ec	 mov	 dx, WORD PTR _y$[ebp]
  00d89	66 89 94 01 22
	01 00 00	 mov	 WORD PTR [ecx+eax+290], dx

; 27623: #else	// MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 27624: 		gObj[aIndex].TX = y;
; 27625: #endif	// MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 27626: 		gObj[aIndex].MapNumber = mapNumber;

  00d91	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00d98	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00d9e	8a 55 eb	 mov	 dl, BYTE PTR _mapNumber$[ebp]
  00da1	88 94 01 09 01
	00 00		 mov	 BYTE PTR [ecx+eax+265], dl

; 27627: 		gObj[aIndex].Dir = dir; 

  00da8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00daf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00db5	8a 55 ea	 mov	 dl, BYTE PTR _dir$[ebp]
  00db8	88 94 01 08 01
	00 00		 mov	 BYTE PTR [ecx+eax+264], dl

; 27628: 		gObj[aIndex].PathCount = 0;

  00dbf	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00dc6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00dcc	c7 84 01 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+296], 0

; 27629: 		gObj[aIndex].Teleport  = 0;

  00dd7	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00dde	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00de4	c6 84 01 fc 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+508], 0

; 27630: 
; 27631: #ifdef MODIFY_AFTERIMAGE_BUGFIX_20060215
; 27632: 		//     .
; 27633: 		//  : Map     
; 27634: 		gObjViewportListProtocolDestroy(&gObj[aIndex]);
; 27635: #endif
; 27636: 
; 27637: #ifdef MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 27638: 		gObjViewportListProtocolDestroy(&gObj[aIndex]);

  00dec	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00df3	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00df9	50		 push	 eax
  00dfa	e8 00 00 00 00	 call	 ?gObjViewportListProtocolDestroy@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy
  00dff	83 c4 04	 add	 esp, 4

; 27639: 		//gObjViewportListProtocolCreate(&gObj[aIndex]);
; 27640: #endif	// MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 27641: 
; 27642: #ifndef MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 27643: 		gObjClearViewport(&gObj[aIndex]);
; 27644: #endif	// MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 27645: 		GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);

  00e02	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00e09	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e0f	0f b6 94 01 08
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+264]
  00e17	52		 push	 edx
  00e18	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00e1f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e25	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00e2d	52		 push	 edx
  00e2e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00e35	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e3b	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  00e43	52		 push	 edx
  00e44	0f b6 45 eb	 movzx	 eax, BYTE PTR _mapNumber$[ebp]
  00e48	50		 push	 eax
  00e49	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _gt$[ebp]
  00e4d	51		 push	 ecx
  00e4e	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00e55	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e5b	52		 push	 edx
  00e5c	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  00e61	83 c4 18	 add	 esp, 24			; 00000018H

; 27646: 
; 27647: #ifdef MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 27648: 		gObjViewportListProtocolCreate(&gObj[aIndex]);

  00e64	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00e6b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e71	50		 push	 eax
  00e72	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00e77	83 c4 04	 add	 esp, 4

; 27649: 		gObjClearViewport(&gObj[aIndex]);

  00e7a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00e81	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00e87	50		 push	 eax
  00e88	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  00e8d	83 c4 04	 add	 esp, 4

; 27650: #endif	// MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 27651: 
; 27652: 		if( lpObj->m_Change >= 0 )

  00e90	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e93	83 b8 a8 02 00
	00 00		 cmp	 DWORD PTR [eax+680], 0
  00e9a	7c 16		 jl	 SHORT $LN38@gObjMoveGa

; 27653: 		{
; 27654: 			gObjViewportListProtocolCreate(&gObj[aIndex]);

  00e9c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00ea3	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ea9	50		 push	 eax
  00eaa	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00eaf	83 c4 04	 add	 esp, 4
$LN38@gObjMoveGa:

; 27655: 		}
; 27656: 
; 27657: 		gObj[aIndex].RegenMapNumber = mapNumber;

  00eb2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00eb9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ebf	8a 55 eb	 mov	 dl, BYTE PTR _mapNumber$[ebp]
  00ec2	88 94 01 00 02
	00 00		 mov	 BYTE PTR [ecx+eax+512], dl

; 27658: 		gObj[aIndex].RegenMapX = (BYTE)x;

  00ec9	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00ed0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ed6	8a 55 f0	 mov	 dl, BYTE PTR _x$[ebp]
  00ed9	88 94 01 01 02
	00 00		 mov	 BYTE PTR [ecx+eax+513], dl

; 27659: 		gObj[aIndex].RegenMapY = (BYTE)y;		

  00ee0	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00ee7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00eed	8a 55 ec	 mov	 dl, BYTE PTR _y$[ebp]
  00ef0	88 94 01 02 02
	00 00		 mov	 BYTE PTR [ecx+eax+514], dl

; 27660: 		gObj[aIndex].RegenOk   = 1;

  00ef7	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00efe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f04	c6 84 01 ff 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+511], 1

; 27661: 	}

  00f0c	eb 77		 jmp	 SHORT $LN37@gObjMoveGa
$LN36@gObjMoveGa:

; 27662: 	else
; 27663: 	{
; 27664: 		GCTeleportSend(&gObj[aIndex], gt, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);

  00f0e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00f15	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f1b	0f b6 94 01 08
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+264]
  00f23	52		 push	 edx
  00f24	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00f2b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f31	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00f39	52		 push	 edx
  00f3a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00f41	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f47	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  00f4f	52		 push	 edx
  00f50	0f b6 45 eb	 movzx	 eax, BYTE PTR _mapNumber$[ebp]
  00f54	50		 push	 eax
  00f55	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _gt$[ebp]
  00f59	51		 push	 ecx
  00f5a	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00f61	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f67	52		 push	 edx
  00f68	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  00f6d	83 c4 18	 add	 esp, 24			; 00000018H

; 27665: 		gObj[aIndex].RegenOk   = 1;

  00f70	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00f77	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f7d	c6 84 01 ff 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+511], 1
$LN37@gObjMoveGa:

; 27666: 
; 27667: 
; 27668: #ifdef CASTLE_MAIN_SCHEDULER_20041111						//        
; 27669: 		if (lpObj->MapNumber == MAP_INDEX_CASTLESIEGE &&
; 27670: 			g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE
; 27671: 			)
; 27672: 		{
; 27673: 			g_CastleSiege.NotifySelfCsJoinSide (aIndex);
; 27674: 			g_CastleSiege.NotifyCsSelfLeftTime (aIndex);
; 27675: 		}
; 27676: #endif
; 27677: 	}
; 27678: 	//LogAddL("  ");
; 27679: 
; 27680: 	if( movefail )

  00f85	83 7d dc 00	 cmp	 DWORD PTR _movefail$[ebp], 0
  00f89	74 04		 je	 SHORT $LN39@gObjMoveGa

; 27681: 		return FALSE;

  00f8b	33 c0		 xor	 eax, eax
  00f8d	eb 31		 jmp	 SHORT $LN1@gObjMoveGa
$LN39@gObjMoveGa:

; 27682: 
; 27683: 	if( gObj[aIndex].Type == OBJTYPE_CHARACTER )

  00f8f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00f96	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00f9c	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00fa1	83 fa 01	 cmp	 edx, 1
  00fa4	75 15		 jne	 SHORT $LN40@gObjMoveGa

; 27684: 	{
; 27685: 		gObj[aIndex].m_LastTeleportTime = 10;				//  ,         

  00fa6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00fad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00fb3	c6 84 01 e9 0e
	00 00 0a	 mov	 BYTE PTR [ecx+eax+3817], 10 ; 0000000aH
$LN40@gObjMoveGa:

; 27686: 	}
; 27687: 
; 27688: #ifdef ADD_NEWPVP_PKFIELD
; 27689: 	g_NewPVP.Reset(*lpObj);
; 27690: #endif // ADD_NEWPVP_PKFIELD
; 27691: 
; 27692: 	return TRUE;

  00fbb	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjMoveGa:

; 27693: }

  00fc0	5f		 pop	 edi
  00fc1	5e		 pop	 esi
  00fc2	5b		 pop	 ebx
  00fc3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00fc6	33 cd		 xor	 ecx, ebp
  00fc8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00fcd	8b e5		 mov	 esp, ebp
  00fcf	5d		 pop	 ebp
  00fd0	c3		 ret	 0
?gObjMoveGate@@YAHHH@Z ENDP				; gObjMoveGate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMovePlayer@@YAHHEEEEE@Z
_TEXT	SEGMENT
tv435 = -360						; size = 4
tv426 = -360						; size = 4
tv129 = -360						; size = 4
tv436 = -356						; size = 4
tv427 = -356						; size = 4
tv130 = -356						; size = 4
_iKalimaGateIndex$1 = -288				; size = 4
_msg$2 = -284						; size = 255
_movefail$ = -28					; size = 4
_dir$ = -21						; size = 1
_y$ = -20						; size = 2
_x$ = -16						; size = 2
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_mapnumber$ = 12					; size = 1
_x1$ = 16						; size = 1
_y1$ = 20						; size = 1
_x2$ = 24						; size = 1
_y2$ = 28						; size = 1
?gObjMovePlayer@@YAHHEEEEE@Z PROC			; gObjMovePlayer, COMDAT

; 25927: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 25928: 	LPOBJECTSTRUCT lpObj;
; 25929: 	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  00016	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00023	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 25930: 
; 25931: 	int  result; 	
; 25932: 	short x, y;
; 25933: 	BYTE  dir;
; 25934: 	int  movefail=0;

  00026	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 0

; 25935: 
; 25936: 
; 25937: #ifdef DARKLORD_WORK	
; 25938: 	if( gObj[aIndex].SkillRecallParty_Time )

  0002d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003a	0f b7 94 01 7c
	10 00 00	 movzx	 edx, WORD PTR [ecx+eax+4220]
  00042	85 d2		 test	 edx, edx
  00044	74 4d		 je	 SHORT $LN2@gObjMovePl

; 25939: 	{
; 25940: 		gObj[aIndex].SkillRecallParty_Time = 0;

  00046	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0004d	33 c9		 xor	 ecx, ecx
  0004f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00055	66 89 8c 02 7c
	10 00 00	 mov	 WORD PTR [edx+eax+4220], cx

; 25941: 		char msg[255];
; 25942: 		wsprintf(msg, lMsg.Get(1254));	// ""

  0005d	68 e6 04 00 00	 push	 1254			; 000004e6H
  00062	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0006d	50		 push	 eax
  0006e	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _msg$2[ebp]
  00074	50		 push	 eax
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0007b	83 c4 08	 add	 esp, 8

; 25943: 		GCServerMsgStringSend(msg, aIndex, 1);	

  0007e	6a 01		 push	 1
  00080	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00083	50		 push	 eax
  00084	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _msg$2[ebp]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@gObjMovePl:

; 25944: 	}
; 25945: #endif
; 25946: 
; 25947: #ifdef DARKLORD_WORK
; 25948: 	if( lpObj->Type == OBJTYPE_CHARACTER )

  00093	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00096	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0009a	83 f9 01	 cmp	 ecx, 1
  0009d	75 15		 jne	 SHORT $LN3@gObjMovePl

; 25949: 	{	//     
; 25950: 		gDarkSpirit[lpObj->m_Index].SetMode(CDarkSpirit::PetItem_Mode_Normal);

  0009f	6a ff		 push	 -1
  000a1	6a 00		 push	 0
  000a3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a6	6b 08 28	 imul	 ecx, DWORD PTR [eax], 40
  000a9	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  000af	e8 00 00 00 00	 call	 ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ; CDarkSpirit::SetMode
$LN3@gObjMovePl:

; 25951: 	}
; 25952: #endif
; 25953: 
; 25954: #ifdef FOR_BLOODCASTLE
; 25955: 	if( CHECK_BLOODCASTLE(lpObj->MapNumber))

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b7	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000be	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  000c1	7d 0c		 jge	 SHORT $LN33@gObjMovePl
  000c3	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv130[ebp], 0
  000cd	eb 31		 jmp	 SHORT $LN34@gObjMovePl
$LN33@gObjMovePl:
  000cf	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000d2	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  000d9	83 f8 11	 cmp	 eax, 17			; 00000011H
  000dc	7e 0c		 jle	 SHORT $LN31@gObjMovePl
  000de	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv129[ebp], 0
  000e8	eb 0a		 jmp	 SHORT $LN32@gObjMovePl
$LN31@gObjMovePl:
  000ea	c7 85 98 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv129[ebp], 1
$LN32@gObjMovePl:
  000f4	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR tv129[ebp]
  000fa	89 8d 9c fe ff
	ff		 mov	 DWORD PTR tv130[ebp], ecx
$LN34@gObjMovePl:
  00100	83 bd 9c fe ff
	ff 00		 cmp	 DWORD PTR tv130[ebp], 0
  00107	74 3f		 je	 SHORT $LN4@gObjMovePl

; 25956: 	{	
; 25957: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 25958: 		int iBridgeIndex = g_BloodCastle.GetBridgeIndexByMapNum( lpObj->MapNumber );
; 25959: 		if (g_BloodCastle.GetCurrentState(iBridgeIndex) == BLOODCASTLE_STATE_PLAYING) {
; 25960: #else
; 25961: 		if (g_BloodCastle.GetCurrentState(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1) == BLOODCASTLE_STATE_PLAYING) {

  00109	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010c	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00113	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00116	51		 push	 ecx
  00117	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0011c	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  00121	83 f8 02	 cmp	 eax, 2
  00124	75 12		 jne	 SHORT $LN5@gObjMovePl

; 25962: #endif
; 25963: 			//         .
; 25964: 			g_BloodCastle.SearchUserDropQuestItem (lpObj->m_Index);

  00126	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00129	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012b	51		 push	 ecx
  0012c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00131	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem

; 25965: 		}

  00136	eb 10		 jmp	 SHORT $LN4@gObjMovePl
$LN5@gObjMovePl:

; 25966: 		else {
; 25967: 			//         .
; 25968: 			g_BloodCastle.SearchUserDeleteQuestItem(lpObj->m_Index);

  00138	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013d	51		 push	 ecx
  0013e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00143	e8 00 00 00 00	 call	 ?SearchUserDeleteQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDeleteQuestItem
$LN4@gObjMovePl:

; 25969: 		}
; 25970: 	}
; 25971: #endif
; 25972: 	
; 25973: 	//if( gObj[aIndex].m_MoveGateNumber>=0 ) return;
; 25974: 	if( gObj[aIndex].RegenOk ) 

  00148	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0014f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00155	0f be 94 01 ff
	01 00 00	 movsx	 edx, BYTE PTR [ecx+eax+511]
  0015d	85 d2		 test	 edx, edx
  0015f	0f 84 37 01 00
	00		 je	 $LN7@gObjMovePl

; 25975: 	{
; 25976: 		LogAdd("Regen OK %s %d", __FILE__, __LINE__);

  00165	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjMovePlayer@@YAHHEEEEE@Z@4JA
  0016a	83 c0 31	 add	 eax, 49			; 00000031H
  0016d	50		 push	 eax
  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00173	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EEJEJBPC@Regen?5OK?5?$CFs?5?$CFd@
  00178	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0017e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25977: 		x = lpObj->X;

  00181	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00184	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  0018b	66 89 4d f0	 mov	 WORD PTR _x$[ebp], cx

; 25978: 		y = lpObj->Y;

  0018f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00192	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  00199	66 89 4d ec	 mov	 WORD PTR _y$[ebp], cx

; 25979: 		mapnumber = lpObj->MapNumber;

  0019d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a0	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  001a6	88 4d 0c	 mov	 BYTE PTR _mapnumber$[ebp], cl

; 25980: 		dir  = lpObj->Dir;

  001a9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ac	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  001b2	88 4d eb	 mov	 BYTE PTR _dir$[ebp], cl

; 25981: 		movefail = 1;		

  001b5	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 1

; 25982: 		lpObj->RegenMapNumber = lpObj->MapNumber;

  001bc	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001bf	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001c2	8a 91 09 01 00
	00		 mov	 dl, BYTE PTR [ecx+265]
  001c8	88 90 00 02 00
	00		 mov	 BYTE PTR [eax+512], dl

; 25983: 		lpObj->RegenMapX = (BYTE)x;

  001ce	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d1	8a 4d f0	 mov	 cl, BYTE PTR _x$[ebp]
  001d4	88 88 01 02 00
	00		 mov	 BYTE PTR [eax+513], cl

; 25984: 		lpObj->RegenMapY = (BYTE)y;		

  001da	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001dd	8a 4d ec	 mov	 cl, BYTE PTR _y$[ebp]
  001e0	88 88 02 02 00
	00		 mov	 BYTE PTR [eax+514], cl

; 25985: 		gObjClearViewport(&gObj[aIndex]);

  001e6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001ed	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  001f9	83 c4 04	 add	 esp, 4

; 25986: 		GCTeleportSend(&gObj[aIndex], -1, mapnumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);

  001fc	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00203	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00209	0f b6 94 01 08
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+264]
  00211	52		 push	 edx
  00212	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00219	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0021f	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00227	52		 push	 edx
  00228	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0022f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00235	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  0023d	52		 push	 edx
  0023e	0f b6 45 0c	 movzx	 eax, BYTE PTR _mapnumber$[ebp]
  00242	50		 push	 eax
  00243	68 ff 00 00 00	 push	 255			; 000000ffH
  00248	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0024f	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00255	51		 push	 ecx
  00256	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  0025b	83 c4 18	 add	 esp, 24			; 00000018H

; 25987: 
; 25988: 		if( lpObj->m_Change >= 0 )

  0025e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00261	83 b8 a8 02 00
	00 00		 cmp	 DWORD PTR [eax+680], 0
  00268	7c 16		 jl	 SHORT $LN8@gObjMovePl

; 25989: 		{
; 25990: 			gObjViewportListProtocolCreate(&gObj[aIndex]);

  0026a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00271	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00277	50		 push	 eax
  00278	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  0027d	83 c4 04	 add	 esp, 4
$LN8@gObjMovePl:

; 25991: 		}
; 25992: 		gObj[aIndex].RegenOk   = 1;

  00280	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00287	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0028d	c6 84 01 ff 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+511], 1

; 25993: 		return FALSE;

  00295	33 c0		 xor	 eax, eax
  00297	e9 f5 09 00 00	 jmp	 $LN1@gObjMovePl
$LN7@gObjMovePl:

; 25994: 	}
; 25995: 
; 25996: 	GetMoveArea(x, y, mapnumber, x1, y1, x2, y2, dir);

  0029c	8d 45 eb	 lea	 eax, DWORD PTR _dir$[ebp]
  0029f	50		 push	 eax
  002a0	0f b6 4d 1c	 movzx	 ecx, BYTE PTR _y2$[ebp]
  002a4	51		 push	 ecx
  002a5	0f b6 55 18	 movzx	 edx, BYTE PTR _x2$[ebp]
  002a9	52		 push	 edx
  002aa	0f b6 45 14	 movzx	 eax, BYTE PTR _y1$[ebp]
  002ae	50		 push	 eax
  002af	0f b6 4d 10	 movzx	 ecx, BYTE PTR _x1$[ebp]
  002b3	51		 push	 ecx
  002b4	0f b6 55 0c	 movzx	 edx, BYTE PTR _mapnumber$[ebp]
  002b8	52		 push	 edx
  002b9	8d 45 ec	 lea	 eax, DWORD PTR _y$[ebp]
  002bc	50		 push	 eax
  002bd	8d 4d f0	 lea	 ecx, DWORD PTR _x$[ebp]
  002c0	51		 push	 ecx
  002c1	e8 00 00 00 00	 call	 ?GetMoveArea@@YAXAAF0EEEEEAAE@Z ; GetMoveArea
  002c6	83 c4 20	 add	 esp, 32			; 00000020H

; 25997: 	
; 25998: #ifdef MODIFY_ITEM_DUPLICATION_IN_MAPSERVER_MOVING_20051219
; 25999: 	if( lpObj->m_bPShopOpen == TRUE )
; 26000: 	{
; 26001: 		BOOL bMove = TRUE;
; 26002: 
; 26003: 		//   :  -> 
; 26004: 		if( lpObj->MapNumber == MAP_INDEX_CASTLESIEGE 
; 26005: 			&& mapNumber == MAP_INDEX_RORENCIA )
; 26006: 		{
; 26007: 			bMove = FALSE;
; 26008: 		}
; 26009: 		//   :  -> 
; 26010: 		if( lpObj->MapNumber == MAP_INDEX_RORENCIA
; 26011: 			&& mapNumber == MAP_INDEX_CASTLESIEGE )
; 26012: 		{
; 26013: 			bMove = FALSE;
; 26014: 		}
; 26015: 
; 26016: 		if( bMove == FALSE )
; 26017: 		{
; 26018: 			LogAddTD("[PSHOP ITEM CLONNING] Move Failed : %d (%s %s)", result, lpObj->AccountID, lpObj->Name);
; 26019: 			x = lpObj->X;
; 26020: 			y = lpObj->Y;
; 26021: 			mapNumber = lpObj->MapNumber;
; 26022: 			dir  = lpObj->Dir;
; 26023: 			movefail = 1;
; 26024: 
; 26025: #ifdef MODIFY_MAPMOVE_SET_REGEN_POSITION_20060905
; 26026: 			lpObj->RegenMapX = x;
; 26027: 			lpObj->RegenMapY = y;
; 26028: 			lpObj->RegenMapNumber = mapNumber;
; 26029: #endif // MODIFY_MAPMOVE_SET_REGEN_POSITION_20060905
; 26030: 
; 26031: 	#ifdef FOR_KOREA
; 26032: 			// MODIFY_LOCALIZING_WTF_20060309  wtf   0.99.60 - 0.99.94
; 26033: 			MsgOutput( lpObj->m_Index, lMsg.Get(3356) );			// "     ."
; 26034: 	#endif
; 26035: 
; 26036: #ifdef MODIFY_MOVEGATE_CHECK_PERSONALSHOP_OPEN_20060704
; 26037: 			lpObj->RegenMapNumber = lpObj->MapNumber;
; 26038: 			lpObj->RegenMapX = (BYTE)x;
; 26039: 			lpObj->RegenMapY = (BYTE)y;		
; 26040: 			gObjClearViewport(&gObj[aIndex]);
; 26041: 			GCTeleportSend(&gObj[aIndex], -1, mapNumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 26042: 
; 26043: 			if( lpObj->m_Change >= 0 )
; 26044: 			{
; 26045: 				gObjViewportListProtocolCreate(&gObj[aIndex]);
; 26046: 			}
; 26047: 
; 26048: 			gObj[aIndex].RegenOk   = 1;
; 26049: 			return FALSE;
; 26050: #endif // MODIFY_MOVEGATE_CHECK_PERSONALSHOP_OPEN_20060704
; 26051: 
; 26052: 		}
; 26053: 	}
; 26054: 		
; 26055: #endif // MODIFY_ITEM_DUPLICATION_IN_MAPSERVER_MOVING_20051219
; 26056: 
; 26057: // , ,     .(apple)
; 26058: #ifdef MODIFY_NPC_SHADOW_PAHTOM_20050628
; 26059: 	if( CHECK_BLOODCASTLE(mapnumber) 
; 26060: 		|| CHECK_CHAOSCASTLE(mapnumber) 
; 26061: 		|| CHECK_DEVILSQUARE(mapnumber)
; 26062: #ifdef MODIFY_SHADOW_PHANTOM_BUFF_IN_ILLUSION_TEMPLE_BUGFIX_20080731
; 26063: 		|| CHECK_ILLUSION_TEMPLE(mapnumber)
; 26064: #endif // MODIFY_SHADOW_PHANTOM_BUFF_IN_ILLUSION_TEMPLE_BUGFIX_20080731
; 26065: 	  )
; 26066: 	{
; 26067: 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 26068: 		if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_ATTDEF_POWER_INC ) == true )
; 26069: 		{
; 26070: 			gObjRemoveBuffEffect( lpObj, BUFFTYPE_ATTDEF_POWER_INC );
; 26071: 		}
; 26072: 	#else
; 26073: 		if(lpObj->m_iSkillNPCHelpTime > 0)
; 26074: 		{
; 26075: 			lpObj->m_iSkillNPCHelpTime = 0;
; 26076: 			lpObj->m_iSkillNPCDefense = 0; 
; 26077: 			lpObj->m_iSkillNPCAttack = 0;
; 26078: 			
; 26079: 			DEL_VIEWSKILLSTATE(lpObj->m_ViewSkillState, STATE_NPC_HELP);
; 26080: 			GCStateInfoSend(lpObj, 0, STATE_NPC_HELP);
; 26081: 		}
; 26082: 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 26083: 	#ifdef ADD_EVENT_MAP_BUFF_EFFECT_DELETE_20090421
; 26084: 		if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_ATTACK_POWER_INC ) == true )
; 26085: 		{	//  
; 26086: 			gObjRemoveBuffEffect( lpObj, BUFFTYPE_ATTACK_POWER_INC );
; 26087: 		}
; 26088: 		if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_DEFENSE_POWER_INC ) == true )
; 26089: 		{	//  
; 26090: 			gObjRemoveBuffEffect( lpObj, BUFFTYPE_DEFENSE_POWER_INC );
; 26091: 		}
; 26092: 		if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_CRITICAL_DMG_INC ) == true )
; 26093: 		{	//   
; 26094: 			gObjRemoveBuffEffect( lpObj, BUFFTYPE_CRITICAL_DMG_INC );
; 26095: 		}
; 26096: 		if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_HP_INC ) == true )
; 26097: 		{	// 
; 26098: 			gObjRemoveBuffEffect( lpObj, BUFFTYPE_HP_INC );
; 26099: 		}
; 26100: 		if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_MELEE_DEFENSE_INC ) == true )
; 26101: 		{	//  
; 26102: 			gObjRemoveBuffEffect( lpObj, BUFFTYPE_MELEE_DEFENSE_INC );
; 26103: 		}
; 26104: 	#endif // ADD_EVENT_MAP_BUFF_EFFECT_DELETE_20090421
; 26105: 	}
; 26106: #endif
; 26107: 
; 26108: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//    
; 26109: 	if( CHECK_ILLUSION_TEMPLE(lpObj->MapNumber) 
; 26110: 		&& mapnumber != lpObj->MapNumber )
; 26111: 	{
; 26112: 		g_IllusionTempleEvent.DropRelicsItem(lpObj->MapNumber, lpObj->m_Index);
; 26113: 		g_IllusionTempleEvent.LeaveIllusionTemple(lpObj->m_Index, lpObj->MapNumber);
; 26114: 	}
; 26115: #endif
; 26116: 
; 26117: #ifdef CASTLE_MAIN_SCHEDULER_20041111	//   -         .
; 26118: 	if (result == 97) {
; 26119: 		if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE) {
; 26120: 			if (lpObj->m_btCsJoinSide != CS_SIEGESIDE_DEFEND && g_CastleSiege.GetCastleTowerAccessable() == FALSE) {
; 26121: 				//      .
; 26122: 				GCServerMsgStringSend(lMsg.Get(1624), lpObj->m_Index, 1);	// "     ."
; 26123: 				x = lpObj->X;
; 26124: 				y = lpObj->Y;
; 26125: 				mapnumber = lpObj->MapNumber;
; 26126: 				dir  = lpObj->Dir;
; 26127: 				movefail = 1;
; 26128: 				lpObj->RegenMapNumber = lpObj->MapNumber;
; 26129: 				lpObj->RegenMapX = (BYTE)x;
; 26130: 				lpObj->RegenMapY = (BYTE)y;		
; 26131: 				gObjClearViewport(&gObj[aIndex]);
; 26132: 				GCTeleportSend(&gObj[aIndex], -1, mapnumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 26133: 
; 26134: 				if( lpObj->m_Change >= 0 )
; 26135: 				{
; 26136: 					gObjViewportListProtocolCreate(&gObj[aIndex]);
; 26137: 				}
; 26138: 
; 26139: 				gObj[aIndex].RegenOk   = 1;
; 26140: 				return FALSE;
; 26141: 			}
; 26142: 			else if (lpObj->m_btCsJoinSide == CS_SIEGESIDE_NONE) {
; 26143: 				//      .
; 26144: 				GCServerMsgStringSend(lMsg.Get(1625), lpObj->m_Index, 1);	// "   ."
; 26145: 				x = lpObj->X;
; 26146: 				y = lpObj->Y;
; 26147: 				mapnumber = lpObj->MapNumber;
; 26148: 				dir  = lpObj->Dir;
; 26149: 				movefail = 1;
; 26150: 				lpObj->RegenMapNumber = lpObj->MapNumber;
; 26151: 				lpObj->RegenMapX = (BYTE)x;
; 26152: 				lpObj->RegenMapY = (BYTE)y;		
; 26153: 				gObjClearViewport(&gObj[aIndex]);
; 26154: 				GCTeleportSend(&gObj[aIndex], -1, mapnumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 26155: 
; 26156: 				if( lpObj->m_Change >= 0 )
; 26157: 				{
; 26158: 					gObjViewportListProtocolCreate(&gObj[aIndex]);
; 26159: 				}
; 26160: 
; 26161: 				gObj[aIndex].RegenOk   = 1;
; 26162: 				return FALSE;
; 26163: 			}
; 26164: 		}
; 26165: 		else {
; 26166: 			if (g_CastleSiege.CheckCastleOwnerUnionMember (lpObj->m_Index) == FALSE) {
; 26167: 				//       .
; 26168: 				GCServerMsgStringSend(lMsg.Get(1626), lpObj->m_Index, 1);	// "      ."
; 26169: 				x = lpObj->X;
; 26170: 				y = lpObj->Y;
; 26171: 				mapnumber = lpObj->MapNumber;
; 26172: 				dir  = lpObj->Dir;
; 26173: 				movefail = 1;
; 26174: 				lpObj->RegenMapNumber = lpObj->MapNumber;
; 26175: 				lpObj->RegenMapX = (BYTE)x;
; 26176: 				lpObj->RegenMapY = (BYTE)y;		
; 26177: 				gObjClearViewport(&gObj[aIndex]);
; 26178: 				GCTeleportSend(&gObj[aIndex], -1, mapnumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 26179: 
; 26180: 				if( lpObj->m_Change >= 0 )
; 26181: 				{
; 26182: 					gObjViewportListProtocolCreate(&gObj[aIndex]);
; 26183: 				}
; 26184: 
; 26185: 				gObj[aIndex].RegenOk   = 1;
; 26186: 				return FALSE;
; 26187: 			}
; 26188: 		}
; 26189: 	}
; 26190: #endif	
; 26191: 
; 26192: #ifdef NEW_SKILL_FORSKYLAND
; 26193: 	if( mapnumber == MAP_INDEX_ATHLANSE )	//       

  002c9	0f b6 45 0c	 movzx	 eax, BYTE PTR _mapnumber$[ebp]
  002cd	83 f8 07	 cmp	 eax, 7
  002d0	0f 85 ea 02 00
	00		 jne	 $LN9@gObjMovePl

; 26194: #else
; 26195: 	if( mapnumber == MAP_INDEX_ATHLANSE )
; 26196: #endif
; 26197: 	{	//       
; 26198: 		if( lpObj->pInventory[EQUIPMENT_HELPER].IsItem())

  002d6	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  002db	c1 e1 03	 shl	 ecx, 3
  002de	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002e1	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  002e7	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  002ec	85 c0		 test	 eax, eax
  002ee	0f 84 cc 02 00
	00		 je	 $LN9@gObjMovePl

; 26199: 		{							
; 26200: 			if( lpObj->pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,2) )

  002f4	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  002f9	c1 e0 03	 shl	 eax, 3
  002fc	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002ff	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00305	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  0030a	6a 02		 push	 2
  0030c	6a 0d		 push	 13			; 0000000dH
  0030e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00313	83 c4 08	 add	 esp, 8
  00316	3b f0		 cmp	 esi, eax
  00318	0f 85 3c 01 00
	00		 jne	 $LN11@gObjMovePl

; 26201: 			{
; 26202: 				GCServerMsgStringSend(lMsg.Get(702), lpObj->m_Index, 1);

  0031e	6a 01		 push	 1
  00320	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00323	8b 08		 mov	 ecx, DWORD PTR [eax]
  00325	51		 push	 ecx
  00326	68 be 02 00 00	 push	 702			; 000002beH
  0032b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00330	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00336	50		 push	 eax
  00337	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0033c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 26203: 				x = lpObj->X;

  0033f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00342	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  00349	66 89 4d f0	 mov	 WORD PTR _x$[ebp], cx

; 26204: 				y = lpObj->Y;

  0034d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00350	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  00357	66 89 4d ec	 mov	 WORD PTR _y$[ebp], cx

; 26205: 				mapnumber = lpObj->MapNumber;

  0035b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0035e	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  00364	88 4d 0c	 mov	 BYTE PTR _mapnumber$[ebp], cl

; 26206: 				dir  = lpObj->Dir;

  00367	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0036a	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  00370	88 4d eb	 mov	 BYTE PTR _dir$[ebp], cl

; 26207: 				movefail = 1;

  00373	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 1

; 26208: 				lpObj->RegenMapNumber = lpObj->MapNumber;

  0037a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0037d	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00380	8a 91 09 01 00
	00		 mov	 dl, BYTE PTR [ecx+265]
  00386	88 90 00 02 00
	00		 mov	 BYTE PTR [eax+512], dl

; 26209: 				lpObj->RegenMapX = (BYTE)x;

  0038c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0038f	8a 4d f0	 mov	 cl, BYTE PTR _x$[ebp]
  00392	88 88 01 02 00
	00		 mov	 BYTE PTR [eax+513], cl

; 26210: 				lpObj->RegenMapY = (BYTE)y;		

  00398	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039b	8a 4d ec	 mov	 cl, BYTE PTR _y$[ebp]
  0039e	88 88 02 02 00
	00		 mov	 BYTE PTR [eax+514], cl

; 26211: 				gObjClearViewport(&gObj[aIndex]);

  003a4	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003ab	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003b1	50		 push	 eax
  003b2	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  003b7	83 c4 04	 add	 esp, 4

; 26212: 				GCTeleportSend(&gObj[aIndex], -1, mapnumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);

  003ba	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003c7	0f b6 94 01 08
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+264]
  003cf	52		 push	 edx
  003d0	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003dd	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  003e5	52		 push	 edx
  003e6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  003ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003f3	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  003fb	52		 push	 edx
  003fc	0f b6 45 0c	 movzx	 eax, BYTE PTR _mapnumber$[ebp]
  00400	50		 push	 eax
  00401	68 ff 00 00 00	 push	 255			; 000000ffH
  00406	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0040d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00413	51		 push	 ecx
  00414	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  00419	83 c4 18	 add	 esp, 24			; 00000018H

; 26213: 
; 26214: 				if( lpObj->m_Change >= 0 )

  0041c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0041f	83 b8 a8 02 00
	00 00		 cmp	 DWORD PTR [eax+680], 0
  00426	7c 16		 jl	 SHORT $LN12@gObjMovePl

; 26215: 				{
; 26216: 					gObjViewportListProtocolCreate(&gObj[aIndex]);

  00428	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0042f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00435	50		 push	 eax
  00436	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  0043b	83 c4 04	 add	 esp, 4
$LN12@gObjMovePl:

; 26217: 				}
; 26218: 
; 26219: 				gObj[aIndex].RegenOk   = 1;

  0043e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00445	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0044b	c6 84 01 ff 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+511], 1

; 26220: 				return FALSE;

  00453	33 c0		 xor	 eax, eax
  00455	e9 37 08 00 00	 jmp	 $LN1@gObjMovePl
$LN11@gObjMovePl:

; 26221: 			}
; 26222: 
; 26223: 			if( lpObj->pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,3) )

  0045a	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0045f	c1 e0 03	 shl	 eax, 3
  00462	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00465	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0046b	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00470	6a 03		 push	 3
  00472	6a 0d		 push	 13			; 0000000dH
  00474	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00479	83 c4 08	 add	 esp, 8
  0047c	3b f0		 cmp	 esi, eax
  0047e	0f 85 3c 01 00
	00		 jne	 $LN9@gObjMovePl

; 26224: 			{
; 26225: 				GCServerMsgStringSend(lMsg.Get(1604), lpObj->m_Index, 1);

  00484	6a 01		 push	 1
  00486	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00489	8b 08		 mov	 ecx, DWORD PTR [eax]
  0048b	51		 push	 ecx
  0048c	68 44 06 00 00	 push	 1604			; 00000644H
  00491	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00496	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0049c	50		 push	 eax
  0049d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  004a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 26226: 				x = lpObj->X;

  004a5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004a8	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  004af	66 89 4d f0	 mov	 WORD PTR _x$[ebp], cx

; 26227: 				y = lpObj->Y;

  004b3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004b6	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  004bd	66 89 4d ec	 mov	 WORD PTR _y$[ebp], cx

; 26228: 				mapnumber = lpObj->MapNumber;

  004c1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004c4	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  004ca	88 4d 0c	 mov	 BYTE PTR _mapnumber$[ebp], cl

; 26229: 				dir  = lpObj->Dir;

  004cd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004d0	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  004d6	88 4d eb	 mov	 BYTE PTR _dir$[ebp], cl

; 26230: 				movefail = 1;

  004d9	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 1

; 26231: 				lpObj->RegenMapNumber = lpObj->MapNumber;

  004e0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004e3	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004e6	8a 91 09 01 00
	00		 mov	 dl, BYTE PTR [ecx+265]
  004ec	88 90 00 02 00
	00		 mov	 BYTE PTR [eax+512], dl

; 26232: 				lpObj->RegenMapX = (BYTE)x;

  004f2	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004f5	8a 4d f0	 mov	 cl, BYTE PTR _x$[ebp]
  004f8	88 88 01 02 00
	00		 mov	 BYTE PTR [eax+513], cl

; 26233: 				lpObj->RegenMapY = (BYTE)y;		

  004fe	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00501	8a 4d ec	 mov	 cl, BYTE PTR _y$[ebp]
  00504	88 88 02 02 00
	00		 mov	 BYTE PTR [eax+514], cl

; 26234: 				gObjClearViewport(&gObj[aIndex]);

  0050a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00511	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00517	50		 push	 eax
  00518	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  0051d	83 c4 04	 add	 esp, 4

; 26235: 				GCTeleportSend(&gObj[aIndex], -1, mapnumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);

  00520	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00527	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0052d	0f b6 94 01 08
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+264]
  00535	52		 push	 edx
  00536	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0053d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00543	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  0054b	52		 push	 edx
  0054c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00553	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00559	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  00561	52		 push	 edx
  00562	0f b6 45 0c	 movzx	 eax, BYTE PTR _mapnumber$[ebp]
  00566	50		 push	 eax
  00567	68 ff 00 00 00	 push	 255			; 000000ffH
  0056c	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00573	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00579	51		 push	 ecx
  0057a	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  0057f	83 c4 18	 add	 esp, 24			; 00000018H

; 26236: 
; 26237: 				if( lpObj->m_Change >= 0 )

  00582	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00585	83 b8 a8 02 00
	00 00		 cmp	 DWORD PTR [eax+680], 0
  0058c	7c 16		 jl	 SHORT $LN14@gObjMovePl

; 26238: 				{
; 26239: 					gObjViewportListProtocolCreate(&gObj[aIndex]);

  0058e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00595	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0059b	50		 push	 eax
  0059c	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  005a1	83 c4 04	 add	 esp, 4
$LN14@gObjMovePl:

; 26240: 				}
; 26241: 				gObj[aIndex].RegenOk   = 1;

  005a4	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  005ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005b1	c6 84 01 ff 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+511], 1

; 26242: 				return FALSE;

  005b9	33 c0		 xor	 eax, eax
  005bb	e9 d1 06 00 00	 jmp	 $LN1@gObjMovePl
$LN9@gObjMovePl:

; 26243: 			}
; 26244: 		}
; 26245: 	}
; 26246: 
; 26247: #ifdef NEW_SKILL_FORSKYLAND	
; 26248: 	if( mapnumber == MAP_INDEX_ICARUS )

  005c0	0f b6 45 0c	 movzx	 eax, BYTE PTR _mapnumber$[ebp]
  005c4	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  005c7	0f 85 6c 02 00
	00		 jne	 $LN15@gObjMovePl

; 26249: 	{
; 26250: 		if( (lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,3) && 
; 26251: #ifdef DARKLORD_WORK
; 26252: 			lpObj->pInventory[EQUIPMENT_WING].m_Type != MAKE_ITEMNUM(13,30) &&	// 
; 26253: #endif
; 26254: #ifdef ADD_ITEM_FENRIR_01_20051110
; 26255: 			lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,37) &&	// 
; 26256: #endif
; 26257: #ifdef MODIFY_SKYLAND_FENRIR_AND_WING_BUGFIX_20080730
; 26258: 			lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,4) &&	// 
; 26259: #endif // MODIFY_SKYLAND_FENRIR_AND_WING_BUGFIX_20080730
; 26260: #ifdef ADD_THIRD_WING_20070525	//    3 
; 26261: 			(  lpObj->pInventory[EQUIPMENT_WING].IsItem() == FALSE ))	|| //  
; 26262: #else
; 26263: 			(lpObj->pInventory[EQUIPMENT_WING].m_Type < MAKE_ITEMNUM(12,0) || lpObj->pInventory[EQUIPMENT_WING].m_Type > MAKE_ITEMNUM(12,6) )) ||
; 26264: #endif
; 26265: 			 lpObj->pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,2) ||
; 26266: 			 lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM(13,10) ||

  005cd	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  005d2	c1 e0 03	 shl	 eax, 3
  005d5	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005d8	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  005de	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  005e3	6a 03		 push	 3
  005e5	6a 0d		 push	 13			; 0000000dH
  005e7	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  005ec	83 c4 08	 add	 esp, 8
  005ef	3b f0		 cmp	 esi, eax
  005f1	74 76		 je	 SHORT $LN18@gObjMovePl
  005f3	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  005f8	6b c8 07	 imul	 ecx, eax, 7
  005fb	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005fe	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00604	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00609	6a 1e		 push	 30			; 0000001eH
  0060b	6a 0d		 push	 13			; 0000000dH
  0060d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00612	83 c4 08	 add	 esp, 8
  00615	3b f0		 cmp	 esi, eax
  00617	74 50		 je	 SHORT $LN18@gObjMovePl
  00619	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0061e	6b c8 07	 imul	 ecx, eax, 7
  00621	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00624	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  0062a	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  0062f	6a 00		 push	 0
  00631	6a 0c		 push	 12			; 0000000cH
  00633	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00638	83 c4 08	 add	 esp, 8
  0063b	3b f0		 cmp	 esi, eax
  0063d	0f 8c 9c 00 00
	00		 jl	 $LN17@gObjMovePl
  00643	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00648	6b c8 07	 imul	 ecx, eax, 7
  0064b	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0064e	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00654	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00659	6a 06		 push	 6
  0065b	6a 0c		 push	 12			; 0000000cH
  0065d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00662	83 c4 08	 add	 esp, 8
  00665	3b f0		 cmp	 esi, eax
  00667	7f 76		 jg	 SHORT $LN17@gObjMovePl
$LN18@gObjMovePl:
  00669	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0066e	c1 e0 03	 shl	 eax, 3
  00671	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00674	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0067a	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  0067f	6a 02		 push	 2
  00681	6a 0d		 push	 13			; 0000000dH
  00683	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00688	83 c4 08	 add	 esp, 8
  0068b	3b f0		 cmp	 esi, eax
  0068d	74 50		 je	 SHORT $LN17@gObjMovePl
  0068f	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00694	6b c8 0b	 imul	 ecx, eax, 11
  00697	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0069a	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  006a0	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  006a5	6a 0a		 push	 10			; 0000000aH
  006a7	6a 0d		 push	 13			; 0000000dH
  006a9	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  006ae	83 c4 08	 add	 esp, 8
  006b1	3b f0		 cmp	 esi, eax
  006b3	74 2a		 je	 SHORT $LN17@gObjMovePl
  006b5	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  006ba	6b c8 0a	 imul	 ecx, eax, 10
  006bd	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  006c0	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  006c6	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  006cb	6a 0a		 push	 10			; 0000000aH
  006cd	6a 0d		 push	 13			; 0000000dH
  006cf	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  006d4	83 c4 08	 add	 esp, 8
  006d7	3b f0		 cmp	 esi, eax
  006d9	0f 85 32 01 00
	00		 jne	 $LN16@gObjMovePl
$LN17@gObjMovePl:

; 26267: 			 lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM(13,10) 
; 26268: #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	//   
; 26269: 			 || lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 39 )
; 26270: 			 || lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 39 ) 	
; 26271: #endif	
; 26272: #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 26273: 			 || lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 40 )
; 26274: 			 || lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 40 )
; 26275: #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 26276: #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 26277: 			 || lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 41 )
; 26278: 			 || lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 41 )
; 26279: #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 26280: #ifdef MODIFY_SNOW_MAN_PANDA_POLYMORPH_RING_BUGFIX_20090715
; 26281: 			 || lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 68 )
; 26282: 			 || lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 68 )
; 26283: 			 || lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 76 )
; 26284: 			 || lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 76 )
; 26285: #endif // MODIFY_SNOW_MAN_PANDA_POLYMORPH_RING_BUGFIX_20090715
; 26286: 		  )
; 26287: 		{	//       
; 26288: 			GCServerMsgStringSend(lMsg.Get(1604), lpObj->m_Index, 1);

  006df	6a 01		 push	 1
  006e1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  006e6	51		 push	 ecx
  006e7	68 44 06 00 00	 push	 1604			; 00000644H
  006ec	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  006f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  006f7	50		 push	 eax
  006f8	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  006fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 26289: 			x = lpObj->X;

  00700	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00703	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  0070a	66 89 4d f0	 mov	 WORD PTR _x$[ebp], cx

; 26290: 			y = lpObj->Y;

  0070e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00711	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  00718	66 89 4d ec	 mov	 WORD PTR _y$[ebp], cx

; 26291: 			mapnumber = lpObj->MapNumber;

  0071c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0071f	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  00725	88 4d 0c	 mov	 BYTE PTR _mapnumber$[ebp], cl

; 26292: 			dir  = lpObj->Dir;

  00728	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0072b	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  00731	88 4d eb	 mov	 BYTE PTR _dir$[ebp], cl

; 26293: 			movefail = 1;

  00734	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 1

; 26294: 			lpObj->RegenMapNumber = lpObj->MapNumber;

  0073b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0073e	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00741	8a 91 09 01 00
	00		 mov	 dl, BYTE PTR [ecx+265]
  00747	88 90 00 02 00
	00		 mov	 BYTE PTR [eax+512], dl

; 26295: 			lpObj->RegenMapX = (BYTE)x;

  0074d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00750	8a 4d f0	 mov	 cl, BYTE PTR _x$[ebp]
  00753	88 88 01 02 00
	00		 mov	 BYTE PTR [eax+513], cl

; 26296: 			lpObj->RegenMapY = (BYTE)y;		

  00759	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0075c	8a 4d ec	 mov	 cl, BYTE PTR _y$[ebp]
  0075f	88 88 02 02 00
	00		 mov	 BYTE PTR [eax+514], cl

; 26297: 
; 26298: 	//####### BUGFIX_CAT001    ,     
; 26299: 			//gObjClearViewport(&gObj[aIndex]); //      , 
; 26300: 			GCTeleportSend(&gObj[aIndex], -1, mapnumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);

  00765	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0076c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00772	0f b6 94 01 08
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+264]
  0077a	52		 push	 edx
  0077b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00782	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00788	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00790	52		 push	 edx
  00791	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00798	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0079e	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  007a6	52		 push	 edx
  007a7	0f b6 45 0c	 movzx	 eax, BYTE PTR _mapnumber$[ebp]
  007ab	50		 push	 eax
  007ac	68 ff 00 00 00	 push	 255			; 000000ffH
  007b1	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  007b8	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007be	51		 push	 ecx
  007bf	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  007c4	83 c4 18	 add	 esp, 24			; 00000018H

; 26301: 
; 26302: 			//    			
; 26303: 			gObjClearViewportOfMine( lpObj );

  007c7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007ca	50		 push	 eax
  007cb	e8 00 00 00 00	 call	 ?gObjClearViewportOfMine@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewportOfMine
  007d0	83 c4 04	 add	 esp, 4

; 26304: 
; 26305: 	//BUGFIX_CAT001 ########
; 26306: 
; 26307: 			if( lpObj->m_Change >= 0 )

  007d3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007d6	83 b8 a8 02 00
	00 00		 cmp	 DWORD PTR [eax+680], 0
  007dd	7c 16		 jl	 SHORT $LN19@gObjMovePl

; 26308: 			{
; 26309: 				gObjViewportListProtocolCreate(&gObj[aIndex]);

  007df	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  007e6	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007ec	50		 push	 eax
  007ed	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  007f2	83 c4 04	 add	 esp, 4
$LN19@gObjMovePl:

; 26310: 			}
; 26311: 
; 26312: 			gObj[aIndex].RegenOk   = 1;

  007f5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  007fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00802	c6 84 01 ff 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+511], 1

; 26313: 			return FALSE;

  0080a	33 c0		 xor	 eax, eax
  0080c	e9 80 04 00 00	 jmp	 $LN1@gObjMovePl
$LN16@gObjMovePl:

; 26314: 		}
; 26315: 
; 26316: 		if( lpObj->m_RecallMon >= 0 ) 

  00811	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00814	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  0081b	7c 1c		 jl	 SHORT $LN15@gObjMovePl

; 26317: 		{
; 26318: 			GCRecallMonLife(aIndex, 60, 0);

  0081d	6a 00		 push	 0
  0081f	6a 3c		 push	 60			; 0000003cH
  00821	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00824	50		 push	 eax
  00825	e8 00 00 00 00	 call	 ?GCRecallMonLife@@YAXHHH@Z ; GCRecallMonLife
  0082a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 26319: 			gObjMonsterCallKill(aIndex);

  0082d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00830	50		 push	 eax
  00831	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  00836	83 c4 04	 add	 esp, 4
$LN15@gObjMovePl:

; 26320: 		}
; 26321: 	}
; 26322: #endif
; 26323: 
; 26324: #ifdef ADD_NEW_MAP_KALIMA_20040518					//       .
; 26325: 	if( !CHECK_KALIMAMAP(mapnumber) &&

  00839	0f b6 45 0c	 movzx	 eax, BYTE PTR _mapnumber$[ebp]
  0083d	83 f8 18	 cmp	 eax, 24			; 00000018H
  00840	7d 0c		 jge	 SHORT $LN37@gObjMovePl
  00842	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv427[ebp], 0
  0084c	eb 2b		 jmp	 SHORT $LN38@gObjMovePl
$LN37@gObjMovePl:
  0084e	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _mapnumber$[ebp]
  00852	83 f9 1d	 cmp	 ecx, 29			; 0000001dH
  00855	7e 0c		 jle	 SHORT $LN35@gObjMovePl
  00857	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv426[ebp], 0
  00861	eb 0a		 jmp	 SHORT $LN36@gObjMovePl
$LN35@gObjMovePl:
  00863	c7 85 98 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv426[ebp], 1
$LN36@gObjMovePl:
  0086d	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR tv426[ebp]
  00873	89 95 9c fe ff
	ff		 mov	 DWORD PTR tv427[ebp], edx
$LN38@gObjMovePl:
  00879	83 bd 9c fe ff
	ff 00		 cmp	 DWORD PTR tv427[ebp], 0
  00880	0f 85 b4 00 00
	00		 jne	 $LN21@gObjMovePl
  00886	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00889	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00890	83 f9 18	 cmp	 ecx, 24			; 00000018H
  00893	7d 0c		 jge	 SHORT $LN41@gObjMovePl
  00895	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv436[ebp], 0
  0089f	eb 31		 jmp	 SHORT $LN42@gObjMovePl
$LN41@gObjMovePl:
  008a1	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008a4	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  008ab	83 f8 1d	 cmp	 eax, 29			; 0000001dH
  008ae	7e 0c		 jle	 SHORT $LN39@gObjMovePl
  008b0	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv435[ebp], 0
  008ba	eb 0a		 jmp	 SHORT $LN40@gObjMovePl
$LN39@gObjMovePl:
  008bc	c7 85 98 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv435[ebp], 1
$LN40@gObjMovePl:
  008c6	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR tv435[ebp]
  008cc	89 8d 9c fe ff
	ff		 mov	 DWORD PTR tv436[ebp], ecx
$LN42@gObjMovePl:
  008d2	83 bd 9c fe ff
	ff 00		 cmp	 DWORD PTR tv436[ebp], 0
  008d9	74 5f		 je	 SHORT $LN21@gObjMovePl

; 26326: 		CHECK_KALIMAMAP(lpObj->MapNumber)
; 26327: 		) 
; 26328: 	{
; 26329: 		//  .
; 26330: 		INT iKalimaGateIndex = lpObj->m_iKalimaGateIndex;			//    

  008db	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008de	8b 88 28 02 00
	00		 mov	 ecx, DWORD PTR [eax+552]
  008e4	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _iKalimaGateIndex$1[ebp], ecx

; 26331: 		if (g_KalimaGate.DeleteKalimaGate(lpObj->m_Index)) {

  008ea	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008ed	8b 08		 mov	 ecx, DWORD PTR [eax]
  008ef	51		 push	 ecx
  008f0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  008f5	e8 00 00 00 00	 call	 ?DeleteKalimaGate@CKalimaGate@@QAEHH@Z ; CKalimaGate::DeleteKalimaGate
  008fa	85 c0		 test	 eax, eax
  008fc	74 3c		 je	 SHORT $LN21@gObjMovePl

; 26332: 			LogAddTD("[Kalima] [%s][%s] Kalima Gate Vanished - User MoveGate (SummonIndex:%d, EnterCount:%d)", 

  008fe	69 85 e0 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _iKalimaGateIndex$1[ebp], 7072
  00908	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0090e	0f be 94 01 2c
	02 00 00	 movsx	 edx, BYTE PTR [ecx+eax+556]
  00916	52		 push	 edx
  00917	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _iKalimaGateIndex$1[ebp]
  0091d	50		 push	 eax
  0091e	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00921	83 c1 73	 add	 ecx, 115		; 00000073H
  00924	51		 push	 ecx
  00925	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00928	83 c2 68	 add	 edx, 104		; 00000068H
  0092b	52		 push	 edx
  0092c	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@OIJJJHHH@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@
  00931	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00937	83 c4 14	 add	 esp, 20			; 00000014H
$LN21@gObjMovePl:

; 26333: 				lpObj->AccountID, 
; 26334: 				lpObj->Name,
; 26335: 				iKalimaGateIndex,
; 26336: 				gObj[iKalimaGateIndex].m_cKalimaGateEnterCount
; 26337: 				);
; 26338: 		}
; 26339: 	}
; 26340: #endif
; 26341: 
; 26342: #ifdef ADD_KANTURU_CONDITION_20060725			
; 26343: 	if( mapnumber == MAP_INDEX_KANTURU_BOSS )
; 26344: 	{
; 26345: 		if( ( lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,3)			// 
; 26346: #ifdef ADD_ITEM_FENRIR_01_20051110
; 26347: 			&& lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,37)			// 
; 26348: #endif			
; 26349: #ifdef MODIFY_KANTURU_ENTERANCE_DARKHORSE_BUGFIX_20080627
; 26350: 			&& lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM(13,4)				// 
; 26351: #endif // MODIFY_KANTURU_ENTERANCE_DARKHORSE_BUGFIX_20080627
; 26352: #ifdef ADD_THIRD_WING_20070525	//    3 	
; 26353: 			&& ( lpObj->pInventory[EQUIPMENT_WING].IsItem() == FALSE ) )	||	//  .
; 26354: #else
; 26355: 			) ||
; 26356: #endif
; 26357: 			 lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM(13,10) ||		// 
; 26358: 			 lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM(13,10)			// 
; 26359: #ifdef ADD_ELITE_SKELETON_WORRIOR_CHANGE_RING_20060830	//   
; 26360: 			|| lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 39 )
; 26361: 			|| lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 39 )	
; 26362: #endif
; 26363: #ifdef HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 26364: 			|| lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 40 )
; 26365: 			|| lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 40 )
; 26366: #endif // HALLOWINDAY_JACK_O_LANTERN_MORPH_RING_20061017
; 26367: #ifdef CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 26368: 			|| lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 41 )
; 26369: 			|| lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 41 )
; 26370: #endif // CHRISTMAS_SANTA_POLYMORPH_RING_20061117
; 26371: #ifdef MODIFY_SNOW_MAN_PANDA_POLYMORPH_RING_BUGFIX_20090715
; 26372: 			|| lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 68 )
; 26373: 			|| lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 68 )
; 26374: 			|| lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM( 13, 76 )
; 26375: 			|| lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM( 13, 76 )
; 26376: #endif // MODIFY_SNOW_MAN_PANDA_POLYMORPH_RING_BUGFIX_20090715
; 26377: 			  )
; 26378: 		{
; 26379: 			//     
; 26380: 			GCServerMsgStringSend(lMsg.Get(1604), lpObj->m_Index, 1);
; 26381: 
; 26382: 			//       .
; 26383: 			x = lpObj->X;
; 26384: 			y = lpObj->Y;
; 26385: 			mapnumber = lpObj->MapNumber;
; 26386: 			dir  = lpObj->Dir;
; 26387: 			movefail = 1;
; 26388: 			lpObj->RegenMapNumber = lpObj->MapNumber;
; 26389: 			lpObj->RegenMapX = (BYTE)x;
; 26390: 			lpObj->RegenMapY = (BYTE)y;
; 26391: 
; 26392: 			//####### BUGFIX_CAT001    ,     
; 26393: 			//gObjClearViewport(&gObj[aIndex]); //      , 
; 26394: 			GCTeleportSend(&gObj[aIndex], -1, mapnumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 26395: 
; 26396: 			//    
; 26397: 			gObjClearViewportOfMine( lpObj );
; 26398: 
; 26399: 			//BUGFIX_CAT001 ########
; 26400: 
; 26401: 			if( lpObj->m_Change >= 0 )
; 26402: 			{
; 26403: 				gObjViewportListProtocolCreate(&gObj[aIndex]);
; 26404: 			}
; 26405: 
; 26406: 			gObj[aIndex].RegenOk   = 1;
; 26407: 			return FALSE;	
; 26408: 
; 26409: 		}
; 26410: 	}
; 26411: #endif	// ADD_KANTURU_CONDITION_20060725
; 26412: 	
; 26413: 
; 26414: 
; 26415: #ifdef MODIFY_KANTURU_MAPNUMBER_CHECK_20060807
; 26416: 	if( g_iBlockKanturuMapEnter == 1 )
; 26417: 	{
; 26418: 		x			= lpObj->X;
; 26419: 		y			= lpObj->Y;
; 26420: 		mapnumber	= lpObj->MapNumber;
; 26421: 		dir			= lpObj->Dir;
; 26422: 		int level		= lpObj->Level;
; 26423: 
; 26424: 		GetMoveArea(x, y, mapnumber, x1, y1, x2, y2, dir);
; 26425: 		
; 26426: 		{
; 26427: 			if( mapnumber >= MAP_INDEX_KANTURU1 && mapnumber <= MAP_INDEX_KANTURU_BOSS )
; 26428: 			{
; 26429: 				//     
; 26430: 				GCServerMsgStringSend(lMsg.Get(1604), lpObj->m_Index, 1);
; 26431: 
; 26432: 				//       .
; 26433: 				x = lpObj->X;
; 26434: 				y = lpObj->Y;
; 26435: 				mapnumber = lpObj->MapNumber;
; 26436: 				dir  = lpObj->Dir;
; 26437: 				movefail = 1;
; 26438: 				lpObj->RegenMapNumber = lpObj->MapNumber;
; 26439: 				lpObj->RegenMapX = (BYTE)x;
; 26440: 				lpObj->RegenMapY = (BYTE)y;
; 26441: 
; 26442: 				//####### BUGFIX_CAT001    ,     
; 26443: 				//gObjClearViewport(&gObj[aIndex]); //      , 
; 26444: 				GCTeleportSend(&gObj[aIndex], -1, mapnumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 26445: 
; 26446: 				//    
; 26447: 				gObjClearViewportOfMine( lpObj );
; 26448: 
; 26449: 				//BUGFIX_CAT001 ########
; 26450: 
; 26451: 				if( lpObj->m_Change >= 0 )
; 26452: 				{
; 26453: 					gObjViewportListProtocolCreate(&gObj[aIndex]);
; 26454: 				}
; 26455: 
; 26456: 				gObj[aIndex].RegenOk   = 1;
; 26457: 				return FALSE;
; 26458: 			}
; 26459: 		}
; 26460: 	}
; 26461: 
; 26462: 	if( g_iBlockCastleSiegeMapEnter == 1 )
; 26463: 	{
; 26464: 		x			= lpObj->X;
; 26465: 		y			= lpObj->Y;
; 26466: 		mapnumber	= lpObj->MapNumber;
; 26467: 		dir			= lpObj->Dir;
; 26468: 		int level		= lpObj->Level;
; 26469: 		
; 26470: 		GetMoveArea(x, y, mapnumber, x1, y1, x2, y2, dir);
; 26471: 		{
; 26472: 			if( mapnumber == MAP_INDEX_CASTLESIEGE
; 26473: 				|| mapnumber == MAP_INDEX_CASTLEHUNTZONE
; 26474: 				|| mapnumber == MAP_INDEX_CRYWOLF_FIRSTZONE
; 26475: 				|| mapnumber == MAP_INDEX_CRYWOLF_SECONDZONE )
; 26476: 			{
; 26477: 				//     
; 26478: 				GCServerMsgStringSend(lMsg.Get(1604), lpObj->m_Index, 1);
; 26479: 
; 26480: 				//       .
; 26481: 				x = lpObj->X;
; 26482: 				y = lpObj->Y;
; 26483: 				mapnumber = lpObj->MapNumber;
; 26484: 				dir  = lpObj->Dir;
; 26485: 				movefail = 1;
; 26486: 				lpObj->RegenMapNumber = lpObj->MapNumber;
; 26487: 				lpObj->RegenMapX = (BYTE)x;
; 26488: 				lpObj->RegenMapY = (BYTE)y;
; 26489: 
; 26490: 				//####### BUGFIX_CAT001    ,     
; 26491: 				//gObjClearViewport(&gObj[aIndex]); //      , 
; 26492: 				GCTeleportSend(&gObj[aIndex], -1, mapnumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 26493: 
; 26494: 				//    
; 26495: 				gObjClearViewportOfMine( lpObj );
; 26496: 
; 26497: 				//BUGFIX_CAT001 ########
; 26498: 
; 26499: 				if( lpObj->m_Change >= 0 )
; 26500: 				{
; 26501: 					gObjViewportListProtocolCreate(&gObj[aIndex]);
; 26502: 				}
; 26503: 
; 26504: 				gObj[aIndex].RegenOk   = 1;
; 26505: 				return FALSE;
; 26506: 			}
; 26507: 		}
; 26508: 	}
; 26509: #endif // MODIFY_KANTURU_MAPNUMBER_CHECK_20060807
; 26510: 
; 26511: #if 0 //def ADD_RAKLION_20080408
; 26512: 	if( mapnumber == MAP_INDEX_RAKLION_BOSS )
; 26513: 	{
; 26514: 		if( g_Raklion.GetRaklionState() >= RAKLION_STATE_CLOSE_DOOR )
; 26515: 		{
; 26516: 			//     
; 26517: 			GCServerMsgStringSend(lMsg.Get(3415), lpObj->m_Index, 1);
; 26518: 			
; 26519: 			//       .
; 26520: 			x = lpObj->X;
; 26521: 			y = lpObj->Y;
; 26522: 			mapnumber = lpObj->MapNumber;
; 26523: 			dir  = lpObj->Dir;
; 26524: 			movefail = 1;
; 26525: 			lpObj->RegenMapNumber = lpObj->MapNumber;
; 26526: 			lpObj->RegenMapX = (BYTE)x;
; 26527: 			lpObj->RegenMapY = (BYTE)y;
; 26528: 			
; 26529: 			GCTeleportSend(&gObj[aIndex], -1, mapnumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 26530: 			
; 26531: 			gObjClearViewportOfMine( lpObj );
; 26532: 			
; 26533: 			if( lpObj->m_Change >= 0 )
; 26534: 			{
; 26535: 				gObjViewportListProtocolCreate(&gObj[aIndex]);
; 26536: 			}
; 26537: 			
; 26538: 			gObj[aIndex].RegenOk   = 1;
; 26539: 			return FALSE;
; 26540: 		}
; 26541: 		else
; 26542: 		{
; 26543: 			if( gt == 290 )
; 26544: 				g_RaklionBattleUserMng.AddUserData( aIndex );
; 26545: 		}
; 26546: 	}
; 26547: 	if( mapnumber == MAP_INDEX_RAKLION_FIELD )
; 26548: 	{
; 26549: 		if( gt == 292 )	//  ->   
; 26550: 		{
; 26551: 			if( g_Raklion.GetRaklionState() >= RAKLION_STATE_CLOSE_DOOR )	//   
; 26552: 			{
; 26553: 				//     
; 26554: 				GCServerMsgStringSend(lMsg.Get(3416), lpObj->m_Index, 1);
; 26555: 				
; 26556: 				//       .
; 26557: 				x = lpObj->X;
; 26558: 				y = lpObj->Y;
; 26559: 				mapnumber = lpObj->MapNumber;
; 26560: 				dir  = lpObj->Dir;
; 26561: 				movefail = 1;
; 26562: 				lpObj->RegenMapNumber = lpObj->MapNumber;
; 26563: 				lpObj->RegenMapX = (BYTE)x;
; 26564: 				lpObj->RegenMapY = (BYTE)y;
; 26565: 				
; 26566: 				GCTeleportSend(&gObj[aIndex], -1, mapnumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 26567: 				
; 26568: 				gObjClearViewportOfMine( lpObj );
; 26569: 				
; 26570: 				if( lpObj->m_Change >= 0 )
; 26571: 				{
; 26572: 					gObjViewportListProtocolCreate(&gObj[aIndex]);
; 26573: 				}
; 26574: 				
; 26575: 				gObj[aIndex].RegenOk   = 1;
; 26576: 				return FALSE;
; 26577: 			}
; 26578: 			else
; 26579: 			{
; 26580: 				g_RaklionBattleUserMng.DeleteUserData( aIndex );
; 26581: 			}
; 26582: 		}
; 26583: 		else
; 26584: 		{	//  ->  .        .
; 26585: 			g_RaklionUtil.NotifyRaklionCurrentState( aIndex, g_Raklion.GetRaklionState(),
; 26586: 				g_Raklion.GetRaklionStateDetail() );
; 26587: 		}
; 26588: 	}
; 26589: #endif // ADD_RAKLION_20080408
; 26590: 
; 26591: 	if( gObj[aIndex].m_IfState.use )

  0093a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00941	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00947	8a 94 01 56 0c
	00 00		 mov	 dl, BYTE PTR [ecx+eax+3158]
  0094e	80 e2 03	 and	 dl, 3
  00951	0f b6 c2	 movzx	 eax, dl
  00954	85 c0		 test	 eax, eax
  00956	74 3b		 je	 SHORT $LN23@gObjMovePl

; 26592: 	{
; 26593: 		x = lpObj->X;

  00958	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0095b	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  00962	66 89 4d f0	 mov	 WORD PTR _x$[ebp], cx

; 26594: 		y = lpObj->Y;

  00966	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00969	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  00970	66 89 4d ec	 mov	 WORD PTR _y$[ebp], cx

; 26595: 		mapnumber = lpObj->MapNumber;

  00974	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00977	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  0097d	88 4d 0c	 mov	 BYTE PTR _mapnumber$[ebp], cl

; 26596: 		dir  = lpObj->Dir;

  00980	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00983	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  00989	88 4d eb	 mov	 BYTE PTR _dir$[ebp], cl

; 26597: 		movefail = 1;

  0098c	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 1
$LN23@gObjMovePl:

; 26598: 		//LogAddL("     ");
; 26599: 	}
; 26600: 	if( gObj[aIndex].DieRegen ) 

  00993	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0099a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  009a0	0f be 94 01 fe
	01 00 00	 movsx	 edx, BYTE PTR [ecx+eax+510]
  009a8	85 d2		 test	 edx, edx
  009aa	74 3b		 je	 SHORT $LN24@gObjMovePl

; 26601: 	{
; 26602: 		x = lpObj->X;

  009ac	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009af	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  009b6	66 89 4d f0	 mov	 WORD PTR _x$[ebp], cx

; 26603: 		y = lpObj->Y;

  009ba	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009bd	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  009c4	66 89 4d ec	 mov	 WORD PTR _y$[ebp], cx

; 26604: 		mapnumber = lpObj->MapNumber;

  009c8	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009cb	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  009d1	88 4d 0c	 mov	 BYTE PTR _mapnumber$[ebp], cl

; 26605: 		dir  = lpObj->Dir;

  009d4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009d7	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  009dd	88 4d eb	 mov	 BYTE PTR _dir$[ebp], cl

; 26606: 		movefail = 1;

  009e0	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _movefail$[ebp], 1
$LN24@gObjMovePl:

; 26607: 		//LogAddL("  %d", mapNumber);
; 26608: 	}
; 26609: 
; 26610: 	lpObj->m_State = OBJST_DELCMD;

  009e7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009ea	c7 80 b8 01 00
	00 20 00 00 00	 mov	 DWORD PTR [eax+440], 32	; 00000020H

; 26611: 	if( movefail == 0 )

  009f4	83 7d e4 00	 cmp	 DWORD PTR _movefail$[ebp], 0
  009f8	0f 85 e1 01 00
	00		 jne	 $LN25@gObjMovePl

; 26612: 	{
; 26613: #ifdef MAP_SERVER_WORK_20041030		//   
; 26614: 		GetMoveArea(x,y,mapnumber,x1,y1,x2,y2,dir);
; 26615: 		{
; 26616: 			if (gObj[aIndex].MapNumber != mapnumber) {
; 26617: 				//        .
; 26618: 				if( !MapNumberCheck(mapnumber) ) 
; 26619: 				{
; 26620: 					LogAdd("error-L3 : %s %d", __FILE__, __LINE__);
; 26621: 					return FALSE;
; 26622: 				}
; 26623: 				
; 26624: 				SHORT sSvrCode	= g_MapServerManager.CheckMoveMapSvr(lpObj->m_Index, mapnumber, lpObj->m_sPrevMapSvrCode);
; 26625: 				if (sSvrCode != gGameServerCode) {
; 26626: 					if (sSvrCode == -1) {
; 26627: 						//   ->  
; 26628: 						LogAddC(LOGC_RED, "[MapServerMng] Map Server Move Fail : CheckMoveMapSvr() == -1 [%s][%s] (%d)",
; 26629: 							lpObj->AccountID,
; 26630: 							lpObj->Name,
; 26631: 							lpObj->m_Index
; 26632: 							);
; 26633: 						return FALSE;
; 26634: 					}
; 26635: 
; 26636: 					//      . (b4nfter)
; 26637: /*					if (gGateC.CheckGateLevel(aIndex, gt) == FALSE) {
; 26638: 						//    
; 26639: 						x = lpObj->X;
; 26640: 						y = lpObj->Y;
; 26641: 						mapnumber = lpObj->MapNumber;
; 26642: 						dir  = lpObj->Dir;
; 26643: 						movefail = 1;
; 26644: 						lpObj->RegenMapNumber = lpObj->MapNumber;
; 26645: 						lpObj->RegenMapX = (BYTE)x;
; 26646: 						lpObj->RegenMapY = (BYTE)y;		
; 26647: 						gObjClearViewport(&gObj[aIndex]);
; 26648: 						GCTeleportSend(&gObj[aIndex], -1, mapnumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);
; 26649: 
; 26650: 						if( lpObj->m_Change >= 0 )
; 26651: 						{
; 26652: 							gObjViewportListProtocolCreate(&gObj[aIndex]);
; 26653: 						}
; 26654: 
; 26655: 						gObj[aIndex].RegenOk   = 1;
; 26656: 
; 26657: #ifdef CASTLE_MAIN_SCHEDULER_20041111		//        
; 26658: 						if (gObj[aIndex].MapNumber == MAP_INDEX_CASTLESIEGE &&
; 26659: 							g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE
; 26660: 							)
; 26661: 						{
; 26662: 							g_CastleSiege.NotifySelfCsJoinSide (aIndex);
; 26663: 							g_CastleSiege.NotifyCsSelfLeftTime (aIndex);
; 26664: 						}
; 26665: #endif
; 26666: 						return FALSE;
; 26667: 					}*/
; 26668: 
; 26669: 					//     .
; 26670: 					GJReqMapSvrMove (lpObj->m_Index, sSvrCode, mapnumber, x, y);
; 26671: 					LogAddTD("[MapServerMng] Request to Move Map Server : (%d) - [%s][%s] (%d)",
; 26672: 						sSvrCode,
; 26673: 						lpObj->AccountID,
; 26674: 						lpObj->Name,
; 26675: 						lpObj->m_Index
; 26676: 						);
; 26677: 					return FALSE;
; 26678: 				}
; 26679: 			}
; 26680: 		}
; 26681: #endif
; 26682: 
; 26683: #ifdef EXTEND_LOG_SYSTEM_20060202
; 26684: 		LogAddTD("[MoveMap][%s][%s] : (Before:Map:%d X:%d Y:%d) -> (New Map:%d X:%d Y:%d)",
; 26685: 			lpObj->AccountID,	lpObj->Name,
; 26686: 			lpObj->MapNumber,	lpObj->X,	lpObj->Y, 
; 26687: 			mapnumber, x, y );
; 26688: #endif
; 26689: 
; 26690: 		gObj[aIndex].X = x;

  009fe	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a05	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a0b	66 8b 55 f0	 mov	 dx, WORD PTR _x$[ebp]
  00a0f	66 89 94 01 04
	01 00 00	 mov	 WORD PTR [ecx+eax+260], dx

; 26691: 		gObj[aIndex].Y = y;

  00a17	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a1e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a24	66 8b 55 ec	 mov	 dx, WORD PTR _y$[ebp]
  00a28	66 89 94 01 06
	01 00 00	 mov	 WORD PTR [ecx+eax+262], dx

; 26692: 		gObj[aIndex].TX = x;

  00a30	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a37	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a3d	66 8b 55 f0	 mov	 dx, WORD PTR _x$[ebp]
  00a41	66 89 94 01 20
	01 00 00	 mov	 WORD PTR [ecx+eax+288], dx

; 26693: #ifdef MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 26694: 		gObj[aIndex].TY = y;

  00a49	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a50	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a56	66 8b 55 ec	 mov	 dx, WORD PTR _y$[ebp]
  00a5a	66 89 94 01 22
	01 00 00	 mov	 WORD PTR [ecx+eax+290], dx

; 26695: #else	// MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 26696: 		gObj[aIndex].TX = y;
; 26697: #endif	// MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 26698: 		gObj[aIndex].MapNumber = mapnumber;

  00a62	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a69	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a6f	8a 55 0c	 mov	 dl, BYTE PTR _mapnumber$[ebp]
  00a72	88 94 01 09 01
	00 00		 mov	 BYTE PTR [ecx+eax+265], dl

; 26699: 		gObj[aIndex].Dir = dir; 

  00a79	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a80	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a86	8a 55 eb	 mov	 dl, BYTE PTR _dir$[ebp]
  00a89	88 94 01 08 01
	00 00		 mov	 BYTE PTR [ecx+eax+264], dl

; 26700: 		gObj[aIndex].PathCount = 0;

  00a90	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00a97	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00a9d	c7 84 01 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+296], 0

; 26701: 		gObj[aIndex].Teleport  = 0;

  00aa8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00aaf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ab5	c6 84 01 fc 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+508], 0

; 26702: 
; 26703: #ifdef MODIFY_AFTERIMAGE_BUGFIX_20060215
; 26704: 		//     .
; 26705: 		//  : Map     
; 26706: 		gObjViewportListProtocolDestroy(&gObj[aIndex]);
; 26707: #endif
; 26708: 
; 26709: #ifdef MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 26710: 		gObjViewportListProtocolDestroy(&gObj[aIndex]);

  00abd	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00ac4	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00aca	50		 push	 eax
  00acb	e8 00 00 00 00	 call	 ?gObjViewportListProtocolDestroy@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy
  00ad0	83 c4 04	 add	 esp, 4

; 26711: 		//gObjViewportListProtocolCreate(&gObj[aIndex]);
; 26712: #endif	// MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 26713: 
; 26714: #ifndef MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 26715: 		gObjClearViewport(&gObj[aIndex]);
; 26716: #endif	// MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 26717: 		GCTeleportSend(&gObj[aIndex], -1, mapnumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);

  00ad3	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00ada	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ae0	0f b6 94 01 08
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+264]
  00ae8	52		 push	 edx
  00ae9	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00af0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00af6	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00afe	52		 push	 edx
  00aff	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00b06	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b0c	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  00b14	52		 push	 edx
  00b15	0f b6 45 0c	 movzx	 eax, BYTE PTR _mapnumber$[ebp]
  00b19	50		 push	 eax
  00b1a	68 ff 00 00 00	 push	 255			; 000000ffH
  00b1f	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00b26	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b2c	51		 push	 ecx
  00b2d	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  00b32	83 c4 18	 add	 esp, 24			; 00000018H

; 26718: 
; 26719: #ifdef MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 26720: 		gObjViewportListProtocolCreate(&gObj[aIndex]);

  00b35	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00b3c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b42	50		 push	 eax
  00b43	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00b48	83 c4 04	 add	 esp, 4

; 26721: 		gObjClearViewport(&gObj[aIndex]);

  00b4b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00b52	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b58	50		 push	 eax
  00b59	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  00b5e	83 c4 04	 add	 esp, 4

; 26722: #endif	// MODIFY_MAPMOVE_POSITION_SYNC_BUGFIX_200981024
; 26723: 		
; 26724: 		if( lpObj->m_Change >= 0 )

  00b61	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b64	83 b8 a8 02 00
	00 00		 cmp	 DWORD PTR [eax+680], 0
  00b6b	7c 16		 jl	 SHORT $LN27@gObjMovePl

; 26725: 		{
; 26726: 			gObjViewportListProtocolCreate(&gObj[aIndex]);

  00b6d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00b74	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b7a	50		 push	 eax
  00b7b	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00b80	83 c4 04	 add	 esp, 4
$LN27@gObjMovePl:

; 26727: 		}
; 26728: 
; 26729: 		gObj[aIndex].RegenMapNumber = mapnumber;

  00b83	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00b8a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00b90	8a 55 0c	 mov	 dl, BYTE PTR _mapnumber$[ebp]
  00b93	88 94 01 00 02
	00 00		 mov	 BYTE PTR [ecx+eax+512], dl

; 26730: 		gObj[aIndex].RegenMapX = (BYTE)x;

  00b9a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00ba1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00ba7	8a 55 f0	 mov	 dl, BYTE PTR _x$[ebp]
  00baa	88 94 01 01 02
	00 00		 mov	 BYTE PTR [ecx+eax+513], dl

; 26731: 		gObj[aIndex].RegenMapY = (BYTE)y;		

  00bb1	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00bb8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bbe	8a 55 ec	 mov	 dl, BYTE PTR _y$[ebp]
  00bc1	88 94 01 02 02
	00 00		 mov	 BYTE PTR [ecx+eax+514], dl

; 26732: 		gObj[aIndex].RegenOk   = 1;

  00bc8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00bcf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bd5	c6 84 01 ff 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+511], 1

; 26733: 	}

  00bdd	eb 77		 jmp	 SHORT $LN26@gObjMovePl
$LN25@gObjMovePl:

; 26734: 	else
; 26735: 	{
; 26736: 		GCTeleportSend(&gObj[aIndex], -1, mapnumber, (BYTE)gObj[aIndex].X, (BYTE)gObj[aIndex].Y, gObj[aIndex].Dir);

  00bdf	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00be6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bec	0f b6 94 01 08
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+264]
  00bf4	52		 push	 edx
  00bf5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00bfc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c02	0f b6 94 01 06
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+262]
  00c0a	52		 push	 edx
  00c0b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00c12	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c18	0f b6 94 01 04
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+260]
  00c20	52		 push	 edx
  00c21	0f b6 45 0c	 movzx	 eax, BYTE PTR _mapnumber$[ebp]
  00c25	50		 push	 eax
  00c26	68 ff 00 00 00	 push	 255			; 000000ffH
  00c2b	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00c32	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c38	51		 push	 ecx
  00c39	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  00c3e	83 c4 18	 add	 esp, 24			; 00000018H

; 26737: 		gObj[aIndex].RegenOk   = 1;

  00c41	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00c48	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c4e	c6 84 01 ff 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+511], 1
$LN26@gObjMovePl:

; 26738: 	
; 26739: 
; 26740: #ifdef CASTLE_MAIN_SCHEDULER_20041111						//        
; 26741: 		if (lpObj->MapNumber == MAP_INDEX_CASTLESIEGE &&
; 26742: 			g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE
; 26743: 			)
; 26744: 		{
; 26745: 			g_CastleSiege.NotifySelfCsJoinSide (aIndex);
; 26746: 			g_CastleSiege.NotifyCsSelfLeftTime (aIndex);
; 26747: 		}
; 26748: #endif
; 26749: 	}
; 26750: 	//LogAddL("  ");
; 26751: 
; 26752: 	if( movefail )

  00c56	83 7d e4 00	 cmp	 DWORD PTR _movefail$[ebp], 0
  00c5a	74 04		 je	 SHORT $LN28@gObjMovePl

; 26753: 		return FALSE;

  00c5c	33 c0		 xor	 eax, eax
  00c5e	eb 31		 jmp	 SHORT $LN1@gObjMovePl
$LN28@gObjMovePl:

; 26754: 
; 26755: 	if( gObj[aIndex].Type == OBJTYPE_CHARACTER )

  00c60	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00c67	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c6d	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00c72	83 fa 01	 cmp	 edx, 1
  00c75	75 15		 jne	 SHORT $LN29@gObjMovePl

; 26756: 	{
; 26757: 		gObj[aIndex].m_LastTeleportTime = 10;				//  ,         

  00c77	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00c7e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00c84	c6 84 01 e9 0e
	00 00 0a	 mov	 BYTE PTR [ecx+eax+3817], 10 ; 0000000aH
$LN29@gObjMovePl:

; 26758: 	}
; 26759: 	
; 26760: #ifdef ADD_NEWPVP_PKFIELD
; 26761: 	g_NewPVP.Reset(*lpObj);
; 26762: #endif // ADD_NEWPVP_PKFIELD
; 26763: 
; 26764: 	return TRUE;

  00c8c	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjMovePl:

; 26765: }

  00c91	5f		 pop	 edi
  00c92	5e		 pop	 esi
  00c93	5b		 pop	 ebx
  00c94	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c97	33 cd		 xor	 ecx, ebp
  00c99	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c9e	8b e5		 mov	 esp, ebp
  00ca0	5d		 pop	 ebp
  00ca1	c3		 ret	 0
?gObjMovePlayer@@YAHHEEEEE@Z ENDP			; gObjMovePlayer
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjPosMagicAttack@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@EE@Z
_TEXT	SEGMENT
tv66 = -380						; size = 4
_n$1 = -312						; size = 4
_MVL$ = -308						; size = 4
_pResult$ = -304					; size = 2
_pCount$ = -300						; size = 9
_MagicNumber$ = -285					; size = 1
_lOfs$ = -284						; size = 4
_sbuf$ = -280						; size = 256
_MagicDistance$ = -24					; size = 4
_ty$ = -20						; size = 4
_tx$ = -16						; size = 4
_dis$ = -12						; size = 4
_tObjNum$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
_x$ = 16						; size = 1
_y$ = 20						; size = 1
?gObjPosMagicAttack@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@EE@Z PROC ; gObjPosMagicAttack, COMDAT

; 27928: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 7c 01 00
	00		 sub	 esp, 380		; 0000017cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 27929: 	int tObjNum;
; 27930: 	int dis;
; 27931: 	int tx, ty;
; 27932: 	int MagicDistance=3;

  00016	c7 45 e8 03 00
	00 00		 mov	 DWORD PTR _MagicDistance$[ebp], 3

; 27933: 	BYTE sbuf[256];
; 27934: 	int lOfs=0;

  0001d	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 0

; 27935: 	BYTE MagicNumber = lpMagic->m_Skill;

  00027	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  0002a	8a 48 05	 mov	 cl, BYTE PTR [eax+5]
  0002d	88 8d e3 fe ff
	ff		 mov	 BYTE PTR _MagicNumber$[ebp], cl

; 27936: 
; 27937: 	//    .
; 27938: 	switch( MagicNumber )

  00033	8a 85 e3 fe ff
	ff		 mov	 al, BYTE PTR _MagicNumber$[ebp]
  00039	88 85 84 fe ff
	ff		 mov	 BYTE PTR tv66[ebp], al
  0003f	80 bd 84 fe ff
	ff 09		 cmp	 BYTE PTR tv66[ebp], 9
  00046	74 02		 je	 SHORT $LN7@gObjPosMag
  00048	eb 09		 jmp	 SHORT $LN8@gObjPosMag
$LN7@gObjPosMag:

; 27939: 	{
; 27940: 	case AT_SKILL_EVIL : MagicDistance = 3; break;

  0004a	c7 45 e8 03 00
	00 00		 mov	 DWORD PTR _MagicDistance$[ebp], 3
  00051	eb 07		 jmp	 SHORT $LN2@gObjPosMag
$LN8@gObjPosMag:

; 27941: 	default : MagicDistance = 3; break;

  00053	c7 45 e8 03 00
	00 00		 mov	 DWORD PTR _MagicDistance$[ebp], 3
$LN2@gObjPosMag:

; 27942: 	}
; 27943: 
; 27944: 	PMSG_POSMAGIC_COUNT		pCount;
; 27945: 	PMSG_POSMAGIC_RESULT	pResult;
; 27946: 
; 27947: 	lOfs = sizeof(pCount);

  0005a	c7 85 e4 fe ff
	ff 09 00 00 00	 mov	 DWORD PTR _lOfs$[ebp], 9

; 27948: 
; 27949: 	pCount.h.c          = PMHC_BYTE;

  00064	c6 85 d4 fe ff
	ff c1		 mov	 BYTE PTR _pCount$[ebp], 193 ; 000000c1H

; 27950: 	pCount.h.headcode   = 0x1A;

  0006b	c6 85 d6 fe ff
	ff 1a		 mov	 BYTE PTR _pCount$[ebp+2], 26 ; 0000001aH

; 27951: 	pCount.h.size       = 0;

  00072	c6 85 d5 fe ff
	ff 00		 mov	 BYTE PTR _pCount$[ebp+1], 0

; 27952: 	pCount.MapX			= x;

  00079	8a 45 10	 mov	 al, BYTE PTR _x$[ebp]
  0007c	88 85 da fe ff
	ff		 mov	 BYTE PTR _pCount$[ebp+6], al

; 27953: 	pCount.MapY			= y;

  00082	8a 45 14	 mov	 al, BYTE PTR _y$[ebp]
  00085	88 85 db fe ff
	ff		 mov	 BYTE PTR _pCount$[ebp+7], al

; 27954: 	pCount.MagicNumber	= MagicNumber;

  0008b	8a 85 e3 fe ff
	ff		 mov	 al, BYTE PTR _MagicNumber$[ebp]
  00091	88 85 d9 fe ff
	ff		 mov	 BYTE PTR _pCount$[ebp+5], al

; 27955: 	pCount.NumberH		= HIBYTE(lpObj->m_Index);

  00097	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009c	c1 e9 08	 shr	 ecx, 8
  0009f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000a5	88 8d d7 fe ff
	ff		 mov	 BYTE PTR _pCount$[ebp+3], cl

; 27956: 	pCount.NumberL		= LOBYTE(lpObj->m_Index);

  000ab	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ae	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b0	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000b6	88 8d d8 fe ff
	ff		 mov	 BYTE PTR _pCount$[ebp+4], cl

; 27957: 	pCount.Count		= 0;

  000bc	c6 85 dc fe ff
	ff 00		 mov	 BYTE PTR _pCount$[ebp+8], 0

; 27958: 
; 27959: 	int MVL = MAXVIEWPORTOBJECT;

  000c3	c7 85 cc fe ff
	ff 4b 00 00 00	 mov	 DWORD PTR _MVL$[ebp], 75 ; 0000004bH

; 27960: 	if( lpObj->Type == OBJTYPE_MONSTER ) MVL = MAX_MONVIEWPORTOBJECT;

  000cd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d0	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  000d4	83 f9 02	 cmp	 ecx, 2
  000d7	75 0a		 jne	 SHORT $LN9@gObjPosMag
  000d9	c7 85 cc fe ff
	ff 14 00 00 00	 mov	 DWORD PTR _MVL$[ebp], 20 ; 00000014H
$LN9@gObjPosMag:

; 27961: 
; 27962: 	for(int n=0; n<MVL; n++)

  000e3	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1[ebp], 0
  000ed	eb 0f		 jmp	 SHORT $LN6@gObjPosMag
$LN4@gObjPosMag:
  000ef	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  000f5	83 c0 01	 add	 eax, 1
  000f8	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _n$1[ebp], eax
$LN6@gObjPosMag:
  000fe	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _n$1[ebp]
  00104	3b 85 cc fe ff
	ff		 cmp	 eax, DWORD PTR _MVL$[ebp]
  0010a	0f 8d 9e 01 00
	00		 jge	 $LN5@gObjPosMag

; 27963: 	{
; 27964: 		if( lpObj->VpPlayer[n].state )

  00110	6b 85 c8 fe ff
	ff 0c		 imul	 eax, DWORD PTR _n$1[ebp], 12
  00117	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0011a	0f be 94 01 64
	03 00 00	 movsx	 edx, BYTE PTR [ecx+eax+868]
  00122	85 d2		 test	 edx, edx
  00124	0f 84 7f 01 00
	00		 je	 $LN15@gObjPosMag

; 27965: 		{
; 27966: 			tObjNum = lpObj->VpPlayer[n].number;

  0012a	6b 85 c8 fe ff
	ff 0c		 imul	 eax, DWORD PTR _n$1[ebp], 12
  00131	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00134	0f bf 94 01 66
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax+870]
  0013c	89 55 f8	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 27967: 			if( tObjNum >= 0 )

  0013f	83 7d f8 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  00143	0f 8c 60 01 00
	00		 jl	 $LN15@gObjPosMag

; 27968: 			{
; 27969: 				if( gObj[tObjNum].Live )	//   ..

  00149	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00150	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00156	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  0015b	85 d2		 test	 edx, edx
  0015d	0f 84 46 01 00
	00		 je	 $LN15@gObjPosMag

; 27970: 				{
; 27971: 					tx = lpObj->X-gObj[tObjNum].X;

  00163	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00166	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0016d	69 55 f8 a0 1b
	00 00		 imul	 edx, DWORD PTR _tObjNum$[ebp], 7072
  00174	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00179	0f bf 94 10 04
	01 00 00	 movsx	 edx, WORD PTR [eax+edx+260]
  00181	2b ca		 sub	 ecx, edx
  00183	89 4d f0	 mov	 DWORD PTR _tx$[ebp], ecx

; 27972: 					ty = lpObj->Y-gObj[tObjNum].Y;

  00186	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00189	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00190	69 55 f8 a0 1b
	00 00		 imul	 edx, DWORD PTR _tObjNum$[ebp], 7072
  00197	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019c	0f bf 94 10 06
	01 00 00	 movsx	 edx, WORD PTR [eax+edx+262]
  001a4	2b ca		 sub	 ecx, edx
  001a6	89 4d ec	 mov	 DWORD PTR _ty$[ebp], ecx

; 27973: 					dis = (int)sqrt((double)(tx*tx)+(ty*ty));

  001a9	8b 45 f0	 mov	 eax, DWORD PTR _tx$[ebp]
  001ac	0f af 45 f0	 imul	 eax, DWORD PTR _tx$[ebp]
  001b0	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  001b4	8b 4d ec	 mov	 ecx, DWORD PTR _ty$[ebp]
  001b7	0f af 4d ec	 imul	 ecx, DWORD PTR _ty$[ebp]
  001bb	f2 0f 2a c9	 cvtsi2sd xmm1, ecx
  001bf	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001c3	83 ec 08	 sub	 esp, 8
  001c6	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001cb	e8 00 00 00 00	 call	 _sqrt
  001d0	83 c4 08	 add	 esp, 8
  001d3	e8 00 00 00 00	 call	 __ftol2_sse
  001d8	89 45 f4	 mov	 DWORD PTR _dis$[ebp], eax

; 27974: 					
; 27975: 					if( dis <= MagicDistance )	//   

  001db	8b 45 f4	 mov	 eax, DWORD PTR _dis$[ebp]
  001de	3b 45 e8	 cmp	 eax, DWORD PTR _MagicDistance$[ebp]
  001e1	0f 8f c2 00 00
	00		 jg	 $LN15@gObjPosMag

; 27976: 					{
; 27977: 						if( gObjAttack(lpObj, &gObj[tObjNum], lpMagic, 0, 0) == TRUE)

  001e7	6a 00		 push	 0
  001e9	6a 00		 push	 0
  001eb	6a 00		 push	 0
  001ed	6a 00		 push	 0
  001ef	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  001f2	50		 push	 eax
  001f3	69 4d f8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _tObjNum$[ebp], 7072
  001fa	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00200	51		 push	 ecx
  00201	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00204	52		 push	 edx
  00205	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  0020a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0020d	83 f8 01	 cmp	 eax, 1
  00210	0f 85 93 00 00
	00		 jne	 $LN15@gObjPosMag

; 27978: 						{
; 27979: 							pResult.NumberH = HIBYTE(tObjNum);

  00216	8b 45 f8	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  00219	c1 e8 08	 shr	 eax, 8
  0021c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00221	88 85 d0 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp], al

; 27980: 							pResult.NumberL = LOBYTE(tObjNum);

  00227	8b 45 f8	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  0022a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0022f	88 85 d1 fe ff
	ff		 mov	 BYTE PTR _pResult$[ebp+1], al

; 27981: 							memcpy(sbuf+lOfs, &pResult, sizeof(pResult));

  00235	6a 02		 push	 2
  00237	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _pResult$[ebp]
  0023d	50		 push	 eax
  0023e	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _lOfs$[ebp]
  00244	8d 94 0d e8 fe
	ff ff		 lea	 edx, DWORD PTR _sbuf$[ebp+ecx]
  0024b	52		 push	 edx
  0024c	e8 00 00 00 00	 call	 _memcpy
  00251	83 c4 0c	 add	 esp, 12			; 0000000cH

; 27982: 							pCount.Count++;

  00254	8a 85 dc fe ff
	ff		 mov	 al, BYTE PTR _pCount$[ebp+8]
  0025a	04 01		 add	 al, 1
  0025c	88 85 dc fe ff
	ff		 mov	 BYTE PTR _pCount$[ebp+8], al

; 27983: 							lOfs += sizeof(pResult);

  00262	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00268	83 c0 02	 add	 eax, 2
  0026b	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _lOfs$[ebp], eax

; 27984: 							if( lOfs > 250 ) 

  00271	81 bd e4 fe ff
	ff fa 00 00 00	 cmp	 DWORD PTR _lOfs$[ebp], 250 ; 000000faH
  0027b	7e 2c		 jle	 SHORT $LN15@gObjPosMag

; 27985: 							{
; 27986: 								LogAdd(lMsg.Get(547), __FILE__, __LINE__);

  0027d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjPosMagicAttack@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@EE@Z@4JA
  00282	83 c0 3a	 add	 eax, 58			; 0000003aH
  00285	50		 push	 eax
  00286	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0028b	68 23 02 00 00	 push	 547			; 00000223H
  00290	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00295	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0029b	50		 push	 eax
  0029c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 27987: 								return FALSE;

  002a5	33 c0		 xor	 eax, eax
  002a7	eb 70		 jmp	 SHORT $LN1@gObjPosMag
$LN15@gObjPosMag:

; 27988: 							}
; 27989: 						}
; 27990: 					}
; 27991: 				}
; 27992: 			}
; 27993: 		}
; 27994: 	}

  002a9	e9 41 fe ff ff	 jmp	 $LN4@gObjPosMag
$LN5@gObjPosMag:

; 27995: 	pCount.h.size = (BYTE)lOfs;

  002ae	8a 85 e4 fe ff
	ff		 mov	 al, BYTE PTR _lOfs$[ebp]
  002b4	88 85 d5 fe ff
	ff		 mov	 BYTE PTR _pCount$[ebp+1], al

; 27996: 	memcpy(sbuf, &pCount, sizeof(pCount));	

  002ba	6a 09		 push	 9
  002bc	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _pCount$[ebp]
  002c2	50		 push	 eax
  002c3	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _sbuf$[ebp]
  002c9	51		 push	 ecx
  002ca	e8 00 00 00 00	 call	 _memcpy
  002cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 27997: 
; 27998: 	if( lpObj->Type == OBJTYPE_CHARACTER )

  002d2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d5	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  002d9	83 f9 01	 cmp	 ecx, 1
  002dc	75 1c		 jne	 SHORT $LN16@gObjPosMag

; 27999: 		DataSend(lpObj->m_Index, sbuf, lOfs);

  002de	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  002e4	50		 push	 eax
  002e5	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _sbuf$[ebp]
  002eb	51		 push	 ecx
  002ec	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002ef	8b 02		 mov	 eax, DWORD PTR [edx]
  002f1	50		 push	 eax
  002f2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002f7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@gObjPosMag:

; 28000: 
; 28001: 	MsgSendV2(lpObj, sbuf, lOfs);

  002fa	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _lOfs$[ebp]
  00300	50		 push	 eax
  00301	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _sbuf$[ebp]
  00307	51		 push	 ecx
  00308	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0030b	52		 push	 edx
  0030c	e8 00 00 00 00	 call	 ?MsgSendV2@@YAXPAVOBJECTSTRUCT@@PAEH@Z ; MsgSendV2
  00311	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28002: 	/*
; 28003: 	for( n=0; n<MAXVIEWPORTOBJECT; n++ )
; 28004: 	{
; 28005: 		if( lpObj->VpPlayer2[n].type == OBJTYPE_CHARACTER )
; 28006: 		{
; 28007: 			if( lpObj->VpPlayer2[n].state != OBJST_NONE &&
; 28008: 				lpObj->VpPlayer[n].state != OBJST_DIED &&
; 28009: 				lpObj->VpPlayer[n].state != OBJST_DIECMD )
; 28010: 			{
; 28011: 				DataSend(lpObj->VpPlayer2[n].number, (char*)sbuf, lOfs);
; 28012: 			}
; 28013: 		}
; 28014: 	}
; 28015: 	*/
; 28016: 	return TRUE;

  00314	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjPosMag:

; 28017: }

  00319	5f		 pop	 edi
  0031a	5e		 pop	 esi
  0031b	5b		 pop	 ebx
  0031c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0031f	33 cd		 xor	 ecx, ebp
  00321	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00326	8b e5		 mov	 esp, ebp
  00328	5d		 pop	 ebp
  00329	c3		 ret	 0
?gObjPosMagicAttack@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@EE@Z ENDP ; gObjPosMagicAttack
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?GetMoveArea@@YAXAAF0EEEEEAAE@Z
_TEXT	SEGMENT
tv66 = -84						; size = 4
_attr$ = -13						; size = 1
_loopcount$ = -12					; size = 4
_ty$ = -8						; size = 4
_tx$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_MapNumber$ = 16					; size = 1
_x1$ = 20						; size = 1
_y1$ = 24						; size = 1
_x2$ = 28						; size = 1
_y2$ = 32						; size = 1
_dir$ = 36						; size = 4
?GetMoveArea@@YAXAAF0EEEEEAAE@Z PROC			; GetMoveArea, COMDAT

; 25893: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 25894: 	int tx, ty;
; 25895: 	int loopcount=10;

  00009	c7 45 f4 0a 00
	00 00		 mov	 DWORD PTR _loopcount$[ebp], 10 ; 0000000aH
$LN2@GetMoveAre:

; 25896: 	BYTE attr;
; 25897: 
; 25898: 	while( loopcount-- )

  00010	8b 45 f4	 mov	 eax, DWORD PTR _loopcount$[ebp]
  00013	89 45 ac	 mov	 DWORD PTR tv66[ebp], eax
  00016	8b 4d f4	 mov	 ecx, DWORD PTR _loopcount$[ebp]
  00019	83 e9 01	 sub	 ecx, 1
  0001c	89 4d f4	 mov	 DWORD PTR _loopcount$[ebp], ecx
  0001f	83 7d ac 00	 cmp	 DWORD PTR tv66[ebp], 0
  00023	0f 84 a6 00 00
	00		 je	 $LN3@GetMoveAre

; 25899: 	{
; 25900: 		if( (x2-x1) > 0 )

  00029	0f b6 45 1c	 movzx	 eax, BYTE PTR _x2$[ebp]
  0002d	0f b6 4d 14	 movzx	 ecx, BYTE PTR _x1$[ebp]
  00031	2b c1		 sub	 eax, ecx
  00033	85 c0		 test	 eax, eax
  00035	7e 1d		 jle	 SHORT $LN4@GetMoveAre

; 25901: 		{
; 25902: 			tx = x1+(rand()%((x2-x1)));

  00037	0f b6 75 14	 movzx	 esi, BYTE PTR _x1$[ebp]
  0003b	e8 00 00 00 00	 call	 _rand
  00040	0f b6 4d 1c	 movzx	 ecx, BYTE PTR _x2$[ebp]
  00044	0f b6 55 14	 movzx	 edx, BYTE PTR _x1$[ebp]
  00048	2b ca		 sub	 ecx, edx
  0004a	99		 cdq
  0004b	f7 f9		 idiv	 ecx
  0004d	03 f2		 add	 esi, edx
  0004f	89 75 fc	 mov	 DWORD PTR _tx$[ebp], esi

; 25903: 		}

  00052	eb 07		 jmp	 SHORT $LN5@GetMoveAre
$LN4@GetMoveAre:

; 25904: 		else tx = x1;

  00054	0f b6 45 14	 movzx	 eax, BYTE PTR _x1$[ebp]
  00058	89 45 fc	 mov	 DWORD PTR _tx$[ebp], eax
$LN5@GetMoveAre:

; 25905: 
; 25906: 		if( (y2-y1) > 0 )

  0005b	0f b6 45 20	 movzx	 eax, BYTE PTR _y2$[ebp]
  0005f	0f b6 4d 18	 movzx	 ecx, BYTE PTR _y1$[ebp]
  00063	2b c1		 sub	 eax, ecx
  00065	85 c0		 test	 eax, eax
  00067	7e 1d		 jle	 SHORT $LN6@GetMoveAre

; 25907: 		{
; 25908: 			ty = y1+(rand()%((y2-y1)));

  00069	0f b6 75 18	 movzx	 esi, BYTE PTR _y1$[ebp]
  0006d	e8 00 00 00 00	 call	 _rand
  00072	0f b6 4d 20	 movzx	 ecx, BYTE PTR _y2$[ebp]
  00076	0f b6 55 18	 movzx	 edx, BYTE PTR _y1$[ebp]
  0007a	2b ca		 sub	 ecx, edx
  0007c	99		 cdq
  0007d	f7 f9		 idiv	 ecx
  0007f	03 f2		 add	 esi, edx
  00081	89 75 f8	 mov	 DWORD PTR _ty$[ebp], esi

; 25909: 		}

  00084	eb 07		 jmp	 SHORT $LN7@GetMoveAre
$LN6@GetMoveAre:

; 25910: 		else ty = y1;

  00086	0f b6 45 18	 movzx	 eax, BYTE PTR _y1$[ebp]
  0008a	89 45 f8	 mov	 DWORD PTR _ty$[ebp], eax
$LN7@GetMoveAre:

; 25911: 
; 25912: 		attr = MapC[MapNumber].GetAttr(tx, ty);

  0008d	8b 45 f8	 mov	 eax, DWORD PTR _ty$[ebp]
  00090	50		 push	 eax
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _tx$[ebp]
  00094	51		 push	 ecx
  00095	0f b6 55 10	 movzx	 edx, BYTE PTR _MapNumber$[ebp]
  00099	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  0009f	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000a5	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000aa	88 45 f3	 mov	 BYTE PTR _attr$[ebp], al

; 25913: 		if( ((attr&MAP_ATTR_BLOCK) != MAP_ATTR_BLOCK) && 
; 25914: 			((attr&MAP_ATTR_STAND) != MAP_ATTR_STAND) &&

  000ad	0f b6 45 f3	 movzx	 eax, BYTE PTR _attr$[ebp]
  000b1	83 e0 04	 and	 eax, 4
  000b4	75 14		 jne	 SHORT $LN8@GetMoveAre
  000b6	0f b6 45 f3	 movzx	 eax, BYTE PTR _attr$[ebp]
  000ba	83 e0 02	 and	 eax, 2
  000bd	75 0b		 jne	 SHORT $LN8@GetMoveAre
  000bf	0f b6 45 f3	 movzx	 eax, BYTE PTR _attr$[ebp]
  000c3	83 e0 08	 and	 eax, 8
  000c6	75 02		 jne	 SHORT $LN8@GetMoveAre

; 25915: 			((attr&MAP_ATTR_HOLLOW) != MAP_ATTR_HOLLOW)) 
; 25916: 		{			
; 25917: 			break;

  000c8	eb 05		 jmp	 SHORT $LN3@GetMoveAre
$LN8@GetMoveAre:

; 25918: 		}
; 25919: 	}

  000ca	e9 41 ff ff ff	 jmp	 $LN2@GetMoveAre
$LN3@GetMoveAre:

; 25920: 	x			= tx;

  000cf	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  000d2	66 8b 4d fc	 mov	 cx, WORD PTR _tx$[ebp]
  000d6	66 89 08	 mov	 WORD PTR [eax], cx

; 25921: 	y			= ty;

  000d9	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  000dc	66 8b 4d f8	 mov	 cx, WORD PTR _ty$[ebp]
  000e0	66 89 08	 mov	 WORD PTR [eax], cx

; 25922: 	dir			= 0;

  000e3	8b 45 24	 mov	 eax, DWORD PTR _dir$[ebp]
  000e6	c6 00 00	 mov	 BYTE PTR [eax], 0

; 25923: }

  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	5b		 pop	 ebx
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
?GetMoveArea@@YAXAAF0EEEEEAAE@Z ENDP			; GetMoveArea
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMagicBPUse@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@@Z
_TEXT	SEGMENT
_bp$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?gObjMagicBPUse@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@@Z PROC ; gObjMagicBPUse, COMDAT

; 27900: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 27901: 	int bp = lpObj->BP;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	8b 88 e8 00 00
	00		 mov	 ecx, DWORD PTR [eax+232]
  00012	89 4d fc	 mov	 DWORD PTR _bp$[ebp], ecx

; 27902: 	
; 27903: 	//  MP  .
; 27904: 	if( lpObj->Type != OBJTYPE_CHARACTER ) return 0;

  00015	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00018	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0001c	83 f9 01	 cmp	 ecx, 1
  0001f	74 04		 je	 SHORT $LN2@gObjMagicB
  00021	33 c0		 xor	 eax, eax
  00023	eb 2e		 jmp	 SHORT $LN1@gObjMagicB
$LN2@gObjMagicB:

; 27905: 	if( lpMagic == NULL ) return FALSE;

  00025	83 7d 0c 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  00029	75 04		 jne	 SHORT $LN3@gObjMagicB
  0002b	33 c0		 xor	 eax, eax
  0002d	eb 24		 jmp	 SHORT $LN1@gObjMagicB
$LN3@gObjMagicB:

; 27906: 
; 27907: #ifdef MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 27908: 	int iUsedBP = MagicDamageC.SkillGetBP(lpMagic->m_Skill);
; 27909: 	if( lpObj->m_btAGReduceRate > 0 )
; 27910: 	{
; 27911: 		iUsedBP -= ( iUsedBP * lpObj->m_btAGReduceRate ) / 100;
; 27912: 	}
; 27913: 
; 27914: 	bp -= iUsedBP;
; 27915: #else
; 27916: 	bp -= MagicDamageC.SkillGetBP(lpMagic->m_Skill);

  0002f	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00032	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00036	51		 push	 ecx
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0003c	e8 00 00 00 00	 call	 ?SkillGetBP@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetBP
  00041	8b 55 fc	 mov	 edx, DWORD PTR _bp$[ebp]
  00044	2b d0		 sub	 edx, eax
  00046	89 55 fc	 mov	 DWORD PTR _bp$[ebp], edx

; 27917: #endif // MODIFY_SOCKET_ITEM_NEW_OPTION_20080818
; 27918: 	
; 27919: 	//       
; 27920: 	if( bp < 0 ) return -1;

  00049	79 05		 jns	 SHORT $LN4@gObjMagicB
  0004b	83 c8 ff	 or	 eax, -1
  0004e	eb 03		 jmp	 SHORT $LN1@gObjMagicB
$LN4@gObjMagicB:

; 27921: 
; 27922: 	return (int)bp;

  00050	8b 45 fc	 mov	 eax, DWORD PTR _bp$[ebp]
$LN1@gObjMagicB:

; 27923: }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?gObjMagicBPUse@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@@Z ENDP ; gObjMagicBPUse
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMagicManaUse@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@@Z
_TEXT	SEGMENT
_mana$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpMagic$ = 12						; size = 4
?gObjMagicManaUse@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@@Z PROC ; gObjMagicManaUse, COMDAT

; 27873: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 27874: 	float mana = lpObj->Mana;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	f3 0f 10 80 d0
	00 00 00	 movss	 xmm0, DWORD PTR [eax+208]
  00014	f3 0f 11 45 fc	 movss	 DWORD PTR _mana$[ebp], xmm0

; 27875: 	
; 27876: 	//  MP  .
; 27877: 	if( lpObj->Type != OBJTYPE_CHARACTER ) return 0;

  00019	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00020	83 f9 01	 cmp	 ecx, 1
  00023	74 04		 je	 SHORT $LN2@gObjMagicM
  00025	33 c0		 xor	 eax, eax
  00027	eb 41		 jmp	 SHORT $LN1@gObjMagicM
$LN2@gObjMagicM:

; 27878: 	if( lpMagic == NULL ) return FALSE;

  00029	83 7d 0c 00	 cmp	 DWORD PTR _lpMagic$[ebp], 0
  0002d	75 04		 jne	 SHORT $LN3@gObjMagicM
  0002f	33 c0		 xor	 eax, eax
  00031	eb 37		 jmp	 SHORT $LN1@gObjMagicM
$LN3@gObjMagicM:

; 27879: 
; 27880: #ifdef UPDATE_MASTER_LEVEL_4RANK_20080428	//   
; 27881: 	float DecreaseMana = 0.0f;
; 27882: 	DecreaseMana = MagicDamageC.SkillGetMana(lpMagic->m_Skill);
; 27883: 	DecreaseMana -= (DecreaseMana * lpObj->m_MPSkillOpt.iMpsDecreaseMana) / 100;
; 27884: 
; 27885: 	if(DecreaseMana < 1.0f)	DecreaseMana = 1.0f;
; 27886: 	mana -= DecreaseMana;
; 27887: #else	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 27888: 	mana -= MagicDamageC.SkillGetMana(lpMagic->m_Skill);

  00033	8b 45 0c	 mov	 eax, DWORD PTR _lpMagic$[ebp]
  00036	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0003a	51		 push	 ecx
  0003b	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00040	e8 00 00 00 00	 call	 ?SkillGetMana@CMagicDamage@@QAEHH@Z ; CMagicDamage::SkillGetMana
  00045	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00049	f3 0f 10 4d fc	 movss	 xmm1, DWORD PTR _mana$[ebp]
  0004e	f3 0f 5c c8	 subss	 xmm1, xmm0
  00052	f3 0f 11 4d fc	 movss	 DWORD PTR _mana$[ebp], xmm1

; 27889: #endif	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 27890: 	
; 27891: 	//       
; 27892: 	if( mana < 0 ) return -1;

  00057	0f 57 c0	 xorps	 xmm0, xmm0
  0005a	0f 2f 45 fc	 comiss	 xmm0, DWORD PTR _mana$[ebp]
  0005e	76 05		 jbe	 SHORT $LN4@gObjMagicM
  00060	83 c8 ff	 or	 eax, -1
  00063	eb 05		 jmp	 SHORT $LN1@gObjMagicM
$LN4@gObjMagicM:

; 27893: 
; 27894: 	return (int)mana;

  00065	f3 0f 2c 45 fc	 cvttss2si eax, DWORD PTR _mana$[ebp]
$LN1@gObjMagicM:

; 27895: }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?gObjMagicManaUse@@YAHPAVOBJECTSTRUCT@@PAVCMagicInf@@@Z ENDP ; gObjMagicManaUse
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjTeleportMagicUse@@YAXHEE@Z
_TEXT	SEGMENT
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_x$ = 12						; size = 1
_y$ = 16						; size = 1
?gObjTeleportMagicUse@@YAXHEE@Z PROC			; gObjTeleportMagicUse, COMDAT

; 25843: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 25844: 	LPOBJECTSTRUCT lpObj;
; 25845: 	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 25846: 	
; 25847: #ifdef MODIFY_TELEPORT_USING_HELLBURST_BUGFIX_20080822
; 25848: 	//    
; 25849: 	//      
; 25850: 	if( lpObj->Type == OBJTYPE_CHARACTER && lpObj->Class == CLASS_WIZARD && lpObj->SkillHellFire2State )
; 25851: 	{
; 25852: 		lpObj->SkillHellFire2State = FALSE;
; 25853: 		lpObj->SkillHellFire2Time = 0;
; 25854: 	}
; 25855: #endif // MODIFY_TELEPORT_USING_HELLBURST_BUGFIX_20080822
; 25856: 
; 25857: 	if( lpObj->Teleport ) return;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	0f be 88 fc 01
	00 00		 movsx	 ecx, BYTE PTR [eax+508]
  00023	85 c9		 test	 ecx, ecx
  00025	74 05		 je	 SHORT $LN2@gObjTelepo
  00027	e9 0c 01 00 00	 jmp	 $LN1@gObjTelepo
$LN2@gObjTelepo:

; 25858: 
; 25859: 	lpObj->TeleportTime = GetTickCount();

  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00035	89 81 f8 01 00
	00		 mov	 DWORD PTR [ecx+504], eax

; 25860: 	lpObj->PathCount	= 0;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003e	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0

; 25861: 	//lpObj->m_State		= OBJST_DELCMD;
; 25862: 	lpObj->Teleport     = 1;

  00048	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004b	c6 80 fc 01 00
	00 01		 mov	 BYTE PTR [eax+508], 1

; 25863: 	lpObj->m_StateSub   = 1;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00055	c6 80 bc 01 00
	00 01		 mov	 BYTE PTR [eax+444], 1

; 25864: 	lpObj->m_ViewState  = 1;

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005f	c6 80 be 01 00
	00 01		 mov	 BYTE PTR [eax+446], 1

; 25865: 	lpObj->X			= x;

  00066	66 0f b6 45 0c	 movzx	 ax, BYTE PTR _x$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0006e	66 89 81 04 01
	00 00		 mov	 WORD PTR [ecx+260], ax

; 25866: 	lpObj->Y			= y;

  00075	66 0f b6 45 10	 movzx	 ax, BYTE PTR _y$[ebp]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0007d	66 89 81 06 01
	00 00		 mov	 WORD PTR [ecx+262], ax

; 25867: 	lpObj->TX			= x;

  00084	66 0f b6 45 0c	 movzx	 ax, BYTE PTR _x$[ebp]
  00089	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0008c	66 89 81 20 01
	00 00		 mov	 WORD PTR [ecx+288], ax

; 25868: 	lpObj->TY			= y;

  00093	66 0f b6 45 10	 movzx	 ax, BYTE PTR _y$[ebp]
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0009b	66 89 81 22 01
	00 00		 mov	 WORD PTR [ecx+290], ax

; 25869: 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  000a2	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a5	0f bf 88 1e 01
	00 00		 movsx	 ecx, WORD PTR [eax+286]
  000ac	51		 push	 ecx
  000ad	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000b0	0f bf 82 1c 01
	00 00		 movsx	 eax, WORD PTR [edx+284]
  000b7	50		 push	 eax
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000bb	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  000c2	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  000c8	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000ce	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 25870: 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->TX, lpObj->TY);

  000d3	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d6	0f bf 88 22 01
	00 00		 movsx	 ecx, WORD PTR [eax+290]
  000dd	51		 push	 ecx
  000de	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e1	0f bf 82 20 01
	00 00		 movsx	 eax, WORD PTR [edx+288]
  000e8	50		 push	 eax
  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ec	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  000f3	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  000f9	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000ff	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 25871: 	lpObj->m_OldX		= lpObj->TX;

  00104	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00107	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0010a	66 8b 91 20 01
	00 00		 mov	 dx, WORD PTR [ecx+288]
  00111	66 89 90 1c 01
	00 00		 mov	 WORD PTR [eax+284], dx

; 25872: 	lpObj->m_OldY		= lpObj->TY;

  00118	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011b	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0011e	66 8b 91 22 01
	00 00		 mov	 dx, WORD PTR [ecx+290]
  00125	66 89 90 1e 01
	00 00		 mov	 WORD PTR [eax+286], dx

; 25873: 	//LogAddC(LOGC_RED,"  %s %d", lpObj->Name, __LINE__);
; 25874: 
; 25875: 	gObjViewportListProtocolDestroy(lpObj);

  0012c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 ?gObjViewportListProtocolDestroy@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy
  00135	83 c4 04	 add	 esp, 4
$LN1@gObjTelepo:

; 25876: 
; 25877: 	/*
; 25878: 	int tObjNum;
; 25879: 	for( int n=0; n<MAXVIEWPORTOBJECT; n++)
; 25880: 	{
; 25881: 		//   ..
; 25882: 		if( (lpObj->VpPlayer[n].state == STVP_CREATE ||
; 25883: 			lpObj->VpPlayer[n].state == STVP_PLAYING)) 
; 25884: 		{
; 25885: 			tObjNum = lpObj->VpPlayer[n].number;
; 25886: 			gObjViewportListDestroy(tObjNum);
; 25887: 		}
; 25888: 	}
; 25889: 	*/
; 25890: }

  00138	5f		 pop	 edi
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx
  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
?gObjTeleportMagicUse@@YAXHEE@Z ENDP			; gObjTeleportMagicUse
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
tv140 = -76						; size = 4
_ty$ = -8						; size = 4
_tx$ = -4						; size = 4
_lpObj1$ = 8						; size = 4
_lpObj2$ = 12						; size = 4
?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z PROC		; gObjCalDistance, COMDAT

; 7011 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7012 : 	if( (lpObj1->X == lpObj2->X) && 

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj1$[ebp]
  0000c	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00013	8b 55 0c	 mov	 edx, DWORD PTR _lpObj2$[ebp]
  00016	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  0001d	3b c8		 cmp	 ecx, eax
  0001f	75 1c		 jne	 SHORT $LN2@gObjCalDis
  00021	8b 45 08	 mov	 eax, DWORD PTR _lpObj1$[ebp]
  00024	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0002b	8b 55 0c	 mov	 edx, DWORD PTR _lpObj2$[ebp]
  0002e	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  00035	3b c8		 cmp	 ecx, eax
  00037	75 04		 jne	 SHORT $LN2@gObjCalDis

; 7013 : 		(lpObj1->Y == lpObj2->Y) )
; 7014 : 	{
; 7015 : 		return 0;

  00039	33 c0		 xor	 eax, eax
  0003b	eb 70		 jmp	 SHORT $LN1@gObjCalDis
$LN2@gObjCalDis:

; 7016 : 	}
; 7017 : 	float tx = (float)(lpObj1->X-lpObj2->X);

  0003d	8b 45 08	 mov	 eax, DWORD PTR _lpObj1$[ebp]
  00040	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00047	8b 55 0c	 mov	 edx, DWORD PTR _lpObj2$[ebp]
  0004a	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  00051	2b c8		 sub	 ecx, eax
  00053	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00057	f3 0f 11 45 fc	 movss	 DWORD PTR _tx$[ebp], xmm0

; 7018 : 	float ty = (float)(lpObj1->Y-lpObj2->Y);

  0005c	8b 45 08	 mov	 eax, DWORD PTR _lpObj1$[ebp]
  0005f	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00066	8b 55 0c	 mov	 edx, DWORD PTR _lpObj2$[ebp]
  00069	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  00070	2b c8		 sub	 ecx, eax
  00072	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00076	f3 0f 11 45 f8	 movss	 DWORD PTR _ty$[ebp], xmm0

; 7019 : 			
; 7020 : 	return (int)(sqrt((tx*tx)+(ty*ty)));

  0007b	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _tx$[ebp]
  00080	f3 0f 59 45 fc	 mulss	 xmm0, DWORD PTR _tx$[ebp]
  00085	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _ty$[ebp]
  0008a	f3 0f 59 4d f8	 mulss	 xmm1, DWORD PTR _ty$[ebp]
  0008f	f3 0f 58 c1	 addss	 xmm0, xmm1
  00093	51		 push	 ecx
  00094	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00099	e8 00 00 00 00	 call	 ?sqrt@@YAMM@Z		; sqrt
  0009e	83 c4 04	 add	 esp, 4
  000a1	d9 5d b4	 fstp	 DWORD PTR tv140[ebp]
  000a4	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR tv140[ebp]
  000a9	f3 0f 2c c0	 cvttss2si eax, xmm0
$LN1@gObjCalDis:

; 7021 : }

  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z ENDP		; gObjCalDistance
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?GetPathPacketDirPos@@YAEHH@Z
_TEXT	SEGMENT
_pos$ = -1						; size = 1
_px$ = 8						; size = 4
_py$ = 12						; size = 4
?GetPathPacketDirPos@@YAEHH@Z PROC			; GetPathPacketDirPos, COMDAT

; 6993 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6994 : 	BYTE pos=0;

  00009	c6 45 ff 00	 mov	 BYTE PTR _pos$[ebp], 0

; 6995 : 
; 6996 : 	if( px <= -1 && py <= -1 ) { pos = 0;}

  0000d	83 7d 08 ff	 cmp	 DWORD PTR _px$[ebp], -1
  00011	7f 0c		 jg	 SHORT $LN2@GetPathPac
  00013	83 7d 0c ff	 cmp	 DWORD PTR _py$[ebp], -1
  00017	7f 06		 jg	 SHORT $LN2@GetPathPac
  00019	c6 45 ff 00	 mov	 BYTE PTR _pos$[ebp], 0
  0001d	eb 7c		 jmp	 SHORT $LN3@GetPathPac
$LN2@GetPathPac:

; 6997 : 	else if( px <= -1 && py ==  0 ) { pos = 7; }

  0001f	83 7d 08 ff	 cmp	 DWORD PTR _px$[ebp], -1
  00023	7f 0c		 jg	 SHORT $LN4@GetPathPac
  00025	83 7d 0c 00	 cmp	 DWORD PTR _py$[ebp], 0
  00029	75 06		 jne	 SHORT $LN4@GetPathPac
  0002b	c6 45 ff 07	 mov	 BYTE PTR _pos$[ebp], 7
  0002f	eb 6a		 jmp	 SHORT $LN3@GetPathPac
$LN4@GetPathPac:

; 6998 : 	else if( px <= -1 && py >=  1 ) { pos = 6; }

  00031	83 7d 08 ff	 cmp	 DWORD PTR _px$[ebp], -1
  00035	7f 0c		 jg	 SHORT $LN6@GetPathPac
  00037	83 7d 0c 01	 cmp	 DWORD PTR _py$[ebp], 1
  0003b	7c 06		 jl	 SHORT $LN6@GetPathPac
  0003d	c6 45 ff 06	 mov	 BYTE PTR _pos$[ebp], 6
  00041	eb 58		 jmp	 SHORT $LN3@GetPathPac
$LN6@GetPathPac:

; 6999 : 	else if( px ==  0 && py <= -1 ) { pos = 1; }

  00043	83 7d 08 00	 cmp	 DWORD PTR _px$[ebp], 0
  00047	75 0c		 jne	 SHORT $LN8@GetPathPac
  00049	83 7d 0c ff	 cmp	 DWORD PTR _py$[ebp], -1
  0004d	7f 06		 jg	 SHORT $LN8@GetPathPac
  0004f	c6 45 ff 01	 mov	 BYTE PTR _pos$[ebp], 1
  00053	eb 46		 jmp	 SHORT $LN3@GetPathPac
$LN8@GetPathPac:

; 7000 : 	else if( px ==  0 && py >=  1 ) { pos = 5; }

  00055	83 7d 08 00	 cmp	 DWORD PTR _px$[ebp], 0
  00059	75 0c		 jne	 SHORT $LN10@GetPathPac
  0005b	83 7d 0c 01	 cmp	 DWORD PTR _py$[ebp], 1
  0005f	7c 06		 jl	 SHORT $LN10@GetPathPac
  00061	c6 45 ff 05	 mov	 BYTE PTR _pos$[ebp], 5
  00065	eb 34		 jmp	 SHORT $LN3@GetPathPac
$LN10@GetPathPac:

; 7001 : 	else if( px >=  1 && py <= -1 ) { pos = 2; }

  00067	83 7d 08 01	 cmp	 DWORD PTR _px$[ebp], 1
  0006b	7c 0c		 jl	 SHORT $LN12@GetPathPac
  0006d	83 7d 0c ff	 cmp	 DWORD PTR _py$[ebp], -1
  00071	7f 06		 jg	 SHORT $LN12@GetPathPac
  00073	c6 45 ff 02	 mov	 BYTE PTR _pos$[ebp], 2
  00077	eb 22		 jmp	 SHORT $LN3@GetPathPac
$LN12@GetPathPac:

; 7002 : 	else if( px >=  1 && py ==  0 ) { pos = 3; }

  00079	83 7d 08 01	 cmp	 DWORD PTR _px$[ebp], 1
  0007d	7c 0c		 jl	 SHORT $LN14@GetPathPac
  0007f	83 7d 0c 00	 cmp	 DWORD PTR _py$[ebp], 0
  00083	75 06		 jne	 SHORT $LN14@GetPathPac
  00085	c6 45 ff 03	 mov	 BYTE PTR _pos$[ebp], 3
  00089	eb 10		 jmp	 SHORT $LN3@GetPathPac
$LN14@GetPathPac:

; 7003 : 	else if( px >=  1 && py >=  1 ) { pos = 4; }

  0008b	83 7d 08 01	 cmp	 DWORD PTR _px$[ebp], 1
  0008f	7c 0a		 jl	 SHORT $LN3@GetPathPac
  00091	83 7d 0c 01	 cmp	 DWORD PTR _py$[ebp], 1
  00095	7c 04		 jl	 SHORT $LN3@GetPathPac
  00097	c6 45 ff 04	 mov	 BYTE PTR _pos$[ebp], 4
$LN3@GetPathPac:

; 7004 : 
; 7005 : 	return (BYTE)pos;

  0009b	8a 45 ff	 mov	 al, BYTE PTR _pos$[ebp]

; 7006 : }

  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
?GetPathPacketDirPos@@YAEHH@Z ENDP			; GetPathPacketDirPos
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjBackSpring@@YAHPAVOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
tv73 = -96						; size = 4
tv74 = -92						; size = 4
_pMove$ = -24						; size = 5
_attr$ = -13						; size = 1
_y$ = -12						; size = 4
_x$ = -8						; size = 4
_tdir$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?gObjBackSpring@@YAHPAVOBJECTSTRUCT@@0@Z PROC		; gObjBackSpring, COMDAT

; 7393 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7394 : 	int tdir;
; 7395 : 
; 7396 : 	if( !CHECK_LIMIT(lpObj->MapNumber, g_TerrainManager.Size())  )

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00013	85 c9		 test	 ecx, ecx
  00015	7d 09		 jge	 SHORT $LN18@gObjBackSp
  00017	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  0001e	eb 31		 jmp	 SHORT $LN19@gObjBackSp
$LN18@gObjBackSp:
  00020	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00023	0f b6 b2 09 01
	00 00		 movzx	 esi, BYTE PTR [edx+265]
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  0002f	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size
  00034	83 e8 01	 sub	 eax, 1
  00037	3b f0		 cmp	 esi, eax
  00039	7e 09		 jle	 SHORT $LN16@gObjBackSp
  0003b	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  00042	eb 07		 jmp	 SHORT $LN17@gObjBackSp
$LN16@gObjBackSp:
  00044	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
$LN17@gObjBackSp:
  0004b	8b 45 a0	 mov	 eax, DWORD PTR tv73[ebp]
  0004e	89 45 a4	 mov	 DWORD PTR tv74[ebp], eax
$LN19@gObjBackSp:
  00051	83 7d a4 00	 cmp	 DWORD PTR tv74[ebp], 0
  00055	75 23		 jne	 SHORT $LN2@gObjBackSp

; 7397 : 	{
; 7398 : 		LogAdd("error : %s %d",__FILE__, __LINE__);

  00057	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjBackSpring@@YAHPAVOBJECTSTRUCT@@0@Z@4JA
  0005c	83 c0 05	 add	 eax, 5
  0005f	50		 push	 eax
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7399 : 		return FALSE;

  00073	33 c0		 xor	 eax, eax
  00075	e9 21 02 00 00	 jmp	 $LN1@gObjBackSp
$LN2@gObjBackSp:

; 7400 : 	}
; 7401 : 
; 7402 : 	if( lpObj->Type == OBJTYPE_CHARACTER )

  0007a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007d	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00081	83 f9 01	 cmp	 ecx, 1
  00084	75 15		 jne	 SHORT $LN3@gObjBackSp

; 7403 : 	{	//     
; 7404 : 		if( lpObj->m_LastTeleportTime > 0 )

  00086	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00089	0f be 88 e9 0e
	00 00		 movsx	 ecx, BYTE PTR [eax+3817]
  00090	85 c9		 test	 ecx, ecx
  00092	7e 07		 jle	 SHORT $LN3@gObjBackSp

; 7405 : 		{
; 7406 : 			return FALSE;

  00094	33 c0		 xor	 eax, eax
  00096	e9 00 02 00 00	 jmp	 $LN1@gObjBackSp
$LN3@gObjBackSp:

; 7407 : 		}
; 7408 : 	}
; 7409 : 
; 7410 : 	if(g_GlobalConfig.m_bBackSpring == false)

  0009b	0f b6 05 4d 00
	00 00		 movzx	 eax, BYTE PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+77
  000a2	85 c0		 test	 eax, eax
  000a4	75 07		 jne	 SHORT $LN5@gObjBackSp

; 7411 : 		return FALSE;

  000a6	33 c0		 xor	 eax, eax
  000a8	e9 ee 01 00 00	 jmp	 $LN1@gObjBackSp
$LN5@gObjBackSp:

; 7412 : 
; 7413 : #ifdef CRYWOLF_NPC_WORK_20050912
; 7414 : 	if( lpObj->Type == OBJTYPE_CHARACTER )
; 7415 : 	{
; 7416 : 		if( (lpObj->Authority&AUTHORITY_ADMIN) == AUTHORITY_ADMIN )
; 7417 : 		{
; 7418 : 			return FALSE;
; 7419 : 		}
; 7420 : 	}
; 7421 : #endif
; 7422 : 
; 7423 : #ifdef FOR_BLOODCASTLE
; 7424 : 	if(lpObj->Class >= 131 && lpObj->Class <= 134 )		// ,   

  000ad	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b0	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000b7	81 f9 83 00 00
	00		 cmp	 ecx, 131		; 00000083H
  000bd	7c 19		 jl	 SHORT $LN6@gObjBackSp
  000bf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c2	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000c9	81 f9 86 00 00
	00		 cmp	 ecx, 134		; 00000086H
  000cf	7f 07		 jg	 SHORT $LN6@gObjBackSp

; 7425 : 		return FALSE;

  000d1	33 c0		 xor	 eax, eax
  000d3	e9 c3 01 00 00	 jmp	 $LN1@gObjBackSp
$LN6@gObjBackSp:

; 7426 : #endif
; 7427 : 	
; 7428 : #ifdef CASTLE_MAIN_SCHEDULER_20041111					//  NPC - ,    
; 7429 : 	if ((lpObj->Class == 277)||			// 
; 7430 : 		(lpObj->Class == 283)||			// 
; 7431 : 		(lpObj->Class == 288)||			// 
; 7432 : 		(lpObj->Class == 278)||			// 
; 7433 : 		(lpObj->Class == 215)||			// 
; 7434 : 		(lpObj->Class == 216)||			// 
; 7435 : 		(lpObj->Class == 217)||			// 
; 7436 : 		(lpObj->Class == 218)||			// 
; 7437 : 		(lpObj->Class == 219)			// 
; 7438 : 		)
; 7439 : 	{
; 7440 : 		return FALSE;
; 7441 : 	}
; 7442 : 
; 7443 : #ifdef MODIFY_CASTLESIEGE_GUILDMASTER_BACKSPRING_20051018
; 7444 : 	//        .
; 7445 : 	if( g_CastleSiege.GetCrownUserIndex() == lpObj->m_Index )
; 7446 : 	{
; 7447 : 		if( lpObj->pInventory[EQUIPMENT_HELPER].m_Type == MAKE_ITEMNUM(13,4) )
; 7448 : 		{
; 7449 : 			return FALSE;
; 7450 : 		}
; 7451 : 
; 7452 : 	}
; 7453 : #endif // MODIFY_CASTLESIEGE_GUILDMASTER_BACKSPRING_20051018
; 7454 : 
; 7455 : #endif // CASTLE_MAIN_SCHEDULER_20041111
; 7456 : 
; 7457 : 
; 7458 : #ifdef CRYWOLF_NPC_WORK_20050912
; 7459 : 	//      .
; 7460 : 	if( g_Crywolf.GetCrywolfState() == CRYWOLF_STATE_START
; 7461 : 		|| g_Crywolf.GetCrywolfState() == CRYWOLF_STATE_READY )
; 7462 : 	{
; 7463 : 		if( lpObj->Type == OBJTYPE_CHARACTER )
; 7464 : 		{		
; 7465 : 			for( int i=CRYWOLF_NPC_ALTAR1; i<=CRYWOLF_NPC_ALTAR5; i++ )
; 7466 : 			{
; 7467 : 				int iUserIndex = g_CrywolfNPC_Altar.GetAltarUserIndex(i);
; 7468 : 				if( iUserIndex != _INVALID && iUserIndex == lpObj->m_Index )
; 7469 : 				{
; 7470 : 					return FALSE;
; 7471 : 				}
; 7472 : 					
; 7473 : 			}
; 7474 : 		}
; 7475 : 		
; 7476 : 	}
; 7477 : #endif // CRYWOLF_NPC_WORK_20050912
; 7478 : 
; 7479 : 
; 7480 : #ifdef CRYWOLF_NPC_WORK_20050912
; 7481 : 	if(	CHECK_CRYWOLF_NPC_ALTAR(lpObj->Class)			//  
; 7482 : 		|| CHECK_CRYWOLF_NPC_STATUE(lpObj->Class)		//  
; 7483 : 	  )
; 7484 : 	{
; 7485 : 		return FALSE;
; 7486 : 	}
; 7487 : #endif // CRYWOLF_NPC_WORK_20050912
; 7488 : 
; 7489 : 	
; 7490 : #ifdef CRYWOLF_MONSTER_WORK_20050914
; 7491 : 	if( lpObj->Class == CRYWOLF_MON_TANKER )
; 7492 : 	{
; 7493 : 		return FALSE;
; 7494 : 	}
; 7495 : #endif // CRYWOLF_MONSTER_WORK_20050914
; 7496 : 	
; 7497 : #ifdef MODIFY_0708_BUFFIX_20070820	//   
; 7498 : 	if( lpObj->Class == 275)

  000d8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000db	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000e2	81 f9 13 01 00
	00		 cmp	 ecx, 275		; 00000113H
  000e8	75 07		 jne	 SHORT $LN7@gObjBackSp

; 7499 : 	{
; 7500 : 		return FALSE;

  000ea	33 c0		 xor	 eax, eax
  000ec	e9 aa 01 00 00	 jmp	 $LN1@gObjBackSp
$LN7@gObjBackSp:

; 7501 : 	}
; 7502 : #endif	// MODIFY_0708_BUFFIX_20070820
; 7503 : 
; 7504 : #ifdef ADD_RAKLION_20080408			//  ,   
; 7505 : 	if( lpObj->Class == 459 || lpObj->Class == 460 || lpObj->Class == 461 || lpObj->Class == 462 )
; 7506 : 	{
; 7507 : 		return FALSE;
; 7508 : 	}
; 7509 : #endif // ADD_RAKLION_20080408
; 7510 : 	
; 7511 : #ifdef MODIFY_BACK_SPRING_SKILL_BUGFIX_20080716		//     
; 7512 : 	INT iBuffIndex = -1;
; 7513 : 	for( INT iCount=0; iCount<lpObj->m_BuffEffectCount; ++iCount )
; 7514 : 	{
; 7515 : 		iBuffIndex = lpObj->m_BuffEffectList[iCount].BuffIndex;
; 7516 : 		
; 7517 : 		//    
; 7518 : 		if( iBuffIndex==BUFFTYPE_STONE			// 
; 7519 : 			|| iBuffIndex==BUFFTYPE_STUN			// 
; 7520 : 			|| iBuffIndex==BUFFTYPE_RESTRICTION )	// 
; 7521 : 		{
; 7522 : 			return FALSE;							//    .
; 7523 : 		}
; 7524 : 	}
; 7525 : #endif // MODIFY_BACK_SPRING_SKILL_BUGFIX_20080716
; 7526 : 
; 7527 : 	
; 7528 : 	if( (rand()%3)==0 )

  000f1	e8 00 00 00 00	 call	 _rand
  000f6	99		 cdq
  000f7	b9 03 00 00 00	 mov	 ecx, 3
  000fc	f7 f9		 idiv	 ecx
  000fe	85 d2		 test	 edx, edx
  00100	75 3b		 jne	 SHORT $LN8@gObjBackSp

; 7529 : 	{
; 7530 : 		if(lpTargetObj->Dir < 4 ) 

  00102	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00105	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  0010c	83 f9 04	 cmp	 ecx, 4
  0010f	7d 12		 jge	 SHORT $LN10@gObjBackSp

; 7531 : 		{
; 7532 : 			tdir = lpTargetObj->Dir+4;

  00111	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00114	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  0011b	83 c1 04	 add	 ecx, 4
  0011e	89 4d fc	 mov	 DWORD PTR _tdir$[ebp], ecx

; 7533 : 		}

  00121	eb 10		 jmp	 SHORT $LN11@gObjBackSp
$LN10@gObjBackSp:

; 7534 : 		else {
; 7535 : 			tdir = lpTargetObj->Dir-4;

  00123	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00126	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  0012d	83 e9 04	 sub	 ecx, 4
  00130	89 4d fc	 mov	 DWORD PTR _tdir$[ebp], ecx
$LN11@gObjBackSp:

; 7536 : 		}
; 7537 : 		tdir *= 2;

  00133	8b 45 fc	 mov	 eax, DWORD PTR _tdir$[ebp]
  00136	d1 e0		 shl	 eax, 1
  00138	89 45 fc	 mov	 DWORD PTR _tdir$[ebp], eax

; 7538 : 	}

  0013b	eb 0f		 jmp	 SHORT $LN9@gObjBackSp
$LN8@gObjBackSp:

; 7539 : 	else {
; 7540 : 		tdir = lpTargetObj->Dir*2;		

  0013d	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00140	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  00147	d1 e1		 shl	 ecx, 1
  00149	89 4d fc	 mov	 DWORD PTR _tdir$[ebp], ecx
$LN9@gObjBackSp:

; 7541 : 	}
; 7542 : 
; 7543 : 	
; 7544 : 	int x, y;
; 7545 : 	BYTE attr;
; 7546 : 
; 7547 : 	x = lpObj->X;

  0014c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014f	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00156	89 4d f8	 mov	 DWORD PTR _x$[ebp], ecx

; 7548 : 	y = lpObj->Y;

  00159	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0015c	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00163	89 4d f4	 mov	 DWORD PTR _y$[ebp], ecx

; 7549 : 	x += RoadPathTable[tdir];

  00166	8b 45 fc	 mov	 eax, DWORD PTR _tdir$[ebp]
  00169	0f bf 0c 45 00
	00 00 00	 movsx	 ecx, WORD PTR ?RoadPathTable@@3PAFA[eax*2]
  00171	03 4d f8	 add	 ecx, DWORD PTR _x$[ebp]
  00174	89 4d f8	 mov	 DWORD PTR _x$[ebp], ecx

; 7550 : 	y += RoadPathTable[tdir+1];

  00177	8b 45 fc	 mov	 eax, DWORD PTR _tdir$[ebp]
  0017a	0f bf 0c 45 02
	00 00 00	 movsx	 ecx, WORD PTR ?RoadPathTable@@3PAFA[eax*2+2]
  00182	03 4d f4	 add	 ecx, DWORD PTR _y$[ebp]
  00185	89 4d f4	 mov	 DWORD PTR _y$[ebp], ecx

; 7551 : 
; 7552 : 	//    ..
; 7553 : 	attr = MapC[lpObj->MapNumber].GetAttr(x, y);

  00188	8b 45 f4	 mov	 eax, DWORD PTR _y$[ebp]
  0018b	50		 push	 eax
  0018c	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  0018f	51		 push	 ecx
  00190	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00193	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0019a	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  001a0	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  001a6	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  001ab	88 45 f3	 mov	 BYTE PTR _attr$[ebp], al

; 7554 : 	if( ((attr&MAP_ATTR_SAFTYZONE) == MAP_ATTR_SAFTYZONE) ||
; 7555 : 		((attr&MAP_ATTR_STAND) == MAP_ATTR_STAND) ||
; 7556 : 		((attr&MAP_ATTR_BLOCK) == MAP_ATTR_BLOCK) ||

  001ae	0f b6 45 f3	 movzx	 eax, BYTE PTR _attr$[ebp]
  001b2	83 e0 01	 and	 eax, 1
  001b5	75 1b		 jne	 SHORT $LN13@gObjBackSp
  001b7	0f b6 45 f3	 movzx	 eax, BYTE PTR _attr$[ebp]
  001bb	83 e0 02	 and	 eax, 2
  001be	75 12		 jne	 SHORT $LN13@gObjBackSp
  001c0	0f b6 45 f3	 movzx	 eax, BYTE PTR _attr$[ebp]
  001c4	83 e0 04	 and	 eax, 4
  001c7	75 09		 jne	 SHORT $LN13@gObjBackSp
  001c9	0f b6 45 f3	 movzx	 eax, BYTE PTR _attr$[ebp]
  001cd	83 e0 08	 and	 eax, 8
  001d0	74 07		 je	 SHORT $LN12@gObjBackSp
$LN13@gObjBackSp:

; 7557 : 		((attr&MAP_ATTR_HOLLOW) == MAP_ATTR_HOLLOW) 
; 7558 : #ifdef CASTLE_NPC_GATE_WORK_20041206	//     
; 7559 : 		|| ((attr&MAP_ATTR_WATER) == MAP_ATTR_WATER)
; 7560 : #endif
; 7561 : 		)
; 7562 : 	{
; 7563 : 		return FALSE;

  001d2	33 c0		 xor	 eax, eax
  001d4	e9 c2 00 00 00	 jmp	 $LN1@gObjBackSp
$LN12@gObjBackSp:

; 7564 : 	}
; 7565 : 	
; 7566 : 	PMSG_POSISTION_SET	pMove;
; 7567 : 	pMove.h.c		 = PMHC_BYTE;

  001d9	c6 45 e8 c1	 mov	 BYTE PTR _pMove$[ebp], 193 ; 000000c1H

; 7568 : 
; 7569 : #ifdef PACKET_CHANGE	
; 7570 : 	pMove.h.headcode = PACKET_POSITION;

  001dd	c6 45 ea d0	 mov	 BYTE PTR _pMove$[ebp+2], 208 ; 000000d0H

; 7571 : #else
; 7572 : 	pMove.h.headcode = 0x11;
; 7573 : #endif
; 7574 : 	pMove.h.size     = sizeof( pMove );

  001e1	c6 45 e9 05	 mov	 BYTE PTR _pMove$[ebp+1], 5

; 7575 : 	pMove.X          = (BYTE)x;

  001e5	8a 45 f8	 mov	 al, BYTE PTR _x$[ebp]
  001e8	88 45 eb	 mov	 BYTE PTR _pMove$[ebp+3], al

; 7576 : 	pMove.Y			 = (BYTE)y;

  001eb	8a 45 f4	 mov	 al, BYTE PTR _y$[ebp]
  001ee	88 45 ec	 mov	 BYTE PTR _pMove$[ebp+4], al

; 7577 : 
; 7578 : 	lpObj->m_Rest = 0;

  001f1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f4	c6 80 bd 01 00
	00 00		 mov	 BYTE PTR [eax+445], 0

; 7579 : 
; 7580 : 	MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  001fb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001fe	0f bf 88 1e 01
	00 00		 movsx	 ecx, WORD PTR [eax+286]
  00205	51		 push	 ecx
  00206	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00209	0f bf 82 1c 01
	00 00		 movsx	 eax, WORD PTR [edx+284]
  00210	50		 push	 eax
  00211	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00214	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0021b	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00221	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00227	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 7581 : 	MapC[lpObj->MapNumber].SetStandAttr(x, y);

  0022c	8b 45 f4	 mov	 eax, DWORD PTR _y$[ebp]
  0022f	50		 push	 eax
  00230	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  00233	51		 push	 ecx
  00234	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00237	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0023e	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00244	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0024a	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 7582 : 	lpObj->m_OldX = x;

  0024f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00252	66 8b 4d f8	 mov	 cx, WORD PTR _x$[ebp]
  00256	66 89 88 1c 01
	00 00		 mov	 WORD PTR [eax+284], cx

; 7583 : 	lpObj->m_OldY = y;

  0025d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00260	66 8b 4d f4	 mov	 cx, WORD PTR _y$[ebp]
  00264	66 89 88 1e 01
	00 00		 mov	 WORD PTR [eax+286], cx

; 7584 : 
; 7585 : 	
; 7586 : 	RecvPositionSetProc(&pMove, lpObj->m_Index);

  0026b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0026e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00270	51		 push	 ecx
  00271	8d 55 e8	 lea	 edx, DWORD PTR _pMove$[ebp]
  00274	52		 push	 edx
  00275	e8 00 00 00 00	 call	 ?RecvPositionSetProc@@YAXPAUPMSG_POSISTION_SET@@H@Z ; RecvPositionSetProc
  0027a	83 c4 08	 add	 esp, 8

; 7587 : 
; 7588 : 	if( lpObj->Type == OBJTYPE_CHARACTER )

  0027d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00280	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00284	83 f9 01	 cmp	 ecx, 1
  00287	75 0d		 jne	 SHORT $LN14@gObjBackSp

; 7589 : 	{
; 7590 : 		//   
; 7591 : 		lpObj->PathCount = 0;	

  00289	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028c	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0
$LN14@gObjBackSp:

; 7592 : 	}
; 7593 : 	
; 7594 : 	return TRUE;

  00296	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjBackSp:

; 7595 : }

  0029b	5f		 pop	 edi
  0029c	5e		 pop	 esi
  0029d	5b		 pop	 ebx
  0029e	8b e5		 mov	 esp, ebp
  002a0	5d		 pop	 ebp
  002a1	c3		 ret	 0
?gObjBackSpring@@YAHPAVOBJECTSTRUCT@@0@Z ENDP		; gObjBackSpring
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMsgProc@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_n$1 = -8						; size = 4
_aIndex$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjMsgProc@@YAXPAVOBJECTSTRUCT@@@Z PROC		; gObjMsgProc, COMDAT

; 7188 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7189 : 	int aIndex;
; 7190 : 
; 7191 : 	aIndex = lpObj->m_Index;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 7192 : 	for( int n=0; n<MAXMESSAGE; n++)

  00011	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00018	eb 09		 jmp	 SHORT $LN4@gObjMsgPro
$LN2@gObjMsgPro:
  0001a	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  0001d	83 c0 01	 add	 eax, 1
  00020	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjMsgPro:
  00023	83 7d f8 0a	 cmp	 DWORD PTR _n$1[ebp], 10	; 0000000aH
  00027	0f 8d f3 00 00
	00		 jge	 $LN1@gObjMsgPro

; 7193 : 	{
; 7194 : 		if( gSMMsg[aIndex][n].MsgCode >= 0 )

  0002d	69 45 fc a0 00
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 160
  00034	8b 4d f8	 mov	 ecx, DWORD PTR _n$1[ebp]
  00037	c1 e1 04	 shl	 ecx, 4
  0003a	83 bc 08 00 00
	00 00 00	 cmp	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+ecx], 0
  00042	0f 8c d3 00 00
	00		 jl	 $LN5@gObjMsgPro

; 7195 : 		{
; 7196 : 			if( GetTickCount() > gSMMsg[aIndex][n].MsgTime )	//     

  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0004e	69 4d fc a0 00
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 160
  00055	8b 55 f8	 mov	 edx, DWORD PTR _n$1[ebp]
  00058	c1 e2 04	 shl	 edx, 4
  0005b	3b 84 11 08 00
	00 00		 cmp	 eax, DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx+8]
  00062	0f 86 b3 00 00
	00		 jbe	 $LN5@gObjMsgPro

; 7197 : 			{
; 7198 : 				if( lpObj->Type == OBJTYPE_MONSTER || lpObj->Type == OBJTYPE_NPC)

  00068	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006b	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0006f	83 f9 02	 cmp	 ecx, 2
  00072	74 0c		 je	 SHORT $LN9@gObjMsgPro
  00074	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00077	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0007b	83 f9 03	 cmp	 ecx, 3
  0007e	75 38		 jne	 SHORT $LN7@gObjMsgPro
$LN9@gObjMsgPro:

; 7199 : 
; 7200 : #ifdef MODIFY_NEW_MONSTER_AI_01_2006724
; 7201 : 					gObjMonsterStateProc(lpObj, gSMMsg[aIndex][n].MsgCode, gSMMsg[aIndex][n].SendUser, gSMMsg[aIndex][n].SubCode);
; 7202 : #else
; 7203 : 					gObjMonsterStateProc(lpObj, gSMMsg[aIndex][n].MsgCode, gSMMsg[aIndex][n].SendUser);

  00080	69 45 fc a0 00
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 160
  00087	8b 4d f8	 mov	 ecx, DWORD PTR _n$1[ebp]
  0008a	c1 e1 04	 shl	 ecx, 4
  0008d	8b 94 08 04 00
	00 00		 mov	 edx, DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+ecx+4]
  00094	52		 push	 edx
  00095	69 45 fc a0 00
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 160
  0009c	8b 4d f8	 mov	 ecx, DWORD PTR _n$1[ebp]
  0009f	c1 e1 04	 shl	 ecx, 4
  000a2	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+ecx]
  000a9	52		 push	 edx
  000aa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 ?gObjMonsterStateProc@@YAXPAVOBJECTSTRUCT@@HH@Z ; gObjMonsterStateProc
  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b6	eb 4b		 jmp	 SHORT $LN8@gObjMsgPro
$LN7@gObjMsgPro:

; 7204 : #endif
; 7205 : 
; 7206 : 				else gObjStateProc(lpObj, gSMMsg[aIndex][n].MsgCode, gSMMsg[aIndex][n].SendUser, gSMMsg[aIndex][n].SubCode);

  000b8	69 45 fc a0 00
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 160
  000bf	8b 4d f8	 mov	 ecx, DWORD PTR _n$1[ebp]
  000c2	c1 e1 04	 shl	 ecx, 4
  000c5	8b 94 08 0c 00
	00 00		 mov	 edx, DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+ecx+12]
  000cc	52		 push	 edx
  000cd	69 45 fc a0 00
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 160
  000d4	8b 4d f8	 mov	 ecx, DWORD PTR _n$1[ebp]
  000d7	c1 e1 04	 shl	 ecx, 4
  000da	8b 94 08 04 00
	00 00		 mov	 edx, DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+ecx+4]
  000e1	52		 push	 edx
  000e2	69 45 fc a0 00
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 160
  000e9	8b 4d f8	 mov	 ecx, DWORD PTR _n$1[ebp]
  000ec	c1 e1 04	 shl	 ecx, 4
  000ef	8b 94 08 00 00
	00 00		 mov	 edx, DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+ecx]
  000f6	52		 push	 edx
  000f7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?gObjStateProc@@YAXPAVOBJECTSTRUCT@@HHH@Z ; gObjStateProc
  00100	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@gObjMsgPro:

; 7207 : 				gSMMsg[aIndex][n].MsgCode = -1;

  00103	69 45 fc a0 00
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 160
  0010a	8b 4d f8	 mov	 ecx, DWORD PTR _n$1[ebp]
  0010d	c1 e1 04	 shl	 ecx, 4
  00110	c7 84 08 00 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[eax+ecx], -1
$LN5@gObjMsgPro:

; 7208 : 			}
; 7209 : 		}
; 7210 : 	}		

  0011b	e9 fa fe ff ff	 jmp	 $LN2@gObjMsgPro
$LN1@gObjMsgPro:

; 7211 : }

  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
?gObjMsgProc@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; gObjMsgProc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjAttack@@YAHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_lpMagic$ = 16						; size = 4
_magicsend$ = 20					; size = 4
_MSBFlag$ = 24						; size = 1
_AttackDamage$ = 28					; size = 4
_bCombo$ = 32						; size = 4
?gObjAttack@@YAHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z PROC ; gObjAttack, COMDAT

; 12582: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 12583: 	return gclassObjAttack.Attack(lpObj, lpTargetObj, lpMagic, magicsend, MSBFlag, AttackDamage, bCombo);

  00009	8b 45 20	 mov	 eax, DWORD PTR _bCombo$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 1c	 mov	 ecx, DWORD PTR _AttackDamage$[ebp]
  00010	51		 push	 ecx
  00011	0f b6 55 18	 movzx	 edx, BYTE PTR _MSBFlag$[ebp]
  00015	52		 push	 edx
  00016	8b 45 14	 mov	 eax, DWORD PTR _magicsend$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR _lpMagic$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00021	52		 push	 edx
  00022	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00025	50		 push	 eax
  00026	b9 00 00 00 00	 mov	 ecx, OFFSET ?gclassObjAttack@@3VCObjAttack@@A ; gclassObjAttack
  0002b	e8 00 00 00 00	 call	 ?Attack@CObjAttack@@QAEHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; CObjAttack::Attack

; 12584: }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?gObjAttack@@YAHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ENDP ; gObjAttack
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?CreateFrustrum@@YAXHHH@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_lpObj$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_aIndex$ = 16						; size = 4
?CreateFrustrum@@YAXHHH@Z PROC				; CreateFrustrum, COMDAT

; 20486: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 20487: 	LPOBJECTSTRUCT lpObj=(LPOBJECTSTRUCT)&gObj[aIndex];

  00009	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 20488: 	
; 20489: 	for(int i=0;i<4;i++)

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00020	eb 09		 jmp	 SHORT $LN4@CreateFrus
$LN2@CreateFrus:
  00022	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00025	83 c0 01	 add	 eax, 1
  00028	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@CreateFrus:
  0002b	83 7d f8 04	 cmp	 DWORD PTR _i$1[ebp], 4
  0002f	7d 36		 jge	 SHORT $LN1@CreateFrus

; 20490: 	{
; 20491: 		lpObj->FrustrumX[i] = FrustrumX[i] + x;

  00031	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00034	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?FrustrumX@@3PAHA[eax*4]
  0003b	03 4d 08	 add	 ecx, DWORD PTR _x$[ebp]
  0003e	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  00041	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00044	89 8c 90 44 03
	00 00		 mov	 DWORD PTR [eax+edx*4+836], ecx

; 20492: 		lpObj->FrustrumY[i] = FrustrumY[i] + y;

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0004e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?FrustrumY@@3PAHA[eax*4]
  00055	03 4d 0c	 add	 ecx, DWORD PTR _y$[ebp]
  00058	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  0005b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005e	89 8c 90 54 03
	00 00		 mov	 DWORD PTR [eax+edx*4+852], ecx

; 20493: 	}

  00065	eb bb		 jmp	 SHORT $LN2@CreateFrus
$LN1@CreateFrus:

; 20494: }

  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	5b		 pop	 ebx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?CreateFrustrum@@YAXHHH@Z ENDP				; CreateFrustrum
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?InitFrustrum@@YAXXZ
_TEXT	SEGMENT
_i$1 = -184						; size = 4
_Frustrum$ = -180					; size = 48
_Matrix$ = -132						; size = 48
_Angle$ = -84						; size = 12
_p$ = -72						; size = 48
_WidthNear$ = -24					; size = 4
_WidthFar$ = -20					; size = 4
_CameraViewTarget$ = -16				; size = 4
_CameraViewNear$ = -12					; size = 4
_CameraViewFar$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
?InitFrustrum@@YAXXZ PROC				; InitFrustrum, COMDAT

; 20459: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 20460: 	
; 20461: 	float CameraViewFar    = 2400.f;	//  

  00016	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@45160000
  0001e	f3 0f 11 45 f8	 movss	 DWORD PTR _CameraViewFar$[ebp], xmm0

; 20462: 	float CameraViewNear   = CameraViewFar*0.19f;//  

  00023	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _CameraViewFar$[ebp]
  00028	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3e428f5c
  00030	f3 0f 11 45 f4	 movss	 DWORD PTR _CameraViewNear$[ebp], xmm0

; 20463: 	float CameraViewTarget = CameraViewFar*0.53f;//   

  00035	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _CameraViewFar$[ebp]
  0003a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f07ae14
  00042	f3 0f 11 45 f0	 movss	 DWORD PTR _CameraViewTarget$[ebp], xmm0

; 20464: 	float WidthFar  = 1190.f;//   

  00047	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@4494c000
  0004f	f3 0f 11 45 ec	 movss	 DWORD PTR _WidthFar$[ebp], xmm0

; 20465: 	float WidthNear = 550.f;//   

  00054	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44098000
  0005c	f3 0f 11 45 e8	 movss	 DWORD PTR _WidthNear$[ebp], xmm0

; 20466: 		
; 20467: 	vec3_t p[4];
; 20468: 	Vector(-WidthFar ,CameraViewFar -CameraViewTarget,0.f,p[0]);

  00061	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _WidthFar$[ebp]
  00066	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0006d	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00072	6b c8 00	 imul	 ecx, eax, 0
  00075	8d 54 0d b8	 lea	 edx, DWORD PTR _p$[ebp+ecx]
  00079	b8 04 00 00 00	 mov	 eax, 4
  0007e	6b c8 00	 imul	 ecx, eax, 0
  00081	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0
  00086	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _CameraViewFar$[ebp]
  0008b	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _CameraViewTarget$[ebp]
  00090	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00095	6b c8 00	 imul	 ecx, eax, 0
  00098	8d 54 0d b8	 lea	 edx, DWORD PTR _p$[ebp+ecx]
  0009c	b8 04 00 00 00	 mov	 eax, 4
  000a1	c1 e0 00	 shl	 eax, 0
  000a4	f3 0f 11 04 02	 movss	 DWORD PTR [edx+eax], xmm0
  000a9	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  000ae	6b c8 00	 imul	 ecx, eax, 0
  000b1	8d 54 0d b8	 lea	 edx, DWORD PTR _p$[ebp+ecx]
  000b5	b8 04 00 00 00	 mov	 eax, 4
  000ba	d1 e0		 shl	 eax, 1
  000bc	0f 57 c0	 xorps	 xmm0, xmm0
  000bf	f3 0f 11 04 02	 movss	 DWORD PTR [edx+eax], xmm0

; 20469: 	Vector( WidthFar ,CameraViewFar -CameraViewTarget,0.f,p[1]);

  000c4	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  000c9	c1 e0 00	 shl	 eax, 0
  000cc	8d 4c 05 b8	 lea	 ecx, DWORD PTR _p$[ebp+eax]
  000d0	ba 04 00 00 00	 mov	 edx, 4
  000d5	6b c2 00	 imul	 eax, edx, 0
  000d8	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _WidthFar$[ebp]
  000dd	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
  000e2	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _CameraViewFar$[ebp]
  000e7	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _CameraViewTarget$[ebp]
  000ec	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  000f1	c1 e0 00	 shl	 eax, 0
  000f4	8d 4c 05 b8	 lea	 ecx, DWORD PTR _p$[ebp+eax]
  000f8	ba 04 00 00 00	 mov	 edx, 4
  000fd	c1 e2 00	 shl	 edx, 0
  00100	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0
  00105	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0010a	c1 e0 00	 shl	 eax, 0
  0010d	8d 4c 05 b8	 lea	 ecx, DWORD PTR _p$[ebp+eax]
  00111	ba 04 00 00 00	 mov	 edx, 4
  00116	d1 e2		 shl	 edx, 1
  00118	0f 57 c0	 xorps	 xmm0, xmm0
  0011b	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 20470: 	Vector( WidthNear,CameraViewNear-CameraViewTarget,0.f,p[2]);

  00120	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00125	d1 e0		 shl	 eax, 1
  00127	8d 4c 05 b8	 lea	 ecx, DWORD PTR _p$[ebp+eax]
  0012b	ba 04 00 00 00	 mov	 edx, 4
  00130	6b c2 00	 imul	 eax, edx, 0
  00133	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _WidthNear$[ebp]
  00138	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0
  0013d	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _CameraViewNear$[ebp]
  00142	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _CameraViewTarget$[ebp]
  00147	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0014c	d1 e0		 shl	 eax, 1
  0014e	8d 4c 05 b8	 lea	 ecx, DWORD PTR _p$[ebp+eax]
  00152	ba 04 00 00 00	 mov	 edx, 4
  00157	c1 e2 00	 shl	 edx, 0
  0015a	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0
  0015f	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00164	d1 e0		 shl	 eax, 1
  00166	8d 4c 05 b8	 lea	 ecx, DWORD PTR _p$[ebp+eax]
  0016a	ba 04 00 00 00	 mov	 edx, 4
  0016f	d1 e2		 shl	 edx, 1
  00171	0f 57 c0	 xorps	 xmm0, xmm0
  00174	f3 0f 11 04 11	 movss	 DWORD PTR [ecx+edx], xmm0

; 20471: 	Vector(-WidthNear,CameraViewNear-CameraViewTarget,0.f,p[3]);

  00179	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _WidthNear$[ebp]
  0017e	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00185	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  0018a	6b c8 03	 imul	 ecx, eax, 3
  0018d	8d 54 0d b8	 lea	 edx, DWORD PTR _p$[ebp+ecx]
  00191	b8 04 00 00 00	 mov	 eax, 4
  00196	6b c8 00	 imul	 ecx, eax, 0
  00199	f3 0f 11 04 0a	 movss	 DWORD PTR [edx+ecx], xmm0
  0019e	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _CameraViewNear$[ebp]
  001a3	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _CameraViewTarget$[ebp]
  001a8	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  001ad	6b c8 03	 imul	 ecx, eax, 3
  001b0	8d 54 0d b8	 lea	 edx, DWORD PTR _p$[ebp+ecx]
  001b4	b8 04 00 00 00	 mov	 eax, 4
  001b9	c1 e0 00	 shl	 eax, 0
  001bc	f3 0f 11 04 02	 movss	 DWORD PTR [edx+eax], xmm0
  001c1	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  001c6	6b c8 03	 imul	 ecx, eax, 3
  001c9	8d 54 0d b8	 lea	 edx, DWORD PTR _p$[ebp+ecx]
  001cd	b8 04 00 00 00	 mov	 eax, 4
  001d2	d1 e0		 shl	 eax, 1
  001d4	0f 57 c0	 xorps	 xmm0, xmm0
  001d7	f3 0f 11 04 02	 movss	 DWORD PTR [edx+eax], xmm0

; 20472: 	vec3_t Angle;
; 20473: 	float Matrix[3][4];
; 20474: 	Vector(0.f,0.f,45.f,Angle);

  001dc	b8 04 00 00 00	 mov	 eax, 4
  001e1	6b c8 00	 imul	 ecx, eax, 0
  001e4	0f 57 c0	 xorps	 xmm0, xmm0
  001e7	f3 0f 11 44 0d
	ac		 movss	 DWORD PTR _Angle$[ebp+ecx], xmm0
  001ed	b8 04 00 00 00	 mov	 eax, 4
  001f2	c1 e0 00	 shl	 eax, 0
  001f5	0f 57 c0	 xorps	 xmm0, xmm0
  001f8	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _Angle$[ebp+eax], xmm0
  001fe	b8 04 00 00 00	 mov	 eax, 4
  00203	d1 e0		 shl	 eax, 1
  00205	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42340000
  0020d	f3 0f 11 44 05
	ac		 movss	 DWORD PTR _Angle$[ebp+eax], xmm0

; 20475: 	AngleMatrix(Angle,Matrix);

  00213	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _Matrix$[ebp]
  00219	50		 push	 eax
  0021a	8d 4d ac	 lea	 ecx, DWORD PTR _Angle$[ebp]
  0021d	51		 push	 ecx
  0021e	e8 00 00 00 00	 call	 _AngleMatrix
  00223	83 c4 08	 add	 esp, 8

; 20476:     vec3_t Frustrum[4];
; 20477: 	for(int i=0;i<4;i++)

  00226	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$1[ebp], 0
  00230	eb 0f		 jmp	 SHORT $LN4@InitFrustr
$LN2@InitFrustr:
  00232	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR _i$1[ebp]
  00238	83 c0 01	 add	 eax, 1
  0023b	89 85 48 ff ff
	ff		 mov	 DWORD PTR _i$1[ebp], eax
$LN4@InitFrustr:
  00241	83 bd 48 ff ff
	ff 04		 cmp	 DWORD PTR _i$1[ebp], 4
  00248	0f 8d 97 00 00
	00		 jge	 $LN3@InitFrustr

; 20478: 	{
; 20479: 		VectorRotate(p[i],Matrix,Frustrum[i]);

  0024e	6b 85 48 ff ff
	ff 0c		 imul	 eax, DWORD PTR _i$1[ebp], 12
  00255	8d 8c 05 4c ff
	ff ff		 lea	 ecx, DWORD PTR _Frustrum$[ebp+eax]
  0025c	51		 push	 ecx
  0025d	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _Matrix$[ebp]
  00263	52		 push	 edx
  00264	6b 85 48 ff ff
	ff 0c		 imul	 eax, DWORD PTR _i$1[ebp], 12
  0026b	8d 4c 05 b8	 lea	 ecx, DWORD PTR _p$[ebp+eax]
  0026f	51		 push	 ecx
  00270	e8 00 00 00 00	 call	 _VectorRotate
  00275	83 c4 0c	 add	 esp, 12			; 0000000cH

; 20480: 		FrustrumX[i] = (int)(Frustrum[i][0]*0.01f);

  00278	6b 85 48 ff ff
	ff 0c		 imul	 eax, DWORD PTR _i$1[ebp], 12
  0027f	8d 8c 05 4c ff
	ff ff		 lea	 ecx, DWORD PTR _Frustrum$[ebp+eax]
  00286	ba 04 00 00 00	 mov	 edx, 4
  0028b	6b c2 00	 imul	 eax, edx, 0
  0028e	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00293	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c23d70a
  0029b	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0029f	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR _i$1[ebp]
  002a5	89 0c 95 00 00
	00 00		 mov	 DWORD PTR ?FrustrumX@@3PAHA[edx*4], ecx

; 20481: 		FrustrumY[i] = (int)(Frustrum[i][1]*0.01f);

  002ac	6b 85 48 ff ff
	ff 0c		 imul	 eax, DWORD PTR _i$1[ebp], 12
  002b3	8d 8c 05 4c ff
	ff ff		 lea	 ecx, DWORD PTR _Frustrum$[ebp+eax]
  002ba	ba 04 00 00 00	 mov	 edx, 4
  002bf	c1 e2 00	 shl	 edx, 0
  002c2	f3 0f 10 04 11	 movss	 xmm0, DWORD PTR [ecx+edx]
  002c7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c23d70a
  002cf	f3 0f 2c c0	 cvttss2si eax, xmm0
  002d3	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _i$1[ebp]
  002d9	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?FrustrumY@@3PAHA[ecx*4], eax

; 20482: 	}

  002e0	e9 4d ff ff ff	 jmp	 $LN2@InitFrustr
$LN3@InitFrustr:

; 20483: }

  002e5	5f		 pop	 edi
  002e6	5e		 pop	 esi
  002e7	5b		 pop	 ebx
  002e8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002eb	33 cd		 xor	 ecx, ebp
  002ed	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002f2	8b e5		 mov	 esp, ebp
  002f4	5d		 pop	 ebp
  002f5	c3		 ret	 0
?InitFrustrum@@YAXXZ ENDP				; InitFrustrum
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjAddMsgSendDelayInSpecificQPos@@YAXPAVOBJECTSTRUCT@@HHHHH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_aMsgCode$ = 12						; size = 4
_aIndex$ = 16						; size = 4
_delay$ = 20						; size = 4
_SubCode$ = 24						; size = 4
_iQPosition$ = 28					; size = 4
?gObjAddMsgSendDelayInSpecificQPos@@YAXPAVOBJECTSTRUCT@@HHHHH@Z PROC ; gObjAddMsgSendDelayInSpecificQPos, COMDAT

; 7137 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7138 : 	if( iQPosition >= 0 && iQPosition < MAXMESSAGE )

  00009	83 7d 1c 00	 cmp	 DWORD PTR _iQPosition$[ebp], 0
  0000d	7c 6d		 jl	 SHORT $LN1@gObjAddMsg
  0000f	83 7d 1c 0a	 cmp	 DWORD PTR _iQPosition$[ebp], 10 ; 0000000aH
  00013	7d 67		 jge	 SHORT $LN1@gObjAddMsg

; 7139 : 	{
; 7140 : 		gSMMsg[lpObj->m_Index][iQPosition].MsgCode = aMsgCode;

  00015	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00018	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  0001e	8b 55 1c	 mov	 edx, DWORD PTR _iQPosition$[ebp]
  00021	c1 e2 04	 shl	 edx, 4
  00024	8b 45 0c	 mov	 eax, DWORD PTR _aMsgCode$[ebp]
  00027	89 84 11 00 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx], eax

; 7141 : 		gSMMsg[lpObj->m_Index][iQPosition].MsgTime = GetTickCount();

  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00037	69 11 a0 00 00
	00		 imul	 edx, DWORD PTR [ecx], 160
  0003d	8b 4d 1c	 mov	 ecx, DWORD PTR _iQPosition$[ebp]
  00040	c1 e1 04	 shl	 ecx, 4
  00043	89 84 0a 08 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[edx+ecx+8], eax

; 7142 : 		gSMMsg[lpObj->m_Index][iQPosition].SendUser= aIndex;

  0004a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004d	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  00053	8b 55 1c	 mov	 edx, DWORD PTR _iQPosition$[ebp]
  00056	c1 e2 04	 shl	 edx, 4
  00059	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0005c	89 84 11 04 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx+4], eax

; 7143 : 		gSMMsg[lpObj->m_Index][iQPosition].SubCode = SubCode;

  00063	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00066	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  0006c	8b 55 1c	 mov	 edx, DWORD PTR _iQPosition$[ebp]
  0006f	c1 e2 04	 shl	 edx, 4
  00072	8b 45 18	 mov	 eax, DWORD PTR _SubCode$[ebp]
  00075	89 84 11 0c 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx+12], eax
$LN1@gObjAddMsg:

; 7144 : 	}
; 7145 : }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
?gObjAddMsgSendDelayInSpecificQPos@@YAXPAVOBJECTSTRUCT@@HHHHH@Z ENDP ; gObjAddMsgSendDelayInSpecificQPos
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z
_TEXT	SEGMENT
_n$1 = -8						; size = 4
_n$2 = -4						; size = 4
_lpObj$ = 8						; size = 4
_aMsgCode$ = 12						; size = 4
_aIndex$ = 16						; size = 4
_delay$ = 20						; size = 4
_SubCode$ = 24						; size = 4
?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z PROC	; gObjAddMsgSendDelay, COMDAT

; 7107 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7108 : 	for( int n=0; n<MAXMESSAGE; n++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$2[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@gObjAddMsg
$LN2@gObjAddMsg:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _n$2[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _n$2[ebp], eax
$LN4@gObjAddMsg:
  0001b	83 7d fc 0a	 cmp	 DWORD PTR _n$2[ebp], 10	; 0000000aH
  0001f	0f 8d 8d 00 00
	00		 jge	 $LN3@gObjAddMsg

; 7109 : 	{
; 7110 : 		if( gSMMsg[lpObj->m_Index][n].MsgCode < 0 )

  00025	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00028	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  0002e	8b 55 fc	 mov	 edx, DWORD PTR _n$2[ebp]
  00031	c1 e2 04	 shl	 edx, 4
  00034	83 bc 11 00 00
	00 00 00	 cmp	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx], 0
  0003c	7d 6f		 jge	 SHORT $LN8@gObjAddMsg

; 7111 : 		{
; 7112 : 			gSMMsg[lpObj->m_Index][n].MsgCode = aMsgCode;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00041	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  00047	8b 55 fc	 mov	 edx, DWORD PTR _n$2[ebp]
  0004a	c1 e2 04	 shl	 edx, 4
  0004d	8b 45 0c	 mov	 eax, DWORD PTR _aMsgCode$[ebp]
  00050	89 84 11 00 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx], eax

; 7113 : 			gSMMsg[lpObj->m_Index][n].MsgTime = GetTickCount()+delay;

  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0005d	03 45 14	 add	 eax, DWORD PTR _delay$[ebp]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00063	69 11 a0 00 00
	00		 imul	 edx, DWORD PTR [ecx], 160
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _n$2[ebp]
  0006c	c1 e1 04	 shl	 ecx, 4
  0006f	89 84 0a 08 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[edx+ecx+8], eax

; 7114 : 			gSMMsg[lpObj->m_Index][n].SendUser= aIndex;

  00076	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00079	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  0007f	8b 55 fc	 mov	 edx, DWORD PTR _n$2[ebp]
  00082	c1 e2 04	 shl	 edx, 4
  00085	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00088	89 84 11 04 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx+4], eax

; 7115 : 			gSMMsg[lpObj->m_Index][n].SubCode = SubCode;

  0008f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00092	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  00098	8b 55 fc	 mov	 edx, DWORD PTR _n$2[ebp]
  0009b	c1 e2 04	 shl	 edx, 4
  0009e	8b 45 18	 mov	 eax, DWORD PTR _SubCode$[ebp]
  000a1	89 84 11 0c 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx+12], eax

; 7116 : 			return;

  000a8	e9 da 00 00 00	 jmp	 $LN1@gObjAddMsg
$LN8@gObjAddMsg:

; 7117 : 		}
; 7118 : 	}

  000ad	e9 60 ff ff ff	 jmp	 $LN2@gObjAddMsg
$LN3@gObjAddMsg:

; 7119 : 
; 7120 : 	for( int n=0; n<MAXMESSAGE; n++)

  000b2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  000b9	eb 09		 jmp	 SHORT $LN7@gObjAddMsg
$LN5@gObjAddMsg:
  000bb	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  000be	83 c0 01	 add	 eax, 1
  000c1	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax
$LN7@gObjAddMsg:
  000c4	83 7d f8 0a	 cmp	 DWORD PTR _n$1[ebp], 10	; 0000000aH
  000c8	0f 8d b9 00 00
	00		 jge	 $LN1@gObjAddMsg

; 7121 : 	{	//          
; 7122 : 		if( gSMMsg[lpObj->m_Index][n].MsgCode == 2 || gSMMsg[lpObj->m_Index][n].MsgCode == 6 || 

  000ce	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d1	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  000d7	8b 55 f8	 mov	 edx, DWORD PTR _n$1[ebp]
  000da	c1 e2 04	 shl	 edx, 4
  000dd	83 bc 11 00 00
	00 00 02	 cmp	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx], 2
  000e5	74 32		 je	 SHORT $LN10@gObjAddMsg
  000e7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ea	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  000f0	8b 55 f8	 mov	 edx, DWORD PTR _n$1[ebp]
  000f3	c1 e2 04	 shl	 edx, 4
  000f6	83 bc 11 00 00
	00 00 06	 cmp	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx], 6
  000fe	74 19		 je	 SHORT $LN10@gObjAddMsg
  00100	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00103	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  00109	8b 55 f8	 mov	 edx, DWORD PTR _n$1[ebp]
  0010c	c1 e2 04	 shl	 edx, 4
  0010f	83 bc 11 00 00
	00 00 07	 cmp	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx], 7
  00117	75 69		 jne	 SHORT $LN9@gObjAddMsg
$LN10@gObjAddMsg:

; 7123 : 			gSMMsg[lpObj->m_Index][n].MsgCode == 7 )
; 7124 : 		{
; 7125 : 			gSMMsg[lpObj->m_Index][n].MsgCode = aMsgCode;

  00119	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011c	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  00122	8b 55 f8	 mov	 edx, DWORD PTR _n$1[ebp]
  00125	c1 e2 04	 shl	 edx, 4
  00128	8b 45 0c	 mov	 eax, DWORD PTR _aMsgCode$[ebp]
  0012b	89 84 11 00 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx], eax

; 7126 : 			gSMMsg[lpObj->m_Index][n].MsgTime = GetTickCount();

  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00138	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0013b	69 11 a0 00 00
	00		 imul	 edx, DWORD PTR [ecx], 160
  00141	8b 4d f8	 mov	 ecx, DWORD PTR _n$1[ebp]
  00144	c1 e1 04	 shl	 ecx, 4
  00147	89 84 0a 08 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[edx+ecx+8], eax

; 7127 : 			gSMMsg[lpObj->m_Index][n].SendUser= aIndex;

  0014e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00151	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  00157	8b 55 f8	 mov	 edx, DWORD PTR _n$1[ebp]
  0015a	c1 e2 04	 shl	 edx, 4
  0015d	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00160	89 84 11 04 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx+4], eax

; 7128 : 			gSMMsg[lpObj->m_Index][n].SubCode = SubCode;

  00167	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016a	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  00170	8b 55 f8	 mov	 edx, DWORD PTR _n$1[ebp]
  00173	c1 e2 04	 shl	 edx, 4
  00176	8b 45 18	 mov	 eax, DWORD PTR _SubCode$[ebp]
  00179	89 84 11 0c 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx+12], eax

; 7129 : 			return;

  00180	eb 05		 jmp	 SHORT $LN1@gObjAddMsg
$LN9@gObjAddMsg:

; 7130 : 		}
; 7131 : 	}	

  00182	e9 34 ff ff ff	 jmp	 $LN5@gObjAddMsg
$LN1@gObjAddMsg:

; 7132 : }

  00187	5f		 pop	 edi
  00188	5e		 pop	 esi
  00189	5b		 pop	 ebx
  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c3		 ret	 0
?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z ENDP	; gObjAddMsgSendDelay
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjAddMsgSend@@YAXPAVOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
_n$1 = -8						; size = 4
_n$2 = -4						; size = 4
_lpObj$ = 8						; size = 4
_aMsgCode$ = 12						; size = 4
_aIndex$ = 16						; size = 4
_SubCode$ = 20						; size = 4
?gObjAddMsgSend@@YAXPAVOBJECTSTRUCT@@HHH@Z PROC		; gObjAddMsgSend, COMDAT

; 7079 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7080 : 	for( int n=0; n<MAXMESSAGE; n++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$2[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@gObjAddMsg
$LN2@gObjAddMsg:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _n$2[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _n$2[ebp], eax
$LN4@gObjAddMsg:
  0001b	83 7d fc 0a	 cmp	 DWORD PTR _n$2[ebp], 10	; 0000000aH
  0001f	0f 8d 8a 00 00
	00		 jge	 $LN3@gObjAddMsg

; 7081 : 	{
; 7082 : 		if( gSMMsg[lpObj->m_Index][n].MsgCode < 0 )

  00025	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00028	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  0002e	8b 55 fc	 mov	 edx, DWORD PTR _n$2[ebp]
  00031	c1 e2 04	 shl	 edx, 4
  00034	83 bc 11 00 00
	00 00 00	 cmp	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx], 0
  0003c	7d 6c		 jge	 SHORT $LN8@gObjAddMsg

; 7083 : 		{
; 7084 : 			gSMMsg[lpObj->m_Index][n].MsgCode = aMsgCode;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00041	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  00047	8b 55 fc	 mov	 edx, DWORD PTR _n$2[ebp]
  0004a	c1 e2 04	 shl	 edx, 4
  0004d	8b 45 0c	 mov	 eax, DWORD PTR _aMsgCode$[ebp]
  00050	89 84 11 00 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx], eax

; 7085 : 			gSMMsg[lpObj->m_Index][n].MsgTime = GetTickCount();

  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00060	69 11 a0 00 00
	00		 imul	 edx, DWORD PTR [ecx], 160
  00066	8b 4d fc	 mov	 ecx, DWORD PTR _n$2[ebp]
  00069	c1 e1 04	 shl	 ecx, 4
  0006c	89 84 0a 08 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[edx+ecx+8], eax

; 7086 : 			gSMMsg[lpObj->m_Index][n].SendUser= aIndex;

  00073	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00076	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  0007c	8b 55 fc	 mov	 edx, DWORD PTR _n$2[ebp]
  0007f	c1 e2 04	 shl	 edx, 4
  00082	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00085	89 84 11 04 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx+4], eax

; 7087 : 			gSMMsg[lpObj->m_Index][n].SubCode = SubCode;

  0008c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008f	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  00095	8b 55 fc	 mov	 edx, DWORD PTR _n$2[ebp]
  00098	c1 e2 04	 shl	 edx, 4
  0009b	8b 45 14	 mov	 eax, DWORD PTR _SubCode$[ebp]
  0009e	89 84 11 0c 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx+12], eax

; 7088 : 			return;

  000a5	e9 da 00 00 00	 jmp	 $LN1@gObjAddMsg
$LN8@gObjAddMsg:

; 7089 : 		}
; 7090 : 	}

  000aa	e9 63 ff ff ff	 jmp	 $LN2@gObjAddMsg
$LN3@gObjAddMsg:

; 7091 : 
; 7092 : 	for( int n=0; n<MAXMESSAGE; n++)

  000af	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  000b6	eb 09		 jmp	 SHORT $LN7@gObjAddMsg
$LN5@gObjAddMsg:
  000b8	8b 45 f8	 mov	 eax, DWORD PTR _n$1[ebp]
  000bb	83 c0 01	 add	 eax, 1
  000be	89 45 f8	 mov	 DWORD PTR _n$1[ebp], eax
$LN7@gObjAddMsg:
  000c1	83 7d f8 0a	 cmp	 DWORD PTR _n$1[ebp], 10	; 0000000aH
  000c5	0f 8d b9 00 00
	00		 jge	 $LN1@gObjAddMsg

; 7093 : 	{	//          
; 7094 : 		if( gSMMsg[lpObj->m_Index][n].MsgCode == 2 || gSMMsg[lpObj->m_Index][n].MsgCode == 6 || 

  000cb	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ce	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  000d4	8b 55 f8	 mov	 edx, DWORD PTR _n$1[ebp]
  000d7	c1 e2 04	 shl	 edx, 4
  000da	83 bc 11 00 00
	00 00 02	 cmp	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx], 2
  000e2	74 32		 je	 SHORT $LN10@gObjAddMsg
  000e4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e7	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  000ed	8b 55 f8	 mov	 edx, DWORD PTR _n$1[ebp]
  000f0	c1 e2 04	 shl	 edx, 4
  000f3	83 bc 11 00 00
	00 00 06	 cmp	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx], 6
  000fb	74 19		 je	 SHORT $LN10@gObjAddMsg
  000fd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00100	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  00106	8b 55 f8	 mov	 edx, DWORD PTR _n$1[ebp]
  00109	c1 e2 04	 shl	 edx, 4
  0010c	83 bc 11 00 00
	00 00 07	 cmp	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx], 7
  00114	75 69		 jne	 SHORT $LN9@gObjAddMsg
$LN10@gObjAddMsg:

; 7095 : 			gSMMsg[lpObj->m_Index][n].MsgCode == 7 )
; 7096 : 		{
; 7097 : 			gSMMsg[lpObj->m_Index][n].MsgCode = aMsgCode;

  00116	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00119	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  0011f	8b 55 f8	 mov	 edx, DWORD PTR _n$1[ebp]
  00122	c1 e2 04	 shl	 edx, 4
  00125	8b 45 0c	 mov	 eax, DWORD PTR _aMsgCode$[ebp]
  00128	89 84 11 00 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx], eax

; 7098 : 			gSMMsg[lpObj->m_Index][n].MsgTime = GetTickCount();

  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00135	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00138	69 11 a0 00 00
	00		 imul	 edx, DWORD PTR [ecx], 160
  0013e	8b 4d f8	 mov	 ecx, DWORD PTR _n$1[ebp]
  00141	c1 e1 04	 shl	 ecx, 4
  00144	89 84 0a 08 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[edx+ecx+8], eax

; 7099 : 			gSMMsg[lpObj->m_Index][n].SendUser= aIndex;

  0014b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014e	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  00154	8b 55 f8	 mov	 edx, DWORD PTR _n$1[ebp]
  00157	c1 e2 04	 shl	 edx, 4
  0015a	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0015d	89 84 11 04 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx+4], eax

; 7100 : 			gSMMsg[lpObj->m_Index][n].SubCode = SubCode;

  00164	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00167	69 08 a0 00 00
	00		 imul	 ecx, DWORD PTR [eax], 160
  0016d	8b 55 f8	 mov	 edx, DWORD PTR _n$1[ebp]
  00170	c1 e2 04	 shl	 edx, 4
  00173	8b 45 14	 mov	 eax, DWORD PTR _SubCode$[ebp]
  00176	89 84 11 0c 00
	00 00		 mov	 DWORD PTR ?gSMMsg@@3PAY09UMessageStateMachine@@A[ecx+edx+12], eax

; 7101 : 			return;

  0017d	eb 05		 jmp	 SHORT $LN1@gObjAddMsg
$LN9@gObjAddMsg:

; 7102 : 		}
; 7103 : 	}	

  0017f	e9 34 ff ff ff	 jmp	 $LN5@gObjAddMsg
$LN1@gObjAddMsg:

; 7104 : }

  00184	5f		 pop	 edi
  00185	5e		 pop	 esi
  00186	5b		 pop	 ebx
  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c3		 ret	 0
?gObjAddMsgSend@@YAXPAVOBJECTSTRUCT@@HHH@Z ENDP		; gObjAddMsgSend
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryItemBoxSet_PShop@@YAXHHHHE@Z
_TEXT	SEGMENT
_x$1 = -24						; size = 4
_y$2 = -20						; size = 4
_yy$ = -16						; size = 4
_xx$ = -12						; size = 4
_itemposy$ = -8						; size = 4
_itemposx$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_itempos$ = 12						; size = 4
_xl$ = 16						; size = 4
_yl$ = 20						; size = 4
_set_byte$ = 24						; size = 1
?gObjInventoryItemBoxSet_PShop@@YAXHHHHE@Z PROC		; gObjInventoryItemBoxSet_PShop, COMDAT

; 14849: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14850: 	int itemposx, itemposy;
; 14851: 	int xx, yy;
; 14852: 
; 14853: 	itemposx = (itempos-MAX_EQUIPMENT)%8;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  0000c	83 e8 0c	 sub	 eax, 12			; 0000000cH
  0000f	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00014	79 05		 jns	 SHORT $LN11@gObjInvent
  00016	48		 dec	 eax
  00017	83 c8 f8	 or	 eax, -8			; fffffff8H
  0001a	40		 inc	 eax
$LN11@gObjInvent:
  0001b	89 45 fc	 mov	 DWORD PTR _itemposx$[ebp], eax

; 14854: 	itemposy = (itempos-MAX_EQUIPMENT)/8;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  00021	83 e8 0c	 sub	 eax, 12			; 0000000cH
  00024	99		 cdq
  00025	83 e2 07	 and	 edx, 7
  00028	03 c2		 add	 eax, edx
  0002a	c1 f8 03	 sar	 eax, 3
  0002d	89 45 f8	 mov	 DWORD PTR _itemposy$[ebp], eax

; 14855: 
; 14856: 	for( int y=0; y<yl; y++)

  00030	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@gObjInvent
$LN2@gObjInvent:
  00039	8b 45 ec	 mov	 eax, DWORD PTR _y$2[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 ec	 mov	 DWORD PTR _y$2[ebp], eax
$LN4@gObjInvent:
  00042	8b 45 ec	 mov	 eax, DWORD PTR _y$2[ebp]
  00045	3b 45 14	 cmp	 eax, DWORD PTR _yl$[ebp]
  00048	0f 8d 95 00 00
	00		 jge	 $LN1@gObjInvent

; 14857: 	{
; 14858: 		yy = itemposy+y;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _itemposy$[ebp]
  00051	03 45 ec	 add	 eax, DWORD PTR _y$2[ebp]
  00054	89 45 f0	 mov	 DWORD PTR _yy$[ebp], eax

; 14859: 		for( int x=0; x<xl; x++)

  00057	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _x$1[ebp], 0
  0005e	eb 09		 jmp	 SHORT $LN7@gObjInvent
$LN5@gObjInvent:
  00060	8b 45 e8	 mov	 eax, DWORD PTR _x$1[ebp]
  00063	83 c0 01	 add	 eax, 1
  00066	89 45 e8	 mov	 DWORD PTR _x$1[ebp], eax
$LN7@gObjInvent:
  00069	8b 45 e8	 mov	 eax, DWORD PTR _x$1[ebp]
  0006c	3b 45 10	 cmp	 eax, DWORD PTR _xl$[ebp]
  0006f	7d 6d		 jge	 SHORT $LN6@gObjInvent

; 14860: 		{
; 14861: 			xx = itemposx+x;

  00071	8b 45 fc	 mov	 eax, DWORD PTR _itemposx$[ebp]
  00074	03 45 e8	 add	 eax, DWORD PTR _x$1[ebp]
  00077	89 45 f4	 mov	 DWORD PTR _xx$[ebp], eax

; 14862: #ifdef PERSONAL_SHOP_20040113		
; 14863: 			if( ExtentCheck(xx, yy, 8, 12) == TRUE )

  0007a	6a 0c		 push	 12			; 0000000cH
  0007c	6a 08		 push	 8
  0007e	8b 45 f0	 mov	 eax, DWORD PTR _yy$[ebp]
  00081	50		 push	 eax
  00082	8b 4d f4	 mov	 ecx, DWORD PTR _xx$[ebp]
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  0008b	83 c4 10	 add	 esp, 16			; 00000010H
  0008e	83 f8 01	 cmp	 eax, 1
  00091	75 2b		 jne	 SHORT $LN8@gObjInvent

; 14864: #else
; 14865: 			if( ExtentCheck(xx, yy, 8, 8) == TRUE )
; 14866: #endif
; 14867: 			{
; 14868: 				*(gObj[aIndex].InventoryMap1+((itemposy+y)*8)+(itemposx+x)) = set_byte;

  00093	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _itemposy$[ebp]
  0009d	03 4d ec	 add	 ecx, DWORD PTR _y$2[ebp]
  000a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a6	8b 84 02 70 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3184]
  000ad	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  000b0	8b 55 fc	 mov	 edx, DWORD PTR _itemposx$[ebp]
  000b3	03 55 e8	 add	 edx, DWORD PTR _x$1[ebp]
  000b6	8a 45 18	 mov	 al, BYTE PTR _set_byte$[ebp]
  000b9	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 14869: 			}

  000bc	eb 1e		 jmp	 SHORT $LN9@gObjInvent
$LN8@gObjInvent:

; 14870: 			else {
; 14871: 				LogAdd("error : %s %d",__FILE__, __LINE__);

  000be	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryItemBoxSet_PShop@@YAXHHHHE@Z@4JA
  000c3	83 c0 16	 add	 eax, 22			; 00000016H
  000c6	50		 push	 eax
  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14872: 				return;

  000da	eb 07		 jmp	 SHORT $LN1@gObjInvent
$LN9@gObjInvent:

; 14873: 			}
; 14874: 		}

  000dc	eb 82		 jmp	 SHORT $LN5@gObjInvent
$LN6@gObjInvent:

; 14875: 	}

  000de	e9 56 ff ff ff	 jmp	 $LN2@gObjInvent
$LN1@gObjInvent:

; 14876: }

  000e3	5f		 pop	 edi
  000e4	5e		 pop	 esi
  000e5	5b		 pop	 ebx
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
?gObjInventoryItemBoxSet_PShop@@YAXHHHHE@Z ENDP		; gObjInventoryItemBoxSet_PShop
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryItemSet_PShop@@YAXHHE@Z
_TEXT	SEGMENT
_height$ = -8						; size = 4
_width$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_itempos$ = 12						; size = 4
_set_byte$ = 16						; size = 1
?gObjInventoryItemSet_PShop@@YAXHHE@Z PROC		; gObjInventoryItemSet_PShop, COMDAT

; 14829: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14830: 	if( itempos < MAX_EQUIPMENT ) return;

  00009	83 7d 0c 0c	 cmp	 DWORD PTR _itempos$[ebp], 12 ; 0000000cH
  0000d	7d 02		 jge	 SHORT $LN2@gObjInvent
  0000f	eb 7a		 jmp	 SHORT $LN1@gObjInvent
$LN2@gObjInvent:

; 14831: #ifdef PERSONAL_SHOP_20040113		
; 14832: 	if( itempos > MAX_INVENTORY_EXTEND-1 ) return;

  00011	83 7d 0c 6b	 cmp	 DWORD PTR _itempos$[ebp], 107 ; 0000006bH
  00015	7e 02		 jle	 SHORT $LN3@gObjInvent
  00017	eb 72		 jmp	 SHORT $LN1@gObjInvent
$LN3@gObjInvent:

; 14833: #else
; 14834: 	if( itempos > MAX_INVENTORY-1 ) return;
; 14835: #endif	
; 14836: 	
; 14837: 	int width, height;
; 14838: 
; 14839: 	if( gObj[aIndex].Inventory1[itempos].GetSize( width, height ) == FALSE ) 

  00019	8d 45 f8	 lea	 eax, DWORD PTR _height$[ebp]
  0001c	50		 push	 eax
  0001d	8d 4d fc	 lea	 ecx, DWORD PTR _width$[ebp]
  00020	51		 push	 ecx
  00021	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00028	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _itempos$[ebp], 168
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00034	03 8c 10 6c 0c
	00 00		 add	 ecx, DWORD PTR [eax+edx+3180]
  0003b	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  00040	85 c0		 test	 eax, eax
  00042	75 2a		 jne	 SHORT $LN4@gObjInvent

; 14840: 	{
; 14841: 		LogAdd(lMsg.Get(527), __FILE__, __LINE__);

  00044	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryItemSet_PShop@@YAXHHE@Z@4JA
  00049	83 c0 0c	 add	 eax, 12			; 0000000cH
  0004c	50		 push	 eax
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00052	68 0f 02 00 00	 push	 527			; 0000020fH
  00057	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00062	50		 push	 eax
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14842: 		return;

  0006c	eb 1d		 jmp	 SHORT $LN1@gObjInvent
$LN4@gObjInvent:

; 14843: 	}
; 14844: 	gObjInventoryItemBoxSet_PShop(aIndex, itempos, width, height, set_byte);	

  0006e	0f b6 45 10	 movzx	 eax, BYTE PTR _set_byte$[ebp]
  00072	50		 push	 eax
  00073	8b 4d f8	 mov	 ecx, DWORD PTR _height$[ebp]
  00076	51		 push	 ecx
  00077	8b 55 fc	 mov	 edx, DWORD PTR _width$[ebp]
  0007a	52		 push	 edx
  0007b	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 ?gObjInventoryItemBoxSet_PShop@@YAXHHHHE@Z ; gObjInventoryItemBoxSet_PShop
  00088	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@gObjInvent:

; 14845: }

  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?gObjInventoryItemSet_PShop@@YAXHHE@Z ENDP		; gObjInventoryItemSet_PShop
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMakePreviewCharSet@@YAXH@Z
_TEXT	SEGMENT
tv66 = -108						; size = 4
tv67 = -104						; size = 4
_levelindex$ = -36					; size = 4
_TempType$ = -32					; size = 20
_lpObj$ = -12						; size = 4
_index$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?gObjMakePreviewCharSet@@YAXH@Z PROC			; gObjMakePreviewCharSet, COMDAT

; 19634: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 19635: 	BYTE index;
; 19636: 
; 19637: 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT) )

  00013	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00017	7d 09		 jge	 SHORT $LN52@gObjMakePr
  00019	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00020	eb 1f		 jmp	 SHORT $LN53@gObjMakePr
$LN52@gObjMakePr:
  00022	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00029	7e 09		 jle	 SHORT $LN50@gObjMakePr
  0002b	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00032	eb 07		 jmp	 SHORT $LN51@gObjMakePr
$LN50@gObjMakePr:
  00034	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN51@gObjMakePr:
  0003b	8b 45 94	 mov	 eax, DWORD PTR tv66[ebp]
  0003e	89 45 98	 mov	 DWORD PTR tv67[ebp], eax
$LN53@gObjMakePr:
  00041	83 7d 98 00	 cmp	 DWORD PTR tv67[ebp], 0
  00045	75 21		 jne	 SHORT $LN2@gObjMakePr

; 19638: 	{
; 19639: 		LogAdd("error : %s %d",__FILE__, __LINE__);

  00047	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjMakePreviewCharSet@@YAXH@Z@4JA
  0004c	83 c0 05	 add	 eax, 5
  0004f	50		 push	 eax
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH

; 19640: 		return;

  00063	e9 e0 0c 00 00	 jmp	 $LN1@gObjMakePr
$LN2@gObjMakePr:

; 19641: 	}
; 19642: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00068	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0006f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00075	89 45 f4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 19643: 
; 19644: #ifdef ITEM_INDEX_EXTEND_20050706
; 19645: 	memset(lpObj->CharSet, 0, sizeof(lpObj->CharSet));
; 19646: #endif
; 19647: 	
; 19648: 	lpObj->CharSet[0]  = (lpObj->Class<<5)&0xE0;

  00078	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007b	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00082	c1 e1 05	 shl	 ecx, 5
  00085	81 e1 e0 00 00
	00		 and	 ecx, 224		; 000000e0H
  0008b	ba 01 00 00 00	 mov	 edx, 1
  00090	6b c2 00	 imul	 eax, edx, 0
  00093	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00096	88 8c 02 28 03
	00 00		 mov	 BYTE PTR [edx+eax+808], cl

; 19649: 
; 19650: #ifdef NEW_SKILL_FORSKYLAND	
; 19651: 	lpObj->CharSet[0] |= (lpObj->ChangeUP<<4)&0x10;

  0009d	b8 01 00 00 00	 mov	 eax, 1
  000a2	6b c8 00	 imul	 ecx, eax, 0
  000a5	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000a8	0f b6 82 9f 00
	00 00		 movzx	 eax, BYTE PTR [edx+159]
  000af	c1 e0 04	 shl	 eax, 4
  000b2	83 e0 10	 and	 eax, 16			; 00000010H
  000b5	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000b8	0f b6 8c 0a 28
	03 00 00	 movzx	 ecx, BYTE PTR [edx+ecx+808]
  000c0	0b c8		 or	 ecx, eax
  000c2	ba 01 00 00 00	 mov	 edx, 1
  000c7	6b c2 00	 imul	 eax, edx, 0
  000ca	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000cd	88 8c 02 28 03
	00 00		 mov	 BYTE PTR [edx+eax+808], cl

; 19652: #else
; 19653: 	lpObj->CharSet[0] |= (lpObj->Skin<<4)&0x10;
; 19654: #endif
; 19655: 
; 19656: #ifdef THIRD_CHANGEUP_SYSTEM_20070507
; 19657: 	lpObj->CharSet[0] |= ( lpObj->ThirdChangeUp << 3 )&0x08;
; 19658: #endif
; 19659: 
; 19660: 	
; 19661: 	if( lpObj->m_ActionNumber == AT_SIT1 )

  000d4	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d7	0f b6 88 b4 01
	00 00		 movzx	 ecx, BYTE PTR [eax+436]
  000de	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  000e4	75 2a		 jne	 SHORT $LN3@gObjMakePr

; 19662: 		lpObj->CharSet[0] |= 2;

  000e6	b8 01 00 00 00	 mov	 eax, 1
  000eb	6b c8 00	 imul	 ecx, eax, 0
  000ee	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000f1	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  000f9	83 c8 02	 or	 eax, 2
  000fc	b9 01 00 00 00	 mov	 ecx, 1
  00101	6b d1 00	 imul	 edx, ecx, 0
  00104	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00107	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
  0010e	eb 60		 jmp	 SHORT $LN4@gObjMakePr
$LN3@gObjMakePr:

; 19663: 	else if( lpObj->m_ActionNumber == AT_POSE1 )

  00110	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00113	0f b6 88 b4 01
	00 00		 movzx	 ecx, BYTE PTR [eax+436]
  0011a	81 f9 81 00 00
	00		 cmp	 ecx, 129		; 00000081H
  00120	75 2a		 jne	 SHORT $LN5@gObjMakePr

; 19664: 		lpObj->CharSet[0] |= 3;

  00122	b8 01 00 00 00	 mov	 eax, 1
  00127	6b c8 00	 imul	 ecx, eax, 0
  0012a	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0012d	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  00135	83 c8 03	 or	 eax, 3
  00138	b9 01 00 00 00	 mov	 ecx, 1
  0013d	6b d1 00	 imul	 edx, ecx, 0
  00140	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00143	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
  0014a	eb 24		 jmp	 SHORT $LN4@gObjMakePr
$LN5@gObjMakePr:

; 19665: 	else lpObj->CharSet[0] |= 0;

  0014c	b8 01 00 00 00	 mov	 eax, 1
  00151	6b c8 00	 imul	 ecx, eax, 0
  00154	ba 01 00 00 00	 mov	 edx, 1
  00159	6b c2 00	 imul	 eax, edx, 0
  0015c	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0015f	8b 75 f4	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00162	8a 8c 0e 28 03
	00 00		 mov	 cl, BYTE PTR [esi+ecx+808]
  00169	88 8c 02 28 03
	00 00		 mov	 BYTE PTR [edx+eax+808], cl
$LN4@gObjMakePr:

; 19666: 	
; 19667: #ifdef ITEM_INDEX_EXTEND_20050706
; 19668: 	// !!! . >   4096      1  .
; 19669: 
; 19670: 	//  
; 19671: 	if( lpObj->pInventory[0].m_Type < 0 ) 
; 19672: 	{
; 19673: 		lpObj->CharSet[12] |= 0xF0;
; 19674: 		lpObj->CharSet[1] = 0xFF;
; 19675: 	}
; 19676: 	else 
; 19677: 	{
; 19678: 		//  4 (4096,2048,1024,512) 
; 19679: 		lpObj->CharSet[12] |= (BYTE)((lpObj->pInventory[0].m_Type&0x0F00)>>4);
; 19680: 		//  4 
; 19681: 		lpObj->CharSet[1] = (BYTE)(lpObj->pInventory[0].m_Type&0x00FF);
; 19682: 	}
; 19683: 
; 19684: 	//  
; 19685: 	if( lpObj->pInventory[1].m_Type < 0 ) 
; 19686: 	{
; 19687: 		lpObj->CharSet[13] |= 0xF0;
; 19688: 		lpObj->CharSet[2] = 0xFF;
; 19689: 	}
; 19690: 	else 
; 19691: 	{
; 19692: 		//  4 (4096,2048,1024,512) 
; 19693: 		lpObj->CharSet[13] |= (BYTE)((lpObj->pInventory[1].m_Type&0x0F00)>>4);
; 19694: 		//  4 
; 19695: 		lpObj->CharSet[2] = (BYTE)(lpObj->pInventory[1].m_Type&0x00FF);
; 19696: 	}
; 19697: 
; 19698: 	// 
; 19699: 	if( lpObj->pInventory[2].m_Type < 0 ) 
; 19700: 	{
; 19701: 		lpObj->CharSet[13] |= 0x0F;
; 19702: 		lpObj->CharSet[9] |= 0x80;
; 19703: 		lpObj->CharSet[3] |= 0xF0;
; 19704: 	}
; 19705: 	else 
; 19706: 	{
; 19707: 		//  4 (256,128,64,32) 
; 19708: 		lpObj->CharSet[13] |= (BYTE)((lpObj->pInventory[2].m_Type&0x01E0)>>5);
; 19709: 		//  5  (32) 
; 19710: 		lpObj->CharSet[9] |= (BYTE)((lpObj->pInventory[2].m_Type&0x0010)<<3);
; 19711: 		//  4 
; 19712: 		lpObj->CharSet[3] |= (BYTE)((lpObj->pInventory[2].m_Type&0x000F)<<4);
; 19713: 	}
; 19714: 	
; 19715: 	// 
; 19716: 	if( lpObj->pInventory[3].m_Type < 0 ) 
; 19717: 	{
; 19718: 		lpObj->CharSet[14] |= 0xF0;
; 19719: 		lpObj->CharSet[9] |= 0x40;
; 19720: 		lpObj->CharSet[3] |= 0x0F;
; 19721: 	}
; 19722: 	else 
; 19723: 	{
; 19724: 		//  4 (256,128,64,32) 
; 19725: 		lpObj->CharSet[14] |= (BYTE)((lpObj->pInventory[3].m_Type&0x01E0)>>1);
; 19726: 		//  5  (32) 
; 19727: 		lpObj->CharSet[9] |= (BYTE)((lpObj->pInventory[3].m_Type&0x0010)<<2);
; 19728: 		//  4 
; 19729: 		lpObj->CharSet[3] |= (BYTE)((lpObj->pInventory[3].m_Type&0x000F));
; 19730: 	}
; 19731: 
; 19732: 	// 
; 19733: 	if( lpObj->pInventory[4].m_Type < 0 ) 
; 19734: 	{
; 19735: 		lpObj->CharSet[14] |= 0x0F;
; 19736: 		lpObj->CharSet[9] |= 0x20;
; 19737: 		lpObj->CharSet[4] |= 0xF0;
; 19738: 	}
; 19739: 	else 
; 19740: 	{
; 19741: 		//  4 (256,128,64,32) 
; 19742: 		lpObj->CharSet[14] |= (BYTE)((lpObj->pInventory[4].m_Type&0x01E0)>>5);
; 19743: 		//  5  (32) 
; 19744: 		lpObj->CharSet[9] |= (BYTE)((lpObj->pInventory[4].m_Type&0x0010)<<1);
; 19745: 		//  4 
; 19746: 		lpObj->CharSet[4] |= (BYTE)((lpObj->pInventory[4].m_Type&0x000F)<<4);
; 19747: 	}
; 19748: 
; 19749: 	// 
; 19750: 	if( lpObj->pInventory[5].m_Type < 0 ) 
; 19751: 	{
; 19752: 		lpObj->CharSet[15] |= 0xF0;
; 19753: 		lpObj->CharSet[9] |= 0x10;
; 19754: 		lpObj->CharSet[4] |= 0x0F;
; 19755: 	}
; 19756: 	else 
; 19757: 	{
; 19758: 		//  4 (256,128,64,32) 
; 19759: 		lpObj->CharSet[15] |= (BYTE)((lpObj->pInventory[5].m_Type&0x01E0)>>1);
; 19760: 		//  5  (32) 
; 19761: 		lpObj->CharSet[9] |= (BYTE)((lpObj->pInventory[5].m_Type&0x0010));
; 19762: 		//  4 
; 19763: 		lpObj->CharSet[4] |= (BYTE)((lpObj->pInventory[5].m_Type&0x000F));
; 19764: 	}
; 19765: 	
; 19766: 	// 
; 19767: 	if( lpObj->pInventory[6].m_Type < 0 ) 
; 19768: 	{
; 19769: 		lpObj->CharSet[15] |= 0x0F;
; 19770: 		lpObj->CharSet[9] |= 0x08;
; 19771: 		lpObj->CharSet[5] |= 0xF0;
; 19772: 	}
; 19773: 	else 
; 19774: 	{
; 19775: 		//  4 (256,128,64,32) 
; 19776: 		lpObj->CharSet[15] |= (BYTE)((lpObj->pInventory[6].m_Type&0x01E0)>>5);
; 19777: 		//  5  (32) 
; 19778: 		lpObj->CharSet[9] |= (BYTE)((lpObj->pInventory[6].m_Type&0x0010)>>1);
; 19779: 		//  4 
; 19780: 		lpObj->CharSet[5] |= (BYTE)((lpObj->pInventory[6].m_Type&0x000F)<<4);
; 19781: 	}
; 19782: 	
; 19783: 	index = 0;	//   .
; 19784: #else
; 19785: 	short TempType[10];
; 19786: 	if( lpObj->pInventory[0].m_Type < 0 )

  00170	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00175	6b c8 00	 imul	 ecx, eax, 0
  00178	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0017b	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00181	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  00186	85 c9		 test	 ecx, ecx
  00188	7d 06		 jge	 SHORT $LN7@gObjMakePr

; 19787: 		index = 0xFF;

  0018a	c6 45 fb ff	 mov	 BYTE PTR _index$[ebp], 255 ; 000000ffH
  0018e	eb 18		 jmp	 SHORT $LN8@gObjMakePr
$LN7@gObjMakePr:

; 19788: 	else index = (BYTE)lpObj->pInventory[0].m_Type;

  00190	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00195	6b c8 00	 imul	 ecx, eax, 0
  00198	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0019b	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  001a1	8a 4c 08 06	 mov	 cl, BYTE PTR [eax+ecx+6]
  001a5	88 4d fb	 mov	 BYTE PTR _index$[ebp], cl
$LN8@gObjMakePr:

; 19789: 	lpObj->CharSet[1] = index;

  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	c1 e0 00	 shl	 eax, 0
  001b0	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001b3	8a 55 fb	 mov	 dl, BYTE PTR _index$[ebp]
  001b6	88 94 01 28 03
	00 00		 mov	 BYTE PTR [ecx+eax+808], dl

; 19790: 
; 19791: 	if( lpObj->pInventory[1].m_Type < 0 )

  001bd	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  001c2	c1 e0 00	 shl	 eax, 0
  001c5	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001c8	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  001ce	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  001d3	85 c0		 test	 eax, eax
  001d5	7d 06		 jge	 SHORT $LN9@gObjMakePr

; 19792: 		index = 0xFF;

  001d7	c6 45 fb ff	 mov	 BYTE PTR _index$[ebp], 255 ; 000000ffH
  001db	eb 18		 jmp	 SHORT $LN10@gObjMakePr
$LN9@gObjMakePr:

; 19793: 	else index = (BYTE)lpObj->pInventory[1].m_Type;

  001dd	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  001e2	c1 e0 00	 shl	 eax, 0
  001e5	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001e8	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  001ee	8a 44 02 06	 mov	 al, BYTE PTR [edx+eax+6]
  001f2	88 45 fb	 mov	 BYTE PTR _index$[ebp], al
$LN10@gObjMakePr:

; 19794: 	lpObj->CharSet[2] = index;

  001f5	b8 01 00 00 00	 mov	 eax, 1
  001fa	d1 e0		 shl	 eax, 1
  001fc	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001ff	8a 55 fb	 mov	 dl, BYTE PTR _index$[ebp]
  00202	88 94 01 28 03
	00 00		 mov	 BYTE PTR [ecx+eax+808], dl

; 19795: 
; 19796: 	TempType[2] = MAKE_ITEMNUM_INDEX(lpObj->pInventory[2].m_Type);

  00209	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0020e	d1 e0		 shl	 eax, 1
  00210	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00213	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00219	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  0021e	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  00223	79 05		 jns	 SHORT $LN54@gObjMakePr
  00225	48		 dec	 eax
  00226	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00229	40		 inc	 eax
$LN54@gObjMakePr:
  0022a	b9 02 00 00 00	 mov	 ecx, 2
  0022f	d1 e1		 shl	 ecx, 1
  00231	66 89 44 0d e0	 mov	 WORD PTR _TempType$[ebp+ecx], ax

; 19797: 	if( lpObj->pInventory[2].m_Type < 0 ) TempType[2] = 31;

  00236	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0023b	d1 e0		 shl	 eax, 1
  0023d	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00240	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00246	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  0024b	85 c0		 test	 eax, eax
  0024d	7d 11		 jge	 SHORT $LN11@gObjMakePr
  0024f	b8 02 00 00 00	 mov	 eax, 2
  00254	d1 e0		 shl	 eax, 1
  00256	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0025b	66 89 4c 05 e0	 mov	 WORD PTR _TempType$[ebp+eax], cx
$LN11@gObjMakePr:

; 19798: 	TempType[3] = MAKE_ITEMNUM_INDEX(lpObj->pInventory[3].m_Type);

  00260	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00265	6b c8 03	 imul	 ecx, eax, 3
  00268	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0026b	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00271	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  00276	81 e1 1f 00 00
	80		 and	 ecx, -2147483617	; 8000001fH
  0027c	79 05		 jns	 SHORT $LN55@gObjMakePr
  0027e	49		 dec	 ecx
  0027f	83 c9 e0	 or	 ecx, -32		; ffffffe0H
  00282	41		 inc	 ecx
$LN55@gObjMakePr:
  00283	ba 02 00 00 00	 mov	 edx, 2
  00288	6b c2 03	 imul	 eax, edx, 3
  0028b	66 89 4c 05 e0	 mov	 WORD PTR _TempType$[ebp+eax], cx

; 19799: 	if( lpObj->pInventory[3].m_Type < 0 ) TempType[3] = 31;

  00290	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00295	6b c8 03	 imul	 ecx, eax, 3
  00298	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0029b	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  002a1	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  002a6	85 c9		 test	 ecx, ecx
  002a8	7d 12		 jge	 SHORT $LN12@gObjMakePr
  002aa	b8 02 00 00 00	 mov	 eax, 2
  002af	6b c8 03	 imul	 ecx, eax, 3
  002b2	ba 1f 00 00 00	 mov	 edx, 31			; 0000001fH
  002b7	66 89 54 0d e0	 mov	 WORD PTR _TempType$[ebp+ecx], dx
$LN12@gObjMakePr:

; 19800: 	TempType[4] = MAKE_ITEMNUM_INDEX(lpObj->pInventory[4].m_Type);

  002bc	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  002c1	c1 e0 02	 shl	 eax, 2
  002c4	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002c7	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  002cd	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  002d2	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  002d7	79 05		 jns	 SHORT $LN56@gObjMakePr
  002d9	48		 dec	 eax
  002da	83 c8 e0	 or	 eax, -32		; ffffffe0H
  002dd	40		 inc	 eax
$LN56@gObjMakePr:
  002de	b9 02 00 00 00	 mov	 ecx, 2
  002e3	c1 e1 02	 shl	 ecx, 2
  002e6	66 89 44 0d e0	 mov	 WORD PTR _TempType$[ebp+ecx], ax

; 19801: 	if( lpObj->pInventory[4].m_Type < 0 ) TempType[4] = 31;

  002eb	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  002f0	c1 e0 02	 shl	 eax, 2
  002f3	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002f6	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  002fc	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  00301	85 c0		 test	 eax, eax
  00303	7d 12		 jge	 SHORT $LN13@gObjMakePr
  00305	b8 02 00 00 00	 mov	 eax, 2
  0030a	c1 e0 02	 shl	 eax, 2
  0030d	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00312	66 89 4c 05 e0	 mov	 WORD PTR _TempType$[ebp+eax], cx
$LN13@gObjMakePr:

; 19802: 	TempType[5] = MAKE_ITEMNUM_INDEX(lpObj->pInventory[5].m_Type);

  00317	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0031c	6b c8 05	 imul	 ecx, eax, 5
  0031f	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00322	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00328	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  0032d	81 e1 1f 00 00
	80		 and	 ecx, -2147483617	; 8000001fH
  00333	79 05		 jns	 SHORT $LN57@gObjMakePr
  00335	49		 dec	 ecx
  00336	83 c9 e0	 or	 ecx, -32		; ffffffe0H
  00339	41		 inc	 ecx
$LN57@gObjMakePr:
  0033a	ba 02 00 00 00	 mov	 edx, 2
  0033f	6b c2 05	 imul	 eax, edx, 5
  00342	66 89 4c 05 e0	 mov	 WORD PTR _TempType$[ebp+eax], cx

; 19803: 	if( lpObj->pInventory[5].m_Type < 0 ) TempType[5] = 31;

  00347	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0034c	6b c8 05	 imul	 ecx, eax, 5
  0034f	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00352	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00358	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  0035d	85 c9		 test	 ecx, ecx
  0035f	7d 12		 jge	 SHORT $LN14@gObjMakePr
  00361	b8 02 00 00 00	 mov	 eax, 2
  00366	6b c8 05	 imul	 ecx, eax, 5
  00369	ba 1f 00 00 00	 mov	 edx, 31			; 0000001fH
  0036e	66 89 54 0d e0	 mov	 WORD PTR _TempType$[ebp+ecx], dx
$LN14@gObjMakePr:

; 19804: 	TempType[6] = MAKE_ITEMNUM_INDEX(lpObj->pInventory[6].m_Type);

  00373	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00378	6b c8 06	 imul	 ecx, eax, 6
  0037b	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0037e	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00384	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  00389	81 e1 1f 00 00
	80		 and	 ecx, -2147483617	; 8000001fH
  0038f	79 05		 jns	 SHORT $LN58@gObjMakePr
  00391	49		 dec	 ecx
  00392	83 c9 e0	 or	 ecx, -32		; ffffffe0H
  00395	41		 inc	 ecx
$LN58@gObjMakePr:
  00396	ba 02 00 00 00	 mov	 edx, 2
  0039b	6b c2 06	 imul	 eax, edx, 6
  0039e	66 89 4c 05 e0	 mov	 WORD PTR _TempType$[ebp+eax], cx

; 19805: 	if( lpObj->pInventory[6].m_Type < 0 ) TempType[6] = 31;

  003a3	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  003a8	6b c8 06	 imul	 ecx, eax, 6
  003ab	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003ae	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  003b4	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  003b9	85 c9		 test	 ecx, ecx
  003bb	7d 12		 jge	 SHORT $LN15@gObjMakePr
  003bd	b8 02 00 00 00	 mov	 eax, 2
  003c2	6b c8 06	 imul	 ecx, eax, 6
  003c5	ba 1f 00 00 00	 mov	 edx, 31			; 0000001fH
  003ca	66 89 54 0d e0	 mov	 WORD PTR _TempType$[ebp+ecx], dx
$LN15@gObjMakePr:

; 19806: 
; 19807: 	
; 19808: 	lpObj->CharSet[3] = ((TempType[2]%16)<<4)+(TempType[3]%16);

  003cf	b8 02 00 00 00	 mov	 eax, 2
  003d4	d1 e0		 shl	 eax, 1
  003d6	0f bf 4c 05 e0	 movsx	 ecx, WORD PTR _TempType$[ebp+eax]
  003db	81 e1 0f 00 00
	80		 and	 ecx, -2147483633	; 8000000fH
  003e1	79 05		 jns	 SHORT $LN59@gObjMakePr
  003e3	49		 dec	 ecx
  003e4	83 c9 f0	 or	 ecx, -16		; fffffff0H
  003e7	41		 inc	 ecx
$LN59@gObjMakePr:
  003e8	c1 e1 04	 shl	 ecx, 4
  003eb	ba 02 00 00 00	 mov	 edx, 2
  003f0	6b c2 03	 imul	 eax, edx, 3
  003f3	0f bf 54 05 e0	 movsx	 edx, WORD PTR _TempType$[ebp+eax]
  003f8	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  003fe	79 05		 jns	 SHORT $LN60@gObjMakePr
  00400	4a		 dec	 edx
  00401	83 ca f0	 or	 edx, -16		; fffffff0H
  00404	42		 inc	 edx
$LN60@gObjMakePr:
  00405	03 ca		 add	 ecx, edx
  00407	b8 01 00 00 00	 mov	 eax, 1
  0040c	6b d0 03	 imul	 edx, eax, 3
  0040f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00412	88 8c 10 28 03
	00 00		 mov	 BYTE PTR [eax+edx+808], cl

; 19809: 	lpObj->CharSet[4] = ((TempType[4]%16)<<4)+(TempType[5]%16);

  00419	b8 02 00 00 00	 mov	 eax, 2
  0041e	c1 e0 02	 shl	 eax, 2
  00421	0f bf 4c 05 e0	 movsx	 ecx, WORD PTR _TempType$[ebp+eax]
  00426	81 e1 0f 00 00
	80		 and	 ecx, -2147483633	; 8000000fH
  0042c	79 05		 jns	 SHORT $LN61@gObjMakePr
  0042e	49		 dec	 ecx
  0042f	83 c9 f0	 or	 ecx, -16		; fffffff0H
  00432	41		 inc	 ecx
$LN61@gObjMakePr:
  00433	c1 e1 04	 shl	 ecx, 4
  00436	ba 02 00 00 00	 mov	 edx, 2
  0043b	6b c2 05	 imul	 eax, edx, 5
  0043e	0f bf 54 05 e0	 movsx	 edx, WORD PTR _TempType$[ebp+eax]
  00443	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  00449	79 05		 jns	 SHORT $LN62@gObjMakePr
  0044b	4a		 dec	 edx
  0044c	83 ca f0	 or	 edx, -16		; fffffff0H
  0044f	42		 inc	 edx
$LN62@gObjMakePr:
  00450	03 ca		 add	 ecx, edx
  00452	b8 01 00 00 00	 mov	 eax, 1
  00457	c1 e0 02	 shl	 eax, 2
  0045a	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0045d	88 8c 02 28 03
	00 00		 mov	 BYTE PTR [edx+eax+808], cl

; 19810: 	index             = ((TempType[6]%16)<<4);

  00464	b8 02 00 00 00	 mov	 eax, 2
  00469	6b c8 06	 imul	 ecx, eax, 6
  0046c	0f bf 54 0d e0	 movsx	 edx, WORD PTR _TempType$[ebp+ecx]
  00471	81 e2 0f 00 00
	80		 and	 edx, -2147483633	; 8000000fH
  00477	79 05		 jns	 SHORT $LN63@gObjMakePr
  00479	4a		 dec	 edx
  0047a	83 ca f0	 or	 edx, -16		; fffffff0H
  0047d	42		 inc	 edx
$LN63@gObjMakePr:
  0047e	c1 e2 04	 shl	 edx, 4
  00481	88 55 fb	 mov	 BYTE PTR _index$[ebp], dl

; 19811: #endif
; 19812: 	
; 19813: 	//   2
; 19814: 	if( lpObj->pInventory[7].m_Type < 0 ) index |= 0x0C;

  00484	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00489	6b c8 07	 imul	 ecx, eax, 7
  0048c	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0048f	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00495	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  0049a	85 c9		 test	 ecx, ecx
  0049c	7d 0c		 jge	 SHORT $LN16@gObjMakePr
  0049e	0f b6 45 fb	 movzx	 eax, BYTE PTR _index$[ebp]
  004a2	83 c8 0c	 or	 eax, 12			; 0000000cH
  004a5	88 45 fb	 mov	 BYTE PTR _index$[ebp], al
  004a8	eb 25		 jmp	 SHORT $LN17@gObjMakePr
$LN16@gObjMakePr:

; 19815: 	else index |=(lpObj->pInventory[7].m_Type&0x03)<<2;

  004aa	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  004af	6b c8 07	 imul	 ecx, eax, 7
  004b2	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004b5	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  004bb	0f bf 4c 08 06	 movsx	 ecx, WORD PTR [eax+ecx+6]
  004c0	83 e1 03	 and	 ecx, 3
  004c3	c1 e1 02	 shl	 ecx, 2
  004c6	0f b6 55 fb	 movzx	 edx, BYTE PTR _index$[ebp]
  004ca	0b d1		 or	 edx, ecx
  004cc	88 55 fb	 mov	 BYTE PTR _index$[ebp], dl
$LN17@gObjMakePr:

; 19816: 
; 19817: 
; 19818: #ifdef DARKLORD_WORK
; 19819: 	if( lpObj->pInventory[8].m_Type != MAKE_ITEMNUM(13,4) )

  004cf	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  004d4	c1 e0 03	 shl	 eax, 3
  004d7	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004da	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  004e0	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  004e5	6a 04		 push	 4
  004e7	6a 0d		 push	 13			; 0000000dH
  004e9	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  004ee	83 c4 08	 add	 esp, 8
  004f1	3b f0		 cmp	 esi, eax
  004f3	74 4a		 je	 SHORT $LN18@gObjMakePr

; 19820: 	{	//  
; 19821: 		if( lpObj->pInventory[8].m_Type < 0 )

  004f5	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  004fa	c1 e0 03	 shl	 eax, 3
  004fd	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00500	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00506	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  0050b	85 c0		 test	 eax, eax
  0050d	7d 0c		 jge	 SHORT $LN20@gObjMakePr

; 19822: 		{
; 19823: 			index |= 0x03;

  0050f	0f b6 45 fb	 movzx	 eax, BYTE PTR _index$[ebp]
  00513	83 c8 03	 or	 eax, 3
  00516	88 45 fb	 mov	 BYTE PTR _index$[ebp], al

; 19824: 		}

  00519	eb 22		 jmp	 SHORT $LN21@gObjMakePr
$LN20@gObjMakePr:

; 19825: //------------->
; 19826: //20080930    (grooving)
; 19827: #ifdef ADD_XMASEVENT_PET_20080930
; 19828: 		else if( lpObj->pInventory[EQUIPMENT_HELPER].m_Type != MAKE_ITEMNUM( 13, 67 ) )//grooving
; 19829: 		{
; 19830: 			index |=(lpObj->pInventory[8].m_Type&0x03);
; 19831: 		}
; 19832: #else //ADD_XMASEVENT_PET_20080930
; 19833: 		else
; 19834: 		{
; 19835: 			index |=(lpObj->pInventory[8].m_Type&0x03);

  0051b	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00520	c1 e0 03	 shl	 eax, 3
  00523	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00526	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0052c	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  00531	83 e0 03	 and	 eax, 3
  00534	0f b6 4d fb	 movzx	 ecx, BYTE PTR _index$[ebp]
  00538	0b c8		 or	 ecx, eax
  0053a	88 4d fb	 mov	 BYTE PTR _index$[ebp], cl
$LN21@gObjMakePr:

; 19836: 		}
; 19837: #endif //ADD_XMASEVENT_PET_20080930
; 19838: //<-------------
; 19839: 	}	

  0053d	eb 0a		 jmp	 SHORT $LN19@gObjMakePr
$LN18@gObjMakePr:

; 19840: 	else
; 19841: 	{
; 19842: 		index |= 0x03;

  0053f	0f b6 45 fb	 movzx	 eax, BYTE PTR _index$[ebp]
  00543	83 c8 03	 or	 eax, 3
  00546	88 45 fb	 mov	 BYTE PTR _index$[ebp], al
$LN19@gObjMakePr:

; 19843: 	}
; 19844: #else
; 19845: 	if( lpObj->pInventory[8].m_Type < 0 ) index |= 0x03;
; 19846: 	else index |=(lpObj->pInventory[8].m_Type&0x03);
; 19847: #endif	
; 19848: 
; 19849: #ifdef ITEM_INDEX_EXTEND_20050706
; 19850: 	lpObj->CharSet[5] |= index;
; 19851: #else
; 19852: 	lpObj->CharSet[5] = index;

  00549	b8 01 00 00 00	 mov	 eax, 1
  0054e	6b c8 05	 imul	 ecx, eax, 5
  00551	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00554	8a 45 fb	 mov	 al, BYTE PTR _index$[ebp]
  00557	88 84 0a 28 03
	00 00		 mov	 BYTE PTR [edx+ecx+808], al

; 19853: #endif
; 19854: 	
; 19855: 	int levelindex;
; 19856: 
; 19857: 	levelindex  = ((int)LevelSmallConvert(aIndex, 0));

  0055e	6a 00		 push	 0
  00560	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00563	50		 push	 eax
  00564	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  00569	83 c4 08	 add	 esp, 8
  0056c	0f b6 c8	 movzx	 ecx, al
  0056f	89 4d dc	 mov	 DWORD PTR _levelindex$[ebp], ecx

; 19858: 	levelindex |= ((int)LevelSmallConvert(aIndex, 1)<<3);

  00572	6a 01		 push	 1
  00574	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00577	50		 push	 eax
  00578	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  0057d	83 c4 08	 add	 esp, 8
  00580	0f b6 c8	 movzx	 ecx, al
  00583	c1 e1 03	 shl	 ecx, 3
  00586	0b 4d dc	 or	 ecx, DWORD PTR _levelindex$[ebp]
  00589	89 4d dc	 mov	 DWORD PTR _levelindex$[ebp], ecx

; 19859: 	levelindex |= ((int)LevelSmallConvert(aIndex, 2)<<6);

  0058c	6a 02		 push	 2
  0058e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00591	50		 push	 eax
  00592	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  00597	83 c4 08	 add	 esp, 8
  0059a	0f b6 c8	 movzx	 ecx, al
  0059d	c1 e1 06	 shl	 ecx, 6
  005a0	0b 4d dc	 or	 ecx, DWORD PTR _levelindex$[ebp]
  005a3	89 4d dc	 mov	 DWORD PTR _levelindex$[ebp], ecx

; 19860: 	levelindex |= ((int)LevelSmallConvert(aIndex, 3)<<9);

  005a6	6a 03		 push	 3
  005a8	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  005ab	50		 push	 eax
  005ac	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  005b1	83 c4 08	 add	 esp, 8
  005b4	0f b6 c8	 movzx	 ecx, al
  005b7	c1 e1 09	 shl	 ecx, 9
  005ba	0b 4d dc	 or	 ecx, DWORD PTR _levelindex$[ebp]
  005bd	89 4d dc	 mov	 DWORD PTR _levelindex$[ebp], ecx

; 19861: 	levelindex |= ((int)LevelSmallConvert(aIndex, 4)<<12);

  005c0	6a 04		 push	 4
  005c2	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  005c5	50		 push	 eax
  005c6	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  005cb	83 c4 08	 add	 esp, 8
  005ce	0f b6 c8	 movzx	 ecx, al
  005d1	c1 e1 0c	 shl	 ecx, 12			; 0000000cH
  005d4	0b 4d dc	 or	 ecx, DWORD PTR _levelindex$[ebp]
  005d7	89 4d dc	 mov	 DWORD PTR _levelindex$[ebp], ecx

; 19862: 	levelindex |= ((int)LevelSmallConvert(aIndex, 5)<<15);

  005da	6a 05		 push	 5
  005dc	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  005df	50		 push	 eax
  005e0	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  005e5	83 c4 08	 add	 esp, 8
  005e8	0f b6 c8	 movzx	 ecx, al
  005eb	c1 e1 0f	 shl	 ecx, 15			; 0000000fH
  005ee	0b 4d dc	 or	 ecx, DWORD PTR _levelindex$[ebp]
  005f1	89 4d dc	 mov	 DWORD PTR _levelindex$[ebp], ecx

; 19863: 	levelindex |= ((int)LevelSmallConvert(aIndex, 6)<<18);

  005f4	6a 06		 push	 6
  005f6	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  005f9	50		 push	 eax
  005fa	e8 00 00 00 00	 call	 ?LevelSmallConvert@@YAEHH@Z ; LevelSmallConvert
  005ff	83 c4 08	 add	 esp, 8
  00602	0f b6 c8	 movzx	 ecx, al
  00605	c1 e1 12	 shl	 ecx, 18			; 00000012H
  00608	0b 4d dc	 or	 ecx, DWORD PTR _levelindex$[ebp]
  0060b	89 4d dc	 mov	 DWORD PTR _levelindex$[ebp], ecx

; 19864: 		
; 19865: 	lpObj->CharSet[6] = (BYTE)((levelindex>>16)&255);

  0060e	8b 45 dc	 mov	 eax, DWORD PTR _levelindex$[ebp]
  00611	c1 f8 10	 sar	 eax, 16			; 00000010H
  00614	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00619	b9 01 00 00 00	 mov	 ecx, 1
  0061e	6b d1 06	 imul	 edx, ecx, 6
  00621	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00624	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al

; 19866: 	lpObj->CharSet[7] = (BYTE)((levelindex>> 8)&255);

  0062b	8b 45 dc	 mov	 eax, DWORD PTR _levelindex$[ebp]
  0062e	c1 f8 08	 sar	 eax, 8
  00631	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00636	b9 01 00 00 00	 mov	 ecx, 1
  0063b	6b d1 07	 imul	 edx, ecx, 7
  0063e	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00641	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al

; 19867: 	lpObj->CharSet[8] = (BYTE)((levelindex    )&255);

  00648	8b 45 dc	 mov	 eax, DWORD PTR _levelindex$[ebp]
  0064b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00650	b9 01 00 00 00	 mov	 ecx, 1
  00655	c1 e1 03	 shl	 ecx, 3
  00658	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0065b	88 84 0a 28 03
	00 00		 mov	 BYTE PTR [edx+ecx+808], al

; 19868: 	 
; 19869: #ifndef ITEM_INDEX_EXTEND_20050706		//     
; 19870: 	lpObj->CharSet[9] = 0;

  00662	b8 01 00 00 00	 mov	 eax, 1
  00667	6b c8 09	 imul	 ecx, eax, 9
  0066a	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0066d	c6 84 0a 28 03
	00 00 00	 mov	 BYTE PTR [edx+ecx+808], 0

; 19871: 	if( TempType[2] > 15 ) lpObj->CharSet[9]  = 0x80;

  00675	b8 02 00 00 00	 mov	 eax, 2
  0067a	d1 e0		 shl	 eax, 1
  0067c	0f bf 4c 05 e0	 movsx	 ecx, WORD PTR _TempType$[ebp+eax]
  00681	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00684	7e 13		 jle	 SHORT $LN22@gObjMakePr
  00686	b8 01 00 00 00	 mov	 eax, 1
  0068b	6b c8 09	 imul	 ecx, eax, 9
  0068e	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00691	c6 84 0a 28 03
	00 00 80	 mov	 BYTE PTR [edx+ecx+808], 128 ; 00000080H
$LN22@gObjMakePr:

; 19872: 	if( TempType[3] > 15 ) lpObj->CharSet[9] |= 0x40;

  00699	b8 02 00 00 00	 mov	 eax, 2
  0069e	6b c8 03	 imul	 ecx, eax, 3
  006a1	0f bf 54 0d e0	 movsx	 edx, WORD PTR _TempType$[ebp+ecx]
  006a6	83 fa 0f	 cmp	 edx, 15			; 0000000fH
  006a9	7e 28		 jle	 SHORT $LN23@gObjMakePr
  006ab	b8 01 00 00 00	 mov	 eax, 1
  006b0	6b c8 09	 imul	 ecx, eax, 9
  006b3	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  006b6	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  006be	83 c8 40	 or	 eax, 64			; 00000040H
  006c1	b9 01 00 00 00	 mov	 ecx, 1
  006c6	6b d1 09	 imul	 edx, ecx, 9
  006c9	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  006cc	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN23@gObjMakePr:

; 19873: 	if( TempType[4] > 15 ) lpObj->CharSet[9] |= 0x20;

  006d3	b8 02 00 00 00	 mov	 eax, 2
  006d8	c1 e0 02	 shl	 eax, 2
  006db	0f bf 4c 05 e0	 movsx	 ecx, WORD PTR _TempType$[ebp+eax]
  006e0	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  006e3	7e 28		 jle	 SHORT $LN24@gObjMakePr
  006e5	b8 01 00 00 00	 mov	 eax, 1
  006ea	6b c8 09	 imul	 ecx, eax, 9
  006ed	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  006f0	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  006f8	83 c8 20	 or	 eax, 32			; 00000020H
  006fb	b9 01 00 00 00	 mov	 ecx, 1
  00700	6b d1 09	 imul	 edx, ecx, 9
  00703	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00706	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN24@gObjMakePr:

; 19874: 	if( TempType[5] > 15 ) lpObj->CharSet[9] |= 0x10;

  0070d	b8 02 00 00 00	 mov	 eax, 2
  00712	6b c8 05	 imul	 ecx, eax, 5
  00715	0f bf 54 0d e0	 movsx	 edx, WORD PTR _TempType$[ebp+ecx]
  0071a	83 fa 0f	 cmp	 edx, 15			; 0000000fH
  0071d	7e 28		 jle	 SHORT $LN25@gObjMakePr
  0071f	b8 01 00 00 00	 mov	 eax, 1
  00724	6b c8 09	 imul	 ecx, eax, 9
  00727	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0072a	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  00732	83 c8 10	 or	 eax, 16			; 00000010H
  00735	b9 01 00 00 00	 mov	 ecx, 1
  0073a	6b d1 09	 imul	 edx, ecx, 9
  0073d	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00740	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN25@gObjMakePr:

; 19875: 	if( TempType[6] > 15 ) lpObj->CharSet[9] |= 0x08;

  00747	b8 02 00 00 00	 mov	 eax, 2
  0074c	6b c8 06	 imul	 ecx, eax, 6
  0074f	0f bf 54 0d e0	 movsx	 edx, WORD PTR _TempType$[ebp+ecx]
  00754	83 fa 0f	 cmp	 edx, 15			; 0000000fH
  00757	7e 28		 jle	 SHORT $LN26@gObjMakePr
  00759	b8 01 00 00 00	 mov	 eax, 1
  0075e	6b c8 09	 imul	 ecx, eax, 9
  00761	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00764	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  0076c	83 c8 08	 or	 eax, 8
  0076f	b9 01 00 00 00	 mov	 ecx, 1
  00774	6b d1 09	 imul	 edx, ecx, 9
  00777	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0077a	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN26@gObjMakePr:

; 19876: #endif
; 19877: 
; 19878: #ifdef NEW_FORSKYLAND2
; 19879: 	// ....
; 19880: #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//  1,2  gObjMakePreviewCharSet   
; 19881: 	if( (lpObj->pInventory[7].m_Type >= MAKE_ITEMNUM(12,3) && lpObj->pInventory[7].m_Type <= MAKE_ITEMNUM(12,6)) ||
; 19882: 			lpObj->pInventory[7].m_Type == MAKE_ITEMNUM(13,30) 	//  
; 19883: 			|| lpObj->pInventory[7].m_Type == MAKE_ITEMNUM(12,41)	//   
; 19884: 			|| lpObj->pInventory[7].m_Type == MAKE_ITEMNUM(12,42)	//  
; 19885: 			)
; 19886: #else // ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 19887: 	#ifdef DARKLORD_WORK
; 19888: 		if( (lpObj->pInventory[7].m_Type >= MAKE_ITEMNUM(12,3) && lpObj->pInventory[7].m_Type <= MAKE_ITEMNUM(12,6)) ||

  00781	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00786	6b c8 07	 imul	 ecx, eax, 7
  00789	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0078c	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00792	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00797	6a 03		 push	 3
  00799	6a 0c		 push	 12			; 0000000cH
  0079b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  007a0	83 c4 08	 add	 esp, 8
  007a3	3b f0		 cmp	 esi, eax
  007a5	7c 26		 jl	 SHORT $LN29@gObjMakePr
  007a7	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  007ac	6b c8 07	 imul	 ecx, eax, 7
  007af	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  007b2	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  007b8	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  007bd	6a 06		 push	 6
  007bf	6a 0c		 push	 12			; 0000000cH
  007c1	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  007c6	83 c4 08	 add	 esp, 8
  007c9	3b f0		 cmp	 esi, eax
  007cb	7e 2a		 jle	 SHORT $LN28@gObjMakePr
$LN29@gObjMakePr:
  007cd	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  007d2	6b c8 07	 imul	 ecx, eax, 7
  007d5	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  007d8	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  007de	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  007e3	6a 1e		 push	 30			; 0000001eH
  007e5	6a 0d		 push	 13			; 0000000dH
  007e7	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  007ec	83 c4 08	 add	 esp, 8
  007ef	3b f0		 cmp	 esi, eax
  007f1	0f 85 bb 00 00
	00		 jne	 $LN27@gObjMakePr
$LN28@gObjMakePr:

; 19889: 			lpObj->pInventory[7].m_Type == MAKE_ITEMNUM(13,30) )	//  
; 19890: 	#else	//  (0x07         )
; 19891: 		if( lpObj->pInventory[7].m_Type >= MAKE_ITEMNUM(12,3) && lpObj->pInventory[7].m_Type <= MAKE_ITEMNUM(12,6))
; 19892: 	#endif	// #ifdef DARKLORD_WORK
; 19893: #endif	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 19894: 	{
; 19895: 		lpObj->CharSet[5] |= 0x0c;

  007f7	b8 01 00 00 00	 mov	 eax, 1
  007fc	6b c8 05	 imul	 ecx, eax, 5
  007ff	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00802	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  0080a	83 c8 0c	 or	 eax, 12			; 0000000cH
  0080d	b9 01 00 00 00	 mov	 ecx, 1
  00812	6b d1 05	 imul	 edx, ecx, 5
  00815	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00818	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al

; 19896: 
; 19897: #ifdef DARKLORD_WORK
; 19898: 		if( lpObj->pInventory[7].m_Type == MAKE_ITEMNUM(13,30) )

  0081f	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00824	6b c8 07	 imul	 ecx, eax, 7
  00827	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0082a	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  00830	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00835	6a 1e		 push	 30			; 0000001eH
  00837	6a 0d		 push	 13			; 0000000dH
  00839	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0083e	83 c4 08	 add	 esp, 8
  00841	3b f0		 cmp	 esi, eax
  00843	75 2a		 jne	 SHORT $LN30@gObjMakePr

; 19899: 			lpObj->CharSet[9] |= 0x05;

  00845	b8 01 00 00 00	 mov	 eax, 1
  0084a	6b c8 09	 imul	 ecx, eax, 9
  0084d	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00850	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  00858	83 c8 05	 or	 eax, 5
  0085b	b9 01 00 00 00	 mov	 ecx, 1
  00860	6b d1 09	 imul	 edx, ecx, 9
  00863	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00866	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
  0086d	eb 43		 jmp	 SHORT $LN27@gObjMakePr
$LN30@gObjMakePr:

; 19900: #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//  1,2  gObjMakePreviewCharSet   
; 19901: 		else if( lpObj->pInventory[7].m_Type == MAKE_ITEMNUM(12,41) )
; 19902: 		{
; 19903: 			lpObj->CharSet[9] |= 0x06;
; 19904: 		}
; 19905: 		else if( lpObj->pInventory[7].m_Type == MAKE_ITEMNUM(12,42) )
; 19906: 		{
; 19907: 			lpObj->CharSet[9] |= 0x07;
; 19908: 		}
; 19909: #endif	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 19910: 		else
; 19911: #endif
; 19912: 			lpObj->CharSet[9] |= ((lpObj->pInventory[7].m_Type-2)&0x7);

  0086f	b8 01 00 00 00	 mov	 eax, 1
  00874	6b c8 09	 imul	 ecx, eax, 9
  00877	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  0087c	6b c2 07	 imul	 eax, edx, 7
  0087f	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00882	8b 92 5c 0c 00
	00		 mov	 edx, DWORD PTR [edx+3164]
  00888	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  0088d	83 e8 02	 sub	 eax, 2
  00890	83 e0 07	 and	 eax, 7
  00893	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00896	0f b6 8c 0a 28
	03 00 00	 movzx	 ecx, BYTE PTR [edx+ecx+808]
  0089e	0b c8		 or	 ecx, eax
  008a0	ba 01 00 00 00	 mov	 edx, 1
  008a5	6b c2 09	 imul	 eax, edx, 9
  008a8	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008ab	88 8c 02 28 03
	00 00		 mov	 BYTE PTR [edx+eax+808], cl
$LN27@gObjMakePr:

; 19913: 	}
; 19914: #else
; 19915: 	#ifdef NEW_SKILL_FORSKYLAND
; 19916: 		// ...
; 19917: 		if( lpObj->pInventory[8].m_Type & 0x03 && lpObj->pInventory[8].m_Type > 0 )
; 19918: 		{
; 19919: 			lpObj->CharSet[9] |= (BYTE)0x04;
; 19920: 		}	
; 19921: 	#endif
; 19922: #endif
; 19923: 
; 19924: 	lpObj->CharSet[10] = 0;

  008b2	b8 01 00 00 00	 mov	 eax, 1
  008b7	6b c8 0a	 imul	 ecx, eax, 10
  008ba	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008bd	c6 84 0a 28 03
	00 00 00	 mov	 BYTE PTR [edx+ecx+808], 0

; 19925: 	if( lpObj->pInventory[EQUIPMENT_HELM  ].IsExtItem()) lpObj->CharSet[10] = 0x80;

  008c5	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  008ca	d1 e1		 shl	 ecx, 1
  008cc	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008cf	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  008d5	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  008da	85 c0		 test	 eax, eax
  008dc	74 13		 je	 SHORT $LN32@gObjMakePr
  008de	b8 01 00 00 00	 mov	 eax, 1
  008e3	6b c8 0a	 imul	 ecx, eax, 10
  008e6	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008e9	c6 84 0a 28 03
	00 00 80	 mov	 BYTE PTR [edx+ecx+808], 128 ; 00000080H
$LN32@gObjMakePr:

; 19926: 	if( lpObj->pInventory[EQUIPMENT_ARMOR ].IsExtItem()) lpObj->CharSet[10] |= 0x40;

  008f1	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  008f6	6b c8 03	 imul	 ecx, eax, 3
  008f9	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008fc	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00902	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  00907	85 c0		 test	 eax, eax
  00909	74 28		 je	 SHORT $LN33@gObjMakePr
  0090b	b8 01 00 00 00	 mov	 eax, 1
  00910	6b c8 0a	 imul	 ecx, eax, 10
  00913	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00916	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  0091e	83 c8 40	 or	 eax, 64			; 00000040H
  00921	b9 01 00 00 00	 mov	 ecx, 1
  00926	6b d1 0a	 imul	 edx, ecx, 10
  00929	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0092c	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN33@gObjMakePr:

; 19927: 	if( lpObj->pInventory[EQUIPMENT_PANTS ].IsExtItem()) lpObj->CharSet[10] |= 0x20;

  00933	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00938	c1 e1 02	 shl	 ecx, 2
  0093b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0093e	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00944	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  00949	85 c0		 test	 eax, eax
  0094b	74 28		 je	 SHORT $LN34@gObjMakePr
  0094d	b8 01 00 00 00	 mov	 eax, 1
  00952	6b c8 0a	 imul	 ecx, eax, 10
  00955	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00958	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  00960	83 c8 20	 or	 eax, 32			; 00000020H
  00963	b9 01 00 00 00	 mov	 ecx, 1
  00968	6b d1 0a	 imul	 edx, ecx, 10
  0096b	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0096e	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN34@gObjMakePr:

; 19928: 	if( lpObj->pInventory[EQUIPMENT_GLOVES].IsExtItem()) lpObj->CharSet[10] |= 0x10;

  00975	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0097a	6b c8 05	 imul	 ecx, eax, 5
  0097d	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00980	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00986	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  0098b	85 c0		 test	 eax, eax
  0098d	74 28		 je	 SHORT $LN35@gObjMakePr
  0098f	b8 01 00 00 00	 mov	 eax, 1
  00994	6b c8 0a	 imul	 ecx, eax, 10
  00997	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0099a	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  009a2	83 c8 10	 or	 eax, 16			; 00000010H
  009a5	b9 01 00 00 00	 mov	 ecx, 1
  009aa	6b d1 0a	 imul	 edx, ecx, 10
  009ad	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  009b0	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN35@gObjMakePr:

; 19929: 	if( lpObj->pInventory[EQUIPMENT_BOOTS ].IsExtItem()) lpObj->CharSet[10] |= 0x08;

  009b7	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  009bc	6b c8 06	 imul	 ecx, eax, 6
  009bf	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  009c2	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  009c8	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  009cd	85 c0		 test	 eax, eax
  009cf	74 28		 je	 SHORT $LN36@gObjMakePr
  009d1	b8 01 00 00 00	 mov	 eax, 1
  009d6	6b c8 0a	 imul	 ecx, eax, 10
  009d9	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  009dc	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  009e4	83 c8 08	 or	 eax, 8
  009e7	b9 01 00 00 00	 mov	 ecx, 1
  009ec	6b d1 0a	 imul	 edx, ecx, 10
  009ef	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  009f2	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN36@gObjMakePr:

; 19930: 	if( lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].IsExtItem()) lpObj->CharSet[10] |= 0x04;

  009f9	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  009fe	6b c8 00	 imul	 ecx, eax, 0
  00a01	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a04	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00a0a	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  00a0f	85 c0		 test	 eax, eax
  00a11	74 28		 je	 SHORT $LN37@gObjMakePr
  00a13	b8 01 00 00 00	 mov	 eax, 1
  00a18	6b c8 0a	 imul	 ecx, eax, 10
  00a1b	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a1e	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  00a26	83 c8 04	 or	 eax, 4
  00a29	b9 01 00 00 00	 mov	 ecx, 1
  00a2e	6b d1 0a	 imul	 edx, ecx, 10
  00a31	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a34	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN37@gObjMakePr:

; 19931: 	if( lpObj->pInventory[EQUIPMENT_WEAPON_LEFT ].IsExtItem()) lpObj->CharSet[10] |= 0x02;

  00a3b	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00a40	c1 e1 00	 shl	 ecx, 0
  00a43	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a46	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00a4c	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  00a51	85 c0		 test	 eax, eax
  00a53	74 28		 je	 SHORT $LN38@gObjMakePr
  00a55	b8 01 00 00 00	 mov	 eax, 1
  00a5a	6b c8 0a	 imul	 ecx, eax, 10
  00a5d	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a60	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  00a68	83 c8 02	 or	 eax, 2
  00a6b	b9 01 00 00 00	 mov	 ecx, 1
  00a70	6b d1 0a	 imul	 edx, ecx, 10
  00a73	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a76	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN38@gObjMakePr:

; 19932: 
; 19933: 	lpObj->CharSet[11] = 0;

  00a7d	b8 01 00 00 00	 mov	 eax, 1
  00a82	6b c8 0b	 imul	 ecx, eax, 11
  00a85	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a88	c6 84 0a 28 03
	00 00 00	 mov	 BYTE PTR [edx+ecx+808], 0

; 19934: 	if( lpObj->pInventory[EQUIPMENT_HELM  ].IsSetItem()) lpObj->CharSet[11] = 0x80;

  00a90	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00a95	d1 e1		 shl	 ecx, 1
  00a97	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a9a	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00aa0	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00aa5	85 c0		 test	 eax, eax
  00aa7	74 13		 je	 SHORT $LN39@gObjMakePr
  00aa9	b8 01 00 00 00	 mov	 eax, 1
  00aae	6b c8 0b	 imul	 ecx, eax, 11
  00ab1	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ab4	c6 84 0a 28 03
	00 00 80	 mov	 BYTE PTR [edx+ecx+808], 128 ; 00000080H
$LN39@gObjMakePr:

; 19935: 	if( lpObj->pInventory[EQUIPMENT_ARMOR ].IsSetItem()) lpObj->CharSet[11] |= 0x40;

  00abc	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00ac1	6b c8 03	 imul	 ecx, eax, 3
  00ac4	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ac7	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00acd	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00ad2	85 c0		 test	 eax, eax
  00ad4	74 28		 je	 SHORT $LN40@gObjMakePr
  00ad6	b8 01 00 00 00	 mov	 eax, 1
  00adb	6b c8 0b	 imul	 ecx, eax, 11
  00ade	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ae1	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  00ae9	83 c8 40	 or	 eax, 64			; 00000040H
  00aec	b9 01 00 00 00	 mov	 ecx, 1
  00af1	6b d1 0b	 imul	 edx, ecx, 11
  00af4	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00af7	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN40@gObjMakePr:

; 19936: 	if( lpObj->pInventory[EQUIPMENT_PANTS ].IsSetItem()) lpObj->CharSet[11] |= 0x20;

  00afe	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00b03	c1 e1 02	 shl	 ecx, 2
  00b06	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b09	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00b0f	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00b14	85 c0		 test	 eax, eax
  00b16	74 28		 je	 SHORT $LN41@gObjMakePr
  00b18	b8 01 00 00 00	 mov	 eax, 1
  00b1d	6b c8 0b	 imul	 ecx, eax, 11
  00b20	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b23	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  00b2b	83 c8 20	 or	 eax, 32			; 00000020H
  00b2e	b9 01 00 00 00	 mov	 ecx, 1
  00b33	6b d1 0b	 imul	 edx, ecx, 11
  00b36	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b39	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN41@gObjMakePr:

; 19937: 	if( lpObj->pInventory[EQUIPMENT_GLOVES].IsSetItem()) lpObj->CharSet[11] |= 0x10;

  00b40	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00b45	6b c8 05	 imul	 ecx, eax, 5
  00b48	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b4b	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00b51	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00b56	85 c0		 test	 eax, eax
  00b58	74 28		 je	 SHORT $LN42@gObjMakePr
  00b5a	b8 01 00 00 00	 mov	 eax, 1
  00b5f	6b c8 0b	 imul	 ecx, eax, 11
  00b62	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b65	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  00b6d	83 c8 10	 or	 eax, 16			; 00000010H
  00b70	b9 01 00 00 00	 mov	 ecx, 1
  00b75	6b d1 0b	 imul	 edx, ecx, 11
  00b78	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b7b	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN42@gObjMakePr:

; 19938: 	if( lpObj->pInventory[EQUIPMENT_BOOTS ].IsSetItem()) lpObj->CharSet[11] |= 0x08;

  00b82	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00b87	6b c8 06	 imul	 ecx, eax, 6
  00b8a	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b8d	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00b93	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00b98	85 c0		 test	 eax, eax
  00b9a	74 28		 je	 SHORT $LN43@gObjMakePr
  00b9c	b8 01 00 00 00	 mov	 eax, 1
  00ba1	6b c8 0b	 imul	 ecx, eax, 11
  00ba4	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ba7	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  00baf	83 c8 08	 or	 eax, 8
  00bb2	b9 01 00 00 00	 mov	 ecx, 1
  00bb7	6b d1 0b	 imul	 edx, ecx, 11
  00bba	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bbd	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN43@gObjMakePr:

; 19939: 	if( lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].IsSetItem()) lpObj->CharSet[11] |= 0x04;

  00bc4	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00bc9	6b c8 00	 imul	 ecx, eax, 0
  00bcc	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00bcf	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00bd5	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00bda	85 c0		 test	 eax, eax
  00bdc	74 28		 je	 SHORT $LN44@gObjMakePr
  00bde	b8 01 00 00 00	 mov	 eax, 1
  00be3	6b c8 0b	 imul	 ecx, eax, 11
  00be6	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00be9	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  00bf1	83 c8 04	 or	 eax, 4
  00bf4	b9 01 00 00 00	 mov	 ecx, 1
  00bf9	6b d1 0b	 imul	 edx, ecx, 11
  00bfc	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bff	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN44@gObjMakePr:

; 19940: 	if( lpObj->pInventory[EQUIPMENT_WEAPON_LEFT ].IsSetItem()) lpObj->CharSet[11] |= 0x02;

  00c06	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  00c0b	c1 e1 00	 shl	 ecx, 0
  00c0e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c11	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00c17	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00c1c	85 c0		 test	 eax, eax
  00c1e	74 28		 je	 SHORT $LN45@gObjMakePr
  00c20	b8 01 00 00 00	 mov	 eax, 1
  00c25	6b c8 0b	 imul	 ecx, eax, 11
  00c28	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c2b	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  00c33	83 c8 02	 or	 eax, 2
  00c36	b9 01 00 00 00	 mov	 ecx, 1
  00c3b	6b d1 0b	 imul	 edx, ecx, 11
  00c3e	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c41	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN45@gObjMakePr:

; 19941: 
; 19942: 	gObjCalCharacter(aIndex);

  00c48	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00c4b	50		 push	 eax
  00c4c	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00c51	83 c4 04	 add	 esp, 4

; 19943: 
; 19944: 	if( lpObj->IsFullSetItem )

  00c54	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c57	0f b6 88 4e 0f
	00 00		 movzx	 ecx, BYTE PTR [eax+3918]
  00c5e	85 c9		 test	 ecx, ecx
  00c60	74 28		 je	 SHORT $LN46@gObjMakePr

; 19945: 	{	// 
; 19946: 		lpObj->CharSet[11] |= (BYTE)0x01;

  00c62	b8 01 00 00 00	 mov	 eax, 1
  00c67	6b c8 0b	 imul	 ecx, eax, 11
  00c6a	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c6d	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  00c75	83 c8 01	 or	 eax, 1
  00c78	b9 01 00 00 00	 mov	 ecx, 1
  00c7d	6b d1 0b	 imul	 edx, ecx, 11
  00c80	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c83	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN46@gObjMakePr:

; 19947: 	}
; 19948: 
; 19949: #ifdef NEW_FORSKYLAND2
; 19950: 	// ...
; 19951: 	if( lpObj->pInventory[8].m_Type & 0x03 && lpObj->pInventory[8].m_Type > 0 )

  00c8a	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00c8f	c1 e0 03	 shl	 eax, 3
  00c92	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c95	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00c9b	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  00ca0	83 e0 03	 and	 eax, 3
  00ca3	74 42		 je	 SHORT $LN47@gObjMakePr
  00ca5	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00caa	c1 e0 03	 shl	 eax, 3
  00cad	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00cb0	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00cb6	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  00cbb	85 c0		 test	 eax, eax
  00cbd	7e 28		 jle	 SHORT $LN47@gObjMakePr

; 19952: 	{
; 19953: 		lpObj->CharSet[10] |= (BYTE)0x01;

  00cbf	b8 01 00 00 00	 mov	 eax, 1
  00cc4	6b c8 0a	 imul	 ecx, eax, 10
  00cc7	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00cca	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  00cd2	83 c8 01	 or	 eax, 1
  00cd5	b9 01 00 00 00	 mov	 ecx, 1
  00cda	6b d1 0a	 imul	 edx, ecx, 10
  00cdd	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00ce0	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN47@gObjMakePr:

; 19954: 	}
; 19955: #endif
; 19956: 
; 19957: #ifdef DARKLORD_WORK
; 19958: #ifndef ITEM_INDEX_EXTEND_20050706
; 19959: 	lpObj->CharSet[12] = 0;

  00ce7	b8 01 00 00 00	 mov	 eax, 1
  00cec	6b c8 0c	 imul	 ecx, eax, 12
  00cef	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00cf2	c6 84 0a 28 03
	00 00 00	 mov	 BYTE PTR [edx+ecx+808], 0

; 19960: #endif	
; 19961: 	if( lpObj->pInventory[8].m_Type == MAKE_ITEMNUM(13,4) )

  00cfa	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00cff	c1 e0 03	 shl	 eax, 3
  00d02	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d05	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00d0b	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  00d10	6a 04		 push	 4
  00d12	6a 0d		 push	 13			; 0000000dH
  00d14	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00d19	83 c4 08	 add	 esp, 8
  00d1c	3b f0		 cmp	 esi, eax
  00d1e	75 28		 jne	 SHORT $LN1@gObjMakePr

; 19962: 	{	// 
; 19963: 		lpObj->CharSet[12] |= (BYTE)0x01;

  00d20	b8 01 00 00 00	 mov	 eax, 1
  00d25	6b c8 0c	 imul	 ecx, eax, 12
  00d28	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00d2b	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  00d33	83 c8 01	 or	 eax, 1
  00d36	b9 01 00 00 00	 mov	 ecx, 1
  00d3b	6b d1 0c	 imul	 edx, ecx, 12
  00d3e	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d41	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al
$LN1@gObjMakePr:

; 19964: 	}
; 19965: #endif
; 19966: 
; 19967: #ifdef MU_CHN_THANKS_RING_EVENT_20040908	//   -   
; 19968: //	lpObj->CharSet[12] = 0;
; 19969: 	if( (
; 19970: 		lpObj->pInventory[EQUIPMENT_RING_RIGHT].IsItem() == TRUE &&
; 19971: 		lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Type == MAKE_ITEMNUM(13,20) &&
; 19972: 		lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Level == 3 &&
; 19973: 		lpObj->pInventory[EQUIPMENT_RING_RIGHT].m_Durability > 0.f
; 19974: 		) ||
; 19975: 		(
; 19976: 		lpObj->pInventory[EQUIPMENT_RING_LEFT].IsItem() == TRUE &&
; 19977: 		lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Type == MAKE_ITEMNUM(13,20) &&
; 19978: 		lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Level == 3 &&
; 19979: 		lpObj->pInventory[EQUIPMENT_RING_LEFT].m_Durability > 0.f
; 19980: 		) )
; 19981: 	{	
; 19982: 		//        
; 19983: 		lpObj->CharSet[12] |= (BYTE)0x02;
; 19984: 	}
; 19985: #endif
; 19986: 
; 19987: #ifdef ADD_ITEM_FENRIR_01_20051110
; 19988: 	// HELPER  
; 19989: 	if( lpObj->pInventory[8].m_Type == MAKE_ITEMNUM(13,37) )
; 19990: 	{
; 19991: 		lpObj->CharSet[10] &= ~ (BYTE)0x01; //  
; 19992: 		lpObj->CharSet[12] &= ~ (BYTE)0x01; //  
; 19993: 		lpObj->CharSet[12] |=   (BYTE)0x04; // 
; 19994: 
; 19995: 		//   
; 19996: 		// CharSet[16], CharSet[17] 
; 19997: 		// CharSet[16] .
; 19998: 
; 19999: 		lpObj->CharSet[16] = 0;
; 20000: 		lpObj->CharSet[17] = 0;
; 20001: 
; 20002: 		if( lpObj->pInventory[8].IsFenrirIncLastAttackDamage() )
; 20003: 		{
; 20004: 			lpObj->CharSet[16] |= (BYTE)0x01;	//  -   
; 20005: 		}
; 20006: 
; 20007: 		if( lpObj->pInventory[8].IsFenrirDecLastAttackDamage() )
; 20008: 		{
; 20009: 			lpObj->CharSet[16] |= (BYTE)0x02;	//  -   
; 20010: 		}
; 20011: 		
; 20012: #ifdef ADD_ILLUSION_FENRIR_20070703	// (CharSet[17] 2 Bit)
; 20013: 		if( lpObj->pInventory[8].IsIllusionFenrirOption() )
; 20014: 		{
; 20015: 			lpObj->CharSet[17] |= (BYTE)0x01;	//  
; 20016: 		}
; 20017: #endif
; 20018: 	}	
; 20019: #endif // ADD_ITEM_FENRIR_01_20051110
; 20020: 
; 20021: 	// 3 
; 20022: #ifdef ADD_THIRD_WING_20070525	// gObjMakePreviewCharSet 3 
; 20023: #ifdef ADD_SUMMONER_SECOND_THIRD_WING_20071130 // gObjMakePreviewCharSet  
; 20024: 	if(( lpObj->pInventory[7].m_Type >= MAKE_ITEMNUM( 12, 36 ) && lpObj->pInventory[7].m_Type <= MAKE_ITEMNUM( 12, 40 ) )
; 20025: 		|| lpObj->pInventory[7].m_Type == MAKE_ITEMNUM( 12, 43 ) )
; 20026: #else
; 20027: 	if( lpObj->pInventory[7].m_Type >= MAKE_ITEMNUM( 12, 36 ) && lpObj->pInventory[7].m_Type <= MAKE_ITEMNUM( 12, 40 ) )
; 20028: #endif
; 20029: 	{
; 20030: 		lpObj->CharSet[5] |= 0x0C;	// 1  
; 20031: 		lpObj->CharSet[16] |= ( (( lpObj->pInventory[7].m_Type - 35 )&0x7 ) << 2 );
; 20032: 	#ifdef MODIFY_SUMMONER_THIRD_WING_BUFGIX_20090109	//   0x06 
; 20033: 		if(lpObj->pInventory[7].m_Type == MAKE_ITEMNUM( 12, 43 ) )
; 20034: 		{
; 20035: 		lpObj->CharSet[16] |= ( (( 0x06 )&0x7 ) << 2 );
; 20036: 		}
; 20037: 	#endif	// MODIFY_SUMMONER_THIRD_WING_BUFGIX_20090109
; 20038: 	}
; 20039: #endif // ADD_THIRD_WING_20070525
; 20040: 
; 20041: #ifdef ADD_SAFEGUARD_ITEM_20080702
; 20042: 	{
; 20043: 		BYTE btItemIndex = 0;
; 20044: 		switch(lpObj->pInventory[EQUIPMENT_HELPER].m_Type)
; 20045: 		{
; 20046: 		case MAKE_ITEMNUM2( 13, 64 )://
; 20047: 			{
; 20048: 				btItemIndex = (BYTE)(0x01 << 5);
; 20049: 				break;
; 20050: 			}
; 20051: 		case MAKE_ITEMNUM2( 13, 65 )://
; 20052: 			{
; 20053: 				btItemIndex = (BYTE)(0x02 << 5);
; 20054: 				break;
; 20055: 			}
; 20056: //------------->
; 20057: //20080930    (grooving)
; 20058: #ifdef ADD_XMASEVENT_PET_20080930
; 20059: 		case MAKE_ITEMNUM2( 13, 67 )://
; 20060: 			{
; 20061: 				btItemIndex = (BYTE)(0x04 << 5);
; 20062: 				break;
; 20063: 			}
; 20064: #endif // ADD_XMASEVENT_PET_20080930
; 20065: //<-------------
; 20066: #ifdef ADD_UNICORN_PET_20090915
; 20067: 		case MAKE_ITEMNUM2( 13, 106 )://  
; 20068: 			{
; 20069: 				btItemIndex = (BYTE)(0x05 << 5);
; 20070: 				break;
; 20071: 			}
; 20072: #endif // ADD_UNICORN_PET_20090915
; 20073: #ifdef ADD_PREMIUMITEM_PANDA
; 20074: 		case MAKE_ITEMNUM2( 13, 80 ):// 
; 20075: 			{
; 20076: 				btItemIndex = (BYTE)(0x07 << 5);
; 20077: 				break;
; 20078: 			}
; 20079: #endif // ADD_PREMIUMITEM_PANDA
; 20080: 		}		
; 20081: 		lpObj->CharSet[16] |= btItemIndex;
; 20082: 	}
; 20083: #endif // ADD_SAFEGUARD_ITEM_20080702
; 20084: }

  00d48	5f		 pop	 edi
  00d49	5e		 pop	 esi
  00d4a	5b		 pop	 ebx
  00d4b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00d4e	33 cd		 xor	 ecx, ebp
  00d50	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00d55	8b e5		 mov	 esp, ebp
  00d57	5d		 pop	 ebp
  00d58	c3		 ret	 0
?gObjMakePreviewCharSet@@YAXH@Z ENDP			; gObjMakePreviewCharSet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryItemBoxSet@@YAXHHHHE@Z
_TEXT	SEGMENT
_x$1 = -24						; size = 4
_y$2 = -20						; size = 4
_yy$ = -16						; size = 4
_xx$ = -12						; size = 4
_itemposy$ = -8						; size = 4
_itemposx$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_itempos$ = 12						; size = 4
_xl$ = 16						; size = 4
_yl$ = 20						; size = 4
_set_byte$ = 24						; size = 1
?gObjInventoryItemBoxSet@@YAXHHHHE@Z PROC		; gObjInventoryItemBoxSet, COMDAT

; 14731: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14732: 	int itemposx, itemposy;
; 14733: 	int xx, yy;
; 14734: 
; 14735: 	itemposx = (itempos-MAX_EQUIPMENT)%8;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  0000c	83 e8 0c	 sub	 eax, 12			; 0000000cH
  0000f	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  00014	79 05		 jns	 SHORT $LN11@gObjInvent
  00016	48		 dec	 eax
  00017	83 c8 f8	 or	 eax, -8			; fffffff8H
  0001a	40		 inc	 eax
$LN11@gObjInvent:
  0001b	89 45 fc	 mov	 DWORD PTR _itemposx$[ebp], eax

; 14736: 	itemposy = (itempos-MAX_EQUIPMENT)/8;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  00021	83 e8 0c	 sub	 eax, 12			; 0000000cH
  00024	99		 cdq
  00025	83 e2 07	 and	 edx, 7
  00028	03 c2		 add	 eax, edx
  0002a	c1 f8 03	 sar	 eax, 3
  0002d	89 45 f8	 mov	 DWORD PTR _itemposy$[ebp], eax

; 14737: 
; 14738: 	for( int y=0; y<yl; y++)

  00030	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _y$2[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@gObjInvent
$LN2@gObjInvent:
  00039	8b 45 ec	 mov	 eax, DWORD PTR _y$2[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 ec	 mov	 DWORD PTR _y$2[ebp], eax
$LN4@gObjInvent:
  00042	8b 45 ec	 mov	 eax, DWORD PTR _y$2[ebp]
  00045	3b 45 14	 cmp	 eax, DWORD PTR _yl$[ebp]
  00048	0f 8d 95 00 00
	00		 jge	 $LN1@gObjInvent

; 14739: 	{
; 14740: 		yy = itemposy+y;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _itemposy$[ebp]
  00051	03 45 ec	 add	 eax, DWORD PTR _y$2[ebp]
  00054	89 45 f0	 mov	 DWORD PTR _yy$[ebp], eax

; 14741: 		for( int x=0; x<xl; x++)

  00057	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _x$1[ebp], 0
  0005e	eb 09		 jmp	 SHORT $LN7@gObjInvent
$LN5@gObjInvent:
  00060	8b 45 e8	 mov	 eax, DWORD PTR _x$1[ebp]
  00063	83 c0 01	 add	 eax, 1
  00066	89 45 e8	 mov	 DWORD PTR _x$1[ebp], eax
$LN7@gObjInvent:
  00069	8b 45 e8	 mov	 eax, DWORD PTR _x$1[ebp]
  0006c	3b 45 10	 cmp	 eax, DWORD PTR _xl$[ebp]
  0006f	7d 6d		 jge	 SHORT $LN6@gObjInvent

; 14742: 		{
; 14743: 			xx = itemposx+x;

  00071	8b 45 fc	 mov	 eax, DWORD PTR _itemposx$[ebp]
  00074	03 45 e8	 add	 eax, DWORD PTR _x$1[ebp]
  00077	89 45 f4	 mov	 DWORD PTR _xx$[ebp], eax

; 14744: #ifdef PERSONAL_SHOP_20040113		
; 14745: 			if( ExtentCheck(xx, yy, 8, 12) == TRUE )

  0007a	6a 0c		 push	 12			; 0000000cH
  0007c	6a 08		 push	 8
  0007e	8b 45 f0	 mov	 eax, DWORD PTR _yy$[ebp]
  00081	50		 push	 eax
  00082	8b 4d f4	 mov	 ecx, DWORD PTR _xx$[ebp]
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  0008b	83 c4 10	 add	 esp, 16			; 00000010H
  0008e	83 f8 01	 cmp	 eax, 1
  00091	75 2b		 jne	 SHORT $LN8@gObjInvent

; 14746: #else
; 14747: 			if( ExtentCheck(xx, yy, 8, 8) == TRUE )
; 14748: #endif
; 14749: 			{
; 14750: 				*(gObj[aIndex].pInventoryMap+((itemposy+y)*8)+(itemposx+x)) = set_byte;

  00093	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _itemposy$[ebp]
  0009d	03 4d ec	 add	 ecx, DWORD PTR _y$2[ebp]
  000a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a6	8b 84 02 60 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3168]
  000ad	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  000b0	8b 55 fc	 mov	 edx, DWORD PTR _itemposx$[ebp]
  000b3	03 55 e8	 add	 edx, DWORD PTR _x$1[ebp]
  000b6	8a 45 18	 mov	 al, BYTE PTR _set_byte$[ebp]
  000b9	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 14751: 			}

  000bc	eb 1e		 jmp	 SHORT $LN9@gObjInvent
$LN8@gObjInvent:

; 14752: 			else {
; 14753: 	
; 14754: 				LogAdd("error : %s %d",__FILE__, __LINE__);

  000be	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryItemBoxSet@@YAXHHHHE@Z@4JA
  000c3	83 c0 17	 add	 eax, 23			; 00000017H
  000c6	50		 push	 eax
  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14755: 				return;

  000da	eb 07		 jmp	 SHORT $LN1@gObjInvent
$LN9@gObjInvent:

; 14756: 			}
; 14757: 		}

  000dc	eb 82		 jmp	 SHORT $LN5@gObjInvent
$LN6@gObjInvent:

; 14758: 	}

  000de	e9 56 ff ff ff	 jmp	 $LN2@gObjInvent
$LN1@gObjInvent:

; 14759: }

  000e3	5f		 pop	 edi
  000e4	5e		 pop	 esi
  000e5	5b		 pop	 ebx
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
?gObjInventoryItemBoxSet@@YAXHHHHE@Z ENDP		; gObjInventoryItemBoxSet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryItemSet@@YAXHHE@Z
_TEXT	SEGMENT
_height$ = -8						; size = 4
_width$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_itempos$ = 12						; size = 4
_set_byte$ = 16						; size = 1
?gObjInventoryItemSet@@YAXHHE@Z PROC			; gObjInventoryItemSet, COMDAT

; 14711: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14712: 	if( itempos < MAX_EQUIPMENT ) return;

  00009	83 7d 0c 0c	 cmp	 DWORD PTR _itempos$[ebp], 12 ; 0000000cH
  0000d	7d 02		 jge	 SHORT $LN2@gObjInvent
  0000f	eb 7a		 jmp	 SHORT $LN1@gObjInvent
$LN2@gObjInvent:

; 14713: #ifdef PERSONAL_SHOP_20040113		
; 14714: 	if( itempos > MAX_INVENTORY_EXTEND-1 ) return;

  00011	83 7d 0c 6b	 cmp	 DWORD PTR _itempos$[ebp], 107 ; 0000006bH
  00015	7e 02		 jle	 SHORT $LN3@gObjInvent
  00017	eb 72		 jmp	 SHORT $LN1@gObjInvent
$LN3@gObjInvent:

; 14715: #else
; 14716: 	if( itempos > MAX_INVENTORY-1 ) return;
; 14717: #endif	
; 14718: 	
; 14719: 	int width, height;
; 14720: 
; 14721: 	if( gObj[aIndex].pInventory[itempos].GetSize( width, height ) == FALSE ) 

  00019	8d 45 f8	 lea	 eax, DWORD PTR _height$[ebp]
  0001c	50		 push	 eax
  0001d	8d 4d fc	 lea	 ecx, DWORD PTR _width$[ebp]
  00020	51		 push	 ecx
  00021	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00028	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _itempos$[ebp], 168
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00034	03 8c 10 5c 0c
	00 00		 add	 ecx, DWORD PTR [eax+edx+3164]
  0003b	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  00040	85 c0		 test	 eax, eax
  00042	75 2a		 jne	 SHORT $LN4@gObjInvent

; 14722: 	{
; 14723: 		LogAdd(lMsg.Get(527), __FILE__, __LINE__);

  00044	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryItemSet@@YAXHHE@Z@4JA
  00049	83 c0 0c	 add	 eax, 12			; 0000000cH
  0004c	50		 push	 eax
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00052	68 0f 02 00 00	 push	 527			; 0000020fH
  00057	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00062	50		 push	 eax
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14724: 		return;

  0006c	eb 1d		 jmp	 SHORT $LN1@gObjInvent
$LN4@gObjInvent:

; 14725: 	}
; 14726: 	gObjInventoryItemBoxSet(aIndex, itempos, width, height, set_byte);	

  0006e	0f b6 45 10	 movzx	 eax, BYTE PTR _set_byte$[ebp]
  00072	50		 push	 eax
  00073	8b 4d f8	 mov	 ecx, DWORD PTR _height$[ebp]
  00076	51		 push	 ecx
  00077	8b 55 fc	 mov	 edx, DWORD PTR _width$[ebp]
  0007a	52		 push	 edx
  0007b	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 ?gObjInventoryItemBoxSet@@YAXHHHHE@Z ; gObjInventoryItemBoxSet
  00088	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@gObjInvent:

; 14727: }

  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?gObjInventoryItemSet@@YAXHHE@Z ENDP			; gObjInventoryItemSet
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryDeleteItem@@YAEHH@Z
_TEXT	SEGMENT
_result$1 = -4						; size = 4
_aIndex$ = 8						; size = 4
_itempos$ = 12						; size = 4
?gObjInventoryDeleteItem@@YAEHH@Z PROC			; gObjInventoryDeleteItem, COMDAT

; 14884: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14885: 	//if( itempos ) .. ??
; 14886: 	
; 14887: 	//   ()   ..
; 14888: 	if( itempos < MAX_EQUIPMENT )

  00009	83 7d 0c 0c	 cmp	 DWORD PTR _itempos$[ebp], 12 ; 0000000cH
  0000d	0f 8d ec 00 00
	00		 jge	 $LN2@gObjInvent

; 14889: 	{
; 14890: 		int result = gObjMagicDel(&gObj[aIndex], gObj[aIndex].pInventory[itempos].m_Special[0], (BYTE)gObj[aIndex].pInventory[itempos].m_Level);

  00013	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0001a	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _itempos$[ebp], 168
  00021	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00027	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  0002e	0f b6 4c 08 08	 movzx	 ecx, BYTE PTR [eax+ecx+8]
  00033	51		 push	 ecx
  00034	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0003b	69 45 0c a8 00
	00 00		 imul	 eax, DWORD PTR _itempos$[ebp], 168
  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00048	8b 94 11 5c 0c
	00 00		 mov	 edx, DWORD PTR [ecx+edx+3164]
  0004f	03 d0		 add	 edx, eax
  00051	b8 01 00 00 00	 mov	 eax, 1
  00056	6b c8 00	 imul	 ecx, eax, 0
  00059	0f b6 54 0a 31	 movzx	 edx, BYTE PTR [edx+ecx+49]
  0005e	52		 push	 edx
  0005f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00066	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ?gObjMagicDel@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMagicDel
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	89 45 fc	 mov	 DWORD PTR _result$1[ebp], eax

; 14891: 		if( result >= 0 )

  00078	83 7d fc 00	 cmp	 DWORD PTR _result$1[ebp], 0
  0007c	7c 5f		 jl	 SHORT $LN4@gObjInvent

; 14892: 		{
; 14893: 			GCMagicListOneDelSend(aIndex, result, gObj[aIndex].pInventory[itempos].m_Special[0], (BYTE)gObj[aIndex].pInventory[itempos].m_Level, 0 );

  0007e	6a 00		 push	 0
  00080	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00087	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _itempos$[ebp], 168
  0008e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00094	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  0009b	0f b6 4c 08 08	 movzx	 ecx, BYTE PTR [eax+ecx+8]
  000a0	51		 push	 ecx
  000a1	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  000a8	69 45 0c a8 00
	00 00		 imul	 eax, DWORD PTR _itempos$[ebp], 168
  000af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b5	8b 94 11 5c 0c
	00 00		 mov	 edx, DWORD PTR [ecx+edx+3164]
  000bc	03 d0		 add	 edx, eax
  000be	b8 01 00 00 00	 mov	 eax, 1
  000c3	6b c8 00	 imul	 ecx, eax, 0
  000c6	0f b6 54 0a 31	 movzx	 edx, BYTE PTR [edx+ecx+49]
  000cb	52		 push	 edx
  000cc	0f b6 45 fc	 movzx	 eax, BYTE PTR _result$1[ebp]
  000d0	50		 push	 eax
  000d1	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 ?GCMagicListOneDelSend@@YAXHDEEE@Z ; GCMagicListOneDelSend
  000da	83 c4 14	 add	 esp, 20			; 00000014H
$LN4@gObjInvent:

; 14894: 		}
; 14895: 
; 14896: 		gObj[aIndex].pInventory[itempos].Clear();

  000dd	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e4	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _itempos$[ebp], 168
  000eb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f1	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  000f8	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 14897: 	}

  000fd	eb 35		 jmp	 SHORT $LN3@gObjInvent
$LN2@gObjInvent:

; 14898: 	else // .
; 14899: 	{
; 14900: 		//    .
; 14901: 		gObjInventoryItemSet(aIndex, itempos, 0xFF);

  000ff	68 ff 00 00 00	 push	 255			; 000000ffH
  00104	8b 45 0c	 mov	 eax, DWORD PTR _itempos$[ebp]
  00107	50		 push	 eax
  00108	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0010b	51		 push	 ecx
  0010c	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14902: 		gObj[aIndex].pInventory[itempos].Clear();

  00114	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0011b	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _itempos$[ebp], 168
  00122	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00128	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  0012f	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear
$LN3@gObjInvent:

; 14903: 	}
; 14904: 	return TRUE;

  00134	b0 01		 mov	 al, 1

; 14905: }

  00136	5f		 pop	 edi
  00137	5e		 pop	 esi
  00138	5b		 pop	 ebx
  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c3		 ret	 0
?gObjInventoryDeleteItem@@YAEHH@Z ENDP			; gObjInventoryDeleteItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHH@Z
_TEXT	SEGMENT
_item_type$ = -196					; size = 4
_blank$ = -189						; size = 1
_iheight$ = -188					; size = 4
_iwidth$ = -184						; size = 4
_h$ = -180						; size = 4
_w$ = -176						; size = 4
_item$ = -172						; size = 168
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_type$ = 12						; size = 4
_index$ = 16						; size = 4
_level$ = 20						; size = 4
_iSerial$ = 24						; size = 4
_iDur$ = 28						; size = 4
?gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHH@Z PROC ; gObjInventoryInsertItem, COMDAT

; 15506: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 15507: 	CItem item;

  00016	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 15508: 	int w, h;
; 15509: 	int iwidth, iheight;
; 15510: 	BYTE blank=0;

  00021	c6 85 43 ff ff
	ff 00		 mov	 BYTE PTR _blank$[ebp], 0

; 15511: 	int item_type;
; 15512: 
; 15513: 	//item_type = type<<4;
; 15514: 	//item_type += index;
; 15515: 	item_type    = ItemGetNumberMake(type, index );

  00028	8b 45 10	 mov	 eax, DWORD PTR _index$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR _type$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00035	83 c4 08	 add	 esp, 8
  00038	89 85 3c ff ff
	ff		 mov	 DWORD PTR _item_type$[ebp], eax

; 15516: 
; 15517: 	item.m_Level = level;

  0003e	66 8b 45 14	 mov	 ax, WORD PTR _level$[ebp]
  00042	66 89 85 5c ff
	ff ff		 mov	 WORD PTR _item$[ebp+8], ax

; 15518: 	item.m_Durability = iDur;

  00049	f3 0f 2a 45 1c	 cvtsi2ss xmm0, DWORD PTR _iDur$[ebp]
  0004e	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _item$[ebp+36], xmm0

; 15519: 	//item.Convert( item_type, 0);	
; 15520: 	item.Convert(item_type, 0, 0, 0, 0, 0, 0);

  00056	6a 00		 push	 0
  00058	6a 00		 push	 0
  0005a	6a 00		 push	 0
  0005c	6a 00		 push	 0
  0005e	6a 00		 push	 0
  00060	6a 00		 push	 0
  00062	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR _item_type$[ebp]
  00068	50		 push	 eax
  00069	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0006f	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 15521: 	
; 15522: 	if( item.GetSize(iwidth, iheight) == FALSE )

  00074	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _iheight$[ebp]
  0007a	50		 push	 eax
  0007b	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00081	51		 push	 ecx
  00082	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  00088	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  0008d	85 c0		 test	 eax, eax
  0008f	75 2f		 jne	 SHORT $LN8@gObjInvent

; 15523: 	{
; 15524: 		LogAdd(lMsg.Get(527), __FILE__, __LINE__);

  00091	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHH@Z@4JA
  00096	83 c0 12	 add	 eax, 18			; 00000012H
  00099	50		 push	 eax
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0009f	68 0f 02 00 00	 push	 527			; 0000020fH
  000a4	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000af	50		 push	 eax
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15525: 		return 0xFF;

  000b9	0c ff		 or	 al, 255			; 000000ffH
  000bb	e9 5e 01 00 00	 jmp	 $LN1@gObjInvent
$LN8@gObjInvent:

; 15526: 	}
; 15527: 
; 15528: 	for( h=0; h<8; h++)		

  000c0	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _h$[ebp], 0
  000ca	eb 0f		 jmp	 SHORT $LN4@gObjInvent
$LN2@gObjInvent:
  000cc	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _h$[ebp]
  000d2	83 c0 01	 add	 eax, 1
  000d5	89 85 4c ff ff
	ff		 mov	 DWORD PTR _h$[ebp], eax
$LN4@gObjInvent:
  000db	83 bd 4c ff ff
	ff 08		 cmp	 DWORD PTR _h$[ebp], 8
  000e2	0f 8d 34 01 00
	00		 jge	 $LN3@gObjInvent

; 15529: 	{		
; 15530: 		for( w=0; w<8; w++)

  000e8	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _w$[ebp], 0
  000f2	eb 0f		 jmp	 SHORT $LN7@gObjInvent
$LN5@gObjInvent:
  000f4	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _w$[ebp]
  000fa	83 c0 01	 add	 eax, 1
  000fd	89 85 50 ff ff
	ff		 mov	 DWORD PTR _w$[ebp], eax
$LN7@gObjInvent:
  00103	83 bd 50 ff ff
	ff 08		 cmp	 DWORD PTR _w$[ebp], 8
  0010a	0f 8d 07 01 00
	00		 jge	 $LN6@gObjInvent

; 15531: 		{
; 15532: 			//  
; 15533: 			if( *(lpObj->pInventoryMap+(h*8)+w) == 0xFF )

  00110	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00113	8b 88 60 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3168]
  00119	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _h$[ebp]
  0011f	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  00122	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _w$[ebp]
  00128	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  0012c	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00132	0f 85 da 00 00
	00		 jne	 $LN12@gObjInvent

; 15534: 			{				
; 15535: 				blank = gObjInventoryRectCheck(lpObj->m_Index, w, h, iwidth,iheight);

  00138	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _iheight$[ebp]
  0013e	50		 push	 eax
  0013f	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _iwidth$[ebp]
  00145	51		 push	 ecx
  00146	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _h$[ebp]
  0014c	52		 push	 edx
  0014d	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _w$[ebp]
  00153	50		 push	 eax
  00154	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00157	8b 11		 mov	 edx, DWORD PTR [ecx]
  00159	52		 push	 edx
  0015a	e8 00 00 00 00	 call	 ?gObjInventoryRectCheck@@YAEHHHHH@Z ; gObjInventoryRectCheck
  0015f	83 c4 14	 add	 esp, 20			; 00000014H
  00162	88 85 43 ff ff
	ff		 mov	 BYTE PTR _blank$[ebp], al

; 15536: 				// 
; 15537: 				if( blank == 0xFE ) goto GOTO_EndFunc;

  00168	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _blank$[ebp]
  0016f	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  00174	75 0a		 jne	 SHORT $LN10@gObjInvent
  00176	e9 a1 00 00 00	 jmp	 $LN11@gObjInvent
  0017b	e9 9c 00 00 00	 jmp	 $GOTO_EndFunc$14
$LN10@gObjInvent:

; 15538: 				if( blank != 0xFF )	{	//   

  00180	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _blank$[ebp]
  00187	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0018c	0f 84 80 00 00
	00		 je	 $LN12@gObjInvent

; 15539: 					lpObj->pInventory[blank] = item;

  00192	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _blank$[ebp]
  00199	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  0019f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001a2	8b ba 5c 0c 00
	00		 mov	 edi, DWORD PTR [edx+3164]
  001a8	03 f9		 add	 edi, ecx
  001aa	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  001af	8d b5 54 ff ff
	ff		 lea	 esi, DWORD PTR _item$[ebp]
  001b5	f3 a5		 rep movsd

; 15540: 					lpObj->pInventory[blank].m_Number = iSerial;

  001b7	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _blank$[ebp]
  001be	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  001c4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001c7	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  001cd	8b 55 18	 mov	 edx, DWORD PTR _iSerial$[ebp]
  001d0	89 14 08	 mov	 DWORD PTR [eax+ecx], edx

; 15541: 					gPlusItemNumber();

  001d3	e8 00 00 00 00	 call	 ?gPlusItemNumber@@YAXXZ	; gPlusItemNumber

; 15542: 					gObjInventoryItemSet(lpObj->m_Index, blank, (BYTE)lpObj->pInventory[blank].m_Type);

  001d8	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _blank$[ebp]
  001df	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  001e5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001e8	8b 82 5c 0c 00
	00		 mov	 eax, DWORD PTR [edx+3164]
  001ee	0f b6 4c 08 06	 movzx	 ecx, BYTE PTR [eax+ecx+6]
  001f3	51		 push	 ecx
  001f4	0f b6 95 43 ff
	ff ff		 movzx	 edx, BYTE PTR _blank$[ebp]
  001fb	52		 push	 edx
  001fc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ff	8b 08		 mov	 ecx, DWORD PTR [eax]
  00201	51		 push	 ecx
  00202	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  00207	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15543: 					return blank;

  0020a	8a 85 43 ff ff
	ff		 mov	 al, BYTE PTR _blank$[ebp]
  00210	eb 0c		 jmp	 SHORT $LN1@gObjInvent
$LN12@gObjInvent:

; 15544: 				}			
; 15545: 			}
; 15546: 		}

  00212	e9 dd fe ff ff	 jmp	 $LN5@gObjInvent
$LN6@gObjInvent:

; 15547: 	}

  00217	e9 b0 fe ff ff	 jmp	 $LN2@gObjInvent
$LN3@gObjInvent:
$LN11@gObjInvent:
$GOTO_EndFunc$14:

; 15548: 
; 15549: GOTO_EndFunc :
; 15550: 	return 0xFF;

  0021c	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjInvent:

; 15551: }

  0021e	5f		 pop	 edi
  0021f	5e		 pop	 esi
  00220	5b		 pop	 ebx
  00221	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00224	33 cd		 xor	 ecx, ebp
  00226	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022b	8b e5		 mov	 esp, ebp
  0022d	5d		 pop	 ebp
  0022e	c3		 ret	 0
?gObjInventoryInsertItem@@YAEPAVOBJECTSTRUCT@@HHHHH@Z ENDP ; gObjInventoryInsertItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSearchItemMinus@@YAHPAVOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_n$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_pos$ = 12						; size = 4
_m_dur$ = 16						; size = 4
?gObjSearchItemMinus@@YAHPAVOBJECTSTRUCT@@HH@Z PROC	; gObjSearchItemMinus, COMDAT

; 15239: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15240: 	int n=pos;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 15241: 	
; 15242: 	if( n < 0 || n > MAX_INVENTORY-1 ) 

  0000f	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  00013	7c 06		 jl	 SHORT $LN3@gObjSearch
  00015	83 7d fc 4b	 cmp	 DWORD PTR _n$[ebp], 75	; 0000004bH
  00019	7e 26		 jle	 SHORT $LN2@gObjSearch
$LN3@gObjSearch:

; 15243: 	{
; 15244: 		LogAdd("error-L4 : %s %d", __FILE__, __LINE__);

  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjSearchItemMinus@@YAHPAVOBJECTSTRUCT@@HH@Z@4JA
  00020	83 c0 05	 add	 eax, 5
  00023	50		 push	 eax
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FDAFLGGN@error?9L4?5?3?5?$CFs?5?$CFd@
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15245: 		return TRUE;

  00037	b8 01 00 00 00	 mov	 eax, 1
  0003c	e9 a5 00 00 00	 jmp	 $LN1@gObjSearch
$LN2@gObjSearch:

; 15246: 	}
; 15247: 	
; 15248: 	if( lpObj->pInventory[n].IsItem() == TRUE )

  00041	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 168
  00048	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004b	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00051	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00056	83 f8 01	 cmp	 eax, 1
  00059	0f 85 85 00 00
	00		 jne	 $LN4@gObjSearch

; 15249: 	{
; 15250: 		if( ((int)lpObj->pInventory[n].m_Durability-m_dur) > 0 )

  0005f	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 168
  00066	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00069	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0006f	f3 0f 2c 44 02
	24		 cvttss2si eax, DWORD PTR [edx+eax+36]
  00075	2b 45 10	 sub	 eax, DWORD PTR _m_dur$[ebp]
  00078	85 c0		 test	 eax, eax
  0007a	7e 68		 jle	 SHORT $LN6@gObjSearch

; 15251: 		{
; 15252: 			lpObj->pInventory[n].m_Durability -= m_dur;

  0007c	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 168
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00086	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0008c	f3 0f 2a 45 10	 cvtsi2ss xmm0, DWORD PTR _m_dur$[ebp]
  00091	f3 0f 10 4c 02
	24		 movss	 xmm1, DWORD PTR [edx+eax+36]
  00097	f3 0f 5c c8	 subss	 xmm1, xmm0
  0009b	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 168
  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a5	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000ab	f3 0f 11 4c 02
	24		 movss	 DWORD PTR [edx+eax+36], xmm1

; 15253: 			GCItemDurSend(lpObj->m_Index, n, (int)lpObj->pInventory[n].m_Durability, 1);

  000b1	6a 01		 push	 1
  000b3	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 168
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000bd	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000c3	f3 0f 2c 44 02
	24		 cvttss2si eax, DWORD PTR [edx+eax+36]
  000c9	50		 push	 eax
  000ca	0f b6 4d fc	 movzx	 ecx, BYTE PTR _n$[ebp]
  000ce	51		 push	 ecx
  000cf	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000d2	8b 02		 mov	 eax, DWORD PTR [edx]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  000da	83 c4 10	 add	 esp, 16			; 00000010H

; 15254: 			//LogAdd("%s  %d", lpObj->pInventory[n].GetName(), (int)lpObj->pInventory[n].m_Durability);
; 15255: 			return TRUE;

  000dd	b8 01 00 00 00	 mov	 eax, 1
  000e2	eb 02		 jmp	 SHORT $LN1@gObjSearch
$LN6@gObjSearch:
$LN4@gObjSearch:

; 15256: 		}		
; 15257: 		else
; 15258: 		{
; 15259: 			//LogAdd("error-L4 : %s %d  ", __FILE__, __LINE__);
; 15260: 		}
; 15261: 	}
; 15262: 	else
; 15263: 	{
; 15264: 		//LogAdd("error-L4 : %s %d", __FILE__, __LINE__);
; 15265: 	}
; 15266: 	return FALSE;

  000e4	33 c0		 xor	 eax, eax
$LN1@gObjSearch:

; 15267: }

  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	5b		 pop	 ebx
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c3		 ret	 0
?gObjSearchItemMinus@@YAHPAVOBJECTSTRUCT@@HH@Z ENDP	; gObjSearchItemMinus
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSearchItem@@YAHPAVOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
_n$1 = -4						; size = 4
_lpObj$ = 8						; size = 4
_item_type$ = 12					; size = 4
_add_dur$ = 16						; size = 4
_nLevel$ = 20						; size = 4
?gObjSearchItem@@YAHPAVOBJECTSTRUCT@@HHH@Z PROC		; gObjSearchItem, COMDAT

; 15185: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15186: 	for( int n=MAX_EQUIPMENT; n<MAX_INVENTORY; n++)

  00009	c7 45 fc 0c 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 12	; 0000000cH
  00010	eb 09		 jmp	 SHORT $LN4@gObjSearch
$LN2@gObjSearch:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjSearch:
  0001b	83 7d fc 4c	 cmp	 DWORD PTR _n$1[ebp], 76	; 0000004cH
  0001f	0f 8d e1 00 00
	00		 jge	 $LN3@gObjSearch

; 15187: 	{
; 15188: 		if( lpObj->pInventory[n].IsItem() == TRUE )

  00025	69 4d fc a8 00
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 168
  0002c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002f	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00035	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0003a	83 f8 01	 cmp	 eax, 1
  0003d	0f 85 be 00 00
	00		 jne	 $LN8@gObjSearch

; 15189: 		{
; 15190: 			if( lpObj->pInventory[n].m_Type == item_type )

  00043	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0004d	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00053	0f bf 44 02 06	 movsx	 eax, WORD PTR [edx+eax+6]
  00058	3b 45 0c	 cmp	 eax, DWORD PTR _item_type$[ebp]
  0005b	0f 85 a0 00 00
	00		 jne	 $LN8@gObjSearch

; 15191: 			{
; 15192: #ifdef ADD_HP_POTION_LEVEL1_FIX_20040420
; 15193: 				if ( lpObj->pInventory[n].m_Level == nLevel ) 

  00061	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00068	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0006b	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00071	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  00076	3b 45 14	 cmp	 eax, DWORD PTR _nLevel$[ebp]
  00079	0f 85 82 00 00
	00		 jne	 $LN8@gObjSearch

; 15194: #endif
; 15195: 				{
; 15196: 					if( ((int)lpObj->pInventory[n].m_Durability+add_dur) <= 3 )

  0007f	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00089	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0008f	f3 0f 2c 44 02
	24		 cvttss2si eax, DWORD PTR [edx+eax+36]
  00095	03 45 10	 add	 eax, DWORD PTR _add_dur$[ebp]
  00098	83 f8 03	 cmp	 eax, 3
  0009b	7f 64		 jg	 SHORT $LN8@gObjSearch

; 15197: 					{
; 15198: 						lpObj->pInventory[n].m_Durability += add_dur;

  0009d	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a7	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000ad	f3 0f 2a 45 10	 cvtsi2ss xmm0, DWORD PTR _add_dur$[ebp]
  000b2	f3 0f 58 44 02
	24		 addss	 xmm0, DWORD PTR [edx+eax+36]
  000b8	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000c2	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000c8	f3 0f 11 44 02
	24		 movss	 DWORD PTR [edx+eax+36], xmm0

; 15199: 						GCItemDurSend(lpObj->m_Index, n, (int)lpObj->pInventory[n].m_Durability, 0);

  000ce	6a 00		 push	 0
  000d0	69 45 fc a8 00
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 168
  000d7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000da	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000e0	f3 0f 2c 44 02
	24		 cvttss2si eax, DWORD PTR [edx+eax+36]
  000e6	50		 push	 eax
  000e7	0f b6 4d fc	 movzx	 ecx, BYTE PTR _n$1[ebp]
  000eb	51		 push	 ecx
  000ec	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ef	8b 02		 mov	 eax, DWORD PTR [edx]
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  000f7	83 c4 10	 add	 esp, 16			; 00000010H

; 15200: 						//LogAdd("%s  %d", lpObj->pInventory[n].GetName(), (int)lpObj->pInventory[n].m_Durability);
; 15201: 						return TRUE;

  000fa	b8 01 00 00 00	 mov	 eax, 1
  000ff	eb 07		 jmp	 SHORT $LN1@gObjSearch
$LN8@gObjSearch:

; 15202: 					}				
; 15203: 				}
; 15204: 			}			
; 15205: 		}
; 15206: 	}

  00101	e9 0c ff ff ff	 jmp	 $LN2@gObjSearch
$LN3@gObjSearch:

; 15207: 	return FALSE;

  00106	33 c0		 xor	 eax, eax
$LN1@gObjSearch:

; 15208: }

  00108	5f		 pop	 edi
  00109	5e		 pop	 esi
  0010a	5b		 pop	 ebx
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
?gObjSearchItem@@YAHPAVOBJECTSTRUCT@@HHH@Z ENDP		; gObjSearchItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjShopBuyInventoryInsertItemSerial@@YAEHVCItem@@@Z
_TEXT	SEGMENT
_blank$ = -17						; size = 1
_iheight$ = -16						; size = 4
_iwidth$ = -12						; size = 4
_h$ = -8						; size = 4
_w$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_item$ = 12						; size = 168
?gObjShopBuyInventoryInsertItemSerial@@YAEHVCItem@@@Z PROC ; gObjShopBuyInventoryInsertItemSerial, COMDAT

; 15324: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15325: 	int w, h;
; 15326: 	int iwidth, iheight;
; 15327: 	BYTE blank=0;

  00009	c6 45 ef 00	 mov	 BYTE PTR _blank$[ebp], 0

; 15328: 
; 15329: 
; 15330: 	if( item.GetSize(iwidth, iheight) == FALSE )

  0000d	8d 45 f0	 lea	 eax, DWORD PTR _iheight$[ebp]
  00010	50		 push	 eax
  00011	8d 4d f4	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00014	51		 push	 ecx
  00015	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  00018	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  0001d	85 c0		 test	 eax, eax
  0001f	75 2f		 jne	 SHORT $LN8@gObjShopBu

; 15331: 	{
; 15332: 		LogAdd(lMsg.Get(527), __FILE__, __LINE__);		

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjShopBuyInventoryInsertItemSerial@@YAEHVCItem@@@Z@4JA
  00026	83 c0 08	 add	 eax, 8
  00029	50		 push	 eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0002f	68 0f 02 00 00	 push	 527			; 0000020fH
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15333: 		return 0xFF;

  00049	0c ff		 or	 al, 255			; 000000ffH
  0004b	e9 ff 00 00 00	 jmp	 $LN1@gObjShopBu
$LN8@gObjShopBu:

; 15334: 	}
; 15335: 
; 15336: 	for( h=0; h<8; h++)

  00050	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _h$[ebp], 0
  00057	eb 09		 jmp	 SHORT $LN4@gObjShopBu
$LN2@gObjShopBu:
  00059	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  0005c	83 c0 01	 add	 eax, 1
  0005f	89 45 f8	 mov	 DWORD PTR _h$[ebp], eax
$LN4@gObjShopBu:
  00062	83 7d f8 08	 cmp	 DWORD PTR _h$[ebp], 8
  00066	0f 8d e1 00 00
	00		 jge	 $LN3@gObjShopBu

; 15337: 	{
; 15338: 		for( w=0; w<8; w++)				

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _w$[ebp], 0
  00073	eb 09		 jmp	 SHORT $LN7@gObjShopBu
$LN5@gObjShopBu:
  00075	8b 45 fc	 mov	 eax, DWORD PTR _w$[ebp]
  00078	83 c0 01	 add	 eax, 1
  0007b	89 45 fc	 mov	 DWORD PTR _w$[ebp], eax
$LN7@gObjShopBu:
  0007e	83 7d fc 08	 cmp	 DWORD PTR _w$[ebp], 8
  00082	0f 8d c0 00 00
	00		 jge	 $LN6@gObjShopBu

; 15339: 		{
; 15340: 			//  
; 15341: 			if( *(gObj[aIndex].pInventoryMap+(h*8)+w) == 0xFF )

  00088	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00095	8b 94 01 60 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3168]
  0009c	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  0009f	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  000a2	8b 55 fc	 mov	 edx, DWORD PTR _w$[ebp]
  000a5	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  000a9	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000ae	0f 85 8f 00 00
	00		 jne	 $LN12@gObjShopBu

; 15342: 			{
; 15343: #ifdef PERSONAL_SHOP_20040113			// NPC       .
; 15344: 				blank = gObjOnlyInventoryRectCheck(aIndex, w, h, iwidth,iheight);

  000b4	8b 45 f0	 mov	 eax, DWORD PTR _iheight$[ebp]
  000b7	50		 push	 eax
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  000bb	51		 push	 ecx
  000bc	8b 55 f8	 mov	 edx, DWORD PTR _h$[ebp]
  000bf	52		 push	 edx
  000c0	8b 45 fc	 mov	 eax, DWORD PTR _w$[ebp]
  000c3	50		 push	 eax
  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 ?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z ; gObjOnlyInventoryRectCheck
  000cd	83 c4 14	 add	 esp, 20			; 00000014H
  000d0	88 45 ef	 mov	 BYTE PTR _blank$[ebp], al

; 15345: #else
; 15346: 				blank = gObjInventoryRectCheck(aIndex, w, h, iwidth,iheight);
; 15347: #endif
; 15348: 
; 15349: 				// 
; 15350: 				if( blank == 0xFE ) goto GOTO_EndFunc;

  000d3	0f b6 45 ef	 movzx	 eax, BYTE PTR _blank$[ebp]
  000d7	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  000dc	75 04		 jne	 SHORT $LN10@gObjShopBu
  000de	eb 6d		 jmp	 SHORT $LN11@gObjShopBu
  000e0	eb 6b		 jmp	 SHORT $GOTO_EndFunc$14
$LN10@gObjShopBu:

; 15351: 				if( blank != 0xFF )	{	//   

  000e2	0f b6 45 ef	 movzx	 eax, BYTE PTR _blank$[ebp]
  000e6	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000eb	74 56		 je	 SHORT $LN12@gObjShopBu

; 15352: 					ItemSerialCreateSend(aIndex,0,0,0,item.m_Type,item.m_Level,

  000ed	6a 01		 push	 1
  000ef	0f b6 85 9e 00
	00 00		 movzx	 eax, BYTE PTR _item$[ebp+146]
  000f6	50		 push	 eax
  000f7	0f b6 8d 87 00
	00 00		 movzx	 ecx, BYTE PTR _item$[ebp+123]
  000fe	51		 push	 ecx
  000ff	6a ff		 push	 -1
  00101	0f b6 95 86 00
	00 00		 movzx	 edx, BYTE PTR _item$[ebp+122]
  00108	52		 push	 edx
  00109	0f b6 85 85 00
	00 00		 movzx	 eax, BYTE PTR _item$[ebp+121]
  00110	50		 push	 eax
  00111	0f b6 8d 84 00
	00 00		 movzx	 ecx, BYTE PTR _item$[ebp+120]
  00118	51		 push	 ecx
  00119	f3 0f 2c 55 30	 cvttss2si edx, DWORD PTR _item$[ebp+36]
  0011e	0f b6 c2	 movzx	 eax, dl
  00121	50		 push	 eax
  00122	0f b6 4d 14	 movzx	 ecx, BYTE PTR _item$[ebp+8]
  00126	51		 push	 ecx
  00127	0f bf 55 12	 movsx	 edx, WORD PTR _item$[ebp+6]
  0012b	52		 push	 edx
  0012c	6a 00		 push	 0
  0012e	6a 00		 push	 0
  00130	6a 00		 push	 0
  00132	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  0013b	83 c4 38	 add	 esp, 56			; 00000038H

; 15353: 						item.m_Durability,item.m_Option1,item.m_Option2,item.m_Option3,-1,
; 15354: 						item.m_NewOption,item.m_SetOption, TRUE);
; 15355: 					return blank;

  0013e	8a 45 ef	 mov	 al, BYTE PTR _blank$[ebp]
  00141	eb 0c		 jmp	 SHORT $LN1@gObjShopBu
$LN12@gObjShopBu:

; 15356: 				}
; 15357: 			}
; 15358: 		}

  00143	e9 2d ff ff ff	 jmp	 $LN5@gObjShopBu
$LN6@gObjShopBu:

; 15359: 	}

  00148	e9 0c ff ff ff	 jmp	 $LN2@gObjShopBu
$LN3@gObjShopBu:
$LN11@gObjShopBu:
$GOTO_EndFunc$14:

; 15360: GOTO_EndFunc :
; 15361: 
; 15362: 	return 0xFF;

  0014d	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjShopBu:

; 15363: }

  0014f	5f		 pop	 edi
  00150	5e		 pop	 esi
  00151	5b		 pop	 ebx
  00152	8b e5		 mov	 esp, ebp
  00154	5d		 pop	 ebp
  00155	c3		 ret	 0
?gObjShopBuyInventoryInsertItemSerial@@YAEHVCItem@@@Z ENDP ; gObjShopBuyInventoryInsertItemSerial
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z
_TEXT	SEGMENT
_blank$ = -17						; size = 1
_iheight$ = -16						; size = 4
_iwidth$ = -12						; size = 4
_h$ = -8						; size = 4
_w$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_item$ = 12						; size = 168
?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z PROC	; gObjShopBuyInventoryInsertItem, COMDAT

; 15271: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15272: 	int w, h;
; 15273: 	int iwidth, iheight;
; 15274: 	BYTE blank=0;

  00009	c6 45 ef 00	 mov	 BYTE PTR _blank$[ebp], 0

; 15275: 
; 15276: 
; 15277: 	if( item.GetSize(iwidth, iheight) == FALSE )

  0000d	8d 45 f0	 lea	 eax, DWORD PTR _iheight$[ebp]
  00010	50		 push	 eax
  00011	8d 4d f4	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00014	51		 push	 ecx
  00015	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  00018	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  0001d	85 c0		 test	 eax, eax
  0001f	75 2f		 jne	 SHORT $LN8@gObjShopBu

; 15278: 	{
; 15279: 		LogAdd(lMsg.Get(527), __FILE__, __LINE__);		

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z@4JA
  00026	83 c0 08	 add	 eax, 8
  00029	50		 push	 eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0002f	68 0f 02 00 00	 push	 527			; 0000020fH
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15280: 		return 0xFF;

  00049	0c ff		 or	 al, 255			; 000000ffH
  0004b	e9 71 01 00 00	 jmp	 $LN1@gObjShopBu
$LN8@gObjShopBu:

; 15281: 	}
; 15282: 
; 15283: 	for( h=0; h<8; h++)

  00050	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _h$[ebp], 0
  00057	eb 09		 jmp	 SHORT $LN4@gObjShopBu
$LN2@gObjShopBu:
  00059	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  0005c	83 c0 01	 add	 eax, 1
  0005f	89 45 f8	 mov	 DWORD PTR _h$[ebp], eax
$LN4@gObjShopBu:
  00062	83 7d f8 08	 cmp	 DWORD PTR _h$[ebp], 8
  00066	0f 8d 53 01 00
	00		 jge	 $GOTO_EndFunc$16

; 15284: 	{
; 15285: 		for( w=0; w<8; w++)				

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _w$[ebp], 0
  00073	eb 09		 jmp	 SHORT $LN7@gObjShopBu
$LN5@gObjShopBu:
  00075	8b 45 fc	 mov	 eax, DWORD PTR _w$[ebp]
  00078	83 c0 01	 add	 eax, 1
  0007b	89 45 fc	 mov	 DWORD PTR _w$[ebp], eax
$LN7@gObjShopBu:
  0007e	83 7d fc 08	 cmp	 DWORD PTR _w$[ebp], 8
  00082	0f 8d 32 01 00
	00		 jge	 $LN6@gObjShopBu

; 15286: 		{
; 15287: 			//  
; 15288: 			if( *(gObj[aIndex].pInventoryMap+(h*8)+w) == 0xFF )

  00088	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00095	8b 94 01 60 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3168]
  0009c	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  0009f	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  000a2	8b 55 fc	 mov	 edx, DWORD PTR _w$[ebp]
  000a5	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  000a9	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000ae	0f 85 01 01 00
	00		 jne	 $LN9@gObjShopBu

; 15289: 			{
; 15290: #ifdef PERSONAL_SHOP_20040113			// NPC       .
; 15291: 				blank = gObjOnlyInventoryRectCheck(aIndex, w, h, iwidth,iheight);

  000b4	8b 45 f0	 mov	 eax, DWORD PTR _iheight$[ebp]
  000b7	50		 push	 eax
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  000bb	51		 push	 ecx
  000bc	8b 55 f8	 mov	 edx, DWORD PTR _h$[ebp]
  000bf	52		 push	 edx
  000c0	8b 45 fc	 mov	 eax, DWORD PTR _w$[ebp]
  000c3	50		 push	 eax
  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 ?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z ; gObjOnlyInventoryRectCheck
  000cd	83 c4 14	 add	 esp, 20			; 00000014H
  000d0	88 45 ef	 mov	 BYTE PTR _blank$[ebp], al

; 15292: #else
; 15293: 				blank = gObjInventoryRectCheck(aIndex, w, h, iwidth,iheight);
; 15294: #endif
; 15295: 
; 15296: 				// 
; 15297: 				if( blank == 0xFE ) goto GOTO_EndFunc;

  000d3	0f b6 45 ef	 movzx	 eax, BYTE PTR _blank$[ebp]
  000d7	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  000dc	75 0a		 jne	 SHORT $LN10@gObjShopBu
  000de	e9 dc 00 00 00	 jmp	 $GOTO_EndFunc$16
  000e3	e9 d7 00 00 00	 jmp	 $GOTO_EndFunc$16
$LN10@gObjShopBu:

; 15298: 				if( blank != 0xFF )	{	//   

  000e8	0f b6 45 ef	 movzx	 eax, BYTE PTR _blank$[ebp]
  000ec	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000f1	0f 84 be 00 00
	00		 je	 $LN9@gObjShopBu

; 15299: 					gObj[aIndex].pInventory[blank] = item;

  000f7	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000fe	0f b6 4d ef	 movzx	 ecx, BYTE PTR _blank$[ebp]
  00102	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00108	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010e	8b bc 01 5c 0c
	00 00		 mov	 edi, DWORD PTR [ecx+eax+3164]
  00115	03 fa		 add	 edi, edx
  00117	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0011c	8d 75 0c	 lea	 esi, DWORD PTR _item$[ebp]
  0011f	f3 a5		 rep movsd

; 15300: 					
; 15301: 					//if( (item.m_serial >= (14<<4)) &&
; 15302: 					//	(item.m_Type <= (14<<4)+10) )	//   ..   .
; 15303: 					if( item.m_serial == 0)  

  00121	0f be 45 10	 movsx	 eax, BYTE PTR _item$[ebp+4]
  00125	85 c0		 test	 eax, eax
  00127	75 27		 jne	 SHORT $LN13@gObjShopBu

; 15304: 					{
; 15305: 						gObj[aIndex].pInventory[blank].m_Number = 0;

  00129	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00130	0f b6 4d ef	 movzx	 ecx, BYTE PTR _blank$[ebp]
  00134	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0013a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00140	8b 84 01 5c 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3164]
  00147	c7 04 10 00 00
	00 00		 mov	 DWORD PTR [eax+edx], 0

; 15306: 					}

  0014e	eb 2b		 jmp	 SHORT $LN14@gObjShopBu
$LN13@gObjShopBu:

; 15307: 					else
; 15308: 					{
; 15309: 						gObj[aIndex].pInventory[blank].m_Number = gGetItemNumber();

  00150	e8 00 00 00 00	 call	 ?gGetItemNumber@@YAKXZ	; gGetItemNumber
  00155	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0015c	0f b6 55 ef	 movzx	 edx, BYTE PTR _blank$[ebp]
  00160	69 d2 a8 00 00
	00		 imul	 edx, edx, 168
  00166	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016c	8b 8c 0e 5c 0c
	00 00		 mov	 ecx, DWORD PTR [esi+ecx+3164]
  00173	89 04 11	 mov	 DWORD PTR [ecx+edx], eax

; 15310: 						gPlusItemNumber();

  00176	e8 00 00 00 00	 call	 ?gPlusItemNumber@@YAXXZ	; gPlusItemNumber
$LN14@gObjShopBu:

; 15311: 					}
; 15312: 					gObjInventoryItemSet(aIndex, blank, (BYTE)gObj[aIndex].pInventory[blank].m_Type);

  0017b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00182	0f b6 4d ef	 movzx	 ecx, BYTE PTR _blank$[ebp]
  00186	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0018c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00192	8b 84 01 5c 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3164]
  00199	0f b6 4c 10 06	 movzx	 ecx, BYTE PTR [eax+edx+6]
  0019e	51		 push	 ecx
  0019f	0f b6 55 ef	 movzx	 edx, BYTE PTR _blank$[ebp]
  001a3	52		 push	 edx
  001a4	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  001ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15313: 					return blank;

  001b0	8a 45 ef	 mov	 al, BYTE PTR _blank$[ebp]
  001b3	eb 0c		 jmp	 SHORT $LN1@gObjShopBu
$LN9@gObjShopBu:

; 15314: 				}
; 15315: 			}
; 15316: 		}

  001b5	e9 bb fe ff ff	 jmp	 $LN5@gObjShopBu
$LN6@gObjShopBu:

; 15317: 	}

  001ba	e9 9a fe ff ff	 jmp	 $LN2@gObjShopBu
$GOTO_EndFunc$16:

; 15318: GOTO_EndFunc :
; 15319: 	
; 15320: 	return 0xFF;

  001bf	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjShopBu:

; 15321: }

  001c1	5f		 pop	 edi
  001c2	5e		 pop	 esi
  001c3	5b		 pop	 ebx
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c3		 ret	 0
?gObjShopBuyInventoryInsertItem@@YAEHVCItem@@@Z ENDP	; gObjShopBuyInventoryInsertItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryInsertItemTemp@@YAEPAVOBJECTSTRUCT@@PAVCMapItem@@@Z
_TEXT	SEGMENT
_blank$ = -189						; size = 1
_iheight$ = -188					; size = 4
_iwidth$ = -184						; size = 4
_h$ = -180						; size = 4
_w$ = -176						; size = 4
_item$ = -172						; size = 168
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_Item$ = 12						; size = 4
?gObjInventoryInsertItemTemp@@YAEPAVOBJECTSTRUCT@@PAVCMapItem@@@Z PROC ; gObjInventoryInsertItemTemp, COMDAT

; 15422: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 15423: 	CItem item;

  00016	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _item$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 15424: 	int w, h;
; 15425: 	int iwidth, iheight;
; 15426: 	BYTE blank=0;

  00021	c6 85 43 ff ff
	ff 00		 mov	 BYTE PTR _blank$[ebp], 0

; 15427: 	
; 15428: 	if( Item->GetSize(iwidth, iheight) == FALSE )

  00028	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR _iheight$[ebp]
  0002e	50		 push	 eax
  0002f	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00035	51		 push	 ecx
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _Item$[ebp]
  00039	83 c1 04	 add	 ecx, 4
  0003c	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  00041	85 c0		 test	 eax, eax
  00043	75 2f		 jne	 SHORT $LN8@gObjInvent

; 15429: 	{
; 15430: 		LogAdd(lMsg.Get(527), __FILE__, __LINE__);

  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryInsertItemTemp@@YAEPAVOBJECTSTRUCT@@PAVCMapItem@@@Z@4JA
  0004a	83 c0 08	 add	 eax, 8
  0004d	50		 push	 eax
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00053	68 0f 02 00 00	 push	 527			; 0000020fH
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00063	50		 push	 eax
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15431: 		return 0xFF;

  0006d	0c ff		 or	 al, 255			; 000000ffH
  0006f	e9 d8 00 00 00	 jmp	 $LN1@gObjInvent
$LN8@gObjInvent:

; 15432: 	}
; 15433: 
; 15434: 	for( h=0; h<8; h++)		

  00074	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _h$[ebp], 0
  0007e	eb 0f		 jmp	 SHORT $LN4@gObjInvent
$LN2@gObjInvent:
  00080	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _h$[ebp]
  00086	83 c0 01	 add	 eax, 1
  00089	89 85 4c ff ff
	ff		 mov	 DWORD PTR _h$[ebp], eax
$LN4@gObjInvent:
  0008f	83 bd 4c ff ff
	ff 08		 cmp	 DWORD PTR _h$[ebp], 8
  00096	0f 8d ae 00 00
	00		 jge	 $GOTO_EndFunc$14

; 15435: 	{		
; 15436: 		for( w=0; w<8; w++)

  0009c	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _w$[ebp], 0
  000a6	eb 0f		 jmp	 SHORT $LN7@gObjInvent
$LN5@gObjInvent:
  000a8	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _w$[ebp]
  000ae	83 c0 01	 add	 eax, 1
  000b1	89 85 50 ff ff
	ff		 mov	 DWORD PTR _w$[ebp], eax
$LN7@gObjInvent:
  000b7	83 bd 50 ff ff
	ff 08		 cmp	 DWORD PTR _w$[ebp], 8
  000be	0f 8d 81 00 00
	00		 jge	 $LN6@gObjInvent

; 15437: 		{
; 15438: 			//  
; 15439: 			if( *(lpObj->pInventoryMap+(h*8)+w) == 0xFF )

  000c4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c7	8b 88 60 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3168]
  000cd	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _h$[ebp]
  000d3	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  000d6	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _w$[ebp]
  000dc	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  000e0	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  000e6	75 58		 jne	 SHORT $LN9@gObjInvent

; 15440: 			{				
; 15441: 				blank = gObjInventoryRectCheck(lpObj->m_Index, w, h, iwidth,iheight);

  000e8	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _iheight$[ebp]
  000ee	50		 push	 eax
  000ef	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _iwidth$[ebp]
  000f5	51		 push	 ecx
  000f6	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _h$[ebp]
  000fc	52		 push	 edx
  000fd	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _w$[ebp]
  00103	50		 push	 eax
  00104	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00107	8b 11		 mov	 edx, DWORD PTR [ecx]
  00109	52		 push	 edx
  0010a	e8 00 00 00 00	 call	 ?gObjInventoryRectCheck@@YAEHHHHH@Z ; gObjInventoryRectCheck
  0010f	83 c4 14	 add	 esp, 20			; 00000014H
  00112	88 85 43 ff ff
	ff		 mov	 BYTE PTR _blank$[ebp], al

; 15442: 				// 
; 15443: 				if( blank == 0xFE ) goto GOTO_EndFunc;

  00118	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _blank$[ebp]
  0011f	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  00124	75 04		 jne	 SHORT $LN10@gObjInvent
  00126	eb 22		 jmp	 SHORT $GOTO_EndFunc$14
  00128	eb 20		 jmp	 SHORT $GOTO_EndFunc$14
$LN10@gObjInvent:

; 15444: 				if( blank != 0xFF )	{	//   					

  0012a	0f b6 85 43 ff
	ff ff		 movzx	 eax, BYTE PTR _blank$[ebp]
  00131	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00136	74 08		 je	 SHORT $LN9@gObjInvent

; 15445: 					return blank;

  00138	8a 85 43 ff ff
	ff		 mov	 al, BYTE PTR _blank$[ebp]
  0013e	eb 0c		 jmp	 SHORT $LN1@gObjInvent
$LN9@gObjInvent:

; 15446: 				}
; 15447: 			}
; 15448: 		}

  00140	e9 63 ff ff ff	 jmp	 $LN5@gObjInvent
$LN6@gObjInvent:

; 15449: 	}

  00145	e9 36 ff ff ff	 jmp	 $LN2@gObjInvent
$GOTO_EndFunc$14:

; 15450: 
; 15451: GOTO_EndFunc :
; 15452: 	return 0xFF;

  0014a	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjInvent:

; 15453: }

  0014c	5f		 pop	 edi
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00152	33 cd		 xor	 ecx, ebp
  00154	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c3		 ret	 0
?gObjInventoryInsertItemTemp@@YAEPAVOBJECTSTRUCT@@PAVCMapItem@@@Z ENDP ; gObjInventoryInsertItemTemp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z
_TEXT	SEGMENT
_blank$ = -17						; size = 1
_iheight$ = -16						; size = 4
_iwidth$ = -12						; size = 4
_h$ = -8						; size = 4
_w$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_item$ = 12						; size = 168
?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z PROC	; gObjOnlyInventoryInsertItem, COMDAT

; 15051: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15052: 	int w, h;
; 15053: 	int iwidth, iheight;
; 15054: 	BYTE blank=0;

  00009	c6 45 ef 00	 mov	 BYTE PTR _blank$[ebp], 0

; 15055: 
; 15056: 	if( item.GetSize(iwidth, iheight) == FALSE )

  0000d	8d 45 f0	 lea	 eax, DWORD PTR _iheight$[ebp]
  00010	50		 push	 eax
  00011	8d 4d f4	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00014	51		 push	 ecx
  00015	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  00018	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  0001d	85 c0		 test	 eax, eax
  0001f	75 2f		 jne	 SHORT $LN8@gObjOnlyIn

; 15057: 	{
; 15058: 		LogAdd(lMsg.Get(527), __FILE__, __LINE__);		

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z@4JA
  00026	83 c0 07	 add	 eax, 7
  00029	50		 push	 eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0002f	68 0f 02 00 00	 push	 527			; 0000020fH
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15059: 		return 0xFF;

  00049	0c ff		 or	 al, 255			; 000000ffH
  0004b	e9 6d 01 00 00	 jmp	 $LN1@gObjOnlyIn
$LN8@gObjOnlyIn:

; 15060: 	}
; 15061: 	for( h=0; h<8; h++)

  00050	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _h$[ebp], 0
  00057	eb 09		 jmp	 SHORT $LN4@gObjOnlyIn
$LN2@gObjOnlyIn:
  00059	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  0005c	83 c0 01	 add	 eax, 1
  0005f	89 45 f8	 mov	 DWORD PTR _h$[ebp], eax
$LN4@gObjOnlyIn:
  00062	83 7d f8 08	 cmp	 DWORD PTR _h$[ebp], 8
  00066	0f 8d 4f 01 00
	00		 jge	 $GOTO_EndFunc$16

; 15062: 	{
; 15063: 		for( w=0; w<8; w++)				

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _w$[ebp], 0
  00073	eb 09		 jmp	 SHORT $LN7@gObjOnlyIn
$LN5@gObjOnlyIn:
  00075	8b 45 fc	 mov	 eax, DWORD PTR _w$[ebp]
  00078	83 c0 01	 add	 eax, 1
  0007b	89 45 fc	 mov	 DWORD PTR _w$[ebp], eax
$LN7@gObjOnlyIn:
  0007e	83 7d fc 08	 cmp	 DWORD PTR _w$[ebp], 8
  00082	0f 8d 2e 01 00
	00		 jge	 $LN6@gObjOnlyIn

; 15064: 		{
; 15065: 			//  
; 15066: 			if( *(gObj[aIndex].pInventoryMap+(h*8)+w) == 0xFF )

  00088	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00095	8b 94 01 60 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3168]
  0009c	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  0009f	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  000a2	8b 55 fc	 mov	 edx, DWORD PTR _w$[ebp]
  000a5	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  000a9	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000ae	0f 85 fd 00 00
	00		 jne	 $LN9@gObjOnlyIn

; 15067: 			{				
; 15068: 				blank = gObjOnlyInventoryRectCheck(aIndex, w, h, iwidth,iheight);

  000b4	8b 45 f0	 mov	 eax, DWORD PTR _iheight$[ebp]
  000b7	50		 push	 eax
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  000bb	51		 push	 ecx
  000bc	8b 55 f8	 mov	 edx, DWORD PTR _h$[ebp]
  000bf	52		 push	 edx
  000c0	8b 45 fc	 mov	 eax, DWORD PTR _w$[ebp]
  000c3	50		 push	 eax
  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 ?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z ; gObjOnlyInventoryRectCheck
  000cd	83 c4 14	 add	 esp, 20			; 00000014H
  000d0	88 45 ef	 mov	 BYTE PTR _blank$[ebp], al

; 15069: 				// 
; 15070: 				if( blank == 0xFE ) goto GOTO_EndFunc;

  000d3	0f b6 45 ef	 movzx	 eax, BYTE PTR _blank$[ebp]
  000d7	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  000dc	75 0a		 jne	 SHORT $LN10@gObjOnlyIn
  000de	e9 d8 00 00 00	 jmp	 $GOTO_EndFunc$16
  000e3	e9 d3 00 00 00	 jmp	 $GOTO_EndFunc$16
$LN10@gObjOnlyIn:

; 15071: 				if( blank != 0xFF )	{	//   

  000e8	0f b6 45 ef	 movzx	 eax, BYTE PTR _blank$[ebp]
  000ec	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000f1	0f 84 ba 00 00
	00		 je	 $LN9@gObjOnlyIn

; 15072: 					//LogAdd(" ");
; 15073: 
; 15074: #ifdef ANTIHACKING_SERIAL_0_ITEM_20051202	
; 15075: 					if( gObjCheckSerial0ItemList(&item) )

  000f7	8d 45 0c	 lea	 eax, DWORD PTR _item$[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  00100	83 c4 04	 add	 esp, 4
  00103	85 c0		 test	 eax, eax
  00105	74 24		 je	 SHORT $LN13@gObjOnlyIn

; 15076: 					{
; 15077: 						// MODIFY_LOCALIZING_WTF_20060309  wtf   0.99.60 - 0.99.94
; 15078: 						MsgOutput( aIndex, lMsg.Get(3354) );			// "  .  ."

  00107	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  0010c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00117	50		 push	 eax
  00118	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00121	83 c4 08	 add	 esp, 8

; 15079: 						return 0xFF;

  00124	0c ff		 or	 al, 255			; 000000ffH
  00126	e9 92 00 00 00	 jmp	 $LN1@gObjOnlyIn
$LN13@gObjOnlyIn:

; 15080: 					}
; 15081: #endif
; 15082: 					
; 15083: 					if( gObjInventorySearchSerialNumber(&gObj[aIndex], item.m_Number) == FALSE )

  0012b	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  0012e	50		 push	 eax
  0012f	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00136	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013c	51		 push	 ecx
  0013d	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  00142	83 c4 08	 add	 esp, 8
  00145	85 c0		 test	 eax, eax
  00147	75 04		 jne	 SHORT $LN14@gObjOnlyIn

; 15084: 					{
; 15085: 						return 0xFF;

  00149	0c ff		 or	 al, 255			; 000000ffH
  0014b	eb 70		 jmp	 SHORT $LN1@gObjOnlyIn
$LN14@gObjOnlyIn:

; 15086: 					}
; 15087: 
; 15088: 					gObj[aIndex].pInventory[blank] = item;

  0014d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00154	0f b6 4d ef	 movzx	 ecx, BYTE PTR _blank$[ebp]
  00158	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0015e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00164	8b bc 01 5c 0c
	00 00		 mov	 edi, DWORD PTR [ecx+eax+3164]
  0016b	03 fa		 add	 edi, edx
  0016d	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00172	8d 75 0c	 lea	 esi, DWORD PTR _item$[ebp]
  00175	f3 a5		 rep movsd

; 15089: 					//LogAdd("  : %d", item.m_Number);
; 15090: 					//gObj[aIndex].pInventory[blank].m_Number = gGetItemNumber();
; 15091: 					//gPlusItemNumber();
; 15092: 					gObjInventoryItemSet(aIndex, blank, (BYTE)gObj[aIndex].pInventory[blank].m_Type);

  00177	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0017e	0f b6 4d ef	 movzx	 ecx, BYTE PTR _blank$[ebp]
  00182	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00188	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018e	8b 84 01 5c 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3164]
  00195	0f b6 4c 10 06	 movzx	 ecx, BYTE PTR [eax+edx+6]
  0019a	51		 push	 ecx
  0019b	0f b6 55 ef	 movzx	 edx, BYTE PTR _blank$[ebp]
  0019f	52		 push	 edx
  001a0	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  001a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15093: 
; 15094: 					return blank;

  001ac	8a 45 ef	 mov	 al, BYTE PTR _blank$[ebp]
  001af	eb 0c		 jmp	 SHORT $LN1@gObjOnlyIn
$LN9@gObjOnlyIn:

; 15095: 				}
; 15096: 			}
; 15097: 		}

  001b1	e9 bf fe ff ff	 jmp	 $LN5@gObjOnlyIn
$LN6@gObjOnlyIn:

; 15098: 	}

  001b6	e9 9e fe ff ff	 jmp	 $LN2@gObjOnlyIn
$GOTO_EndFunc$16:

; 15099: GOTO_EndFunc :
; 15100: 	
; 15101: 	return 0xFF;

  001bb	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjOnlyIn:

; 15102: }

  001bd	5f		 pop	 edi
  001be	5e		 pop	 esi
  001bf	5b		 pop	 ebx
  001c0	8b e5		 mov	 esp, ebp
  001c2	5d		 pop	 ebp
  001c3	c3		 ret	 0
?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z ENDP	; gObjOnlyInventoryInsertItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z
_TEXT	SEGMENT
_copyitem$ = -192					; size = 168
_blank$ = -21						; size = 1
_iheight$ = -20						; size = 4
_iwidth$ = -16						; size = 4
_h$ = -12						; size = 4
_w$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_item$ = 12						; size = 4
?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z PROC	; gObjInventoryInsertItem, COMDAT

; 15108: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 15109: 	int w, h;
; 15110: 	int iwidth, iheight;
; 15111: 	BYTE blank=0;

  00016	c6 45 eb 00	 mov	 BYTE PTR _blank$[ebp], 0

; 15112: 	CItem copyitem;

  0001a	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _copyitem$[ebp]
  00020	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem

; 15113: 
; 15114: 	if( item->GetSize(iwidth, iheight) == FALSE )

  00025	8d 45 ec	 lea	 eax, DWORD PTR _iheight$[ebp]
  00028	50		 push	 eax
  00029	8d 4d f0	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00030	83 c1 04	 add	 ecx, 4
  00033	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  00038	85 c0		 test	 eax, eax
  0003a	75 2f		 jne	 SHORT $LN8@gObjInvent

; 15115: 	{
; 15116: 		LogAdd(lMsg.Get(527), __FILE__, __LINE__);		

  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z@4JA
  00041	83 c0 08	 add	 eax, 8
  00044	50		 push	 eax
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0004a	68 0f 02 00 00	 push	 527			; 0000020fH
  0004f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0005a	50		 push	 eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15117: 		return 0xFF;

  00064	0c ff		 or	 al, 255			; 000000ffH
  00066	e9 a3 01 00 00	 jmp	 $LN1@gObjInvent
$LN8@gObjInvent:

; 15118: 	}
; 15119: 
; 15120: 
; 15121: 	for( h=0; h<8; h++)

  0006b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _h$[ebp], 0
  00072	eb 09		 jmp	 SHORT $LN4@gObjInvent
$LN2@gObjInvent:
  00074	8b 45 f4	 mov	 eax, DWORD PTR _h$[ebp]
  00077	83 c0 01	 add	 eax, 1
  0007a	89 45 f4	 mov	 DWORD PTR _h$[ebp], eax
$LN4@gObjInvent:
  0007d	83 7d f4 08	 cmp	 DWORD PTR _h$[ebp], 8
  00081	0f 8d 85 01 00
	00		 jge	 $LN3@gObjInvent

; 15122: 	{
; 15123: 		for( w=0; w<8; w++)				

  00087	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _w$[ebp], 0
  0008e	eb 09		 jmp	 SHORT $LN7@gObjInvent
$LN5@gObjInvent:
  00090	8b 45 f8	 mov	 eax, DWORD PTR _w$[ebp]
  00093	83 c0 01	 add	 eax, 1
  00096	89 45 f8	 mov	 DWORD PTR _w$[ebp], eax
$LN7@gObjInvent:
  00099	83 7d f8 08	 cmp	 DWORD PTR _w$[ebp], 8
  0009d	0f 8d 64 01 00
	00		 jge	 $LN6@gObjInvent

; 15124: 		{
; 15125: 			//  
; 15126: 			if( *(gObj[aIndex].pInventoryMap+(h*8)+w) == 0xFF )

  000a3	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b0	8b 94 01 60 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3168]
  000b7	8b 45 f4	 mov	 eax, DWORD PTR _h$[ebp]
  000ba	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  000bd	8b 55 f8	 mov	 edx, DWORD PTR _w$[ebp]
  000c0	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  000c4	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000c9	0f 85 33 01 00
	00		 jne	 $LN12@gObjInvent

; 15127: 			{
; 15128: #ifdef PERSONAL_SHOP_20040113			//        .
; 15129: 				blank = gObjOnlyInventoryRectCheck(aIndex, w, h, iwidth,iheight);

  000cf	8b 45 ec	 mov	 eax, DWORD PTR _iheight$[ebp]
  000d2	50		 push	 eax
  000d3	8b 4d f0	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  000d6	51		 push	 ecx
  000d7	8b 55 f4	 mov	 edx, DWORD PTR _h$[ebp]
  000da	52		 push	 edx
  000db	8b 45 f8	 mov	 eax, DWORD PTR _w$[ebp]
  000de	50		 push	 eax
  000df	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000e2	51		 push	 ecx
  000e3	e8 00 00 00 00	 call	 ?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z ; gObjOnlyInventoryRectCheck
  000e8	83 c4 14	 add	 esp, 20			; 00000014H
  000eb	88 45 eb	 mov	 BYTE PTR _blank$[ebp], al

; 15130: #else
; 15131: 				blank = gObjInventoryRectCheck(aIndex, w, h, iwidth,iheight);
; 15132: #endif
; 15133: 			
; 15134: 				// 
; 15135: 				if( blank == 0xFE ) goto GOTO_EndFunc;

  000ee	0f b6 45 eb	 movzx	 eax, BYTE PTR _blank$[ebp]
  000f2	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  000f7	75 0a		 jne	 SHORT $LN10@gObjInvent
  000f9	e9 0e 01 00 00	 jmp	 $LN11@gObjInvent
  000fe	e9 09 01 00 00	 jmp	 $GOTO_EndFunc$14
$LN10@gObjInvent:

; 15136: 				if( blank != 0xFF )	

  00103	0f b6 45 eb	 movzx	 eax, BYTE PTR _blank$[ebp]
  00107	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0010c	0f 84 f0 00 00
	00		 je	 $LN12@gObjInvent

; 15137: 				{	//   
; 15138: 					copyitem.m_Level = item->m_Level;

  00112	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  00115	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  00119	66 89 8d 48 ff
	ff ff		 mov	 WORD PTR _copyitem$[ebp+8], cx

; 15139: 					copyitem.m_Durability = item->m_Durability;

  00120	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  00123	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]
  00128	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _copyitem$[ebp+36], xmm0

; 15140: 
; 15141: #ifdef ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 15142: 					copyitem.Convert(item->m_Type, item->m_Option1,item->m_Option2, item->m_Option3, item->m_NewOption, item->m_SetOption, item->m_ItemOptionEx, item->m_SocketOption, item->m_BonusSocketOption );
; 15143: #else
; 15144: 	#ifdef ADD_380ITEM_NEWOPTION_20060711
; 15145: 					copyitem.Convert(item->m_Type, item->m_Option1,item->m_Option2, item->m_Option3, item->m_NewOption, item->m_SetOption, item->m_ItemOptionEx);
; 15146: 	#else
; 15147: 					copyitem.Convert(item->m_Type, item->m_Option1,item->m_Option2, item->m_Option3, item->m_NewOption, item->m_SetOption);

  00130	6a 01		 push	 1
  00132	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  00135	0f b6 88 96 00
	00 00		 movzx	 ecx, BYTE PTR [eax+150]
  0013c	51		 push	 ecx
  0013d	8b 55 0c	 mov	 edx, DWORD PTR _item$[ebp]
  00140	0f b6 42 7f	 movzx	 eax, BYTE PTR [edx+127]
  00144	50		 push	 eax
  00145	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00148	0f b6 51 7e	 movzx	 edx, BYTE PTR [ecx+126]
  0014c	52		 push	 edx
  0014d	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  00150	0f b6 48 7d	 movzx	 ecx, BYTE PTR [eax+125]
  00154	51		 push	 ecx
  00155	8b 55 0c	 mov	 edx, DWORD PTR _item$[ebp]
  00158	0f b6 42 7c	 movzx	 eax, BYTE PTR [edx+124]
  0015c	50		 push	 eax
  0015d	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00160	0f bf 51 0a	 movsx	 edx, WORD PTR [ecx+10]
  00164	52		 push	 edx
  00165	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _copyitem$[ebp]
  0016b	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEE@Z ; CItem::Convert

; 15148: 	#endif // ADD_380ITEM_NEWOPTION_20060711
; 15149: #endif // ADD_ITEM_SOCKET_OPTION_EXTEND_20080422
; 15150: 
; 15151: #ifdef DARKLORD_WORK
; 15152: 					copyitem.SetPetItemInfo(item->m_PetItem_Level, item->m_PetItem_Exp);

  00170	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  00173	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00179	51		 push	 ecx
  0017a	8b 55 0c	 mov	 edx, DWORD PTR _item$[ebp]
  0017d	8b 82 a4 00 00
	00		 mov	 eax, DWORD PTR [edx+164]
  00183	50		 push	 eax
  00184	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _copyitem$[ebp]
  0018a	e8 00 00 00 00	 call	 ?SetPetItemInfo@CItem@@QAEXHH@Z ; CItem::SetPetItemInfo

; 15153: #endif
; 15154: 					copyitem.m_Number     = item->m_Number;

  0018f	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  00192	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00195	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _copyitem$[ebp], ecx

; 15155: 
; 15156: 
; 15157: 					gObj[aIndex].pInventory[blank] = copyitem;

  0019b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001a2	0f b6 4d eb	 movzx	 ecx, BYTE PTR _blank$[ebp]
  001a6	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  001ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b2	8b bc 01 5c 0c
	00 00		 mov	 edi, DWORD PTR [ecx+eax+3164]
  001b9	03 fa		 add	 edi, edx
  001bb	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  001c0	8d b5 40 ff ff
	ff		 lea	 esi, DWORD PTR _copyitem$[ebp]
  001c6	f3 a5		 rep movsd

; 15158: 					//LogAdd("  : %d", item->m_Number);
; 15159: 					//gObj[aIndex].pInventory[blank].m_Number = gGetItemNumber();
; 15160: 					//gPlusItemNumber();
; 15161: 					gObjInventoryItemSet(aIndex, blank, (BYTE)gObj[aIndex].pInventory[blank].m_Type);

  001c8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  001cf	0f b6 4d eb	 movzx	 ecx, BYTE PTR _blank$[ebp]
  001d3	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  001d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001df	8b 84 01 5c 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3164]
  001e6	0f b6 4c 10 06	 movzx	 ecx, BYTE PTR [eax+edx+6]
  001eb	51		 push	 ecx
  001ec	0f b6 55 eb	 movzx	 edx, BYTE PTR _blank$[ebp]
  001f0	52		 push	 edx
  001f1	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001f4	50		 push	 eax
  001f5	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  001fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15162: 
; 15163: 					/*
; 15164: 					if( gObjInventorySearchSerialNumber(&gObj[aIndex], item->m_Number) == FALSE )
; 15165: 					{
; 15166: 						return 0xFF;
; 15167: 					}
; 15168: 					*/
; 15169: 					return blank;

  001fd	8a 45 eb	 mov	 al, BYTE PTR _blank$[ebp]
  00200	eb 0c		 jmp	 SHORT $LN1@gObjInvent
$LN12@gObjInvent:

; 15170: 				}
; 15171: 			}
; 15172: 		}

  00202	e9 89 fe ff ff	 jmp	 $LN5@gObjInvent
$LN6@gObjInvent:

; 15173: 	}

  00207	e9 68 fe ff ff	 jmp	 $LN2@gObjInvent
$LN3@gObjInvent:
$LN11@gObjInvent:
$GOTO_EndFunc$14:

; 15174: GOTO_EndFunc :
; 15175: 	
; 15176: 	return 0xFF;

  0020c	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjInvent:

; 15177: }

  0020e	5f		 pop	 edi
  0020f	5e		 pop	 esi
  00210	5b		 pop	 ebx
  00211	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00214	33 cd		 xor	 ecx, ebp
  00216	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021b	8b e5		 mov	 esp, ebp
  0021d	5d		 pop	 ebp
  0021e	c3		 ret	 0
?gObjInventoryInsertItem@@YAEHPAVCMapItem@@@Z ENDP	; gObjInventoryInsertItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryInsertItem@@YAEHVCItem@@@Z
_TEXT	SEGMENT
_blank$ = -17						; size = 1
_iheight$ = -16						; size = 4
_iwidth$ = -12						; size = 4
_h$ = -8						; size = 4
_w$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_item$ = 12						; size = 168
?gObjInventoryInsertItem@@YAEHVCItem@@@Z PROC		; gObjInventoryInsertItem, COMDAT

; 14993: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14994: 	int w, h;
; 14995: 	int iwidth, iheight;
; 14996: 	BYTE blank=0;

  00009	c6 45 ef 00	 mov	 BYTE PTR _blank$[ebp], 0

; 14997: 
; 14998: 	if( item.GetSize(iwidth, iheight) == FALSE )

  0000d	8d 45 f0	 lea	 eax, DWORD PTR _iheight$[ebp]
  00010	50		 push	 eax
  00011	8d 4d f4	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00014	51		 push	 ecx
  00015	8d 4d 0c	 lea	 ecx, DWORD PTR _item$[ebp]
  00018	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  0001d	85 c0		 test	 eax, eax
  0001f	75 2f		 jne	 SHORT $LN8@gObjInvent

; 14999: 	{
; 15000: 		LogAdd(lMsg.Get(527), __FILE__, __LINE__);		

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryInsertItem@@YAEHVCItem@@@Z@4JA
  00026	83 c0 07	 add	 eax, 7
  00029	50		 push	 eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0002f	68 0f 02 00 00	 push	 527			; 0000020fH
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15001: 		return 0xFF;

  00049	0c ff		 or	 al, 255			; 000000ffH
  0004b	e9 6d 01 00 00	 jmp	 $LN1@gObjInvent
$LN8@gObjInvent:

; 15002: 	}
; 15003: 	for( h=0; h<8; h++)

  00050	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _h$[ebp], 0
  00057	eb 09		 jmp	 SHORT $LN4@gObjInvent
$LN2@gObjInvent:
  00059	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  0005c	83 c0 01	 add	 eax, 1
  0005f	89 45 f8	 mov	 DWORD PTR _h$[ebp], eax
$LN4@gObjInvent:
  00062	83 7d f8 08	 cmp	 DWORD PTR _h$[ebp], 8
  00066	0f 8d 4f 01 00
	00		 jge	 $GOTO_EndFunc$16

; 15004: 	{
; 15005: 		for( w=0; w<8; w++)				

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _w$[ebp], 0
  00073	eb 09		 jmp	 SHORT $LN7@gObjInvent
$LN5@gObjInvent:
  00075	8b 45 fc	 mov	 eax, DWORD PTR _w$[ebp]
  00078	83 c0 01	 add	 eax, 1
  0007b	89 45 fc	 mov	 DWORD PTR _w$[ebp], eax
$LN7@gObjInvent:
  0007e	83 7d fc 08	 cmp	 DWORD PTR _w$[ebp], 8
  00082	0f 8d 2e 01 00
	00		 jge	 $LN6@gObjInvent

; 15006: 		{
; 15007: 			//  
; 15008: 			if( *(gObj[aIndex].pInventoryMap+(h*8)+w) == 0xFF )

  00088	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00095	8b 94 01 60 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3168]
  0009c	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  0009f	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  000a2	8b 55 fc	 mov	 edx, DWORD PTR _w$[ebp]
  000a5	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  000a9	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000ae	0f 85 fd 00 00
	00		 jne	 $LN9@gObjInvent

; 15009: 			{				
; 15010: 				blank = gObjInventoryRectCheck(aIndex, w, h, iwidth,iheight);

  000b4	8b 45 f0	 mov	 eax, DWORD PTR _iheight$[ebp]
  000b7	50		 push	 eax
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  000bb	51		 push	 ecx
  000bc	8b 55 f8	 mov	 edx, DWORD PTR _h$[ebp]
  000bf	52		 push	 edx
  000c0	8b 45 fc	 mov	 eax, DWORD PTR _w$[ebp]
  000c3	50		 push	 eax
  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 ?gObjInventoryRectCheck@@YAEHHHHH@Z ; gObjInventoryRectCheck
  000cd	83 c4 14	 add	 esp, 20			; 00000014H
  000d0	88 45 ef	 mov	 BYTE PTR _blank$[ebp], al

; 15011: 				// 
; 15012: 				if( blank == 0xFE ) goto GOTO_EndFunc;

  000d3	0f b6 45 ef	 movzx	 eax, BYTE PTR _blank$[ebp]
  000d7	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  000dc	75 0a		 jne	 SHORT $LN10@gObjInvent
  000de	e9 d8 00 00 00	 jmp	 $GOTO_EndFunc$16
  000e3	e9 d3 00 00 00	 jmp	 $GOTO_EndFunc$16
$LN10@gObjInvent:

; 15013: 				if( blank != 0xFF )	{	//   

  000e8	0f b6 45 ef	 movzx	 eax, BYTE PTR _blank$[ebp]
  000ec	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000f1	0f 84 ba 00 00
	00		 je	 $LN9@gObjInvent

; 15014: 					//LogAdd(" ");
; 15015: 
; 15016: #ifdef ANTIHACKING_SERIAL_0_ITEM_20051202	
; 15017: 					if( gObjCheckSerial0ItemList(&item) )

  000f7	8d 45 0c	 lea	 eax, DWORD PTR _item$[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  00100	83 c4 04	 add	 esp, 4
  00103	85 c0		 test	 eax, eax
  00105	74 24		 je	 SHORT $LN13@gObjInvent

; 15018: 					{
; 15019: 						// MODIFY_LOCALIZING_WTF_20060309  wtf   0.99.60 - 0.99.94
; 15020: 						MsgOutput( aIndex, lMsg.Get(3354) );			// "  .  ."

  00107	68 1a 0d 00 00	 push	 3354			; 00000d1aH
  0010c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00117	50		 push	 eax
  00118	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  00121	83 c4 08	 add	 esp, 8

; 15021: 						return 0xFF;

  00124	0c ff		 or	 al, 255			; 000000ffH
  00126	e9 92 00 00 00	 jmp	 $LN1@gObjInvent
$LN13@gObjInvent:

; 15022: 					}
; 15023: #endif
; 15024: 					
; 15025: 					if( gObjInventorySearchSerialNumber(&gObj[aIndex], item.m_Number) == FALSE )

  0012b	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  0012e	50		 push	 eax
  0012f	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00136	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013c	51		 push	 ecx
  0013d	e8 00 00 00 00	 call	 ?gObjInventorySearchSerialNumber@@YAHPAVOBJECTSTRUCT@@K@Z ; gObjInventorySearchSerialNumber
  00142	83 c4 08	 add	 esp, 8
  00145	85 c0		 test	 eax, eax
  00147	75 04		 jne	 SHORT $LN14@gObjInvent

; 15026: 					{
; 15027: 						return 0xFF;

  00149	0c ff		 or	 al, 255			; 000000ffH
  0014b	eb 70		 jmp	 SHORT $LN1@gObjInvent
$LN14@gObjInvent:

; 15028: 					}
; 15029: 
; 15030: 					gObj[aIndex].pInventory[blank] = item;

  0014d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00154	0f b6 4d ef	 movzx	 ecx, BYTE PTR _blank$[ebp]
  00158	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  0015e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00164	8b bc 01 5c 0c
	00 00		 mov	 edi, DWORD PTR [ecx+eax+3164]
  0016b	03 fa		 add	 edi, edx
  0016d	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00172	8d 75 0c	 lea	 esi, DWORD PTR _item$[ebp]
  00175	f3 a5		 rep movsd

; 15031: 					//LogAdd("  : %d", item.m_Number);
; 15032: 					//gObj[aIndex].pInventory[blank].m_Number = gGetItemNumber();
; 15033: 					//gPlusItemNumber();
; 15034: 					gObjInventoryItemSet(aIndex, blank, (BYTE)gObj[aIndex].pInventory[blank].m_Type);

  00177	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0017e	0f b6 4d ef	 movzx	 ecx, BYTE PTR _blank$[ebp]
  00182	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00188	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018e	8b 84 01 5c 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3164]
  00195	0f b6 4c 10 06	 movzx	 ecx, BYTE PTR [eax+edx+6]
  0019a	51		 push	 ecx
  0019b	0f b6 55 ef	 movzx	 edx, BYTE PTR _blank$[ebp]
  0019f	52		 push	 edx
  001a0	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  001a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15035: 
; 15036: 					return blank;

  001ac	8a 45 ef	 mov	 al, BYTE PTR _blank$[ebp]
  001af	eb 0c		 jmp	 SHORT $LN1@gObjInvent
$LN9@gObjInvent:

; 15037: 				}
; 15038: 			}
; 15039: 		}

  001b1	e9 bf fe ff ff	 jmp	 $LN5@gObjInvent
$LN6@gObjInvent:

; 15040: 	}

  001b6	e9 9e fe ff ff	 jmp	 $LN2@gObjInvent
$GOTO_EndFunc$16:

; 15041: GOTO_EndFunc :
; 15042: 	
; 15043: 	return 0xFF;

  001bb	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjInvent:

; 15044: }

  001bd	5f		 pop	 edi
  001be	5e		 pop	 esi
  001bf	5b		 pop	 ebx
  001c0	8b e5		 mov	 esp, ebp
  001c2	5d		 pop	 ebp
  001c3	c3		 ret	 0
?gObjInventoryInsertItem@@YAEHVCItem@@@Z ENDP		; gObjInventoryInsertItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryInsertItem@@YAEHH@Z
_TEXT	SEGMENT
_blank$ = -21						; size = 1
_iheight$ = -20						; size = 4
_iwidth$ = -16						; size = 4
_map_num$ = -12						; size = 4
_h$ = -8						; size = 4
_w$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_item_num$ = 12						; size = 4
?gObjInventoryInsertItem@@YAEHH@Z PROC			; gObjInventoryInsertItem, COMDAT

; 14930: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 14931: 	int w, h;
; 14932: 	int map_num;
; 14933: 	int iwidth, iheight;
; 14934: 	BYTE blank=0;

  00009	c6 45 eb 00	 mov	 BYTE PTR _blank$[ebp], 0

; 14935: 	
; 14936: 	map_num = gObj[aIndex].MapNumber;	

  0000d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0001a	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00022	89 55 f4	 mov	 DWORD PTR _map_num$[ebp], edx

; 14937: 	if( MapC[map_num].m_cItem[item_num].live == 0 ) 

  00025	69 45 f4 8c 04
	05 00		 imul	 eax, DWORD PTR _map_num$[ebp], 328844
  0002c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00032	69 4d 0c 48 04
	00 00		 imul	 ecx, DWORD PTR _item_num$[ebp], 1096
  00039	0f b6 94 08 ce
	00 00 00	 movzx	 edx, BYTE PTR [eax+ecx+206]
  00041	85 d2		 test	 edx, edx
  00043	75 07		 jne	 SHORT $LN8@gObjInvent

; 14938: 	{
; 14939: 		
; 14940: 		return 0xFF;

  00045	0c ff		 or	 al, 255			; 000000ffH
  00047	e9 7f 01 00 00	 jmp	 $LN1@gObjInvent
$LN8@gObjInvent:

; 14941: 	}
; 14942: 
; 14943: 	if( MapC[map_num].m_cItem[item_num].GetSize(iwidth, iheight) == FALSE )

  0004c	8d 45 ec	 lea	 eax, DWORD PTR _iheight$[ebp]
  0004f	50		 push	 eax
  00050	8d 4d f0	 lea	 ecx, DWORD PTR _iwidth$[ebp]
  00053	51		 push	 ecx
  00054	69 55 f4 8c 04
	05 00		 imul	 edx, DWORD PTR _map_num$[ebp], 328844
  0005b	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00061	69 45 0c 48 04
	00 00		 imul	 eax, DWORD PTR _item_num$[ebp], 1096
  00068	8d 4c 02 24	 lea	 ecx, DWORD PTR [edx+eax+36]
  0006c	e8 00 00 00 00	 call	 ?GetSize@CItem@@QAEHAAH0@Z ; CItem::GetSize
  00071	85 c0		 test	 eax, eax
  00073	75 2f		 jne	 SHORT $LN9@gObjInvent

; 14944: 	{
; 14945: 		LogAdd(lMsg.Get(527), __FILE__, __LINE__);

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryInsertItem@@YAEHH@Z@4JA
  0007a	83 c0 0f	 add	 eax, 15			; 0000000fH
  0007d	50		 push	 eax
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00083	68 0f 02 00 00	 push	 527			; 0000020fH
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00093	50		 push	 eax
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14946: 		
; 14947: 		return 0xFF;

  0009d	0c ff		 or	 al, 255			; 000000ffH
  0009f	e9 27 01 00 00	 jmp	 $LN1@gObjInvent
$LN9@gObjInvent:

; 14948: 	}
; 14949: 
; 14950: 	for( h=0; h<8; h++)

  000a4	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _h$[ebp], 0
  000ab	eb 09		 jmp	 SHORT $LN4@gObjInvent
$LN2@gObjInvent:
  000ad	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  000b0	83 c0 01	 add	 eax, 1
  000b3	89 45 f8	 mov	 DWORD PTR _h$[ebp], eax
$LN4@gObjInvent:
  000b6	83 7d f8 08	 cmp	 DWORD PTR _h$[ebp], 8
  000ba	0f 8d 09 01 00
	00		 jge	 $GOTO_EndFunc$15

; 14951: 	{		
; 14952: 		for( w=0; w<8; w++)	

  000c0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _w$[ebp], 0
  000c7	eb 09		 jmp	 SHORT $LN7@gObjInvent
$LN5@gObjInvent:
  000c9	8b 45 fc	 mov	 eax, DWORD PTR _w$[ebp]
  000cc	83 c0 01	 add	 eax, 1
  000cf	89 45 fc	 mov	 DWORD PTR _w$[ebp], eax
$LN7@gObjInvent:
  000d2	83 7d fc 08	 cmp	 DWORD PTR _w$[ebp], 8
  000d6	0f 8d e8 00 00
	00		 jge	 $LN6@gObjInvent

; 14953: 		{
; 14954: 			//  
; 14955: 			if( *(gObj[aIndex].pInventoryMap+(h*8)+w) == 0xFF )

  000dc	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e9	8b 94 01 60 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3168]
  000f0	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  000f3	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _w$[ebp]
  000f9	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  000fd	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00102	0f 85 b7 00 00
	00		 jne	 $LN10@gObjInvent

; 14956: 			{
; 14957: 				blank = gObjInventoryRectCheck(aIndex, w, h, iwidth,iheight);

  00108	8b 45 ec	 mov	 eax, DWORD PTR _iheight$[ebp]
  0010b	50		 push	 eax
  0010c	8b 4d f0	 mov	 ecx, DWORD PTR _iwidth$[ebp]
  0010f	51		 push	 ecx
  00110	8b 55 f8	 mov	 edx, DWORD PTR _h$[ebp]
  00113	52		 push	 edx
  00114	8b 45 fc	 mov	 eax, DWORD PTR _w$[ebp]
  00117	50		 push	 eax
  00118	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0011b	51		 push	 ecx
  0011c	e8 00 00 00 00	 call	 ?gObjInventoryRectCheck@@YAEHHHHH@Z ; gObjInventoryRectCheck
  00121	83 c4 14	 add	 esp, 20			; 00000014H
  00124	88 45 eb	 mov	 BYTE PTR _blank$[ebp], al

; 14958: 				// 
; 14959: 				if( blank == 0xFE )	goto GOTO_EndFunc;

  00127	0f b6 45 eb	 movzx	 eax, BYTE PTR _blank$[ebp]
  0012b	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  00130	75 0a		 jne	 SHORT $LN11@gObjInvent
  00132	e9 92 00 00 00	 jmp	 $GOTO_EndFunc$15
  00137	e9 8d 00 00 00	 jmp	 $GOTO_EndFunc$15
$LN11@gObjInvent:

; 14960: 				if( blank != 0xFF )	//   

  0013c	0f b6 45 eb	 movzx	 eax, BYTE PTR _blank$[ebp]
  00140	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00145	74 78		 je	 SHORT $LN10@gObjInvent

; 14961: 				{
; 14962: 					gObj[aIndex].pInventory[blank] = MapC[map_num].m_cItem[item_num];

  00147	69 45 f4 8c 04
	05 00		 imul	 eax, DWORD PTR _map_num$[ebp], 328844
  0014e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00154	69 4d 0c 48 04
	00 00		 imul	 ecx, DWORD PTR _item_num$[ebp], 1096
  0015b	8d 74 08 24	 lea	 esi, DWORD PTR [eax+ecx+36]
  0015f	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  00166	0f b6 45 eb	 movzx	 eax, BYTE PTR _blank$[ebp]
  0016a	69 c8 a8 00 00
	00		 imul	 ecx, eax, 168
  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00175	8b bc 10 5c 0c
	00 00		 mov	 edi, DWORD PTR [eax+edx+3164]
  0017c	03 f9		 add	 edi, ecx
  0017e	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00183	f3 a5		 rep movsd

; 14963: 					//LogAdd("  : %d", gObj[aIndex].pInventory[blank].m_Number);
; 14964: 					gObjInventoryItemSet(aIndex, blank, (BYTE)gObj[aIndex].pInventory[blank].m_Type);

  00185	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0018c	0f b6 4d eb	 movzx	 ecx, BYTE PTR _blank$[ebp]
  00190	69 d1 a8 00 00
	00		 imul	 edx, ecx, 168
  00196	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0019c	8b 84 01 5c 0c
	00 00		 mov	 eax, DWORD PTR [ecx+eax+3164]
  001a3	0f b6 4c 10 06	 movzx	 ecx, BYTE PTR [eax+edx+6]
  001a8	51		 push	 ecx
  001a9	0f b6 55 eb	 movzx	 edx, BYTE PTR _blank$[ebp]
  001ad	52		 push	 edx
  001ae	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001b1	50		 push	 eax
  001b2	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  001b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14965: 					return blank;

  001ba	8a 45 eb	 mov	 al, BYTE PTR _blank$[ebp]
  001bd	eb 0c		 jmp	 SHORT $LN1@gObjInvent
$LN10@gObjInvent:

; 14966: 				}
; 14967: 			}
; 14968: 		}

  001bf	e9 05 ff ff ff	 jmp	 $LN5@gObjInvent
$LN6@gObjInvent:

; 14969: 	}

  001c4	e9 e4 fe ff ff	 jmp	 $LN2@gObjInvent
$GOTO_EndFunc$15:

; 14970: 
; 14971: GOTO_EndFunc :
; 14972: 
; 14973: 	
; 14974: 	return 0xFF;

  001c9	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjInvent:

; 14975: }

  001cb	5f		 pop	 edi
  001cc	5e		 pop	 esi
  001cd	5b		 pop	 ebx
  001ce	8b e5		 mov	 esp, ebp
  001d0	5d		 pop	 ebp
  001d1	c3		 ret	 0
?gObjInventoryInsertItem@@YAEHH@Z ENDP			; gObjInventoryInsertItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?LevelSmallConvert@@YAEH@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
?LevelSmallConvert@@YAEH@Z PROC				; LevelSmallConvert, COMDAT

; 19593: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19594: #ifdef ITEM_12_13_20040401
; 19595: #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//  13 
; 19596: 	if( level >= 13 ) return 7;
; 19597: 	else if( level == 12  ) return 6;
; 19598: 	else if( level == 11  ) return 5;
; 19599: 	else if( level >= 9 && level <= 10 ) return 4;
; 19600: 	else if( level >= 7 && level <= 8 ) return 3;
; 19601: 	else if( level >= 5 && level <= 6 ) return 2;
; 19602: 	else if( level >= 3 && level <= 4 ) return 1;
; 19603: #else	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 19604: 	if( level >= 13 ) return 6;

  00009	83 7d 08 0d	 cmp	 DWORD PTR _level$[ebp], 13 ; 0000000dH
  0000d	7c 06		 jl	 SHORT $LN2@LevelSmall
  0000f	b0 06		 mov	 al, 6
  00011	eb 5c		 jmp	 SHORT $LN1@LevelSmall
  00013	eb 58		 jmp	 SHORT $LN3@LevelSmall
$LN2@LevelSmall:

; 19605: 	else if( level >= 11 && level <= 12 ) return 5;

  00015	83 7d 08 0b	 cmp	 DWORD PTR _level$[ebp], 11 ; 0000000bH
  00019	7c 0c		 jl	 SHORT $LN4@LevelSmall
  0001b	83 7d 08 0c	 cmp	 DWORD PTR _level$[ebp], 12 ; 0000000cH
  0001f	7f 06		 jg	 SHORT $LN4@LevelSmall
  00021	b0 05		 mov	 al, 5
  00023	eb 4a		 jmp	 SHORT $LN1@LevelSmall
  00025	eb 46		 jmp	 SHORT $LN3@LevelSmall
$LN4@LevelSmall:

; 19606: 	else if( level >= 9 && level <= 10 ) return 4;

  00027	83 7d 08 09	 cmp	 DWORD PTR _level$[ebp], 9
  0002b	7c 0c		 jl	 SHORT $LN6@LevelSmall
  0002d	83 7d 08 0a	 cmp	 DWORD PTR _level$[ebp], 10 ; 0000000aH
  00031	7f 06		 jg	 SHORT $LN6@LevelSmall
  00033	b0 04		 mov	 al, 4
  00035	eb 38		 jmp	 SHORT $LN1@LevelSmall
  00037	eb 34		 jmp	 SHORT $LN3@LevelSmall
$LN6@LevelSmall:

; 19607: 	else if( level >= 7 && level <= 8 ) return 3;

  00039	83 7d 08 07	 cmp	 DWORD PTR _level$[ebp], 7
  0003d	7c 0c		 jl	 SHORT $LN8@LevelSmall
  0003f	83 7d 08 08	 cmp	 DWORD PTR _level$[ebp], 8
  00043	7f 06		 jg	 SHORT $LN8@LevelSmall
  00045	b0 03		 mov	 al, 3
  00047	eb 26		 jmp	 SHORT $LN1@LevelSmall
  00049	eb 22		 jmp	 SHORT $LN3@LevelSmall
$LN8@LevelSmall:

; 19608: 	else if( level >= 5 && level <= 6 ) return 2;

  0004b	83 7d 08 05	 cmp	 DWORD PTR _level$[ebp], 5
  0004f	7c 0c		 jl	 SHORT $LN10@LevelSmall
  00051	83 7d 08 06	 cmp	 DWORD PTR _level$[ebp], 6
  00055	7f 06		 jg	 SHORT $LN10@LevelSmall
  00057	b0 02		 mov	 al, 2
  00059	eb 14		 jmp	 SHORT $LN1@LevelSmall
  0005b	eb 10		 jmp	 SHORT $LN3@LevelSmall
$LN10@LevelSmall:

; 19609: 	else if( level >= 3 && level <= 4 ) return 1;

  0005d	83 7d 08 03	 cmp	 DWORD PTR _level$[ebp], 3
  00061	7c 0a		 jl	 SHORT $LN3@LevelSmall
  00063	83 7d 08 04	 cmp	 DWORD PTR _level$[ebp], 4
  00067	7f 04		 jg	 SHORT $LN3@LevelSmall
  00069	b0 01		 mov	 al, 1
  0006b	eb 02		 jmp	 SHORT $LN1@LevelSmall
$LN3@LevelSmall:

; 19610: #endif	// ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 19611: #else
; 19612: 	if( level >= 11 ) return 7;
; 19613: 	else if( level == 10 ) return 6;
; 19614: 	else if( level == 9 ) return 5;
; 19615: 	else if( level == 8 ) return 4;
; 19616: 	else if( level == 7 ) return 3;
; 19617: 	else if( level >= 5 && level <= 6 ) return 2;
; 19618: 	else if( level >= 3 && level <= 4 ) return 1;
; 19619: #endif
; 19620: 	return 0;

  0006d	32 c0		 xor	 al, al
$LN1@LevelSmall:

; 19621: }

  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?LevelSmallConvert@@YAEH@Z ENDP				; LevelSmallConvert
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?LevelSmallConvert@@YAEHH@Z
_TEXT	SEGMENT
_level$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_inventoryindex$ = 12					; size = 4
?LevelSmallConvert@@YAEHH@Z PROC			; LevelSmallConvert, COMDAT

; 19559: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 19560: 	int level = gObj[aIndex].pInventory[inventoryindex].m_Level;

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	69 4d 0c a8 00
	00 00		 imul	 ecx, DWORD PTR _inventoryindex$[ebp], 168
  00017	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0001d	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  00024	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  00029	89 4d fc	 mov	 DWORD PTR _level$[ebp], ecx

; 19561: 	
; 19562: #ifdef ITEM_12_13_20040401
; 19563: 	#ifdef DARKLORD_WORK
; 19564: 		if( level >= 13 ) return 7;

  0002c	83 7d fc 0d	 cmp	 DWORD PTR _level$[ebp], 13 ; 0000000dH
  00030	7c 06		 jl	 SHORT $LN2@LevelSmall
  00032	b0 07		 mov	 al, 7
  00034	eb 62		 jmp	 SHORT $LN1@LevelSmall
  00036	eb 5e		 jmp	 SHORT $LN3@LevelSmall
$LN2@LevelSmall:

; 19565: 		else if( level == 12  ) return 6;

  00038	83 7d fc 0c	 cmp	 DWORD PTR _level$[ebp], 12 ; 0000000cH
  0003c	75 06		 jne	 SHORT $LN4@LevelSmall
  0003e	b0 06		 mov	 al, 6
  00040	eb 56		 jmp	 SHORT $LN1@LevelSmall
  00042	eb 52		 jmp	 SHORT $LN3@LevelSmall
$LN4@LevelSmall:

; 19566: 		else if( level == 11  ) return 5;

  00044	83 7d fc 0b	 cmp	 DWORD PTR _level$[ebp], 11 ; 0000000bH
  00048	75 06		 jne	 SHORT $LN6@LevelSmall
  0004a	b0 05		 mov	 al, 5
  0004c	eb 4a		 jmp	 SHORT $LN1@LevelSmall
  0004e	eb 46		 jmp	 SHORT $LN3@LevelSmall
$LN6@LevelSmall:

; 19567: 		else if( level >= 9 && level <= 10 ) return 4;

  00050	83 7d fc 09	 cmp	 DWORD PTR _level$[ebp], 9
  00054	7c 0c		 jl	 SHORT $LN8@LevelSmall
  00056	83 7d fc 0a	 cmp	 DWORD PTR _level$[ebp], 10 ; 0000000aH
  0005a	7f 06		 jg	 SHORT $LN8@LevelSmall
  0005c	b0 04		 mov	 al, 4
  0005e	eb 38		 jmp	 SHORT $LN1@LevelSmall
  00060	eb 34		 jmp	 SHORT $LN3@LevelSmall
$LN8@LevelSmall:

; 19568: 		else if( level >= 7 && level <= 8 ) return 3;

  00062	83 7d fc 07	 cmp	 DWORD PTR _level$[ebp], 7
  00066	7c 0c		 jl	 SHORT $LN10@LevelSmall
  00068	83 7d fc 08	 cmp	 DWORD PTR _level$[ebp], 8
  0006c	7f 06		 jg	 SHORT $LN10@LevelSmall
  0006e	b0 03		 mov	 al, 3
  00070	eb 26		 jmp	 SHORT $LN1@LevelSmall
  00072	eb 22		 jmp	 SHORT $LN3@LevelSmall
$LN10@LevelSmall:

; 19569: 		else if( level >= 5 && level <= 6 ) return 2;

  00074	83 7d fc 05	 cmp	 DWORD PTR _level$[ebp], 5
  00078	7c 0c		 jl	 SHORT $LN12@LevelSmall
  0007a	83 7d fc 06	 cmp	 DWORD PTR _level$[ebp], 6
  0007e	7f 06		 jg	 SHORT $LN12@LevelSmall
  00080	b0 02		 mov	 al, 2
  00082	eb 14		 jmp	 SHORT $LN1@LevelSmall
  00084	eb 10		 jmp	 SHORT $LN3@LevelSmall
$LN12@LevelSmall:

; 19570: 		else if( level >= 3 && level <= 4 ) return 1;

  00086	83 7d fc 03	 cmp	 DWORD PTR _level$[ebp], 3
  0008a	7c 0a		 jl	 SHORT $LN3@LevelSmall
  0008c	83 7d fc 04	 cmp	 DWORD PTR _level$[ebp], 4
  00090	7f 04		 jg	 SHORT $LN3@LevelSmall
  00092	b0 01		 mov	 al, 1
  00094	eb 02		 jmp	 SHORT $LN1@LevelSmall
$LN3@LevelSmall:

; 19571: 	#else	// #ifdef DARKLORD_WORK
; 19572: 		if( level >= 13 ) return 6;
; 19573: 		else if( level >= 11 && level <= 12 ) return 5;
; 19574: 		else if( level >= 9 && level <= 10 ) return 4;
; 19575: 		else if( level >= 7 && level <= 8 ) return 3;
; 19576: 		else if( level >= 5 && level <= 6 ) return 2;
; 19577: 		else if( level >= 3 && level <= 4 ) return 1;
; 19578: 	#endif	// #ifdef DARKLORD_WORK
; 19579: #else
; 19580: 	if( level >= 11 ) return 7;
; 19581: 	else if( level == 10 ) return 6;
; 19582: 	else if( level == 9 ) return 5;
; 19583: 	else if( level == 8 ) return 4;
; 19584: 	else if( level == 7 ) return 3;
; 19585: 	else if( level >= 5 && level <= 6 ) return 2;
; 19586: 	else if( level >= 3 && level <= 4 ) return 1;
; 19587: #endif
; 19588: 
; 19589: 	return 0;

  00096	32 c0		 xor	 al, al
$LN1@LevelSmall:

; 19590: }

  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
?LevelSmallConvert@@YAEHH@Z ENDP			; LevelSmallConvert
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjLevelUpPointAdd@@YAHEPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv82 = -68						; size = 4
_type$ = 8						; size = 1
_lpObj$ = 12						; size = 4
?gObjLevelUpPointAdd@@YAHEPAVOBJECTSTRUCT@@@Z PROC	; gObjLevelUpPointAdd, COMDAT

; 8074 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 8075 : 	if( lpObj->Type > 3 ) {

  00009	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00010	83 f9 03	 cmp	 ecx, 3
  00013	7e 3f		 jle	 SHORT $LN4@gObjLevelU

; 8076 : 		LogAddC(LOGC_RED, lMsg.Get(521), lpObj->AccountID, lpObj->Name, __FILE__, __LINE__);

  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjLevelUpPointAdd@@YAHEPAVOBJECTSTRUCT@@@Z@4JA
  0001a	83 c0 02	 add	 eax, 2
  0001d	50		 push	 eax
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00026	83 c1 73	 add	 ecx, 115		; 00000073H
  00029	51		 push	 ecx
  0002a	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0002d	83 c2 68	 add	 edx, 104		; 00000068H
  00030	52		 push	 edx
  00031	68 09 02 00 00	 push	 521			; 00000209H
  00036	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00041	50		 push	 eax
  00042	6a 02		 push	 2
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0004a	83 c4 18	 add	 esp, 24			; 00000018H

; 8077 : 		return FALSE;

  0004d	33 c0		 xor	 eax, eax
  0004f	e9 a4 01 00 00	 jmp	 $LN1@gObjLevelU
$LN4@gObjLevelU:

; 8078 : 	}
; 8079 : 	if( lpObj->LevelUpPoint < 1 ) return FALSE;

  00054	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00057	83 b8 a4 00 00
	00 01		 cmp	 DWORD PTR [eax+164], 1
  0005e	7d 07		 jge	 SHORT $LN5@gObjLevelU
  00060	33 c0		 xor	 eax, eax
  00062	e9 91 01 00 00	 jmp	 $LN1@gObjLevelU
$LN5@gObjLevelU:

; 8080 : 
; 8081 : 	switch( type )

  00067	0f b6 45 08	 movzx	 eax, BYTE PTR _type$[ebp]
  0006b	89 45 bc	 mov	 DWORD PTR tv82[ebp], eax
  0006e	83 7d bc 04	 cmp	 DWORD PTR tv82[ebp], 4
  00072	0f 87 58 01 00
	00		 ja	 $LN2@gObjLevelU
  00078	8b 4d bc	 mov	 ecx, DWORD PTR tv82[ebp]
  0007b	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN17@gObjLevelU[ecx*4]
$LN6@gObjLevelU:

; 8082 : 	{
; 8083 : 	case 0 : // 
; 8084 : 		{
; 8085 : 			if(lpObj->Strength >= g_GlobalConfig.m_iMax_Stats)

  00082	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00085	0f b7 88 b4 00
	00 00		 movzx	 ecx, WORD PTR [eax+180]
  0008c	3b 0d 98 00 00
	00		 cmp	 ecx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+152
  00092	7c 07		 jl	 SHORT $LN7@gObjLevelU

; 8086 : 				return FALSE;

  00094	33 c0		 xor	 eax, eax
  00096	e9 5d 01 00 00	 jmp	 $LN1@gObjLevelU
$LN7@gObjLevelU:

; 8087 : 
; 8088 : 			lpObj->Strength += 1;

  0009b	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009e	0f b7 88 b4 00
	00 00		 movzx	 ecx, WORD PTR [eax+180]
  000a5	83 c1 01	 add	 ecx, 1
  000a8	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ab	66 89 8a b4 00
	00 00		 mov	 WORD PTR [edx+180], cx

; 8089 : 		}
; 8090 : 		break;

  000b2	e9 19 01 00 00	 jmp	 $LN2@gObjLevelU
$LN8@gObjLevelU:

; 8091 : 	case 1 : // 
; 8092 : 		{
; 8093 : 			if(lpObj->Dexterity >= g_GlobalConfig.m_iMax_Stats)

  000b7	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ba	0f b7 88 b6 00
	00 00		 movzx	 ecx, WORD PTR [eax+182]
  000c1	3b 0d 98 00 00
	00		 cmp	 ecx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+152
  000c7	7c 07		 jl	 SHORT $LN9@gObjLevelU

; 8094 : 				return FALSE;

  000c9	33 c0		 xor	 eax, eax
  000cb	e9 28 01 00 00	 jmp	 $LN1@gObjLevelU
$LN9@gObjLevelU:

; 8095 : 
; 8096 : 			lpObj->Dexterity += 1;

  000d0	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d3	0f b7 88 b6 00
	00 00		 movzx	 ecx, WORD PTR [eax+182]
  000da	83 c1 01	 add	 ecx, 1
  000dd	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e0	66 89 8a b6 00
	00 00		 mov	 WORD PTR [edx+182], cx

; 8097 : 		}
; 8098 : 		break;

  000e7	e9 e4 00 00 00	 jmp	 $LN2@gObjLevelU
$LN10@gObjLevelU:

; 8099 : 	case 2 : // 
; 8100 : 		{
; 8101 : 			if(lpObj->Vitality >= g_GlobalConfig.m_iMax_Stats)

  000ec	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ef	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  000f6	3b 0d 98 00 00
	00		 cmp	 ecx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+152
  000fc	7c 07		 jl	 SHORT $LN11@gObjLevelU

; 8102 : 				return FALSE;

  000fe	33 c0		 xor	 eax, eax
  00100	e9 f3 00 00 00	 jmp	 $LN1@gObjLevelU
$LN11@gObjLevelU:

; 8103 : 
; 8104 : 			lpObj->Vitality += 1;

  00105	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00108	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0010f	83 c1 01	 add	 ecx, 1
  00112	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00115	66 89 8a b8 00
	00 00		 mov	 WORD PTR [edx+184], cx

; 8105 : 			lpObj->MaxLife += lpObj->VitalityToLife;

  0011c	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011f	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00122	f3 0f 10 80 c0
	00 00 00	 movss	 xmm0, DWORD PTR [eax+192]
  0012a	f3 0f 58 81 f4
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+244]
  00132	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00135	f3 0f 11 82 c0
	00 00 00	 movss	 DWORD PTR [edx+192], xmm0

; 8106 : 			gObjCalcMaxLifePower(lpObj->m_Index);	//    

  0013d	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00140	8b 08		 mov	 ecx, DWORD PTR [eax]
  00142	51		 push	 ecx
  00143	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower
  00148	83 c4 04	 add	 esp, 4

; 8107 : 		}
; 8108 : 		break;

  0014b	e9 80 00 00 00	 jmp	 $LN2@gObjLevelU
$LN12@gObjLevelU:

; 8109 : 	case 3 : // 
; 8110 : 		{
; 8111 : 			if(lpObj->Energy >= g_GlobalConfig.m_iMax_Stats)

  00150	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00153	0f b7 88 ba 00
	00 00		 movzx	 ecx, WORD PTR [eax+186]
  0015a	3b 0d 98 00 00
	00		 cmp	 ecx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+152
  00160	7c 07		 jl	 SHORT $LN13@gObjLevelU

; 8112 : 				return FALSE;

  00162	33 c0		 xor	 eax, eax
  00164	e9 8f 00 00 00	 jmp	 $LN1@gObjLevelU
$LN13@gObjLevelU:

; 8113 : 
; 8114 : 			lpObj->Energy += 1;

  00169	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016c	0f b7 88 ba 00
	00 00		 movzx	 ecx, WORD PTR [eax+186]
  00173	83 c1 01	 add	 ecx, 1
  00176	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00179	66 89 8a ba 00
	00 00		 mov	 WORD PTR [edx+186], cx

; 8115 : 			lpObj->MaxMana += lpObj->EnergyToMana;

  00180	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00183	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00186	f3 0f 10 80 d4
	00 00 00	 movss	 xmm0, DWORD PTR [eax+212]
  0018e	f3 0f 58 81 f8
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+248]
  00196	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00199	f3 0f 11 82 d4
	00 00 00	 movss	 DWORD PTR [edx+212], xmm0

; 8116 : 		}
; 8117 : 		break;

  001a1	eb 2d		 jmp	 SHORT $LN2@gObjLevelU
$LN14@gObjLevelU:

; 8118 : 		
; 8119 : #ifdef DARKLORD_WORK
; 8120 : 	case 4 : // 
; 8121 : 		{
; 8122 : 			if(lpObj->Leadership >= g_GlobalConfig.m_iMax_Stats)

  001a3	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a6	0f b7 88 d8 00
	00 00		 movzx	 ecx, WORD PTR [eax+216]
  001ad	3b 0d 98 00 00
	00		 cmp	 ecx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+152
  001b3	7c 04		 jl	 SHORT $LN15@gObjLevelU

; 8123 : 				return FALSE;

  001b5	33 c0		 xor	 eax, eax
  001b7	eb 3f		 jmp	 SHORT $LN1@gObjLevelU
$LN15@gObjLevelU:

; 8124 : 
; 8125 : 			lpObj->Leadership += 1;

  001b9	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001bc	0f b7 88 d8 00
	00 00		 movzx	 ecx, WORD PTR [eax+216]
  001c3	83 c1 01	 add	 ecx, 1
  001c6	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001c9	66 89 8a d8 00
	00 00		 mov	 WORD PTR [edx+216], cx
$LN2@gObjLevelU:

; 8126 : 		}
; 8127 : 		break;
; 8128 : #endif
; 8129 : 	}
; 8130 : 	lpObj->LevelUpPoint-=1;

  001d0	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d3	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  001d9	83 e9 01	 sub	 ecx, 1
  001dc	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001df	89 8a a4 00 00
	00		 mov	 DWORD PTR [edx+164], ecx

; 8131 : 
; 8132 : 	// 
; 8133 : 	gObjCalCharacter(lpObj->m_Index);

  001e5	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ea	51		 push	 ecx
  001eb	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  001f0	83 c4 04	 add	 esp, 4

; 8134 : 	return TRUE;

  001f3	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjLevelU:

; 8135 : }

  001f8	5f		 pop	 edi
  001f9	5e		 pop	 esi
  001fa	5b		 pop	 ebx
  001fb	8b e5		 mov	 esp, ebp
  001fd	5d		 pop	 ebp
  001fe	c3		 ret	 0
  001ff	90		 npad	 1
$LN17@gObjLevelU:
  00200	00 00 00 00	 DD	 $LN6@gObjLevelU
  00204	00 00 00 00	 DD	 $LN8@gObjLevelU
  00208	00 00 00 00	 DD	 $LN10@gObjLevelU
  0020c	00 00 00 00	 DD	 $LN12@gObjLevelU
  00210	00 00 00 00	 DD	 $LN14@gObjLevelU
?gObjLevelUpPointAdd@@YAHEPAVOBJECTSTRUCT@@@Z ENDP	; gObjLevelUpPointAdd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjLevelUp@@YA_NPAVOBJECTSTRUCT@@HHH@Z
_TEXT	SEGMENT
_MaxAddPoint$ = -8					; size = 2
_AddPoint$ = -4						; size = 2
_lpObj$ = 8						; size = 4
_addexp$ = 12						; size = 4
_iMonsterType$ = 16					; size = 4
_iEventType$ = 20					; size = 4
?gObjLevelUp@@YA_NPAVOBJECTSTRUCT@@HHH@Z PROC		; gObjLevelUp, COMDAT

; 7816 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7817 : #if TESTSERVER == 1
; 7818 : 	#ifdef MODIFY_LIFEANDMANA_BUG_LEVELUP_RELOGIN_20065018
; 7819 : 		// 2006.5.27 
; 7820 : 		//lpObj->Experience += addexp;
; 7821 : 	#endif
; 7822 : #endif
; 7823 : 
; 7824 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912		//    
; 7825 : 	bool bEventMapReward = false;
; 7826 : 
; 7827 : 	if( iEventType == EVENT_TYPE_DEVILSQUARE )
; 7828 : 		bEventMapReward = true;
; 7829 : 
; 7830 : 	if( g_MasterLevelSystem.MasterLevelUp( lpObj, addexp, bEventMapReward) )
; 7831 : 		return false;	
; 7832 : #endif
; 7833 : 
; 7834 : #ifdef UPDATE_ADD_LOG_20080117
; 7835 : 	LogAddTD("Experience : Map[%d]-(%d,%d) [%s][%s](%d) %I64u %I64d MonsterIndex : %d, EventType : %d",

  00009	8b 45 14	 mov	 eax, DWORD PTR _iEventType$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _iMonsterType$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR _addexp$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00018	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  0001e	2b 4d 0c	 sub	 ecx, DWORD PTR _addexp$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00025	0f bf 82 a0 00
	00 00		 movsx	 eax, WORD PTR [edx+160]
  0002c	50		 push	 eax
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00030	83 c1 73	 add	 ecx, 115		; 00000073H
  00033	51		 push	 ecx
  00034	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00037	83 c2 68	 add	 edx, 104		; 00000068H
  0003a	52		 push	 edx
  0003b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003e	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00045	51		 push	 ecx
  00046	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00049	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  00050	50		 push	 eax
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00054	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0005b	52		 push	 edx
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@OHEIPIHL@Experience?5?3?5Map?$FL?$CFd?$FN?9?$CI?$CFd?0?$CFd?$CJ?5?$FL?$CF@
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00067	83 c4 2c	 add	 esp, 44			; 0000002cH

; 7836 : 		lpObj->MapNumber, lpObj->X, lpObj->Y,
; 7837 : 		lpObj->AccountID, lpObj->Name, lpObj->Level, lpObj->Experience-addexp, addexp,
; 7838 : 		iMonsterType, iEventType );	
; 7839 : #else	// UPDATE_ADD_LOG_20080117
; 7840 : #ifdef MODIFY_EXP_LOG_MONSTER_EVENT_INDEX_20060906	
; 7841 : 	LogAddTD("Experience : Map[%d]-(%d,%d) [%s][%s](%d) %u %d MonsterIndex : %d, EventType : %d",
; 7842 : 		lpObj->MapNumber, lpObj->X, lpObj->Y,
; 7843 : 		lpObj->AccountID, lpObj->Name, lpObj->Level, lpObj->Experience-addexp, addexp,
; 7844 : 		iMonsterType, iEventType );	
; 7845 : #endif
; 7846 : #endif	// UPDATE_ADD_LOG_20080117
; 7847 : 
; 7848 : #ifdef MAX_LEVEL_BLOCK_GAIN_EXPERIENCE_20050613
; 7849 : 	//   MAX_LEVEL .
; 7850 : 	if( lpObj->Level >= g_GlobalConfig.m_iMaxLevel &&

  0006a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006d	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00074	3b 0d c8 00 00
	00		 cmp	 ecx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+200
  0007a	7c 5e		 jl	 SHORT $LN2@gObjLevelU
  0007c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007f	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00086	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00089	8b 82 a8 00 00
	00		 mov	 eax, DWORD PTR [edx+168]
  0008f	3b 04 8d fc ff
	ff ff		 cmp	 eax, DWORD PTR ?gLevelExperience@@3PAKA[ecx*4-4]
  00096	72 42		 jb	 SHORT $LN2@gObjLevelU

; 7851 : 		((DWORD)lpObj->Experience) >= gLevelExperience[lpObj->Level-1]
; 7852 : 		)
; 7853 : 	{
; 7854 : 		lpObj->Experience = gLevelExperience[lpObj->Level-1];

  00098	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009b	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  000a2	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000a5	8b 04 8d fc ff
	ff ff		 mov	 eax, DWORD PTR ?gLevelExperience@@3PAKA[ecx*4-4]
  000ac	89 82 a8 00 00
	00		 mov	 DWORD PTR [edx+168], eax

; 7855 : 		GCServerMsgStringSend(lMsg.Get(1136), lpObj->m_Index, 1);

  000b2	6a 01		 push	 1
  000b4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	51		 push	 ecx
  000ba	68 70 04 00 00	 push	 1136			; 00000470H
  000bf	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7856 : 		return false;

  000d3	32 c0		 xor	 al, al
  000d5	e9 19 03 00 00	 jmp	 $LN1@gObjLevelU
$LN2@gObjLevelU:

; 7857 : 	}
; 7858 : #endif
; 7859 : 	
; 7860 : //--------->
; 7861 : //  0    . 20081124 (grooving)
; 7862 : if( 0 == addexp )

  000da	83 7d 0c 00	 cmp	 DWORD PTR _addexp$[ebp], 0
  000de	75 07		 jne	 SHORT $LN3@gObjLevelU

; 7863 : 	return false;

  000e0	32 c0		 xor	 al, al
  000e2	e9 0c 03 00 00	 jmp	 $LN1@gObjLevelU
$LN3@gObjLevelU:

; 7864 : //<---------
; 7865 : 
; 7866 : #ifdef PCBANG_ADVANTAGE
; 7867 : 	if( addexp == 0 )
; 7868 : 	#ifdef MAX_LEVEL_BLOCK_GAIN_EXPERIENCE_20050613
; 7869 : 		return false;
; 7870 : 	#else
; 7871 : 		return;
; 7872 : 	#endif
; 7873 : 
; 7874 : 
; 7875 : #ifdef PCBANG_ADVANTAGE_EXPAND_20060919
; 7876 : 	#ifdef FOR_TAIWAN
; 7877 : 	if( IsOKPCBangBenefitAll(lpObj) )
; 7878 : 	#else
; 7879 : 	if( lpObj->Level <= 150 && IsOKPCBangBenefitAll(lpObj) )
; 7880 : 	#endif
; 7881 : #else
; 7882 : 	#ifdef FOR_TAIWAN
; 7883 : 	if ( lpObj->m_bPCBangUser )	
; 7884 : 	#else
; 7885 : 	if (lpObj->Level <= 150 && lpObj->m_bPCBangUser)
; 7886 : 	#endif
; 7887 : #endif //PCBANG_ADVANTAGE_EXPAND_20060919
; 7888 : 
; 7889 : 	{
; 7890 : 
; 7891 : 	#ifdef FOR_TAIWAN
; 7892 : 		int iAddPCBangExp = addexp / 2;
; 7893 : 	#else
; 7894 : 		int iAddPCBangExp = addexp / 10;
; 7895 : 	#endif
; 7896 : 		
; 7897 : 		iAddPCBangExp = min( iAddPCBangExp, gLevelExperience[lpObj->Level] );
; 7898 : 		lpObj->Experience += iAddPCBangExp;
; 7899 : 
; 7900 : 		addexp += iAddPCBangExp;
; 7901 : 	}
; 7902 : #endif //happycat@20050211
; 7903 : 
; 7904 : #ifdef BONUS_EXPERIENCE_POINT_20050303
; 7905 : 	#define BONUS_LEVEL_LIMIT                       150
; 7906 :     #define BONUS_INCREASE_EXPERIENCE_RATE           10
; 7907 : 
; 7908 : 	if( addexp == 0 )
; 7909 : #ifdef MAX_LEVEL_BLOCK_GAIN_EXPERIENCE_20050613
; 7910 : 		return false;
; 7911 : #else
; 7912 : 		return;
; 7913 : #endif
; 7914 : 
; 7915 : 	if( lpObj->Level <= BONUS_LEVEL_LIMIT )	
; 7916 : 	{ 
; 7917 : 		int iAddExp = addexp / BONUS_INCREASE_EXPERIENCE_RATE;
; 7918 : 		
; 7919 : 		iAddExp = min( iAddExp, gLevelExperience[lpObj->Level] );
; 7920 : 		lpObj->Experience += iAddExp;
; 7921 : 
; 7922 : 		addexp += iAddExp;
; 7923 : 	}
; 7924 : #endif // BONUS_EXPERIENCE_POINT_20050303
; 7925 : 
; 7926 : #ifdef DARKLORD_WORK	//    	
; 7927 : 	gObjSetExpPetItem(lpObj->m_Index, addexp);

  000e7	8b 45 0c	 mov	 eax, DWORD PTR _addexp$[ebp]
  000ea	50		 push	 eax
  000eb	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f0	52		 push	 edx
  000f1	e8 00 00 00 00	 call	 ?gObjSetExpPetItem@@YAXHH@Z ; gObjSetExpPetItem
  000f6	83 c4 08	 add	 esp, 8

; 7928 : #endif
; 7929 : 
; 7930 : #ifndef MAX_LEVEL_BLOCK_GAIN_EXPERIENCE_20050613
; 7931 : 	//   MAX_LEVEL .
; 7932 : 	if( lpObj->Level >= g_GlobalConfig.m_iMaxLevel )
; 7933 : 	{
; 7934 : 		GCServerMsgStringSend(lMsg.Get(1136), lpObj->m_Index, 1);
; 7935 : 		return;
; 7936 : 	}
; 7937 : #endif
; 7938 : 
; 7939 : #ifdef MAX_LEVEL_BLOCK_GAIN_EXPERIENCE_20050613
; 7940 : 	if( lpObj->Experience < lpObj->NextExp ) return true;

  000f9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ff	8b 90 a8 00 00
	00		 mov	 edx, DWORD PTR [eax+168]
  00105	3b 91 ac 00 00
	00		 cmp	 edx, DWORD PTR [ecx+172]
  0010b	73 07		 jae	 SHORT $LN4@gObjLevelU
  0010d	b0 01		 mov	 al, 1
  0010f	e9 df 02 00 00	 jmp	 $LN1@gObjLevelU
$LN4@gObjLevelU:

; 7941 : #else
; 7942 : 	if( lpObj->Experience < lpObj->NextExp ) return;
; 7943 : #endif
; 7944 : 
; 7945 : #ifdef BUGFIX_GAIN_EXP_20071210	
; 7946 : 	//       .
; 7947 : 	addexp = 0;
; 7948 : #endif
; 7949 : 
; 7950 : 	lpObj->Experience = lpObj->NextExp;

  00114	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00117	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0011a	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  00120	89 90 a8 00 00
	00		 mov	 DWORD PTR [eax+168], edx

; 7951 : 	lpObj->Level += 1;

  00126	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00129	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00130	83 c1 01	 add	 ecx, 1
  00133	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00136	66 89 8a a0 00
	00 00		 mov	 WORD PTR [edx+160], cx

; 7952 : 
; 7953 : #ifdef DARKLORD_WORK
; 7954 : 	if(lpObj->Class == CLASS_DARKLORD )

  0013d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00140	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00147	83 f9 04	 cmp	 ecx, 4
  0014a	75 1a		 jne	 SHORT $LN5@gObjLevelU

; 7955 : 		lpObj->LevelUpPoint += g_GlobalConfig.m_iSpecial_Points;

  0014c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014f	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00155	03 0d c0 00 00
	00		 add	 ecx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+192
  0015b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0015e	89 8a a4 00 00
	00		 mov	 DWORD PTR [edx+164], ecx
  00164	eb 41		 jmp	 SHORT $LN8@gObjLevelU
$LN5@gObjLevelU:

; 7956 : 	else
; 7957 : #endif
; 7958 : 	if(lpObj->Class == CLASS_MAGUMSA )

  00166	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00169	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00170	83 f9 03	 cmp	 ecx, 3
  00173	75 1a		 jne	 SHORT $LN7@gObjLevelU

; 7959 :     	lpObj->LevelUpPoint += g_GlobalConfig.m_iSpecial_Points;

  00175	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00178	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0017e	03 0d c0 00 00
	00		 add	 ecx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+192
  00184	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00187	89 8a a4 00 00
	00		 mov	 DWORD PTR [edx+164], ecx
  0018d	eb 18		 jmp	 SHORT $LN8@gObjLevelU
$LN7@gObjLevelU:

; 7960 : 	else
; 7961 :     	lpObj->LevelUpPoint += g_GlobalConfig.m_iNormal_Points;

  0018f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00192	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00198	03 0d bc 00 00
	00		 add	 ecx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+188
  0019e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001a1	89 8a a4 00 00
	00		 mov	 DWORD PTR [edx+164], ecx
$LN8@gObjLevelU:

; 7962 : 
; 7963 : #ifdef SECOND_QUEST
; 7964 : 	if( lpObj->PlusStatQuestClear )

  001a7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001aa	0f b6 88 8c 00
	00 00		 movzx	 ecx, BYTE PTR [eax+140]
  001b1	85 c9		 test	 ecx, ecx
  001b3	74 3e		 je	 SHORT $LN9@gObjLevelU

; 7965 : 	{	// +1     
; 7966 : 		lpObj->LevelUpPoint += g_GlobalConfig.m_iPowerUP_Points;

  001b5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b8	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  001be	03 0d c4 00 00
	00		 add	 ecx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+196
  001c4	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001c7	89 8a a4 00 00
	00		 mov	 DWORD PTR [edx+164], ecx

; 7967 : 		LogAddTD("[%s][%s] LevelUp PlusStatQuest Clear AddStat %d", lpObj->AccountID, lpObj->Name, lpObj->LevelUpPoint);

  001cd	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d0	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  001d6	51		 push	 ecx
  001d7	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001da	83 c2 73	 add	 edx, 115		; 00000073H
  001dd	52		 push	 edx
  001de	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e1	83 c0 68	 add	 eax, 104		; 00000068H
  001e4	50		 push	 eax
  001e5	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@KDBPKGIM@?$FL?$CFs?$FN?$FL?$CFs?$FN?5LevelUp?5PlusStatQuest?5@
  001ea	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001f0	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@gObjLevelU:

; 7968 : 	}
; 7969 : #endif
; 7970 : 
; 7971 : #ifdef MODIFY_LIFEANDMANA_BUG_LEVELUP_RELOGIN_20065018
; 7972 : 	// AddLife AddMana    .
; 7973 : 	gObjCalCharacter(lpObj->m_Index);

  001f3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f8	51		 push	 ecx
  001f9	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  001fe	83 c4 04	 add	 esp, 4

; 7974 : #endif // MODIFY_LIFEANDMANA_BUG_LEVELUP_RELOGIN_20065018
; 7975 : 	
; 7976 : 	lpObj->MaxLife += DCInfo.DefClass[lpObj->Class].LevelLife;

  00201	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00204	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0020b	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  00211	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00214	f3 0f 10 80 c0
	00 00 00	 movss	 xmm0, DWORD PTR [eax+192]
  0021c	f3 0f 58 82 10
	00 00 00	 addss	 xmm0, DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+16]
  00224	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00227	f3 0f 11 81 c0
	00 00 00	 movss	 DWORD PTR [ecx+192], xmm0

; 7977 : 
; 7978 : 	if(g_GlobalConfig.m_bLimitLife && lpObj->MaxLife > g_GlobalConfig.m_iLimitLife)

  0022f	83 3d 48 00 00
	00 00		 cmp	 DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+72, 0
  00236	74 2b		 je	 SHORT $LN10@gObjLevelU
  00238	f3 0f 2a 05 d0
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+208
  00240	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00243	f3 0f 10 88 c0
	00 00 00	 movss	 xmm1, DWORD PTR [eax+192]
  0024b	0f 2f c8	 comiss	 xmm1, xmm0
  0024e	76 13		 jbe	 SHORT $LN10@gObjLevelU

; 7979 : 		lpObj->MaxLife = g_GlobalConfig.m_iLimitLife;

  00250	f3 0f 2a 05 d0
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+208
  00258	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0025b	f3 0f 11 80 c0
	00 00 00	 movss	 DWORD PTR [eax+192], xmm0
$LN10@gObjLevelU:

; 7980 : 
; 7981 : 	lpObj->MaxMana += DCInfo.DefClass[lpObj->Class].LevelMana;

  00263	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00266	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0026d	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  00273	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00276	f3 0f 10 80 d4
	00 00 00	 movss	 xmm0, DWORD PTR [eax+212]
  0027e	f3 0f 58 82 1c
	00 00 00	 addss	 xmm0, DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+28]
  00286	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00289	f3 0f 11 81 d4
	00 00 00	 movss	 DWORD PTR [ecx+212], xmm0

; 7982 : 	lpObj->Life = lpObj->MaxLife;

  00291	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00294	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00297	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  0029d	89 90 bc 00 00
	00		 mov	 DWORD PTR [eax+188], edx

; 7983 : 	lpObj->Mana = lpObj->MaxMana;	

  002a3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a6	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002a9	8b 91 d4 00 00
	00		 mov	 edx, DWORD PTR [ecx+212]
  002af	89 90 d0 00 00
	00		 mov	 DWORD PTR [eax+208], edx

; 7984 : 
; 7985 : #ifdef MODIFY_LIFEANDMANA_BUG_LEVELUP_RELOGIN_20065018
; 7986 : 	//   AddLife, AddMana  .
; 7987 : 	lpObj->Life = lpObj->MaxLife + lpObj->AddLife;

  002b5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002b8	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  002c0	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002c3	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  002cb	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002ce	f3 0f 11 82 bc
	00 00 00	 movss	 DWORD PTR [edx+188], xmm0

; 7988 : 	lpObj->Mana = lpObj->MaxMana + lpObj->AddMana;

  002d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d9	f3 0f 2a 80 10
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+272]
  002e1	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002e4	f3 0f 58 81 d4
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+212]
  002ec	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002ef	f3 0f 11 82 d0
	00 00 00	 movss	 DWORD PTR [edx+208], xmm0

; 7989 : 	// SD 
; 7990 : 	#ifdef ADD_SHIELD_POINT_01_20060403
; 7991 : 		gObjCalcShieldPoint(lpObj);
; 7992 : 		lpObj->iShield = lpObj->iMaxShield + lpObj->iAddShield;
; 7993 : 		//    
; 7994 : 		GCReFillSend(lpObj->m_Index, (WORD)(lpObj->Life), 0xFF, 0, (WORD)(lpObj->iShield));
; 7995 : 	#endif // ADD_SHIELD_POINT_01_20060403
; 7996 : #endif // MODIFY_LIFEANDMANA_BUG_LEVELUP_RELOGIN_20065018
; 7997 : 
; 7998 : 	gObjNextExpCal(lpObj);

  002f7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002fa	50		 push	 eax
  002fb	e8 00 00 00 00	 call	 ?gObjNextExpCal@@YAXPAVOBJECTSTRUCT@@@Z ; gObjNextExpCal
  00300	83 c4 04	 add	 esp, 4

; 7999 : 	
; 8000 : 	LogAddTD(lMsg.Get(520), lpObj->AccountID, lpObj->Name, lpObj->Level);

  00303	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00306	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0030d	51		 push	 ecx
  0030e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00311	83 c2 73	 add	 edx, 115		; 00000073H
  00314	52		 push	 edx
  00315	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00318	83 c0 68	 add	 eax, 104		; 00000068H
  0031b	50		 push	 eax
  0031c	68 08 02 00 00	 push	 520			; 00000208H
  00321	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00326	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0032c	50		 push	 eax
  0032d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00333	83 c4 10	 add	 esp, 16			; 00000010H

; 8001 : 
; 8002 : #ifdef ADD_SKILL_MUSE_ELF_INFINITYARROW_20060406
; 8003 : 	//  220     
; 8004 : 	if( lpObj->Class == CLASS_ELF && lpObj->Level >= g_SkillAdditionInfo.GetInfinityArrowUseLevel() && lpObj->ChangeUP == 1 )
; 8005 : 	{
; 8006 : 		int iAddSkillPosition = gObjMagicAdd( lpObj, AT_SKILL_INFINITY_ARROW, 0 );
; 8007 : 		if( iAddSkillPosition >= 0 )
; 8008 : 		{					
; 8009 : 			GCMagicListOneSend( lpObj->m_Index, iAddSkillPosition, AT_SKILL_INFINITY_ARROW, 220, 0 );
; 8010 : 			LogAddTD( "[%s][%s] Add Infinity Arrow Skill (Character Level : %d)(ChangeUp: %d)"
; 8011 : 						, lpObj->AccountID, lpObj->Name, lpObj->Level, lpObj->ChangeUP );
; 8012 : 		}
; 8013 : 		else
; 8014 : 		{
; 8015 : 			// !! !!
; 8016 : 			LogAddTD( "[%s][%s] Fail - Add Infinity Arrow Skill (Character Level : %d)(ChangeUp: %d)"
; 8017 : 						, lpObj->AccountID, lpObj->Name, lpObj->Level, lpObj->ChangeUP );
; 8018 : 		}
; 8019 : 	}
; 8020 : #endif
; 8021 : 	
; 8022 : 	//   .
; 8023 : 	//GJSetCharacterInfo(lpObj, lpObj->m_Index); //FIX DS
; 8024 : 	//LogAdd("   ");
; 8025 : 
; 8026 : #ifdef NEW_FORSKYLAND2
; 8027 : 	gObjSetBP(lpObj->m_Index);

  00336	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00339	8b 08		 mov	 ecx, DWORD PTR [eax]
  0033b	51		 push	 ecx
  0033c	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP
  00341	83 c4 04	 add	 esp, 4

; 8028 : #endif
; 8029 : 	
; 8030 : #ifdef ADD_MINUS_STAT_SYSTEM_USING_FRUIT_20050712
; 8031 : 	GCLevelUpMsgSend(lpObj->m_Index );
; 8032 : #else
; 8033 : 	short AddPoint		= 0;

  00344	33 c0		 xor	 eax, eax
  00346	66 89 45 fc	 mov	 WORD PTR _AddPoint$[ebp], ax

; 8034 : 	short MaxAddPoint	= 0;

  0034a	33 c0		 xor	 eax, eax
  0034c	66 89 45 f8	 mov	 WORD PTR _MaxAddPoint$[ebp], ax

; 8035 : 	gObjGetStatPointState(lpObj->m_Index, AddPoint, MaxAddPoint);

  00350	8d 45 f8	 lea	 eax, DWORD PTR _MaxAddPoint$[ebp]
  00353	50		 push	 eax
  00354	8d 4d fc	 lea	 ecx, DWORD PTR _AddPoint$[ebp]
  00357	51		 push	 ecx
  00358	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0035b	8b 02		 mov	 eax, DWORD PTR [edx]
  0035d	50		 push	 eax
  0035e	e8 00 00 00 00	 call	 ?gObjGetStatPointState@@YAXHAAF0@Z ; gObjGetStatPointState
  00363	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8036 : 
; 8037 : 	GCLevelUpMsgSend(lpObj->m_Index, lpObj->Level, lpObj->LevelUpPoint, 

  00366	0f b7 45 f8	 movzx	 eax, WORD PTR _MaxAddPoint$[ebp]
  0036a	50		 push	 eax
  0036b	0f b7 4d fc	 movzx	 ecx, WORD PTR _AddPoint$[ebp]
  0036f	51		 push	 ecx
  00370	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00373	8b 82 ec 00 00
	00		 mov	 eax, DWORD PTR [edx+236]
  00379	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0037c	03 81 f0 00 00
	00		 add	 eax, DWORD PTR [ecx+240]
  00382	50		 push	 eax
  00383	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00386	f3 0f 2a 82 10
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [edx+272]
  0038e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00391	f3 0f 58 80 d4
	00 00 00	 addss	 xmm0, DWORD PTR [eax+212]
  00399	f3 0f 2c c8	 cvttss2si ecx, xmm0
  0039d	0f b7 d1	 movzx	 edx, cx
  003a0	52		 push	 edx
  003a1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003a4	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  003ac	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003af	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  003b7	f3 0f 2c d0	 cvttss2si edx, xmm0
  003bb	0f b7 c2	 movzx	 eax, dx
  003be	50		 push	 eax
  003bf	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003c2	0f b7 91 a4 00
	00 00		 movzx	 edx, WORD PTR [ecx+164]
  003c9	52		 push	 edx
  003ca	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003cd	0f b7 88 a0 00
	00 00		 movzx	 ecx, WORD PTR [eax+160]
  003d4	51		 push	 ecx
  003d5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003d8	8b 02		 mov	 eax, DWORD PTR [edx]
  003da	50		 push	 eax
  003db	e8 00 00 00 00	 call	 ?GCLevelUpMsgSend@@YAXHGGGGGFF@Z ; GCLevelUpMsgSend
  003e0	83 c4 20	 add	 esp, 32			; 00000020H

; 8038 : 					 (WORD)(lpObj->MaxLife+lpObj->AddLife), 
; 8039 : 					 (WORD)(lpObj->MaxMana+lpObj->AddMana), 
; 8040 : 					 lpObj->MaxBP+lpObj->AddBP,
; 8041 : 					 AddPoint, MaxAddPoint);
; 8042 : #endif // ADD_MINUS_STAT_SYSTEM_USING_FRUIT_20050712
; 8043 : 
; 8044 : 	gObjCalcMaxLifePower(lpObj->m_Index);	//    

  003e3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  003e8	51		 push	 ecx
  003e9	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower
  003ee	83 c4 04	 add	 esp, 4

; 8045 : 
; 8046 : #ifdef ADD_LOG_400LEVELUP_PARTY_20070628	// 400      
; 8047 : 	if(lpObj->Level == 400 && lpObj->PartyNumber >=0)
; 8048 : 	{
; 8049 : 		int partynum = lpObj->PartyNumber;
; 8050 : 		char partyLog[256];
; 8051 : 		int number;
; 8052 : 		sprintf(partyLog, "400 LevelUp (%s)(%s) Party ", lpObj->AccountID, lpObj->Name);
; 8053 : 
; 8054 : 		for( int n=0; n<MAX_PARTYUSER; n++)
; 8055 : 		{
; 8056 : 			number = gParty.m_PartyS[partynum].Number[n];
; 8057 : 			if( number >= 0 )
; 8058 : 			{
; 8059 : 				int noffSet = strlen(partyLog);
; 8060 : 				sprintf(partyLog + noffSet, ",(%s)(%s) ",gObj[number].AccountID, gObj[number].Name);								
; 8061 : 			}
; 8062 : 		}
; 8063 : 
; 8064 : 		LogAddTD(partyLog);
; 8065 : 	}
; 8066 : #endif
; 8067 : 
; 8068 : #ifdef MAX_LEVEL_BLOCK_GAIN_EXPERIENCE_20050613
; 8069 : 	return true;

  003f1	b0 01		 mov	 al, 1
$LN1@gObjLevelU:

; 8070 : #endif
; 8071 : }

  003f3	5f		 pop	 edi
  003f4	5e		 pop	 esi
  003f5	5b		 pop	 ebx
  003f6	8b e5		 mov	 esp, ebp
  003f8	5d		 pop	 ebp
  003f9	c3		 ret	 0
?gObjLevelUp@@YA_NPAVOBJECTSTRUCT@@HHH@Z ENDP		; gObjLevelUp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGetNumber@@YAHHAAH0@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_UN$ = 12						; size = 4
_DBN$ = 16						; size = 4
?gObjGetNumber@@YAHHAAH0@Z PROC				; gObjGetNumber, COMDAT

; 6927 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6928 : 	if( aIndex < 0 || aIndex > MAX_OBJECT-1 )

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@gObjGetNum
  0000f	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00016	7e 20		 jle	 SHORT $LN2@gObjGetNum
$LN3@gObjGetNum:

; 6929 : 	{
; 6930 : 		LogAdd("error : %s %d",__FILE__, __LINE__);

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjGetNumber@@YAHHAAH0@Z@4JA
  0001d	83 c0 03	 add	 eax, 3
  00020	50		 push	 eax
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6931 : 		return FALSE;

  00034	33 c0		 xor	 eax, eax
  00036	eb 31		 jmp	 SHORT $LN1@gObjGetNum
$LN2@gObjGetNum:

; 6932 : 	}
; 6933 : 	UN = gObj[aIndex].UserNumber;

  00038	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _UN$[ebp]
  00042	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00048	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  0004c	89 01		 mov	 DWORD PTR [ecx], eax

; 6934 : 	DBN= gObj[aIndex].DBNumber;

  0004e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00055	8b 4d 10	 mov	 ecx, DWORD PTR _DBN$[ebp]
  00058	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005e	8b 44 02 2c	 mov	 eax, DWORD PTR [edx+eax+44]
  00062	89 01		 mov	 DWORD PTR [ecx], eax

; 6935 : 	
; 6936 : 	return 1;

  00064	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjGetNum:

; 6937 : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?gObjGetNumber@@YAHHAAH0@Z ENDP				; gObjGetNumber
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGetUserNumber@@YAHH@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv67 = -72						; size = 4
_usernumber$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?gObjGetUserNumber@@YAHH@Z PROC				; gObjGetUserNumber, COMDAT

; 6910 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6911 : 	int usernumber;
; 6912 : 
; 6913 : 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT) )

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN6@gObjGetUse
  0000f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN7@gObjGetUse
$LN6@gObjGetUse:
  00018	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN4@gObjGetUse
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN5@gObjGetUse
$LN4@gObjGetUse:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN5@gObjGetUse:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN7@gObjGetUse:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 20		 jne	 SHORT $LN2@gObjGetUse

; 6914 : 	{
; 6915 : 		LogAdd("error : %s %d",__FILE__, __LINE__);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjGetUserNumber@@YAHH@Z@4JA
  00042	83 c0 05	 add	 eax, 5
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6916 : 		return 0;

  00059	33 c0		 xor	 eax, eax
  0005b	eb 17		 jmp	 SHORT $LN1@gObjGetUse
$LN2@gObjGetUse:

; 6917 : 	}
; 6918 : 	usernumber = gObj[aIndex].UserNumber;

  0005d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006a	8b 54 01 28	 mov	 edx, DWORD PTR [ecx+eax+40]
  0006e	89 55 fc	 mov	 DWORD PTR _usernumber$[ebp], edx

; 6919 : 	
; 6920 : 	return usernumber;

  00071	8b 45 fc	 mov	 eax, DWORD PTR _usernumber$[ebp]
$LN1@gObjGetUse:

; 6921 : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?gObjGetUserNumber@@YAHH@Z ENDP				; gObjGetUserNumber
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjViewportPaint@@YAXPAUHWND__@@F@Z
_TEXT	SEGMENT
tv68 = -360						; size = 4
tv69 = -356						; size = 4
_totalplayer$ = -288					; size = 4
_playerc$ = -284					; size = 4
_count3$ = -280						; size = 4
_count2$ = -276						; size = 4
_count$ = -272						; size = 4
_szTemp$ = -268						; size = 256
_hdc$ = -12						; size = 4
_n$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_hWnd$ = 8						; size = 4
_aIndex$ = 12						; size = 2
?gObjViewportPaint@@YAXPAUHWND__@@F@Z PROC		; gObjViewportPaint, COMDAT

; 20091: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 20092: 	int n;
; 20093: 	HDC hdc;
; 20094: 	char szTemp[256];
; 20095: 	int count=0, count2=0, count3=0, playerc=0, totalplayer=0;

  00016	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$[ebp], 0
  00020	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _count2$[ebp], 0
  0002a	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _count3$[ebp], 0
  00034	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _playerc$[ebp], 0
  0003e	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _totalplayer$[ebp], 0

; 20096: 	//RECT rect;
; 20097: 
; 20098: 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT ))

  00048	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0004c	85 c0		 test	 eax, eax
  0004e	7d 0c		 jge	 SHORT $LN19@gObjViewpo
  00050	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], 0
  0005a	eb 2e		 jmp	 SHORT $LN20@gObjViewpo
$LN19@gObjViewpo:
  0005c	0f bf 4d 0c	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  00060	81 f9 e7 1c 00
	00		 cmp	 ecx, 7399		; 00001ce7H
  00066	7e 0c		 jle	 SHORT $LN17@gObjViewpo
  00068	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv68[ebp], 0
  00072	eb 0a		 jmp	 SHORT $LN18@gObjViewpo
$LN17@gObjViewpo:
  00074	c7 85 98 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv68[ebp], 1
$LN18@gObjViewpo:
  0007e	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR tv68[ebp]
  00084	89 95 9c fe ff
	ff		 mov	 DWORD PTR tv69[ebp], edx
$LN20@gObjViewpo:
  0008a	83 bd 9c fe ff
	ff 00		 cmp	 DWORD PTR tv69[ebp], 0
  00091	75 05		 jne	 SHORT $LN5@gObjViewpo

; 20099: 	{
; 20100: 		
; 20101: 		return;

  00093	e9 13 02 00 00	 jmp	 $LN1@gObjViewpo
$LN5@gObjViewpo:

; 20102: 	}
; 20103: 
; 20104: 	hdc = GetDC(hWnd);

  00098	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  0009b	50		 push	 eax
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4
  000a2	89 45 f4	 mov	 DWORD PTR _hdc$[ebp], eax

; 20105: 	
; 20106: /*
; 20107: 	for( n=0; n<MAXVIEWPORTOBJECT; n++)
; 20108: 	{
; 20109: 		if( gObj[aIndex].VpPlayer[n].state )
; 20110: 		{
; 20111: 			count3++;
; 20112: 		}
; 20113: 	}
; 20114: */
; 20115: 
; 20116: /*
; 20117: 	for( n=0; n<MAXVIEWPORTOBJECT; n++)
; 20118: 	{
; 20119: 		if( gObj[aIndex].VpPlayer2[n].state )
; 20120: 		//if( gObj[aIndex].VpPlayer[n].number != -1 )
; 20121: 		{
; 20122: 			number = gObj[aIndex].VpPlayer2[n].number;
; 20123: 			rect.left = 400+gObj[number].X;
; 20124: 			rect.right= 400+gObj[number].X+3;
; 20125: 			rect.top  = 50+gObj[number].Y;			
; 20126: 			rect.bottom= 50+gObj[number].Y+3;
; 20127: 			FillRect(hdc, &rect, (HBRUSH)GetStockObject(BLACK_BRUSH));
; 20128: 			wsprintf(szTemp, "%d", n);
; 20129: 			TextOut(hdc, 400, 0, szTemp, strlen(szTemp));
; 20130: 			
; 20131: 			count2++;
; 20132: 		}
; 20133: 	}	
; 20134: */
; 20135: 
; 20136: /*
; 20137: 	if( gCurPaintType == 1 )
; 20138: 	{
; 20139: 		COLORREF prgb;
; 20140: 		int x, y;
; 20141: 		
; 20142: 		prgb = RGB(210,210,210);
; 20143: 		if( MapC[gCurPaintMapNumber].m_attrbuf != NULL )
; 20144: 		{
; 20145: 			for( y=0;y<255;y++)
; 20146: 			{
; 20147: 				for( x=0;x<255;x++)
; 20148: 				{
; 20149: 					if( //MapC[gCurPaintMapNumber].m_attrbuf[(y*MAX_TERRAIN_SIZE)+x])	
; 20150: 						//(MapC[gCurPaintMapNumber].m_attrbuf[(y*MAX_TERRAIN_SIZE)+x]&MAP_ATTR_SAFTYZONE) == MAP_ATTR_SAFTYZONE )
; 20151: 						(MapC[gCurPaintMapNumber].m_attrbuf[(y*MAX_TERRAIN_SIZE)+x]&MAP_ATTR_BLOCK) == MAP_ATTR_BLOCK ||
; 20152: 						(MapC[gCurPaintMapNumber].m_attrbuf[(y*MAX_TERRAIN_SIZE)+x]&MAP_ATTR_HOLLOW) == MAP_ATTR_HOLLOW )
; 20153: 					{
; 20154: 						rect.left = 400+y;
; 20155: 						rect.right= 400+y+2;
; 20156: 						rect.top  = 51+x;
; 20157: 						rect.bottom= 51+x+2;
; 20158: 						
; 20159: 						//FillRect(hdc, &rect, (HBRUSH)GetStockObject(LTGRAY_BRUSH));
; 20160: 						SetPixel(hdc, rect.left, rect.top, prgb);
; 20161: 					}
; 20162: 				}
; 20163: 			}
; 20164: 		}
; 20165: 	}	
; 20166: 	else
; 20167: 	{
; 20168: 		COLORREF prgb;
; 20169: 				
; 20170: 		prgb = RGB(255,0,0);
; 20171: 		for( int n=0; n<MAX_MAPITEM; n++)
; 20172: 		{
; 20173: 			//   ..		
; 20174: 			//    .
; 20175: 			if( MapC[gCurPaintMapNumber].m_cItem[n].IsItem() )
; 20176: 			{
; 20177: 				rect.left = 400+MapC[gCurPaintMapNumber].m_cItem[n].py;
; 20178: 				rect.right= 400+MapC[gCurPaintMapNumber].m_cItem[n].py+2;
; 20179: 				rect.top  = 51+MapC[gCurPaintMapNumber].m_cItem[n].px;
; 20180: 				rect.bottom= 51+MapC[gCurPaintMapNumber].m_cItem[n].px+2;
; 20181: 						
; 20182: 				//FillRect(hdc, &rect, (HBRUSH)RGB(255,0,0));//(HBRUSH)GetStockObject(LTGRAY_BRUSH));
; 20183: 				SetPixel(hdc, rect.left, rect.top, prgb);
; 20184: 				SetPixel(hdc, rect.left+1, rect.top, prgb);
; 20185: 				SetPixel(hdc, rect.left, rect.top+1, prgb);
; 20186: 				SetPixel(hdc, rect.left+1, rect.top+1, prgb);
; 20187: 			}
; 20188: 		}
; 20189: 	}
; 20190: */
; 20191: 
; 20192: 
; 20193: 
; 20194: 	for( n=0; n<MAX_OBJECT; n++)

  000a5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  000ac	eb 09		 jmp	 SHORT $LN4@gObjViewpo
$LN2@gObjViewpo:
  000ae	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000b1	83 c0 01	 add	 eax, 1
  000b4	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjViewpo:
  000b7	81 7d f8 e8 1c
	00 00		 cmp	 DWORD PTR _n$[ebp], 7400 ; 00001ce8H
  000be	0f 8d d1 00 00
	00		 jge	 $LN3@gObjViewpo

; 20195: 	{	
; 20196: 		if( gObj[n].Live && gObj[n].Connected && gCurPaintMapNumber == gObj[n].MapNumber)

  000c4	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  000cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d1	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  000d6	85 d2		 test	 edx, edx
  000d8	74 57		 je	 SHORT $LN6@gObjViewpo
  000da	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e7	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  000ec	74 43		 je	 SHORT $LN6@gObjViewpo
  000ee	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  000f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fb	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00103	39 15 00 00 00
	00		 cmp	 DWORD PTR ?gCurPaintMapNumber@@3HA, edx ; gCurPaintMapNumber
  00109	75 26		 jne	 SHORT $LN6@gObjViewpo

; 20197: 		{				
; 20198: 			if( gObj[n].Type == OBJTYPE_CHARACTER )	

  0010b	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  00112	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00118	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0011d	83 fa 01	 cmp	 edx, 1
  00120	75 0f		 jne	 SHORT $LN6@gObjViewpo

; 20199: 			{				
; 20200: 				
; 20201: 				//rect.left  = 400+gObj[n].Y;
; 20202: 				//rect.right = 400+gObj[n].Y+4;
; 20203: 				//rect.top   = 51+gObj[n].X;			
; 20204: 				//rect.bottom= 51+gObj[n].X+4;
; 20205: 				//FillRect(hdc, &rect, (HBRUSH)GetStockObject(BLACK_BRUSH));
; 20206: 				
; 20207: 				playerc++;

  00122	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _playerc$[ebp]
  00128	83 c0 01	 add	 eax, 1
  0012b	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _playerc$[ebp], eax
$LN6@gObjViewpo:

; 20208: 			}
; 20209: 			else 
; 20210: 			{
; 20211: 				
; 20212: 				//FillRect(hdc, &rect, (HBRUSH)GetStockObject(GRAY_BRUSH));
; 20213: 				//if( gObj[n].m_RecallMon >= 0 )
; 20214: 				{
; 20215: 				//	rect.left  = 400+gObj[n].Y;
; 20216: 				//	rect.right = 400+gObj[n].Y+2;
; 20217: 				//	rect.top   = 51+gObj[n].X;			
; 20218: 				//	rect.bottom= 51+gObj[n].X+2;			
; 20219: 				//	FillRect(hdc, &rect, (HBRUSH)GetStockObject(BLACK_BRUSH));
; 20220: 				}
; 20221: 								
; 20222: 			}
; 20223: 			
; 20224: 		}
; 20225: 		if( gObj[n].Type == OBJTYPE_CHARACTER && gObj[n].Connected )

  00131	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013e	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00143	83 fa 01	 cmp	 edx, 1
  00146	75 25		 jne	 SHORT $LN9@gObjViewpo
  00148	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  0014f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00155	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  0015a	74 11		 je	 SHORT $LN9@gObjViewpo

; 20226: 		{
; 20227: 			totalplayer ++;

  0015c	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _totalplayer$[ebp]
  00162	83 c0 01	 add	 eax, 1
  00165	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _totalplayer$[ebp], eax

; 20228: 		}

  0016b	eb 23		 jmp	 SHORT $LN10@gObjViewpo
$LN9@gObjViewpo:

; 20229: 		else if( gObj[n].Connected )

  0016d	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  00174	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017a	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  0017f	74 0f		 je	 SHORT $LN10@gObjViewpo

; 20230: 		{
; 20231: 			count++;

  00181	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  00187	83 c0 01	 add	 eax, 1
  0018a	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _count$[ebp], eax
$LN10@gObjViewpo:

; 20232: 		}
; 20233: 	}

  00190	e9 19 ff ff ff	 jmp	 $LN2@gObjViewpo
$LN3@gObjViewpo:

; 20234: 	
; 20235: 
; 20236: 
; 20237: /*
; 20238: 	for( y=0; y<8; y++)
; 20239: 	{
; 20240: 		for( x=0; x<8; x++)
; 20241: 		{
; 20242: 			if( gObj[274].InventoryMap[y][x] == 0xFF )
; 20243: 			{
; 20244: 				rect.left = 350+(x*4);
; 20245: 				rect.right= 350+(x*4)+2;
; 20246: 				rect.top  = 51+(y*4);
; 20247: 				rect.bottom= 51+(y*4)+2;
; 20248: 				FillRect(hdc, &rect, (HBRUSH)GetStockObject(DKGRAY_BRUSH));
; 20249: 			}
; 20250: 			else FillRect(hdc, &rect, (HBRUSH)GetStockObject(BLACK_BRUSH));
; 20251: 		}
; 20252: 	}
; 20253: */
; 20254: 
; 20255: #ifdef ADD_NEW_MONSTER_SYSTEM_02_20050725
; 20256: //   !
; 20257: 
; 20258: 	if( gCurPaintType == 1 )
; 20259: 	{
; 20260: 		RECT rect;
; 20261: 
; 20262: 		int iStartX		= 100;
; 20263: 		int iStartY		= 50;
; 20264: 		int iWidth		= 1;
; 20265: 		int iHeight		= 1;
; 20266: 		int iMagnifying = 3;
; 20267: 
; 20268: 		hdc = GetDC(hWnd);
; 20269: 		
; 20270: 		// 1. >  
; 20271: 		int x, y;
; 20272: 
; 20273: 		HBRUSH hCharacterBrush	= CreateSolidBrush( RGB(255,0,0) );
; 20274: 		HBRUSH hMonsterBrush	= CreateSolidBrush( RGB(128,128,128) );
; 20275: 		HBRUSH hNpcBrush		= CreateSolidBrush( RGB(0,255,255) );
; 20276: 		HBRUSH hItemBrush		= CreateSolidBrush( RGB(0,0,255) );
; 20277: 		HBRUSH hCrywolfMovePath	= CreateSolidBrush( RGB(0,255,0) );
; 20278: 		
; 20279: 
; 20280: 
; 20281: 		int iOldBkMode = SetBkMode(hdc, TRANSPARENT); 
; 20282: 
; 20283: 		if( MapC[gCurPaintMapNumber].m_attrbuf != NULL )
; 20284: 		{
; 20285: 			for( y=0;y<255;y++)
; 20286: 			{
; 20287: 				for( x=0;x<255;x++)
; 20288: 				{
; 20289: 					if( (MapC[gCurPaintMapNumber].m_attrbuf[(y*MAX_TERRAIN_SIZE)+x]&MAP_ATTR_BLOCK) == MAP_ATTR_BLOCK 
; 20290: 						|| (MapC[gCurPaintMapNumber].m_attrbuf[(y*MAX_TERRAIN_SIZE)+x]&MAP_ATTR_HOLLOW) == MAP_ATTR_HOLLOW )
; 20291: 					{
; 20292: 						rect.left	= iStartX  + y * iWidth * iMagnifying;
; 20293: 						rect.right	= iStartX  + y * iWidth * iMagnifying + iWidth * iMagnifying;
; 20294: 
; 20295: 						rect.top	= iStartY  + x * iHeight * iMagnifying;
; 20296: 						rect.bottom = iStartY  + x * iHeight * iMagnifying + iHeight * iMagnifying;
; 20297: 
; 20298: 						
; 20299: 						FillRect(hdc, &rect, (HBRUSH)GetStockObject(LTGRAY_BRUSH));
; 20300: 					}
; 20301: 				}
; 20302: 			}
; 20303: 		}
; 20304: 		// 4. >       
; 20305: 		
; 20306: 		if( TMonsterAIElement::s_MonsterAIMovePath != NULL && TMonsterAIElement::s_MonsterAIMovePath[MAP_INDEX_CRYWOLF_FIRSTZONE].m_bDataLoad )
; 20307: 		{
; 20308: 			TMonsterAIMovePath &MovePath = TMonsterAIElement::s_MonsterAIMovePath[MAP_INDEX_CRYWOLF_FIRSTZONE];	
; 20309: 
; 20310: 			for( int i=0; i<MovePath.m_iMovePathSpotCount; i++ )
; 20311: 			{
; 20312: 				rect.left	= iStartX  + MovePath.m_MovePathInfo[i].m_iPathY * iWidth * iMagnifying;
; 20313: 				rect.right	= iStartX  + MovePath.m_MovePathInfo[i].m_iPathY * iWidth * iMagnifying + iWidth * iMagnifying;
; 20314: 				
; 20315: 				rect.top	= iStartY  + MovePath.m_MovePathInfo[i].m_iPathX * iHeight * iMagnifying;
; 20316: 				rect.bottom = iStartY  + MovePath.m_MovePathInfo[i].m_iPathX * iHeight * iMagnifying + iHeight * iMagnifying;			
; 20317: 				FillRect(hdc, &rect, hCrywolfMovePath );
; 20318: 
; 20319: 				CString szDesc;
; 20320: 				szDesc.Format("(%d,%d)", MovePath.m_MovePathInfo[i].m_iPathX, MovePath.m_MovePathInfo[i].m_iPathY );
; 20321: 				//TextOut( hdc, rect.left, rect.bottom, szDesc, szDesc.GetLength());
; 20322: 			}
; 20323: 			
; 20324: 		}
; 20325: 
; 20326: 		// 4. >       
; 20327: 		
; 20328: 	
; 20329: 
; 20330: 		// 2. > OBJECT 
; 20331: 		for( n=0; n<MAX_OBJECT; n++)
; 20332: 		{		
; 20333: 			if( gObj[n].Live && gObj[n].Connected && gCurPaintMapNumber == gObj[n].MapNumber)
; 20334: 			{				
; 20335: 				if( gObj[n].Type == OBJTYPE_CHARACTER )	
; 20336: 				{				
; 20337: 					rect.left	= iStartX  + gObj[n].Y * iWidth * iMagnifying;
; 20338: 					rect.right	= iStartX  + gObj[n].Y * iWidth * iMagnifying + (iWidth+2) * iMagnifying;
; 20339: 
; 20340: 					rect.top	= iStartY  + gObj[n].X * iHeight * iMagnifying;
; 20341: 					rect.bottom = iStartY  + gObj[n].X * iHeight * iMagnifying + (iHeight+2) * iMagnifying;
; 20342: 
; 20343: 					FillRect(hdc, &rect, hCharacterBrush );
; 20344: 					CString szName;
; 20345: 					szName.Format("%s (%d,%d)", gObj[n].Name, gObj[n].X, gObj[n].Y );
; 20346: 					TextOut( hdc, rect.left, rect.bottom, szName, szName.GetLength());
; 20347: 					
; 20348: 				}
; 20349: 				else if( gObj[n].Type == OBJTYPE_MONSTER )
; 20350: 				{
; 20351: 					rect.left	= iStartX  + gObj[n].Y * iWidth * iMagnifying;
; 20352: 					rect.right	= iStartX  + gObj[n].Y * iWidth * iMagnifying + iWidth * iMagnifying;
; 20353: 
; 20354: 					rect.top	= iStartY  + gObj[n].X * iHeight * iMagnifying;
; 20355: 					rect.bottom = iStartY  + gObj[n].X * iHeight * iMagnifying + iHeight * iMagnifying;			
; 20356: 
; 20357: 					FillRect(hdc, &rect, hMonsterBrush );
; 20358: 
; 20359: 					if( gObj[n].m_iCurrentAI )
; 20360: 					{
; 20361: 						//  
; 20362: 						if( gObj[n].m_iGroupMemberGuid == 0 )
; 20363: 						{
; 20364: 							FillRect(hdc, &rect, hCharacterBrush );
; 20365: 							CString szDesc;
; 20366: 							//szDesc.Format("%d (%d,%d)", gObj[n].m_Index, gObj[n].X, gObj[n].Y );
; 20367: 							szDesc.Format("G(%d,%d)", gObj[n].m_iGroupNumber, gObj[n].m_iGroupMemberGuid );
; 20368: 							TextOut( hdc, rect.left, rect.bottom, szDesc, szDesc.GetLength());
; 20369: 						}
; 20370: 						
; 20371: 					}
; 20372: 				
; 20373: 				}
; 20374: 				else if( gObj[n].Type == OBJTYPE_NPC )
; 20375: 				{
; 20376: 					rect.left	= iStartX  + gObj[n].Y * iWidth * iMagnifying;
; 20377: 					rect.right	= iStartX  + gObj[n].Y * iWidth * iMagnifying + iWidth * iMagnifying;
; 20378: 
; 20379: 					rect.top	= iStartY  + gObj[n].X * iHeight * iMagnifying;
; 20380: 					rect.bottom = iStartY  + gObj[n].X * iHeight * iMagnifying + iHeight * iMagnifying;			
; 20381: 					FillRect(hdc, &rect, hNpcBrush );
; 20382: 				}
; 20383: 				
; 20384: 			}
; 20385: 		}
; 20386: 
; 20387: 		// 3. >    
; 20388: 		for( int n=0; n<MAX_MAPITEM; n++)
; 20389: 		{
; 20390: 			if( MapC[gCurPaintMapNumber].m_cItem[n].IsItem() )
; 20391: 			{
; 20392: 				rect.left	= iStartX  + MapC[gCurPaintMapNumber].m_cItem[n].py * iWidth * iMagnifying;
; 20393: 				rect.right	= iStartX  + MapC[gCurPaintMapNumber].m_cItem[n].py * iWidth * iMagnifying + iWidth * iMagnifying;
; 20394: 				
; 20395: 				rect.top	= iStartY  + MapC[gCurPaintMapNumber].m_cItem[n].px * iHeight * iMagnifying;
; 20396: 				rect.bottom = iStartY  + MapC[gCurPaintMapNumber].m_cItem[n].px * iHeight * iMagnifying + iHeight * iMagnifying;			
; 20397: 				FillRect(hdc, &rect, hItemBrush );
; 20398: 				CString szDesc;
; 20399: 				szDesc.Format("%s (%d,%d)", 
; 20400: 					MapC[gCurPaintMapNumber].m_cItem[n].GetName(),
; 20401: 					MapC[gCurPaintMapNumber].m_cItem[n].px,
; 20402: 					MapC[gCurPaintMapNumber].m_cItem[n].py	);
; 20403: 				//TextOut( hdc, rect.left, rect.bottom, szDesc, szDesc.GetLength());
; 20404: 				
; 20405: 			}
; 20406: 		}
; 20407: 
; 20408: 		
; 20409: 
; 20410: 
; 20411: 		DeleteObject( hCharacterBrush );
; 20412: 		DeleteObject( hMonsterBrush );
; 20413: 		DeleteObject( hNpcBrush );
; 20414: 		DeleteObject( hItemBrush );
; 20415: 		DeleteObject( hCrywolfMovePath );
; 20416: 
; 20417: 		SetBkMode(hdc, iOldBkMode);
; 20418: 
; 20419: 	}
; 20420: #endif
; 20421: 
; 20422: 
; 20423: 	gObjTotalUser = totalplayer;

  00195	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _totalplayer$[ebp]
  0019b	a3 00 00 00 00	 mov	 DWORD PTR ?gObjTotalUser@@3HA, eax ; gObjTotalUser

; 20424: 	//wsprintf(szTemp, "recv:%10d  send:%10d  COUNT:%d  VpCount:%d/%d", wsGServer.m_RecvSec,wsGServer.m_SendSec, count, gObj[0].VPCount, count2);
; 20425: 
; 20426: 	wsprintf(szTemp, "COUNT:%d  TotalPlayer : %d  Player(%d):%d VpCount:%d(%d/%d) : item count:%d max:%d", count, totalplayer, aIndex, playerc, gObj[aIndex].VPCount, count3, count2, gItemLoop,gServerMaxUser);

  001a0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gServerMaxUser@@3HA ; gServerMaxUser
  001a5	50		 push	 eax
  001a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gItemLoop@@3HA ; gItemLoop
  001ac	51		 push	 ecx
  001ad	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _count2$[ebp]
  001b3	52		 push	 edx
  001b4	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _count3$[ebp]
  001ba	50		 push	 eax
  001bb	0f bf 4d 0c	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  001bf	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  001c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ca	8b 8c 10 6c 0a
	00 00		 mov	 ecx, DWORD PTR [eax+edx+2668]
  001d1	51		 push	 ecx
  001d2	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _playerc$[ebp]
  001d8	52		 push	 edx
  001d9	0f bf 45 0c	 movsx	 eax, WORD PTR _aIndex$[ebp]
  001dd	50		 push	 eax
  001de	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _totalplayer$[ebp]
  001e4	51		 push	 ecx
  001e5	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR _count$[ebp]
  001eb	52		 push	 edx
  001ec	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@OILHKKPM@COUNT?3?$CFd?5?5TotalPlayer?5?3?5?$CFd?5?5Pla@
  001f1	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  001f7	50		 push	 eax
  001f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  001fe	83 c4 2c	 add	 esp, 44			; 0000002cH

; 20427: 
; 20428: 	if( gXMasEvent )

  00201	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gXMasEvent@@3HA, 0 ; gXMasEvent
  00208	74 14		 je	 SHORT $LN12@gObjViewpo

; 20429: 	{
; 20430: 		strcat(szTemp, ":StarOfXMas");

  0020a	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IBFDBMCH@?3StarOfXMas@
  0020f	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  00215	50		 push	 eax
  00216	e8 00 00 00 00	 call	 _strcat
  0021b	83 c4 08	 add	 esp, 8
$LN12@gObjViewpo:

; 20431: 	}
; 20432: 
; 20433: 	if( gFireCrackerEvent )

  0021e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gFireCrackerEvent@@3HA, 0 ; gFireCrackerEvent
  00225	74 14		 je	 SHORT $LN13@gObjViewpo

; 20434: 	{
; 20435: 		strcat(szTemp, ":FireCracker");

  00227	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KDMPKOEE@?3FireCracker@
  0022c	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 _strcat
  00238	83 c4 08	 add	 esp, 8
$LN13@gObjViewpo:

; 20436: 	}	
; 20437: 
; 20438: 	if( gHeartOfLoveEvent )

  0023b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gHeartOfLoveEvent@@3HA, 0 ; gHeartOfLoveEvent
  00242	74 14		 je	 SHORT $LN14@gObjViewpo

; 20439: 	{
; 20440: 		strcat(szTemp, ":HeartOfLove");

  00244	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MIHFOCLN@?3HeartOfLove@
  00249	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0024f	50		 push	 eax
  00250	e8 00 00 00 00	 call	 _strcat
  00255	83 c4 08	 add	 esp, 8
$LN14@gObjViewpo:

; 20441: 	}
; 20442: 
; 20443: 	if( gMedalEvent )

  00258	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gMedalEvent@@3HA, 0 ; gMedalEvent
  0025f	74 14		 je	 SHORT $LN15@gObjViewpo

; 20444: 	{
; 20445: 		strcat(szTemp, ":MedalEvent");

  00261	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CNBLPJGM@?3MedalEvent@
  00266	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0026c	50		 push	 eax
  0026d	e8 00 00 00 00	 call	 _strcat
  00272	83 c4 08	 add	 esp, 8
$LN15@gObjViewpo:

; 20446: 	}
; 20447: 
; 20448: 	TextOut(hdc, 200, 0, szTemp, strlen(szTemp));

  00275	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0027b	50		 push	 eax
  0027c	e8 00 00 00 00	 call	 _strlen
  00281	83 c4 04	 add	 esp, 4
  00284	50		 push	 eax
  00285	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  0028b	51		 push	 ecx
  0028c	6a 00		 push	 0
  0028e	68 c8 00 00 00	 push	 200			; 000000c8H
  00293	8b 55 f4	 mov	 edx, DWORD PTR _hdc$[ebp]
  00296	52		 push	 edx
  00297	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TextOutA@20

; 20449: 	ReleaseDC(hWnd, hdc);

  0029d	8b 45 f4	 mov	 eax, DWORD PTR _hdc$[ebp]
  002a0	50		 push	 eax
  002a1	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  002a4	51		 push	 ecx
  002a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8
$LN1@gObjViewpo:

; 20450: }

  002ab	5f		 pop	 edi
  002ac	5e		 pop	 esi
  002ad	5b		 pop	 ebx
  002ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b1	33 cd		 xor	 ecx, ebp
  002b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b8	8b e5		 mov	 esp, ebp
  002ba	5d		 pop	 ebp
  002bb	c3		 ret	 0
?gObjViewportPaint@@YAXPAUHWND__@@F@Z ENDP		; gObjViewportPaint
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjStateSetCreate@@YAXH@Z
_TEXT	SEGMENT
_y$1 = -24						; size = 4
_x$2 = -20						; size = 4
_y$3 = -16						; size = 4
_x$4 = -12						; size = 4
_dwNowTick$ = -8					; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjStateSetCreate@@YAXH@Z PROC			; gObjStateSetCreate, COMDAT

; 21277: {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 21278: 	LPOBJECTSTRUCT	lpObj=&gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 21279: 
; 21280: 	if( lpObj->Connected < 3 )

  00019	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00020	7d 05		 jge	 SHORT $LN2@gObjStateS

; 21281: 	{
; 21282: 		return;

  00022	e9 15 04 00 00	 jmp	 $LN1@gObjStateS
$LN2@gObjStateS:

; 21283: 	}
; 21284: 
; 21285: 	DWORD dwNowTick = GetTickCount();	// happycat@20050201

  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0002d	89 45 f8	 mov	 DWORD PTR _dwNowTick$[ebp], eax

; 21286: 
; 21287: 	//  ..
; 21288: 	if( lpObj->DieRegen == 1 )

  00030	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00033	0f be 88 fe 01
	00 00		 movsx	 ecx, BYTE PTR [eax+510]
  0003a	83 f9 01	 cmp	 ecx, 1
  0003d	75 35		 jne	 SHORT $LN3@gObjStateS

; 21289: 	{
; 21290: 		if ((dwNowTick - lpObj->RegenTime) > (lpObj->MaxRegenTime+1000)) //    ..

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _dwNowTick$[ebp]
  00045	2b 88 04 02 00
	00		 sub	 ecx, DWORD PTR [eax+516]
  0004b	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0004e	8b 82 08 02 00
	00		 mov	 eax, DWORD PTR [edx+520]
  00054	05 e8 03 00 00	 add	 eax, 1000		; 000003e8H
  00059	3b c8		 cmp	 ecx, eax
  0005b	76 17		 jbe	 SHORT $LN3@gObjStateS

; 21291: 		{
; 21292: #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 21293: 			gObjClearBuffEffect( lpObj, CLEAR_TYPE_NON_PCS_ITEM_EFFECT );
; 21294: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 21295: 			lpObj->DieRegen = 2;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00060	c6 80 fe 01 00
	00 02		 mov	 BYTE PTR [eax+510], 2

; 21296: 			lpObj->m_State = OBJST_DIECMD;	//   

  00067	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006a	c7 80 b8 01 00
	00 08 00 00 00	 mov	 DWORD PTR [eax+440], 8
$LN3@gObjStateS:

; 21297: 		}
; 21298: #ifdef DEVILSQUARE_EXTEND_20050221		//    
; 21299: 		//if( lpObj->Type == OBJTYPE_MONSTER && CHECK_DEVILSQUARE(lpObj->MapNumber) )
; 21300: #else
; 21301: 		//if( lpObj->Type == OBJTYPE_MONSTER && lpObj->MapNumber == 9 )
; 21302: #endif
; 21303: 		//{	//    
; 21304: 		//	lpObj->DieRegen = 2;
; 21305: 		//	lpObj->m_State = OBJST_DIECMD;	//   
; 21306: 		//}
; 21307: 	}	
; 21308: 
; 21309: 	#ifdef	HAPPY_CAT
; 21310: 	// Object     1 ,          .
; 21311: 	if (OBJTYPE_CHARACTER == lpObj->Type)
; 21312: 	{
; 21313: 		if (OBJST_DIECMD == lpObj->m_State)
; 21314: 		{
; 21315: 			gObjReady4Relife(lpObj);
; 21316: 		}
; 21317: 		else
; 21318: 		{
; 21319: 			gObjCheckTimeOutValue(lpObj, dwNowTick);
; 21320: 		}
; 21321: 	}
; 21322: 	#endif	//HAPPY_CAT
; 21323: 
; 21324: #ifdef MODIFY_SEASON_01_20060317
; 21325: 
; 21326: 	#ifndef HAPPY_CAT
; 21327: 	if( lpObj->Type == OBJTYPE_CHARACTER )
; 21328: 	{
; 21329: 		if( OBJST_DIECMD == lpObj->m_State )
; 21330: 		{
; 21331: 			gObjReady4Relife( lpObj );
; 21332: 		}
; 21333: 		else
; 21334: 		{
; 21335: 			gObjCheckTimeOutValue( lpObj, dwNowTick );
; 21336: 		}
; 21337: 	}
; 21338: 	#endif // HAPPY_CAT
; 21339: 
; 21340: #endif // MODIFY_SEASON_01_20060317
; 21341: 
; 21342: 	//if( lpObj->m_State == OBJST_CREATE && lpObj->m_StateSub == 1 )
; 21343: 	if( lpObj->Teleport == 1 )

  00074	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00077	0f be 88 fc 01
	00 00		 movsx	 ecx, BYTE PTR [eax+508]
  0007e	83 f9 01	 cmp	 ecx, 1
  00081	75 3d		 jne	 SHORT $LN5@gObjStateS

; 21344: 	{
; 21345: 		if( lpObj->DieRegen )

  00083	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00086	0f be 88 fe 01
	00 00		 movsx	 ecx, BYTE PTR [eax+510]
  0008d	85 c9		 test	 ecx, ecx
  0008f	74 0c		 je	 SHORT $LN7@gObjStateS

; 21346: 		{
; 21347: 			lpObj->Teleport = 0;

  00091	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00094	c6 80 fc 01 00
	00 00		 mov	 BYTE PTR [eax+508], 0

; 21348: 			//LogAddC(LOGC_RED," . %s %d", lpObj->Name, __LINE__);
; 21349: 		}

  0009b	eb 1e		 jmp	 SHORT $LN8@gObjStateS
$LN7@gObjStateS:

; 21350: 		else
; 21351: 		{
; 21352: 			if( GetTickCount()-lpObj->TeleportTime > 100 )

  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a6	2b 81 f8 01 00
	00		 sub	 eax, DWORD PTR [ecx+504]
  000ac	83 f8 64	 cmp	 eax, 100		; 00000064H
  000af	76 0a		 jbe	 SHORT $LN8@gObjStateS

; 21353: 			{
; 21354: 				lpObj->Teleport = 2;

  000b1	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b4	c6 80 fc 01 00
	00 02		 mov	 BYTE PTR [eax+508], 2
$LN8@gObjStateS:

; 21355: 				//lpObj->m_State = OBJST_CREATE;
; 21356: 				//LogAddC(LOGC_RED," 2 %s %d", lpObj->Name, __LINE__);
; 21357: 			}
; 21358: 		}
; 21359: 	}

  000bb	e9 62 02 00 00	 jmp	 $LN6@gObjStateS
$LN5@gObjStateS:

; 21360: 	else if( lpObj->Teleport == 2 )

  000c0	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c3	0f be 88 fc 01
	00 00		 movsx	 ecx, BYTE PTR [eax+508]
  000ca	83 f9 02	 cmp	 ecx, 2
  000cd	0f 85 4f 02 00
	00		 jne	 $LN6@gObjStateS

; 21361: 	{
; 21362: 		lpObj->Teleport = 3;

  000d3	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d6	c6 80 fc 01 00
	00 03		 mov	 BYTE PTR [eax+508], 3

; 21363: 		//LogAddC(LOGC_RED," 3 %s %d", lpObj->Name, __LINE__);
; 21364: 		if( lpObj->Type == OBJTYPE_CHARACTER )

  000dd	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e0	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  000e4	83 f9 01	 cmp	 ecx, 1
  000e7	0f 85 a9 00 00
	00		 jne	 $LN11@gObjStateS

; 21365: 		{
; 21366: 			lpObj->TX   = lpObj->X;

  000ed	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f0	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000f3	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  000fa	66 89 90 20 01
	00 00		 mov	 WORD PTR [eax+288], dx

; 21367: 			lpObj->TY   = lpObj->Y;

  00101	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00104	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00107	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  0010e	66 89 90 22 01
	00 00		 mov	 WORD PTR [eax+290], dx

; 21368: 			
; 21369: #ifdef MODIFY_WIZARD_TELEPORT_VIEWPORT_20060526
; 21370: 				CreateFrustrum(lpObj->X,lpObj->Y, aIndex);

  00115	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00118	50		 push	 eax
  00119	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0011c	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00123	52		 push	 edx
  00124	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00127	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0012e	51		 push	 ecx
  0012f	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  00134	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21371: 				GCTeleportSend(&gObj[aIndex], 0, lpObj->MapNumber, (BYTE)lpObj->X, (BYTE)lpObj->Y, lpObj->Dir);

  00137	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013a	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  00141	51		 push	 ecx
  00142	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00145	0f b6 82 06 01
	00 00		 movzx	 eax, BYTE PTR [edx+262]
  0014c	50		 push	 eax
  0014d	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00150	0f b6 91 04 01
	00 00		 movzx	 edx, BYTE PTR [ecx+260]
  00157	52		 push	 edx
  00158	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0015b	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00162	51		 push	 ecx
  00163	6a 00		 push	 0
  00165	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  0016c	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00172	52		 push	 edx
  00173	e8 00 00 00 00	 call	 ?GCTeleportSend@@YAXPAVOBJECTSTRUCT@@EEEEE@Z ; GCTeleportSend
  00178	83 c4 18	 add	 esp, 24			; 00000018H

; 21372: 				gObjViewportListProtocolCreate(lpObj);

  0017b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017e	50		 push	 eax
  0017f	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00184	83 c4 04	 add	 esp, 4

; 21373: #else
; 21374: 	#ifdef BUGFIX_WIZARD_TELEPORT_MAGIC_20041018
; 21375: 				GCTeleportSend(&gObj[aIndex], 0, lpObj->MapNumber, (BYTE)lpObj->X, (BYTE)lpObj->Y, lpObj->Dir);
; 21376: 				gObjViewportAllDel(lpObj->m_Index);
; 21377: 				gObjViewportListDestroy(lpObj->m_Index);
; 21378: 				CreateFrustrum(lpObj->X,lpObj->Y, lpObj->m_Index);
; 21379: 				gObjClearViewport(lpObj);
; 21380: 				gObjViewportListCreate(lpObj->m_Index);
; 21381: 				gObjViewportListProtocolCreate(lpObj);
; 21382: 	#else
; 21383: 				CreateFrustrum(lpObj->X,lpObj->Y, aIndex);
; 21384: 				GCTeleportSend(&gObj[aIndex], 0, lpObj->MapNumber, (BYTE)lpObj->X, (BYTE)lpObj->Y, lpObj->Dir);
; 21385: 				gObjViewportListProtocolCreate(lpObj);
; 21386: 	#endif
; 21387: #endif // MODIFY_WIZARD_TELEPORT_VIEWPORT_20060526
; 21388: 
; 21389: 			
; 21390: #ifdef CASTLE_MAIN_SCHEDULER_20041111		//        
; 21391: 			if (lpObj->MapNumber == MAP_INDEX_CASTLESIEGE &&
; 21392: 				g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE
; 21393: 				)
; 21394: 			{
; 21395: 				g_CastleSiege.NotifySelfCsJoinSide (aIndex);
; 21396: 				g_CastleSiege.NotifyCsSelfLeftTime (aIndex);
; 21397: 			}
; 21398: #endif
; 21399: 
; 21400: 			lpObj->Teleport = 0;			

  00187	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0018a	c6 80 fc 01 00
	00 00		 mov	 BYTE PTR [eax+508], 0

; 21401: 		}

  00191	e9 8c 01 00 00	 jmp	 $LN6@gObjStateS
$LN11@gObjStateS:

; 21402: #ifdef	NPC_QEUSTNPC2
; 21403: 		else if( lpObj->Type == OBJTYPE_NPC && lpObj->Class == NPC_QEUSTNPC2 )

  00196	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00199	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0019d	83 f9 03	 cmp	 ecx, 3
  001a0	0f 85 b2 00 00
	00		 jne	 $LN13@gObjStateS
  001a6	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a9	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  001b0	81 f9 e5 00 00
	00		 cmp	 ecx, 229		; 000000e5H
  001b6	0f 85 9c 00 00
	00		 jne	 $LN13@gObjStateS

; 21404: 		{
; 21405: 			int x, y;
; 21406: 			
; 21407: 			x = lpObj->X;

  001bc	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001bf	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  001c6	89 4d f4	 mov	 DWORD PTR _x$4[ebp], ecx

; 21408: 			y = lpObj->Y;

  001c9	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001cc	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  001d3	89 4d f0	 mov	 DWORD PTR _y$3[ebp], ecx

; 21409: 			
; 21410: 			lpObj->X = x;

  001d6	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d9	66 8b 4d f4	 mov	 cx, WORD PTR _x$4[ebp]
  001dd	66 89 88 04 01
	00 00		 mov	 WORD PTR [eax+260], cx

; 21411: 			lpObj->Y = y;

  001e4	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e7	66 8b 4d f0	 mov	 cx, WORD PTR _y$3[ebp]
  001eb	66 89 88 06 01
	00 00		 mov	 WORD PTR [eax+262], cx

; 21412: 			lpObj->TX   = lpObj->X;

  001f2	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f5	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001f8	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  001ff	66 89 90 20 01
	00 00		 mov	 WORD PTR [eax+288], dx

; 21413: 			lpObj->TY   = lpObj->Y;

  00206	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00209	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0020c	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  00213	66 89 90 22 01
	00 00		 mov	 WORD PTR [eax+290], dx

; 21414: 
; 21415: 			CreateFrustrum(lpObj->X,lpObj->Y, aIndex);			

  0021a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0021d	50		 push	 eax
  0021e	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00221	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00228	52		 push	 edx
  00229	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0022c	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00233	51		 push	 ecx
  00234	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  00239	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21416: 			//gObjViewportListProtocolCreate(lpObj);
; 21417: 			lpObj->m_State	= OBJST_CREATE;

  0023c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0023f	c7 80 b8 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+440], 1

; 21418: 			lpObj->PathStartEnd       = 0;

  00249	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0024c	c6 80 30 01 00
	00 00		 mov	 BYTE PTR [eax+304], 0

; 21419: 		}

  00253	e9 ca 00 00 00	 jmp	 $LN6@gObjStateS
$LN13@gObjStateS:

; 21420: #endif
; 21421: #ifdef MODIFY_NEW_MONSTER_SKILL_01_20060724
; 21422: 		else if ( lpObj->Type == OBJTYPE_MONSTER )
; 21423: 		{
; 21424: 			//    
; 21425: 			lpObj->TX   = lpObj->X;
; 21426: 			lpObj->TY   = lpObj->Y;
; 21427: 			CreateFrustrum(lpObj->X,lpObj->Y, aIndex);
; 21428: 		
; 21429: 			//   
; 21430: 			gObjViewportListCreate(lpObj->m_Index);
; 21431: 			gObjViewportListProtocolCreate(lpObj);
; 21432: 
; 21433: 			// 
; 21434: 			lpObj->Teleport = 0;	
; 21435: 
; 21436: 			//  .
; 21437: 			lpObj->PathStartEnd = 0;
; 21438: 			lpObj->PathCur = 0;
; 21439: 			lpObj->PathCount = 0;
; 21440: 		}
; 21441: #endif // MODIFY_NEW_MONSTER_SKILL_01_20060724	
; 21442: 		else 
; 21443: 		{
; 21444: 			int x, y;
; 21445: 
; 21446: 			if( lpObj->m_RecallMon>=0)

  00258	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0025b	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  00262	7c 1c		 jl	 SHORT $LN15@gObjStateS

; 21447: 			{
; 21448: 				x = lpObj->X;

  00264	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00267	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0026e	89 4d ec	 mov	 DWORD PTR _x$2[ebp], ecx

; 21449: 				y = lpObj->Y;

  00271	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00274	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0027b	89 4d e8	 mov	 DWORD PTR _y$1[ebp], ecx

; 21450: 			}

  0027e	eb 3c		 jmp	 SHORT $LN16@gObjStateS
$LN15@gObjStateS:

; 21451: 			else
; 21452: 			{
; 21453: 				x = (lpObj->X-3)+((rand()%6));

  00280	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00283	0f bf b0 04 01
	00 00		 movsx	 esi, WORD PTR [eax+260]
  0028a	e8 00 00 00 00	 call	 _rand
  0028f	99		 cdq
  00290	b9 06 00 00 00	 mov	 ecx, 6
  00295	f7 f9		 idiv	 ecx
  00297	8d 54 16 fd	 lea	 edx, DWORD PTR [esi+edx-3]
  0029b	89 55 ec	 mov	 DWORD PTR _x$2[ebp], edx

; 21454: 				y = (lpObj->Y-3)+((rand()%6));

  0029e	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a1	0f bf b0 06 01
	00 00		 movsx	 esi, WORD PTR [eax+262]
  002a8	e8 00 00 00 00	 call	 _rand
  002ad	99		 cdq
  002ae	b9 06 00 00 00	 mov	 ecx, 6
  002b3	f7 f9		 idiv	 ecx
  002b5	8d 54 16 fd	 lea	 edx, DWORD PTR [esi+edx-3]
  002b9	89 55 e8	 mov	 DWORD PTR _y$1[ebp], edx
$LN16@gObjStateS:

; 21455: 			}
; 21456: 			lpObj->X = x;

  002bc	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002bf	66 8b 4d ec	 mov	 cx, WORD PTR _x$2[ebp]
  002c3	66 89 88 04 01
	00 00		 mov	 WORD PTR [eax+260], cx

; 21457: 			lpObj->Y = y;

  002ca	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002cd	66 8b 4d e8	 mov	 cx, WORD PTR _y$1[ebp]
  002d1	66 89 88 06 01
	00 00		 mov	 WORD PTR [eax+262], cx

; 21458: 			lpObj->TX   = lpObj->X;

  002d8	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002db	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002de	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  002e5	66 89 90 20 01
	00 00		 mov	 WORD PTR [eax+288], dx

; 21459: 			lpObj->TY   = lpObj->Y;

  002ec	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ef	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002f2	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  002f9	66 89 90 22 01
	00 00		 mov	 WORD PTR [eax+290], dx

; 21460: 			//CreateFrustrum(lpObj->X,lpObj->Y, aIndex);
; 21461: 			if( lpObj->m_RecallMon>=0)

  00300	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00303	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  0030a	7c 16		 jl	 SHORT $LN6@gObjStateS

; 21462: 			{
; 21463: 				gObjViewportListProtocolCreate(lpObj);

  0030c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030f	50		 push	 eax
  00310	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00315	83 c4 04	 add	 esp, 4

; 21464: 				lpObj->PathStartEnd       = 0;

  00318	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0031b	c6 80 30 01 00
	00 00		 mov	 BYTE PTR [eax+304], 0
$LN6@gObjStateS:

; 21465: 				//lpObj->m_ActState.Emotion = 1;
; 21466: 			}
; 21467: 		}
; 21468: 	}
; 21469: 
; 21470: 	if( lpObj->RegenOk == 2 ) //   

  00322	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00325	0f be 88 ff 01
	00 00		 movsx	 ecx, BYTE PTR [eax+511]
  0032c	83 f9 02	 cmp	 ecx, 2
  0032f	0f 85 07 01 00
	00		 jne	 $LN1@gObjStateS

; 21471: 	{
; 21472: 		if( lpObj->Type == OBJTYPE_CHARACTER )

  00335	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00338	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0033c	83 f9 01	 cmp	 ecx, 1
  0033f	0f 85 f7 00 00
	00		 jne	 $LN1@gObjStateS

; 21473: 		{
; 21474: 			lpObj->m_State = OBJST_CREATE;

  00345	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00348	c7 80 b8 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+440], 1

; 21475: 			lpObj->RegenOk = 3;

  00352	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00355	c6 80 ff 01 00
	00 03		 mov	 BYTE PTR [eax+511], 3

; 21476: 			
; 21477: 			lpObj->X = lpObj->RegenMapX;

  0035c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0035f	66 0f b6 88 01
	02 00 00	 movzx	 cx, BYTE PTR [eax+513]
  00367	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0036a	66 89 8a 04 01
	00 00		 mov	 WORD PTR [edx+260], cx

; 21478: 			lpObj->Y = lpObj->RegenMapY;

  00371	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00374	66 0f b6 88 02
	02 00 00	 movzx	 cx, BYTE PTR [eax+514]
  0037c	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0037f	66 89 8a 06 01
	00 00		 mov	 WORD PTR [edx+262], cx

; 21479: 			lpObj->MapNumber = lpObj->RegenMapNumber;

  00386	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00389	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0038c	8a 91 00 02 00
	00		 mov	 dl, BYTE PTR [ecx+512]
  00392	88 90 09 01 00
	00		 mov	 BYTE PTR [eax+265], dl

; 21480: 
; 21481: 			lpObj->TX   = lpObj->X;

  00398	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039b	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0039e	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  003a5	66 89 90 20 01
	00 00		 mov	 WORD PTR [eax+288], dx

; 21482: 			lpObj->TY   = lpObj->Y;

  003ac	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003af	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003b2	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  003b9	66 89 90 22 01
	00 00		 mov	 WORD PTR [eax+290], dx

; 21483: 			CreateFrustrum(lpObj->X,lpObj->Y, aIndex);

  003c0	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003c3	50		 push	 eax
  003c4	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003c7	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  003ce	52		 push	 edx
  003cf	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003d2	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  003d9	51		 push	 ecx
  003da	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  003df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21484: 			//   ..
; 21485: 			if( DragonEvent->GetState() > 0 )

  003e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  003e8	e8 00 00 00 00	 call	 ?GetState@CDragonEvent@@QAEEXZ ; CDragonEvent::GetState
  003ed	0f b6 c0	 movzx	 eax, al
  003f0	85 c0		 test	 eax, eax
  003f2	7e 33		 jle	 SHORT $LN20@gObjStateS

; 21486: 			{
; 21487: 				if( DragonEvent->GetMapNumber() == lpObj->MapNumber )

  003f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  003fa	e8 00 00 00 00	 call	 ?GetMapNumber@CDragonEvent@@QAEEXZ ; CDragonEvent::GetMapNumber
  003ff	0f b6 c0	 movzx	 eax, al
  00402	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00405	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0040c	3b c2		 cmp	 eax, edx
  0040e	75 17		 jne	 SHORT $LN20@gObjStateS

; 21488: 				{
; 21489: 					GCMapEventStateSend(lpObj->MapNumber, 1, 1);

  00410	6a 01		 push	 1
  00412	6a 01		 push	 1
  00414	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00417	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0041e	51		 push	 ecx
  0041f	e8 00 00 00 00	 call	 ?GCMapEventStateSend@@YAXHEE@Z ; GCMapEventStateSend
  00424	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@gObjStateS:

; 21490: 				}
; 21491: 			}			
; 21492: #ifdef CASTLE_MAIN_SCHEDULER_20041111				//     .
; 21493: 			if (lpObj->MapNumber == MAP_INDEX_CASTLESIEGE) {
; 21494: 				GCAnsCsNotifyStart(lpObj->m_Index, (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)?1:0);
; 21495: 				if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE) {
; 21496: 					g_CastleSiege.NotifySelfCsJoinSide (lpObj->m_Index);
; 21497: 					g_CastleSiege.NotifyCsSelfLeftTime (lpObj->m_Index);
; 21498: 				}
; 21499: 			}
; 21500: #endif
; 21501: 			gEledoradoEvent.CheckGoldDercon(lpObj->MapNumber);

  00427	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0042a	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00431	51		 push	 ecx
  00432	b9 00 00 00 00	 mov	 ecx, OFFSET ?gEledoradoEvent@@3VCEledoradoEvent@@A ; gEledoradoEvent
  00437	e8 00 00 00 00	 call	 ?CheckGoldDercon@CEledoradoEvent@@QAEXH@Z ; CEledoradoEvent::CheckGoldDercon
$LN1@gObjStateS:

; 21502: 
; 21503: 
; 21504: #ifdef FOR_JAPAN	
; 21505: 	//   
; 21506: 			if( gTamaJJangEvent )
; 21507: 			{
; 21508: 				if( gAppearTamaJJang && lpObj->MapNumber == 0 )
; 21509: 				{	//   ,  
; 21510: 					GCMapEventStateSend(0, gAppearTamaJJang, 2);	
; 21511: 				}
; 21512: 			}
; 21513: #endif
; 21514: 			
; 21515: #ifdef PCBANG_ADVANTAGE	// happycat@20050201 (PC )
; 21516: 			LPOBJECTSTRUCT	lpObj	= (LPOBJECTSTRUCT)&gObj[aIndex];
; 21517: 
; 21518: 	#ifdef PCBANG_ADVANTAGE_EXPAND_20060919
; 21519: 			if( IsOKPCBangBenefitAll(lpObj) )
; 21520: 	#else
; 21521: 			if (lpObj->m_bPCBangUser)
; 21522: 	#endif //PCBANG_ADVANTAGE_EXPAND_20060919
; 21523: 			{
; 21524: 				gObjCalCharacter(lpObj->m_Index);
; 21525: 				
; 21526: 	#ifdef ADD_SHIELD_POINT_01_20060403
; 21527: 				GCReFillSend(lpObj->m_Index, (WORD)(lpObj->MaxLife + lpObj->AddLife), 0xFE, 0, (WORD)(lpObj->iMaxShield+lpObj->iAddShield));
; 21528: 	#else
; 21529: 				GCReFillSend(lpObj->m_Index, (WORD)(lpObj->MaxLife + lpObj->AddLife), 0xFE, 0);
; 21530: 	#endif
; 21531: 				GCManaSend(lpObj->m_Index, (short)(lpObj->MaxMana+lpObj->AddMana), 0xFE, 0, lpObj->MaxBP+lpObj->AddBP);		
; 21532: 			}
; 21533: #endif//PCBANG_ADVANTAGE
; 21534: 
; 21535: 		}//if( lpObj->Type == OBJTYPE_CHARACTER )
; 21536: 
; 21537: 	}//if( lpObj->RegenOk == 2 )
; 21538: 	
; 21539: }

  0043c	5f		 pop	 edi
  0043d	5e		 pop	 esi
  0043e	5b		 pop	 ebx
  0043f	8b e5		 mov	 esp, ebp
  00441	5d		 pop	 ebp
  00442	c3		 ret	 0
?gObjStateSetCreate@@YAXH@Z ENDP			; gObjStateSetCreate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?PShop_CheckInventoryEmpty@@YA_NF@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 2
?PShop_CheckInventoryEmpty@@YA_NF@Z PROC		; PShop_CheckInventoryEmpty, COMDAT

; 21257: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 21258: 	// aIndex       .
; 21259: 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00009	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0000d	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00013	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00019	89 4d fc	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 21260: 
; 21261: 	for (INT i = MAX_INVENTORY ; i < MAX_INVENTORY_EXTEND ; i++) {

  0001c	c7 45 f8 4c 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 76	; 0000004cH
  00023	eb 09		 jmp	 SHORT $LN4@PShop_Chec
$LN2@PShop_Chec:
  00025	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00028	83 c0 01	 add	 eax, 1
  0002b	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@PShop_Chec:
  0002e	83 7d f8 6c	 cmp	 DWORD PTR _i$1[ebp], 108 ; 0000006cH
  00032	7d 20		 jge	 SHORT $LN3@PShop_Chec

; 21262: 		if (lpObj->Inventory1[i].IsItem() == TRUE)

  00034	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _i$1[ebp], 168
  0003b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003e	03 88 6c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3180]
  00044	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00049	83 f8 01	 cmp	 eax, 1
  0004c	75 04		 jne	 SHORT $LN5@PShop_Chec

; 21263: 			return false;

  0004e	32 c0		 xor	 al, al
  00050	eb 04		 jmp	 SHORT $LN1@PShop_Chec
$LN5@PShop_Chec:

; 21264: 	}

  00052	eb d1		 jmp	 SHORT $LN2@PShop_Chec
$LN3@PShop_Chec:

; 21265: 	
; 21266: 	return true;

  00054	b0 01		 mov	 al, 1
$LN1@PShop_Chec:

; 21267: }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?PShop_CheckInventoryEmpty@@YA_NF@Z ENDP		; PShop_CheckInventoryEmpty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?PShop_ViewportListRegenarate@@YAXF@Z
_TEXT	SEGMENT
_iVP$1 = -16720						; size = 4
_bVpFound$2 = -16716					; size = 4
_n$ = -16712						; size = 4
_iPShopOpenIndex$ = -16708				; size = 300
_lpMsgBody$ = -16408					; size = 4
_lpMsg$ = -16404					; size = 4
_iVpAddCount$ = -16400					; size = 4
_iVpOpenCount$ = -16396					; size = 4
_cBUFFER$ = -16392					; size = 16384
_lpObj$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 2
?PShop_ViewportListRegenarate@@YAXF@Z PROC		; PShop_ViewportListRegenarate, COMDAT

; 21062: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 50 43 00 00	 mov	 eax, 17232		; 00004350H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi

; 21063: 	if (!gObjIsConnected(aIndex)) {

  0001a	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 05		 jne	 SHORT $LN11@PShop_View

; 21064: 		return;

  0002b	e9 16 08 00 00	 jmp	 $LN1@PShop_View
$LN11@PShop_View:

; 21065: 	}
; 21066: 	
; 21067: 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00030	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00034	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0003a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00040	89 4d f8	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 21068: 	
; 21069: 	if( lpObj->Type != OBJTYPE_CHARACTER ) {	//  NPC    .

  00043	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00046	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0004a	83 f9 01	 cmp	 ecx, 1
  0004d	74 05		 je	 SHORT $LN12@PShop_View

; 21070: 		return;

  0004f	e9 f2 07 00 00	 jmp	 $LN1@PShop_View
$LN12@PShop_View:

; 21071: 	}
; 21072: 	if( lpObj->RegenOk > 0 ) {					//    .

  00054	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00057	0f be 88 ff 01
	00 00		 movsx	 ecx, BYTE PTR [eax+511]
  0005e	85 c9		 test	 ecx, ecx
  00060	7e 05		 jle	 SHORT $LN13@PShop_View

; 21073: 		return;

  00062	e9 df 07 00 00	 jmp	 $LN1@PShop_View
$LN13@PShop_View:

; 21074: 	}
; 21075: 	if( lpObj->CloseCount > -1) {				//    .

  00067	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006a	0f be 48 0a	 movsx	 ecx, BYTE PTR [eax+10]
  0006e	83 f9 ff	 cmp	 ecx, -1
  00071	7e 05		 jle	 SHORT $LN14@PShop_View

; 21076: 		return;

  00073	e9 ce 07 00 00	 jmp	 $LN1@PShop_View
$LN14@PShop_View:

; 21077: 	}
; 21078: 
; 21079: 	// *> .    
; 21080: 	CHAR cBUFFER [MAX_BUFF_SIZE];
; 21081: 	INT iVpOpenCount = 0;		//   

  00078	c7 85 f4 bf ff
	ff 00 00 00 00	 mov	 DWORD PTR _iVpOpenCount$[ebp], 0

; 21082: 	INT iVpAddCount = 0;		//  

  00082	c7 85 f0 bf ff
	ff 00 00 00 00	 mov	 DWORD PTR _iVpAddCount$[ebp], 0

; 21083: 	LPPMSG_ANS_PSHOP_VIEWPORT_NOTIFY lpMsg = (LPPMSG_ANS_PSHOP_VIEWPORT_NOTIFY) cBUFFER;

  0008c	8d 85 f8 bf ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp]
  00092	89 85 ec bf ff
	ff		 mov	 DWORD PTR _lpMsg$[ebp], eax

; 21084: 	LPPMSG_PSHOP_VIEWPORT_NOTIFY lpMsgBody = (LPPMSG_PSHOP_VIEWPORT_NOTIFY) (cBUFFER + sizeof(PMSG_ANS_PSHOP_VIEWPORT_NOTIFY));

  00098	8d 85 fe bf ff
	ff		 lea	 eax, DWORD PTR _cBUFFER$[ebp+6]
  0009e	89 85 e8 bf ff
	ff		 mov	 DWORD PTR _lpMsgBody$[ebp], eax

; 21085: 
; 21086: 
; 21087: 	// *> .    
; 21088: 	int iPShopOpenIndex[MAXVIEWPORTOBJECT];		//   iVpOpenCount 
; 21089: 
; 21090: 
; 21091: 	// *> .        .
; 21092: 	if (lpObj->m_bPShopRedrawAbs) {

  000a4	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a7	0f b6 88 fb 0c
	00 00		 movzx	 ecx, BYTE PTR [eax+3323]
  000ae	85 c9		 test	 ecx, ecx
  000b0	74 2e		 je	 SHORT $LN15@PShop_View

; 21093: 		memset(lpObj->m_iVpPShopPlayer, 0, sizeof(lpObj->m_iVpPShopPlayer));	//   

  000b2	68 2c 01 00 00	 push	 300			; 0000012cH
  000b7	6a 00		 push	 0
  000b9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bc	05 4c 0d 00 00	 add	 eax, 3404		; 00000d4cH
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 _memset
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21094: 		lpObj->m_wVpPShopPlayerCount = 0;										//     

  000ca	33 c0		 xor	 eax, eax
  000cc	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000cf	66 89 81 78 0e
	00 00		 mov	 WORD PTR [ecx+3704], ax

; 21095: 		lpObj->m_bPShopRedrawAbs = false;

  000d6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d9	c6 80 fb 0c 00
	00 00		 mov	 BYTE PTR [eax+3323], 0
$LN15@PShop_View:

; 21096: 	}
; 21097: 
; 21098: 
; 21099: 	// 1 .   set  -> set     
; 21100: 	int n;
; 21101: 	for( n = 0 ; n < MAXVIEWPORTOBJECT ; n++ )

  000e0	c7 85 b8 be ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  000ea	eb 0f		 jmp	 SHORT $LN4@PShop_View
$LN2@PShop_View:
  000ec	8b 85 b8 be ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  000f2	83 c0 01	 add	 eax, 1
  000f5	89 85 b8 be ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
$LN4@PShop_View:
  000fb	83 bd b8 be ff
	ff 4b		 cmp	 DWORD PTR _n$[ebp], 75	; 0000004bH
  00102	0f 8d af 02 00
	00		 jge	 $LN3@PShop_View

; 21102: 	{
; 21103: 		if( lpObj->VpPlayer[n].state == STVP_PLAYING &&

  00108	6b 85 b8 be ff
	ff 0c		 imul	 eax, DWORD PTR _n$[ebp], 12
  0010f	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00112	0f be 94 01 64
	03 00 00	 movsx	 edx, BYTE PTR [ecx+eax+868]
  0011a	83 fa 02	 cmp	 edx, 2
  0011d	0f 85 8f 02 00
	00		 jne	 $LN16@PShop_View
  00123	6b 85 b8 be ff
	ff 0c		 imul	 eax, DWORD PTR _n$[ebp], 12
  0012a	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0012d	0f b6 94 01 68
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+872]
  00135	83 fa 01	 cmp	 edx, 1
  00138	0f 85 74 02 00
	00		 jne	 $LN16@PShop_View

; 21104: 			lpObj->VpPlayer[n].type == OBJTYPE_CHARACTER
; 21105: 			)
; 21106: 		{
; 21107: 			if (gObj[lpObj->VpPlayer[n].number].m_bPShopOpen == true) {

  0013e	6b 85 b8 be ff
	ff 0c		 imul	 eax, DWORD PTR _n$[ebp], 12
  00145	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00148	0f bf 94 01 66
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax+870]
  00150	69 c2 a0 1b 00
	00		 imul	 eax, edx, 7072
  00156	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0015c	0f b6 94 01 f8
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3320]
  00164	83 fa 01	 cmp	 edx, 1
  00167	0f 85 45 02 00
	00		 jne	 $LN16@PShop_View

; 21108: 				iPShopOpenIndex[iVpOpenCount] = lpObj->VpPlayer[n].number;

  0016d	6b 85 b8 be ff
	ff 0c		 imul	 eax, DWORD PTR _n$[ebp], 12
  00174	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00177	0f bf 94 01 66
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax+870]
  0017f	8b 85 f4 bf ff
	ff		 mov	 eax, DWORD PTR _iVpOpenCount$[ebp]
  00185	89 94 85 bc be
	ff ff		 mov	 DWORD PTR _iPShopOpenIndex$[ebp+eax*4], edx

; 21109: 				iVpOpenCount++;

  0018c	8b 85 f4 bf ff
	ff		 mov	 eax, DWORD PTR _iVpOpenCount$[ebp]
  00192	83 c0 01	 add	 eax, 1
  00195	89 85 f4 bf ff
	ff		 mov	 DWORD PTR _iVpOpenCount$[ebp], eax

; 21110: 
; 21111: 				if (lpObj->m_wVpPShopPlayerCount > 0 && lpObj->m_wVpPShopPlayerCount <= MAXVIEWPORTOBJECT) {

  0019b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019e	0f b7 88 78 0e
	00 00		 movzx	 ecx, WORD PTR [eax+3704]
  001a5	85 c9		 test	 ecx, ecx
  001a7	0f 8e 33 01 00
	00		 jle	 $LN18@PShop_View
  001ad	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b0	0f b7 88 78 0e
	00 00		 movzx	 ecx, WORD PTR [eax+3704]
  001b7	83 f9 4b	 cmp	 ecx, 75			; 0000004bH
  001ba	0f 8f 20 01 00
	00		 jg	 $LN18@PShop_View

; 21112: 					BOOL bVpFound = FALSE;

  001c0	c7 85 b4 be ff
	ff 00 00 00 00	 mov	 DWORD PTR _bVpFound$2[ebp], 0

; 21113: 					for (INT iVP = 0 ; iVP < lpObj->m_wVpPShopPlayerCount ; iVP++) {

  001ca	c7 85 b0 be ff
	ff 00 00 00 00	 mov	 DWORD PTR _iVP$1[ebp], 0
  001d4	eb 0f		 jmp	 SHORT $LN7@PShop_View
$LN5@PShop_View:
  001d6	8b 85 b0 be ff
	ff		 mov	 eax, DWORD PTR _iVP$1[ebp]
  001dc	83 c0 01	 add	 eax, 1
  001df	89 85 b0 be ff
	ff		 mov	 DWORD PTR _iVP$1[ebp], eax
$LN7@PShop_View:
  001e5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e8	0f b7 88 78 0e
	00 00		 movzx	 ecx, WORD PTR [eax+3704]
  001ef	39 8d b0 be ff
	ff		 cmp	 DWORD PTR _iVP$1[ebp], ecx
  001f5	7d 32		 jge	 SHORT $LN6@PShop_View

; 21114: 						if (lpObj->m_iVpPShopPlayer[iVP] == lpObj->VpPlayer[n].number) {

  001f7	6b 85 b8 be ff
	ff 0c		 imul	 eax, DWORD PTR _n$[ebp], 12
  001fe	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00201	0f bf 94 01 66
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax+870]
  00209	8b 85 b0 be ff
	ff		 mov	 eax, DWORD PTR _iVP$1[ebp]
  0020f	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00212	39 94 81 4c 0d
	00 00		 cmp	 DWORD PTR [ecx+eax*4+3404], edx
  00219	75 0c		 jne	 SHORT $LN20@PShop_View

; 21115: 							bVpFound = TRUE;

  0021b	c7 85 b4 be ff
	ff 01 00 00 00	 mov	 DWORD PTR _bVpFound$2[ebp], 1

; 21116: 							break;

  00225	eb 02		 jmp	 SHORT $LN6@PShop_View
$LN20@PShop_View:

; 21117: 						}
; 21118: 					}

  00227	eb ad		 jmp	 SHORT $LN5@PShop_View
$LN6@PShop_View:

; 21119: 					
; 21120: 					if (bVpFound == FALSE) {

  00229	83 bd b4 be ff
	ff 00		 cmp	 DWORD PTR _bVpFound$2[ebp], 0
  00230	0f 85 a5 00 00
	00		 jne	 $LN21@PShop_View

; 21121: 						//   . ->     .
; 21122: 						lpMsgBody[iVpAddCount].btNumberL = LOBYTE(WORD(lpObj->VpPlayer[n].number));

  00236	6b 85 b8 be ff
	ff 0c		 imul	 eax, DWORD PTR _n$[ebp], 12
  0023d	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00240	0f b7 94 01 66
	03 00 00	 movzx	 edx, WORD PTR [ecx+eax+870]
  00248	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0024e	6b 85 f0 bf ff
	ff 26		 imul	 eax, DWORD PTR _iVpAddCount$[ebp], 38
  00255	8b 8d e8 bf ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  0025b	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 21123: 						lpMsgBody[iVpAddCount].btNumberH = HIBYTE(WORD(lpObj->VpPlayer[n].number));

  0025f	6b 85 b8 be ff
	ff 0c		 imul	 eax, DWORD PTR _n$[ebp], 12
  00266	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00269	0f b7 94 01 66
	03 00 00	 movzx	 edx, WORD PTR [ecx+eax+870]
  00271	c1 ea 08	 shr	 edx, 8
  00274	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0027a	6b 85 f0 bf ff
	ff 26		 imul	 eax, DWORD PTR _iVpAddCount$[ebp], 38
  00281	8b 8d e8 bf ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  00287	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 21124: 						memcpy (lpMsgBody[iVpAddCount].szPShopText, gObj[lpObj->VpPlayer[n].number].m_szPShopText, MAX_PSHOP_TEXT);

  0028a	6a 24		 push	 36			; 00000024H
  0028c	6b 85 b8 be ff
	ff 0c		 imul	 eax, DWORD PTR _n$[ebp], 12
  00293	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00296	0f bf 94 01 66
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax+870]
  0029e	69 c2 a0 1b 00
	00		 imul	 eax, edx, 7072
  002a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002aa	8d 94 01 fc 0c
	00 00		 lea	 edx, DWORD PTR [ecx+eax+3324]
  002b1	52		 push	 edx
  002b2	6b 85 f0 bf ff
	ff 26		 imul	 eax, DWORD PTR _iVpAddCount$[ebp], 38
  002b9	8b 8d e8 bf ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  002bf	8d 54 01 02	 lea	 edx, DWORD PTR [ecx+eax+2]
  002c3	52		 push	 edx
  002c4	e8 00 00 00 00	 call	 _memcpy
  002c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21125: 						iVpAddCount++;

  002cc	8b 85 f0 bf ff
	ff		 mov	 eax, DWORD PTR _iVpAddCount$[ebp]
  002d2	83 c0 01	 add	 eax, 1
  002d5	89 85 f0 bf ff
	ff		 mov	 DWORD PTR _iVpAddCount$[ebp], eax
$LN21@PShop_View:

; 21126: 					}
; 21127: 				}

  002db	e9 d2 00 00 00	 jmp	 $LN16@PShop_View
$LN18@PShop_View:

; 21128: 				else if (lpObj->m_wVpPShopPlayerCount == 0) {

  002e0	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002e3	0f b7 88 78 0e
	00 00		 movzx	 ecx, WORD PTR [eax+3704]
  002ea	85 c9		 test	 ecx, ecx
  002ec	0f 85 a7 00 00
	00		 jne	 $LN22@PShop_View

; 21129: 					//          .
; 21130: 					lpMsgBody[iVpAddCount].btNumberL = LOBYTE(WORD(lpObj->VpPlayer[n].number));

  002f2	6b 85 b8 be ff
	ff 0c		 imul	 eax, DWORD PTR _n$[ebp], 12
  002f9	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002fc	0f b7 94 01 66
	03 00 00	 movzx	 edx, WORD PTR [ecx+eax+870]
  00304	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0030a	6b 85 f0 bf ff
	ff 26		 imul	 eax, DWORD PTR _iVpAddCount$[ebp], 38
  00311	8b 8d e8 bf ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  00317	88 54 01 01	 mov	 BYTE PTR [ecx+eax+1], dl

; 21131: 					lpMsgBody[iVpAddCount].btNumberH = HIBYTE(WORD(lpObj->VpPlayer[n].number));

  0031b	6b 85 b8 be ff
	ff 0c		 imul	 eax, DWORD PTR _n$[ebp], 12
  00322	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00325	0f b7 94 01 66
	03 00 00	 movzx	 edx, WORD PTR [ecx+eax+870]
  0032d	c1 ea 08	 shr	 edx, 8
  00330	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00336	6b 85 f0 bf ff
	ff 26		 imul	 eax, DWORD PTR _iVpAddCount$[ebp], 38
  0033d	8b 8d e8 bf ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  00343	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 21132: 					memcpy (lpMsgBody[iVpAddCount].szPShopText, gObj[lpObj->VpPlayer[n].number].m_szPShopText, MAX_PSHOP_TEXT);

  00346	6a 24		 push	 36			; 00000024H
  00348	6b 85 b8 be ff
	ff 0c		 imul	 eax, DWORD PTR _n$[ebp], 12
  0034f	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00352	0f bf 94 01 66
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax+870]
  0035a	69 c2 a0 1b 00
	00		 imul	 eax, edx, 7072
  00360	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00366	8d 94 01 fc 0c
	00 00		 lea	 edx, DWORD PTR [ecx+eax+3324]
  0036d	52		 push	 edx
  0036e	6b 85 f0 bf ff
	ff 26		 imul	 eax, DWORD PTR _iVpAddCount$[ebp], 38
  00375	8b 8d e8 bf ff
	ff		 mov	 ecx, DWORD PTR _lpMsgBody$[ebp]
  0037b	8d 54 01 02	 lea	 edx, DWORD PTR [ecx+eax+2]
  0037f	52		 push	 edx
  00380	e8 00 00 00 00	 call	 _memcpy
  00385	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21133: 					iVpAddCount++;

  00388	8b 85 f0 bf ff
	ff		 mov	 eax, DWORD PTR _iVpAddCount$[ebp]
  0038e	83 c0 01	 add	 eax, 1
  00391	89 85 f0 bf ff
	ff		 mov	 DWORD PTR _iVpAddCount$[ebp], eax

; 21134: 				}

  00397	eb 19		 jmp	 SHORT $LN16@PShop_View
$LN22@PShop_View:

; 21135: 				else {
; 21136: 					//   -> 
; 21137: 					LogAddTD("[PShop] ERROR : lpObj->m_wVpPShopPlayerCount is OUT of BOUND : %d", lpObj->m_wVpPShopPlayerCount);

  00399	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039c	0f b7 88 78 0e
	00 00		 movzx	 ecx, WORD PTR [eax+3704]
  003a3	51		 push	 ecx
  003a4	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@MINIMHLG@?$FLPShop?$FN?5ERROR?5?3?5lpObj?9?$DOm_wVpPSh@
  003a9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003af	83 c4 08	 add	 esp, 8
$LN16@PShop_View:

; 21138: 				}
; 21139: 			}
; 21140: 		}
; 21141: 	}

  003b2	e9 35 fd ff ff	 jmp	 $LN2@PShop_View
$LN3@PShop_View:

; 21142: 
; 21143: 
; 21144: 	// 2 .           
; 21145: 	memset(lpObj->m_iVpPShopPlayer, 0, sizeof(lpObj->m_iVpPShopPlayer));	//   

  003b7	68 2c 01 00 00	 push	 300			; 0000012cH
  003bc	6a 00		 push	 0
  003be	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003c1	05 4c 0d 00 00	 add	 eax, 3404		; 00000d4cH
  003c6	50		 push	 eax
  003c7	e8 00 00 00 00	 call	 _memset
  003cc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21146: 	lpObj->m_wVpPShopPlayerCount = 0;										//     

  003cf	33 c0		 xor	 eax, eax
  003d1	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003d4	66 89 81 78 0e
	00 00		 mov	 WORD PTR [ecx+3704], ax

; 21147: 	
; 21148: 
; 21149: 	if (iVpOpenCount > 0 && iVpOpenCount <= MAXVIEWPORTOBJECT) {

  003db	83 bd f4 bf ff
	ff 00		 cmp	 DWORD PTR _iVpOpenCount$[ebp], 0
  003e2	7e 64		 jle	 SHORT $LN24@PShop_View
  003e4	83 bd f4 bf ff
	ff 4b		 cmp	 DWORD PTR _iVpOpenCount$[ebp], 75 ; 0000004bH
  003eb	7f 5b		 jg	 SHORT $LN24@PShop_View

; 21150: 		for ( n = 0 ; n < iVpOpenCount ; n++) {

  003ed	c7 85 b8 be ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$[ebp], 0
  003f7	eb 0f		 jmp	 SHORT $LN10@PShop_View
$LN8@PShop_View:
  003f9	8b 85 b8 be ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  003ff	83 c0 01	 add	 eax, 1
  00402	89 85 b8 be ff
	ff		 mov	 DWORD PTR _n$[ebp], eax
$LN10@PShop_View:
  00408	8b 85 b8 be ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  0040e	3b 85 f4 bf ff
	ff		 cmp	 eax, DWORD PTR _iVpOpenCount$[ebp]
  00414	7d 1f		 jge	 SHORT $LN9@PShop_View

; 21151: 			lpObj->m_iVpPShopPlayer[n] = iPShopOpenIndex[n];

  00416	8b 85 b8 be ff
	ff		 mov	 eax, DWORD PTR _n$[ebp]
  0041c	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0041f	8b 95 b8 be ff
	ff		 mov	 edx, DWORD PTR _n$[ebp]
  00425	8b 94 95 bc be
	ff ff		 mov	 edx, DWORD PTR _iPShopOpenIndex$[ebp+edx*4]
  0042c	89 94 81 4c 0d
	00 00		 mov	 DWORD PTR [ecx+eax*4+3404], edx

; 21152: 		}

  00433	eb c4		 jmp	 SHORT $LN8@PShop_View
$LN9@PShop_View:

; 21153: 		lpObj->m_wVpPShopPlayerCount = iVpOpenCount;

  00435	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00438	66 8b 8d f4 bf
	ff ff		 mov	 cx, WORD PTR _iVpOpenCount$[ebp]
  0043f	66 89 88 78 0e
	00 00		 mov	 WORD PTR [eax+3704], cx

; 21154: 	}

  00446	eb 1e		 jmp	 SHORT $LN25@PShop_View
$LN24@PShop_View:

; 21155: 	else if (iVpOpenCount != 0) {

  00448	83 bd f4 bf ff
	ff 00		 cmp	 DWORD PTR _iVpOpenCount$[ebp], 0
  0044f	74 15		 je	 SHORT $LN25@PShop_View

; 21156: 		LogAddTD("[PShop] ERROR : iVpOpenCount is OUT of BOUND: %d", iVpOpenCount);

  00451	8b 85 f4 bf ff
	ff		 mov	 eax, DWORD PTR _iVpOpenCount$[ebp]
  00457	50		 push	 eax
  00458	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@CHPPJFL@?$FLPShop?$FN?5ERROR?5?3?5iVpOpenCount?5is@
  0045d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00463	83 c4 08	 add	 esp, 8
$LN25@PShop_View:

; 21157: 	}
; 21158: 
; 21159: 
; 21160: 	// 3 .       
; 21161: 	if (iVpAddCount > 0 && iVpAddCount <= MAXVIEWPORTOBJECT) {

  00466	83 bd f0 bf ff
	ff 00		 cmp	 DWORD PTR _iVpAddCount$[ebp], 0
  0046d	7e 7b		 jle	 SHORT $LN27@PShop_View
  0046f	83 bd f0 bf ff
	ff 4b		 cmp	 DWORD PTR _iVpAddCount$[ebp], 75 ; 0000004bH
  00476	7f 72		 jg	 SHORT $LN27@PShop_View

; 21162: 		lpMsg->btCount = iVpAddCount;

  00478	8b 85 ec bf ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0047e	8a 8d f0 bf ff
	ff		 mov	 cl, BYTE PTR _iVpAddCount$[ebp]
  00484	88 48 05	 mov	 BYTE PTR [eax+5], cl

; 21163: 		PHeadSubSetW((LPBYTE) lpMsg, 0x3F, 0x00, sizeof(PMSG_ANS_PSHOP_VIEWPORT_NOTIFY) + (sizeof(PMSG_PSHOP_VIEWPORT_NOTIFY) * iVpAddCount));

  00487	6b 85 f0 bf ff
	ff 26		 imul	 eax, DWORD PTR _iVpAddCount$[ebp], 38
  0048e	83 c0 06	 add	 eax, 6
  00491	50		 push	 eax
  00492	6a 00		 push	 0
  00494	6a 3f		 push	 63			; 0000003fH
  00496	8b 8d ec bf ff
	ff		 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  0049c	51		 push	 ecx
  0049d	e8 00 00 00 00	 call	 ?PHeadSubSetW@@YAXPAEEEH@Z ; PHeadSubSetW
  004a2	83 c4 10	 add	 esp, 16			; 00000010H

; 21164: 		DataSend (aIndex, (LPBYTE) lpMsg, MAKEWORD(lpMsg->h.sizeL, lpMsg->h.sizeH));

  004a5	8b 85 ec bf ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  004ab	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  004af	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  004b5	0f b6 d1	 movzx	 edx, cl
  004b8	8b 85 ec bf ff
	ff		 mov	 eax, DWORD PTR _lpMsg$[ebp]
  004be	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  004c2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  004c8	0f b6 c1	 movzx	 eax, cl
  004cb	c1 e0 08	 shl	 eax, 8
  004ce	0b d0		 or	 edx, eax
  004d0	0f b7 ca	 movzx	 ecx, dx
  004d3	51		 push	 ecx
  004d4	8b 95 ec bf ff
	ff		 mov	 edx, DWORD PTR _lpMsg$[ebp]
  004da	52		 push	 edx
  004db	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  004df	50		 push	 eax
  004e0	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  004e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21165: /*
; 21166: 		LogAddTD ("   INDEX:%d, :%s, :%d",
; 21167: 			aIndex,
; 21168: 			gObj[aIndex].Name,
; 21169: 			lpMsg->btCount
; 21170: 			);
; 21171: 		for ( n = 0 ; n < iVpAddCount ; n++) {
; 21172: 			LogAddTD("  INDEX:%d, TEXT:%s", 
; 21173: 				MAKEWORD(lpMsgBody[n].btNumberL ,lpMsgBody[n].btNumberH),
; 21174: 				lpMsgBody[n].szPShopText
; 21175: 				);
; 21176: 		}
; 21177: */
; 21178: 	}

  004e8	eb 1e		 jmp	 SHORT $LN28@PShop_View
$LN27@PShop_View:

; 21179: 	else if (iVpAddCount != 0) {

  004ea	83 bd f0 bf ff
	ff 00		 cmp	 DWORD PTR _iVpAddCount$[ebp], 0
  004f1	74 15		 je	 SHORT $LN28@PShop_View

; 21180: 		// 
; 21181: 		LogAddTD("[PShop] ERROR : iVpAddCount is OUT of BOUND: %d", iVpAddCount);

  004f3	8b 85 f0 bf ff
	ff		 mov	 eax, DWORD PTR _iVpAddCount$[ebp]
  004f9	50		 push	 eax
  004fa	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@GGNIPOJP@?$FLPShop?$FN?5ERROR?5?3?5iVpAddCount?5is?5@
  004ff	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00505	83 c4 08	 add	 esp, 8
$LN28@PShop_View:

; 21182: 	}
; 21183: 
; 21184: 
; 21185: 	// 4 .          .       
; 21186: 	if (gObj[aIndex].m_bPShopWantDeal == true) {

  00508	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0050c	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00512	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00518	0f b6 84 0a 20
	0d 00 00	 movzx	 eax, BYTE PTR [edx+ecx+3360]
  00520	83 f8 01	 cmp	 eax, 1
  00523	0f 85 1d 03 00
	00		 jne	 $LN1@PShop_View

; 21187: 		if (gObjIsConnected(gObj[aIndex].m_iPShopDealerIndex)) {

  00529	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0052d	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00533	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00539	8b 84 0a 24 0d
	00 00		 mov	 eax, DWORD PTR [edx+ecx+3364]
  00540	50		 push	 eax
  00541	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00546	83 c4 04	 add	 esp, 4
  00549	85 c0		 test	 eax, eax
  0054b	0f 84 79 02 00
	00		 je	 $LN31@PShop_View

; 21188: 			if (gObj[gObj[aIndex].m_iPShopDealerIndex].Type == OBJTYPE_CHARACTER) {

  00551	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00555	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0055b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00561	69 84 0a 24 0d
	00 00 a0 1b 00
	00		 imul	 eax, DWORD PTR [edx+ecx+3364], 7072
  0056c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00572	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00577	83 fa 01	 cmp	 edx, 1
  0057a	0f 85 cc 01 00
	00		 jne	 $LN33@PShop_View

; 21189: 				if (gObj[gObj[aIndex].m_iPShopDealerIndex].m_bPShopOpen == false) {

  00580	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00584	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0058a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00590	69 84 0a 24 0d
	00 00 a0 1b 00
	00		 imul	 eax, DWORD PTR [edx+ecx+3364], 7072
  0059b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005a1	0f b6 94 01 f8
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3320]
  005a9	85 d2		 test	 edx, edx
  005ab	0f 85 81 00 00
	00		 jne	 $LN35@PShop_View

; 21190: 					//  .
; 21191: 					gObj[aIndex].m_bPShopWantDeal = false;

  005b1	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  005b5	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  005bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005c1	c6 84 0a 20 0d
	00 00 00	 mov	 BYTE PTR [edx+ecx+3360], 0

; 21192: 					gObj[aIndex].m_iPShopDealerIndex = -1;

  005c9	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  005cd	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  005d3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005d9	c7 84 0a 24 0d
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+ecx+3364], -1

; 21193: 					memset (gObj[aIndex].m_szPShopDealerName, 0, MAX_IDSTRING);

  005e4	6a 0a		 push	 10			; 0000000aH
  005e6	6a 00		 push	 0
  005e8	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  005ec	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  005f2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005f8	8d 84 0a 28 0d
	00 00		 lea	 eax, DWORD PTR [edx+ecx+3368]
  005ff	50		 push	 eax
  00600	e8 00 00 00 00	 call	 _memset
  00605	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21194: 
; 21195: 					CGPShopAnsDealerClosedShop (aIndex, gObj[aIndex].m_iPShopDealerIndex);

  00608	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0060c	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00612	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00618	8b 84 0a 24 0d
	00 00		 mov	 eax, DWORD PTR [edx+ecx+3364]
  0061f	50		 push	 eax
  00620	0f bf 4d 08	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  00624	51		 push	 ecx
  00625	e8 00 00 00 00	 call	 ?CGPShopAnsDealerClosedShop@@YAXHH@Z ; CGPShopAnsDealerClosedShop
  0062a	83 c4 08	 add	 esp, 8

; 21196: 				}

  0062d	e9 18 01 00 00	 jmp	 $LN36@PShop_View
$LN35@PShop_View:

; 21197: #ifdef BUGFIX_PERSONALSHOP_ZENCOPY_20050426
; 21198: 				else if (
; 21199: 					gObj[gObj[aIndex].m_iPShopDealerIndex].CloseCount >= 0 ||

  00632	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00636	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0063c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00642	69 84 0a 24 0d
	00 00 a0 1b 00
	00		 imul	 eax, DWORD PTR [edx+ecx+3364], 7072
  0064d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00653	0f be 54 01 0a	 movsx	 edx, BYTE PTR [ecx+eax+10]
  00658	85 d2		 test	 edx, edx
  0065a	7d 19		 jge	 SHORT $LN39@PShop_View
  0065c	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00660	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00666	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0066c	0f be 44 0a 0a	 movsx	 eax, BYTE PTR [edx+ecx+10]
  00671	85 c0		 test	 eax, eax
  00673	7c 7e		 jl	 SHORT $LN37@PShop_View
$LN39@PShop_View:

; 21200: 					gObj[aIndex].CloseCount >= 0
; 21201: 					)
; 21202: 				{
; 21203: 					//  .
; 21204: 					gObj[aIndex].m_bPShopWantDeal = false;

  00675	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00679	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0067f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00685	c6 84 0a 20 0d
	00 00 00	 mov	 BYTE PTR [edx+ecx+3360], 0

; 21205: 					gObj[aIndex].m_iPShopDealerIndex = -1;

  0068d	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00691	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00697	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0069d	c7 84 0a 24 0d
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+ecx+3364], -1

; 21206: 					memset (gObj[aIndex].m_szPShopDealerName, 0, MAX_IDSTRING);

  006a8	6a 0a		 push	 10			; 0000000aH
  006aa	6a 00		 push	 0
  006ac	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  006b0	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  006b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006bc	8d 84 0a 28 0d
	00 00		 lea	 eax, DWORD PTR [edx+ecx+3368]
  006c3	50		 push	 eax
  006c4	e8 00 00 00 00	 call	 _memset
  006c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21207: 
; 21208: 					CGPShopAnsDealerClosedShop (aIndex, gObj[aIndex].m_iPShopDealerIndex);

  006cc	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  006d0	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  006d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006dc	8b 84 0a 24 0d
	00 00		 mov	 eax, DWORD PTR [edx+ecx+3364]
  006e3	50		 push	 eax
  006e4	0f bf 4d 08	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  006e8	51		 push	 ecx
  006e9	e8 00 00 00 00	 call	 ?CGPShopAnsDealerClosedShop@@YAXHH@Z ; CGPShopAnsDealerClosedShop
  006ee	83 c4 08	 add	 esp, 8

; 21209: 				}

  006f1	eb 57		 jmp	 SHORT $LN36@PShop_View
$LN37@PShop_View:

; 21210: #endif
; 21211: 				else {
; 21212: 					//    .
; 21213: 					if (gObj[gObj[aIndex].m_iPShopDealerIndex].m_bPShopItemChange == true) {

  006f3	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  006f7	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  006fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00703	69 84 0a 24 0d
	00 00 a0 1b 00
	00		 imul	 eax, DWORD PTR [edx+ecx+3364], 7072
  0070e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00714	0f b6 94 01 fa
	0c 00 00	 movzx	 edx, BYTE PTR [ecx+eax+3322]
  0071c	83 fa 01	 cmp	 edx, 1
  0071f	75 29		 jne	 SHORT $LN36@PShop_View

; 21214: 						//       .
; 21215: 						CGPShopAnsBuyList (aIndex, gObj[aIndex].m_iPShopDealerIndex, true, true);

  00721	6a 01		 push	 1
  00723	6a 01		 push	 1
  00725	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00729	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0072f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00735	8b 84 0a 24 0d
	00 00		 mov	 eax, DWORD PTR [edx+ecx+3364]
  0073c	50		 push	 eax
  0073d	0f bf 4d 08	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  00741	51		 push	 ecx
  00742	e8 00 00 00 00	 call	 ?CGPShopAnsBuyList@@YAXHHE_N@Z ; CGPShopAnsBuyList
  00747	83 c4 10	 add	 esp, 16			; 00000010H
$LN36@PShop_View:

; 21216: 					}
; 21217: 				}
; 21218: 
; 21219: 
; 21220: /*
; 21221: 				//      .
; 21222: 				else {
; 21223: 					if (memcmp(gObj[gObj[aIndex].m_iPShopDealerIndex].Name, gObj[aIndex].m_szPShopDealerName, MAX_IDSTRING)) {
; 21224: 						//  . ( )
; 21225: 						gObj[aIndex].m_bPShopWantDeal = false;
; 21226: 						gObj[aIndex].m_iPShopDealerIndex = -1;
; 21227: 						memset (gObj[aIndex].m_szPShopDealerName, 0, MAX_IDSTRING);
; 21228: 
; 21229: 						CGPShopAnsDealerClosedShop (aIndex, gObj[aIndex].m_iPShopDealerIndex);
; 21230: 					}
; 21231: 				}
; 21232: */
; 21233: 			}

  0074a	eb 7c		 jmp	 SHORT $LN34@PShop_View
$LN33@PShop_View:

; 21234: 			else {
; 21235: 				//  .
; 21236: 				gObj[aIndex].m_bPShopWantDeal = false;

  0074c	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00750	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00756	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0075c	c6 84 0a 20 0d
	00 00 00	 mov	 BYTE PTR [edx+ecx+3360], 0

; 21237: 				gObj[aIndex].m_iPShopDealerIndex = -1;

  00764	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00768	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0076e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00774	c7 84 0a 24 0d
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+ecx+3364], -1

; 21238: 				memset (gObj[aIndex].m_szPShopDealerName, 0, MAX_IDSTRING);

  0077f	6a 0a		 push	 10			; 0000000aH
  00781	6a 00		 push	 0
  00783	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00787	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0078d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00793	8d 84 0a 28 0d
	00 00		 lea	 eax, DWORD PTR [edx+ecx+3368]
  0079a	50		 push	 eax
  0079b	e8 00 00 00 00	 call	 _memset
  007a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21239: 
; 21240: 				CGPShopAnsDealerClosedShop (aIndex, gObj[aIndex].m_iPShopDealerIndex);

  007a3	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  007a7	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  007ad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007b3	8b 84 0a 24 0d
	00 00		 mov	 eax, DWORD PTR [edx+ecx+3364]
  007ba	50		 push	 eax
  007bb	0f bf 4d 08	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  007bf	51		 push	 ecx
  007c0	e8 00 00 00 00	 call	 ?CGPShopAnsDealerClosedShop@@YAXHH@Z ; CGPShopAnsDealerClosedShop
  007c5	83 c4 08	 add	 esp, 8
$LN34@PShop_View:

; 21241: 			}
; 21242: 		}

  007c8	eb 7c		 jmp	 SHORT $LN1@PShop_View
$LN31@PShop_View:

; 21243: 		else {
; 21244: 			//    .
; 21245: 			gObj[aIndex].m_bPShopWantDeal = false;

  007ca	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  007ce	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  007d4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007da	c6 84 0a 20 0d
	00 00 00	 mov	 BYTE PTR [edx+ecx+3360], 0

; 21246: 			gObj[aIndex].m_iPShopDealerIndex = -1;

  007e2	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  007e6	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  007ec	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007f2	c7 84 0a 24 0d
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [edx+ecx+3364], -1

; 21247: 			memset (gObj[aIndex].m_szPShopDealerName, 0, MAX_IDSTRING);

  007fd	6a 0a		 push	 10			; 0000000aH
  007ff	6a 00		 push	 0
  00801	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00805	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0080b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00811	8d 84 0a 28 0d
	00 00		 lea	 eax, DWORD PTR [edx+ecx+3368]
  00818	50		 push	 eax
  00819	e8 00 00 00 00	 call	 _memset
  0081e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 21248: 			
; 21249: 			CGPShopAnsDealerClosedShop (aIndex, gObj[aIndex].m_iPShopDealerIndex);

  00821	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00825	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0082b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00831	8b 84 0a 24 0d
	00 00		 mov	 eax, DWORD PTR [edx+ecx+3364]
  00838	50		 push	 eax
  00839	0f bf 4d 08	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  0083d	51		 push	 ecx
  0083e	e8 00 00 00 00	 call	 ?CGPShopAnsDealerClosedShop@@YAXHH@Z ; CGPShopAnsDealerClosedShop
  00843	83 c4 08	 add	 esp, 8
$LN1@PShop_View:

; 21250: 		}
; 21251: 	}
; 21252: }

  00846	5f		 pop	 edi
  00847	5e		 pop	 esi
  00848	5b		 pop	 ebx
  00849	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0084c	33 cd		 xor	 ecx, ebp
  0084e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00853	8b e5		 mov	 esp, ebp
  00855	5d		 pop	 ebp
  00856	c3		 ret	 0
?PShop_ViewportListRegenarate@@YAXF@Z ENDP		; PShop_ViewportListRegenarate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSecondProc@@YAXXZ
_TEXT	SEGMENT
_szTemp$1 = -156					; size = 128
_ground$2 = -28						; size = 4
_ground$3 = -24						; size = 4
_bt_time$4 = -20					; size = 4
_GroundOutCheck$5 = -16					; size = 4
_lpObj$ = -12						; size = 4
_n$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?gObjSecondProc@@YAXXZ PROC				; gObjSecondProc, COMDAT

; 22506: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 22507: 	int n;
; 22508: 	LPOBJECTSTRUCT	lpObj;
; 22509: 	
; 22510: 	if( gDisconnect == 1 ) return;	

  00016	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gDisconnect@@3HA, 1 ; gDisconnect
  0001d	75 05		 jne	 SHORT $LN5@gObjSecond
  0001f	e9 a9 05 00 00	 jmp	 $LN1@gObjSecond
$LN5@gObjSecond:

; 22511: 
; 22512: #ifdef GS_DS_LIVECHECK_20041008			// [0x58] GS -> DS  LIVE   .
; 22513: 	// 1  DS 
; 22514: 	cDBSMng.CheckDBServerLivePerSec();
; 22515: 	// 1  DS  
; 22516: 	GS_GDReqLiveCheck();
; 22517: #endif
; 22518: 
; 22519: #ifdef ADD_HACKING_TOOL_BLOCK_20090311
; 22520: 	//          
; 22521: 	g_HackToolBlock.CheckStatisticsResult();
; 22522: 	g_HackToolBlock.CheckBlockActive();
; 22523: #endif // ADD_HACKING_TOOL_BLOCK_20090311
; 22524: 
; 22525: #ifdef FOR_THAILAND	
; 22526: 	struct tm * today;
; 22527: 	time_t		ltime;				
; 22528: 	
; 22529: 	time( &ltime );
; 22530: 	today = localtime( &ltime );
; 22531: #endif
; 22532: 
; 22533: 
; 22534: #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 22535: 	gObjSendTimeView(1);
; 22536: 	GuildWarAndBattleSoccerTimeCheck();
; 22537: #endif
; 22538: 	
; 22539: 	for( n=0; n<MAX_OBJECT; n++ )

  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  0002b	eb 09		 jmp	 SHORT $LN4@gObjSecond
$LN2@gObjSecond:
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00030	83 c0 01	 add	 eax, 1
  00033	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjSecond:
  00036	81 7d f8 e8 1c
	00 00		 cmp	 DWORD PTR _n$[ebp], 7400 ; 00001ce8H
  0003d	0f 8d 8a 05 00
	00		 jge	 $LN1@gObjSecond

; 22540: 	{
; 22541: 		lpObj = &gObj[n];

  00043	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  0004a	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00050	89 45 f4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 22542: 				
; 22543: 		if( lpObj->Connected > 2 )

  00053	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00056	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  0005a	0f 8e ea 02 00
	00		 jle	 $LN6@gObjSecond

; 22544: 		{
; 22545: #ifdef MAP_SERVER_WORK_20041030		//    
; 22546: 			if (lpObj->m_bMapSvrMoveQuit == true) {
; 22547: 				if (GetTickCount() - lpObj->m_dwMapSvrQuitTick > 30*1000) {
; 22548: 					//    30      . ->     .
; 22549: 					gObjDel(lpObj->m_Index);
; 22550: 					continue;
; 22551: 				}
; 22552: 			}
; 22553: #endif
; 22554: 			if(lpObj->m_bShell == true)

  00060	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00063	0f b6 88 7d 1a
	00 00		 movzx	 ecx, BYTE PTR [eax+6781]
  0006a	83 f9 01	 cmp	 ecx, 1
  0006d	75 02		 jne	 SHORT $LN7@gObjSecond

; 22555: 				continue;

  0006f	eb bc		 jmp	 SHORT $LN2@gObjSecond
$LN7@gObjSecond:

; 22556: 
; 22557: 			gObjSkillUseProc(lpObj);

  00071	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ?gObjSkillUseProc@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSkillUseProc
  0007a	83 c4 04	 add	 esp, 4

; 22558: #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 22559: 			gObjCheckBuffEffectList( lpObj );
; 22560: #else
; 22561: 			gObjSkillBeAttackProc(lpObj);

  0007d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ?gObjSkillBeAttackProc@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSkillBeAttackProc
  00086	83 c4 04	 add	 esp, 4

; 22562: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 22563: 
; 22564: #ifdef SECOND_QUEST
; 22565: 			if( lpObj->Type == OBJTYPE_NPC &&  lpObj->Class == NPC_QEUSTNPC2 )

  00089	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00090	83 f9 03	 cmp	 ecx, 3
  00093	75 20		 jne	 SHORT $LN8@gObjSecond
  00095	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00098	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0009f	81 f9 e5 00 00
	00		 cmp	 ecx, 229		; 000000e5H
  000a5	75 0e		 jne	 SHORT $LN8@gObjSecond

; 22566: 			{
; 22567: 				gQeustNpcTeleport.Run(n);

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000aa	50		 push	 eax
  000ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A ; gQeustNpcTeleport
  000b0	e8 00 00 00 00	 call	 ?Run@CQeustNpcTeleport@@QAEXH@Z ; CQeustNpcTeleport::Run
$LN8@gObjSecond:

; 22568: 			}
; 22569: #endif
; 22570: 
; 22571: 			if( lpObj->Type == OBJTYPE_MONSTER )

  000b5	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b8	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  000bc	83 f9 02	 cmp	 ecx, 2
  000bf	75 24		 jne	 SHORT $LN11@gObjSecond

; 22572: 			{
; 22573: #ifdef ADD_ABILLITY_KUNDUN_01_20040920
; 22574: 				// 6   HP 
; 22575: 				if( lpObj->Class == 275 )

  000c1	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c4	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000cb	81 f9 13 01 00
	00		 cmp	 ecx, 275		; 00000113H
  000d1	75 12		 jne	 SHORT $LN11@gObjSecond

; 22576: 				{		
; 22577: 					// 0.01%  
; 22578: #ifdef ADD_KUNDUN_CONTROL_20040923
; 22579: 					gObjRefillMonsterHP(lpObj, giKundunRefillHPSec);

  000d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?giKundunRefillHPSec@@3HA ; giKundunRefillHPSec
  000d8	50		 push	 eax
  000d9	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 ?gObjRefillMonsterHP@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjRefillMonsterHP
  000e2	83 c4 08	 add	 esp, 8
$LN11@gObjSecond:

; 22580: #else
; 22581: 					gObjRefillMonsterHP(lpObj, 1);
; 22582: #endif
; 22583: 
; 22584: 				}
; 22585: #endif
; 22586: 				
; 22587: #ifdef CASTLE_NPC_GUARDIANSTATUE_WORK_20041207			//  
; 22588: 				if (lpObj->Class == 283) {
; 22589: 					g_CsNPC_GuardianStatue.GuardianStatueAct(lpObj->m_Index);
; 22590: 					continue;
; 22591: 				}
; 22592: #endif
; 22593: 
; 22594: #ifdef CASTLE_NPC_LIFESTONE_WORK_20041208				//  () 
; 22595: 				if (lpObj->Class == NPC_INDEX_LIFESTONE ) 
; 22596: 				{
; 22597: 					g_CsNPC_LifeStone.LifeStoneAct(lpObj->m_Index);
; 22598: 					continue;
; 22599: 				}
; 22600: #endif
; 22601: 
; 22602: #ifdef ADD_NEW_WEAPON_FOR_CASTLE_01_20041116			//  
; 22603: 				if( lpObj->Class == NPC_INDEX_GUARDIAN )
; 22604: 				{
; 22605: 					g_CsNPC_Guardian.GuardianAct(lpObj->m_Index);
; 22606: 					continue;
; 22607: 				}
; 22608: #endif
; 22609: 
; 22610: #ifdef CASTLE_NPC_CANNON_TOWER_20041223					//  
; 22611: 				if (lpObj->Class == 288) {
; 22612: 					g_CsNPC_CannonTower.CannonTowerAct(lpObj->m_Index);
; 22613: 					continue;
; 22614: 				}
; 22615: #endif
; 22616: 
; 22617: #ifdef CRYWOLF_MONSTER_WORK_20050914
; 22618: 				g_Crywolf.CrywolfMonsterAct( lpObj->m_Index );
; 22619: #endif
; 22620: 				
; 22621: 			}		
; 22622: 			
; 22623: 			if( lpObj->Type == OBJTYPE_NPC )
; 22624: 			{
; 22625: 				
; 22626: #ifdef CRYWOLF_NPC_WORK_20050912						//  NPC 
; 22627: 				if( CHECK_CRYWOLF_SPECIAL_NPC(lpObj->Class) )
; 22628: 					g_Crywolf.CrywolfNpcAct( lpObj->m_Index );
; 22629: #endif
; 22630: 				
; 22631: #ifdef CASTLE_NPC_CROWN_WORK_20041210					//  
; 22632: 				if (lpObj->Class == CS_NPC_CROWN)
; 22633: 				{
; 22634: 					g_CsNPC_CastleCrown.CastleCrownAct(lpObj->m_Index);
; 22635: 					continue;
; 22636: 				}
; 22637: #endif
; 22638: 
; 22639: #ifdef CASTLE_NPC_CROWN_SWITCH_WORK_20041210			//   
; 22640: 				if (CHECK_NPC_CROWN_SWITCH(lpObj->Class))
; 22641: 				{
; 22642: 					g_CsNPC_CastleCrownSwitch.CastleCrownSwitchAct(lpObj->m_Index);
; 22643: 					continue;
; 22644: 				}
; 22645: #endif
; 22646: 
; 22647: #ifdef ADD_NEW_WEAPON_FOR_CASTLE_01_20041116
; 22648: 				if( lpObj->Class == NPC_SIEGE_MACHINE_ATTACK || lpObj->Class == NPC_SIEGE_MACHINE_DEFENSE )
; 22649: 					g_CsNPC_Weapon.WeaponAct(lpObj->m_Index);
; 22650: #endif
; 22651: 			}
; 22652: 	
; 22653: 			if( lpObj->Type == OBJTYPE_CHARACTER )

  000e5	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e8	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  000ec	83 f9 01	 cmp	 ecx, 1
  000ef	0f 85 55 02 00
	00		 jne	 $LN6@gObjSecond

; 22654: 			{
; 22655: 				gObjManaPotionFill(lpObj);

  000f5	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ?gObjManaPotionFill@@YAXPAVOBJECTSTRUCT@@@Z ; gObjManaPotionFill
  000fe	83 c4 04	 add	 esp, 4

; 22656: 				gObjRestPotionFill(lpObj);

  00101	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ?gObjRestPotionFill@@YAXPAVOBJECTSTRUCT@@@Z ; gObjRestPotionFill
  0010a	83 c4 04	 add	 esp, 4

; 22657: 
; 22658: #ifdef ADD_LOG_CHECK_INVLIDE_X_Y_POSITION_20060131
; 22659: 				gObjCheckXYMapTile(lpObj, DBGNAME_gObjSecondProc);

  0010d	6a 03		 push	 3
  0010f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 ?gObjCheckXYMapTile@@YAHPAVOBJECTSTRUCT@@H@Z ; gObjCheckXYMapTile
  00118	83 c4 08	 add	 esp, 8

; 22660: #else
; 22661: 				gObjCheckXYMapTile(lpObj);
; 22662: #endif // ADD_LOG_CHECK_INVLIDE_X_Y_POSITION_20060131
; 22663: 
; 22664: #ifdef DARKLORD_WORK
; 22665: 				if( lpObj->ChatLitmitTime > 0 )

  0011b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0011e	0f b7 88 dc 00
	00 00		 movzx	 ecx, WORD PTR [eax+220]
  00125	85 c9		 test	 ecx, ecx
  00127	0f 8e 80 00 00
	00		 jle	 $LN13@gObjSecond

; 22666: 				{
; 22667: 					lpObj->ChatLimitTimeSec++;

  0012d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00130	8a 88 de 00 00
	00		 mov	 cl, BYTE PTR [eax+222]
  00136	80 c1 01	 add	 cl, 1
  00139	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0013c	88 8a de 00 00
	00		 mov	 BYTE PTR [edx+222], cl

; 22668: 					if( lpObj->ChatLimitTimeSec > 60 )

  00142	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00145	0f b6 88 de 00
	00 00		 movzx	 ecx, BYTE PTR [eax+222]
  0014c	83 f9 3c	 cmp	 ecx, 60			; 0000003cH
  0014f	7e 5c		 jle	 SHORT $LN13@gObjSecond

; 22669: 					{
; 22670: 						lpObj->ChatLimitTimeSec = 0;

  00151	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00154	c6 80 de 00 00
	00 00		 mov	 BYTE PTR [eax+222], 0

; 22671: 						lpObj->ChatLitmitTime--;

  0015b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0015e	66 8b 88 dc 00
	00 00		 mov	 cx, WORD PTR [eax+220]
  00165	66 83 e9 01	 sub	 cx, 1
  00169	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0016c	66 89 8a dc 00
	00 00		 mov	 WORD PTR [edx+220], cx

; 22672: 						if( lpObj->ChatLitmitTime < 1 )

  00173	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00176	0f b7 88 dc 00
	00 00		 movzx	 ecx, WORD PTR [eax+220]
  0017d	83 f9 01	 cmp	 ecx, 1
  00180	7d 2b		 jge	 SHORT $LN13@gObjSecond

; 22673: 						{
; 22674: 							lpObj->ChatLitmitTime = 0;							

  00182	33 c0		 xor	 eax, eax
  00184	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00187	66 89 81 dc 00
	00 00		 mov	 WORD PTR [ecx+220], ax

; 22675: 							MsgOutput(lpObj->m_Index,lMsg.Get(1141));	//  

  0018e	68 75 04 00 00	 push	 1141			; 00000475H
  00193	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00198	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0019e	50		 push	 eax
  0019f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a4	51		 push	 ecx
  001a5	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  001aa	83 c4 08	 add	 esp, 8
$LN13@gObjSecond:

; 22676: 						}
; 22677: 					}
; 22678: 				}
; 22679: #endif
; 22680: 
; 22681: #ifdef CHARACTER_AUTO_RECUPERATION_SYSTEM_20050614
; 22682: 				if(g_iUseCharacterAutoRecuperationSystem && lpObj->Level <= g_iCharacterRecuperationMaxLevel) {
; 22683: 					gProcessAutoRecuperation(lpObj);
; 22684: 				}
; 22685: #endif
; 22686: 
; 22687: #ifdef ADD_SHIELD_POINT_01_20060403
; 22688: 				if( lpObj->Type == OBJTYPE_CHARACTER )
; 22689: 				{
; 22690: 					gObjShieldAutoRefill( lpObj );
; 22691: 				}
; 22692: #endif
; 22693: 				if( lpObj->Type == OBJTYPE_CHARACTER )

  001ad	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b0	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  001b4	83 f9 01	 cmp	 ecx, 1
  001b7	75 23		 jne	 SHORT $LN16@gObjSecond

; 22694: 				{
; 22695: 					if( lpObj->m_LastTeleportTime > 0 )

  001b9	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001bc	0f be 88 e9 0e
	00 00		 movsx	 ecx, BYTE PTR [eax+3817]
  001c3	85 c9		 test	 ecx, ecx
  001c5	7e 15		 jle	 SHORT $LN16@gObjSecond

; 22696: 					{
; 22697: 						lpObj->m_LastTeleportTime--;

  001c7	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ca	8a 88 e9 0e 00
	00		 mov	 cl, BYTE PTR [eax+3817]
  001d0	80 e9 01	 sub	 cl, 1
  001d3	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001d6	88 8a e9 0e 00
	00		 mov	 BYTE PTR [edx+3817], cl
$LN16@gObjSecond:

; 22698: 					}
; 22699: 				}
; 22700: 				
; 22701: #ifdef NEW_FORSKYLAND3
; 22702: 				gObjDelayLifeCheck(n);

  001dc	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 ?gObjDelayLifeCheck@@YAXH@Z ; gObjDelayLifeCheck
  001e5	83 c4 04	 add	 esp, 4

; 22703: #endif
; 22704: 
; 22705: #ifdef APPLY_PACKETCHECKSUM_T_T
; 22706: 				lpObj->m_PacketChecksumTime++;
; 22707: 				if( lpObj->m_PacketChecksumTime > 300 )
; 22708: 				{
; 22709: 					lpObj->m_PacketChecksumTime = 0;
; 22710: 					gPacketCheckSum.Check(lpObj->m_Index);
; 22711: 				}
; 22712: #endif
; 22713: 				//    (20030308)(foguy) 
; 22714: 				gObjSecondDurDown(lpObj);

  001e8	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001eb	50		 push	 eax
  001ec	e8 00 00 00 00	 call	 ?gObjSecondDurDown@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSecondDurDown
  001f1	83 c4 04	 add	 esp, 4

; 22715: 				
; 22716: 				if( lpObj->PartyNumber>=0)

  001f4	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f7	83 b8 88 02 00
	00 00		 cmp	 DWORD PTR [eax+648], 0
  001fe	7c 14		 jl	 SHORT $LN18@gObjSecond

; 22717: 					gParty.PartyMemberLifeSend(lpObj->PartyNumber);

  00200	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00203	8b 88 88 02 00
	00		 mov	 ecx, DWORD PTR [eax+648]
  00209	51		 push	 ecx
  0020a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0020f	e8 00 00 00 00	 call	 ?PartyMemberLifeSend@PartyClass@@QAEXH@Z ; PartyClass::PartyMemberLifeSend
$LN18@gObjSecond:

; 22718: 				
; 22719: 				//      .
; 22720: 				if( lpObj->m_ShopTime >= 1 ) 

  00214	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00217	0f b6 88 ec 01
	00 00		 movzx	 ecx, BYTE PTR [eax+492]
  0021e	83 f9 01	 cmp	 ecx, 1
  00221	7c 27		 jl	 SHORT $LN19@gObjSecond

; 22721: 				{
; 22722: 					if( lpObj->m_ShopTime < 255 ) lpObj->m_ShopTime++;

  00223	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00226	0f b6 88 ec 01
	00 00		 movzx	 ecx, BYTE PTR [eax+492]
  0022d	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00233	7d 15		 jge	 SHORT $LN19@gObjSecond
  00235	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00238	8a 88 ec 01 00
	00		 mov	 cl, BYTE PTR [eax+492]
  0023e	80 c1 01	 add	 cl, 1
  00241	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00244	88 8a ec 01 00
	00		 mov	 BYTE PTR [edx+492], cl
$LN19@gObjSecond:

; 22723: 				}
; 22724: 				/*if( lpObj->m_TotalAttackCount > 0 )
; 22725: 				{
; 22726: 					if( (GetTickCount()-lpObj->m_TotalAttackTime) > (1000*5))
; 22727: 					{
; 22728: 						lpObj->m_TotalAttackTime = GetTickCount();
; 22729: 						//LogAdd("%s lpObj->m_TotalAttackCount : %d (%d %d %d)", lpObj->Name, lpObj->m_TotalAttackCount, lpObj->MapNumber, lpObj->X, lpObj->Y);
; 22730: 						lpObj->m_TotalAttackCount = 0;
; 22731: 					}
; 22732: 				}*/
; 22733: 				int GroundOutCheck = 1;

  0024a	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _GroundOutCheck$5[ebp], 1

; 22734: 				
; 22735: 				int bt_time = gCheckBattleGroundTimer();

  00251	e8 00 00 00 00	 call	 ?gCheckBattleGroundTimer@@YAHXZ ; gCheckBattleGroundTimer
  00256	89 45 ec	 mov	 DWORD PTR _bt_time$4[ebp], eax

; 22736: 
; 22737: 				//if( bt_time > 0 )
; 22738: 				{
; 22739: 					if( (lpObj->Authority&AUTHORITY_ADMIN) == AUTHORITY_ADMIN ) 

  00259	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0025c	8b 88 a4 01 00
	00		 mov	 ecx, DWORD PTR [eax+420]
  00262	83 e1 02	 and	 ecx, 2
  00265	74 19		 je	 SHORT $LN21@gObjSecond

; 22740: 					{
; 22741: 						GroundOutCheck = 0;					

  00267	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _GroundOutCheck$5[ebp], 0

; 22742: 				#ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 22743: 						GCTimeViewSend(lpObj->m_Index, eMatchType_BattleSoccer, bt_time);
; 22744: 				#else
; 22745: 						GCTimeViewSend(lpObj->m_Index, bt_time);

  0026e	8b 45 ec	 mov	 eax, DWORD PTR _bt_time$4[ebp]
  00271	50		 push	 eax
  00272	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00275	8b 11		 mov	 edx, DWORD PTR [ecx]
  00277	52		 push	 edx
  00278	e8 00 00 00 00	 call	 ?GCTimeViewSend@@YAXHH@Z ; GCTimeViewSend
  0027d	83 c4 08	 add	 esp, 8
$LN21@gObjSecond:

; 22746: 				#endif
; 22747: 					}
; 22748: 				}
; 22749: 
; 22750: #ifdef FOR_ONAIR	//       
; 22751: 				GroundOutCheck = 0;
; 22752: #endif
; 22753: 
; 22754: 				if( lpObj->MapNumber == 6 && GroundOutCheck == 1 )

  00280	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00283	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0028a	83 f9 06	 cmp	 ecx, 6
  0028d	0f 85 b7 00 00
	00		 jne	 $LN6@gObjSecond
  00293	83 7d f0 01	 cmp	 DWORD PTR _GroundOutCheck$5[ebp], 1
  00297	0f 85 ad 00 00
	00		 jne	 $LN6@gObjSecond

; 22755: 				{
; 22756: 					GroundOutCheck = 1;

  0029d	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _GroundOutCheck$5[ebp], 1

; 22757: 					if( lpObj->lpGuild != NULL )

  002a4	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a7	83 b8 94 02 00
	00 00		 cmp	 DWORD PTR [eax+660], 0
  002ae	74 68		 je	 SHORT $LN23@gObjSecond

; 22758: 					{
; 22759: 						if( lpObj->lpGuild->WarState ) 

  002b0	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002b3	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  002b9	0f b6 91 91 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1425]
  002c0	85 d2		 test	 edx, edx
  002c2	74 52		 je	 SHORT $LN25@gObjSecond

; 22760: 						{
; 22761: 							int ground = gCheckBattleGround(lpObj);

  002c4	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c7	50		 push	 eax
  002c8	e8 00 00 00 00	 call	 ?gCheckBattleGround@@YAHPAVOBJECTSTRUCT@@@Z ; gCheckBattleGround
  002cd	83 c4 04	 add	 esp, 4
  002d0	89 45 e8	 mov	 DWORD PTR _ground$3[ebp], eax

; 22762: 							if( ground != lpObj->lpGuild->BattleGroundIndex )

  002d3	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d6	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  002dc	0f b6 91 93 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1427]
  002e3	39 55 e8	 cmp	 DWORD PTR _ground$3[ebp], edx
  002e6	74 27		 je	 SHORT $LN26@gObjSecond

; 22763: 							{
; 22764: 								if( lpObj->lpGuild->WarType == BTT_SOCCER )

  002e8	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002eb	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  002f1	0f b6 91 92 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1426]
  002f8	83 fa 01	 cmp	 edx, 1
  002fb	75 09		 jne	 SHORT $LN28@gObjSecond

; 22765: 								{
; 22766: 									GroundOutCheck = 0;

  002fd	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _GroundOutCheck$5[ebp], 0

; 22767: 								}

  00304	eb 07		 jmp	 SHORT $LN29@gObjSecond
$LN28@gObjSecond:

; 22768: 								else
; 22769: 								{
; 22770: 									GroundOutCheck = 0;

  00306	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _GroundOutCheck$5[ebp], 0
$LN29@gObjSecond:

; 22771: 								}
; 22772: 							}

  0030d	eb 07		 jmp	 SHORT $LN25@gObjSecond
$LN26@gObjSecond:

; 22773: 							else GroundOutCheck = 0;

  0030f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _GroundOutCheck$5[ebp], 0
$LN25@gObjSecond:

; 22774: 						}
; 22775: 					}

  00316	eb 07		 jmp	 SHORT $LN24@gObjSecond
$LN23@gObjSecond:

; 22776: 					else 
; 22777: 					{
; 22778: 						GroundOutCheck = 1;

  00318	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _GroundOutCheck$5[ebp], 1
$LN24@gObjSecond:

; 22779: 					}
; 22780: #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 22781: 					GroundOutCheck = 0;
; 22782: #endif
; 22783: 					if( GroundOutCheck )

  0031f	83 7d f0 00	 cmp	 DWORD PTR _GroundOutCheck$5[ebp], 0
  00323	74 25		 je	 SHORT $LN6@gObjSecond

; 22784: 					{
; 22785: #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 22786: 						int ground = gCheckBattleGround(lpObj);
; 22787: 						if ( ground >= 0 )
; 22788: 						{
; 22789: 							gObjMoveGate(lpObj->m_Index, 82);
; 22790: 							//gObjTeleport(lpObj->m_Index, 6, 72, 161);
; 22791: 						}
; 22792: #else
; 22793: 						int ground = gCheckBattleGround(lpObj);

  00325	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00328	50		 push	 eax
  00329	e8 00 00 00 00	 call	 ?gCheckBattleGround@@YAHPAVOBJECTSTRUCT@@@Z ; gCheckBattleGround
  0032e	83 c4 04	 add	 esp, 4
  00331	89 45 e4	 mov	 DWORD PTR _ground$2[ebp], eax

; 22794: 						if ( ground >= 0 )

  00334	83 7d e4 00	 cmp	 DWORD PTR _ground$2[ebp], 0
  00338	7c 10		 jl	 SHORT $LN6@gObjSecond

; 22795: 						{
; 22796: 							gObjMoveGate(lpObj->m_Index, 17);

  0033a	6a 11		 push	 17			; 00000011H
  0033c	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0033f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00341	51		 push	 ecx
  00342	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00347	83 c4 08	 add	 esp, 8
$LN6@gObjSecond:

; 22797: 							//gObjTeleport(lpObj->m_Index, 6, 72, 161);
; 22798: 						}
; 22799: #endif
; 22800: 					}
; 22801: 				}				
; 22802: 			}
; 22803: 		}
; 22804: 		
; 22805: 		if( (lpObj->Connected >= CSS_LOGINOK
; 22806: #ifdef MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 22807: 			|| lpObj->Connected == CSS_LOGINWAIT
; 22808: #endif // MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 22809: 			) && (lpObj->Type == OBJTYPE_CHARACTER ) )

  0034a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0034d	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  00351	7d 0d		 jge	 SHORT $LN33@gObjSecond
  00353	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00356	83 78 04 ff	 cmp	 DWORD PTR [eax+4], -1
  0035a	0f 85 f7 00 00
	00		 jne	 $LN32@gObjSecond
$LN33@gObjSecond:
  00360	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00363	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00367	83 f9 01	 cmp	 ecx, 1
  0036a	0f 85 e7 00 00
	00		 jne	 $LN32@gObjSecond

; 22810: 		{
; 22811: 			if( lpObj->CloseCount > 0 )

  00370	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00373	0f be 48 0a	 movsx	 ecx, BYTE PTR [eax+10]
  00377	85 c9		 test	 ecx, ecx
  00379	0f 8e d8 00 00
	00		 jle	 $LN32@gObjSecond

; 22812: 			{
; 22813: 				if( lpObj->CloseCount == 1 )	// 

  0037f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00382	0f be 48 0a	 movsx	 ecx, BYTE PTR [eax+10]
  00386	83 f9 01	 cmp	 ecx, 1
  00389	75 7a		 jne	 SHORT $LN35@gObjSecond

; 22814: 				{
; 22815: 					if( lpObj->CloseType == CL_BACK )

  0038b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0038e	0f be 48 0b	 movsx	 ecx, BYTE PTR [eax+11]
  00392	83 f9 01	 cmp	 ecx, 1
  00395	75 25		 jne	 SHORT $LN37@gObjSecond

; 22816: 					{
; 22817: 						if( gObjGameClose(lpObj->m_Index) == TRUE)

  00397	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0039c	51		 push	 ecx
  0039d	e8 00 00 00 00	 call	 ?gObjGameClose@@YAHH@Z	; gObjGameClose
  003a2	83 c4 04	 add	 esp, 4
  003a5	83 f8 01	 cmp	 eax, 1
  003a8	75 10		 jne	 SHORT $LN39@gObjSecond

; 22818: 						{
; 22819: 							GCCloseMsgSend(lpObj->m_Index, 0x01);

  003aa	6a 01		 push	 1
  003ac	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003af	8b 08		 mov	 ecx, DWORD PTR [eax]
  003b1	51		 push	 ecx
  003b2	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  003b7	83 c4 08	 add	 esp, 8
$LN39@gObjSecond:

; 22820: #ifdef MODIFY_UPDATE_MATCHDB_AT_CHARACTERLIST_VIEW_20060725
; 22821: 							GJUpdateMatchDBUserCharacters(lpObj);
; 22822: #endif
; 22823: 						}
; 22824: 					}

  003ba	eb 47		 jmp	 SHORT $LN38@gObjSecond
$LN37@gObjSecond:

; 22825: 					else if( lpObj->CloseType == CL_EXIT )

  003bc	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003bf	0f be 48 0b	 movsx	 ecx, BYTE PTR [eax+11]
  003c3	85 c9		 test	 ecx, ecx
  003c5	75 20		 jne	 SHORT $LN40@gObjSecond

; 22826: 					{
; 22827: 						GCCloseMsgSend(lpObj->m_Index, 0x00);	//   .

  003c7	6a 00		 push	 0
  003c9	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ce	51		 push	 ecx
  003cf	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  003d4	83 c4 08	 add	 esp, 8

; 22828: 						CloseClient(lpObj->m_Index);

  003d7	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003da	8b 08		 mov	 ecx, DWORD PTR [eax]
  003dc	51		 push	 ecx
  003dd	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  003e2	83 c4 04	 add	 esp, 4

; 22829: 					}

  003e5	eb 1c		 jmp	 SHORT $LN38@gObjSecond
$LN40@gObjSecond:

; 22830: 					else if( lpObj->CloseType == CL_SERVERLIST )

  003e7	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003ea	0f be 48 0b	 movsx	 ecx, BYTE PTR [eax+11]
  003ee	83 f9 02	 cmp	 ecx, 2
  003f1	75 10		 jne	 SHORT $LN38@gObjSecond

; 22831: 					{
; 22832: #ifdef MODIFY_NEWPVP_GAME_CLOSING_BUGFIX_20070715
; 22833: 						gObjGameClose(lpObj->m_Index);
; 22834: #endif // MODIFY_NEWPVP_GAME_CLOSING_BUGFIX_20070715
; 22835: 						GCCloseMsgSend(lpObj->m_Index, 0x02);

  003f3	6a 02		 push	 2
  003f5	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  003fa	51		 push	 ecx
  003fb	e8 00 00 00 00	 call	 ?GCCloseMsgSend@@YAXHE@Z ; GCCloseMsgSend
  00400	83 c4 08	 add	 esp, 8
$LN38@gObjSecond:

; 22836: 					}
; 22837: 				}

  00403	eb 43		 jmp	 SHORT $LN36@gObjSecond
$LN35@gObjSecond:

; 22838: 				else
; 22839: 				{
; 22840: 					char szTemp[128];
; 22841: 					wsprintf(szTemp, lMsg.Get(1116), lpObj->CloseCount-1);

  00405	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00408	0f be 48 0a	 movsx	 ecx, BYTE PTR [eax+10]
  0040c	83 e9 01	 sub	 ecx, 1
  0040f	51		 push	 ecx
  00410	68 5c 04 00 00	 push	 1116			; 0000045cH
  00415	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0041a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00420	50		 push	 eax
  00421	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR _szTemp$1[ebp]
  00427	52		 push	 edx
  00428	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0042e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 22842: 					GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  00431	6a 01		 push	 1
  00433	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00436	8b 08		 mov	 ecx, DWORD PTR [eax]
  00438	51		 push	 ecx
  00439	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR _szTemp$1[ebp]
  0043f	52		 push	 edx
  00440	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00445	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN36@gObjSecond:

; 22843: 				}
; 22844: 				lpObj->CloseCount--;

  00448	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0044b	8a 48 0a	 mov	 cl, BYTE PTR [eax+10]
  0044e	80 e9 01	 sub	 cl, 1
  00451	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00454	88 4a 0a	 mov	 BYTE PTR [edx+10], cl
$LN32@gObjSecond:

; 22845: 			}
; 22846: 		}
; 22847: 		
; 22848: 		if( (lpObj->Connected > 2 ) && (lpObj->Type == OBJTYPE_CHARACTER ) )

  00457	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0045a	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  0045e	0f 8e d9 00 00
	00		 jle	 $LN43@gObjSecond
  00464	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00467	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0046b	83 f9 01	 cmp	 ecx, 1
  0046e	0f 85 c9 00 00
	00		 jne	 $LN43@gObjSecond

; 22849: 		{
; 22850: #ifdef CHINA_HACKUSER_KICK_SYSTEM		// 1  
; 22851: 			ChinaHackUserKick.ResetNCount(lpObj->m_Index);
; 22852: #endif
; 22853: 			//DevGamesX 01/05/2018 - OffExp
; 22854: 			OffExp.TickTimes(n);

  00474	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00477	50		 push	 eax
  00478	b9 00 00 00 00	 mov	 ecx, OFFSET ?OffExp@@3VcOffExp@@A ; OffExp
  0047d	e8 00 00 00 00	 call	 ?TickTimes@cOffExp@@QAEXH@Z ; cOffExp::TickTimes

; 22855: 			// 10   
; 22856: 			if( (GetTickCount()-lpObj->AutoSaveTime) > (1000*60*10) )

  00482	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00488	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0048b	2b 41 34	 sub	 eax, DWORD PTR [ecx+52]
  0048e	3d c0 27 09 00	 cmp	 eax, 600000		; 000927c0H
  00493	76 1e		 jbe	 SHORT $LN44@gObjSecond

; 22857: 			{				
; 22858: 				GJSetCharacterInfo(lpObj, n);

  00495	6a 00		 push	 0
  00497	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0049a	50		 push	 eax
  0049b	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0049e	51		 push	 ecx
  0049f	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAVOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo
  004a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 22859: 
; 22860: #ifdef CHECK_ATTACK_AREA
; 22861: 	#ifdef MU_CHN_HACKLOG_MODIFY_20040930
; 22862: 				if( lpObj->m_NotAttackAreaCount > 5 )
; 22863: 				{
; 22864: 					INT iCheckTickCount = (GetTickCount() - lpObj->AutoSaveTime) / 1000;
; 22865: 					if (iCheckTickCount < 1)
; 22866: 						iCheckTickCount = 1;
; 22867: 
; 22868: 		#ifdef CHINA_HACKUSER_KICK_SYSTEM		
; 22869: 					ChinaHackLogFile.Output("[%s][%s] Try Attack In Not Attack Area (%d)", 
; 22870: 										  lpObj->AccountID, 
; 22871: 										  lpObj->Name, 
; 22872: 										  lpObj->m_NotAttackAreaCount * 1000 / iCheckTickCount
; 22873: 										  );
; 22874: 		#else // else CHINA_HACKUSER_KICK_SYSTEM		
; 22875: 					LogAddTD("[%s][%s] Try Attack In Not Attack Area (%d)", 
; 22876: 							  lpObj->AccountID, 
; 22877: 							  lpObj->Name, 
; 22878: 							  lpObj->m_NotAttackAreaCount * 1000 / iCheckTickCount
; 22879: 							  );
; 22880: 		#endif // CHINA_HACKUSER_KICK_SYSTEM
; 22881: 
; 22882: 				}			
; 22883: 				lpObj->m_NotAttackAreaCount = 0;
; 22884: 	#endif // MU_CHN_HACKLOG_MODIFY_20040930		
; 22885: 	
; 22886: 	#ifdef MODIFY_HACKLOG_OF_ATTACK_20050518
; 22887: 				if( lpObj->m_NotAttackAreaCount > 5 )
; 22888: 				{	
; 22889: 					INT iCheckTickCount = (GetTickCount() - lpObj->AutoSaveTime) / 1000;
; 22890: 					if (iCheckTickCount < 1)
; 22891: 						iCheckTickCount = 1;
; 22892: 
; 22893: 		#ifdef CHINA_HACKUSER_KICK_SYSTEM		
; 22894: 					ChinaHackLogFile.Output("[%s][%s] Try Attack In Not Attack Area (%d) @%d", 
; 22895: 										    lpObj->AccountID, 
; 22896: 										    lpObj->Name, 
; 22897: 										    lpObj->m_NotAttackAreaCountFor10Min * 1000 / iCheckTickCount,
; 22898: 										    lpObj->MapNumber);
; 22899: 		#else // else CHINA_HACKUSER_KICK_SYSTEM	
; 22900: 					LogAddTD("[%s][%s] Try Attack In Not Attack Area (%d) @%d", 
; 22901: 							 lpObj->AccountID, 
; 22902: 							 lpObj->Name, 
; 22903: 							 lpObj->m_NotAttackAreaCount,
; 22904: 							 lpObj->MapNumber);
; 22905: 		#endif // CHINA_HACKUSER_KICK_SYSTEM
; 22906: 
; 22907: 				}
; 22908: 				lpObj->m_NotAttackAreaCountFor10Min = 0;
; 22909: 	#endif // MODIFY_HACKLOG_OF_ATTACK_20050518
; 22910: #endif // CHECK_ATTACK_AREA
; 22911: 				lpObj->AutoSaveTime = GetTickCount();

  004a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  004ad	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004b0	89 41 34	 mov	 DWORD PTR [ecx+52], eax
$LN44@gObjSecond:

; 22912: 			}
; 22913: 			
; 22914: 			if(lpObj->CheckSumTime > 0)

  004b3	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004b6	83 78 60 00	 cmp	 DWORD PTR [eax+96], 0
  004ba	76 49		 jbe	 SHORT $LN45@gObjSecond

; 22915: 			{
; 22916: #ifdef MODIFY_JOIN_ERROR_BUGFIX_20071211
; 22917: 				if( (GetTickCount()-lpObj->CheckSumTime) > 5000 )

  004bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  004c2	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004c5	2b 41 60	 sub	 eax, DWORD PTR [ecx+96]
  004c8	3d 88 13 00 00	 cmp	 eax, 5000		; 00001388H
  004cd	76 36		 jbe	 SHORT $LN45@gObjSecond

; 22918: #else
; 22919: 				if( (GetTickCount()-lpObj->CheckSumTime) > 3000 )
; 22920: #endif
; 22921: 				{
; 22922: 					if(lpObj->m_bShell == false)

  004cf	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004d2	0f b6 88 7d 1a
	00 00		 movzx	 ecx, BYTE PTR [eax+6781]
  004d9	85 c9		 test	 ecx, ecx
  004db	75 28		 jne	 SHORT $LN45@gObjSecond

; 22923: 					{
; 22924: #ifdef MODIFY_JOIN_ERROR_BUGFIX_20071211
; 22925: 						LogAddTD("[%s][%s] CheckSumTime Error", lpObj->AccountID, lpObj->Name);

  004dd	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004e0	83 c0 73	 add	 eax, 115		; 00000073H
  004e3	50		 push	 eax
  004e4	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004e7	83 c1 68	 add	 ecx, 104		; 00000068H
  004ea	51		 push	 ecx
  004eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@KBFDEFAD@?$FL?$CFs?$FN?$FL?$CFs?$FN?5CheckSumTime?5Error@
  004f0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004f6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 22926: #endif
; 22927: 						CloseClient(n);

  004f9	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  004fc	50		 push	 eax
  004fd	e8 00 00 00 00	 call	 ?CloseClient@@YAXH@Z	; CloseClient
  00502	83 c4 04	 add	 esp, 4
$LN45@gObjSecond:

; 22928: 					}
; 22929: 				}
; 22930: 			}
; 22931: 
; 22932: 
; 22933: 			gObjPkDownTimeCheck(lpObj, 1);

  00505	6a 01		 push	 1
  00507	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0050a	50		 push	 eax
  0050b	e8 00 00 00 00	 call	 ?gObjPkDownTimeCheck@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjPkDownTimeCheck
  00510	83 c4 08	 add	 esp, 8

; 22934: 
; 22935: 
; 22936: 			gObjInterfaceTimeCheck(lpObj);

  00513	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00516	50		 push	 eax
  00517	e8 00 00 00 00	 call	 ?gObjInterfaceTimeCheck@@YAXPAVOBJECTSTRUCT@@@Z ; gObjInterfaceTimeCheck
  0051c	83 c4 04	 add	 esp, 4

; 22937: 			gObjTimeCheckSelfDefense(lpObj);	

  0051f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00522	50		 push	 eax
  00523	e8 00 00 00 00	 call	 ?gObjTimeCheckSelfDefense@@YAXPAVOBJECTSTRUCT@@@Z ; gObjTimeCheckSelfDefense
  00528	83 c4 04	 add	 esp, 4

; 22938: 
; 22939: 			//DevGamesX 01/05/2018 - OffExp
; 22940: 			OffExp.Update(lpObj->m_Index, 1 );

  0052b	6a 01		 push	 1
  0052d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00530	8b 08		 mov	 ecx, DWORD PTR [eax]
  00532	51		 push	 ecx
  00533	b9 00 00 00 00	 mov	 ecx, OFFSET ?OffExp@@3VcOffExp@@A ; OffExp
  00538	e8 00 00 00 00	 call	 ?Update@cOffExp@@QAE_NHE@Z ; cOffExp::Update
$LN43@gObjSecond:

; 22941: 
; 22942: 			if(lpObj->m_bShell == false)
; 22943: 			{
; 22944: #ifdef NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_25_20060123
; 22945: 				gObjNProtectGGCheckSum(n);
; 22946: #else
; 22947: 	#if defined NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_10_20050411 || defined NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_20_20050411
; 22948: 				gObjNProtectGGCheckSum(n);
; 22949: 	#endif // NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_10_20050411 || NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_20_20050411
; 22950: #endif // NPROTECT_GAME_GAURD_FOR_SERVER_VERSION_25_20060123
; 22951: 			}
; 22952: #ifdef CHINA_GM_EVENT
; 22953: 			gObjGMEventProc(n);			
; 22954: #endif
; 22955: 
; 22956: #ifdef MODIFY_CHN_GMEVENT_TO_TAIWAN_GM_EVENT_20070906
; 22957: 			gObjGMEventProc(n);
; 22958: #endif // MODIFY_CHN_GMEVENT_TO_TAIWAN_GM_EVENT_20070906
; 22959: 		}
; 22960: 
; 22961: #ifdef PCBANG_POINT_SYSTEM_20070206		// gObjSecondProc()
; 22962: 		g_PCBangPointSystem.Run( lpObj );
; 22963: #endif
; 22964: 
; 22965: #ifdef FOR_THAILAND				
; 22966: 		if( (lpObj->Connected > 1 ) && (lpObj->Type == OBJTYPE_CHARACTER ) )
; 22967: 		{
; 22968: 			if( !lpObj->m_AuthAdult )
; 22969: 			{	//  
; 22970: 				char Msg[255];
; 22971: 				if( today->tm_hour >= 22 || today->tm_hour < 6)
; 22972: 				{	//      
; 22973: 					if( lpObj->m_DisplayTeenLogOutMsg )
; 22974: 					{
; 22975: 						wsprintf(Msg, lMsg.Get(1609));
; 22976: 						lpObj->m_DisplayTeenLogOutMsg = FALSE;
; 22977: 					}					
; 22978: 							
; 22979: 					GCServerMsgStringSend(Msg, n, 0);
; 22980: 					lpObj->m_DisplayTeenLogOutMsg = TRUE;
; 22981: 					gObjCloseSet(n, CL_EXIT);
; 22982: 				}
; 22983: 				else if( today->tm_hour == 21 )
; 22984: 				{	// 9  15     
; 22985: 					if( today->tm_min >= 45 )
; 22986: 					{
; 22987: 						if( !lpObj->m_DisplayTeenLogOutMsg )
; 22988: 						{							
; 22989: 							wsprintf(Msg, lMsg.Get(1608), 60-today->tm_min);
; 22990: 							
; 22991: 							GCServerMsgStringSend(Msg, n, 0);
; 22992: 							lpObj->m_DisplayTeenLogOutMsg = TRUE;
; 22993: 						}
; 22994: 					}
; 22995: 				}
; 22996: 			}
; 22997: 		}
; 22998: #endif
; 22999: 	
; 23000: 		if( lpObj->Connected == 1 || lpObj->Connected == 2 || lpObj->Connected == 3
; 23001: #ifdef MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 23002: 			|| lpObj->Connected == CSS_LOGINWAIT

  0053d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00540	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  00544	74 1b		 je	 SHORT $LN50@gObjSecond
  00546	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00549	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  0054d	74 12		 je	 SHORT $LN50@gObjSecond
  0054f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00552	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00556	74 09		 je	 SHORT $LN50@gObjSecond
  00558	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0055b	83 78 04 ff	 cmp	 DWORD PTR [eax+4], -1
  0055f	75 67		 jne	 SHORT $LN49@gObjSecond
$LN50@gObjSecond:

; 23003: #endif // MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 23004: 			)
; 23005: 		{
; 23006: 			if( lpObj->Type == OBJTYPE_CHARACTER )

  00561	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00564	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00568	83 f9 01	 cmp	 ecx, 1
  0056b	75 5b		 jne	 SHORT $LN49@gObjSecond

; 23007: 			{
; 23008: 				//      ...
; 23009: 				if( lpObj->Connected >= CSS_CHARACTERVIEW )

  0056d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00570	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  00574	7c 33		 jl	 SHORT $LN52@gObjSecond

; 23010: 				{
; 23011: 
; 23012: 					//DevGamesX 01/05/2018 - OffExp
; 23013: 					OffExp.Update(lpObj->m_Index, 1 );

  00576	6a 01		 push	 1
  00578	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0057b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0057d	51		 push	 ecx
  0057e	b9 00 00 00 00	 mov	 ecx, OFFSET ?OffExp@@3VcOffExp@@A ; OffExp
  00583	e8 00 00 00 00	 call	 ?Update@cOffExp@@QAE_NHE@Z ; cOffExp::Update

; 23014: 
; 23015: 					if( (GetTickCount()-lpObj->ConnectCheckTime) > (1000*60) )	// 60   

  00588	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0058e	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00591	2b 41 38	 sub	 eax, DWORD PTR [ecx+56]
  00594	3d 60 ea 00 00	 cmp	 eax, 60000		; 0000ea60H
  00599	76 0c		 jbe	 SHORT $LN54@gObjSecond

; 23016: 					{	
; 23017: 						ResponErrorCloseClient(n);

  0059b	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0059e	50		 push	 eax
  0059f	e8 00 00 00 00	 call	 ?ResponErrorCloseClient@@YAXH@Z ; ResponErrorCloseClient
  005a4	83 c4 04	 add	 esp, 4
$LN54@gObjSecond:

; 23018: 						//CloseClient(n);
; 23019: 						//LogAddTD(lMsg.Get(542), lpObj->m_Index, lpObj->AccountID, lpObj->Name, lpObj->Ip_addr);
; 23020: 					}
; 23021: 				}

  005a7	eb 1f		 jmp	 SHORT $LN49@gObjSecond
$LN52@gObjSecond:

; 23022: 				else 
; 23023: 				{
; 23024: 					if( (GetTickCount()-lpObj->ConnectCheckTime) > (1000*30) )	// 30   

  005a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  005af	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005b2	2b 41 38	 sub	 eax, DWORD PTR [ecx+56]
  005b5	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  005ba	76 0c		 jbe	 SHORT $LN49@gObjSecond

; 23025: 					{	
; 23026: 						ResponErrorCloseClient(n);

  005bc	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  005bf	50		 push	 eax
  005c0	e8 00 00 00 00	 call	 ?ResponErrorCloseClient@@YAXH@Z ; ResponErrorCloseClient
  005c5	83 c4 04	 add	 esp, 4
$LN49@gObjSecond:

; 23027: 						//CloseClient(n);
; 23028: 						//LogAddTD(lMsg.Get(543), lpObj->m_Index, lpObj->AccountID, lpObj->Name, lpObj->Ip_addr);
; 23029: 					}
; 23030: 				}
; 23031: 			}
; 23032: 		}
; 23033: 	}

  005c8	e9 60 fa ff ff	 jmp	 $LN2@gObjSecond
$LN1@gObjSecond:

; 23034: 
; 23035: #ifdef FOR_JAPAN
; 23036: 	if( gTamaJJangEvent )
; 23037: 	{
; 23038: 		gTamaJJangTime--;
; 23039: 		if( gTamaJJangTime <= 0 )
; 23040: 		{
; 23041: 			if( gAppearTamaJJang == FALSE )
; 23042: 			{
; 23043: 				gAppearTamaJJang = TRUE;
; 23044: 				gTamaJJangTime = gTamaJJangKeepTime;
; 23045: 				LogAddTD("Appear TamaJJang : Keep Time (%d)", gTamaJJangTime);
; 23046: 			}
; 23047: 			else
; 23048: 			{
; 23049: 				gAppearTamaJJang = FALSE;
; 23050: 				gTamaJJangTime = gTamaJJangDisappearTime+(rand()%gTamaJJangDisappearTimeRandomRange);
; 23051: 				LogAddTD("DisAppear TamaJJang : Keep Time (%d)", gTamaJJangTime);
; 23052: 			}
; 23053: 			GCMapEventStateSend(0, gAppearTamaJJang, 2);
; 23054: 		}
; 23055: 	}
; 23056: #endif
; 23057: 
; 23058: #ifdef AUTH_GAMESERVER	//   
; 23059: 	gGameServerAuth.SendInfo();	
; 23060: #endif
; 23061: }

  005cd	5f		 pop	 edi
  005ce	5e		 pop	 esi
  005cf	5b		 pop	 ebx
  005d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005d3	33 cd		 xor	 ecx, ebp
  005d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005da	8b e5		 mov	 esp, ebp
  005dc	5d		 pop	 ebp
  005dd	c3		 ret	 0
?gObjSecondProc@@YAXXZ ENDP				; gObjSecondProc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSetState@@YAXXZ
_TEXT	SEGMENT
tv558 = -140						; size = 4
tv536 = -140						; size = 4
tv514 = -140						; size = 4
tv303 = -140						; size = 4
tv276 = -140						; size = 4
tv235 = -140						; size = 4
tv226 = -140						; size = 4
tv148 = -140						; size = 4
tv559 = -136						; size = 4
tv537 = -136						; size = 4
tv515 = -136						; size = 4
tv304 = -136						; size = 4
tv274 = -136						; size = 4
tv236 = -136						; size = 4
tv227 = -136						; size = 4
tv149 = -136						; size = 4
_bgi$1 = -68						; size = 4
_wtype$2 = -64						; size = 4
_i$3 = -60						; size = 4
_pMsg$4 = -56						; size = 24
_sheildindex$5 = -32					; size = 4
_iregen$6 = -28						; size = 4
_iType$7 = -24						; size = 4
_iLevel$8 = -20						; size = 4
_iMaxHitUser$9 = -16					; size = 4
_lpObj$ = -12						; size = 4
_n$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?gObjSetState@@YAXXZ PROC				; gObjSetState, COMDAT

; 21546: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 21547: 	int n;
; 21548: 	LPOBJECTSTRUCT	lpObj;
; 21549: 		
; 21550: 	for( n=0; n<MAX_OBJECT; n++ )

  00016	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  0001d	eb 09		 jmp	 SHORT $LN4@gObjSetSta
$LN2@gObjSetSta:
  0001f	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00022	83 c0 01	 add	 eax, 1
  00025	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjSetSta:
  00028	81 7d f8 e8 1c
	00 00		 cmp	 DWORD PTR _n$[ebp], 7400 ; 00001ce8H
  0002f	0f 8d 9a 0d 00
	00		 jge	 $LN3@gObjSetSta

; 21551: 	{
; 21552: 		lpObj = &gObj[n];

  00035	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  0003c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00042	89 45 f4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 21553: 
; 21554: 		if( lpObj->Connected > 2 )

  00045	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00048	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  0004c	0f 8e 78 0d 00
	00		 jle	 $LN37@gObjSetSta

; 21555: 		{
; 21556: 			if( lpObj->m_State == OBJST_CREATE )

  00052	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00055	83 b8 b8 01 00
	00 01		 cmp	 DWORD PTR [eax+440], 1
  0005c	75 26		 jne	 SHORT $LN13@gObjSetSta

; 21557: 			{
; 21558: 				lpObj->m_State = OBJST_PLAYING;

  0005e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00061	c7 80 b8 01 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+440], 2

; 21559: 			
; 21560: 				if (lpObj->RegenOk == 3 )

  0006b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006e	0f be 88 ff 01
	00 00		 movsx	 ecx, BYTE PTR [eax+511]
  00075	83 f9 03	 cmp	 ecx, 3
  00078	75 0a		 jne	 SHORT $LN13@gObjSetSta

; 21561: 				{
; 21562: 					lpObj->RegenOk = 0;

  0007a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007d	c6 80 ff 01 00
	00 00		 mov	 BYTE PTR [eax+511], 0
$LN13@gObjSetSta:

; 21563: 				}
; 21564: 			}	
; 21565: 			if( lpObj->Teleport == 3 )

  00084	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00087	0f be 88 fc 01
	00 00		 movsx	 ecx, BYTE PTR [eax+508]
  0008e	83 f9 03	 cmp	 ecx, 3
  00091	75 0a		 jne	 SHORT $LN14@gObjSetSta

; 21566: 			{
; 21567: 				lpObj->Teleport = 0;

  00093	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00096	c6 80 fc 01 00
	00 00		 mov	 BYTE PTR [eax+508], 0
$LN14@gObjSetSta:

; 21568: 				//LogAddC(LOGC_RED," 0 %s %d", lpObj->Name, __LINE__);
; 21569: 				//gObjClearViewport(lpObj);
; 21570: 			}
; 21571: 		
; 21572: 
; 21573: 			if( lpObj->DieRegen == 2 )	// ..  ..

  0009d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a0	0f be 88 fe 01
	00 00		 movsx	 ecx, BYTE PTR [eax+510]
  000a7	83 f9 02	 cmp	 ecx, 2
  000aa	0f 85 1a 0d 00
	00		 jne	 $LN37@gObjSetSta

; 21574: 			{
; 21575: #ifdef GMCOMMAND_EX
; 21576: 				if (lpObj->m_bGMSummon == TRUE) {

  000b0	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b3	0f b6 88 5c 1a
	00 00		 movzx	 ecx, BYTE PTR [eax+6748]
  000ba	83 f9 01	 cmp	 ecx, 1
  000bd	75 13		 jne	 SHORT $LN16@gObjSetSta

; 21577: 					gObjDel(lpObj->m_Index);

  000bf	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c4	51		 push	 ecx
  000c5	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  000ca	83 c4 04	 add	 esp, 4

; 21578: 					continue;

  000cd	e9 4d ff ff ff	 jmp	 $LN2@gObjSetSta
$LN16@gObjSetSta:

; 21579: 				}
; 21580: #endif // GMCOMMAND_EX
; 21581: 
; 21582: #ifdef MAP_SERVER_WORK_20041030								//         
; 21583: 				INT iObjSrcMap				= lpObj->MapNumber;
; 21584: 				INT iObjSrcX				= lpObj->X;
; 21585: 				INT iObjSrcY				= lpObj->Y;
; 21586: #endif
; 21587: 				//------------->
; 21588: 				//20080930  5  ,   (grooving)
; 21589: 				#ifdef ADD_TELEPORT_CHARM_ITEM_20080930
; 21590: 				lpObj->m_siDieRegenX		=	lpObj->X;			//   X
; 21591: 				lpObj->m_siDieRegenY		=	lpObj->Y;			//   Y
; 21592: 				lpObj->m_siDieRegenMapIndex	=	lpObj->MapNumber;	//   Map
; 21593: 				#endif //ADD_TELEPORT_CHARM_ITEM_20080930
; 21594: 				//<-------------
; 21595: #ifdef USER_DIE_MAKE_OPPOSIT_PK_20040329
; 21596: 				lpObj->m_bAttackerKilled	= false;		//       

  000d2	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d5	c6 80 3c 02 00
	00 00		 mov	 BYTE PTR [eax+572], 0

; 21597: #endif
; 21598: 
; 21599: #ifdef DEVILSQUARE_EXTEND_20050221		//    
; 21600: 				if( CHECK_DEVILSQUARE(lpObj->MapNumber) && lpObj->Type >= OBJTYPE_MONSTER )
; 21601: #else
; 21602: 				if( lpObj->MapNumber == 9 && lpObj->Type >= OBJTYPE_MONSTER )

  000dc	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000df	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000e6	83 f9 09	 cmp	 ecx, 9
  000e9	75 1f		 jne	 SHORT $LN17@gObjSetSta
  000eb	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ee	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  000f2	83 f9 02	 cmp	 ecx, 2
  000f5	7c 13		 jl	 SHORT $LN17@gObjSetSta

; 21603: #endif
; 21604: 				{
; 21605: 					g_DevilSquare.gDevilSquareMonsterRegen(lpObj);

  000f7	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000fa	50		 push	 eax
  000fb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  00100	e8 00 00 00 00	 call	 ?gDevilSquareMonsterRegen@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@@Z ; CDevilSquare::gDevilSquareMonsterRegen

; 21606: 					continue;

  00105	e9 15 ff ff ff	 jmp	 $LN2@gObjSetSta
$LN17@gObjSetSta:

; 21607: 				}
; 21608: 
; 21609: #ifdef ADD_KANTURU_20060627
; 21610: 				//     .
; 21611: 				else if( lpObj->MapNumber == MAP_INDEX_KANTURU_BOSS && lpObj->Type == OBJTYPE_MONSTER )
; 21612: 				{
; 21613: 					continue;
; 21614: 				}
; 21615: #endif
; 21616: #ifdef ADD_NEW_MONSTER_SYSTEM_02_20050725
; 21617: 	   //   Regen      ,     .
; 21618: 				if( lpObj->m_iCurrentAI )
; 21619: 				{
; 21620: 					if( lpObj->m_iRegenType != 0 )
; 21621: 					{
; 21622: 						// -1   .
; 21623: 						// 0   
; 21624: 						// 1      - 
; 21625: 						continue;
; 21626: 					}
; 21627: 				}
; 21628: 				
; 21629: 
; 21630: #endif // ADD_NEW_MONSTER_SYSTEM_02_20050725
; 21631: 
; 21632: 
; 21633: #ifdef CRYWOLF_MONSTER_WORK_20050914
; 21634: 				if(lpObj->MapNumber == MAP_INDEX_CRYWOLF_FIRSTZONE )
; 21635: 				{
; 21636: 
; 21637: //     . -   .
; 21638: 
; 21639: //        .
; 21640: 					
; 21641: 					if( g_CrywolfSync.GetCrywolfState() == CRYWOLF_STATE_READY 
; 21642: 						&& lpObj->Type >= OBJTYPE_MONSTER)
; 21643: 					{
; 21644: 						continue;
; 21645: 					}
; 21646: 
; 21647: 				}
; 21648: #endif
; 21649: 				
; 21650: 
; 21651: #ifdef MONSTER_HERD_SYSTEM_20031120
; 21652: 				if (lpObj->m_bIsInMonsterHerd) {			//    .

  0010a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010d	83 b8 ec 0e 00
	00 00		 cmp	 DWORD PTR [eax+3820], 0
  00114	74 2e		 je	 SHORT $LN18@gObjSetSta

; 21653: 					if (lpObj->m_lpMonsterHerd != NULL)

  00116	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00119	83 b8 f4 0e 00
	00 00		 cmp	 DWORD PTR [eax+3828], 0
  00120	74 1d		 je	 SHORT $LN19@gObjSetSta

; 21654: 						lpObj->m_lpMonsterHerd->MonsterRegenAction(lpObj);

  00122	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00125	50		 push	 eax
  00126	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00129	8b 91 f4 0e 00
	00		 mov	 edx, DWORD PTR [ecx+3828]
  0012f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00132	8b 12		 mov	 edx, DWORD PTR [edx]
  00134	8b 88 f4 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3828]
  0013a	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  0013d	ff d0		 call	 eax
$LN19@gObjSetSta:

; 21655: 					continue;

  0013f	e9 db fe ff ff	 jmp	 $LN2@gObjSetSta
$LN18@gObjSetSta:

; 21656: 				}
; 21657: #endif
; 21658: 
; 21659: #ifdef FOR_BLOODCASTLE		// 2004.02.02      -    (   )
; 21660: 				if( CHECK_BLOODCASTLE(lpObj->MapNumber) && lpObj->Type >= OBJTYPE_MONSTER )

  00144	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00147	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0014e	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00151	7d 0c		 jge	 SHORT $LN70@gObjSetSta
  00153	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv149[ebp], 0
  0015d	eb 31		 jmp	 SHORT $LN71@gObjSetSta
$LN70@gObjSetSta:
  0015f	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00162	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00169	83 f8 11	 cmp	 eax, 17			; 00000011H
  0016c	7e 0c		 jle	 SHORT $LN68@gObjSetSta
  0016e	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv148[ebp], 0
  00178	eb 0a		 jmp	 SHORT $LN69@gObjSetSta
$LN68@gObjSetSta:
  0017a	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv148[ebp], 1
$LN69@gObjSetSta:
  00184	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv148[ebp]
  0018a	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv149[ebp], ecx
$LN71@gObjSetSta:
  00190	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv149[ebp], 0
  00197	0f 84 ae 03 00
	00		 je	 $LN27@gObjSetSta
  0019d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a0	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  001a4	83 f9 02	 cmp	 ecx, 2
  001a7	0f 8c 9e 03 00
	00		 jl	 $LN27@gObjSetSta

; 21661: 				{
; 21662: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 21663: 					int iBridgeIndex = g_BloodCastle.GetBridgeIndexByMapNum( lpObj->MapNumber );
; 21664: #endif
; 21665: 					if (lpObj->Class == 131) {		//   ->   

  001ad	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b0	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  001b7	81 f9 83 00 00
	00		 cmp	 ecx, 131		; 00000083H
  001bd	0f 85 15 01 00
	00		 jne	 $LN23@gObjSetSta

; 21666: 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_bCASTLE_DOOR_LIVE = FALSE;

  001c3	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c6	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  001cd	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  001d3	c7 82 4c 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+332], 0

; 21667: 
; 21668: 						//    
; 21669: 						g_BloodCastle.m_BridgeData[lpObj->m_cBloodCastleIndex].m_bBC_DOOR_TERMINATE_COMPLETE = TRUE;

  001dd	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e0	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  001e7	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  001ed	c6 82 62 01 00
	00 01		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+354], 1

; 21670: 
; 21671: 						//   . ->     
; 21672: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 21673: 						g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT = g_BloodCastle.GetCurrentLiveUserCount(iBridgeIndex) * BC_PERUSER_BOSS_MONSTER_KILL;
; 21674: 						g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_KILL_COUNT = 0;
; 21675: 
; 21676: 						if( g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT > 10 )
; 21677: 						{
; 21678: 							g_BloodCastle.m_BridgeData[iBridgeIndex].m_iBC_BOSS_MONSTER_MAX_COUNT = 10;
; 21679: 						}
; 21680: #else
; 21681: 						g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_MAX_COUNT = g_BloodCastle.GetCurrentLiveUserCount(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1) * BC_PERUSER_BOSS_MONSTER_KILL;

  001f4	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f7	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  001fe	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00201	51		 push	 ecx
  00202	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00207	e8 00 00 00 00	 call	 ?GetCurrentLiveUserCount@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentLiveUserCount
  0020c	d1 e0		 shl	 eax, 1
  0020e	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00211	0f b6 8a 09 01
	00 00		 movzx	 ecx, BYTE PTR [edx+265]
  00218	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  0021b	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00221	89 82 84 01 00
	00		 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+388], eax

; 21682: 						g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_KILL_COUNT = 0;

  00227	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0022a	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00231	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00234	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  0023a	c7 82 88 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+392], 0

; 21683: 
; 21684: 						if( g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_MAX_COUNT > 10 )

  00244	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00247	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0024e	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00251	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00257	83 ba 84 01 00
	00 0a		 cmp	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+388], 10 ; 0000000aH
  0025e	7e 1d		 jle	 SHORT $LN22@gObjSetSta

; 21685: 						{
; 21686: 							g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_iBC_BOSS_MONSTER_MAX_COUNT = 10;

  00260	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00263	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0026a	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  0026d	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00273	c7 82 84 01 00
	00 0a 00 00 00	 mov	 DWORD PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+388], 10 ; 0000000aH
$LN22@gObjSetSta:

; 21687: 						}
; 21688: #endif
; 21689: 						
; 21690: 						//       .
; 21691: 						g_BloodCastle.SendCastleDoorBlockInfo(lpObj->m_cBloodCastleIndex, false);

  0027d	6a 00		 push	 0
  0027f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00282	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  00289	51		 push	 ecx
  0028a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0028f	e8 00 00 00 00	 call	 ?SendCastleDoorBlockInfo@CBloodCastle@@QAEXH_N@Z ; CBloodCastle::SendCastleDoorBlockInfo

; 21692: 
; 21693: 						//   .
; 21694: 						g_BloodCastle.ReleaseCastleDoor(lpObj->m_cBloodCastleIndex);

  00294	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00297	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  0029e	51		 push	 ecx
  0029f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  002a4	e8 00 00 00 00	 call	 ?ReleaseCastleDoor@CBloodCastle@@QAEXH@Z ; CBloodCastle::ReleaseCastleDoor

; 21695: 
; 21696: 						//          .
; 21697: 						if (g_BloodCastle.GetCurrentState(lpObj->m_cBloodCastleIndex) == BLOODCASTLE_STATE_PLAYING)

  002a9	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ac	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  002b3	51		 push	 ecx
  002b4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  002b9	e8 00 00 00 00	 call	 ?GetCurrentState@CBloodCastle@@QAEHH@Z ; CBloodCastle::GetCurrentState
  002be	83 f8 02	 cmp	 eax, 2
  002c1	75 15		 jne	 SHORT $LN23@gObjSetSta

; 21698: 							g_BloodCastle.SetBossMonster(lpObj->m_cBloodCastleIndex);

  002c3	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c6	0f be 88 d2 0c
	00 00		 movsx	 ecx, BYTE PTR [eax+3282]
  002cd	51		 push	 ecx
  002ce	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  002d3	e8 00 00 00 00	 call	 ?SetBossMonster@CBloodCastle@@QAEXH@Z ; CBloodCastle::SetBossMonster
$LN23@gObjSetSta:

; 21699: 					}
; 21700: 
; 21701: 
; 21702: 					if (CHECK_LIMIT(lpObj->Class-BC_SAINT_STATUE_1, 3))		//        .

  002d8	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002db	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  002e2	81 e9 84 00 00
	00		 sub	 ecx, 132		; 00000084H
  002e8	79 0c		 jns	 SHORT $LN74@gObjSetSta
  002ea	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv227[ebp], 0
  002f4	eb 36		 jmp	 SHORT $LN75@gObjSetSta
$LN74@gObjSetSta:
  002f6	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002f9	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  00300	2d 84 00 00 00	 sub	 eax, 132		; 00000084H
  00305	83 f8 02	 cmp	 eax, 2
  00308	7e 0c		 jle	 SHORT $LN72@gObjSetSta
  0030a	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv226[ebp], 0
  00314	eb 0a		 jmp	 SHORT $LN73@gObjSetSta
$LN72@gObjSetSta:
  00316	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv226[ebp], 1
$LN73@gObjSetSta:
  00320	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv226[ebp]
  00326	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv227[ebp], ecx
$LN75@gObjSetSta:
  0032c	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv227[ebp], 0
  00333	0f 84 53 01 00
	00		 je	 $LN25@gObjSetSta

; 21703: 					{
; 21704: 						if (CHECK_BLOODCASTLE(lpObj->MapNumber)) {

  00339	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0033c	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00343	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00346	7d 0c		 jge	 SHORT $LN78@gObjSetSta
  00348	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv236[ebp], 0
  00352	eb 31		 jmp	 SHORT $LN79@gObjSetSta
$LN78@gObjSetSta:
  00354	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00357	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0035e	83 f8 11	 cmp	 eax, 17			; 00000011H
  00361	7e 0c		 jle	 SHORT $LN76@gObjSetSta
  00363	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv235[ebp], 0
  0036d	eb 0a		 jmp	 SHORT $LN77@gObjSetSta
$LN76@gObjSetSta:
  0036f	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv235[ebp], 1
$LN77@gObjSetSta:
  00379	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv235[ebp]
  0037f	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv236[ebp], ecx
$LN79@gObjSetSta:
  00385	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv236[ebp], 0
  0038c	0f 84 fa 00 00
	00		 je	 $LN25@gObjSetSta

; 21705: 							//         .
; 21706: 							int iMaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00392	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00395	50		 push	 eax
  00396	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  0039b	83 c4 04	 add	 esp, 4
  0039e	89 45 f0	 mov	 DWORD PTR _iMaxHitUser$9[ebp], eax

; 21707: 							int iLevel = lpObj->Class-BC_SAINT_STATUE_1;

  003a1	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003a4	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  003ab	81 e9 84 00 00
	00		 sub	 ecx, 132		; 00000084H
  003b1	89 4d ec	 mov	 DWORD PTR _iLevel$8[ebp], ecx

; 21708:  							int iType = ItemGetNumberMake(13, 19);

  003b4	6a 13		 push	 19			; 00000013H
  003b6	6a 0d		 push	 13			; 0000000dH
  003b8	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  003bd	83 c4 08	 add	 esp, 8
  003c0	89 45 e8	 mov	 DWORD PTR _iType$7[ebp], eax

; 21709: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 21710: 							int iUltimateWeaponMapNum;
; 21711: 							switch( lpObj->MapNumber )
; 21712: 							{
; 21713: 							case MAP_INDEX_BLOODCASTLE1:	iUltimateWeaponMapNum = BC_MAPNUMBER_ULTIMATEWEAPON1; break;
; 21714: 							case MAP_INDEX_BLOODCASTLE2:	iUltimateWeaponMapNum = BC_MAPNUMBER_ULTIMATEWEAPON2; break;
; 21715: 							case MAP_INDEX_BLOODCASTLE3:	iUltimateWeaponMapNum = BC_MAPNUMBER_ULTIMATEWEAPON3; break;
; 21716: 							case MAP_INDEX_BLOODCASTLE4:	iUltimateWeaponMapNum = BC_MAPNUMBER_ULTIMATEWEAPON4; break;
; 21717: 							case MAP_INDEX_BLOODCASTLE5:	iUltimateWeaponMapNum = BC_MAPNUMBER_ULTIMATEWEAPON5; break;
; 21718: 							case MAP_INDEX_BLOODCASTLE6:	iUltimateWeaponMapNum = BC_MAPNUMBER_ULTIMATEWEAPON6; break;
; 21719: 							case MAP_INDEX_BLOODCASTLE7:	iUltimateWeaponMapNum = BC_MAPNUMBER_ULTIMATEWEAPON7; break;
; 21720: 							case MAP_INDEX_BLOODCASTLE8:	iUltimateWeaponMapNum = BC_MAPNUMBER_ULTIMATEWEAPON8; break;
; 21721: 							}
; 21722: 							ItemSerialCreateSend(lpObj->m_Index, iUltimateWeaponMapNum, (BYTE)lpObj->X, (BYTE)lpObj->Y, iType, iLevel, (BYTE)0, 0, 0, 0, iMaxHitUser);
; 21723: #else
; 21724: 							ItemSerialCreateSend(lpObj->m_Index, BC_MAPNUMBER_BASE_ULTIMATEWEAPON + lpObj->MapNumber, (BYTE)lpObj->X, (BYTE)lpObj->Y, iType, iLevel, (BYTE)0, 0, 0, 0, iMaxHitUser);

  003c3	6a 00		 push	 0
  003c5	6a 00		 push	 0
  003c7	6a 00		 push	 0
  003c9	8b 45 f0	 mov	 eax, DWORD PTR _iMaxHitUser$9[ebp]
  003cc	50		 push	 eax
  003cd	6a 00		 push	 0
  003cf	6a 00		 push	 0
  003d1	6a 00		 push	 0
  003d3	6a 00		 push	 0
  003d5	0f b6 4d ec	 movzx	 ecx, BYTE PTR _iLevel$8[ebp]
  003d9	51		 push	 ecx
  003da	8b 55 e8	 mov	 edx, DWORD PTR _iType$7[ebp]
  003dd	52		 push	 edx
  003de	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003e1	0f b6 88 06 01
	00 00		 movzx	 ecx, BYTE PTR [eax+262]
  003e8	51		 push	 ecx
  003e9	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003ec	0f b6 82 04 01
	00 00		 movzx	 eax, BYTE PTR [edx+260]
  003f3	50		 push	 eax
  003f4	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003f7	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  003fe	81 c2 ec 00 00
	00		 add	 edx, 236		; 000000ecH
  00404	52		 push	 edx
  00405	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00408	8b 08		 mov	 ecx, DWORD PTR [eax]
  0040a	51		 push	 ecx
  0040b	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00410	83 c4 38	 add	 esp, 56			; 00000038H

; 21725: #endif
; 21726: 							
; 21727: 							//     . (0: / 1: / 2:)
; 21728: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 21729: 							g_BloodCastle.m_BridgeData[iBridgeIndex].m_btBC_QUEST_ITEM_NUMBER = iLevel;
; 21730: 
; 21731: 							LogAddTD("[Blood Castle] (%d) Ultimate Weapon Dropped -> (%s)", 
; 21732: 								iBridgeIndex + 1,
; 21733: 								(iLevel)?((iLevel==1)?"Sword":"Crossbow"):"Staff"								
; 21734: 								);
; 21735: #else
; 21736: 							g_BloodCastle.m_BridgeData[lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1].m_btBC_QUEST_ITEM_NUMBER = iLevel;

  00413	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00416	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0041d	83 e9 0b	 sub	 ecx, 11			; 0000000bH
  00420	69 d1 04 02 00
	00		 imul	 edx, ecx, 516
  00426	8a 45 ec	 mov	 al, BYTE PTR _iLevel$8[ebp]
  00429	88 82 98 01 00
	00		 mov	 BYTE PTR ?g_BloodCastle@@3VCBloodCastle@@A[edx+408], al

; 21737: 
; 21738: 							LogAddTD("[Blood Castle] (%d) Ultimate Weapon Dropped -> (%s)", 

  0042f	83 7d ec 00	 cmp	 DWORD PTR _iLevel$8[ebp], 0
  00433	74 2a		 je	 SHORT $LN82@gObjSetSta
  00435	83 7d ec 01	 cmp	 DWORD PTR _iLevel$8[ebp], 1
  00439	75 0c		 jne	 SHORT $LN80@gObjSetSta
  0043b	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv274[ebp], OFFSET ??_C@_05LKHEONBC@Sword@
  00445	eb 0a		 jmp	 SHORT $LN81@gObjSetSta
$LN80@gObjSetSta:
  00447	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv274[ebp], OFFSET ??_C@_08OMHMMHKG@Crossbow@
$LN81@gObjSetSta:
  00451	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv274[ebp]
  00457	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv276[ebp], eax
  0045d	eb 0a		 jmp	 SHORT $LN83@gObjSetSta
$LN82@gObjSetSta:
  0045f	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv276[ebp], OFFSET ??_C@_05DEBCIJNP@Staff@
$LN83@gObjSetSta:
  00469	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv276[ebp]
  0046f	51		 push	 ecx
  00470	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00473	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0047a	83 e8 0a	 sub	 eax, 10			; 0000000aH
  0047d	50		 push	 eax
  0047e	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@KDNIOEPF@?$FLBlood?5Castle?$FN?5?$CI?$CFd?$CJ?5Ultimate?5We@
  00483	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00489	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN25@gObjSetSta:

; 21739: 								lpObj->MapNumber-MAP_INDEX_BLOODCASTLE1+1,
; 21740: 								(iLevel)?((iLevel==1)?"Sword":"Crossbow"):"Staff"								
; 21741: 								);
; 21742: #endif
; 21743: 						}
; 21744: 					}
; 21745: 
; 21746: 					if (lpObj->m_PosNum == -1) {	//      .

  0048c	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0048f	0f bf 88 0c 02
	00 00		 movsx	 ecx, WORD PTR [eax+524]
  00496	83 f9 ff	 cmp	 ecx, -1
  00499	75 13		 jne	 SHORT $LN26@gObjSetSta

; 21747: 						gObjDel (lpObj->m_Index);

  0049b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0049e	8b 08		 mov	 ecx, DWORD PTR [eax]
  004a0	51		 push	 ecx
  004a1	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  004a6	83 c4 04	 add	 esp, 4

; 21748: 						continue;

  004a9	e9 71 fb ff ff	 jmp	 $LN2@gObjSetSta
$LN26@gObjSetSta:

; 21749: 					}
; 21750: 
; 21751: #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 21752: 					if (lpObj->Type == OBJTYPE_MONSTER &&

  004ae	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004b1	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  004b5	83 f9 02	 cmp	 ecx, 2
  004b8	0f 85 8d 00 00
	00		 jne	 $LN27@gObjSetSta
  004be	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004c1	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  004c8	81 f9 83 00 00
	00		 cmp	 ecx, 131		; 00000083H
  004ce	74 7b		 je	 SHORT $LN27@gObjSetSta
  004d0	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004d3	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  004da	81 e9 84 00 00
	00		 sub	 ecx, 132		; 00000084H
  004e0	79 0c		 jns	 SHORT $LN86@gObjSetSta
  004e2	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv304[ebp], 0
  004ec	eb 36		 jmp	 SHORT $LN87@gObjSetSta
$LN86@gObjSetSta:
  004ee	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004f1	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  004f8	2d 84 00 00 00	 sub	 eax, 132		; 00000084H
  004fd	83 f8 02	 cmp	 eax, 2
  00500	7e 0c		 jle	 SHORT $LN84@gObjSetSta
  00502	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv303[ebp], 0
  0050c	eb 0a		 jmp	 SHORT $LN85@gObjSetSta
$LN84@gObjSetSta:
  0050e	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv303[ebp], 1
$LN85@gObjSetSta:
  00518	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv303[ebp]
  0051e	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv304[ebp], ecx
$LN87@gObjSetSta:
  00524	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv304[ebp], 0
  0052b	75 1e		 jne	 SHORT $LN27@gObjSetSta

; 21753: 						(lpObj->Class != 131 && !CHECK_LIMIT(lpObj->Class-BC_SAINT_STATUE_1, 3))
; 21754: 						)
; 21755: 					{
; 21756: 						//         ,    
; 21757: #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010	//    
; 21758: 						g_BloodCastle.ChangeMonsterState(iBridgeIndex, lpObj->m_Index);
; 21759: #else
; 21760: 						g_BloodCastle.ChangeMonsterState(lpObj->MapNumber - MAP_INDEX_BLOODCASTLE1, lpObj->m_Index);

  0052d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00530	8b 08		 mov	 ecx, DWORD PTR [eax]
  00532	51		 push	 ecx
  00533	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00536	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0053d	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00540	50		 push	 eax
  00541	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00546	e8 00 00 00 00	 call	 ?ChangeMonsterState@CBloodCastle@@QAEXHH@Z ; CBloodCastle::ChangeMonsterState
$LN27@gObjSetSta:

; 21761: #endif	// ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010
; 21762: 					}
; 21763: #endif
; 21764: 				}
; 21765: #endif
; 21766: 
; 21767: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//     
; 21768: 				if(CHECK_ILLUSION_TEMPLE(lpObj->MapNumber))
; 21769: 				{
; 21770: 					
; 21771: 					if( (lpObj->Class == NPC_ILLUSION_HOLY_RELICS_STATUE				// 
; 21772: 						|| ( lpObj->Class >= MON_GHOST_OF_ILLUSION_BROTHERHOOD_A1	//  
; 21773: 						&& lpObj->Class <= MON_GHOST_OF_ILLUSION_BROTHERHOOD_C6) )
; 21774: 						&& lpObj->m_PosNum == -1)
; 21775: 					{
; 21776: 						continue;
; 21777: 					}
; 21778: 				}
; 21779: #endif
; 21780: 				
; 21781: #ifdef ADD_NEW_MAP_KALIMA_20040518					//      .
; 21782: 				if (lpObj->m_Attribute == MON_ATTR_SUMMONED) {

  0054b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0054e	0f bf 88 fe 02
	00 00		 movsx	 ecx, WORD PTR [eax+766]
  00555	83 f9 3c	 cmp	 ecx, 60			; 0000003cH
  00558	75 13		 jne	 SHORT $LN28@gObjSetSta

; 21783: 					gObjDel (lpObj->m_Index);

  0055a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0055d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0055f	51		 push	 ecx
  00560	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00565	83 c4 04	 add	 esp, 4

; 21784: 					continue;

  00568	e9 b2 fa ff ff	 jmp	 $LN2@gObjSetSta
$LN28@gObjSetSta:

; 21785: 				}
; 21786: #endif
; 21787: 
; 21788: #ifdef CASTLEDEEP_EVENT_20050413
; 21789: 				if (lpObj->m_Attribute == MON_ATTR_INSTANCE) {
; 21790: 					gObjDel (lpObj->m_Index);
; 21791: 					continue;
; 21792: 				}
; 21793: 
; 21794: 				if (lpObj->m_Attribute == MON_ATTR_CASTLEDEEP) {
; 21795: 					switch(lpObj->Class) {
; 21796: 					case 300:
; 21797: 					case 301:
; 21798: 					case 302:
; 21799: 					case 303:
; 21800: 						{
; 21801: 							//     
; 21802: 							gObjDel (lpObj->m_Index);
; 21803: 							continue;
; 21804: 						}
; 21805: 						break;
; 21806: 					default:
; 21807: 						{
; 21808: 							//    N  
; 21809: 							if (lpObj->m_dwLastCheckTick + CASTLEDEEP_DELTICKCOUNT < GetTickCount()) {
; 21810: 								gObjDel (lpObj->m_Index);
; 21811: 								continue;
; 21812: 							}
; 21813: 						}
; 21814: 						break;
; 21815: 					}
; 21816: 				}
; 21817: #endif
; 21818: 
; 21819: #ifdef ADD_NEW_MERCENARY_FOR_CASTLE_01_20041214		
; 21820: 				if (lpObj->Type >= OBJTYPE_MONSTER 
; 21821: 					&& ( lpObj->Class == NPC_INDEX_SPEARMAN || lpObj->Class == NPC_INDEX_BOWMAN) ) 
; 21822: 				{
; 21823: 					g_CsNPC_Mercenary.DeleteMercenary( lpObj->m_Index );
; 21824: 					gObjDel (lpObj->m_Index);
; 21825: 					continue;
; 21826: 				}
; 21827: #endif
; 21828: 				
; 21829: #ifdef CASTLE_NPC_LIFESTONE_WORK_20041208
; 21830: 				if( lpObj->Type >= OBJTYPE_MONSTER && lpObj->Class == NPC_INDEX_LIFESTONE )
; 21831: 				{
; 21832: 					g_CsNPC_LifeStone.DeleteLifeStone( lpObj->m_Index );
; 21833: 					gObjDel (lpObj->m_Index);
; 21834: 					continue;
; 21835: 				}
; 21836: #endif
; 21837: 
; 21838: 				int iregen = 1;

  0056d	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _iregen$6[ebp], 1

; 21839: 
; 21840: 				if( lpObj->Type >= OBJTYPE_MONSTER  )

  00574	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00577	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0057b	83 f9 02	 cmp	 ecx, 2
  0057e	0f 8c 11 01 00
	00		 jl	 $LN36@gObjSetSta

; 21841: 				{
; 21842: 					if( lpObj->Class == 44 )

  00584	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00587	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0058e	83 f9 2c	 cmp	 ecx, 44			; 0000002cH
  00591	75 19		 jne	 SHORT $LN31@gObjSetSta

; 21843: 					{
; 21844: 						if( (DragonEvent->GetState()) == 0 )

  00593	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  00599	e8 00 00 00 00	 call	 ?GetState@CDragonEvent@@QAEEXZ ; CDragonEvent::GetState
  0059e	0f b6 c0	 movzx	 eax, al
  005a1	85 c0		 test	 eax, eax
  005a3	75 07		 jne	 SHORT $LN31@gObjSetSta

; 21845: 						{
; 21846: 							iregen = 0;

  005a5	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iregen$6[ebp], 0
$LN31@gObjSetSta:

; 21847: 						}
; 21848: 					}
; 21849: 					if( lpObj->Class == 53 || 
; 21850: 						lpObj->Class == 54 || 
; 21851: 						lpObj->Class == 55 || 

  005ac	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005af	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  005b6	83 f9 35	 cmp	 ecx, 53			; 00000035H
  005b9	74 2d		 je	 SHORT $LN33@gObjSetSta
  005bb	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005be	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  005c5	83 f9 36	 cmp	 ecx, 54			; 00000036H
  005c8	74 1e		 je	 SHORT $LN33@gObjSetSta
  005ca	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005cd	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  005d4	83 f9 37	 cmp	 ecx, 55			; 00000037H
  005d7	74 0f		 je	 SHORT $LN33@gObjSetSta
  005d9	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005dc	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  005e3	83 f9 38	 cmp	 ecx, 56			; 00000038H
  005e6	75 23		 jne	 SHORT $LN32@gObjSetSta
$LN33@gObjSetSta:

; 21852: 						lpObj->Class == 56 )
; 21853: 					{
; 21854: 						iregen = 0;

  005e8	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iregen$6[ebp], 0

; 21855: 						lpObj->Life		= lpObj->MaxLife;

  005ef	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005f2	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005f5	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  005fb	89 90 bc 00 00
	00		 mov	 DWORD PTR [eax+188], edx

; 21856: 						lpObj->DieRegen	= 0;

  00601	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00604	c6 80 fe 01 00
	00 00		 mov	 BYTE PTR [eax+510], 0
$LN32@gObjSetSta:

; 21857: 					}
; 21858: 
; 21859: 					if( lpObj->Class >= 78 && lpObj->Class <= 83 )

  0060b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0060e	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00615	83 f9 4e	 cmp	 ecx, 78			; 0000004eH
  00618	7c 32		 jl	 SHORT $LN34@gObjSetSta
  0061a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0061d	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00624	83 f9 53	 cmp	 ecx, 83			; 00000053H
  00627	7f 23		 jg	 SHORT $LN34@gObjSetSta

; 21860: 					{
; 21861: 						iregen = 0;

  00629	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _iregen$6[ebp], 0

; 21862: 						lpObj->Life		= lpObj->MaxLife;

  00630	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00633	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00636	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  0063c	89 90 bc 00 00
	00		 mov	 DWORD PTR [eax+188], edx

; 21863: 						lpObj->DieRegen	= 0;

  00642	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00645	c6 80 fe 01 00
	00 00		 mov	 BYTE PTR [eax+510], 0
$LN34@gObjSetSta:

; 21864: 					}					
; 21865: #ifdef ADD_GOLDEN_EVENT_RENEWAL_20090311	
; 21866: 					if( lpObj->Class >= 493 && lpObj->Class <= 502 )
; 21867: 					{	
; 21868: 						iregen = 0;
; 21869: 						lpObj->Life		= lpObj->MaxLife;
; 21870: 						lpObj->DieRegen	= 0;
; 21871: 					}
; 21872: #endif //ADD_GOLDEN_EVENT_RENEWAL_20090311
; 21873: #ifdef NEW_SKILL_FORSKYLAND
; 21874: 					if( lpObj->Class == 77 )

  0064c	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0064f	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00656	83 f9 4d	 cmp	 ecx, 77			; 0000004dH
  00659	75 3a		 jne	 SHORT $LN36@gObjSetSta

; 21875: 					{	//    
; 21876: 						int sheildindex = lpObj->m_SkyBossMonSheildLinkIndex;

  0065b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0065e	8b 88 c4 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3780]
  00664	89 4d e0	 mov	 DWORD PTR _sheildindex$5[ebp], ecx

; 21877: 
; 21878: 						if( sheildindex != -1 )

  00667	83 7d e0 ff	 cmp	 DWORD PTR _sheildindex$5[ebp], -1
  0066b	74 28		 je	 SHORT $LN36@gObjSetSta

; 21879: 						{
; 21880: 							gObj[sheildindex].Life = gObj[sheildindex].MaxLife;

  0066d	69 45 e0 a0 1b
	00 00		 imul	 eax, DWORD PTR _sheildindex$5[ebp], 7072
  00674	69 4d e0 a0 1b
	00 00		 imul	 ecx, DWORD PTR _sheildindex$5[ebp], 7072
  0067b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00681	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00687	8b 84 06 c0 00
	00 00		 mov	 eax, DWORD PTR [esi+eax+192]
  0068e	89 84 0a bc 00
	00 00		 mov	 DWORD PTR [edx+ecx+188], eax
$LN36@gObjSetSta:

; 21881: 						}
; 21882: 					}
; 21883: #endif
; 21884: 				}
; 21885: 
; 21886: 				if( iregen )

  00695	83 7d e4 00	 cmp	 DWORD PTR _iregen$6[ebp], 0
  00699	0f 84 2b 07 00
	00		 je	 $LN37@gObjSetSta

; 21887: 				{
; 21888: 					PMSG_CHARREGEN	pMsg;
; 21889: 					lpObj->Life		= lpObj->MaxLife+lpObj->AddLife;

  0069f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006a2	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  006aa	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  006ad	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  006b5	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  006b8	f3 0f 11 82 bc
	00 00 00	 movss	 DWORD PTR [edx+188], xmm0

; 21890: 					lpObj->Mana		= lpObj->MaxMana+lpObj->AddMana;

  006c0	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006c3	f3 0f 2a 80 10
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+272]
  006cb	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  006ce	f3 0f 58 81 d4
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+212]
  006d6	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  006d9	f3 0f 11 82 d0
	00 00 00	 movss	 DWORD PTR [edx+208], xmm0

; 21891: #ifdef ADD_SHIELD_POINT_01_20060403
; 21892: 					lpObj->iShield	= lpObj->iMaxShield+lpObj->iAddShield;
; 21893: #endif
; 21894: 					lpObj->Live		= 1;

  006e1	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006e4	c6 40 66 01	 mov	 BYTE PTR [eax+102], 1

; 21895: #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 21896: 					gObjRemoveBuffEffect( lpObj, BUFFTYPE_POISON );
; 21897: 					gObjRemoveBuffEffect( lpObj, BUFFTYPE_FREEZE );
; 21898: 					gObjRemoveBuffEffect( lpObj, BUFFTYPE_STONE );
; 21899: #else
; 21900: 					lpObj->m_PoisonBeattackCount= 0;

  006e8	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006eb	c6 80 18 1a 00
	00 00		 mov	 BYTE PTR [eax+6680], 0

; 21901: 					lpObj->m_ColdBeattackCount	= 0;

  006f2	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006f5	c6 80 19 1a 00
	00 00		 mov	 BYTE PTR [eax+6681], 0

; 21902: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 21903: 					lpObj->m_ViewState			= 0;

  006fc	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006ff	c6 80 be 01 00
	00 00		 mov	 BYTE PTR [eax+446], 0

; 21904: 					lpObj->Teleport				= 0;

  00706	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00709	c6 80 fc 01 00
	00 00		 mov	 BYTE PTR [eax+508], 0

; 21905: 					
; 21906: 					for( int i=0; i<MAXSELFDEFENSE; i++)

  00710	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  00717	eb 09		 jmp	 SHORT $LN7@gObjSetSta
$LN5@gObjSetSta:
  00719	8b 45 c4	 mov	 eax, DWORD PTR _i$3[ebp]
  0071c	83 c0 01	 add	 eax, 1
  0071f	89 45 c4	 mov	 DWORD PTR _i$3[ebp], eax
$LN7@gObjSetSta:
  00722	83 7d c4 07	 cmp	 DWORD PTR _i$3[ebp], 7
  00726	7d 13		 jge	 SHORT $LN6@gObjSetSta

; 21907: 					{
; 21908: 						//lpObj->SelfDefense[i]		= -1;
; 21909: 						lpObj->SelfDefenseTime[i]	= 0;

  00728	8b 45 c4	 mov	 eax, DWORD PTR _i$3[ebp]
  0072b	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0072e	c7 84 81 5c 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+604], 0

; 21910: 					}

  00739	eb de		 jmp	 SHORT $LN5@gObjSetSta
$LN6@gObjSetSta:

; 21911: 					
; 21912: 					gObjTimeCheckSelfDefense(lpObj);

  0073b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0073e	50		 push	 eax
  0073f	e8 00 00 00 00	 call	 ?gObjTimeCheckSelfDefense@@YAXPAVOBJECTSTRUCT@@@Z ; gObjTimeCheckSelfDefense
  00744	83 c4 04	 add	 esp, 4

; 21913: 					
; 21914: #ifdef MODIFY_PK_SYSTEM_BUGFIX_20070323	//     
; 21915: 					lpObj->MySelfDefenseTime = 0;

  00747	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0074a	c7 80 78 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+632], 0

; 21916: #endif
; 21917: 					
; 21918: #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 21919: 					gObjClearBuffEffect( lpObj, CLEAR_TYPE_NON_PCS_ITEM_EFFECT );
; 21920: #else
; 21921: 	#ifdef EXPAND_VIEWSKILLSTATE_WORD_TO_INT_20041122
; 21922: 					DEL_VIEWSKILLSTATE( lpObj->m_ViewSkillState, STATE_POISON );
; 21923: 					DEL_VIEWSKILLSTATE( lpObj->m_ViewSkillState, STATE_FREEZE );
; 21924: 	#else
; 21925: 					lpObj->m_ViewSkillState &= 0xFC;

  00754	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00757	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  0075e	81 e1 fc 00 00
	00		 and	 ecx, 252		; 000000fcH
  00764	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00767	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 21926: 	#endif
; 21927: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 21928: 					
; 21929: 					gObjClearViewport(lpObj);

  0076e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00771	50		 push	 eax
  00772	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  00777	83 c4 04	 add	 esp, 4

; 21930: 					
; 21931: 
; 21932: 					if( lpObj->Type == OBJTYPE_CHARACTER )

  0077a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0077d	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00781	83 f9 01	 cmp	 ecx, 1
  00784	0f 85 f2 05 00
	00		 jne	 $LN38@gObjSetSta

; 21933: 					{
; 21934: 
; 21935: #ifdef CHARACTER_AUTO_RECUPERATION_SYSTEM_20050614
; 21936: 						if(g_iUseCharacterAutoRecuperationSystem && lpObj->Level <= g_iCharacterRecuperationMaxLevel)
; 21937: 							lpObj->m_iAutoRecuperationTime = GetTickCount();
; 21938: 						else lpObj->m_iAutoRecuperationTime = 0;
; 21939: #endif
; 21940: 
; 21941: #ifdef ADD_SHIELD_POINT_01_20060403
; 21942: 						lpObj->dwShieldAutoRefillTimer = GetTickCount();
; 21943: #endif
; 21944: 
; 21945: #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004				// !! NOT
; 21946: 	#ifdef ADD_NPC_SHADOW_PHANTOM_20050616
; 21947: 						if(lpObj->m_iSkillNPCHelpTime > 0)
; 21948: 						{
; 21949: 							lpObj->m_iSkillNPCHelpTime = 0;
; 21950: 							lpObj->m_iSkillNPCDefense = 0; 
; 21951: 							lpObj->m_iSkillNPCAttack = 0;
; 21952: 
; 21953: 							DEL_VIEWSKILLSTATE(lpObj->m_ViewSkillState, STATE_NPC_HELP);
; 21954: 							GCStateInfoSend(lpObj, 0, STATE_NPC_HELP);			
; 21955: 						}	
; 21956: 	#endif
; 21957: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 21958: 
; 21959: #ifdef DARKLORD_WORK
; 21960: 						gDarkSpirit[lpObj->m_Index].SetMode(CDarkSpirit::PetItem_Mode_Normal);

  0078a	6a ff		 push	 -1
  0078c	6a 00		 push	 0
  0078e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00791	6b 08 28	 imul	 ecx, DWORD PTR [eax], 40
  00794	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  0079a	e8 00 00 00 00	 call	 ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ; CDarkSpirit::SetMode

; 21961: #endif
; 21962: 						//    
; 21963: #ifdef DUEL_SYSTEM_20031028
; 21964: 						//    
; 21965: 						if( lpObj->KillerType == KT_DUELCHAR ) {

  0079f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007a2	0f be 88 fd 01
	00 00		 movsx	 ecx, BYTE PTR [eax+509]
  007a9	83 f9 03	 cmp	 ecx, 3
  007ac	75 35		 jne	 SHORT $LN40@gObjSetSta

; 21966: #ifdef WORLD_TOURNAMENT_EVENT_SETTING
; 21967: 	#ifdef ADD_NEWPVP_PKFIELD
; 21968: 							if (!g_NewPVP.IsDuel(*lpObj))
; 21969: 								MapC[lpObj->MapNumber].GetRandomLengthPos(lpObj->X, lpObj->Y, 8);
; 21970: 	#else
; 21971: 							MapC[lpObj->MapNumber].GetRandomLengthPos(lpObj->X, lpObj->Y, 8);
; 21972: 	#endif // ADD_NEWPVP_PKFIELD
; 21973: #else
; 21974: 	#ifdef ADD_NEWPVP_PKFIELD
; 21975: 							if (!g_NewPVP.IsDuel(*lpObj))
; 21976: 								MapC[lpObj->MapNumber].GetRandomLengthPos(lpObj->X, lpObj->Y, 18);
; 21977: 	#else
; 21978: 							MapC[lpObj->MapNumber].GetRandomLengthPos(lpObj->X, lpObj->Y, 18);

  007ae	6a 12		 push	 18			; 00000012H
  007b0	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007b3	05 06 01 00 00	 add	 eax, 262		; 00000106H
  007b8	50		 push	 eax
  007b9	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  007bc	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  007c2	51		 push	 ecx
  007c3	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  007c6	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  007cd	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  007d3	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  007d9	e8 00 00 00 00	 call	 ?GetRandomLengthPos@MapClass@@QAEXAAF0H@Z ; MapClass::GetRandomLengthPos

; 21979: 	#endif // ADD_NEWPVP_PKFIELD
; 21980: #endif
; 21981: 						} else

  007de	e9 41 04 00 00	 jmp	 $LN63@gObjSetSta
$LN40@gObjSetSta:

; 21982: #endif
; 21983: 						//    
; 21984: 						if( lpObj->KillerType == KT_GUILDWARCHAR )

  007e3	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007e6	0f be 88 fd 01
	00 00		 movsx	 ecx, BYTE PTR [eax+509]
  007ed	83 f9 02	 cmp	 ecx, 2
  007f0	0f 85 c3 00 00
	00		 jne	 $LN42@gObjSetSta

; 21985: 						{
; 21986: 							int wtype=0;

  007f6	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _wtype$2[ebp], 0

; 21987: 							if( (lpObj->lpGuild != NULL) )

  007fd	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00800	83 b8 94 02 00
	00 00		 cmp	 DWORD PTR [eax+660], 0
  00807	74 1c		 je	 SHORT $LN45@gObjSetSta

; 21988: 							{
; 21989: 								if( lpObj->lpGuild->WarType == BTT_SOCCER )

  00809	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0080c	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00812	0f b6 91 92 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1426]
  00819	83 fa 01	 cmp	 edx, 1
  0081c	75 07		 jne	 SHORT $LN45@gObjSetSta

; 21990: 								{
; 21991: 									wtype = 1;

  0081e	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR _wtype$2[ebp], 1
$LN45@gObjSetSta:

; 21992: 								}
; 21993: 							}
; 21994: 							if( wtype == 0 )	//  

  00825	83 7d c0 00	 cmp	 DWORD PTR _wtype$2[ebp], 0
  00829	75 32		 jne	 SHORT $LN46@gObjSetSta

; 21995: 								MapC[lpObj->MapNumber].GetRandomLengthPos(lpObj->X, lpObj->Y, 18);

  0082b	6a 12		 push	 18			; 00000012H
  0082d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00830	05 06 01 00 00	 add	 eax, 262		; 00000106H
  00835	50		 push	 eax
  00836	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00839	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  0083f	51		 push	 ecx
  00840	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00843	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0084a	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00850	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00856	e8 00 00 00 00	 call	 ?GetRandomLengthPos@MapClass@@QAEXAAF0H@Z ; MapClass::GetRandomLengthPos
  0085b	eb 57		 jmp	 SHORT $LN48@gObjSetSta
$LN46@gObjSetSta:

; 21996: 							else				// 
; 21997: 							{
; 21998: 								if( lpObj->lpGuild->WarState )

  0085d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00860	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00866	0f b6 91 91 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1425]
  0086d	85 d2		 test	 edx, edx
  0086f	74 43		 je	 SHORT $LN48@gObjSetSta

; 21999: 								{
; 22000: 									int bgi = lpObj->lpGuild->BattleGroundIndex;

  00871	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00874	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  0087a	0f b6 91 93 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1427]
  00881	89 55 bc	 mov	 DWORD PTR _bgi$1[ebp], edx

; 22001: 									gBattleGetTeamPosition(bgi, lpObj->lpGuild->BattleTeamCode, lpObj->X, lpObj->Y);

  00884	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00887	05 06 01 00 00	 add	 eax, 262		; 00000106H
  0088c	50		 push	 eax
  0088d	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00890	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00896	51		 push	 ecx
  00897	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0089a	8b 82 94 02 00
	00		 mov	 eax, DWORD PTR [edx+660]
  008a0	0f b6 88 94 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1428]
  008a7	51		 push	 ecx
  008a8	8b 55 bc	 mov	 edx, DWORD PTR _bgi$1[ebp]
  008ab	52		 push	 edx
  008ac	e8 00 00 00 00	 call	 ?gBattleGetTeamPosition@@YAXHHAAF0@Z ; gBattleGetTeamPosition
  008b1	83 c4 10	 add	 esp, 16			; 00000010H
$LN48@gObjSetSta:

; 22002: 									//LogAdd("   : %d %d", lpObj->X, lpObj->Y);
; 22003: 								}
; 22004: 							}
; 22005: 
; 22006: 						}

  008b4	e9 6b 03 00 00	 jmp	 $LN63@gObjSetSta
$LN42@gObjSetSta:

; 22007: 						else
; 22008: 						{
; 22009: 							//   ..
; 22010: 							if( lpObj->MapNumber == 0 ||	// 

  008b9	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008bc	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  008c3	85 c9		 test	 ecx, ecx
  008c5	74 0f		 je	 SHORT $LN51@gObjSetSta
  008c7	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008ca	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  008d1	83 f9 01	 cmp	 ecx, 1
  008d4	75 4c		 jne	 SHORT $LN49@gObjSetSta
$LN51@gObjSetSta:

; 22011: 								lpObj->MapNumber == 1 )		// 
; 22012: 							{
; 22013: 								lpObj->MapNumber = 0;

  008d6	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008d9	c6 80 09 01 00
	00 00		 mov	 BYTE PTR [eax+265], 0

; 22014: 								MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );

  008e0	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008e3	05 06 01 00 00	 add	 eax, 262		; 00000106H
  008e8	50		 push	 eax
  008e9	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  008ec	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  008f2	51		 push	 ecx
  008f3	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008f6	66 0f b6 82 09
	01 00 00	 movzx	 ax, BYTE PTR [edx+265]
  008fe	0f b7 c8	 movzx	 ecx, ax
  00901	51		 push	 ecx
  00902	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00905	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0090c	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00912	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00918	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos

; 22015: 							}

  0091d	e9 02 03 00 00	 jmp	 $LN63@gObjSetSta
$LN49@gObjSetSta:

; 22016: 							else if( lpObj->m_stateEngagePVP == PVP_USER_PLAYING )

  00922	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00925	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  0092c	75 15		 jne	 SHORT $LN52@gObjSetSta

; 22017: 							{
; 22018: 								g_PvpEvent.DeleteUser(lpObj->m_Index);

  0092e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00931	8b 08		 mov	 ecx, DWORD PTR [eax]
  00933	51		 push	 ecx
  00934	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PvpEvent@@3VCEngagePVP@@A ; g_PvpEvent
  00939	e8 00 00 00 00	 call	 ?DeleteUser@CEngagePVP@@QAEXH@Z ; CEngagePVP::DeleteUser

; 22019: 							}

  0093e	e9 e1 02 00 00	 jmp	 $LN63@gObjSetSta
$LN52@gObjSetSta:

; 22020: #ifdef DEVILSQUARE_EXTEND_20050221		//    
; 22021: 							else if( CHECK_DEVILSQUARE(lpObj->MapNumber) )	//  
; 22022: #else
; 22023: 							else if( lpObj->MapNumber == 9 )				//  

  00943	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00946	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0094d	83 f9 09	 cmp	 ecx, 9
  00950	75 5a		 jne	 SHORT $LN54@gObjSetSta

; 22024: #endif
; 22025: 							{
; 22026: 								g_DevilSquare.DieProcDevilSquare(lpObj);

  00952	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00955	50		 push	 eax
  00956	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_DevilSquare@@3VCDevilSquare@@A ; g_DevilSquare
  0095b	e8 00 00 00 00	 call	 ?DieProcDevilSquare@CDevilSquare@@QAEXPAVOBJECTSTRUCT@@@Z ; CDevilSquare::DieProcDevilSquare

; 22027: 								lpObj->MapNumber = 3;

  00960	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00963	c6 80 09 01 00
	00 03		 mov	 BYTE PTR [eax+265], 3

; 22028: 								MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );

  0096a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0096d	05 06 01 00 00	 add	 eax, 262		; 00000106H
  00972	50		 push	 eax
  00973	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00976	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  0097c	51		 push	 ecx
  0097d	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00980	66 0f b6 82 09
	01 00 00	 movzx	 ax, BYTE PTR [edx+265]
  00988	0f b7 c8	 movzx	 ecx, ax
  0098b	51		 push	 ecx
  0098c	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0098f	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00996	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  0099c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  009a2	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos

; 22029: 							}

  009a7	e9 78 02 00 00	 jmp	 $LN63@gObjSetSta
$LN54@gObjSetSta:

; 22030: #ifdef NEW_SKILL_FORSKYLAND
; 22031: 							else if( lpObj->MapNumber == 10 )

  009ac	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009af	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  009b6	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  009b9	75 4c		 jne	 SHORT $LN56@gObjSetSta

; 22032: 							{
; 22033: 								lpObj->MapNumber = 2;

  009bb	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009be	c6 80 09 01 00
	00 02		 mov	 BYTE PTR [eax+265], 2

; 22034: 								MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );

  009c5	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009c8	05 06 01 00 00	 add	 eax, 262		; 00000106H
  009cd	50		 push	 eax
  009ce	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  009d1	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  009d7	51		 push	 ecx
  009d8	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  009db	66 0f b6 82 09
	01 00 00	 movzx	 ax, BYTE PTR [edx+265]
  009e3	0f b7 c8	 movzx	 ecx, ax
  009e6	51		 push	 ecx
  009e7	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  009ea	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  009f1	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  009f7	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  009fd	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos

; 22035: 							}

  00a02	e9 1d 02 00 00	 jmp	 $LN63@gObjSetSta
$LN56@gObjSetSta:

; 22036: #endif
; 22037: #ifdef FOR_BLOODCASTLE
; 22038: 							else if( CHECK_BLOODCASTLE(lpObj->MapNumber))	//   

  00a07	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a0a	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00a11	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00a14	7d 0c		 jge	 SHORT $LN90@gObjSetSta
  00a16	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv515[ebp], 0
  00a20	eb 31		 jmp	 SHORT $LN91@gObjSetSta
$LN90@gObjSetSta:
  00a22	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a25	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00a2c	83 f8 11	 cmp	 eax, 17			; 00000011H
  00a2f	7e 0c		 jle	 SHORT $LN88@gObjSetSta
  00a31	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv514[ebp], 0
  00a3b	eb 0a		 jmp	 SHORT $LN89@gObjSetSta
$LN88@gObjSetSta:
  00a3d	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv514[ebp], 1
$LN89@gObjSetSta:
  00a47	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv514[ebp]
  00a4d	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv515[ebp], ecx
$LN91@gObjSetSta:
  00a53	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv515[ebp], 0
  00a5a	74 4c		 je	 SHORT $LN58@gObjSetSta

; 22039: 							{
; 22040: 								lpObj->MapNumber = 2;

  00a5c	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a5f	c6 80 09 01 00
	00 02		 mov	 BYTE PTR [eax+265], 2

; 22041: 								MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );

  00a66	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a69	05 06 01 00 00	 add	 eax, 262		; 00000106H
  00a6e	50		 push	 eax
  00a6f	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00a72	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00a78	51		 push	 ecx
  00a79	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a7c	66 0f b6 82 09
	01 00 00	 movzx	 ax, BYTE PTR [edx+265]
  00a84	0f b7 c8	 movzx	 ecx, ax
  00a87	51		 push	 ecx
  00a88	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a8b	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00a92	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00a98	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00a9e	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos

; 22042: 							}

  00aa3	e9 7c 01 00 00	 jmp	 $LN63@gObjSetSta
$LN58@gObjSetSta:

; 22043: #endif
; 22044: #ifdef CHAOSCASTLE_SYSTEM_20040408
; 22045: 							else if( CHECK_CHAOSCASTLE(lpObj->MapNumber))	//   

  00aa8	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00aab	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00ab2	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00ab5	7d 0c		 jge	 SHORT $LN94@gObjSetSta
  00ab7	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv537[ebp], 0
  00ac1	eb 31		 jmp	 SHORT $LN95@gObjSetSta
$LN94@gObjSetSta:
  00ac3	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ac6	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00acd	83 f8 17	 cmp	 eax, 23			; 00000017H
  00ad0	7e 0c		 jle	 SHORT $LN92@gObjSetSta
  00ad2	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv536[ebp], 0
  00adc	eb 0a		 jmp	 SHORT $LN93@gObjSetSta
$LN92@gObjSetSta:
  00ade	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv536[ebp], 1
$LN93@gObjSetSta:
  00ae8	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv536[ebp]
  00aee	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv537[ebp], ecx
$LN95@gObjSetSta:
  00af4	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv537[ebp], 0
  00afb	74 4c		 je	 SHORT $LN60@gObjSetSta

; 22046: 							{
; 22047: 								lpObj->MapNumber = 2;

  00afd	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b00	c6 80 09 01 00
	00 02		 mov	 BYTE PTR [eax+265], 2

; 22048: 								MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );

  00b07	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b0a	05 06 01 00 00	 add	 eax, 262		; 00000106H
  00b0f	50		 push	 eax
  00b10	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b13	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00b19	51		 push	 ecx
  00b1a	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b1d	66 0f b6 82 09
	01 00 00	 movzx	 ax, BYTE PTR [edx+265]
  00b25	0f b7 c8	 movzx	 ecx, ax
  00b28	51		 push	 ecx
  00b29	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b2c	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00b33	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00b39	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00b3f	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos

; 22049: 							}

  00b44	e9 db 00 00 00	 jmp	 $LN63@gObjSetSta
$LN60@gObjSetSta:

; 22050: #endif
; 22051: #ifdef ADD_NEW_MAP_KALIMA_20040518
; 22052: 							else if( CHECK_KALIMAMAP(lpObj->MapNumber))		//   

  00b49	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b4c	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00b53	83 f9 18	 cmp	 ecx, 24			; 00000018H
  00b56	7d 0c		 jge	 SHORT $LN98@gObjSetSta
  00b58	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv559[ebp], 0
  00b62	eb 31		 jmp	 SHORT $LN99@gObjSetSta
$LN98@gObjSetSta:
  00b64	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b67	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00b6e	83 f8 1d	 cmp	 eax, 29			; 0000001dH
  00b71	7e 0c		 jle	 SHORT $LN96@gObjSetSta
  00b73	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv558[ebp], 0
  00b7d	eb 0a		 jmp	 SHORT $LN97@gObjSetSta
$LN96@gObjSetSta:
  00b7f	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv558[ebp], 1
$LN97@gObjSetSta:
  00b89	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv558[ebp]
  00b8f	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv559[ebp], ecx
$LN99@gObjSetSta:
  00b95	83 bd 78 ff ff
	ff 00		 cmp	 DWORD PTR tv559[ebp], 0
  00b9c	74 49		 je	 SHORT $LN62@gObjSetSta

; 22053: 							{
; 22054: 								lpObj->MapNumber = 2;

  00b9e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ba1	c6 80 09 01 00
	00 02		 mov	 BYTE PTR [eax+265], 2

; 22055: 								MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );

  00ba8	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bab	05 06 01 00 00	 add	 eax, 262		; 00000106H
  00bb0	50		 push	 eax
  00bb1	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bb4	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00bba	51		 push	 ecx
  00bbb	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00bbe	66 0f b6 82 09
	01 00 00	 movzx	 ax, BYTE PTR [edx+265]
  00bc6	0f b7 c8	 movzx	 ecx, ax
  00bc9	51		 push	 ecx
  00bca	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00bcd	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00bd4	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00bda	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00be0	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos

; 22056: 							}

  00be5	eb 3d		 jmp	 SHORT $LN63@gObjSetSta
$LN62@gObjSetSta:

; 22057: #endif
; 22058: 							
; 22059: #ifdef ADD_CASTLE_HUNTZONE_NPC_01_20050111
; 22060: 							else if( lpObj->MapNumber == MAP_INDEX_CASTLEHUNTZONE)	//    
; 22061: 							{
; 22062: 								INT iGateNum	= CASTLE_HUNTZONE_GATE_01;
; 22063: 								
; 22064: 								SHORT sX, sY, sLVL;
; 22065: 								BYTE btMAPNUM	= lpObj->MapNumber; 
; 22066: 								BYTE btDIR;
; 22067: 								INT iMapNumber	= gGateC.GetGate(iGateNum, sX, sY, btMAPNUM, btDIR, sLVL);
; 22068: 								if( iMapNumber >= 0 ) 
; 22069: 								{
; 22070: 									lpObj->MapNumber	= btMAPNUM;
; 22071: 									lpObj->X			= sX;
; 22072: 									lpObj->Y			= sY;
; 22073: 								}
; 22074: 							}
; 22075: #endif
; 22076: 							
; 22077: #ifdef CASTLE_NPC_LIFESTONE_WORK_20041208	//        
; 22078: 							else if( lpObj->MapNumber == MAP_INDEX_CASTLESIEGE )		
; 22079: 							{
; 22080: 								if( g_CsNPC_LifeStone.SetReSpawnUserXY( lpObj->m_Index ) == FALSE )
; 22081: 								{
; 22082: 									INT iGateNum	= 100;
; 22083: 									if (lpObj->m_btCsJoinSide == CS_SIEGESIDE_DEFEND) 
; 22084: 									{
; 22085: 										iGateNum	= 105;		//    
; 22086: 									}
; 22087: 									else 
; 22088: 									{
; 22089: 										iGateNum	= 100;		//    
; 22090: 									}
; 22091: 
; 22092: 									SHORT sX, sY, sLVL;
; 22093: 									BYTE btMAPNUM	= lpObj->MapNumber; 
; 22094: 									BYTE btDIR;
; 22095: 									INT iMapNumber	= gGateC.GetGate(iGateNum, sX, sY, btMAPNUM, btDIR, sLVL);
; 22096: 									if( iMapNumber >= 0 ) {
; 22097: 										lpObj->MapNumber	= btMAPNUM;
; 22098: 										lpObj->X			= sX;
; 22099: 										lpObj->Y			= sY;
; 22100: 									}
; 22101: 									//     
; 22102: 								}
; 22103: 							}
; 22104: #endif
; 22105: 
; 22106: #ifdef ADD_NEW_MAP_AIDA_20050617
; 22107: 							//   
; 22108: 							else if( lpObj->MapNumber == MAP_INDEX_AIDA )		
; 22109: 							{
; 22110: 								MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );
; 22111: 							}
; 22112: #endif
; 22113: 							
; 22114: #ifdef ADD_NEW_MAP_CRYWOLF_FIRSTZONE_20050414
; 22115: 							//  1   
; 22116: 							else if( lpObj->MapNumber == MAP_INDEX_CRYWOLF_FIRSTZONE )		
; 22117: 							{
; 22118: 								
; 22119: #ifdef CRYWOLF_MODIFY_REGEN_POS_ON_MVP_20060116
; 22120: 								if( g_Crywolf.GetCrywolfState() == CRYWOLF_STATE_START )
; 22121: 								{
; 22122: 									//  (/ )  
; 22123: 									INT iGateNum	= 118;
; 22124: 									
; 22125: 									SHORT sX, sY, sLVL;
; 22126: 									BYTE btMAPNUM	= lpObj->MapNumber; 
; 22127: 									BYTE btDIR;
; 22128: 									INT iMapNumber	= gGateC.GetGate(iGateNum, sX, sY, btMAPNUM, btDIR, sLVL);
; 22129: 									if( iMapNumber >= 0 ) 
; 22130: 									{
; 22131: 										lpObj->MapNumber	= btMAPNUM;
; 22132: 										lpObj->X			= sX;
; 22133: 										lpObj->Y			= sY;
; 22134: 									}
; 22135: 									else
; 22136: 									{
; 22137: 										MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );
; 22138: 									}
; 22139: 								}
; 22140: 								else
; 22141: 								{
; 22142: 									MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );
; 22143: 								}
; 22144: #else
; 22145: 								MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );
; 22146: #endif // CRYWOLF_MODIFY_REGEN_POS_ON_MVP_20060116
; 22147: 								
; 22148: 							}
; 22149: 
; 22150: #endif
; 22151: 
; 22152: #ifdef ADD_KANTURU_20060627
; 22153: 							//    
; 22154: 							else if( lpObj->MapNumber == MAP_INDEX_KANTURU_BOSS )		
; 22155: 							{
; 22156: 								INT iGateNum	= KANTURU_DEFAULT_REGEN_MAP_GATE;
; 22157: 								
; 22158: 								SHORT sX, sY, sLVL;
; 22159: 								BYTE btMAPNUM	= lpObj->MapNumber; 
; 22160: 								BYTE btDIR;
; 22161: 								INT iMapNumber	= gGateC.GetGate(iGateNum, sX, sY, btMAPNUM, btDIR, sLVL);
; 22162: 								if( iMapNumber >= 0 ) 
; 22163: 								{
; 22164: 									lpObj->MapNumber	= btMAPNUM;
; 22165: 									lpObj->X			= sX;
; 22166: 									lpObj->Y			= sY;
; 22167: 								}			
; 22168: 								
; 22169: 								g_KanturuBattleUserMng.DeleteUserData( lpObj->m_Index );
; 22170: 							}
; 22171: #endif	// #ifdef ADD_KANTURU_20060627
; 22172: 
; 22173: #ifdef ADD_KANTURU_CONDITION_20060725
; 22174: 							//    
; 22175: 							else if( lpObj->MapNumber == MAP_INDEX_KANTURU1 )
; 22176: 							{
; 22177: 								int iGateNum = KANTURU_DIEREGEN_GATE_MAP_1;
; 22178: 
; 22179: 								SHORT sX, sY, sLVL;
; 22180: 								BYTE btMAPNUM	= lpObj->MapNumber; 
; 22181: 								BYTE btDIR;
; 22182: 								INT iMapNumber	= gGateC.GetGate(iGateNum, sX, sY, btMAPNUM, btDIR, sLVL);
; 22183: 								if( iMapNumber >= 0 ) 
; 22184: 								{
; 22185: 									lpObj->MapNumber	= btMAPNUM;
; 22186: 									lpObj->X			= sX;
; 22187: 									lpObj->Y			= sY;
; 22188: 								}
; 22189: 							}
; 22190: 							else if( lpObj->MapNumber == MAP_INDEX_KANTURU2 ) 
; 22191: 							{
; 22192: 								int iGateNum = KANTURU_DIEREGEN_GATE_MAP_2;
; 22193: 
; 22194: 								SHORT sX, sY, sLVL;
; 22195: 								BYTE btMAPNUM	= lpObj->MapNumber; 
; 22196: 								BYTE btDIR;
; 22197: 								INT iMapNumber	= gGateC.GetGate(iGateNum, sX, sY, btMAPNUM, btDIR, sLVL);
; 22198: 								if( iMapNumber >= 0 ) 
; 22199: 								{
; 22200: 									lpObj->MapNumber	= btMAPNUM;
; 22201: 									lpObj->X			= sX;
; 22202: 									lpObj->Y			= sY;
; 22203: 								}
; 22204: 							}
; 22205: #endif		//ADD_KANTURU_CONDITION_20060725
; 22206: #ifdef THIRD_CHANGEUP_SYSTEM_20070507	// 3      						
; 22207: 							else if( lpObj->MapNumber == MAP_INDEX_3RD_CHANGEUP_QUEST 
; 22208: 								|| lpObj->MapNumber == MAP_INDEX_3RD_CHANGEUP_BOSS_QUEST )
; 22209: 							{
; 22210: 								int iGateNum = GATE_REGENPLACE_OF_BALGAS;
; 22211: 
; 22212: 								SHORT sX, sY, sLVL;
; 22213: 								BYTE btMAPNUM	= lpObj->MapNumber; 
; 22214: 								BYTE btDIR;
; 22215: 								INT iMapNumber	= gGateC.GetGate(iGateNum, sX, sY, btMAPNUM, btDIR, sLVL);
; 22216: 								if( iMapNumber >= 0 ) 
; 22217: 								{
; 22218: 									lpObj->MapNumber	= btMAPNUM;
; 22219: 									lpObj->X			= sX;
; 22220: 									lpObj->Y			= sY;
; 22221: 								}
; 22222: 							}
; 22223: #endif	// THIRD_CHANGEUP_SYSTEM_20070507
; 22224: #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//     
; 22225: 							else if( CHECK_ILLUSION_TEMPLE(lpObj->MapNumber))
; 22226: 							{
; 22227: 								BYTE btTeam = g_IllusionTempleEvent.GetUserTeam(lpObj->MapNumber, lpObj->m_Index);
; 22228: 								if( btTeam == 0xFF)
; 22229: 								{
; 22230: 									lpObj->MapNumber = 2;
; 22231: 									MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );
; 22232: 								}
; 22233: 								else
; 22234: 								{
; 22235: 									if(btTeam == TEAM_ALLIED)
; 22236: 									{	
; 22237: 										int iGateNum = GATE_ILLUSION_TEMPLE_ALLIED1 + (lpObj->MapNumber - MAP_INDEX_ILLUSION_TEMPLE1);
; 22238: 										
; 22239: 										SHORT sX, sY, sLVL;
; 22240: 										BYTE btMAPNUM	= lpObj->MapNumber; 
; 22241: 										BYTE btDIR;
; 22242: 										INT iMapNumber	= gGateC.GetGate(iGateNum, sX, sY, btMAPNUM, btDIR, sLVL);
; 22243: 										if( iMapNumber >= 0 ) 
; 22244: 										{
; 22245: 											lpObj->MapNumber	= btMAPNUM;
; 22246: 											lpObj->X			= sX;
; 22247: 											lpObj->Y			= sY;
; 22248: 										}
; 22249: 
; 22250: 										//  
; 22251: 										g_IllusionTempleEvent.IllusionTempleUserDieRegen(lpObj);
; 22252: 									}
; 22253: 									else if(btTeam == TEAM_ILLUSION)
; 22254: 									{
; 22255: 										int iGateNum = GATE_ILLUSION_TEMPLE_ILLUSION1 + (lpObj->MapNumber - MAP_INDEX_ILLUSION_TEMPLE1);
; 22256: 										
; 22257: 										SHORT sX, sY, sLVL;
; 22258: 										BYTE btMAPNUM	= lpObj->MapNumber; 
; 22259: 										BYTE btDIR;
; 22260: 										INT iMapNumber	= gGateC.GetGate(iGateNum, sX, sY, btMAPNUM, btDIR, sLVL);
; 22261: 										if( iMapNumber >= 0 ) 
; 22262: 										{
; 22263: 											lpObj->MapNumber	= btMAPNUM;
; 22264: 											lpObj->X			= sX;
; 22265: 											lpObj->Y			= sY;
; 22266: 										}
; 22267: 
; 22268: 										//  
; 22269: 										g_IllusionTempleEvent.IllusionTempleUserDieRegen(lpObj);
; 22270: 									}
; 22271: 									else
; 22272: 									{
; 22273: 										lpObj->MapNumber = 2;
; 22274: 										MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );
; 22275: 									}
; 22276: 								}
; 22277: 							}
; 22278: #endif	// ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328
; 22279: #ifdef UPDATE_NEWMAP_SWAMP_OF_CALMNESS_20080108					//  
; 22280: 							else if( lpObj->MapNumber == MAP_INDEX_SWAMP_OF_CALMNESS )	
; 22281: 							{
; 22282: 								int iGateNum = 273;	//     
; 22283: 								
; 22284: 								SHORT sX, sY, sLVL;
; 22285: 								BYTE btMAPNUM	= lpObj->MapNumber; 
; 22286: 								BYTE btDIR;
; 22287: 								INT iMapNumber	= gGateC.GetGate(iGateNum, sX, sY, btMAPNUM, btDIR, sLVL);
; 22288: 								if( iMapNumber >= 0 ) 
; 22289: 								{
; 22290: 									lpObj->MapNumber	= btMAPNUM;
; 22291: 									lpObj->X			= sX;
; 22292: 									lpObj->Y			= sY;
; 22293: 								}
; 22294: 							}
; 22295: #endif	// ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328							
; 22296: #ifdef ADD_RAKLION_20080408							//   
; 22297: 							else if( lpObj->MapNumber == MAP_INDEX_RAKLION_FIELD 
; 22298: 								|| lpObj->MapNumber == MAP_INDEX_RAKLION_BOSS )	
; 22299: 							{
; 22300: 								int iGateNum = 286;	//  
; 22301: 								
; 22302: 								SHORT sX, sY, sLVL;
; 22303: 								BYTE btMAPNUM	= lpObj->MapNumber; 
; 22304: 								BYTE btDIR;
; 22305: 								INT iMapNumber	= gGateC.GetGate(iGateNum, sX, sY, btMAPNUM, btDIR, sLVL);
; 22306: 								if( iMapNumber >= 0 ) 
; 22307: 								{
; 22308: 									lpObj->MapNumber	= btMAPNUM;
; 22309: 									lpObj->X			= sX;
; 22310: 									lpObj->Y			= sY;
; 22311: 								}
; 22312: 							}
; 22313: #endif	// ADD_RAKLION_20080408
; 22314: 							else //    ..
; 22315: 							{
; 22316: 								MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );

  00be7	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bea	05 06 01 00 00	 add	 eax, 262		; 00000106H
  00bef	50		 push	 eax
  00bf0	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00bf3	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00bf9	51		 push	 ecx
  00bfa	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00bfd	66 0f b6 82 09
	01 00 00	 movzx	 ax, BYTE PTR [edx+265]
  00c05	0f b7 c8	 movzx	 ecx, ax
  00c08	51		 push	 ecx
  00c09	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c0c	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00c13	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00c19	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00c1f	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos
$LN63@gObjSetSta:

; 22317: 							}
; 22318: 
; 22319: 						}
; 22320: 						
; 22321: #ifdef MAP_SERVER_WORK_20041030								//    ->         
; 22322: 						SHORT sSvrCode	= g_MapServerManager.CheckMoveMapSvr(lpObj->m_Index, lpObj->MapNumber, lpObj->m_sPrevMapSvrCode);
; 22323: 						if (sSvrCode != gGameServerCode) {
; 22324: 							if (sSvrCode == -1) {
; 22325: 								//   ->  
; 22326: 								LogAddC(LOGC_RED, "[MapServerMng] Map Server Move Fail : CheckMoveMapSvr() == -1 [%s][%s] (%d)",
; 22327: 									lpObj->AccountID,
; 22328: 									lpObj->Name,
; 22329: 									lpObj->m_Index
; 22330: 									);
; 22331: 								continue;
; 22332: 							}
; 22333: 
; 22334: 							//     .
; 22335: 							INT iObjDstMap				= lpObj->MapNumber;
; 22336: 							INT iObjDstX				= lpObj->X;
; 22337: 							INT iObjDstY				= lpObj->Y;
; 22338: 							lpObj->MapNumber			= iObjSrcMap;
; 22339: 							lpObj->X					= iObjSrcX;
; 22340: 							lpObj->Y					= iObjSrcY;
; 22341: 
; 22342: 							GJReqMapSvrMove (lpObj->m_Index, sSvrCode, iObjDstMap, iObjDstX, iObjDstY);
; 22343: 							LogAddTD("[MapServerMng] Request to Move Map Server : (%d) - [%s][%s] (%d)",
; 22344: 								sSvrCode,
; 22345: 								lpObj->AccountID,
; 22346: 								lpObj->Name,
; 22347: 								lpObj->m_Index
; 22348: 								);
; 22349: 							continue;
; 22350: 						}
; 22351: #endif
; 22352: 
; 22353: 						//LogAdd("MapNumber2 %d", lpObj->MapNumber);
; 22354: 						
; 22355: 						lpObj->TX   = lpObj->X;

  00c24	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c27	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c2a	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  00c31	66 89 90 20 01
	00 00		 mov	 WORD PTR [eax+288], dx

; 22356: 						lpObj->TY   = lpObj->Y;						

  00c38	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c3b	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c3e	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  00c45	66 89 90 22 01
	00 00		 mov	 WORD PTR [eax+290], dx

; 22357: 						CreateFrustrum(lpObj->X,lpObj->Y, n);

  00c4c	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00c4f	50		 push	 eax
  00c50	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c53	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00c5a	52		 push	 edx
  00c5b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c5e	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00c65	51		 push	 ecx
  00c66	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  00c6b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 22358: 						
; 22359: 						pMsg.h.c          = PMHCE_BYTE;

  00c6e	c6 45 c8 c3	 mov	 BYTE PTR _pMsg$4[ebp], 195 ; 000000c3H

; 22360: 						pMsg.h.headcode   = 0xF3;

  00c72	c6 45 ca f3	 mov	 BYTE PTR _pMsg$4[ebp+2], 243 ; 000000f3H

; 22361: 						pMsg.h.size       = sizeof( pMsg );

  00c76	c6 45 c9 18	 mov	 BYTE PTR _pMsg$4[ebp+1], 24 ; 00000018H

; 22362: 						pMsg.subcode      = 0x04;

  00c7a	c6 45 cb 04	 mov	 BYTE PTR _pMsg$4[ebp+3], 4

; 22363: 						pMsg.Dir          = lpObj->Dir;

  00c7e	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c81	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  00c87	88 4d cf	 mov	 BYTE PTR _pMsg$4[ebp+7], cl

; 22364: 						pMsg.MapX         = (BYTE)lpObj->X;

  00c8a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c8d	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  00c93	88 4d cc	 mov	 BYTE PTR _pMsg$4[ebp+4], cl

; 22365: 						pMsg.MapY         = (BYTE)lpObj->Y;

  00c96	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c99	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  00c9f	88 4d cd	 mov	 BYTE PTR _pMsg$4[ebp+5], cl

; 22366: 						pMsg.Life         = (WORD)lpObj->Life;

  00ca2	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ca5	f3 0f 2c 88 bc
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+188]
  00cad	66 89 4d d0	 mov	 WORD PTR _pMsg$4[ebp+8], cx

; 22367: 						pMsg.Mana         = (WORD)lpObj->Mana;

  00cb1	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cb4	f3 0f 2c 88 d0
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+208]
  00cbc	66 89 4d d2	 mov	 WORD PTR _pMsg$4[ebp+10], cx

; 22368: 						
; 22369: #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	//    .
; 22370: 						INT64 i64Exp = lpObj->Experience;
; 22371: 						if( g_MasterLevelSystem.IsMasterLevelUser( lpObj ) )
; 22372: 						{
; 22373: 							i64Exp = lpObj->m_i64MasterLevelExp;
; 22374: 						}
; 22375: 						else
; 22376: 						{
; 22377: 							i64Exp = lpObj->Experience;
; 22378: 						}
; 22379: 						//     						
; 22380: 						pMsg.btExp1			= HIBYTE(HIWORD(HILONG( i64Exp )));
; 22381: 						pMsg.btExp2			= LOBYTE(HIWORD(HILONG( i64Exp )));
; 22382: 						pMsg.btExp3			= HIBYTE(LOWORD(HILONG( i64Exp )));
; 22383: 						pMsg.btExp4			= LOBYTE(LOWORD(HILONG( i64Exp )));
; 22384: 						pMsg.btExp5			= HIBYTE(HIWORD(LOLONG( i64Exp )));
; 22385: 						pMsg.btExp6			= LOBYTE(HIWORD(LOLONG( i64Exp )));
; 22386: 						pMsg.btExp7			= HIBYTE(LOWORD(LOLONG( i64Exp )));
; 22387: 						pMsg.btExp8			= LOBYTE(LOWORD(LOLONG( i64Exp )));						
; 22388: #else
; 22389: 						pMsg.Exp		  = lpObj->Experience;

  00cc0	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cc3	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00cc9	89 4d d8	 mov	 DWORD PTR _pMsg$4[ebp+16], ecx

; 22390: #endif	// MASTER_LEVEL_UP_SYSTEM_20070912
; 22391: 						pMsg.MapNumber    = lpObj->MapNumber;

  00ccc	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ccf	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  00cd5	88 4d ce	 mov	 BYTE PTR _pMsg$4[ebp+6], cl

; 22392: 						pMsg.Money		  = lpObj->Money;

  00cd8	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cdb	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00ce1	89 4d dc	 mov	 DWORD PTR _pMsg$4[ebp+20], ecx

; 22393: 
; 22394: #ifdef ADD_SHIELD_POINT_01_20060403
; 22395: 						pMsg.wShield	  = lpObj->iShield;
; 22396: #endif
; 22397: 
; 22398: #ifdef NEW_FORSKYLAND2
; 22399: 						pMsg.BP			  = lpObj->BP;	

  00ce4	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ce7	66 8b 88 e8 00
	00 00		 mov	 cx, WORD PTR [eax+232]
  00cee	66 89 4d d4	 mov	 WORD PTR _pMsg$4[ebp+12], cx

; 22400: #endif
; 22401: 						lpObj->PathCount  = 0;

  00cf2	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cf5	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0

; 22402: 						
; 22403: 						DataSend(n, (LPBYTE)&pMsg, pMsg.h.size);

  00cff	0f b6 45 c9	 movzx	 eax, BYTE PTR _pMsg$4[ebp+1]
  00d03	50		 push	 eax
  00d04	8d 4d c8	 lea	 ecx, DWORD PTR _pMsg$4[ebp]
  00d07	51		 push	 ecx
  00d08	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  00d0b	52		 push	 edx
  00d0c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00d11	83 c4 0c	 add	 esp, 12			; 0000000cH

; 22404: 
; 22405: #ifdef BUGFIX_UPDATE_VIEWPORT_INFO_FOR_SELF_20050510
; 22406: 						gObjViewportListProtocolCreate(lpObj);

  00d14	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d17	50		 push	 eax
  00d18	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00d1d	83 c4 04	 add	 esp, 4

; 22407: #endif // BUGFIX_UPDATE_VIEWPORT_INFO_FOR_SELF_20050510
; 22408: 
; 22409: 						//   ..
; 22410: 						if( DragonEvent->GetState() != 0 )

  00d20	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  00d26	e8 00 00 00 00	 call	 ?GetState@CDragonEvent@@QAEEXZ ; CDragonEvent::GetState
  00d2b	0f b6 c0	 movzx	 eax, al
  00d2e	85 c0		 test	 eax, eax
  00d30	74 33		 je	 SHORT $LN65@gObjSetSta

; 22411: 						{
; 22412: 							if( DragonEvent->GetMapNumber() == lpObj->MapNumber )

  00d32	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  00d38	e8 00 00 00 00	 call	 ?GetMapNumber@CDragonEvent@@QAEEXZ ; CDragonEvent::GetMapNumber
  00d3d	0f b6 c0	 movzx	 eax, al
  00d40	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d43	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00d4a	3b c2		 cmp	 eax, edx
  00d4c	75 17		 jne	 SHORT $LN65@gObjSetSta

; 22413: 							{
; 22414: 								GCMapEventStateSend(lpObj->MapNumber, 1, 1);

  00d4e	6a 01		 push	 1
  00d50	6a 01		 push	 1
  00d52	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d55	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00d5c	51		 push	 ecx
  00d5d	e8 00 00 00 00	 call	 ?GCMapEventStateSend@@YAXHEE@Z ; GCMapEventStateSend
  00d62	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN65@gObjSetSta:

; 22415: 							}
; 22416: 						}
; 22417: 						gEledoradoEvent.CheckGoldDercon(lpObj->MapNumber);

  00d65	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d68	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00d6f	51		 push	 ecx
  00d70	b9 00 00 00 00	 mov	 ecx, OFFSET ?gEledoradoEvent@@3VCEledoradoEvent@@A ; gEledoradoEvent
  00d75	e8 00 00 00 00	 call	 ?CheckGoldDercon@CEledoradoEvent@@QAEXH@Z ; CEledoradoEvent::CheckGoldDercon

; 22418: 
; 22419: #ifdef GMCOMMAND_EX_1ST_BUGFIX
; 22420: 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 22421: 						if( lpObj->Authority == AUTHORITY_EVENT_GM )
; 22422: 						{
; 22423: 							gObjAddBuffEffect( lpObj, BUFFTYPE_GM_MARK, 0, 0, 0, 0, BUFFTIME_INFINITE );
; 22424: 						}
; 22425: 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 22426: #endif // GMCOMMAND_EX_1ST_BUGFIX
; 22427: 
; 22428: #ifdef CASTLE_MAIN_SCHEDULER_20041111				//     .
; 22429: 						if (lpObj->MapNumber == MAP_INDEX_CASTLESIEGE) {
; 22430: 							GCAnsCsNotifyStart(lpObj->m_Index, (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)?1:0);
; 22431: 							if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE) {
; 22432: 								g_CastleSiege.NotifySelfCsJoinSide (lpObj->m_Index);
; 22433: 								g_CastleSiege.NotifyCsSelfLeftTime (lpObj->m_Index);
; 22434: 							}
; 22435: 						}
; 22436: #endif
; 22437: 
; 22438: #ifdef CRYWOLF_MAIN_SCHEDULER_20050505
; 22439: 						//     ,
; 22440: 						//      ?
; 22441: 						
; 22442: #endif
; 22443: 
; 22444: #ifdef FOR_JAPAN	
; 22445: 						//   
; 22446: 						if( gTamaJJangEvent )
; 22447: 						{
; 22448: 							if( gAppearTamaJJang && lpObj->MapNumber == 0 )
; 22449: 							{	//   ,  
; 22450: 								GCMapEventStateSend(0, gAppearTamaJJang, 2);	
; 22451: 							}
; 22452: 						}
; 22453: #endif
; 22454: 
; 22455: 					}

  00d7a	eb 37		 jmp	 SHORT $LN39@gObjSetSta
$LN38@gObjSetSta:

; 22456: 					else 
; 22457: 					{	
; 22458: 						//     .
; 22459: 
; 22460: 						/*if( lpObj->m_RecallMon >= 0 )
; 22461: 						{
; 22462: 							gObjMonsterCallKill(lpObj->m_RecallMon);
; 22463: 						}
; 22464: 						else */
; 22465: 						{
; 22466: 							if( !gObjMonsterRegen(lpObj) )

  00d7c	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d7f	50		 push	 eax
  00d80	e8 00 00 00 00	 call	 ?gObjMonsterRegen@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterRegen
  00d85	83 c4 04	 add	 esp, 4
  00d88	85 c0		 test	 eax, eax
  00d8a	75 05		 jne	 SHORT $LN66@gObjSetSta

; 22467: 								continue;

  00d8c	e9 8e f2 ff ff	 jmp	 $LN2@gObjSetSta
$LN66@gObjSetSta:

; 22468: 
; 22469: 							CreateFrustrum(lpObj->X,lpObj->Y, n);

  00d91	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00d94	50		 push	 eax
  00d95	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d98	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00d9f	52		 push	 edx
  00da0	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00da3	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00daa	51		 push	 ecx
  00dab	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  00db0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN39@gObjSetSta:

; 22470: 						}
; 22471: 						
; 22472: #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_4_20070802
; 22473: 						if(CHECK_ILLUSION_TEMPLE(lpObj->MapNumber))
; 22474: 						{
; 22475: 							if(lpObj->Class == NPC_ILLUSION_HOLY_RELICS_STATUE)
; 22476: 							{
; 22477: 								LogAddTD("[Illusion Temple] (%d) Status Regen OK (%d: %d/%d)",
; 22478: 									lpObj->MapNumber - MAP_INDEX_ILLUSION_TEMPLE1 +1, lpObj->MapNumber, lpObj->X, lpObj->Y);
; 22479: 							}
; 22480: 							
; 22481: 						}
; 22482: #endif
; 22483: 					}
; 22484: 					lpObj->DieRegen	= 0;

  00db3	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00db6	c6 80 fe 01 00
	00 00		 mov	 BYTE PTR [eax+510], 0

; 22485: 					lpObj->m_State	= OBJST_CREATE;

  00dbd	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dc0	c7 80 b8 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+440], 1
$LN37@gObjSetSta:

; 22486: 				}
; 22487: 			}
; 22488: 		}
; 22489: 	}

  00dca	e9 50 f2 ff ff	 jmp	 $LN2@gObjSetSta
$LN3@gObjSetSta:

; 22490: 	for( n=0; n<g_TerrainManager.Size(); n++)

  00dcf	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00dd6	eb 09		 jmp	 SHORT $LN10@gObjSetSta
$LN8@gObjSetSta:
  00dd8	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00ddb	83 c0 01	 add	 eax, 1
  00dde	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN10@gObjSetSta:
  00de1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  00de6	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size
  00deb	39 45 f8	 cmp	 DWORD PTR _n$[ebp], eax
  00dee	7d 14		 jge	 SHORT $LN9@gObjSetSta

; 22491: 	{
; 22492: 		MapC[n].StateSetDestroy();

  00df0	69 4d f8 8c 04
	05 00		 imul	 ecx, DWORD PTR _n$[ebp], 328844
  00df7	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00dfd	e8 00 00 00 00	 call	 ?StateSetDestroy@MapClass@@QAEXXZ ; MapClass::StateSetDestroy

; 22493: 	}

  00e02	eb d4		 jmp	 SHORT $LN8@gObjSetSta
$LN9@gObjSetSta:

; 22494: }

  00e04	5f		 pop	 edi
  00e05	5e		 pop	 esi
  00e06	5b		 pop	 ebx
  00e07	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e0a	33 cd		 xor	 ecx, ebp
  00e0c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e11	8b e5		 mov	 esp, ebp
  00e13	5d		 pop	 ebp
  00e14	c3		 ret	 0
?gObjSetState@@YAXXZ ENDP				; gObjSetState
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjViewportListProtocol@@YAXF@Z
_TEXT	SEGMENT
tv486 = -20856						; size = 4
tv371 = -20856						; size = 4
tv487 = -20852						; size = 4
tv372 = -20852						; size = 4
tv262 = -20852						; size = 4
tv94 = -20852						; size = 4
$T1 = -20848						; size = 168
_pGUCount$2 = -20168					; size = 5
_pGVCount$3 = -20160					; size = 5
_pwCount$4 = -20152					; size = 5
_pwCount$5 = -20144					; size = 5
_pwCount$6 = -20136					; size = 5
_pwCount$7 = -20128					; size = 5
_pwCount$8 = -20120					; size = 5
_moneyl$9 = -20112					; size = 2
_moneyh$10 = -20108					; size = 2
_pMsg$11 = -20104					; size = 42
_pGVUMsg$12 = -20060					; size = 4
_ItemBuf$ = -20056					; size = 5000
_callMonstersendBuf$ = -15056				; size = 5000
_MonstersendBuf$ = -10056				; size = 5000
_sendBuf$ = -5056					; size = 5000
_callmonstercount$ = -55				; size = 1
_monstercount$ = -54					; size = 1
_count$ = -53						; size = 1
_tObjNum$ = -52						; size = 2
_pMsgSize$ = -48					; size = 4
_callMonlOfs$ = -44					; size = 4
_MonlOfs$ = -40						; size = 4
_lOfs$ = -36						; size = 4
_ItemStructSize$ = -32					; size = 4
_count_Item$ = -28					; size = 4
_lOfs_Item$ = -24					; size = 4
_lpObj$ = -20						; size = 4
_lpTargetObj$ = -16					; size = 4
_pCount$ = -12						; size = 4
_n$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 2
?gObjViewportListProtocol@@YAXF@Z PROC			; gObjViewportListProtocol, COMDAT

; 24229: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 78 51 00 00	 mov	 eax, 20856		; 00005178H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi

; 24230: 	int n;
; 24231: 	
; 24232: 	if( gObj[aIndex].Connected < 3 ) return;

  0001a	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0001e	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00024	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0002a	83 7c 0a 04 03	 cmp	 DWORD PTR [edx+ecx+4], 3
  0002f	7d 05		 jge	 SHORT $LN18@gObjViewpo
  00031	e9 b6 12 00 00	 jmp	 $LN1@gObjViewpo
$LN18@gObjViewpo:

; 24233: 
; 24234: 	PBMSG_COUNT				pCount;
; 24235: 	
; 24236: 	LPOBJECTSTRUCT			lpTargetObj;
; 24237: 	LPOBJECTSTRUCT			lpObj;
; 24238: 
; 24239: 	lpObj = &gObj[aIndex];

  00036	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0003a	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00040	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00046	89 4d ec	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 24240: 
; 24241: 	int	  lOfs_Item;
; 24242: 	int   count_Item;
; 24243: 
; 24244: 	int   ItemStructSize = sizeof(pItemViewportCreate);

  00049	c7 45 e0 09 00
	00 00		 mov	 DWORD PTR _ItemStructSize$[ebp], 9

; 24245: 	int   lOfs;
; 24246: 	int	  MonlOfs;
; 24247: 	int   callMonlOfs;
; 24248: 
; 24249: 	int   pMsgSize;
; 24250: 	short tObjNum;
; 24251: 	BYTE  count;
; 24252: 	BYTE  monstercount;
; 24253: 	BYTE  callmonstercount;
; 24254: 	BYTE  sendBuf[5000];
; 24255: 	BYTE  MonstersendBuf[5000];
; 24256: 	BYTE  callMonstersendBuf[5000];
; 24257: 	BYTE  ItemBuf[5000];
; 24258: 	
; 24259: 	GuildInfoOfs=0;

  00050	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GuildInfoOfs@@3HA, 0 ; GuildInfoOfs

; 24260: 	GuildInfoCount=0;

  0005a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GuildInfoCount@@3HA, 0 ; GuildInfoCount

; 24261: 	GuildUserOfs=0;

  00064	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GuildUserOfs@@3HA, 0 ; GuildUserOfs

; 24262: 	GuildUserCount=0;

  0006e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GuildUserCount@@3HA, 0 ; GuildUserCount

; 24263: 	ChangeCount=0;

  00078	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ChangeCount@@3HA, 0 ; ChangeCount

; 24264: 
; 24265: #ifdef MODIFY_GUILD_VIEWPORT_01_20040701
; 24266: 	GuildInfoOfs=sizeof(PMSG_SIMPLE_GUILDVIEWPORT_COUNT);
; 24267: #else
; 24268: 	GuildInfoOfs=sizeof(PMSG_GUILDVIEWPORT_COUNT);

  00082	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?GuildInfoOfs@@3HA, 5 ; GuildInfoOfs

; 24269: #endif
; 24270: 
; 24271: #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24272: 	int		iViewportSize = 0;
; 24273: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24274: 
; 24275: 	GuildUserOfs=sizeof(PMSG_GUILDVIEWPORT_USERCOUNT);

  0008c	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?GuildUserOfs@@3HA, 5 ; GuildUserOfs

; 24276: 
; 24277: 	lOfsChange=sizeof( PWMSG_COUNT );

  00096	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?lOfsChange@@3HA, 5 ; lOfsChange

; 24278: 
; 24279: 	//////////////////////////////////////////////////////////////////////////////
; 24280: 	//    .
; 24281: 	lOfs       = sizeof( PBMSG_COUNT );

  000a0	c7 45 dc 04 00
	00 00		 mov	 DWORD PTR _lOfs$[ebp], 4

; 24282: 	lOfs_Item  = sizeof( PWMSG_COUNT );

  000a7	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR _lOfs_Item$[ebp], 5

; 24283: 	count      = 0;

  000ae	c6 45 cb 00	 mov	 BYTE PTR _count$[ebp], 0

; 24284: 	count_Item = 0;

  000b2	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _count_Item$[ebp], 0

; 24285: 
; 24286: 	if( lpObj->Type == OBJTYPE_CHARACTER ) //  ..

  000b9	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bc	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  000c0	83 f9 01	 cmp	 ecx, 1
  000c3	0f 85 5f 01 00
	00		 jne	 $LN19@gObjViewpo

; 24287: 	{
; 24288: 		for( n=0; n<MAXVIEWPORTOBJECT; n++)

  000c9	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  000d0	eb 09		 jmp	 SHORT $LN4@gObjViewpo
$LN2@gObjViewpo:
  000d2	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000d5	83 c0 01	 add	 eax, 1
  000d8	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjViewpo:
  000db	83 7d f8 4b	 cmp	 DWORD PTR _n$[ebp], 75	; 0000004bH
  000df	0f 8d 41 01 00
	00		 jge	 $LN3@gObjViewpo

; 24289: 		{
; 24290: 			if( lpObj->VpPlayer[n].state == STVP_DESTROY ) 

  000e5	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ec	0f be 94 01 64
	03 00 00	 movsx	 edx, BYTE PTR [ecx+eax+868]
  000f4	83 fa 03	 cmp	 edx, 3
  000f7	0f 85 24 01 00
	00		 jne	 $LN21@gObjViewpo

; 24291: 			{
; 24292: 				tObjNum = lpObj->VpPlayer[n].number;

  000fd	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  00101	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00104	66 8b 94 01 66
	03 00 00	 mov	 dx, WORD PTR [ecx+eax+870]
  0010c	66 89 55 cc	 mov	 WORD PTR _tObjNum$[ebp], dx

; 24293: 				if( tObjNum >= 0 )

  00110	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00114	85 c0		 test	 eax, eax
  00116	0f 8c cf 00 00
	00		 jl	 $LN22@gObjViewpo

; 24294: 				{
; 24295: 					switch( lpObj->VpPlayer[n].type )

  0011c	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  00120	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00123	8a 94 01 68 03
	00 00		 mov	 dl, BYTE PTR [ecx+eax+872]
  0012a	88 95 8c ae ff
	ff		 mov	 BYTE PTR tv94[ebp], dl
  00130	80 bd 8c ae ff
	ff 00		 cmp	 BYTE PTR tv94[ebp], 0
  00137	0f 86 ae 00 00
	00		 jbe	 $LN22@gObjViewpo
  0013d	80 bd 8c ae ff
	ff 03		 cmp	 BYTE PTR tv94[ebp], 3
  00144	76 0e		 jbe	 SHORT $LN23@gObjViewpo
  00146	80 bd 8c ae ff
	ff 05		 cmp	 BYTE PTR tv94[ebp], 5
  0014d	74 51		 je	 SHORT $LN24@gObjViewpo
  0014f	e9 97 00 00 00	 jmp	 $LN22@gObjViewpo
$LN23@gObjViewpo:

; 24296: 					{
; 24297: 					case OBJTYPE_CHARACTER :
; 24298: 					case OBJTYPE_MONSTER :
; 24299: 					case OBJTYPE_NPC :
; 24300: 						pViewportDestroy.NumberH = HIBYTE(tObjNum);

  00154	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00158	c1 e8 08	 shr	 eax, 8
  0015b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00160	a2 00 00 00 00	 mov	 BYTE PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A, al

; 24301: 						pViewportDestroy.NumberL = LOBYTE(tObjNum);

  00165	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00169	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0016e	a2 01 00 00 00	 mov	 BYTE PTR ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A+1, al

; 24302: 						memcpy((sendBuf+lOfs), (char*)&pViewportDestroy, sizeof(PMSG_VIEWPORTDESTROY));

  00173	6a 02		 push	 2
  00175	68 00 00 00 00	 push	 OFFSET ?pViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A ; pViewportDestroy
  0017a	8b 45 dc	 mov	 eax, DWORD PTR _lOfs$[ebp]
  0017d	8d 8c 05 40 ec
	ff ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp+eax]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 _memcpy
  0018a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24303: 						lOfs += sizeof(PMSG_VIEWPORTDESTROY);

  0018d	8b 45 dc	 mov	 eax, DWORD PTR _lOfs$[ebp]
  00190	83 c0 02	 add	 eax, 2
  00193	89 45 dc	 mov	 DWORD PTR _lOfs$[ebp], eax

; 24304: 						count++;

  00196	8a 45 cb	 mov	 al, BYTE PTR _count$[ebp]
  00199	04 01		 add	 al, 1
  0019b	88 45 cb	 mov	 BYTE PTR _count$[ebp], al

; 24305: 						break;

  0019e	eb 4b		 jmp	 SHORT $LN22@gObjViewpo
$LN24@gObjViewpo:

; 24306: 					case OBJTYPE_ITEM :
; 24307: 						pItemViewportDestroy.NumberH = HIBYTE(tObjNum);

  001a0	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  001a4	c1 e8 08	 shr	 eax, 8
  001a7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001ac	a2 00 00 00 00	 mov	 BYTE PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A, al

; 24308: 						pItemViewportDestroy.NumberL = LOBYTE(tObjNum);

  001b1	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  001b5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001ba	a2 01 00 00 00	 mov	 BYTE PTR ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A+1, al

; 24309: 						memcpy((ItemBuf+lOfs_Item), (char*)&pItemViewportDestroy, sizeof(pItemViewportDestroy));

  001bf	6a 02		 push	 2
  001c1	68 00 00 00 00	 push	 OFFSET ?pItemViewportDestroy@@3UPMSG_VIEWPORTDESTROY@@A ; pItemViewportDestroy
  001c6	8b 45 e8	 mov	 eax, DWORD PTR _lOfs_Item$[ebp]
  001c9	8d 8c 05 a8 b1
	ff ff		 lea	 ecx, DWORD PTR _ItemBuf$[ebp+eax]
  001d0	51		 push	 ecx
  001d1	e8 00 00 00 00	 call	 _memcpy
  001d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24310: 						lOfs_Item += sizeof(PMSG_VIEWPORTDESTROY);

  001d9	8b 45 e8	 mov	 eax, DWORD PTR _lOfs_Item$[ebp]
  001dc	83 c0 02	 add	 eax, 2
  001df	89 45 e8	 mov	 DWORD PTR _lOfs_Item$[ebp], eax

; 24311: 						count_Item++;

  001e2	8b 45 e4	 mov	 eax, DWORD PTR _count_Item$[ebp]
  001e5	83 c0 01	 add	 eax, 1
  001e8	89 45 e4	 mov	 DWORD PTR _count_Item$[ebp], eax
$LN22@gObjViewpo:

; 24312: 						break;
; 24313: 					}				
; 24314: 				}
; 24315: 				lpObj->VpPlayer[n].state = STVP_NONE;

  001eb	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  001ef	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001f2	c6 84 01 64 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+868], 0

; 24316: 				lpObj->VpPlayer[n].number = -1;

  001fa	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  001fe	83 c9 ff	 or	 ecx, -1
  00201	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00204	66 89 8c 02 66
	03 00 00	 mov	 WORD PTR [edx+eax+870], cx

; 24317: 				lpObj->VPCount--;

  0020c	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0020f	8b 88 6c 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2668]
  00215	83 e9 01	 sub	 ecx, 1
  00218	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0021b	89 8a 6c 0a 00
	00		 mov	 DWORD PTR [edx+2668], ecx
$LN21@gObjViewpo:

; 24318: 			}
; 24319: 		}

  00221	e9 ac fe ff ff	 jmp	 $LN2@gObjViewpo
$LN3@gObjViewpo:

; 24320: 	}

  00226	eb 7c		 jmp	 SHORT $LN20@gObjViewpo
$LN19@gObjViewpo:

; 24321: 	else if( lpObj->Type == OBJTYPE_MONSTER || lpObj->Type ==  OBJTYPE_NPC)	//   NPC 

  00228	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0022b	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0022f	83 f9 02	 cmp	 ecx, 2
  00232	74 0c		 je	 SHORT $LN26@gObjViewpo
  00234	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00237	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0023b	83 f9 03	 cmp	 ecx, 3
  0023e	75 64		 jne	 SHORT $LN20@gObjViewpo
$LN26@gObjViewpo:

; 24322: 	{
; 24323: 		for( n=0; n<MAX_MONVIEWPORTOBJECT; n++)

  00240	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00247	eb 09		 jmp	 SHORT $LN9@gObjViewpo
$LN7@gObjViewpo:
  00249	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0024c	83 c0 01	 add	 eax, 1
  0024f	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN9@gObjViewpo:
  00252	83 7d f8 14	 cmp	 DWORD PTR _n$[ebp], 20	; 00000014H
  00256	7d 4c		 jge	 SHORT $LN20@gObjViewpo

; 24324: 		{
; 24325: 			if( lpObj->VpPlayer[n].state == STVP_DESTROY ) 

  00258	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  0025c	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0025f	0f be 94 01 64
	03 00 00	 movsx	 edx, BYTE PTR [ecx+eax+868]
  00267	83 fa 03	 cmp	 edx, 3
  0026a	75 36		 jne	 SHORT $LN27@gObjViewpo

; 24326: 			{
; 24327: 				lpObj->VpPlayer[n].state = STVP_NONE;

  0026c	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  00270	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00273	c6 84 01 64 03
	00 00 00	 mov	 BYTE PTR [ecx+eax+868], 0

; 24328: 				lpObj->VpPlayer[n].number = -1;

  0027b	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  0027f	83 c9 ff	 or	 ecx, -1
  00282	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00285	66 89 8c 02 66
	03 00 00	 mov	 WORD PTR [edx+eax+870], cx

; 24329: 				lpObj->VPCount--;

  0028d	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00290	8b 88 6c 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2668]
  00296	83 e9 01	 sub	 ecx, 1
  00299	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0029c	89 8a 6c 0a 00
	00		 mov	 DWORD PTR [edx+2668], ecx
$LN27@gObjViewpo:

; 24330: 			}
; 24331: 		}

  002a2	eb a5		 jmp	 SHORT $LN7@gObjViewpo
$LN20@gObjViewpo:

; 24332: 	}
; 24333: 
; 24334: 	if( lpObj->Type == OBJTYPE_CHARACTER )

  002a4	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a7	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  002ab	83 f9 01	 cmp	 ecx, 1
  002ae	0f 85 b0 00 00
	00		 jne	 $LN28@gObjViewpo

; 24335: 	{
; 24336: 		//  
; 24337: 		if( count > 0 )	

  002b4	0f b6 45 cb	 movzx	 eax, BYTE PTR _count$[ebp]
  002b8	85 c0		 test	 eax, eax
  002ba	7e 41		 jle	 SHORT $LN29@gObjViewpo

; 24338: 		{	
; 24339: 			pCount.h.c        = PMHC_BYTE;

  002bc	c6 45 f4 c1	 mov	 BYTE PTR _pCount$[ebp], 193 ; 000000c1H

; 24340: 			pCount.h.headcode = PMHC_VIEWPORTDESTROY;

  002c0	c6 45 f6 14	 mov	 BYTE PTR _pCount$[ebp+2], 20 ; 00000014H

; 24341: 			pCount.h.size     = lOfs;

  002c4	8a 45 dc	 mov	 al, BYTE PTR _lOfs$[ebp]
  002c7	88 45 f5	 mov	 BYTE PTR _pCount$[ebp+1], al

; 24342: 			pCount.count      = count;

  002ca	8a 45 cb	 mov	 al, BYTE PTR _count$[ebp]
  002cd	88 45 f7	 mov	 BYTE PTR _pCount$[ebp+3], al

; 24343: 			memcpy(sendBuf, (char*)&pCount, sizeof(PBMSG_COUNT));

  002d0	6a 04		 push	 4
  002d2	8d 45 f4	 lea	 eax, DWORD PTR _pCount$[ebp]
  002d5	50		 push	 eax
  002d6	8d 8d 40 ec ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  002dc	51		 push	 ecx
  002dd	e8 00 00 00 00	 call	 _memcpy
  002e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24344: 			DataSend(aIndex, sendBuf, lOfs);

  002e5	8b 45 dc	 mov	 eax, DWORD PTR _lOfs$[ebp]
  002e8	50		 push	 eax
  002e9	8d 8d 40 ec ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  002ef	51		 push	 ecx
  002f0	0f bf 55 08	 movsx	 edx, WORD PTR _aIndex$[ebp]
  002f4	52		 push	 edx
  002f5	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  002fa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN29@gObjViewpo:

; 24345: 		}
; 24346: 		//   
; 24347: 		if( count_Item > 0 )

  002fd	83 7d e4 00	 cmp	 DWORD PTR _count_Item$[ebp], 0
  00301	7e 61		 jle	 SHORT $LN28@gObjViewpo

; 24348: 		{		
; 24349: 			pItemCount.h.c        = PMHC_WORD;

  00303	c6 05 00 00 00
	00 c2		 mov	 BYTE PTR ?pItemCount@@3UPWMSG_COUNT@@A, 194 ; 000000c2H

; 24350: 			pItemCount.h.headcode = 0x21;

  0030a	c6 05 03 00 00
	00 21		 mov	 BYTE PTR ?pItemCount@@3UPWMSG_COUNT@@A+3, 33 ; 00000021H

; 24351: 			
; 24352: 			pItemCount.h.sizeH    = HIBYTE(lOfs_Item);

  00311	8b 45 e8	 mov	 eax, DWORD PTR _lOfs_Item$[ebp]
  00314	c1 e8 08	 shr	 eax, 8
  00317	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0031c	a2 01 00 00 00	 mov	 BYTE PTR ?pItemCount@@3UPWMSG_COUNT@@A+1, al

; 24353: 			pItemCount.h.sizeL    = LOBYTE(lOfs_Item);

  00321	8b 45 e8	 mov	 eax, DWORD PTR _lOfs_Item$[ebp]
  00324	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00329	a2 02 00 00 00	 mov	 BYTE PTR ?pItemCount@@3UPWMSG_COUNT@@A+2, al

; 24354: 			pItemCount.count      = count_Item;

  0032e	8a 45 e4	 mov	 al, BYTE PTR _count_Item$[ebp]
  00331	a2 04 00 00 00	 mov	 BYTE PTR ?pItemCount@@3UPWMSG_COUNT@@A+4, al

; 24355: 			memcpy(ItemBuf, (char*)&pItemCount, sizeof(pItemCount));

  00336	6a 05		 push	 5
  00338	68 00 00 00 00	 push	 OFFSET ?pItemCount@@3UPWMSG_COUNT@@A ; pItemCount
  0033d	8d 85 a8 b1 ff
	ff		 lea	 eax, DWORD PTR _ItemBuf$[ebp]
  00343	50		 push	 eax
  00344	e8 00 00 00 00	 call	 _memcpy
  00349	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24356: 			DataSend(aIndex, ItemBuf, lOfs_Item);

  0034c	8b 45 e8	 mov	 eax, DWORD PTR _lOfs_Item$[ebp]
  0034f	50		 push	 eax
  00350	8d 8d a8 b1 ff
	ff		 lea	 ecx, DWORD PTR _ItemBuf$[ebp]
  00356	51		 push	 ecx
  00357	0f bf 55 08	 movsx	 edx, WORD PTR _aIndex$[ebp]
  0035b	52		 push	 edx
  0035c	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00361	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN28@gObjViewpo:

; 24357: 		}	
; 24358: 	}
; 24359: 
; 24360: 	if( lpObj->Type == OBJTYPE_MONSTER || 

  00364	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00367	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0036b	83 f9 02	 cmp	 ecx, 2
  0036e	74 0c		 je	 SHORT $LN32@gObjViewpo
  00370	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00373	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00377	83 f9 03	 cmp	 ecx, 3
  0037a	75 42		 jne	 SHORT $LN31@gObjViewpo
$LN32@gObjViewpo:

; 24361: 		lpObj->Type == OBJTYPE_NPC)
; 24362: 	{
; 24363: 		for( n=0; n<MAX_MONVIEWPORTOBJECT; n++)

  0037c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00383	eb 09		 jmp	 SHORT $LN12@gObjViewpo
$LN10@gObjViewpo:
  00385	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00388	83 c0 01	 add	 eax, 1
  0038b	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN12@gObjViewpo:
  0038e	83 7d f8 14	 cmp	 DWORD PTR _n$[ebp], 20	; 00000014H
  00392	7d 25		 jge	 SHORT $LN11@gObjViewpo

; 24364: 		{
; 24365: 			if( lpObj->VpPlayer[n].state == STVP_CREATE ) 

  00394	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  00398	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0039b	0f be 94 01 64
	03 00 00	 movsx	 edx, BYTE PTR [ecx+eax+868]
  003a3	83 fa 01	 cmp	 edx, 1
  003a6	75 0f		 jne	 SHORT $LN33@gObjViewpo

; 24366: 			{
; 24367: 				lpObj->VpPlayer[n].state = STVP_PLAYING;

  003a8	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  003ac	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003af	c6 84 01 64 03
	00 00 02	 mov	 BYTE PTR [ecx+eax+868], 2
$LN33@gObjViewpo:

; 24368: 			}
; 24369: 		}

  003b7	eb cc		 jmp	 SHORT $LN10@gObjViewpo
$LN11@gObjViewpo:

; 24370: 		return;

  003b9	e9 2e 0f 00 00	 jmp	 $LN1@gObjViewpo
$LN31@gObjViewpo:

; 24371: 	}
; 24372: 
; 24373: 	//------------------------------------------------------------------------
; 24374: 	//  viewport    .
; 24375: 	//------------------------------------------------------------------------
; 24376: 	count        = 0;

  003be	c6 45 cb 00	 mov	 BYTE PTR _count$[ebp], 0

; 24377: 	monstercount = 0;

  003c2	c6 45 ca 00	 mov	 BYTE PTR _monstercount$[ebp], 0

; 24378: 	count_Item   = 0;

  003c6	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _count_Item$[ebp], 0

; 24379: 	callmonstercount = 0;

  003cd	c6 45 c9 00	 mov	 BYTE PTR _callmonstercount$[ebp], 0

; 24380: 	
; 24381: 	callMonlOfs = MonlOfs = lOfs  = sizeof( PWMSG_COUNT );

  003d1	c7 45 dc 05 00
	00 00		 mov	 DWORD PTR _lOfs$[ebp], 5
  003d8	8b 45 dc	 mov	 eax, DWORD PTR _lOfs$[ebp]
  003db	89 45 d8	 mov	 DWORD PTR _MonlOfs$[ebp], eax
  003de	8b 4d d8	 mov	 ecx, DWORD PTR _MonlOfs$[ebp]
  003e1	89 4d d4	 mov	 DWORD PTR _callMonlOfs$[ebp], ecx

; 24382: 	lOfs_Item		= sizeof( PWMSG_COUNT );

  003e4	c7 45 e8 05 00
	00 00		 mov	 DWORD PTR _lOfs_Item$[ebp], 5

; 24383: 	pMsgSize		= sizeof( PMSG_VIEWPORTCREATE );

  003eb	c7 45 d0 22 00
	00 00		 mov	 DWORD PTR _pMsgSize$[ebp], 34 ; 00000022H

; 24384: 
; 24385: 	if( lpObj->Type == OBJTYPE_CHARACTER )

  003f2	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003f5	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  003f9	83 f9 01	 cmp	 ecx, 1
  003fc	0f 85 cb 0b 00
	00		 jne	 $LN34@gObjViewpo

; 24386: 	{
; 24387: 
; 24388: #ifdef MODIFY_GUILD_VIEWPORT_01_20040701
; 24389: 		//  .
; 24390: #else
; 24391: 		ViewGuildMng.Init();

  00402	b9 00 00 00 00	 mov	 ecx, OFFSET ?ViewGuildMng@@3VCViewportGuild@@A ; ViewGuildMng
  00407	e8 00 00 00 00	 call	 ?Init@CViewportGuild@@QAEXXZ ; CViewportGuild::Init

; 24392: #endif
; 24393: 
; 24394: 		for( n=0; n<MAXVIEWPORTOBJECT; n++)

  0040c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00413	eb 09		 jmp	 SHORT $LN15@gObjViewpo
$LN13@gObjViewpo:
  00415	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00418	83 c0 01	 add	 eax, 1
  0041b	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN15@gObjViewpo:
  0041e	83 7d f8 4b	 cmp	 DWORD PTR _n$[ebp], 75	; 0000004bH
  00422	0f 8d a5 0b 00
	00		 jge	 $LN34@gObjViewpo

; 24395: 		{
; 24396: 			if( lpObj->VpPlayer[n].state == STVP_CREATE ) 

  00428	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  0042c	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0042f	0f be 94 01 64
	03 00 00	 movsx	 edx, BYTE PTR [ecx+eax+868]
  00437	83 fa 01	 cmp	 edx, 1
  0043a	0f 85 88 0b 00
	00		 jne	 $LN35@gObjViewpo

; 24397: 			{
; 24398: 				tObjNum = lpObj->VpPlayer[n].number;

  00440	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  00444	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00447	66 8b 94 01 66
	03 00 00	 mov	 dx, WORD PTR [ecx+eax+870]
  0044f	66 89 55 cc	 mov	 WORD PTR _tObjNum$[ebp], dx

; 24399: #ifdef FOR_KOREA	//      
; 24400: 				//if( gObj[tObjNum].Authority == AUTHORITY_ADMIN )
; 24401: 				//	continue;
; 24402: #endif
; 24403: 
; 24404: #ifdef FOR_CHINA	//      
; 24405: 				if( gObj[tObjNum].Authority == AUTHORITY_ADMIN )
; 24406: 					continue;
; 24407: #endif
; 24408: 
; 24409: #ifdef FOR_GLOBAL	//      
; 24410: 				if( gObj[tObjNum].Authority == AUTHORITY_ADMIN )
; 24411: 					continue;
; 24412: #endif
; 24413: 
; 24414: #ifdef FOR_USA		//      
; 24415: 				if( gObj[tObjNum].Authority == AUTHORITY_ADMIN )
; 24416: 					continue;
; 24417: #endif
; 24418: 
; 24419: #ifdef FOR_PHILIPPINE	// 
; 24420: 				if( gObj[tObjNum].Authority == AUTHORITY_ADMIN )
; 24421: 					continue;
; 24422: #endif
; 24423: 
; 24424: #ifdef FOR_VIETNAM		// 
; 24425: 				if( gObj[tObjNum].Authority == AUTHORITY_ADMIN )
; 24426: 					continue;
; 24427: #endif
; 24428: 
; 24429: #ifdef FOR_TAIWAN	//      
; 24430: 				if( gObj[tObjNum].Authority == AUTHORITY_ADMIN )
; 24431: 					continue;
; 24432: #endif
; 24433: 
; 24434: #ifdef UPDATE_GM_FUNCTION_20070228		// "/"   
; 24435: 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24436: 				if( ( ( gObj[tObjNum].Authority&AUTHORITY_EVENT_GM ) == AUTHORITY_EVENT_GM )
; 24437: 					&& gObjCheckUsedBuffEffect( &gObj[tObjNum], BUFFTYPE_INVISABLE ) == true 
; 24438: 				  )
; 24439: 				{
; 24440: 					continue;
; 24441: 				}
; 24442: 	#else
; 24443: 				if( ( (gObj[tObjNum].Authority&AUTHORITY_EVENT_GM) == AUTHORITY_EVENT_GM) 
; 24444: 					&&( (gObj[tObjNum].m_ViewSkillState&STATE_CLOAKING) == STATE_CLOAKING ) )
; 24445: 					continue;
; 24446: 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24447: #endif
; 24448: 
; 24449: #ifdef ADD_NEWPVP_PKFIELD
; 24450: 				if (g_NewPVP.IsObserver(gObj[tObjNum]))
; 24451: 					continue;
; 24452: #endif // ADD_NEWPVP_PKFIELD
; 24453: 
; 24454: 				if( tObjNum >= 0 )

  00453	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00457	85 c0		 test	 eax, eax
  00459	0f 8c 5a 0b 00
	00		 jl	 $LN36@gObjViewpo

; 24455: 				{
; 24456: 					switch( lpObj->VpPlayer[n].type )

  0045f	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  00463	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00466	0f b6 94 01 68
	03 00 00	 movzx	 edx, BYTE PTR [ecx+eax+872]
  0046e	89 95 8c ae ff
	ff		 mov	 DWORD PTR tv262[ebp], edx
  00474	8b 85 8c ae ff
	ff		 mov	 eax, DWORD PTR tv262[ebp]
  0047a	83 e8 01	 sub	 eax, 1
  0047d	89 85 8c ae ff
	ff		 mov	 DWORD PTR tv262[ebp], eax
  00483	83 bd 8c ae ff
	ff 04		 cmp	 DWORD PTR tv262[ebp], 4
  0048a	0f 87 29 0b 00
	00		 ja	 $LN36@gObjViewpo
  00490	8b 8d 8c ae ff
	ff		 mov	 ecx, DWORD PTR tv262[ebp]
  00496	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN87@gObjViewpo[ecx*4]
$LN37@gObjViewpo:

; 24457: 					{
; 24458: 					case OBJTYPE_CHARACTER :
; 24459: 						lpTargetObj = &gObj[tObjNum];

  0049d	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  004a1	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  004a7	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004ad	89 4d f0	 mov	 DWORD PTR _lpTargetObj$[ebp], ecx

; 24460: 						
; 24461: 						if( lpTargetObj->m_Change >= 0 )

  004b0	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  004b3	83 b8 a8 02 00
	00 00		 cmp	 DWORD PTR [eax+680], 0
  004ba	0f 8c 23 02 00
	00		 jl	 $LN38@gObjViewpo

; 24462: 						{
; 24463: 							pViewportCreateChange.NumberH	= HIBYTE(tObjNum);

  004c0	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  004c4	c1 e8 08	 shr	 eax, 8
  004c7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004cc	a2 00 00 00 00	 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A, al

; 24464: 							pViewportCreateChange.NumberL	= LOBYTE(tObjNum);

  004d1	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  004d5	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004da	a2 01 00 00 00	 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+1, al

; 24465: 
; 24466: #ifdef THIRD_CHANGEUP_SYSTEM_20070507	// 3  CharSet[0]  
; 24467: 							lpTargetObj->CharSet[0] &= 0xF8;
; 24468: #elif GAME_VERSION >= G_V_99B
; 24469: 							lpTargetObj->CharSet[0] &= 0xF0;

  004df	b8 01 00 00 00	 mov	 eax, 1
  004e4	6b c8 00	 imul	 ecx, eax, 0
  004e7	8b 55 f0	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  004ea	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  004f2	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  004f7	b9 01 00 00 00	 mov	 ecx, 1
  004fc	6b d1 00	 imul	 edx, ecx, 0
  004ff	8b 4d f0	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00502	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al

; 24470: #endif	// THIRD_CHANGEUP_SYSTEM_20070507
; 24471: 							if( lpTargetObj->m_State == OBJST_CREATE )

  00509	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0050c	83 b8 b8 01 00
	00 01		 cmp	 DWORD PTR [eax+440], 1
  00513	75 1f		 jne	 SHORT $LN40@gObjViewpo

; 24472: 							{
; 24473: 								if( !lpTargetObj->Teleport )

  00515	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00518	0f be 88 fc 01
	00 00		 movsx	 ecx, BYTE PTR [eax+508]
  0051f	85 c9		 test	 ecx, ecx
  00521	75 11		 jne	 SHORT $LN40@gObjViewpo

; 24474: 								{
; 24475: 									pViewportCreateChange.NumberH |= (0x01<<7);	//   ..

  00523	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A
  0052a	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  0052f	a2 00 00 00 00	 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A, al
$LN40@gObjViewpo:

; 24476: 								}
; 24477: 							}
; 24478: 							pViewportCreateChange.X			= (BYTE)lpTargetObj->X;

  00534	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00537	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  0053d	88 0d 02 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+2, cl

; 24479: 							pViewportCreateChange.Y			= (BYTE)lpTargetObj->Y;

  00543	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00546	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  0054c	88 0d 03 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+3, cl

; 24480: 							pViewportCreateChange.TX		= (BYTE)lpTargetObj->TX;

  00552	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00555	8a 88 20 01 00
	00		 mov	 cl, BYTE PTR [eax+288]
  0055b	88 0d 12 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+18, cl

; 24481: 							pViewportCreateChange.TY		= (BYTE)lpTargetObj->TY;

  00561	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00564	8a 88 22 01 00
	00		 mov	 cl, BYTE PTR [eax+290]
  0056a	88 0d 13 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+19, cl

; 24482: #ifdef ENHANCE_MONSTER_TYPE_TO_WORD_20040618
; 24483: 							pViewportCreateChange.SkinH		= HIBYTE(LOWORD(lpTargetObj->m_Change));

  00570	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00573	8b 88 a8 02 00
	00		 mov	 ecx, DWORD PTR [eax+680]
  00579	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0057f	0f b7 d1	 movzx	 edx, cx
  00582	c1 ea 08	 shr	 edx, 8
  00585	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0058b	88 15 04 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+4, dl

; 24484: 							pViewportCreateChange.SkinL		= LOBYTE(LOWORD(lpTargetObj->m_Change));

  00591	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00594	8b 88 a8 02 00
	00		 mov	 ecx, DWORD PTR [eax+680]
  0059a	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  005a0	0f b7 d1	 movzx	 edx, cx
  005a3	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  005a9	88 15 05 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+5, dl

; 24485: #else
; 24486: 							pViewportCreateChange.Skin		= lpTargetObj->m_Change;
; 24487: #endif
; 24488: 	
; 24489: #ifdef UPDATE_GM_FUNCTION_20070228
; 24490: 							if((lpTargetObj->Authority&AUTHORITY_EVENT_GM) == AUTHORITY_EVENT_GM)
; 24491: 							{
; 24492: 	#ifdef MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24493: 								gObjAddBuffEffect( lpTargetObj, BUFFTYPE_GM_MARK, 0, 0, 0, 0, BUFFTIME_INFINITE );
; 24494: 	#else
; 24495: 								pViewportCreate.ViewSkillState	|= STATE_ADD_GM_MARK;
; 24496: 								lpTargetObj->m_ViewSkillState	|= STATE_ADD_GM_MARK;
; 24497: 	#endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24498: 							}
; 24499: #endif
; 24500: 							
; 24501: #ifndef MODIFY_BUFF_SYSTEM_EXTENTION_20070917					// !! NOT
; 24502: 							pViewportCreateChange.ViewSkillState	= lpTargetObj->m_ViewSkillState;

  005af	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  005b2	66 8b 88 c0 01
	00 00		 mov	 cx, WORD PTR [eax+448]
  005b9	66 89 0d 06 00
	00 00		 mov	 WORD PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+6, cx

; 24503: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24504: 							pViewportCreateChange.DirAndPkLevel  = lpTargetObj->Dir<<4;

  005c0	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  005c3	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  005ca	c1 e1 04	 shl	 ecx, 4
  005cd	88 0d 14 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+20, cl

; 24505: 
; 24506: 							if(lpTargetObj->m_stateEngagePVP == PVP_USER_PLAYING && lpTargetObj->MapNumber != PVP_EVENT_MAP)

  005d3	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  005d6	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  005dd	75 1f		 jne	 SHORT $LN42@gObjViewpo
  005df	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  005e2	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  005e9	83 f9 09	 cmp	 ecx, 9
  005ec	74 10		 je	 SHORT $LN42@gObjViewpo

; 24507: 							{
; 24508: 								g_PvpEvent.DeleteUser(lpTargetObj->m_Index);

  005ee	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  005f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  005f3	51		 push	 ecx
  005f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PvpEvent@@3VCEngagePVP@@A ; g_PvpEvent
  005f9	e8 00 00 00 00	 call	 ?DeleteUser@CEngagePVP@@QAEXH@Z ; CEngagePVP::DeleteUser
$LN42@gObjViewpo:

; 24509: 							}
; 24510: 
; 24511: 							if(lpTargetObj->m_stateEngagePVP == PVP_USER_PLAYING)

  005fe	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00601	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  00608	75 11		 jne	 SHORT $LN43@gObjViewpo

; 24512: 								pViewportCreateChange.DirAndPkLevel |= ((PK_LEVEL_DEFAULT+3)&0x0F);

  0060a	0f b6 05 14 00
	00 00		 movzx	 eax, BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+20
  00611	83 c8 06	 or	 eax, 6
  00614	a2 14 00 00 00	 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+20, al
  00619	eb 1c		 jmp	 SHORT $LN44@gObjViewpo
$LN43@gObjViewpo:

; 24513: 							else
; 24514: 								pViewportCreateChange.DirAndPkLevel |= (lpTargetObj->m_PK_Level&0x0F);

  0061b	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0061e	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  00625	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00628	0f b6 15 14 00
	00 00		 movzx	 edx, BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+20
  0062f	0b d1		 or	 edx, ecx
  00631	88 15 14 00 00
	00		 mov	 BYTE PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+20, dl
$LN44@gObjViewpo:

; 24515: 
; 24516: #ifdef THIRD_CHANGEUP_SYSTEM_20070507	// 3  m_ViewState 
; 24517: 							lpObj->CharSet[0] &= 0xF8;						// 3   
; 24518: 							lpObj->CharSet[0] |= (lpObj->m_ViewState&0x07);	// m_ViewState  3bit .
; 24519: #else
; 24520: #ifdef UPDATE_VIEWPORTCREATE_CHANGE_ADD_CHARSET_20070314
; 24521: 							lpObj->CharSet[0] &= 0xF0;
; 24522: 							lpObj->CharSet[0] |= (lpObj->m_ViewState&0x0F);
; 24523: #endif
; 24524: #endif	// THIRD_CHANGEUP_SYSTEM_20070507
; 24525: 
; 24526: #ifndef MODIFY_BUFF_SYSTEM_EXTENTION_20070917			// !! NOT
; 24527: 	#ifdef CHAOSCASTLE_SYSTEM_20040408		// !!> .          .
; 24528: 							if (CHECK_CHAOSCASTLE(lpTargetObj->MapNumber))

  00637	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0063a	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00641	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00644	7d 0c		 jge	 SHORT $LN81@gObjViewpo
  00646	c7 85 8c ae ff
	ff 00 00 00 00	 mov	 DWORD PTR tv372[ebp], 0
  00650	eb 31		 jmp	 SHORT $LN82@gObjViewpo
$LN81@gObjViewpo:
  00652	8b 55 f0	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00655	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0065c	83 f8 17	 cmp	 eax, 23			; 00000017H
  0065f	7e 0c		 jle	 SHORT $LN79@gObjViewpo
  00661	c7 85 88 ae ff
	ff 00 00 00 00	 mov	 DWORD PTR tv371[ebp], 0
  0066b	eb 0a		 jmp	 SHORT $LN80@gObjViewpo
$LN79@gObjViewpo:
  0066d	c7 85 88 ae ff
	ff 01 00 00 00	 mov	 DWORD PTR tv371[ebp], 1
$LN80@gObjViewpo:
  00677	8b 8d 88 ae ff
	ff		 mov	 ecx, DWORD PTR tv371[ebp]
  0067d	89 8d 8c ae ff
	ff		 mov	 DWORD PTR tv372[ebp], ecx
$LN82@gObjViewpo:
  00683	83 bd 8c ae ff
	ff 00		 cmp	 DWORD PTR tv372[ebp], 0
  0068a	74 08		 je	 SHORT $LN45@gObjViewpo

; 24529: 							{
; 24530: //								pViewportCreateChange.ViewSkillState &= ~STATE_REDUCE_MAGICDEFENSE;		// 
; 24531: //								pViewportCreateChange.ViewSkillState &= ~STATE_ADD_LIFE;				// 
; 24532: //								pViewportCreateChange.ViewSkillState &= ~STATE_ATTACK;					// 
; 24533: //								pViewportCreateChange.ViewSkillState &= ~STATE_DEFENSE;					// 
; 24534: 								pViewportCreateChange.ViewSkillState = 0;

  0068c	33 c0		 xor	 eax, eax
  0068e	66 a3 06 00 00
	00		 mov	 WORD PTR ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+6, ax
$LN45@gObjViewpo:

; 24535: 							}
; 24536: 	#endif
; 24537: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24538: 
; 24539: 
; 24540: #ifdef MODIFY_CASTLESIEGE_VIEWPORT_BY_CANGE_RING_20051103
; 24541: #ifdef MU_CASTLESIEGE_JOINSIDE_VIEWPORT_20041209
; 24542: 	#ifndef MODIFY_BUFFSYSTEM_BUGFIX_02_20071204					// !! NOT
; 24543: 							if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE) 
; 24544: 							{
; 24545: 								BYTE btCsJoinSide							= lpTargetObj->m_btCsJoinSide;
; 24546: 								if (btCsJoinSide < CS_SIEGESIDE_NONE)		btCsJoinSide	= CS_SIEGESIDE_NONE;
; 24547: 								if (btCsJoinSide > CS_SIEGESIDE_ATTACK)		btCsJoinSide	= CS_SIEGESIDE_ATTACK;
; 24548: 
; 24549: 								switch(btCsJoinSide) 
; 24550: 								{
; 24551: 								case CS_SIEGESIDE_DEFEND :
; 24552: 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24553: 									gObjAddBuffEffect( lpTargetObj, BUFFTYPE_CASTLE_DEFENSE_MARK, 0, 0, 0, 0, BUFFTIME_INFINITE );
; 24554: 	#else
; 24555: 									pViewportCreate.ViewSkillState	|= STATE_JOIN_SIDE_DEFEND;
; 24556: 									lpTargetObj->m_ViewSkillState	|= STATE_JOIN_SIDE_DEFEND;
; 24557: 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24558: 									break;
; 24559: 								case CS_SIEGESIDE_ATTACK :
; 24560: 		
; 24561: 	#ifdef MODIFY_CASTLESIEGE_IDENTIFICATION_20051012
; 24562: 									{
; 24563: 		#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24564: 										if( lpTargetObj->m_btCsJoinSide == CS_SIEGESIDE_ATTACK )
; 24565: 										{
; 24566: 											gObjAddBuffEffect( lpTargetObj, BUFFTYPE_CASTLE_ATTACK_MARK, 0, 0, 0, 0, BUFFTIME_INFINITE );
; 24567: 										}
; 24568: 										else if( lpTargetObj->m_btCsJoinSide == CS_SIEGESIDE_ATTACK_2 )
; 24569: 										{
; 24570: 											gObjAddBuffEffect( lpTargetObj, BUFFTYPE_CASTLE_ATTACK_MARK_2, 0, 0, 0, 0, BUFFTIME_INFINITE );
; 24571: 										}
; 24572: 										else if( lpTargetObj->m_btCsJoinSide == CS_SIEGESIDE_ATTACK_3 )
; 24573: 										{
; 24574: 											gObjAddBuffEffect( lpTargetObj, BUFFTYPE_CASTLE_ATTACK_MARK_3, 0, 0, 0, 0, BUFFTIME_INFINITE );
; 24575: 										}
; 24576: 		#else
; 24577: 										DWORD btCSMarkViewSkillState = 0;
; 24578: 										if( lpTargetObj->m_btCsJoinSide == CS_SIEGESIDE_ATTACK )
; 24579: 										{
; 24580: 											btCSMarkViewSkillState = STATE_JOIN_SIDE_ATTACK;
; 24581: 										}
; 24582: 										else if( lpTargetObj->m_btCsJoinSide == CS_SIEGESIDE_ATTACK_2 )
; 24583: 										{
; 24584: 											btCSMarkViewSkillState = STATE_JOIN_SIDE_ATTACK_2;
; 24585: 										}
; 24586: 										else if( lpTargetObj->m_btCsJoinSide == CS_SIEGESIDE_ATTACK_3 )
; 24587: 										{
; 24588: 											btCSMarkViewSkillState = STATE_JOIN_SIDE_ATTACK_3;
; 24589: 										}
; 24590: 
; 24591: 										pViewportCreate.ViewSkillState	|= btCSMarkViewSkillState;
; 24592: 										lpTargetObj->m_ViewSkillState	|= btCSMarkViewSkillState;
; 24593: 		#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24594: 									}
; 24595: 	#else
; 24596: 									pViewportCreate.ViewSkillState	|= STATE_JOIN_SIDE_ATTACK;
; 24597: 									lpTargetObj->m_ViewSkillState	|= STATE_JOIN_SIDE_DEFEND;
; 24598: 	#endif
; 24599: 									break;
; 24600: 								case CS_SIEGESIDE_NONE :
; 24601: 								default :
; 24602: 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24603: 									gObjClearBuffEffect( lpTargetObj, CLEAR_TYPE_CASTLESIEGE );
; 24604: 	#else
; 24605: 									pViewportCreate.ViewSkillState	&= ~(STATE_JOIN_SIDE_DEFEND | STATE_JOIN_SIDE_ATTACK);
; 24606: 									lpTargetObj->m_ViewSkillState	&= ~(STATE_JOIN_SIDE_DEFEND | STATE_JOIN_SIDE_ATTACK);
; 24607: 		#ifdef MODIFY_CASTLESIEGE_IDENTIFICATION_20051012
; 24608: 									pViewportCreate.ViewSkillState	&= ~(STATE_JOIN_SIDE_ATTACK_2 | STATE_JOIN_SIDE_ATTACK_3);
; 24609: 									lpTargetObj->m_ViewSkillState	&= ~(STATE_JOIN_SIDE_ATTACK_2 | STATE_JOIN_SIDE_ATTACK_3);
; 24610: 		#endif
; 24611: 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24612: 									break;
; 24613: 								}
; 24614: 							}
; 24615: 	#endif // MODIFY_BUFFSYSTEM_BUGFIX_02_20071204
; 24616: #endif // MU_CASTLESIEGE_JOINSIDE_VIEWPORT_20041209
; 24617: #endif // MODIFY_CASTLESIEGE_VIEWPORT_BY_CANGE_RING_20051103
; 24618: 
; 24619: #ifdef UPDATE_VIEWPORTCREATE_CHANGE_ADD_CHARSET_20070314	// gObjViewportListProtocolCreate()    
; 24620: 							memcpy(&pViewportCreateChange.CharSet, lpTargetObj->CharSet, MAX_PREVIEWCHARSET+9);
; 24621: #endif
; 24622: 							memcpy(pViewportCreateChange.Id, lpTargetObj->Name, MAX_IDSTRING);

  00694	6a 0a		 push	 10			; 0000000aH
  00696	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00699	83 c0 73	 add	 eax, 115		; 00000073H
  0069c	50		 push	 eax
  0069d	68 08 00 00 00	 push	 OFFSET ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A+8
  006a2	e8 00 00 00 00	 call	 _memcpy
  006a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24623: #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24624: 							iViewportSize = gObjMakeViewportState( lpTargetObj, pViewportCreateChange.BuffEffectList );
; 24625: 							pViewportCreateChange.BuffEffectCount = iViewportSize;
; 24626: 							memcpy((SendGBufChange+lOfsChange), (char*)&pViewportCreateChange, sizeof(PMSG_VIEWPORTCREATE_CHANGE) );
; 24627: 							lOfsChange += ( sizeof(PMSG_VIEWPORTCREATE_CHANGE) - ( MAX_BUFF_SLOT_INDEX - iViewportSize ) );
; 24628: #else
; 24629: 							memcpy((SendGBufChange+lOfsChange), (char*)&pViewportCreateChange, sizeof(PMSG_VIEWPORTCREATE_CHANGE));

  006aa	6a 16		 push	 22			; 00000016H
  006ac	68 00 00 00 00	 push	 OFFSET ?pViewportCreateChange@@3UPMSG_VIEWPORTCREATE_CHANGE@@A ; pViewportCreateChange
  006b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lOfsChange@@3HA ; lOfsChange
  006b6	05 00 00 00 00	 add	 eax, OFFSET ?SendGBufChange@@3PAEA ; SendGBufChange
  006bb	50		 push	 eax
  006bc	e8 00 00 00 00	 call	 _memcpy
  006c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24630: 							lOfsChange += sizeof(PMSG_VIEWPORTCREATE_CHANGE);

  006c4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lOfsChange@@3HA ; lOfsChange
  006c9	83 c0 16	 add	 eax, 22			; 00000016H
  006cc	a3 00 00 00 00	 mov	 DWORD PTR ?lOfsChange@@3HA, eax ; lOfsChange

; 24631: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24632: 							ChangeCount++;

  006d1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ChangeCount@@3HA ; ChangeCount
  006d6	83 c0 01	 add	 eax, 1
  006d9	a3 00 00 00 00	 mov	 DWORD PTR ?ChangeCount@@3HA, eax ; ChangeCount

; 24633: 						}

  006de	e9 22 02 00 00	 jmp	 $LN39@gObjViewpo
$LN38@gObjViewpo:

; 24634: 						else
; 24635: 						{
; 24636: 							pViewportCreate.NumberH = HIBYTE(tObjNum);

  006e3	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  006e7	c1 e8 08	 shr	 eax, 8
  006ea	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006ef	a2 00 00 00 00	 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A, al

; 24637: 							pViewportCreate.NumberL = LOBYTE(tObjNum);

  006f4	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  006f8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006fd	a2 01 00 00 00	 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+1, al

; 24638: 							
; 24639: #ifdef THIRD_CHANGEUP_SYSTEM_20070507	// CharSet[0] 3   
; 24640: 							lpTargetObj->CharSet[0] &= 0xF8;
; 24641: #elif GAME_VERSION >= G_V_99B
; 24642: 							lpTargetObj->CharSet[0] &= 0xF0;

  00702	b8 01 00 00 00	 mov	 eax, 1
  00707	6b c8 00	 imul	 ecx, eax, 0
  0070a	8b 55 f0	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  0070d	0f b6 84 0a 28
	03 00 00	 movzx	 eax, BYTE PTR [edx+ecx+808]
  00715	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0071a	b9 01 00 00 00	 mov	 ecx, 1
  0071f	6b d1 00	 imul	 edx, ecx, 0
  00722	8b 4d f0	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00725	88 84 11 28 03
	00 00		 mov	 BYTE PTR [ecx+edx+808], al

; 24643: #endif	// THIRD_CHANGEUP_SYSTEM_20070507
; 24644: 							if( lpTargetObj->m_State == OBJST_CREATE )

  0072c	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0072f	83 b8 b8 01 00
	00 01		 cmp	 DWORD PTR [eax+440], 1
  00736	75 1f		 jne	 SHORT $LN46@gObjViewpo

; 24645: 							{
; 24646: 								if( !lpTargetObj->Teleport )

  00738	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0073b	0f be 88 fc 01
	00 00		 movsx	 ecx, BYTE PTR [eax+508]
  00742	85 c9		 test	 ecx, ecx
  00744	75 11		 jne	 SHORT $LN46@gObjViewpo

; 24647: 								{
; 24648: 									pViewportCreate.NumberH |= (0x01<<7);	//   ..

  00746	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A
  0074d	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  00752	a2 00 00 00 00	 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A, al
$LN46@gObjViewpo:

; 24649: 								}
; 24650: 							}
; 24651: 
; 24652: #ifndef MODIFY_BUFF_SYSTEM_EXTENTION_20070917					// !! NOT
; 24653: 							pViewportCreate.ViewSkillState = lpTargetObj->m_ViewSkillState;

  00757	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0075a	66 8b 88 c0 01
	00 00		 mov	 cx, WORD PTR [eax+448]
  00761	66 89 0d 12 00
	00 00		 mov	 WORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+18, cx

; 24654: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24655: 							lpTargetObj->CharSet[0] |= (lpTargetObj->m_ViewState&0x0F);

  00768	b8 01 00 00 00	 mov	 eax, 1
  0076d	6b c8 00	 imul	 ecx, eax, 0
  00770	8b 55 f0	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00773	0f be 82 be 01
	00 00		 movsx	 eax, BYTE PTR [edx+446]
  0077a	83 e0 0f	 and	 eax, 15			; 0000000fH
  0077d	8b 55 f0	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00780	0f b6 8c 0a 28
	03 00 00	 movzx	 ecx, BYTE PTR [edx+ecx+808]
  00788	0b c8		 or	 ecx, eax
  0078a	ba 01 00 00 00	 mov	 edx, 1
  0078f	6b c2 00	 imul	 eax, edx, 0
  00792	8b 55 f0	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00795	88 8c 02 28 03
	00 00		 mov	 BYTE PTR [edx+eax+808], cl

; 24656: 							pViewportCreate.X       = (BYTE)lpTargetObj->X;

  0079c	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0079f	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  007a5	88 0d 02 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+2, cl

; 24657: 							pViewportCreate.Y       = (BYTE)lpTargetObj->Y;

  007ab	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  007ae	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  007b4	88 0d 03 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+3, cl

; 24658: 							pViewportCreate.TX		= (BYTE)lpTargetObj->TX;

  007ba	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  007bd	8a 88 20 01 00
	00		 mov	 cl, BYTE PTR [eax+288]
  007c3	88 0d 1e 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+30, cl

; 24659: 							pViewportCreate.TY		= (BYTE)lpTargetObj->TY;

  007c9	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  007cc	8a 88 22 01 00
	00		 mov	 cl, BYTE PTR [eax+290]
  007d2	88 0d 1f 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+31, cl

; 24660: 							pViewportCreate.DirAndPkLevel = lpTargetObj->Dir<<4;

  007d8	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  007db	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  007e2	c1 e1 04	 shl	 ecx, 4
  007e5	88 0d 20 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+32, cl

; 24661: 
; 24662: 							if(lpTargetObj->m_stateEngagePVP == PVP_USER_PLAYING && lpTargetObj->MapNumber != PVP_EVENT_MAP)

  007eb	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  007ee	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  007f5	75 1f		 jne	 SHORT $LN48@gObjViewpo
  007f7	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  007fa	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00801	83 f9 09	 cmp	 ecx, 9
  00804	74 10		 je	 SHORT $LN48@gObjViewpo

; 24663: 							{
; 24664: 								g_PvpEvent.DeleteUser(lpTargetObj->m_Index);

  00806	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00809	8b 08		 mov	 ecx, DWORD PTR [eax]
  0080b	51		 push	 ecx
  0080c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PvpEvent@@3VCEngagePVP@@A ; g_PvpEvent
  00811	e8 00 00 00 00	 call	 ?DeleteUser@CEngagePVP@@QAEXH@Z ; CEngagePVP::DeleteUser
$LN48@gObjViewpo:

; 24665: 							}
; 24666: 
; 24667: 							if(lpTargetObj->m_stateEngagePVP == PVP_USER_PLAYING)

  00816	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00819	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  00820	75 11		 jne	 SHORT $LN49@gObjViewpo

; 24668: 								pViewportCreate.DirAndPkLevel |= ((PK_LEVEL_DEFAULT+3)&0x0F);

  00822	0f b6 05 20 00
	00 00		 movzx	 eax, BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+32
  00829	83 c8 06	 or	 eax, 6
  0082c	a2 20 00 00 00	 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+32, al
  00831	eb 1c		 jmp	 SHORT $LN50@gObjViewpo
$LN49@gObjViewpo:

; 24669: 							else
; 24670: 								pViewportCreate.DirAndPkLevel |= (lpTargetObj->m_PK_Level&0x0F);

  00833	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00836	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  0083d	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00840	0f b6 15 20 00
	00 00		 movzx	 edx, BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+32
  00847	0b d1		 or	 edx, ecx
  00849	88 15 20 00 00
	00		 mov	 BYTE PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+32, dl
$LN50@gObjViewpo:

; 24671: 
; 24672: #ifndef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004			// !! NOT
; 24673: 	#ifdef CHAOSCASTLE_SYSTEM_20040408		// !!> .          .
; 24674: 							if (CHECK_CHAOSCASTLE(lpTargetObj->MapNumber)) {

  0084f	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00852	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00859	83 f9 12	 cmp	 ecx, 18			; 00000012H
  0085c	7d 0c		 jge	 SHORT $LN85@gObjViewpo
  0085e	c7 85 8c ae ff
	ff 00 00 00 00	 mov	 DWORD PTR tv487[ebp], 0
  00868	eb 31		 jmp	 SHORT $LN86@gObjViewpo
$LN85@gObjViewpo:
  0086a	8b 55 f0	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  0086d	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00874	83 f8 17	 cmp	 eax, 23			; 00000017H
  00877	7e 0c		 jle	 SHORT $LN83@gObjViewpo
  00879	c7 85 88 ae ff
	ff 00 00 00 00	 mov	 DWORD PTR tv486[ebp], 0
  00883	eb 0a		 jmp	 SHORT $LN84@gObjViewpo
$LN83@gObjViewpo:
  00885	c7 85 88 ae ff
	ff 01 00 00 00	 mov	 DWORD PTR tv486[ebp], 1
$LN84@gObjViewpo:
  0088f	8b 8d 88 ae ff
	ff		 mov	 ecx, DWORD PTR tv486[ebp]
  00895	89 8d 8c ae ff
	ff		 mov	 DWORD PTR tv487[ebp], ecx
$LN86@gObjViewpo:
  0089b	83 bd 8c ae ff
	ff 00		 cmp	 DWORD PTR tv487[ebp], 0
  008a2	74 08		 je	 SHORT $LN51@gObjViewpo

; 24675: //								pViewportCreateChange.ViewSkillState &= ~STATE_REDUCE_MAGICDEFENSE;		// 
; 24676: //								pViewportCreateChange.ViewSkillState &= ~STATE_ADD_LIFE;				// 
; 24677: //								pViewportCreateChange.ViewSkillState &= ~STATE_ATTACK;					// 
; 24678: //								pViewportCreateChange.ViewSkillState &= ~STATE_DEFENSE;					// 
; 24679: 								pViewportCreate.ViewSkillState = 0;

  008a4	33 c0		 xor	 eax, eax
  008a6	66 a3 12 00 00
	00		 mov	 WORD PTR ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+18, ax
$LN51@gObjViewpo:

; 24680: 							}
; 24681: 	#endif
; 24682: #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24683: 
; 24684: #ifdef MU_CASTLESIEGE_JOINSIDE_VIEWPORT_20041209	//        .
; 24685: 	#ifndef MODIFY_BUFFSYSTEM_BUGFIX_02_20071204					// !! NOT
; 24686: 							if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE) 
; 24687: 							{
; 24688: 								BYTE btCsJoinSide							= lpTargetObj->m_btCsJoinSide;
; 24689: 								if (btCsJoinSide < CS_SIEGESIDE_NONE)		btCsJoinSide	= CS_SIEGESIDE_NONE;
; 24690: 								if (btCsJoinSide > CS_SIEGESIDE_ATTACK)		btCsJoinSide	= CS_SIEGESIDE_ATTACK;
; 24691: 
; 24692: 								switch(btCsJoinSide) 
; 24693: 								{
; 24694: 								case CS_SIEGESIDE_DEFEND :
; 24695: 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24696: 									gObjAddBuffEffect( lpTargetObj, BUFFTYPE_CASTLE_DEFENSE_MARK, 0, 0, 0, 0, BUFFTIME_INFINITE );
; 24697: 	#else
; 24698: 									pViewportCreate.ViewSkillState	|= STATE_JOIN_SIDE_DEFEND;
; 24699: 									lpTargetObj->m_ViewSkillState	|= STATE_JOIN_SIDE_DEFEND;
; 24700: 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24701: 									break;
; 24702: 								case CS_SIEGESIDE_ATTACK :
; 24703: 		
; 24704: 	#ifdef MODIFY_CASTLESIEGE_IDENTIFICATION_20051012
; 24705: 									{
; 24706: 		#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24707: 										if( lpTargetObj->m_btCsJoinSide == CS_SIEGESIDE_ATTACK )
; 24708: 										{
; 24709: 											gObjAddBuffEffect( lpTargetObj, BUFFTYPE_CASTLE_ATTACK_MARK, 0, 0, 0, 0, BUFFTIME_INFINITE );
; 24710: 										}
; 24711: 										else if( lpTargetObj->m_btCsJoinSide == CS_SIEGESIDE_ATTACK_2 )
; 24712: 										{
; 24713: 											gObjAddBuffEffect( lpTargetObj, BUFFTYPE_CASTLE_ATTACK_MARK_2, 0, 0, 0, 0, BUFFTIME_INFINITE );
; 24714: 										}
; 24715: 										else if( lpTargetObj->m_btCsJoinSide == CS_SIEGESIDE_ATTACK_3 )
; 24716: 										{
; 24717: 											gObjAddBuffEffect( lpTargetObj, BUFFTYPE_CASTLE_ATTACK_MARK_3, 0, 0, 0, 0, BUFFTIME_INFINITE );
; 24718: 										}
; 24719: 		#else
; 24720: 										DWORD btCSMarkViewSkillState = 0;
; 24721: 										if( lpTargetObj->m_btCsJoinSide == CS_SIEGESIDE_ATTACK )
; 24722: 										{
; 24723: 											btCSMarkViewSkillState = STATE_JOIN_SIDE_ATTACK;
; 24724: 										}
; 24725: 										else if( lpTargetObj->m_btCsJoinSide == CS_SIEGESIDE_ATTACK_2 )
; 24726: 										{
; 24727: 											btCSMarkViewSkillState = STATE_JOIN_SIDE_ATTACK_2;
; 24728: 										}
; 24729: 										else if( lpTargetObj->m_btCsJoinSide == CS_SIEGESIDE_ATTACK_3 )
; 24730: 										{
; 24731: 											btCSMarkViewSkillState = STATE_JOIN_SIDE_ATTACK_3;
; 24732: 										}
; 24733: 										
; 24734: 										pViewportCreate.ViewSkillState	|= btCSMarkViewSkillState;
; 24735: 										lpTargetObj->m_ViewSkillState	|= btCSMarkViewSkillState;
; 24736: 		#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24737: 									}
; 24738: 	#else
; 24739: 									pViewportCreate.ViewSkillState	|= STATE_JOIN_SIDE_ATTACK;
; 24740: 									lpTargetObj->m_ViewSkillState	|= STATE_JOIN_SIDE_DEFEND;
; 24741: 	#endif
; 24742: 									break;
; 24743: 								case CS_SIEGESIDE_NONE :
; 24744: 								default :
; 24745: 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24746: 									gObjClearBuffEffect( lpTargetObj, CLEAR_TYPE_CASTLESIEGE );
; 24747: 	#else
; 24748: 									pViewportCreate.ViewSkillState	&= ~(STATE_JOIN_SIDE_DEFEND | STATE_JOIN_SIDE_ATTACK);
; 24749: 									lpTargetObj->m_ViewSkillState	&= ~(STATE_JOIN_SIDE_DEFEND | STATE_JOIN_SIDE_ATTACK);
; 24750: 		#ifdef MODIFY_CASTLESIEGE_IDENTIFICATION_20051012
; 24751: 									pViewportCreate.ViewSkillState	&= ~(STATE_JOIN_SIDE_ATTACK_2 | STATE_JOIN_SIDE_ATTACK_3);
; 24752: 									lpTargetObj->m_ViewSkillState	&= ~(STATE_JOIN_SIDE_ATTACK_2 | STATE_JOIN_SIDE_ATTACK_3);
; 24753: 		#endif
; 24754: 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 24755: 									break;
; 24756: 								}
; 24757: 							}
; 24758: 	#endif // MODIFY_BUFFSYSTEM_BUGFIX_02_20071204
; 24759: #endif
; 24760: 
; 24761: #ifdef ITEM_INDEX_EXTEND_20050706
; 24762: 							memcpy(&pViewportCreate.CharSet, lpTargetObj->CharSet, MAX_PREVIEWCHARSET+9);
; 24763: #else
; 24764: #ifdef DARKLORD_WORK
; 24765: 							memcpy(&pViewportCreate.CharSet, lpTargetObj->CharSet, MAX_PREVIEWCHARSET+4);

  008ac	6a 0d		 push	 13			; 0000000dH
  008ae	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  008b1	05 28 03 00 00	 add	 eax, 808		; 00000328H
  008b6	50		 push	 eax
  008b7	68 04 00 00 00	 push	 OFFSET ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+4
  008bc	e8 00 00 00 00	 call	 _memcpy
  008c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24766: #else
; 24767: 							memcpy(&pViewportCreate.CharSet, lpTargetObj->CharSet, MAX_PREVIEWCHARSET+3);
; 24768: #endif
; 24769: #endif
; 24770: 							
; 24771: 							memcpy(pViewportCreate.Id, lpTargetObj->Name, MAX_IDSTRING);

  008c4	6a 0a		 push	 10			; 0000000aH
  008c6	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  008c9	83 c0 73	 add	 eax, 115		; 00000073H
  008cc	50		 push	 eax
  008cd	68 14 00 00 00	 push	 OFFSET ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A+20
  008d2	e8 00 00 00 00	 call	 _memcpy
  008d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24772: #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24773: 							iViewportSize = gObjMakeViewportState( lpTargetObj, pViewportCreate.BuffEffectList );
; 24774: 							pViewportCreate.BuffEffectCount = iViewportSize;
; 24775: 							memcpy((sendBuf+lOfs), (char*)&pViewportCreate, sizeof(PMSG_VIEWPORTCREATE) );
; 24776: 							lOfs += ( sizeof(PMSG_VIEWPORTCREATE) - ( MAX_BUFF_SLOT_INDEX - iViewportSize ) );
; 24777: #else
; 24778: 							memcpy((sendBuf+lOfs), (char*)&pViewportCreate, sizeof(PMSG_VIEWPORTCREATE));

  008da	6a 22		 push	 34			; 00000022H
  008dc	68 00 00 00 00	 push	 OFFSET ?pViewportCreate@@3UPMSG_VIEWPORTCREATE@@A ; pViewportCreate
  008e1	8b 45 dc	 mov	 eax, DWORD PTR _lOfs$[ebp]
  008e4	8d 8c 05 40 ec
	ff ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp+eax]
  008eb	51		 push	 ecx
  008ec	e8 00 00 00 00	 call	 _memcpy
  008f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24779: 							lOfs += sizeof(PMSG_VIEWPORTCREATE);

  008f4	8b 45 dc	 mov	 eax, DWORD PTR _lOfs$[ebp]
  008f7	83 c0 22	 add	 eax, 34			; 00000022H
  008fa	89 45 dc	 mov	 DWORD PTR _lOfs$[ebp], eax

; 24780: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917							
; 24781: 							count++;

  008fd	8a 45 cb	 mov	 al, BYTE PTR _count$[ebp]
  00900	04 01		 add	 al, 1
  00902	88 45 cb	 mov	 BYTE PTR _count$[ebp], al
$LN39@gObjViewpo:

; 24782: 						}
; 24783: 						if( lpObj->Type == OBJTYPE_CHARACTER )

  00905	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00908	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0090c	83 f9 01	 cmp	 ecx, 1
  0090f	0f 85 80 01 00
	00		 jne	 $LN52@gObjViewpo

; 24784: 						{
; 24785: 
; 24786: #ifdef MODIFY_GUILD_VIEWPORT_01_20040701
; 24787: 							if( lpTargetObj->lpGuild )								
; 24788: 							{
; 24789: 								//   .
; 24790: 				
; 24791: 								PMSG_SIMPLE_GUILDVIEWPORT	pMsg;
; 24792: 
; 24793: 		#ifdef MODIFY_GUILD_VIEWPORT_02_20040830
; 24794: 								pMsg.GuildNumber= lpTargetObj->lpGuild->Number;
; 24795: 		#else
; 24796: 								pMsg.GNumberH = HIBYTE(lpTargetObj->lpGuild->Number);
; 24797: 								pMsg.GNumberL = LOBYTE(lpTargetObj->lpGuild->Number);
; 24798: 		#endif
; 24799: 								pMsg.NumberH  = HIBYTE(lpTargetObj->m_Index)&0x7f;
; 24800: 								pMsg.NumberL  = LOBYTE(lpTargetObj->m_Index);
; 24801: 
; 24802: 		#ifdef ADD_NEW_GUILD_01_20040913
; 24803: 								//   .
; 24804: 								pMsg.btGuildStatus = lpTargetObj->GuildStatus;
; 24805: 		#endif
; 24806: 
; 24807: 		#ifdef ADD_NEW_GUILD_02_20040922
; 24808: 								pMsg.btGuildType = lpTargetObj->lpGuild->btGuildType;
; 24809: 		#endif
; 24810: 
; 24811: 		#ifdef ADD_NEW_UNION_01_20041006
; 24812: 								//  
; 24813: 								if( lpObj->lpGuild != NULL )
; 24814: 								{
; 24815: 									pMsg.btGuildRelationShip = gObjGetRelationShip( lpObj, lpTargetObj );
; 24816: 								}
; 24817: 								else
; 24818: 								{
; 24819: 									pMsg.btGuildRelationShip = G_RELATIONSHIP_NONE;
; 24820: 								}
; 24821: 		#endif
; 24822: 
; 24823: 								if(!strcmp(lpTargetObj->lpGuild->Names[0], lpTargetObj->Name))
; 24824: 								{	//   
; 24825: 									pMsg.NumberH |= 0x80;
; 24826: 
; 24827: 								}
; 24828: 								
; 24829: 		#ifdef UPDATE_CHECK_CASTLE_OWNERMEMBER_20090217
; 24830: 								if (g_CastleSiegeSync.CheckCastleOwnerMember(lpTargetObj->m_Index) == TRUE ||
; 24831: 									g_CastleSiegeSync.CheckCastleOwnerUnionMember(lpTargetObj->m_Index) == TRUE)
; 24832: 								{
; 24833: 									pMsg.btCastleOwner = 0x01;
; 24834: 								}
; 24835: 								else
; 24836: 								{
; 24837: 									pMsg.btCastleOwner = 0x00;
; 24838: 								}						
; 24839: 		#endif	// UPDATE_CHECK_CASTLE_OWNERMEMBER_20090217
; 24840: 
; 24841: 								memcpy(GuildInfoBuf+GuildInfoOfs, &pMsg, sizeof(pMsg));
; 24842: 								GuildInfoOfs += sizeof(pMsg);
; 24843: 								GuildInfoCount++;
; 24844: 							}
; 24845: #endif
; 24846: 							
; 24847: #ifdef MODIFY_GUILD_VIEWPORT_01_20040701
; 24848: 							//       .
; 24849: 							if( FALSE )
; 24850: #else
; 24851: 							if( lpTargetObj->GuildNumber )

  00915	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00918	83 b8 90 02 00
	00 00		 cmp	 DWORD PTR [eax+656], 0
  0091f	0f 84 70 01 00
	00		 je	 $LN52@gObjViewpo

; 24852: #endif
; 24853: 							{
; 24854: 								PMSG_GUILDVIEWPORT_USER pGVUMsg;
; 24855: 								if( ViewGuildMng.Add(lpTargetObj->GuildNumber, lpTargetObj->m_Index) == TRUE)

  00925	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00928	8b 08		 mov	 ecx, DWORD PTR [eax]
  0092a	51		 push	 ecx
  0092b	8b 55 f0	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  0092e	8b 82 90 02 00
	00		 mov	 eax, DWORD PTR [edx+656]
  00934	50		 push	 eax
  00935	b9 00 00 00 00	 mov	 ecx, OFFSET ?ViewGuildMng@@3VCViewportGuild@@A ; ViewGuildMng
  0093a	e8 00 00 00 00	 call	 ?Add@CViewportGuild@@QAEHHH@Z ; CViewportGuild::Add
  0093f	83 f8 01	 cmp	 eax, 1
  00942	0f 85 b3 00 00
	00		 jne	 $LN54@gObjViewpo

; 24856: 								{
; 24857: #ifdef CHINA_GUILD_POINTER_REF_ERROR
; 24858: 									if( lpTargetObj->lpGuild )

  00948	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0094b	83 b8 94 02 00
	00 00		 cmp	 DWORD PTR [eax+660], 0
  00952	0f 84 a3 00 00
	00		 je	 $LN54@gObjViewpo

; 24859: #endif
; 24860: 									{
; 24861: 										PMSG_GUILDVIEWPORT	pMsg;
; 24862: 										pMsg.NumberH = HIBYTE(lpTargetObj->lpGuild->Number);

  00958	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0095b	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00961	8b 11		 mov	 edx, DWORD PTR [ecx]
  00963	c1 ea 08	 shr	 edx, 8
  00966	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0096c	88 95 78 b1 ff
	ff		 mov	 BYTE PTR _pMsg$11[ebp], dl

; 24863: 										pMsg.NumberL = LOBYTE(lpTargetObj->lpGuild->Number);		

  00972	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00975	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  0097b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0097d	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00983	88 95 79 b1 ff
	ff		 mov	 BYTE PTR _pMsg$11[ebp+1], dl

; 24864: 										strcpy(pMsg.GuildName, lpTargetObj->lpGuild->Name);

  00989	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0098c	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00992	83 c1 04	 add	 ecx, 4
  00995	51		 push	 ecx
  00996	8d 95 7a b1 ff
	ff		 lea	 edx, DWORD PTR _pMsg$11[ebp+2]
  0099c	52		 push	 edx
  0099d	e8 00 00 00 00	 call	 _strcpy
  009a2	83 c4 08	 add	 esp, 8

; 24865: 										memcpy(pMsg.Mark, lpTargetObj->lpGuild->Mark, 32);

  009a5	6a 20		 push	 32			; 00000020H
  009a7	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  009aa	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  009b0	83 c1 0d	 add	 ecx, 13			; 0000000dH
  009b3	51		 push	 ecx
  009b4	8d 95 82 b1 ff
	ff		 lea	 edx, DWORD PTR _pMsg$11[ebp+10]
  009ba	52		 push	 edx
  009bb	e8 00 00 00 00	 call	 _memcpy
  009c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24866: 										memcpy(GuildInfoBuf+GuildInfoOfs, &pMsg, sizeof(pMsg));

  009c3	6a 2a		 push	 42			; 0000002aH
  009c5	8d 85 78 b1 ff
	ff		 lea	 eax, DWORD PTR _pMsg$11[ebp]
  009cb	50		 push	 eax
  009cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GuildInfoOfs@@3HA ; GuildInfoOfs
  009d2	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?GuildInfoBuf@@3PAEA ; GuildInfoBuf
  009d8	51		 push	 ecx
  009d9	e8 00 00 00 00	 call	 _memcpy
  009de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24867: 										GuildInfoOfs += sizeof(pMsg);

  009e1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildInfoOfs@@3HA ; GuildInfoOfs
  009e6	83 c0 2a	 add	 eax, 42			; 0000002aH
  009e9	a3 00 00 00 00	 mov	 DWORD PTR ?GuildInfoOfs@@3HA, eax ; GuildInfoOfs

; 24868: 										GuildInfoCount++;

  009ee	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildInfoCount@@3HA ; GuildInfoCount
  009f3	83 c0 01	 add	 eax, 1
  009f6	a3 00 00 00 00	 mov	 DWORD PTR ?GuildInfoCount@@3HA, eax ; GuildInfoCount
$LN54@gObjViewpo:

; 24869: 										//LogAdd(" : %s (%s)", lpTargetObj->lpGuild->Name, gObj[aIndex].Name);
; 24870: 									}
; 24871: 								}
; 24872: 
; 24873: 						#ifdef GUILD_VIEWPORT_MODIFY
; 24874: 								pGVUMsg.NumberH = HIBYTE(lpTargetObj->m_Index)&0x7f;
; 24875: 								pGVUMsg.NumberL = LOBYTE(lpTargetObj->m_Index);
; 24876: #ifdef CHINA_GUILD_POINTER_REF_ERROR
; 24877: 								if( lpTargetObj->lpGuild )								
; 24878: #endif
; 24879: 								{
; 24880: 									if(!strcmp(lpTargetObj->lpGuild->Names[0], lpTargetObj->Name))
; 24881: 									{	//   
; 24882: 										pGVUMsg.NumberH |= 0x80;
; 24883: 									}
; 24884: 								}
; 24885: 						#else
; 24886: 								pGVUMsg.NumberH = HIBYTE(lpTargetObj->m_Index);

  009fb	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  009fe	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a00	c1 e9 08	 shr	 ecx, 8
  00a03	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00a09	88 8d a4 b1 ff
	ff		 mov	 BYTE PTR _pGVUMsg$12[ebp], cl

; 24887: 								pGVUMsg.NumberL = LOBYTE(lpTargetObj->m_Index);

  00a0f	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00a12	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a14	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00a1a	88 8d a5 b1 ff
	ff		 mov	 BYTE PTR _pGVUMsg$12[ebp+1], cl

; 24888: 						#endif						
; 24889: 
; 24890: #ifdef CHINA_GUILD_POINTER_REF_ERROR
; 24891: 								if(lpTargetObj->lpGuild)								

  00a20	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00a23	83 b8 94 02 00
	00 00		 cmp	 DWORD PTR [eax+660], 0
  00a2a	74 69		 je	 SHORT $LN52@gObjViewpo

; 24892: #endif
; 24893: 								{
; 24894: 									pGVUMsg.GNumberH = HIBYTE(lpTargetObj->lpGuild->Number);

  00a2c	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00a2f	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00a35	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a37	c1 ea 08	 shr	 edx, 8
  00a3a	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00a40	88 95 a6 b1 ff
	ff		 mov	 BYTE PTR _pGVUMsg$12[ebp+2], dl

; 24895: 									pGVUMsg.GNumberL = LOBYTE(lpTargetObj->lpGuild->Number);						

  00a46	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00a49	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00a4f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00a51	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00a57	88 95 a7 b1 ff
	ff		 mov	 BYTE PTR _pGVUMsg$12[ebp+3], dl

; 24896: 									memcpy(GuildUserBuf+GuildUserOfs, &pGVUMsg, sizeof(pGVUMsg));

  00a5d	6a 04		 push	 4
  00a5f	8d 85 a4 b1 ff
	ff		 lea	 eax, DWORD PTR _pGVUMsg$12[ebp]
  00a65	50		 push	 eax
  00a66	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GuildUserOfs@@3HA ; GuildUserOfs
  00a6c	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?GuildUserBuf@@3PAEA ; GuildUserBuf
  00a72	51		 push	 ecx
  00a73	e8 00 00 00 00	 call	 _memcpy
  00a78	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24897: 									GuildUserOfs += sizeof(pGVUMsg);

  00a7b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildUserOfs@@3HA ; GuildUserOfs
  00a80	83 c0 04	 add	 eax, 4
  00a83	a3 00 00 00 00	 mov	 DWORD PTR ?GuildUserOfs@@3HA, eax ; GuildUserOfs

; 24898: 									GuildUserCount++;

  00a88	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildUserCount@@3HA ; GuildUserCount
  00a8d	83 c0 01	 add	 eax, 1
  00a90	a3 00 00 00 00	 mov	 DWORD PTR ?GuildUserCount@@3HA, eax ; GuildUserCount
$LN52@gObjViewpo:

; 24899: 								}
; 24900: 							}
; 24901: 						}
; 24902: 						break;

  00a95	e9 1f 05 00 00	 jmp	 $LN36@gObjViewpo
$LN57@gObjViewpo:

; 24903: 					case OBJTYPE_MONSTER :
; 24904: 					case OBJTYPE_NPC :
; 24905: 						if( lpObj->Type == OBJTYPE_CHARACTER )

  00a9a	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a9d	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00aa1	83 f9 01	 cmp	 ecx, 1
  00aa4	0f 85 69 02 00
	00		 jne	 $LN58@gObjViewpo

; 24906: 						{							
; 24907: 							lpTargetObj = &gObj[tObjNum];

  00aaa	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00aae	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00ab4	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00aba	89 4d f0	 mov	 DWORD PTR _lpTargetObj$[ebp], ecx

; 24908: 
; 24909: 							if( lpTargetObj->m_RecallMon >= 0 )

  00abd	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00ac0	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  00ac7	0f 8c 50 01 00
	00		 jl	 $LN59@gObjViewpo

; 24910: 							{
; 24911: 								pCallMonsterViewportCreate.NumberH = HIBYTE(tObjNum);

  00acd	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00ad1	c1 e8 08	 shr	 eax, 8
  00ad4	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00ad9	a2 00 00 00 00	 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A, al

; 24912: 								pCallMonsterViewportCreate.NumberL = LOBYTE(tObjNum);

  00ade	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00ae2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00ae7	a2 01 00 00 00	 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+1, al

; 24913: 								if( lpTargetObj->m_State == OBJST_CREATE )

  00aec	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00aef	83 b8 b8 01 00
	00 01		 cmp	 DWORD PTR [eax+440], 1
  00af6	75 11		 jne	 SHORT $LN61@gObjViewpo

; 24914: 									pCallMonsterViewportCreate.NumberH |= (0x01<<7);	//   ..

  00af8	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A
  00aff	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  00b04	a2 00 00 00 00	 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A, al
$LN61@gObjViewpo:

; 24915: 								
; 24916: #ifdef ENHANCE_MONSTER_TYPE_TO_WORD_20040618
; 24917: 								pCallMonsterViewportCreate.Type_HI = HIBYTE(lpTargetObj->Class);

  00b09	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00b0c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00b13	c1 e9 08	 shr	 ecx, 8
  00b16	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00b1c	88 0d 02 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+2, cl

; 24918: 								pCallMonsterViewportCreate.Type_LO = LOBYTE(lpTargetObj->Class);

  00b22	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00b25	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00b2c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00b32	88 0d 03 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+3, cl

; 24919: #else
; 24920: 								pCallMonsterViewportCreate.Type	   = lpTargetObj->Class;
; 24921: #endif
; 24922: #ifndef MODIFY_BUFF_SYSTEM_EXTENTION_20070917					// !! NOT
; 24923: 								pCallMonsterViewportCreate.ViewState = lpTargetObj->m_ViewSkillState;

  00b38	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00b3b	66 8b 88 c0 01
	00 00		 mov	 cx, WORD PTR [eax+448]
  00b42	66 89 0d 04 00
	00 00		 mov	 WORD PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+4, cx

; 24924: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24925: 								pCallMonsterViewportCreate.X       = (BYTE)lpTargetObj->X;

  00b49	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00b4c	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  00b52	88 0d 06 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+6, cl

; 24926: 								pCallMonsterViewportCreate.Y       = (BYTE)lpTargetObj->Y;

  00b58	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00b5b	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  00b61	88 0d 07 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+7, cl

; 24927: 								pCallMonsterViewportCreate.TX      = (BYTE)lpTargetObj->TX;

  00b67	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00b6a	8a 88 20 01 00
	00		 mov	 cl, BYTE PTR [eax+288]
  00b70	88 0d 08 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+8, cl

; 24928: 								pCallMonsterViewportCreate.TY      = (BYTE)lpTargetObj->TY;

  00b76	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00b79	8a 88 22 01 00
	00		 mov	 cl, BYTE PTR [eax+290]
  00b7f	88 0d 09 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+9, cl

; 24929: 								pCallMonsterViewportCreate.Path    = lpTargetObj->Dir<<4;								

  00b85	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00b88	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  00b8f	c1 e1 04	 shl	 ecx, 4
  00b92	88 0d 0a 00 00
	00		 mov	 BYTE PTR ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+10, cl

; 24930: 								
; 24931: 								if( lpTargetObj->m_RecallMon >= 0 && lpTargetObj->m_RecallMon < MAX_OBJECT-1 )

  00b98	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00b9b	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  00ba2	7c 38		 jl	 SHORT $LN62@gObjViewpo
  00ba4	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00ba7	81 b8 a4 02 00
	00 e7 1c 00 00	 cmp	 DWORD PTR [eax+676], 7399 ; 00001ce7H
  00bb1	7d 29		 jge	 SHORT $LN62@gObjViewpo

; 24932: 								{
; 24933: 									memcpy(pCallMonsterViewportCreate.Id, gObj[lpTargetObj->m_RecallMon].Name, MAX_IDSTRING);

  00bb3	6a 0a		 push	 10			; 0000000aH
  00bb5	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00bb8	69 88 a4 02 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR [eax+676], 7072
  00bc2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00bc8	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00bcc	50		 push	 eax
  00bcd	68 0b 00 00 00	 push	 OFFSET ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+11
  00bd2	e8 00 00 00 00	 call	 _memcpy
  00bd7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24934: 								}

  00bda	eb 11		 jmp	 SHORT $LN63@gObjViewpo
$LN62@gObjViewpo:

; 24935: 								else memset(pCallMonsterViewportCreate.Id, 0, MAX_IDSTRING);								

  00bdc	6a 0a		 push	 10			; 0000000aH
  00bde	6a 00		 push	 0
  00be0	68 0b 00 00 00	 push	 OFFSET ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A+11
  00be5	e8 00 00 00 00	 call	 _memset
  00bea	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN63@gObjViewpo:

; 24936: 								
; 24937: #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24938: 								iViewportSize = gObjMakeViewportState( lpTargetObj, pCallMonsterViewportCreate.BuffEffectList );
; 24939: 								pCallMonsterViewportCreate.BuffEffectCount = iViewportSize;
; 24940: 								memcpy((callMonstersendBuf+callMonlOfs), (char*)&pCallMonsterViewportCreate, sizeof(PMSG_CALLMONSTER_VIEWPORTCREATE) );
; 24941: 								callMonlOfs += ( sizeof(PMSG_CALLMONSTER_VIEWPORTCREATE) - ( MAX_BUFF_SLOT_INDEX - iViewportSize ) );
; 24942: #else
; 24943: 								memcpy((callMonstersendBuf+callMonlOfs), (char*)&pCallMonsterViewportCreate, sizeof(PMSG_CALLMONSTER_VIEWPORTCREATE));

  00bed	6a 16		 push	 22			; 00000016H
  00bef	68 00 00 00 00	 push	 OFFSET ?pCallMonsterViewportCreate@@3UPMSG_CALLMONSTER_VIEWPORTCREATE@@A ; pCallMonsterViewportCreate
  00bf4	8b 45 d4	 mov	 eax, DWORD PTR _callMonlOfs$[ebp]
  00bf7	8d 8c 05 30 c5
	ff ff		 lea	 ecx, DWORD PTR _callMonstersendBuf$[ebp+eax]
  00bfe	51		 push	 ecx
  00bff	e8 00 00 00 00	 call	 _memcpy
  00c04	83 c4 0c	 add	 esp, 12			; 0000000cH

; 24944: 								callMonlOfs += sizeof(PMSG_CALLMONSTER_VIEWPORTCREATE);

  00c07	8b 45 d4	 mov	 eax, DWORD PTR _callMonlOfs$[ebp]
  00c0a	83 c0 16	 add	 eax, 22			; 00000016H
  00c0d	89 45 d4	 mov	 DWORD PTR _callMonlOfs$[ebp], eax

; 24945: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 24946: 								callmonstercount++;

  00c10	8a 45 c9	 mov	 al, BYTE PTR _callmonstercount$[ebp]
  00c13	04 01		 add	 al, 1
  00c15	88 45 c9	 mov	 BYTE PTR _callmonstercount$[ebp], al

; 24947: 							}

  00c18	e9 f6 00 00 00	 jmp	 $LN58@gObjViewpo
$LN59@gObjViewpo:

; 24948: 							else
; 24949: 							{
; 24950: 								pMonsterViewportCreate.NumberH = HIBYTE(tObjNum);

  00c1d	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00c21	c1 e8 08	 shr	 eax, 8
  00c24	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00c29	a2 00 00 00 00	 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A, al

; 24951: 								pMonsterViewportCreate.NumberL = LOBYTE(tObjNum);

  00c2e	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00c32	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00c37	a2 01 00 00 00	 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+1, al

; 24952: 								if( lpTargetObj->m_State == OBJST_CREATE )

  00c3c	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c3f	83 b8 b8 01 00
	00 01		 cmp	 DWORD PTR [eax+440], 1
  00c46	75 11		 jne	 SHORT $LN64@gObjViewpo

; 24953: 								{
; 24954: 									pMonsterViewportCreate.NumberH |= (0x01<<7);	//   ..

  00c48	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A
  00c4f	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  00c54	a2 00 00 00 00	 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A, al
$LN64@gObjViewpo:

; 24955: 
; 24956: #ifdef MODIFY_NEW_MONSTER_SKILL_01_20060724
; 24957: 									if ( lpTargetObj->Teleport != 0 )
; 24958: 									{
; 24959: 										//   . NumberH  2bit 1.  1bit  . 
; 24960: 										//  2bit . 2bit | 4bit : 0 ~ 16383  .
; 24961: 										pMonsterViewportCreate.NumberH |= (0x01<<6);
; 24962: 									}
; 24963: #endif // MODIFY_NEW_MONSTER_SKILL_01_20060724
; 24964: 
; 24965: 								}
; 24966: #ifdef ENHANCE_MONSTER_TYPE_TO_WORD_20040618
; 24967: 								pMonsterViewportCreate.Type_HI    = HIBYTE(lpTargetObj->Class);

  00c59	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c5c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00c63	c1 e9 08	 shr	 ecx, 8
  00c66	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00c6c	88 0d 02 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+2, cl

; 24968: 								pMonsterViewportCreate.Type_LO    = LOBYTE(lpTargetObj->Class);

  00c72	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c75	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00c7c	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00c82	88 0d 03 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+3, cl

; 24969: #else
; 24970: 								pMonsterViewportCreate.Type		  = lpTargetObj->Class;
; 24971: #endif
; 24972: 								
; 24973: #ifdef CASTLE_NPC_LIFESTONE_WORK_20041208
; 24974: 								//     .
; 24975: 								if( lpTargetObj->Class == NPC_INDEX_LIFESTONE )
; 24976: 								{
; 24977: 
; 24978: 									// 1.   (   1  )
; 24979: 									if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE) 
; 24980: 									{							
; 24981: 										if( lpObj->m_btCsJoinSide == lpTargetObj->m_btCsJoinSide )
; 24982: 										{
; 24983: 											//  Class   Bit 1   
; 24984: 											pMonsterViewportCreate.Type_HI |= 0x80;
; 24985: 										}	
; 24986: 									}
; 24987: 									
; 24988: 									// 1-1.  
; 24989: 									if( lpObj->lpGuild != NULL && lpTargetObj->lpGuild != NULL )
; 24990: 									{
; 24991: 										if( lpObj->lpGuild == lpTargetObj->lpGuild )
; 24992: 										{
; 24993: 											//  Class   Bit 1   
; 24994: 											pMonsterViewportCreate.Type_HI |= 0x80;
; 24995: 										}
; 24996: 									}
; 24997: 
; 24998: 									// 2.     (   2 3 4  )
; 24999: 									pMonsterViewportCreate.Type_HI |= ((lpTargetObj->m_btCreationState<<4)&0x70);
; 25000: 
; 25001: 								}
; 25002: #endif	
; 25003: 
; 25004: 								//pMonsterViewportCreate.ViewState = lpTargetObj->m_ViewState;
; 25005: #ifndef MODIFY_BUFF_SYSTEM_EXTENTION_20070917					// !! NOT
; 25006: 								pMonsterViewportCreate.ViewState = lpTargetObj->m_ViewSkillState;

  00c88	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c8b	66 8b 88 c0 01
	00 00		 mov	 cx, WORD PTR [eax+448]
  00c92	66 89 0d 04 00
	00 00		 mov	 WORD PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+4, cx

; 25007: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 25008: 								pMonsterViewportCreate.X       = (BYTE)lpTargetObj->X;

  00c99	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00c9c	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  00ca2	88 0d 06 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+6, cl

; 25009: 								pMonsterViewportCreate.Y       = (BYTE)lpTargetObj->Y;

  00ca8	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00cab	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  00cb1	88 0d 07 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+7, cl

; 25010: 								pMonsterViewportCreate.TX      = (BYTE)lpTargetObj->TX;

  00cb7	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00cba	8a 88 20 01 00
	00		 mov	 cl, BYTE PTR [eax+288]
  00cc0	88 0d 08 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+8, cl

; 25011: 								pMonsterViewportCreate.TY      = (BYTE)lpTargetObj->TY;

  00cc6	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00cc9	8a 88 22 01 00
	00		 mov	 cl, BYTE PTR [eax+290]
  00ccf	88 0d 09 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+9, cl

; 25012: 								pMonsterViewportCreate.Path    = lpTargetObj->Dir<<4;

  00cd5	8b 45 f0	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00cd8	0f b6 88 08 01
	00 00		 movzx	 ecx, BYTE PTR [eax+264]
  00cdf	c1 e1 04	 shl	 ecx, 4
  00ce2	88 0d 0a 00 00
	00		 mov	 BYTE PTR ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A+10, cl

; 25013: 
; 25014: #ifdef CASTLE_NPC_GATE_WORK_20041206	//     
; 25015: 								if (lpTargetObj->Class == 277) {
; 25016: 									//       
; 25017: 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 25018: 									if (lpTargetObj->m_btCsGateOpen == CS_GATE_STATE_CLOSED)
; 25019: 									{
; 25020: 										gObjRemoveBuffEffect( lpTargetObj, BUFFTYPE_CASTLE_DOOR_STATE );
; 25021: 									}
; 25022: 									else
; 25023: 									{
; 25024: 										gObjAddBuffEffect( lpTargetObj, BUFFTYPE_CASTLE_DOOR_STATE );
; 25025: 									}
; 25026: 	#else
; 25027: 									if (lpTargetObj->m_btCsGateOpen == CS_GATE_STATE_CLOSED)
; 25028: 										pMonsterViewportCreate.ViewState &= ~STATE_CASTLE_GATE;
; 25029: 									else
; 25030: 										pMonsterViewportCreate.ViewState |= STATE_CASTLE_GATE;
; 25031: 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 25032: 								}
; 25033: #endif
; 25034: #ifdef CASTLE_NPC_CROWN_WORK_20041210
; 25035: 								if (lpTargetObj->Class == 216)
; 25036: 								{
; 25037: 									//         
; 25038: 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 25039: 		#ifdef MODIFY_BUFFSYSTEM_BUGFIX_01_20071128
; 25040: 									if (g_CastleSiege.GetRegCrownAvailable() == FALSE )
; 25041: 		#else
; 25042: 									if (g_CastleSiege.GetRegCrownAvailable() == TRUE )
; 25043: 		#endif // MODIFY_BUFFSYSTEM_BUGFIX_01_20071128
; 25044: 									{
; 25045: 										gObjRemoveBuffEffect( lpTargetObj, BUFFTYPE_CASTLE_CROWN_STATE );
; 25046: 									}
; 25047: 									else
; 25048: 									{
; 25049: 										gObjAddBuffEffect( lpTargetObj, BUFFTYPE_CASTLE_CROWN_STATE );
; 25050: 									}
; 25051: 	#else
; 25052: 									if (g_CastleSiege.GetRegCrownAvailable() == FALSE)
; 25053: 										pMonsterViewportCreate.ViewState &= ~STATE_CASTLE_CROWN;
; 25054: 									else
; 25055: 										pMonsterViewportCreate.ViewState |= STATE_CASTLE_CROWN;
; 25056: 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 25057: 								}
; 25058: #endif
; 25059: 
; 25060: #ifdef CRYWOLF_NPC_WORK_20050912
; 25061: 								//     /   
; 25062: 								// ADD_VIEWSKILLSTATE
; 25063: 								// DEL_VIEWSKILLSTATE( x, y )	GCStateInfoSend( lpObj, 1, STATE_BLESS_POTION );
; 25064: 
; 25065: 								//    /  /    
; 25066: #endif
; 25067: 								
; 25068: #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 25069: 								iViewportSize = gObjMakeViewportState( lpTargetObj, pMonsterViewportCreate.BuffEffectList );
; 25070: 								pMonsterViewportCreate.BuffEffectCount = iViewportSize;
; 25071: 								memcpy((MonstersendBuf+MonlOfs), (char*)&pMonsterViewportCreate, sizeof(PMSG_MONSTER_VIEWPORTCREATE) );
; 25072: 								MonlOfs += ( sizeof(PMSG_MONSTER_VIEWPORTCREATE) - ( MAX_BUFF_SLOT_INDEX - iViewportSize ) );
; 25073: #else
; 25074: 								memcpy((MonstersendBuf+MonlOfs), (char*)&pMonsterViewportCreate, sizeof(PMSG_MONSTER_VIEWPORTCREATE));

  00ce8	6a 0c		 push	 12			; 0000000cH
  00cea	68 00 00 00 00	 push	 OFFSET ?pMonsterViewportCreate@@3UPMSG_MONSTER_VIEWPORTCREATE@@A ; pMonsterViewportCreate
  00cef	8b 45 d8	 mov	 eax, DWORD PTR _MonlOfs$[ebp]
  00cf2	8d 8c 05 b8 d8
	ff ff		 lea	 ecx, DWORD PTR _MonstersendBuf$[ebp+eax]
  00cf9	51		 push	 ecx
  00cfa	e8 00 00 00 00	 call	 _memcpy
  00cff	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25075: 								MonlOfs += sizeof(PMSG_MONSTER_VIEWPORTCREATE);

  00d02	8b 45 d8	 mov	 eax, DWORD PTR _MonlOfs$[ebp]
  00d05	83 c0 0c	 add	 eax, 12			; 0000000cH
  00d08	89 45 d8	 mov	 DWORD PTR _MonlOfs$[ebp], eax

; 25076: #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 25077: 								monstercount++;

  00d0b	8a 45 ca	 mov	 al, BYTE PTR _monstercount$[ebp]
  00d0e	04 01		 add	 al, 1
  00d10	88 45 ca	 mov	 BYTE PTR _monstercount$[ebp], al
$LN58@gObjViewpo:

; 25078: 							}
; 25079: 						}
; 25080: 						break;

  00d13	e9 a1 02 00 00	 jmp	 $LN36@gObjViewpo
$LN65@gObjViewpo:

; 25081: 					case OBJTYPE_ITEM :
; 25082: 						if( lpObj->Type == OBJTYPE_CHARACTER )

  00d18	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d1b	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00d1f	83 f9 01	 cmp	 ecx, 1
  00d22	0f 85 91 02 00
	00		 jne	 $LN36@gObjViewpo

; 25083: 						{
; 25084: 							pItemViewportCreate.NumberH		= HIBYTE(tObjNum);

  00d28	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00d2c	c1 e8 08	 shr	 eax, 8
  00d2f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00d34	a2 00 00 00 00	 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A, al

; 25085: 							pItemViewportCreate.NumberL		= LOBYTE(tObjNum);

  00d39	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00d3d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00d42	a2 01 00 00 00	 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+1, al

; 25086: 							if( MapC[lpObj->MapNumber].m_cItem[tObjNum].m_State == OBJST_CREATE )

  00d47	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d4a	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00d51	69 d1 8c 04 05
	00		 imul	 edx, ecx, 328844
  00d57	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00d5d	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00d61	69 c8 48 04 00
	00		 imul	 ecx, eax, 1096
  00d67	83 bc 0a d0 00
	00 00 01	 cmp	 DWORD PTR [edx+ecx+208], 1
  00d6f	75 11		 jne	 SHORT $LN67@gObjViewpo

; 25087: 							{
; 25088: 								pItemViewportCreate.NumberH |= (0x01<<7);

  00d71	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A
  00d78	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  00d7d	a2 00 00 00 00	 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A, al
$LN67@gObjViewpo:

; 25089: 							}
; 25090: 							pItemViewportCreate.px			= MapC[lpObj->MapNumber].m_cItem[tObjNum].px;

  00d82	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d85	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00d8c	69 d1 8c 04 05
	00		 imul	 edx, ecx, 328844
  00d92	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00d98	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00d9c	69 c8 48 04 00
	00		 imul	 ecx, eax, 1096
  00da2	8a 94 0a cc 00
	00 00		 mov	 dl, BYTE PTR [edx+ecx+204]
  00da9	88 15 02 00 00
	00		 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+2, dl

; 25091: 							pItemViewportCreate.py			= MapC[lpObj->MapNumber].m_cItem[tObjNum].py;

  00daf	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00db2	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00db9	69 d1 8c 04 05
	00		 imul	 edx, ecx, 328844
  00dbf	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00dc5	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00dc9	69 c8 48 04 00
	00		 imul	 ecx, eax, 1096
  00dcf	8a 94 0a cd 00
	00 00		 mov	 dl, BYTE PTR [edx+ecx+205]
  00dd6	88 15 03 00 00
	00		 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+3, dl

; 25092: 							//  
; 25093: 							if( MapC[lpObj->MapNumber].m_cItem[tObjNum].m_Type == GOLD_TYPE_INDEX )

  00ddc	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ddf	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00de6	69 d1 8c 04 05
	00		 imul	 edx, ecx, 328844
  00dec	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00df2	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00df6	69 c8 48 04 00
	00		 imul	 ecx, eax, 1096
  00dfc	0f bf 54 0a 2a	 movsx	 edx, WORD PTR [edx+ecx+42]
  00e01	81 fa cf 01 00
	00		 cmp	 edx, 463		; 000001cfH
  00e07	0f 85 2a 01 00
	00		 jne	 $LN68@gObjViewpo

; 25094: 							{
; 25095: 								WORD moneyh, moneyl;
; 25096: 								moneyh = HIWORD(MapC[lpObj->MapNumber].m_cItem[tObjNum].m_BuyMoney);

  00e0d	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e10	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00e17	69 d1 8c 04 05
	00		 imul	 edx, ecx, 328844
  00e1d	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00e23	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00e27	69 c8 48 04 00
	00		 imul	 ecx, eax, 1096
  00e2d	8b 94 0a 88 00
	00 00		 mov	 edx, DWORD PTR [edx+ecx+136]
  00e34	c1 ea 10	 shr	 edx, 16			; 00000010H
  00e37	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00e3d	66 89 95 74 b1
	ff ff		 mov	 WORD PTR _moneyh$10[ebp], dx

; 25097: 								moneyl = LOWORD(MapC[lpObj->MapNumber].m_cItem[tObjNum].m_BuyMoney);

  00e44	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e47	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00e4e	69 d1 8c 04 05
	00		 imul	 edx, ecx, 328844
  00e54	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00e5a	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00e5e	69 c8 48 04 00
	00		 imul	 ecx, eax, 1096
  00e64	8b 94 0a 88 00
	00 00		 mov	 edx, DWORD PTR [edx+ecx+136]
  00e6b	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00e71	66 89 95 70 b1
	ff ff		 mov	 WORD PTR _moneyl$9[ebp], dx

; 25098: 								
; 25099: 								pItemViewportCreate.ItemInfo[0] = (BYTE)MapC[lpObj->MapNumber].m_cItem[tObjNum].m_Type%255;

  00e78	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e7b	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00e82	69 d1 8c 04 05
	00		 imul	 edx, ecx, 328844
  00e88	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00e8e	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00e92	69 c8 48 04 00
	00		 imul	 ecx, eax, 1096
  00e98	0f b6 44 0a 2a	 movzx	 eax, BYTE PTR [edx+ecx+42]
  00e9d	99		 cdq
  00e9e	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00ea3	f7 f9		 idiv	 ecx
  00ea5	b8 01 00 00 00	 mov	 eax, 1
  00eaa	6b c8 00	 imul	 ecx, eax, 0
  00ead	88 91 04 00 00
	00		 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A[ecx+4], dl

; 25100: 								pItemViewportCreate.ItemInfo[1] = LOBYTE(moneyh);

  00eb3	0f b7 85 74 b1
	ff ff		 movzx	 eax, WORD PTR _moneyh$10[ebp]
  00eba	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00ebf	b9 01 00 00 00	 mov	 ecx, 1
  00ec4	c1 e1 00	 shl	 ecx, 0
  00ec7	88 81 04 00 00
	00		 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A[ecx+4], al

; 25101: 								pItemViewportCreate.ItemInfo[2] = HIBYTE(moneyl);

  00ecd	0f b7 85 70 b1
	ff ff		 movzx	 eax, WORD PTR _moneyl$9[ebp]
  00ed4	c1 e8 08	 shr	 eax, 8
  00ed7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00edc	b9 01 00 00 00	 mov	 ecx, 1
  00ee1	d1 e1		 shl	 ecx, 1
  00ee3	88 81 04 00 00
	00		 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A[ecx+4], al

; 25102: 								pItemViewportCreate.ItemInfo[4] = LOBYTE(moneyl);

  00ee9	0f b7 85 70 b1
	ff ff		 movzx	 eax, WORD PTR _moneyl$9[ebp]
  00ef0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00ef5	b9 01 00 00 00	 mov	 ecx, 1
  00efa	c1 e1 02	 shl	 ecx, 2
  00efd	88 81 04 00 00
	00		 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A[ecx+4], al

; 25103: #ifdef ITEM_INDEX_EXTEND_20050706	//      .
; 25104: 								pItemViewportCreate.ItemInfo[3] = 0x00;
; 25105: 								pItemViewportCreate.ItemInfo[5] = (BYTE)((MapC[lpObj->MapNumber].m_cItem[tObjNum].m_Type&0x1E00)>>5);
; 25106: 								pItemViewportCreate.ItemInfo[6] = 0;
; 25107: #else
; 25108: 								pItemViewportCreate.ItemInfo[3] = 0x80;

  00f03	b8 01 00 00 00	 mov	 eax, 1
  00f08	6b c8 03	 imul	 ecx, eax, 3
  00f0b	c6 81 04 00 00
	00 80		 mov	 BYTE PTR ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A[ecx+4], 128 ; 00000080H

; 25109: #endif
; 25110: 								memcpy(ItemBuf+lOfs_Item, (char*)&pItemViewportCreate, sizeof(pItemViewportCreate));

  00f12	6a 09		 push	 9
  00f14	68 00 00 00 00	 push	 OFFSET ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A ; pItemViewportCreate
  00f19	8b 45 e8	 mov	 eax, DWORD PTR _lOfs_Item$[ebp]
  00f1c	8d 8c 05 a8 b1
	ff ff		 lea	 ecx, DWORD PTR _ItemBuf$[ebp+eax]
  00f23	51		 push	 ecx
  00f24	e8 00 00 00 00	 call	 _memcpy
  00f29	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25111: 								lOfs_Item += ItemStructSize;

  00f2c	8b 45 e8	 mov	 eax, DWORD PTR _lOfs_Item$[ebp]
  00f2f	03 45 e0	 add	 eax, DWORD PTR _ItemStructSize$[ebp]
  00f32	89 45 e8	 mov	 DWORD PTR _lOfs_Item$[ebp], eax

; 25112: 							}

  00f35	eb 79		 jmp	 SHORT $LN69@gObjViewpo
$LN68@gObjViewpo:

; 25113: 							else 
; 25114: 							{
; 25115: 								ItemByteConvert(pItemViewportCreate.ItemInfo, MapC[lpObj->MapNumber].m_cItem[tObjNum]);

  00f37	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00f3a	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00f41	69 d1 8c 04 05
	00		 imul	 edx, ecx, 328844
  00f47	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00f4d	0f bf 45 cc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00f51	69 c8 48 04 00
	00		 imul	 ecx, eax, 1096
  00f57	8d 74 0a 24	 lea	 esi, DWORD PTR [edx+ecx+36]
  00f5b	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00f60	8d bd 90 ae ff
	ff		 lea	 edi, DWORD PTR $T1[ebp]
  00f66	f3 a5		 rep movsd
  00f68	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00f6e	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00f73	8d b5 90 ae ff
	ff		 lea	 esi, DWORD PTR $T1[ebp]
  00f79	8b fc		 mov	 edi, esp
  00f7b	f3 a5		 rep movsd
  00f7d	68 04 00 00 00	 push	 OFFSET ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A+4
  00f82	e8 00 00 00 00	 call	 ?ItemByteConvert@@YAXPAEVCItem@@@Z ; ItemByteConvert
  00f87	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH

; 25116: 								memcpy(ItemBuf+lOfs_Item, (char*)&pItemViewportCreate, sizeof(pItemViewportCreate));

  00f8d	6a 09		 push	 9
  00f8f	68 00 00 00 00	 push	 OFFSET ?pItemViewportCreate@@3UPMSG_ITEMVIEWPORTCREATE@@A ; pItemViewportCreate
  00f94	8b 45 e8	 mov	 eax, DWORD PTR _lOfs_Item$[ebp]
  00f97	8d 8c 05 a8 b1
	ff ff		 lea	 ecx, DWORD PTR _ItemBuf$[ebp+eax]
  00f9e	51		 push	 ecx
  00f9f	e8 00 00 00 00	 call	 _memcpy
  00fa4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25117: 
; 25118: 								lOfs_Item += ItemStructSize;

  00fa7	8b 45 e8	 mov	 eax, DWORD PTR _lOfs_Item$[ebp]
  00faa	03 45 e0	 add	 eax, DWORD PTR _ItemStructSize$[ebp]
  00fad	89 45 e8	 mov	 DWORD PTR _lOfs_Item$[ebp], eax
$LN69@gObjViewpo:

; 25119: 																
; 25120: 							}
; 25121: 							count_Item++;

  00fb0	8b 45 e4	 mov	 eax, DWORD PTR _count_Item$[ebp]
  00fb3	83 c0 01	 add	 eax, 1
  00fb6	89 45 e4	 mov	 DWORD PTR _count_Item$[ebp], eax
$LN36@gObjViewpo:

; 25122: 
; 25123: 
; 25124: 
; 25125: 						}				
; 25126: 						break;
; 25127: 					}
; 25128: 				}			
; 25129: 				lpObj->VpPlayer[n].state = STVP_PLAYING;

  00fb9	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  00fbd	8b 4d ec	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00fc0	c6 84 01 64 03
	00 00 02	 mov	 BYTE PTR [ecx+eax+868], 2
$LN35@gObjViewpo:

; 25130: 			}
; 25131: 		}

  00fc8	e9 48 f4 ff ff	 jmp	 $LN13@gObjViewpo
$LN34@gObjViewpo:

; 25132: 	}
; 25133: 	//     .
; 25134: 	if( lpObj->Type == OBJTYPE_CHARACTER )

  00fcd	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00fd0	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00fd4	83 f9 01	 cmp	 ecx, 1
  00fd7	0f 85 0f 03 00
	00		 jne	 $LN1@gObjViewpo

; 25135: 	{
; 25136: 		if( count > 0 ) 

  00fdd	0f b6 45 cb	 movzx	 eax, BYTE PTR _count$[ebp]
  00fe1	85 c0		 test	 eax, eax
  00fe3	7e 66		 jle	 SHORT $LN71@gObjViewpo

; 25137: 		{
; 25138: 			PWMSG_COUNT			pwCount;
; 25139: 			pwCount.h.c         = PMHC_WORD;

  00fe5	c6 85 68 b1 ff
	ff c2		 mov	 BYTE PTR _pwCount$8[ebp], 194 ; 000000c2H

; 25140: 			pwCount.h.headcode  = PMHC_VIEWPORTCREATE;

  00fec	c6 85 6b b1 ff
	ff 12		 mov	 BYTE PTR _pwCount$8[ebp+3], 18 ; 00000012H

; 25141: 			pwCount.h.sizeH     = HIBYTE(lOfs);

  00ff3	8b 45 dc	 mov	 eax, DWORD PTR _lOfs$[ebp]
  00ff6	c1 e8 08	 shr	 eax, 8
  00ff9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00ffe	88 85 69 b1 ff
	ff		 mov	 BYTE PTR _pwCount$8[ebp+1], al

; 25142: 			pwCount.h.sizeL     = LOBYTE(lOfs);

  01004	8b 45 dc	 mov	 eax, DWORD PTR _lOfs$[ebp]
  01007	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0100c	88 85 6a b1 ff
	ff		 mov	 BYTE PTR _pwCount$8[ebp+2], al

; 25143: 			pwCount.count       = count;

  01012	8a 45 cb	 mov	 al, BYTE PTR _count$[ebp]
  01015	88 85 6c b1 ff
	ff		 mov	 BYTE PTR _pwCount$8[ebp+4], al

; 25144: 			memcpy(sendBuf, (char*)&pwCount, sizeof(PWMSG_COUNT));

  0101b	6a 05		 push	 5
  0101d	8d 85 68 b1 ff
	ff		 lea	 eax, DWORD PTR _pwCount$8[ebp]
  01023	50		 push	 eax
  01024	8d 8d 40 ec ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  0102a	51		 push	 ecx
  0102b	e8 00 00 00 00	 call	 _memcpy
  01030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25145: 			DataSend(aIndex, sendBuf, lOfs);

  01033	8b 45 dc	 mov	 eax, DWORD PTR _lOfs$[ebp]
  01036	50		 push	 eax
  01037	8d 8d 40 ec ff
	ff		 lea	 ecx, DWORD PTR _sendBuf$[ebp]
  0103d	51		 push	 ecx
  0103e	0f bf 55 08	 movsx	 edx, WORD PTR _aIndex$[ebp]
  01042	52		 push	 edx
  01043	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01048	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN71@gObjViewpo:

; 25146: 		}	
; 25147: 		if( ChangeCount > 0 )

  0104b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ChangeCount@@3HA, 0 ; ChangeCount
  01052	7e 6a		 jle	 SHORT $LN72@gObjViewpo

; 25148: 		{
; 25149: 			PWMSG_COUNT			pwCount;
; 25150: 			pwCount.h.c         = PMHC_WORD;

  01054	c6 85 60 b1 ff
	ff c2		 mov	 BYTE PTR _pwCount$7[ebp], 194 ; 000000c2H

; 25151: 			pwCount.h.headcode  = 0x45;

  0105b	c6 85 63 b1 ff
	ff 45		 mov	 BYTE PTR _pwCount$7[ebp+3], 69 ; 00000045H

; 25152: 			pwCount.h.sizeH     = HIBYTE(lOfsChange);

  01062	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lOfsChange@@3HA ; lOfsChange
  01067	c1 e8 08	 shr	 eax, 8
  0106a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0106f	88 85 61 b1 ff
	ff		 mov	 BYTE PTR _pwCount$7[ebp+1], al

; 25153: 			pwCount.h.sizeL     = LOBYTE(lOfsChange);

  01075	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lOfsChange@@3HA ; lOfsChange
  0107a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0107f	88 85 62 b1 ff
	ff		 mov	 BYTE PTR _pwCount$7[ebp+2], al

; 25154: 			pwCount.count       = ChangeCount;

  01085	a0 00 00 00 00	 mov	 al, BYTE PTR ?ChangeCount@@3HA
  0108a	88 85 64 b1 ff
	ff		 mov	 BYTE PTR _pwCount$7[ebp+4], al

; 25155: 			memcpy(SendGBufChange, (char*)&pwCount, sizeof(PWMSG_COUNT));

  01090	6a 05		 push	 5
  01092	8d 85 60 b1 ff
	ff		 lea	 eax, DWORD PTR _pwCount$7[ebp]
  01098	50		 push	 eax
  01099	68 00 00 00 00	 push	 OFFSET ?SendGBufChange@@3PAEA ; SendGBufChange
  0109e	e8 00 00 00 00	 call	 _memcpy
  010a3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25156: 			DataSend(aIndex, SendGBufChange, lOfsChange);

  010a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?lOfsChange@@3HA ; lOfsChange
  010ab	50		 push	 eax
  010ac	68 00 00 00 00	 push	 OFFSET ?SendGBufChange@@3PAEA ; SendGBufChange
  010b1	0f bf 4d 08	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  010b5	51		 push	 ecx
  010b6	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  010bb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN72@gObjViewpo:

; 25157: 		}			
; 25158: 		//  
; 25159: 		if( monstercount > 0 )

  010be	0f b6 45 ca	 movzx	 eax, BYTE PTR _monstercount$[ebp]
  010c2	85 c0		 test	 eax, eax
  010c4	7e 66		 jle	 SHORT $LN73@gObjViewpo

; 25160: 		{
; 25161: 			PWMSG_COUNT			pwCount;
; 25162: 			pwCount.h.c         = PMHC_WORD;

  010c6	c6 85 58 b1 ff
	ff c2		 mov	 BYTE PTR _pwCount$6[ebp], 194 ; 000000c2H

; 25163: 			pwCount.h.headcode  = PMHC_VIEWPORTMONSTERCREATE;

  010cd	c6 85 5b b1 ff
	ff 13		 mov	 BYTE PTR _pwCount$6[ebp+3], 19 ; 00000013H

; 25164: 			pwCount.h.sizeH     = HIBYTE(MonlOfs);

  010d4	8b 45 d8	 mov	 eax, DWORD PTR _MonlOfs$[ebp]
  010d7	c1 e8 08	 shr	 eax, 8
  010da	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  010df	88 85 59 b1 ff
	ff		 mov	 BYTE PTR _pwCount$6[ebp+1], al

; 25165: 			pwCount.h.sizeL     = LOBYTE(MonlOfs);

  010e5	8b 45 d8	 mov	 eax, DWORD PTR _MonlOfs$[ebp]
  010e8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  010ed	88 85 5a b1 ff
	ff		 mov	 BYTE PTR _pwCount$6[ebp+2], al

; 25166: 			pwCount.count       = monstercount;

  010f3	8a 45 ca	 mov	 al, BYTE PTR _monstercount$[ebp]
  010f6	88 85 5c b1 ff
	ff		 mov	 BYTE PTR _pwCount$6[ebp+4], al

; 25167: 			memcpy(MonstersendBuf, (char*)&pwCount, sizeof(PWMSG_COUNT));

  010fc	6a 05		 push	 5
  010fe	8d 85 58 b1 ff
	ff		 lea	 eax, DWORD PTR _pwCount$6[ebp]
  01104	50		 push	 eax
  01105	8d 8d b8 d8 ff
	ff		 lea	 ecx, DWORD PTR _MonstersendBuf$[ebp]
  0110b	51		 push	 ecx
  0110c	e8 00 00 00 00	 call	 _memcpy
  01111	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25168: 			DataSend(aIndex, MonstersendBuf, MonlOfs);

  01114	8b 45 d8	 mov	 eax, DWORD PTR _MonlOfs$[ebp]
  01117	50		 push	 eax
  01118	8d 8d b8 d8 ff
	ff		 lea	 ecx, DWORD PTR _MonstersendBuf$[ebp]
  0111e	51		 push	 ecx
  0111f	0f bf 55 08	 movsx	 edx, WORD PTR _aIndex$[ebp]
  01123	52		 push	 edx
  01124	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01129	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN73@gObjViewpo:

; 25169: 		}
; 25170: 		if( callmonstercount > 0 )

  0112c	0f b6 45 c9	 movzx	 eax, BYTE PTR _callmonstercount$[ebp]
  01130	85 c0		 test	 eax, eax
  01132	7e 66		 jle	 SHORT $LN74@gObjViewpo

; 25171: 		{
; 25172: 			PWMSG_COUNT			pwCount;
; 25173: 			pwCount.h.c         = PMHC_WORD;

  01134	c6 85 50 b1 ff
	ff c2		 mov	 BYTE PTR _pwCount$5[ebp], 194 ; 000000c2H

; 25174: 			pwCount.h.headcode  = 0x1F;

  0113b	c6 85 53 b1 ff
	ff 1f		 mov	 BYTE PTR _pwCount$5[ebp+3], 31 ; 0000001fH

; 25175: 			pwCount.h.sizeH     = HIBYTE(callMonlOfs);

  01142	8b 45 d4	 mov	 eax, DWORD PTR _callMonlOfs$[ebp]
  01145	c1 e8 08	 shr	 eax, 8
  01148	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0114d	88 85 51 b1 ff
	ff		 mov	 BYTE PTR _pwCount$5[ebp+1], al

; 25176: 			pwCount.h.sizeL     = LOBYTE(callMonlOfs);

  01153	8b 45 d4	 mov	 eax, DWORD PTR _callMonlOfs$[ebp]
  01156	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0115b	88 85 52 b1 ff
	ff		 mov	 BYTE PTR _pwCount$5[ebp+2], al

; 25177: 			pwCount.count       = callmonstercount;

  01161	8a 45 c9	 mov	 al, BYTE PTR _callmonstercount$[ebp]
  01164	88 85 54 b1 ff
	ff		 mov	 BYTE PTR _pwCount$5[ebp+4], al

; 25178: 			memcpy(callMonstersendBuf, (char*)&pwCount, sizeof(PWMSG_COUNT));

  0116a	6a 05		 push	 5
  0116c	8d 85 50 b1 ff
	ff		 lea	 eax, DWORD PTR _pwCount$5[ebp]
  01172	50		 push	 eax
  01173	8d 8d 30 c5 ff
	ff		 lea	 ecx, DWORD PTR _callMonstersendBuf$[ebp]
  01179	51		 push	 ecx
  0117a	e8 00 00 00 00	 call	 _memcpy
  0117f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25179: 			DataSend(aIndex, callMonstersendBuf, callMonlOfs);

  01182	8b 45 d4	 mov	 eax, DWORD PTR _callMonlOfs$[ebp]
  01185	50		 push	 eax
  01186	8d 8d 30 c5 ff
	ff		 lea	 ecx, DWORD PTR _callMonstersendBuf$[ebp]
  0118c	51		 push	 ecx
  0118d	0f bf 55 08	 movsx	 edx, WORD PTR _aIndex$[ebp]
  01191	52		 push	 edx
  01192	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01197	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@gObjViewpo:

; 25180: 		}
; 25181: 		
; 25182: 		//   
; 25183: 		if( count_Item > 0 )

  0119a	83 7d e4 00	 cmp	 DWORD PTR _count_Item$[ebp], 0
  0119e	7e 66		 jle	 SHORT $LN75@gObjViewpo

; 25184: 		{
; 25185: 			PWMSG_COUNT			pwCount;
; 25186: 			pwCount.h.c         = PMHC_WORD;

  011a0	c6 85 48 b1 ff
	ff c2		 mov	 BYTE PTR _pwCount$4[ebp], 194 ; 000000c2H

; 25187: 			pwCount.h.headcode  = 0x20;

  011a7	c6 85 4b b1 ff
	ff 20		 mov	 BYTE PTR _pwCount$4[ebp+3], 32 ; 00000020H

; 25188: 			pwCount.count       = count_Item;

  011ae	8a 45 e4	 mov	 al, BYTE PTR _count_Item$[ebp]
  011b1	88 85 4c b1 ff
	ff		 mov	 BYTE PTR _pwCount$4[ebp+4], al

; 25189: 			pwCount.h.sizeH     = HIBYTE(lOfs_Item);

  011b7	8b 45 e8	 mov	 eax, DWORD PTR _lOfs_Item$[ebp]
  011ba	c1 e8 08	 shr	 eax, 8
  011bd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  011c2	88 85 49 b1 ff
	ff		 mov	 BYTE PTR _pwCount$4[ebp+1], al

; 25190: 			pwCount.h.sizeL     = LOBYTE(lOfs_Item);

  011c8	8b 45 e8	 mov	 eax, DWORD PTR _lOfs_Item$[ebp]
  011cb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  011d0	88 85 4a b1 ff
	ff		 mov	 BYTE PTR _pwCount$4[ebp+2], al

; 25191: 			memcpy(ItemBuf, (char*)&pwCount, sizeof(pwCount));						

  011d6	6a 05		 push	 5
  011d8	8d 85 48 b1 ff
	ff		 lea	 eax, DWORD PTR _pwCount$4[ebp]
  011de	50		 push	 eax
  011df	8d 8d a8 b1 ff
	ff		 lea	 ecx, DWORD PTR _ItemBuf$[ebp]
  011e5	51		 push	 ecx
  011e6	e8 00 00 00 00	 call	 _memcpy
  011eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25192: 			DataSend(aIndex, ItemBuf, lOfs_Item);

  011ee	8b 45 e8	 mov	 eax, DWORD PTR _lOfs_Item$[ebp]
  011f1	50		 push	 eax
  011f2	8d 8d a8 b1 ff
	ff		 lea	 ecx, DWORD PTR _ItemBuf$[ebp]
  011f8	51		 push	 ecx
  011f9	0f bf 55 08	 movsx	 edx, WORD PTR _aIndex$[ebp]
  011fd	52		 push	 edx
  011fe	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01203	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN75@gObjViewpo:

; 25193: 		}
; 25194: 		//    ..
; 25195: 		if ( GuildInfoCount )

  01206	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GuildInfoCount@@3HA, 0 ; GuildInfoCount
  0120d	74 6a		 je	 SHORT $LN76@gObjViewpo

; 25196: 		{
; 25197: #ifdef MODIFY_GUILD_VIEWPORT_01_20040701
; 25198: 			PMSG_SIMPLE_GUILDVIEWPORT_COUNT pGVCount;
; 25199: 			pGVCount.h.headcode = 0x65;
; 25200: #else
; 25201: 			PMSG_GUILDVIEWPORT_COUNT pGVCount;
; 25202: 			pGVCount.h.headcode = 0x5A;

  0120f	c6 85 43 b1 ff
	ff 5a		 mov	 BYTE PTR _pGVCount$3[ebp+3], 90 ; 0000005aH

; 25203: #endif
; 25204: 			
; 25205: 			pGVCount.h.c		= PMHC_WORD;		

  01216	c6 85 40 b1 ff
	ff c2		 mov	 BYTE PTR _pGVCount$3[ebp], 194 ; 000000c2H

; 25206: 			pGVCount.h.sizeH	= HIBYTE( GuildInfoOfs );

  0121d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildInfoOfs@@3HA ; GuildInfoOfs
  01222	c1 e8 08	 shr	 eax, 8
  01225	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0122a	88 85 41 b1 ff
	ff		 mov	 BYTE PTR _pGVCount$3[ebp+1], al

; 25207: 			pGVCount.h.sizeL	= LOBYTE( GuildInfoOfs );

  01230	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildInfoOfs@@3HA ; GuildInfoOfs
  01235	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0123a	88 85 42 b1 ff
	ff		 mov	 BYTE PTR _pGVCount$3[ebp+2], al

; 25208: 			pGVCount.Count		= GuildInfoCount;

  01240	a0 00 00 00 00	 mov	 al, BYTE PTR ?GuildInfoCount@@3HA
  01245	88 85 44 b1 ff
	ff		 mov	 BYTE PTR _pGVCount$3[ebp+4], al

; 25209: 			memcpy(GuildInfoBuf, &pGVCount, sizeof(pGVCount));

  0124b	6a 05		 push	 5
  0124d	8d 85 40 b1 ff
	ff		 lea	 eax, DWORD PTR _pGVCount$3[ebp]
  01253	50		 push	 eax
  01254	68 00 00 00 00	 push	 OFFSET ?GuildInfoBuf@@3PAEA ; GuildInfoBuf
  01259	e8 00 00 00 00	 call	 _memcpy
  0125e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25210: 			DataSend(aIndex, GuildInfoBuf, GuildInfoOfs);

  01261	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildInfoOfs@@3HA ; GuildInfoOfs
  01266	50		 push	 eax
  01267	68 00 00 00 00	 push	 OFFSET ?GuildInfoBuf@@3PAEA ; GuildInfoBuf
  0126c	0f bf 4d 08	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  01270	51		 push	 ecx
  01271	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01276	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN76@gObjViewpo:

; 25211: 		}
; 25212: 
; 25213: #ifdef MODIFY_GUILD_VIEWPORT_01_20040701
; 25214: 		// 0x65  .
; 25215: #else
; 25216: 		//   .
; 25217: 		if( GuildUserCount )

  01279	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?GuildUserCount@@3HA, 0 ; GuildUserCount
  01280	74 6a		 je	 SHORT $LN1@gObjViewpo

; 25218: 		{
; 25219: 			PMSG_GUILDVIEWPORT_USERCOUNT pGUCount;
; 25220: 			pGUCount.h.c		= PMHC_WORD;

  01282	c6 85 38 b1 ff
	ff c2		 mov	 BYTE PTR _pGUCount$2[ebp], 194 ; 000000c2H

; 25221: 			pGUCount.h.headcode = 0x5B;

  01289	c6 85 3b b1 ff
	ff 5b		 mov	 BYTE PTR _pGUCount$2[ebp+3], 91 ; 0000005bH

; 25222: 			pGUCount.h.sizeH	= HIBYTE( GuildUserOfs );

  01290	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildUserOfs@@3HA ; GuildUserOfs
  01295	c1 e8 08	 shr	 eax, 8
  01298	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0129d	88 85 39 b1 ff
	ff		 mov	 BYTE PTR _pGUCount$2[ebp+1], al

; 25223: 			pGUCount.h.sizeL	= LOBYTE( GuildUserOfs );

  012a3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildUserOfs@@3HA ; GuildUserOfs
  012a8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  012ad	88 85 3a b1 ff
	ff		 mov	 BYTE PTR _pGUCount$2[ebp+2], al

; 25224: 			pGUCount.Count		= GuildUserCount;

  012b3	a0 00 00 00 00	 mov	 al, BYTE PTR ?GuildUserCount@@3HA
  012b8	88 85 3c b1 ff
	ff		 mov	 BYTE PTR _pGUCount$2[ebp+4], al

; 25225: 			memcpy(GuildUserBuf, &pGUCount, sizeof(pGUCount));

  012be	6a 05		 push	 5
  012c0	8d 85 38 b1 ff
	ff		 lea	 eax, DWORD PTR _pGUCount$2[ebp]
  012c6	50		 push	 eax
  012c7	68 00 00 00 00	 push	 OFFSET ?GuildUserBuf@@3PAEA ; GuildUserBuf
  012cc	e8 00 00 00 00	 call	 _memcpy
  012d1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25226: 			DataSend(aIndex, GuildUserBuf, GuildUserOfs);			

  012d4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GuildUserOfs@@3HA ; GuildUserOfs
  012d9	50		 push	 eax
  012da	68 00 00 00 00	 push	 OFFSET ?GuildUserBuf@@3PAEA ; GuildUserBuf
  012df	0f bf 4d 08	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  012e3	51		 push	 ecx
  012e4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  012e9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gObjViewpo:

; 25227: 		}
; 25228: #endif
; 25229: 		
; 25230: 	}	
; 25231: }

  012ec	5f		 pop	 edi
  012ed	5e		 pop	 esi
  012ee	5b		 pop	 ebx
  012ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  012f2	33 cd		 xor	 ecx, ebp
  012f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  012f9	8b e5		 mov	 esp, ebp
  012fb	5d		 pop	 ebp
  012fc	c3		 ret	 0
  012fd	0f 1f 00	 npad	 3
$LN87@gObjViewpo:
  01300	00 00 00 00	 DD	 $LN37@gObjViewpo
  01304	00 00 00 00	 DD	 $LN57@gObjViewpo
  01308	00 00 00 00	 DD	 $LN57@gObjViewpo
  0130c	00 00 00 00	 DD	 $LN36@gObjViewpo
  01310	00 00 00 00	 DD	 $LN65@gObjViewpo
?gObjViewportListProtocol@@YAXF@Z ENDP			; gObjViewportListProtocol
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjViewportListDestroy@@YAXF@Z
_TEXT	SEGMENT
tv68 = -92						; size = 4
tv137 = -88						; size = 4
tv69 = -88						; size = 4
_mapnum$1 = -20						; size = 4
_MVL$ = -16						; size = 4
_lpObj$ = -12						; size = 4
_n$ = -8						; size = 4
_tObjNum$ = -4						; size = 2
_aIndex$ = 8						; size = 2
?gObjViewportListDestroy@@YAXF@Z PROC			; gObjViewportListDestroy, COMDAT

; 20940: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 20941: 	short tObjNum;
; 20942: 	int   n;
; 20943: 	
; 20944: 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT) ) return;

  00009	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0000d	85 c0		 test	 eax, eax
  0000f	7d 09		 jge	 SHORT $LN35@gObjViewpo
  00011	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00018	eb 22		 jmp	 SHORT $LN36@gObjViewpo
$LN35@gObjViewpo:
  0001a	0f bf 4d 08	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  0001e	81 f9 e7 1c 00
	00		 cmp	 ecx, 7399		; 00001ce7H
  00024	7e 09		 jle	 SHORT $LN33@gObjViewpo
  00026	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  0002d	eb 07		 jmp	 SHORT $LN34@gObjViewpo
$LN33@gObjViewpo:
  0002f	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
$LN34@gObjViewpo:
  00036	8b 55 a4	 mov	 edx, DWORD PTR tv68[ebp]
  00039	89 55 a8	 mov	 DWORD PTR tv69[ebp], edx
$LN36@gObjViewpo:
  0003c	83 7d a8 00	 cmp	 DWORD PTR tv69[ebp], 0
  00040	75 05		 jne	 SHORT $LN7@gObjViewpo
  00042	e9 d6 03 00 00	 jmp	 $LN1@gObjViewpo
$LN7@gObjViewpo:

; 20945: 
; 20946: 	if( gObj[aIndex].Connected < CSS_GAMEPLAYING ) return;

  00047	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0004b	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00051	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00057	83 7c 0a 04 03	 cmp	 DWORD PTR [edx+ecx+4], 3
  0005c	7d 05		 jge	 SHORT $LN8@gObjViewpo
  0005e	e9 ba 03 00 00	 jmp	 $LN1@gObjViewpo
$LN8@gObjViewpo:

; 20947: 	LPOBJECTSTRUCT	lpObj = &gObj[aIndex];

  00063	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00067	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0006d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00073	89 4d f4	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 20948: 	
; 20949: 	int MVL = MAXVIEWPORTOBJECT;

  00076	c7 45 f0 4b 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 75 ; 0000004bH

; 20950: 	if( lpObj->Type == OBJTYPE_MONSTER ) MVL = MAX_MONVIEWPORTOBJECT;

  0007d	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00080	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00084	83 f9 02	 cmp	 ecx, 2
  00087	75 07		 jne	 SHORT $LN9@gObjViewpo
  00089	c7 45 f0 14 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 20 ; 00000014H
$LN9@gObjViewpo:

; 20951: 
; 20952: 	for( n=0; n<MVL; n++)

  00090	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00097	eb 09		 jmp	 SHORT $LN4@gObjViewpo
$LN2@gObjViewpo:
  00099	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0009c	83 c0 01	 add	 eax, 1
  0009f	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjViewpo:
  000a2	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000a5	3b 45 f0	 cmp	 eax, DWORD PTR _MVL$[ebp]
  000a8	0f 8d 6f 03 00
	00		 jge	 $LN1@gObjViewpo

; 20953: 	{
; 20954: 		//   ..
; 20955: 		if( (lpObj->VpPlayer[n].state == STVP_CREATE ||

  000ae	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  000b2	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000b5	0f be 94 01 64
	03 00 00	 movsx	 edx, BYTE PTR [ecx+eax+868]
  000bd	83 fa 01	 cmp	 edx, 1
  000c0	74 18		 je	 SHORT $LN11@gObjViewpo
  000c2	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  000c6	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000c9	0f be 94 01 64
	03 00 00	 movsx	 edx, BYTE PTR [ecx+eax+868]
  000d1	83 fa 02	 cmp	 edx, 2
  000d4	0f 85 53 02 00
	00		 jne	 $LN10@gObjViewpo
$LN11@gObjViewpo:

; 20956: 			lpObj->VpPlayer[n].state == STVP_PLAYING)) 
; 20957: 		{
; 20958: 			tObjNum = lpObj->VpPlayer[n].number;

  000da	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  000de	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000e1	66 8b 94 01 66
	03 00 00	 mov	 dx, WORD PTR [ecx+eax+870]
  000e9	66 89 55 fc	 mov	 WORD PTR _tObjNum$[ebp], dx

; 20959: 
; 20960: 			switch( lpObj->VpPlayer[n].type )

  000ed	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  000f1	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000f4	8a 94 01 68 03
	00 00		 mov	 dl, BYTE PTR [ecx+eax+872]
  000fb	88 55 a8	 mov	 BYTE PTR tv137[ebp], dl
  000fe	80 7d a8 05	 cmp	 BYTE PTR tv137[ebp], 5
  00102	74 05		 je	 SHORT $LN12@gObjViewpo
  00104	e9 35 01 00 00	 jmp	 $LN21@gObjViewpo
$LN12@gObjViewpo:

; 20961: 			{
; 20962: 			case OBJTYPE_ITEM :	// .
; 20963: 				{
; 20964: 				int mapnum = lpObj->MapNumber;

  00109	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010c	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00113	89 4d ec	 mov	 DWORD PTR _mapnum$1[ebp], ecx

; 20965: 				//  ...
; 20966: 				
; 20967: 				if( MapC[mapnum].m_cItem[tObjNum].IsItem() == TRUE )

  00116	69 45 ec 8c 04
	05 00		 imul	 eax, DWORD PTR _mapnum$1[ebp], 328844
  0011d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00123	0f bf 4d fc	 movsx	 ecx, WORD PTR _tObjNum$[ebp]
  00127	69 d1 48 04 00
	00		 imul	 edx, ecx, 1096
  0012d	8d 4c 10 24	 lea	 ecx, DWORD PTR [eax+edx+36]
  00131	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00136	83 f8 01	 cmp	 eax, 1
  00139	0f 85 94 00 00
	00		 jne	 $LN13@gObjViewpo

; 20968: 				{
; 20969: 					// ...   .. ..
; 20970: 					if( MapC[mapnum].m_cItem[tObjNum].m_State == OBJST_DIECMD )//||

  0013f	69 45 ec 8c 04
	05 00		 imul	 eax, DWORD PTR _mapnum$1[ebp], 328844
  00146	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0014c	0f bf 4d fc	 movsx	 ecx, WORD PTR _tObjNum$[ebp]
  00150	69 d1 48 04 00
	00		 imul	 edx, ecx, 1096
  00156	83 bc 10 d0 00
	00 00 08	 cmp	 DWORD PTR [eax+edx+208], 8
  0015e	75 11		 jne	 SHORT $LN15@gObjViewpo

; 20971: 					{
; 20972: 						lpObj->VpPlayer[n].state = STVP_DESTROY;

  00160	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  00164	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00167	c6 84 01 64 03
	00 00 03	 mov	 BYTE PTR [ecx+eax+868], 3

; 20973: 					}

  0016f	eb 60		 jmp	 SHORT $LN16@gObjViewpo
$LN15@gObjViewpo:

; 20974: 					else
; 20975: 					{
; 20976: 						if( gObjCheckViewport(aIndex, MapC[mapnum].m_cItem[tObjNum].px, MapC[mapnum].m_cItem[tObjNum].py) == FALSE )

  00171	69 45 ec 8c 04
	05 00		 imul	 eax, DWORD PTR _mapnum$1[ebp], 328844
  00178	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0017e	0f bf 4d fc	 movsx	 ecx, WORD PTR _tObjNum$[ebp]
  00182	69 d1 48 04 00
	00		 imul	 edx, ecx, 1096
  00188	0f b6 84 10 cd
	00 00 00	 movzx	 eax, BYTE PTR [eax+edx+205]
  00190	50		 push	 eax
  00191	69 4d ec 8c 04
	05 00		 imul	 ecx, DWORD PTR _mapnum$1[ebp], 328844
  00198	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0019e	0f bf 55 fc	 movsx	 edx, WORD PTR _tObjNum$[ebp]
  001a2	69 c2 48 04 00
	00		 imul	 eax, edx, 1096
  001a8	0f b6 8c 01 cc
	00 00 00	 movzx	 ecx, BYTE PTR [ecx+eax+204]
  001b0	51		 push	 ecx
  001b1	0f bf 55 08	 movsx	 edx, WORD PTR _aIndex$[ebp]
  001b5	52		 push	 edx
  001b6	e8 00 00 00 00	 call	 ?gObjCheckViewport@@YAHHHH@Z ; gObjCheckViewport
  001bb	83 c4 0c	 add	 esp, 12			; 0000000cH
  001be	85 c0		 test	 eax, eax
  001c0	75 0f		 jne	 SHORT $LN16@gObjViewpo

; 20977: 						{ //   
; 20978: 							lpObj->VpPlayer[n].state = STVP_DESTROY;

  001c2	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  001c6	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001c9	c6 84 01 64 03
	00 00 03	 mov	 BYTE PTR [ecx+eax+868], 3
$LN16@gObjViewpo:

; 20979: 						}
; 20980: 					}
; 20981: 				}

  001d1	eb 66		 jmp	 SHORT $LN14@gObjViewpo
$LN13@gObjViewpo:

; 20982: 				else if( MapC[mapnum].m_cItem[tObjNum].live == 0 ||

  001d3	69 45 ec 8c 04
	05 00		 imul	 eax, DWORD PTR _mapnum$1[ebp], 328844
  001da	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  001e0	0f bf 4d fc	 movsx	 ecx, WORD PTR _tObjNum$[ebp]
  001e4	69 d1 48 04 00
	00		 imul	 edx, ecx, 1096
  001ea	0f b6 84 10 ce
	00 00 00	 movzx	 eax, BYTE PTR [eax+edx+206]
  001f2	85 c0		 test	 eax, eax
  001f4	74 23		 je	 SHORT $LN20@gObjViewpo
  001f6	69 45 ec 8c 04
	05 00		 imul	 eax, DWORD PTR _mapnum$1[ebp], 328844
  001fd	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00203	0f bf 4d fc	 movsx	 ecx, WORD PTR _tObjNum$[ebp]
  00207	69 d1 48 04 00
	00		 imul	 edx, ecx, 1096
  0020d	0f b6 84 10 cf
	00 00 00	 movzx	 eax, BYTE PTR [eax+edx+207]
  00215	85 c0		 test	 eax, eax
  00217	75 11		 jne	 SHORT $LN18@gObjViewpo
$LN20@gObjViewpo:

; 20983: 						 MapC[mapnum].m_cItem[tObjNum].Give == 0 )
; 20984: 				{
; 20985: 					lpObj->VpPlayer[n].state = STVP_DESTROY;					

  00219	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  0021d	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00220	c6 84 01 64 03
	00 00 03	 mov	 BYTE PTR [ecx+eax+868], 3

; 20986: 				}

  00228	eb 0f		 jmp	 SHORT $LN14@gObjViewpo
$LN18@gObjViewpo:

; 20987: 				else 
; 20988: 				{					
; 20989: 					//  .
; 20990: 					lpObj->VpPlayer[n].state = STVP_DESTROY;

  0022a	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  0022e	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00231	c6 84 01 64 03
	00 00 03	 mov	 BYTE PTR [ecx+eax+868], 3
$LN14@gObjViewpo:

; 20991: 				}
; 20992: 				}
; 20993: 				break;

  00239	e9 ef 00 00 00	 jmp	 $LN10@gObjViewpo
$LN21@gObjViewpo:

; 20994: 			//case OBJTYPE_CHARACTER :
; 20995: 			default:
; 20996: 				//      .
; 20997: 				if( gObj[tObjNum].m_State == OBJST_CREATE && 

  0023e	0f bf 45 fc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00242	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00248	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0024e	83 bc 0a b8 01
	00 00 01	 cmp	 DWORD PTR [edx+ecx+440], 1
  00256	75 28		 jne	 SHORT $LN22@gObjViewpo
  00258	0f bf 45 fc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  0025c	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00262	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00268	0f b6 44 0a 66	 movzx	 eax, BYTE PTR [edx+ecx+102]
  0026d	85 c0		 test	 eax, eax
  0026f	75 0f		 jne	 SHORT $LN22@gObjViewpo

; 20998: 					gObj[tObjNum].Live == 0 ) 
; 20999: 				{
; 21000: 					lpObj->VpPlayer[n].state = STVP_DESTROY;

  00271	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  00275	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00278	c6 84 01 64 03
	00 00 03	 mov	 BYTE PTR [ecx+eax+868], 3
$LN22@gObjViewpo:

; 21001: 				}
; 21002: 				// OBJST_DELCMD
; 21003: 				if( gObj[tObjNum].Connected == 0 || 
; 21004: 					gObj[tObjNum].m_State == OBJST_DIECMD ||

  00280	0f bf 45 fc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00284	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  0028a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00290	83 7c 0a 04 00	 cmp	 DWORD PTR [edx+ecx+4], 0
  00295	74 34		 je	 SHORT $LN25@gObjViewpo
  00297	0f bf 45 fc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  0029b	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  002a1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002a7	83 bc 0a b8 01
	00 00 08	 cmp	 DWORD PTR [edx+ecx+440], 8
  002af	74 1a		 je	 SHORT $LN25@gObjViewpo
  002b1	0f bf 45 fc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  002b5	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  002bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c1	83 bc 0a b8 01
	00 00 20	 cmp	 DWORD PTR [edx+ecx+440], 32 ; 00000020H
  002c9	75 11		 jne	 SHORT $LN23@gObjViewpo
$LN25@gObjViewpo:

; 21005: #ifdef MODIFY_NEW_MONSTER_SKILL_01_20060724
; 21006: 					gObj[tObjNum].Teleport != 0 || //   
; 21007: #endif
; 21008: 					gObj[tObjNum].m_State == OBJST_DELCMD )	
; 21009: 				{
; 21010: 					lpObj->VpPlayer[n].state = STVP_DESTROY;

  002cb	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  002cf	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002d2	c6 84 01 64 03
	00 00 03	 mov	 BYTE PTR [ecx+eax+868], 3

; 21011: 					//LogAddC(LOGC_RED,"  . %s %s %d", gObj[aIndex].Name, gObj[tObjNum].Name, __LINE__);
; 21012: 				}

  002da	eb 51		 jmp	 SHORT $LN10@gObjViewpo
$LN23@gObjViewpo:

; 21013: 				else
; 21014: 				{
; 21015: 					if( gObjCheckViewport(aIndex, gObj[tObjNum].X, gObj[tObjNum].Y) == FALSE )

  002dc	0f bf 45 fc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  002e0	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  002e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ec	0f bf 84 0a 06
	01 00 00	 movsx	 eax, WORD PTR [edx+ecx+262]
  002f4	50		 push	 eax
  002f5	0f bf 4d fc	 movsx	 ecx, WORD PTR _tObjNum$[ebp]
  002f9	69 d1 a0 1b 00
	00		 imul	 edx, ecx, 7072
  002ff	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00304	0f bf 8c 10 04
	01 00 00	 movsx	 ecx, WORD PTR [eax+edx+260]
  0030c	51		 push	 ecx
  0030d	0f bf 55 08	 movsx	 edx, WORD PTR _aIndex$[ebp]
  00311	52		 push	 edx
  00312	e8 00 00 00 00	 call	 ?gObjCheckViewport@@YAHHHH@Z ; gObjCheckViewport
  00317	83 c4 0c	 add	 esp, 12			; 0000000cH
  0031a	85 c0		 test	 eax, eax
  0031c	75 0f		 jne	 SHORT $LN10@gObjViewpo

; 21016: 					{ //    
; 21017: 						lpObj->VpPlayer[n].state = STVP_DESTROY;

  0031e	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  00322	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00325	c6 84 01 64 03
	00 00 03	 mov	 BYTE PTR [ecx+eax+868], 3
$LN10@gObjViewpo:

; 21018: 						
; 21019: #ifdef 	ADD_NEW_MONSTER_SYSTEM_02_20050725
; 21020: 						// Agro System -     .
; 21021: 					  	if( (lpObj->Type == OBJTYPE_MONSTER || lpObj->Type == OBJTYPE_NPC)
; 21022: 							&& gObj[tObjNum].Type == OBJTYPE_CHARACTER )
; 21023: 						{
; 21024: 							if( lpObj->m_iCurrentAI )
; 21025: 								lpObj->m_Agro.DelAgro(tObjNum);
; 21026: 						}	
; 21027: #endif
; 21028: 
; 21029: 					}
; 21030: 				}
; 21031: 				break;
; 21032: 			}
; 21033: 			
; 21034: 		}
; 21035: 		
; 21036: 		//     
; 21037: 		if( (lpObj->VpPlayer2[n].state == STVP_CREATE ||

  0032d	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  00331	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00334	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  0033c	83 fa 01	 cmp	 edx, 1
  0033f	74 18		 je	 SHORT $LN28@gObjViewpo
  00341	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  00345	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00348	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  00350	83 fa 02	 cmp	 edx, 2
  00353	0f 85 bf 00 00
	00		 jne	 $LN27@gObjViewpo
$LN28@gObjViewpo:

; 21038: 			lpObj->VpPlayer2[n].state == STVP_PLAYING)) 
; 21039: 		{
; 21040: 			tObjNum = lpObj->VpPlayer2[n].number;

  00359	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  0035d	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00360	66 8b 94 01 ea
	06 00 00	 mov	 dx, WORD PTR [ecx+eax+1770]
  00368	66 89 55 fc	 mov	 WORD PTR _tObjNum$[ebp], dx

; 21041: 			if( gObj[tObjNum].Connected < 3 )

  0036c	0f bf 45 fc	 movsx	 eax, WORD PTR _tObjNum$[ebp]
  00370	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00376	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0037c	83 7c 0a 04 03	 cmp	 DWORD PTR [edx+ecx+4], 3
  00381	7d 38		 jge	 SHORT $LN29@gObjViewpo

; 21042: 			{
; 21043: 				lpObj->VpPlayer2[n].state = STVP_NONE;

  00383	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  00387	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0038a	c6 84 01 e8 06
	00 00 00	 mov	 BYTE PTR [ecx+eax+1768], 0

; 21044: 				lpObj->VpPlayer2[n].number= -1;

  00392	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  00396	83 c9 ff	 or	 ecx, -1
  00399	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0039c	66 89 8c 02 ea
	06 00 00	 mov	 WORD PTR [edx+eax+1770], cx

; 21045: 				lpObj->VPCount2--;

  003a4	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003a7	8b 88 70 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2672]
  003ad	83 e9 01	 sub	 ecx, 1
  003b0	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003b3	89 8a 70 0a 00
	00		 mov	 DWORD PTR [edx+2672], ecx

; 21046: 			}

  003b9	eb 5d		 jmp	 SHORT $LN27@gObjViewpo
$LN29@gObjViewpo:

; 21047: 			else if( gObjCheckViewport(tObjNum, lpObj->X, lpObj->Y) == FALSE )

  003bb	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003be	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  003c5	51		 push	 ecx
  003c6	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003c9	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  003d0	50		 push	 eax
  003d1	0f bf 4d fc	 movsx	 ecx, WORD PTR _tObjNum$[ebp]
  003d5	51		 push	 ecx
  003d6	e8 00 00 00 00	 call	 ?gObjCheckViewport@@YAHHHH@Z ; gObjCheckViewport
  003db	83 c4 0c	 add	 esp, 12			; 0000000cH
  003de	85 c0		 test	 eax, eax
  003e0	75 36		 jne	 SHORT $LN27@gObjViewpo

; 21048: 			{ //          
; 21049: 				lpObj->VpPlayer2[n].state = STVP_NONE;//STVP_DESTROY;

  003e2	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  003e6	8b 4d f4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003e9	c6 84 01 e8 06
	00 00 00	 mov	 BYTE PTR [ecx+eax+1768], 0

; 21050: 				lpObj->VpPlayer2[n].number= -1;

  003f1	6b 45 f8 0c	 imul	 eax, DWORD PTR _n$[ebp], 12
  003f5	83 c9 ff	 or	 ecx, -1
  003f8	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003fb	66 89 8c 02 ea
	06 00 00	 mov	 WORD PTR [edx+eax+1770], cx

; 21051: 				lpObj->VPCount2--;

  00403	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00406	8b 88 70 0a 00
	00		 mov	 ecx, DWORD PTR [eax+2672]
  0040c	83 e9 01	 sub	 ecx, 1
  0040f	8b 55 f4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00412	89 8a 70 0a 00
	00		 mov	 DWORD PTR [edx+2672], ecx
$LN27@gObjViewpo:

; 21052: 			}
; 21053: 		}
; 21054: 	} // for

  00418	e9 7c fc ff ff	 jmp	 $LN2@gObjViewpo
$LN1@gObjViewpo:

; 21055: }

  0041d	5f		 pop	 edi
  0041e	5e		 pop	 esi
  0041f	5b		 pop	 ebx
  00420	8b e5		 mov	 esp, ebp
  00422	5d		 pop	 ebp
  00423	c3		 ret	 0
?gObjViewportListDestroy@@YAXF@Z ENDP			; gObjViewportListDestroy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjViewportListCreate@@YAXF@Z
_TEXT	SEGMENT
tv68 = -100						; size = 4
tv69 = -96						; size = 4
_lpTempObj$ = -28					; size = 4
_a$ = -24						; size = 4
_lpMapC$1 = -20						; size = 4
_mapnum$ = -16						; size = 4
_lpObj$ = -12						; size = 4
_n$ = -8						; size = 4
_result$ = -4						; size = 4
_aIndex$ = 8						; size = 2
?gObjViewportListCreate@@YAXF@Z PROC			; gObjViewportListCreate, COMDAT

; 20606: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 20607: 	int result;
; 20608: 	int n;
; 20609: 	LPOBJECTSTRUCT	lpObj;
; 20610: 	
; 20611: 	if(!CHECK_LIMIT(aIndex, MAX_OBJECT) ) return;

  00009	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0000d	85 c0		 test	 eax, eax
  0000f	7d 09		 jge	 SHORT $LN36@gObjViewpo
  00011	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  00018	eb 22		 jmp	 SHORT $LN37@gObjViewpo
$LN36@gObjViewpo:
  0001a	0f bf 4d 08	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  0001e	81 f9 e7 1c 00
	00		 cmp	 ecx, 7399		; 00001ce7H
  00024	7e 09		 jle	 SHORT $LN34@gObjViewpo
  00026	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  0002d	eb 07		 jmp	 SHORT $LN35@gObjViewpo
$LN34@gObjViewpo:
  0002f	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
$LN35@gObjViewpo:
  00036	8b 55 9c	 mov	 edx, DWORD PTR tv68[ebp]
  00039	89 55 a0	 mov	 DWORD PTR tv69[ebp], edx
$LN37@gObjViewpo:
  0003c	83 7d a0 00	 cmp	 DWORD PTR tv69[ebp], 0
  00040	75 05		 jne	 SHORT $LN11@gObjViewpo
  00042	e9 ea 02 00 00	 jmp	 $LN1@gObjViewpo
$LN11@gObjViewpo:

; 20612: 
; 20613: 	lpObj = &gObj[aIndex];

  00047	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0004b	69 c8 a0 1b 00
	00		 imul	 ecx, eax, 7072
  00051	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00057	89 4d f4	 mov	 DWORD PTR _lpObj$[ebp], ecx

; 20614: 
; 20615: 	if( lpObj->Connected < CSS_GAMEPLAYING ) return;

  0005a	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005d	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00061	7d 05		 jge	 SHORT $LN12@gObjViewpo
  00063	e9 c9 02 00 00	 jmp	 $LN1@gObjViewpo
$LN12@gObjViewpo:

; 20616: 	if( lpObj->RegenOk > 0 ) return;

  00068	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006b	0f be 88 ff 01
	00 00		 movsx	 ecx, BYTE PTR [eax+511]
  00072	85 c9		 test	 ecx, ecx
  00074	7e 05		 jle	 SHORT $LN13@gObjViewpo
  00076	e9 b6 02 00 00	 jmp	 $LN1@gObjViewpo
$LN13@gObjViewpo:

; 20617: 	
; 20618: 	int mapnum = lpObj->MapNumber;

  0007b	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007e	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00085	89 4d f0	 mov	 DWORD PTR _mapnum$[ebp], ecx

; 20619: 	
; 20620: 	gItemLoop2 = 0;

  00088	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gItemLoop2@@3HA, 0 ; gItemLoop2

; 20621: 	
; 20622: 	
; 20623: 	if( lpObj->Type == OBJTYPE_CHARACTER )

  00092	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00095	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00099	83 f9 01	 cmp	 ecx, 1
  0009c	0f 85 d1 00 00
	00		 jne	 $LN14@gObjViewpo

; 20624: 	{
; 20625: 		MapClass * lpMapC = &MapC[mapnum];;

  000a2	69 45 f0 8c 04
	05 00		 imul	 eax, DWORD PTR _mapnum$[ebp], 328844
  000a9	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000af	89 45 ec	 mov	 DWORD PTR _lpMapC$1[ebp], eax

; 20626: 		//  
; 20627: 		for( n=0; n<MAX_MAPITEM; n++)

  000b2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  000b9	eb 09		 jmp	 SHORT $LN4@gObjViewpo
$LN2@gObjViewpo:
  000bb	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000be	83 c0 01	 add	 eax, 1
  000c1	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjViewpo:
  000c4	81 7d f8 2c 01
	00 00		 cmp	 DWORD PTR _n$[ebp], 300	; 0000012cH
  000cb	0f 8d a2 00 00
	00		 jge	 $LN14@gObjViewpo

; 20628: 		{
; 20629: 			if( lpMapC->m_cItem[n].live )

  000d1	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 1096
  000d8	8b 4d ec	 mov	 ecx, DWORD PTR _lpMapC$1[ebp]
  000db	0f b6 94 01 ce
	00 00 00	 movzx	 edx, BYTE PTR [ecx+eax+206]
  000e3	85 d2		 test	 edx, edx
  000e5	0f 84 83 00 00
	00		 je	 $LN15@gObjViewpo

; 20630: 			{
; 20631: 				gItemLoop2++;

  000eb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gItemLoop2@@3HA ; gItemLoop2
  000f0	83 c0 01	 add	 eax, 1
  000f3	a3 00 00 00 00	 mov	 DWORD PTR ?gItemLoop2@@3HA, eax ; gItemLoop2

; 20632: 				if( lpMapC->m_cItem[n].m_State == OBJST_CREATE ||

  000f8	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 1096
  000ff	8b 4d ec	 mov	 ecx, DWORD PTR _lpMapC$1[ebp]
  00102	83 bc 01 d0 00
	00 00 01	 cmp	 DWORD PTR [ecx+eax+208], 1
  0010a	74 14		 je	 SHORT $LN17@gObjViewpo
  0010c	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 1096
  00113	8b 4d ec	 mov	 ecx, DWORD PTR _lpMapC$1[ebp]
  00116	83 bc 01 d0 00
	00 00 02	 cmp	 DWORD PTR [ecx+eax+208], 2
  0011e	75 4e		 jne	 SHORT $LN15@gObjViewpo
$LN17@gObjViewpo:

; 20633: 					lpMapC->m_cItem[n].m_State == OBJST_PLAYING )
; 20634: 				{
; 20635: 					//
; 20636: 					//     
; 20637: 					if( gObjCheckViewport(aIndex, lpMapC->m_cItem[n].px, lpMapC->m_cItem[n].py) == TRUE )

  00120	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 1096
  00127	8b 4d ec	 mov	 ecx, DWORD PTR _lpMapC$1[ebp]
  0012a	0f b6 94 01 cd
	00 00 00	 movzx	 edx, BYTE PTR [ecx+eax+205]
  00132	52		 push	 edx
  00133	69 45 f8 48 04
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 1096
  0013a	8b 4d ec	 mov	 ecx, DWORD PTR _lpMapC$1[ebp]
  0013d	0f b6 94 01 cc
	00 00 00	 movzx	 edx, BYTE PTR [ecx+eax+204]
  00145	52		 push	 edx
  00146	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0014a	50		 push	 eax
  0014b	e8 00 00 00 00	 call	 ?gObjCheckViewport@@YAHHHH@Z ; gObjCheckViewport
  00150	83 c4 0c	 add	 esp, 12			; 0000000cH
  00153	83 f8 01	 cmp	 eax, 1
  00156	75 16		 jne	 SHORT $LN15@gObjViewpo

; 20638: 					{
; 20639: 						//      .
; 20640: 						result = ViewportAdd(aIndex, n, OBJTYPE_ITEM);

  00158	6a 05		 push	 5
  0015a	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0015d	50		 push	 eax
  0015e	0f bf 4d 08	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  00162	51		 push	 ecx
  00163	e8 00 00 00 00	 call	 ?ViewportAdd@@YAHHHH@Z	; ViewportAdd
  00168	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016b	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax
$LN15@gObjViewpo:

; 20641: 					}
; 20642: 				}
; 20643: 			}
; 20644: 		}

  0016e	e9 48 ff ff ff	 jmp	 $LN2@gObjViewpo
$LN14@gObjViewpo:

; 20645: 	}
; 20646: 
; 20647: 	if( aIndex == 0 )

  00173	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00177	85 c0		 test	 eax, eax
  00179	75 1d		 jne	 SHORT $LN19@gObjViewpo

; 20648: 	{
; 20649: 	//if( gItemLoop2 > gItemLoopMax )
; 20650: 	//{
; 20651: 		gItemLoopMax    = gItemLoop2;

  0017b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gItemLoop2@@3HA ; gItemLoop2
  00180	a3 00 00 00 00	 mov	 DWORD PTR ?gItemLoopMax@@3HA, eax ; gItemLoopMax

; 20652: 		gItemLoop       = gItemLoop2;

  00185	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gItemLoop2@@3HA ; gItemLoop2
  0018a	a3 00 00 00 00	 mov	 DWORD PTR ?gItemLoop@@3HA, eax ; gItemLoop

; 20653: 		gCurPaintPlayer = aIndex;

  0018f	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  00193	a3 00 00 00 00	 mov	 DWORD PTR ?gCurPaintPlayer@@3HA, eax ; gCurPaintPlayer
$LN19@gObjViewpo:

; 20654: 	}
; 20655: 	/*if( aIndex == gCurPaintPlayer )	
; 20656: 	{
; 20657: 		gItemLoop = gItemLoop2;
; 20658: 	}
; 20659: 	*/
; 20660: 
; 20661: 	int a = 1;

  00198	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _a$[ebp], 1

; 20662: 	LPOBJECTSTRUCT	lpTempObj;
; 20663: 		//    
; 20664: 	if( lpObj->Type == OBJTYPE_CHARACTER )

  0019f	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a2	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  001a6	83 f9 01	 cmp	 ecx, 1
  001a9	0f 85 b6 00 00
	00		 jne	 $LN20@gObjViewpo

; 20665: 	{
; 20666: 		for( n=0; n<MAX_OBJECT; n++)

  001af	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  001b6	eb 09		 jmp	 SHORT $LN7@gObjViewpo
$LN5@gObjViewpo:
  001b8	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  001bb	83 c0 01	 add	 eax, 1
  001be	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN7@gObjViewpo:
  001c1	81 7d f8 e8 1c
	00 00		 cmp	 DWORD PTR _n$[ebp], 7400 ; 00001ce8H
  001c8	0f 8d 92 00 00
	00		 jge	 $LN6@gObjViewpo

; 20667: 		{	
; 20668: 			lpTempObj = &gObj[n];

  001ce	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  001d5	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001db	89 45 e4	 mov	 DWORD PTR _lpTempObj$[ebp], eax

; 20669: 			if( (lpTempObj->Connected == CSS_GAMEPLAYING) &&  ( aIndex != n ) )

  001de	8b 45 e4	 mov	 eax, DWORD PTR _lpTempObj$[ebp]
  001e1	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  001e5	75 74		 jne	 SHORT $LN22@gObjViewpo
  001e7	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  001eb	3b 45 f8	 cmp	 eax, DWORD PTR _n$[ebp]
  001ee	74 6b		 je	 SHORT $LN22@gObjViewpo

; 20670: 			{ //  ..  ..
; 20671: 				if( lpTempObj->m_State == OBJST_CREATE ||

  001f0	8b 45 e4	 mov	 eax, DWORD PTR _lpTempObj$[ebp]
  001f3	83 b8 b8 01 00
	00 01		 cmp	 DWORD PTR [eax+440], 1
  001fa	74 0c		 je	 SHORT $LN24@gObjViewpo
  001fc	8b 45 e4	 mov	 eax, DWORD PTR _lpTempObj$[ebp]
  001ff	83 b8 b8 01 00
	00 02		 cmp	 DWORD PTR [eax+440], 2
  00206	75 53		 jne	 SHORT $LN22@gObjViewpo
$LN24@gObjViewpo:

; 20672: 					lpTempObj->m_State == OBJST_PLAYING )
; 20673: 				{
; 20674: 					if( mapnum == lpTempObj->MapNumber ) 

  00208	8b 45 e4	 mov	 eax, DWORD PTR _lpTempObj$[ebp]
  0020b	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00212	39 4d f0	 cmp	 DWORD PTR _mapnum$[ebp], ecx
  00215	75 44		 jne	 SHORT $LN22@gObjViewpo

; 20675: 					{ //   
; 20676: 						if( gObjCheckViewport(aIndex, lpTempObj->X, lpTempObj->Y) == TRUE )

  00217	8b 45 e4	 mov	 eax, DWORD PTR _lpTempObj$[ebp]
  0021a	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00221	51		 push	 ecx
  00222	8b 55 e4	 mov	 edx, DWORD PTR _lpTempObj$[ebp]
  00225	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  0022c	50		 push	 eax
  0022d	0f bf 4d 08	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  00231	51		 push	 ecx
  00232	e8 00 00 00 00	 call	 ?gObjCheckViewport@@YAHHHH@Z ; gObjCheckViewport
  00237	83 c4 0c	 add	 esp, 12			; 0000000cH
  0023a	83 f8 01	 cmp	 eax, 1
  0023d	75 1c		 jne	 SHORT $LN22@gObjViewpo

; 20677: 						{ //   ...
; 20678: 							result = ViewportAdd(aIndex, n, lpTempObj->Type);

  0023f	8b 45 e4	 mov	 eax, DWORD PTR _lpTempObj$[ebp]
  00242	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00246	51		 push	 ecx
  00247	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  0024a	52		 push	 edx
  0024b	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  0024f	50		 push	 eax
  00250	e8 00 00 00 00	 call	 ?ViewportAdd@@YAHHHH@Z	; ViewportAdd
  00255	83 c4 0c	 add	 esp, 12			; 0000000cH
  00258	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax
$LN22@gObjViewpo:

; 20679: 	#ifdef MODIFY_MOVEMAP_RESET_VIEWPORT_BUGFIX_20060511
; 20680: 							result = ViewportAdd2(n, aIndex, gObj[aIndex].Type);
; 20681: 	#endif
; 20682: 						}
; 20683: 					}
; 20684: 				}
; 20685: 			}			
; 20686: 		}// for

  0025b	e9 58 ff ff ff	 jmp	 $LN5@gObjViewpo
$LN6@gObjViewpo:

; 20687: 	}

  00260	e9 cc 00 00 00	 jmp	 $LN1@gObjViewpo
$LN20@gObjViewpo:

; 20688: 	else if( lpObj->Type == OBJTYPE_MONSTER 

  00265	8b 45 f4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00268	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0026c	83 f9 02	 cmp	 ecx, 2
  0026f	0f 85 bc 00 00
	00		 jne	 $LN1@gObjViewpo

; 20689: #ifdef GAMESERVER_TO_CASTLESIEGESERVER				//     NPC  .
; 20690: 			|| lpObj->Type == OBJTYPE_NPC
; 20691: #endif
; 20692: #ifdef CRYWOLF_NPC_WORK_20050912
; 20693: 			|| lpObj->Type == OBJTYPE_NPC			//     NPC  .
; 20694: #endif
; 20695: 		)
; 20696: 	{	
; 20697: 		for( n = MAX_MONSTER; n < MAX_OBJECT; n++ )

  00275	c7 45 f8 a8 16
	00 00		 mov	 DWORD PTR _n$[ebp], 5800 ; 000016a8H
  0027c	eb 09		 jmp	 SHORT $LN10@gObjViewpo
$LN8@gObjViewpo:
  0027e	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00281	83 c0 01	 add	 eax, 1
  00284	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN10@gObjViewpo:
  00287	81 7d f8 e8 1c
	00 00		 cmp	 DWORD PTR _n$[ebp], 7400 ; 00001ce8H
  0028e	0f 8d 9d 00 00
	00		 jge	 $LN1@gObjViewpo

; 20698: 		{
; 20699: 			lpTempObj = &gObj[n];

  00294	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  0029b	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002a1	89 45 e4	 mov	 DWORD PTR _lpTempObj$[ebp], eax

; 20700: 			//  ..  ..						
; 20701: 			if( (lpTempObj->Connected == CSS_GAMEPLAYING) &&  ( aIndex != n ) )

  002a4	8b 45 e4	 mov	 eax, DWORD PTR _lpTempObj$[ebp]
  002a7	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  002ab	75 7f		 jne	 SHORT $LN28@gObjViewpo
  002ad	0f bf 45 08	 movsx	 eax, WORD PTR _aIndex$[ebp]
  002b1	3b 45 f8	 cmp	 eax, DWORD PTR _n$[ebp]
  002b4	74 76		 je	 SHORT $LN28@gObjViewpo

; 20702: 			{	
; 20703: 				//    
; 20704: 				if( lpTempObj->m_State == OBJST_CREATE ||

  002b6	8b 45 e4	 mov	 eax, DWORD PTR _lpTempObj$[ebp]
  002b9	83 b8 b8 01 00
	00 01		 cmp	 DWORD PTR [eax+440], 1
  002c0	74 0c		 je	 SHORT $LN30@gObjViewpo
  002c2	8b 45 e4	 mov	 eax, DWORD PTR _lpTempObj$[ebp]
  002c5	83 b8 b8 01 00
	00 02		 cmp	 DWORD PTR [eax+440], 2
  002cc	75 5e		 jne	 SHORT $LN28@gObjViewpo
$LN30@gObjViewpo:

; 20705: 					lpTempObj->m_State == OBJST_PLAYING )
; 20706: 				{
; 20707: 					if( mapnum == lpTempObj->MapNumber )

  002ce	8b 45 e4	 mov	 eax, DWORD PTR _lpTempObj$[ebp]
  002d1	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  002d8	39 4d f0	 cmp	 DWORD PTR _mapnum$[ebp], ecx
  002db	75 4f		 jne	 SHORT $LN28@gObjViewpo

; 20708: 					{ //   
; 20709: 						if( gObjCheckViewport(aIndex, lpTempObj->X, lpTempObj->Y) == TRUE )

  002dd	8b 45 e4	 mov	 eax, DWORD PTR _lpTempObj$[ebp]
  002e0	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  002e7	51		 push	 ecx
  002e8	8b 55 e4	 mov	 edx, DWORD PTR _lpTempObj$[ebp]
  002eb	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  002f2	50		 push	 eax
  002f3	0f bf 4d 08	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  002f7	51		 push	 ecx
  002f8	e8 00 00 00 00	 call	 ?gObjCheckViewport@@YAHHHH@Z ; gObjCheckViewport
  002fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00300	83 f8 01	 cmp	 eax, 1
  00303	75 27		 jne	 SHORT $LN28@gObjViewpo

; 20710: 						{ //   ...
; 20711: 							result = ViewportAdd(aIndex, n, gObj[n].Type);

  00305	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 7072
  0030c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00312	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00317	52		 push	 edx
  00318	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0031b	50		 push	 eax
  0031c	0f bf 4d 08	 movsx	 ecx, WORD PTR _aIndex$[ebp]
  00320	51		 push	 ecx
  00321	e8 00 00 00 00	 call	 ?ViewportAdd@@YAHHHH@Z	; ViewportAdd
  00326	83 c4 0c	 add	 esp, 12			; 0000000cH
  00329	89 45 fc	 mov	 DWORD PTR _result$[ebp], eax
$LN28@gObjViewpo:

; 20712: 	#ifdef MODIFY_MOVEMAP_RESET_VIEWPORT_BUGFIX_20060511
; 20713: 							result = ViewportAdd2(n, aIndex, gObj[aIndex].Type );
; 20714: 	#endif
; 20715: 						}
; 20716: 					}
; 20717: 				}
; 20718: 			}
; 20719: 		}// for

  0032c	e9 4d ff ff ff	 jmp	 $LN8@gObjViewpo
$LN1@gObjViewpo:

; 20720: 	}
; 20721: 	
; 20722: }

  00331	5f		 pop	 edi
  00332	5e		 pop	 esi
  00333	5b		 pop	 ebx
  00334	8b e5		 mov	 esp, ebp
  00336	5d		 pop	 ebp
  00337	c3		 ret	 0
?gObjViewportListCreate@@YAXF@Z ENDP			; gObjViewportListCreate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSetPosMonster@@YAHHH@Z
_TEXT	SEGMENT
tv75 = -76						; size = 4
tv66 = -76						; size = 4
tv76 = -72						; size = 4
tv67 = -72						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_PosTableNum$ = 12					; size = 4
?gObjSetPosMonster@@YAHHH@Z PROC			; gObjSetPosMonster, COMDAT

; 4530 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4531 : 	LPOBJECTSTRUCT	lpObj;
; 4532 : 
; 4533 : 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT)  )

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN13@gObjSetPos
  0000f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN14@gObjSetPos
$LN13@gObjSetPos:
  00018	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN11@gObjSetPos
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN12@gObjSetPos
$LN11@gObjSetPos:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN12@gObjSetPos:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN14@gObjSetPos:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 23		 jne	 SHORT $LN2@gObjSetPos

; 4534 : 	{
; 4535 : 		LogAdd("error : %s %d",__FILE__, __LINE__);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjSetPosMonster@@YAHHH@Z@4JA
  00042	83 c0 05	 add	 eax, 5
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4536 : 		return FALSE;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 ba 02 00 00	 jmp	 $LN1@gObjSetPos
$LN2@gObjSetPos:

; 4537 : 	}	
; 4538 : 
; 4539 : 	if( !CHECK_LIMIT(PosTableNum, MAX_MONSTER)  )

  00060	83 7d 0c 00	 cmp	 DWORD PTR _PosTableNum$[ebp], 0
  00064	7d 09		 jge	 SHORT $LN17@gObjSetPos
  00066	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
  0006d	eb 1f		 jmp	 SHORT $LN18@gObjSetPos
$LN17@gObjSetPos:
  0006f	81 7d 0c a7 16
	00 00		 cmp	 DWORD PTR _PosTableNum$[ebp], 5799 ; 000016a7H
  00076	7e 09		 jle	 SHORT $LN15@gObjSetPos
  00078	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
  0007f	eb 07		 jmp	 SHORT $LN16@gObjSetPos
$LN15@gObjSetPos:
  00081	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
$LN16@gObjSetPos:
  00088	8b 45 b4	 mov	 eax, DWORD PTR tv75[ebp]
  0008b	89 45 b8	 mov	 DWORD PTR tv76[ebp], eax
$LN18@gObjSetPos:
  0008e	83 7d b8 00	 cmp	 DWORD PTR tv76[ebp], 0
  00092	75 23		 jne	 SHORT $LN3@gObjSetPos

; 4540 : 	{
; 4541 : 		LogAdd("error : %s %d",__FILE__, __LINE__);

  00094	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjSetPosMonster@@YAHHH@Z@4JA
  00099	83 c0 0b	 add	 eax, 11			; 0000000bH
  0009c	50		 push	 eax
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4542 : 		return FALSE;

  000b0	33 c0		 xor	 eax, eax
  000b2	e9 63 02 00 00	 jmp	 $LN1@gObjSetPos
$LN3@gObjSetPos:

; 4543 : 	}	
; 4544 : 
; 4545 : 	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];	

  000b7	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000be	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c4	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 4546 : 
; 4547 : 	lpObj->m_PosNum     = PosTableNum;

  000c7	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ca	66 8b 4d 0c	 mov	 cx, WORD PTR _PosTableNum$[ebp]
  000ce	66 89 88 0c 02
	00 00		 mov	 WORD PTR [eax+524], cx

; 4548 : 	lpObj->X			= gMSetBase.m_Mp[PosTableNum].m_X;

  000d5	6b 45 0c 0c	 imul	 eax, DWORD PTR _PosTableNum$[ebp], 12
  000d9	66 0f b6 88 0a
	00 00 00	 movzx	 cx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+10]
  000e1	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e4	66 89 8a 04 01
	00 00		 mov	 WORD PTR [edx+260], cx

; 4549 : 	lpObj->Y			= gMSetBase.m_Mp[PosTableNum].m_Y;

  000eb	6b 45 0c 0c	 imul	 eax, DWORD PTR _PosTableNum$[ebp], 12
  000ef	66 0f b6 88 0b
	00 00 00	 movzx	 cx, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+11]
  000f7	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000fa	66 89 8a 06 01
	00 00		 mov	 WORD PTR [edx+262], cx

; 4550 : 	lpObj->MapNumber	= gMSetBase.m_Mp[PosTableNum].m_MapNumber;

  00101	6b 45 0c 0c	 imul	 eax, DWORD PTR _PosTableNum$[ebp], 12
  00105	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00108	8a 90 08 00 00
	00		 mov	 dl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+8]
  0010e	88 91 09 01 00
	00		 mov	 BYTE PTR [ecx+265], dl

; 4551 : 	
; 4552 : 	lpObj->TX			= lpObj->X;

  00114	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00117	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0011a	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  00121	66 89 90 20 01
	00 00		 mov	 WORD PTR [eax+288], dx

; 4553 : 	lpObj->TY			= lpObj->Y;

  00128	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012b	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0012e	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  00135	66 89 90 22 01
	00 00		 mov	 WORD PTR [eax+290], dx

; 4554 : 	lpObj->m_OldX		= lpObj->X;

  0013c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013f	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00142	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  00149	66 89 90 1c 01
	00 00		 mov	 WORD PTR [eax+284], dx

; 4555 : 	lpObj->m_OldY		= lpObj->Y;

  00150	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00153	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00156	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  0015d	66 89 90 1e 01
	00 00		 mov	 WORD PTR [eax+286], dx

; 4556 : 	lpObj->Dir			= gMSetBase.m_Mp[PosTableNum].m_Dir;

  00164	6b 45 0c 0c	 imul	 eax, DWORD PTR _PosTableNum$[ebp], 12
  00168	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0016b	8a 90 0c 00 00
	00		 mov	 dl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+12]
  00171	88 91 08 01 00
	00		 mov	 BYTE PTR [ecx+264], dl

; 4557 : 	lpObj->StartX       = (BYTE)lpObj->X;

  00177	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017a	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0017d	8a 91 04 01 00
	00		 mov	 dl, BYTE PTR [ecx+260]
  00183	88 90 1a 01 00
	00		 mov	 BYTE PTR [eax+282], dl

; 4558 : 	lpObj->StartY       = (BYTE)lpObj->Y;

  00189	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0018c	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0018f	8a 91 06 01 00
	00		 mov	 dl, BYTE PTR [ecx+262]
  00195	88 90 1b 01 00
	00		 mov	 BYTE PTR [eax+283], dl

; 4559 : 
; 4560 : 	if( lpObj->Class == 44 ||
; 4561 : 		lpObj->Class == 53 ||
; 4562 : 		lpObj->Class == 54 ||
; 4563 : 		lpObj->Class == 55 || 

  0019b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019e	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  001a5	83 f9 2c	 cmp	 ecx, 44			; 0000002cH
  001a8	74 3c		 je	 SHORT $LN6@gObjSetPos
  001aa	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ad	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  001b4	83 f9 35	 cmp	 ecx, 53			; 00000035H
  001b7	74 2d		 je	 SHORT $LN6@gObjSetPos
  001b9	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001bc	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  001c3	83 f9 36	 cmp	 ecx, 54			; 00000036H
  001c6	74 1e		 je	 SHORT $LN6@gObjSetPos
  001c8	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001cb	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  001d2	83 f9 37	 cmp	 ecx, 55			; 00000037H
  001d5	74 0f		 je	 SHORT $LN6@gObjSetPos
  001d7	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001da	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  001e1	83 f9 38	 cmp	 ecx, 56			; 00000038H
  001e4	75 05		 jne	 SHORT $LN4@gObjSetPos
$LN6@gObjSetPos:

; 4564 : 		lpObj->Class == 56)
; 4565 : 	{
; 4566 : 	}

  001e6	e9 a3 00 00 00	 jmp	 $LN5@gObjSetPos
$LN4@gObjSetPos:

; 4567 : 	else if( lpObj->Class >= 78 && lpObj->Class <= 83 )

  001eb	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ee	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  001f5	83 f9 4e	 cmp	 ecx, 78			; 0000004eH
  001f8	7c 14		 jl	 SHORT $LN7@gObjSetPos
  001fa	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001fd	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00204	83 f9 53	 cmp	 ecx, 83			; 00000053H
  00207	7f 05		 jg	 SHORT $LN7@gObjSetPos

; 4568 : 	{
; 4569 : 	}

  00209	e9 80 00 00 00	 jmp	 $LN5@gObjSetPos
$LN7@gObjSetPos:

; 4570 : #ifdef ADD_GOLDEN_EVENT_RENEWAL_20090311	
; 4571 : 	else if( lpObj->Class >= 493 && lpObj->Class <= 502 )
; 4572 : 	{
; 4573 : 	}
; 4574 : #endif //ADD_GOLDEN_EVENT_RENEWAL_20090311
; 4575 : 	else
; 4576 : 	{
; 4577 : 		if( gMSetBase.GetPosition(PosTableNum, lpObj->MapNumber, lpObj->X, lpObj->Y) == FALSE )

  0020e	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00211	05 06 01 00 00	 add	 eax, 262		; 00000106H
  00216	50		 push	 eax
  00217	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0021a	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00220	51		 push	 ecx
  00221	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00224	66 0f b6 82 09
	01 00 00	 movzx	 ax, BYTE PTR [edx+265]
  0022c	0f b7 c8	 movzx	 ecx, ax
  0022f	51		 push	 ecx
  00230	8b 55 0c	 mov	 edx, DWORD PTR _PosTableNum$[ebp]
  00233	52		 push	 edx
  00234	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMSetBase@@3VCMonsterSetBase@@A ; gMSetBase
  00239	e8 00 00 00 00	 call	 ?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z ; CMonsterSetBase::GetPosition
  0023e	85 c0		 test	 eax, eax
  00240	75 4c		 jne	 SHORT $LN5@gObjSetPos

; 4578 : 		{
; 4579 : 			LogAdd(lMsg.Get(508), __FILE__, __LINE__);

  00242	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjSetPosMonster@@YAHHH@Z@4JA
  00247	83 c0 31	 add	 eax, 49			; 00000031H
  0024a	50		 push	 eax
  0024b	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00250	68 fc 01 00 00	 push	 508			; 000001fcH
  00255	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0025a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00260	50		 push	 eax
  00261	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00267	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4580 : 			LogAdd("error-L2 : %d class : %d", PosTableNum, lpObj->Class);

  0026a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0026d	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00274	51		 push	 ecx
  00275	8b 55 0c	 mov	 edx, DWORD PTR _PosTableNum$[ebp]
  00278	52		 push	 edx
  00279	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@KEIINKC@error?9L2?5?3?5?$CFd?5class?5?3?5?$CFd@
  0027e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00284	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4581 : 			return FALSE;

  00287	33 c0		 xor	 eax, eax
  00289	e9 8c 00 00 00	 jmp	 $LN1@gObjSetPos
$LN5@gObjSetPos:

; 4582 : 		}
; 4583 : 	}
; 4584 : 	lpObj->TX			= lpObj->X;

  0028e	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00291	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00294	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  0029b	66 89 90 20 01
	00 00		 mov	 WORD PTR [eax+288], dx

; 4585 : 	lpObj->TY			= lpObj->Y;

  002a2	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a5	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002a8	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  002af	66 89 90 22 01
	00 00		 mov	 WORD PTR [eax+290], dx

; 4586 : 	lpObj->m_OldX		= lpObj->X;

  002b6	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002b9	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002bc	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  002c3	66 89 90 1c 01
	00 00		 mov	 WORD PTR [eax+284], dx

; 4587 : 	lpObj->m_OldY		= lpObj->Y;

  002ca	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002cd	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002d0	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  002d7	66 89 90 1e 01
	00 00		 mov	 WORD PTR [eax+286], dx

; 4588 : 	lpObj->Dir			= gMSetBase.m_Mp[PosTableNum].m_Dir;

  002de	6b 45 0c 0c	 imul	 eax, DWORD PTR _PosTableNum$[ebp], 12
  002e2	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002e5	8a 90 0c 00 00
	00		 mov	 dl, BYTE PTR ?gMSetBase@@3VCMonsterSetBase@@A[eax+12]
  002eb	88 91 08 01 00
	00		 mov	 BYTE PTR [ecx+264], dl

; 4589 : 	lpObj->StartX       = (BYTE)lpObj->X;

  002f1	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002f4	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002f7	8a 91 04 01 00
	00		 mov	 dl, BYTE PTR [ecx+260]
  002fd	88 90 1a 01 00
	00		 mov	 BYTE PTR [eax+282], dl

; 4590 : 	lpObj->StartY       = (BYTE)lpObj->Y;

  00303	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00306	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00309	8a 91 06 01 00
	00		 mov	 dl, BYTE PTR [ecx+262]
  0030f	88 90 1b 01 00
	00		 mov	 BYTE PTR [eax+283], dl

; 4591 : 
; 4592 : 	return TRUE;

  00315	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjSetPos:

; 4593 : }

  0031a	5f		 pop	 edi
  0031b	5e		 pop	 esi
  0031c	5b		 pop	 ebx
  0031d	8b e5		 mov	 esp, ebp
  0031f	5d		 pop	 ebp
  00320	c3		 ret	 0
?gObjSetPosMonster@@YAHHH@Z ENDP			; gObjSetPosMonster
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSetMonster@@YAHHH@Z
_TEXT	SEGMENT
tv66 = -88						; size = 4
tv80 = -84						; size = 4
tv67 = -84						; size = 4
_lpm$ = -16						; size = 4
_DefenceIndex$1 = -12					; size = 4
_lpObj$ = -8						; size = 4
_Level$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_MonsterClass$ = 12					; size = 4
?gObjSetMonster@@YAHHH@Z PROC				; gObjSetMonster, COMDAT

; 4599 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4600 : 	int Level;
; 4601 : 
; 4602 : 		
; 4603 : 	LPOBJECTSTRUCT	lpObj;
; 4604 : 
; 4605 : 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT)  )

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN52@gObjSetMon
  0000f	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN53@gObjSetMon
$LN52@gObjSetMon:
  00018	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN50@gObjSetMon
  00021	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN51@gObjSetMon
$LN50@gObjSetMon:
  0002a	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN51@gObjSetMon:
  00031	8b 45 a8	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 ac	 mov	 DWORD PTR tv67[ebp], eax
$LN53@gObjSetMon:
  00037	83 7d ac 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 23		 jne	 SHORT $LN4@gObjSetMon

; 4606 : 	{
; 4607 : 		LogAdd("error : %s %d",__FILE__, __LINE__);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjSetMonster@@YAHHH@Z@4JA
  00042	83 c0 08	 add	 eax, 8
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4608 : 		return FALSE;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 a0 0c 00 00	 jmp	 $LN1@gObjSetMon
$LN4@gObjSetMon:

; 4609 : 	}	
; 4610 : 
; 4611 : 	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];	

  00060	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00067	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006d	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 4612 : 	//else if( lpMsg->Index == 0 ) strcpy(gObj[aIndex].Name, "Monster");
; 4613 : 
; 4614 : 	lpObj->ConnectCheckTime	= GetTickCount();

  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00076	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00079	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 4615 : 
; 4616 : 	
; 4617 : 	lpObj->ShopNumber	= -1;

  0007c	83 c8 ff	 or	 eax, -1
  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00082	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax

; 4618 : 	lpObj->TargetNumber = -1;

  00089	83 c8 ff	 or	 eax, -1
  0008c	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0008f	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 4619 : 	lpObj->m_RecallMon  = -1;

  00096	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00099	c7 80 a4 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+676], -1

; 4620 : 	//251, 255, 254, 249, 249, 249, 249
; 4621 : 	switch(MonsterClass)

  000a3	8b 45 0c	 mov	 eax, DWORD PTR _MonsterClass$[ebp]
  000a6	89 45 ac	 mov	 DWORD PTR tv80[ebp], eax
  000a9	8b 4d ac	 mov	 ecx, DWORD PTR tv80[ebp]
  000ac	81 e9 c8 00 00
	00		 sub	 ecx, 200		; 000000c8H
  000b2	89 4d ac	 mov	 DWORD PTR tv80[ebp], ecx
  000b5	83 7d ac 37	 cmp	 DWORD PTR tv80[ebp], 55	; 00000037H
  000b9	0f 87 4d 01 00
	00		 ja	 $LN2@gObjSetMon
  000bf	8b 55 ac	 mov	 edx, DWORD PTR tv80[ebp]
  000c2	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN54@gObjSetMon[edx]
  000c9	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN55@gObjSetMon[eax*4]
$LN5@gObjSetMon:

; 4622 : 	{
; 4623 : 	case 200 : gBSGround[0]->m_BallIndex = aIndex; break;

  000d0	b8 04 00 00 00	 mov	 eax, 4
  000d5	6b c8 00	 imul	 ecx, eax, 0
  000d8	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?gBSGround@@3PAPAVCBattleSoccer@@A[ecx]
  000de	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000e1	89 42 64	 mov	 DWORD PTR [edx+100], eax
  000e4	e9 23 01 00 00	 jmp	 $LN2@gObjSetMon
$LN6@gObjSetMon:

; 4624 : 
; 4625 : #ifdef ADD_SHOP_11_12	
; 4626 : 	case 251 : lpObj->ShopNumber = 0; break;	//  () (116,141)

  000e9	33 c0		 xor	 eax, eax
  000eb	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ee	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax
  000f5	e9 12 01 00 00	 jmp	 $LN2@gObjSetMon
$LN7@gObjSetMon:

; 4627 : 	case 255 : lpObj->ShopNumber = 1; break;	//   () (123,135)

  000fa	b8 01 00 00 00	 mov	 eax, 1
  000ff	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00102	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax
  00109	e9 fe 00 00 00	 jmp	 $LN2@gObjSetMon
$LN8@gObjSetMon:

; 4628 : 	case 254 : lpObj->ShopNumber = 2; break;	//   () (118,113)

  0010e	b8 02 00 00 00	 mov	 eax, 2
  00113	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00116	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax
  0011d	e9 ea 00 00 00	 jmp	 $LN2@gObjSetMon
$LN9@gObjSetMon:

; 4629 : 	case 250 : lpObj->ShopNumber = 3; break;	//  (_) (183,137)

  00122	b8 03 00 00 00	 mov	 eax, 3
  00127	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0012a	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax
  00131	e9 d6 00 00 00	 jmp	 $LN2@gObjSetMon
$LN10@gObjSetMon:

; 4630 : 	case 248 : lpObj->ShopNumber = 4; break;	//  ( ) (7.148)

  00136	b8 04 00 00 00	 mov	 eax, 4
  0013b	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0013e	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax
  00145	e9 c2 00 00 00	 jmp	 $LN2@gObjSetMon
$LN11@gObjSetMon:

; 4631 : 	case 239 : 
; 4632 : 	case 253 : lpObj->ShopNumber = 5; break;	//  () (127,86)

  0014a	b8 05 00 00 00	 mov	 eax, 5
  0014f	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00152	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax
  00159	e9 ae 00 00 00	 jmp	 $LN2@gObjSetMon
$LN12@gObjSetMon:

; 4633 : 	case 244 : lpObj->ShopNumber = 6; break;	//  () (226,25)

  0015e	b8 06 00 00 00	 mov	 eax, 6
  00163	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00166	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax
  0016d	e9 9a 00 00 00	 jmp	 $LN2@gObjSetMon
$LN13@gObjSetMon:

; 4634 : 	case 245 : lpObj->ShopNumber = 7; break;	//  () (225,41)

  00172	b8 07 00 00 00	 mov	 eax, 7
  00177	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0017a	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax
  00181	e9 86 00 00 00	 jmp	 $LN2@gObjSetMon
$LN14@gObjSetMon:

; 4635 : 	case 246 : lpObj->ShopNumber = 8; break;	//  () (186,47)

  00186	b8 08 00 00 00	 mov	 eax, 8
  0018b	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0018e	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax
  00195	eb 75		 jmp	 SHORT $LN2@gObjSetMon
$LN15@gObjSetMon:

; 4636 : 	case 243 : lpObj->ShopNumber = 9; break;	//  () (195,124)

  00197	b8 09 00 00 00	 mov	 eax, 9
  0019c	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0019f	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax
  001a6	eb 64		 jmp	 SHORT $LN2@gObjSetMon
$LN16@gObjSetMon:

; 4637 : 	case 242 : lpObj->ShopNumber = 10; break;	//  () (173,125)

  001a8	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  001ad	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001b0	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax
  001b7	eb 53		 jmp	 SHORT $LN2@gObjSetMon
$LN17@gObjSetMon:

; 4638 : 
; 4639 : 	case 231 : lpObj->ShopNumber = 12; break;	//   

  001b9	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  001be	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001c1	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax
  001c8	eb 42		 jmp	 SHORT $LN2@gObjSetMon
$LN18@gObjSetMon:

; 4640 : 	case 230 : lpObj->ShopNumber = 11; break;	//   

  001ca	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  001cf	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001d2	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax
  001d9	eb 31		 jmp	 SHORT $LN2@gObjSetMon
$LN19@gObjSetMon:

; 4641 : 
; 4642 : 	case 240 : lpObj->ShopNumber = 100; break;	// 	

  001db	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  001e0	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001e3	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax
  001ea	eb 20		 jmp	 SHORT $LN2@gObjSetMon
$LN20@gObjSetMon:

; 4643 : 	case 238 : lpObj->ShopNumber = 101; break;	//  	

  001ec	b8 65 00 00 00	 mov	 eax, 101		; 00000065H
  001f1	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001f4	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax
  001fb	eb 0f		 jmp	 SHORT $LN2@gObjSetMon
$LN21@gObjSetMon:

; 4644 : 	case 236 : lpObj->ShopNumber = 102; break;	// 	

  001fd	b8 66 00 00 00	 mov	 eax, 102		; 00000066H
  00202	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00205	66 89 81 b0 02
	00 00		 mov	 WORD PTR [ecx+688], ax
$LN2@gObjSetMon:

; 4645 : #else
; 4646 : 	case 238 : lpObj->ShopNumber = 12; break;	//  
; 4647 : 	case 240 : lpObj->ShopNumber = 11; break;	// 
; 4648 : 	case 242 : lpObj->ShopNumber = 10; break;	// 
; 4649 : 	case 243 : lpObj->ShopNumber = 9; break;	// 
; 4650 : 	case 246 : lpObj->ShopNumber = 8; break;	//   
; 4651 : 	case 245 : lpObj->ShopNumber = 7; break;	//  
; 4652 : 	case 244 : lpObj->ShopNumber = 6; break;	//   
; 4653 : 	case 239 : 
; 4654 : 	case 253 : lpObj->ShopNumber = 5; break;	// 
; 4655 : 	case 248 : lpObj->ShopNumber = 4; break;	//  	
; 4656 : 	case 250 : lpObj->ShopNumber = 3; break;
; 4657 : 	case 251 : lpObj->ShopNumber = 0; break;
; 4658 : 	case 255 : lpObj->ShopNumber = 1; break;
; 4659 : 	case 254 : lpObj->ShopNumber = 2; break;	// 
; 4660 : 	case 236 : lpObj->ShopNumber = 13; break;	// 
; 4661 : #endif
; 4662 : 		
; 4663 : #ifdef ADD_SHOP_KALIMA_NPC_REIRA_20060403
; 4664 : 	case NPC_KALIMA_REIRA:	lpObj->ShopNumber	= 5; break;		//  () (37, 100)
; 4665 : #endif
; 4666 : 
; 4667 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 4668 : 	case JEWELOFHARMONY_NPC_RESTORE:
; 4669 : 	case JEWELOFHARMONY_NPC_SMELT:
; 4670 : 	case JEWELOFHARMONY_NPC_PURITY:
; 4671 : 		lpObj->ShopNumber = 101; //  
; 4672 : 		break;
; 4673 : #endif
; 4674 : 		
; 4675 : #ifdef UPDATE_QUARTERMASTER_NPC_20070122 //  ,  (goni)
; 4676 : 	case NPC_QUARTERMASTER_PAMELLA:	lpObj->ShopNumber = 5; break;	// ()   (90,44)
; 4677 : 	case NPC_QUARTERMASTER_ANGELA:	lpObj->ShopNumber = 5; break;	// ()   (89,218)
; 4678 : #endif
; 4679 : 
; 4680 : #ifdef ADD_FIRECRACKER_NPC_20070306			//  NPC 
; 4681 : 	case NPC_FRIECRACKER_STORE:		lpObj->ShopNumber = 13; break;	//    NPC (30, 31)
; 4682 : #endif
; 4683 : 
; 4684 : #ifdef ADD_SEASON_3_NEW_MAP_20070910		//  NPC 
; 4685 : 	case NPC_SILVIA:	lpObj->ShopNumber = 15;		break;		//   
; 4686 : 	case NPC_RHEA:		lpObj->ShopNumber = 16;		break;		//     
; 4687 : 	case NPC_MARCE:		lpObj->ShopNumber = 17;		break;		//   
; 4688 : #endif
; 4689 : 		
; 4690 : #ifdef ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 4691 : 	case NPC_SEED_MASTER:
; 4692 : 		lpObj->ShopNumber	= 101;
; 4693 : 		break;
; 4694 : 	case NPC_SEED_RESEARCHER:
; 4695 : 		lpObj->ShopNumber	= 101;
; 4696 : 		break;
; 4697 : #endif // ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 4698 : 
; 4699 : #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312
; 4700 : 	case NPC_CHERRY:	lpObj->ShopNumber = 101;	break;		//  
; 4701 : #endif // ADD_EVENT_CHERRYBLOSSOM_20080312
; 4702 : 
; 4703 : #ifdef UPDATE_LUCKY_COIN_EVENT_20081029	//    
; 4704 : 	case NPC_DELGADO:	lpObj->ShopNumber = 101;	break;		//  
; 4705 : #endif	// UPDATE_LUCKY_COIN_EVENT_20081029
; 4706 : 
; 4707 : #ifdef ADD_GAMBLING_20090120
; 4708 : 	case NPC_GAMBLER_1:
; 4709 : 		lpObj->ShopNumber = 18;
; 4710 : 		break;
; 4711 : #endif // ADD_GAMBLING_20090120
; 4712 : 	}
; 4713 : 	
; 4714 : 	//------------------------------------------------------------------------
; 4715 : 	lpObj->Connected	= CSS_GAMEPLAYING;	//      .

  0020c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0020f	c7 40 04 03 00
	00 00		 mov	 DWORD PTR [eax+4], 3

; 4716 : 	lpObj->Live			= 0;

  00216	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00219	c6 40 66 00	 mov	 BYTE PTR [eax+102], 0

; 4717 : 	lpObj->m_State		= 0;

  0021d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00220	c7 80 b8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+440], 0

; 4718 : 	if( (MonsterClass == 44 ||
; 4719 : 		MonsterClass == 54 ||
; 4720 : 		MonsterClass == 53 ||
; 4721 : 		lpObj->Class == 55 ||
; 4722 : 		lpObj->Class == 56 
; 4723 : #ifdef NEW_SKILL_FORSKYLAND
; 4724 : 		|| MonsterClass == 76			//   
; 4725 : #endif
; 4726 : 
; 4727 : #ifdef ELEGORADO_EVENT
; 4728 : 		|| MonsterClass == 78
; 4729 : 		|| MonsterClass == 79
; 4730 : 		|| MonsterClass == 80
; 4731 : 		|| MonsterClass == 81
; 4732 : 		|| MonsterClass == 82
; 4733 : 		|| MonsterClass == 83

  0022a	83 7d 0c 2c	 cmp	 DWORD PTR _MonsterClass$[ebp], 44 ; 0000002cH
  0022e	74 54		 je	 SHORT $LN24@gObjSetMon
  00230	83 7d 0c 36	 cmp	 DWORD PTR _MonsterClass$[ebp], 54 ; 00000036H
  00234	74 4e		 je	 SHORT $LN24@gObjSetMon
  00236	83 7d 0c 35	 cmp	 DWORD PTR _MonsterClass$[ebp], 53 ; 00000035H
  0023a	74 48		 je	 SHORT $LN24@gObjSetMon
  0023c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0023f	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00246	83 f9 37	 cmp	 ecx, 55			; 00000037H
  00249	74 39		 je	 SHORT $LN24@gObjSetMon
  0024b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0024e	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00255	83 f9 38	 cmp	 ecx, 56			; 00000038H
  00258	74 2a		 je	 SHORT $LN24@gObjSetMon
  0025a	83 7d 0c 4c	 cmp	 DWORD PTR _MonsterClass$[ebp], 76 ; 0000004cH
  0025e	74 24		 je	 SHORT $LN24@gObjSetMon
  00260	83 7d 0c 4e	 cmp	 DWORD PTR _MonsterClass$[ebp], 78 ; 0000004eH
  00264	74 1e		 je	 SHORT $LN24@gObjSetMon
  00266	83 7d 0c 4f	 cmp	 DWORD PTR _MonsterClass$[ebp], 79 ; 0000004fH
  0026a	74 18		 je	 SHORT $LN24@gObjSetMon
  0026c	83 7d 0c 50	 cmp	 DWORD PTR _MonsterClass$[ebp], 80 ; 00000050H
  00270	74 12		 je	 SHORT $LN24@gObjSetMon
  00272	83 7d 0c 51	 cmp	 DWORD PTR _MonsterClass$[ebp], 81 ; 00000051H
  00276	74 0c		 je	 SHORT $LN24@gObjSetMon
  00278	83 7d 0c 52	 cmp	 DWORD PTR _MonsterClass$[ebp], 82 ; 00000052H
  0027c	74 06		 je	 SHORT $LN24@gObjSetMon
  0027e	83 7d 0c 53	 cmp	 DWORD PTR _MonsterClass$[ebp], 83 ; 00000053H
  00282	75 02		 jne	 SHORT $LN22@gObjSetMon
$LN24@gObjSetMon:

; 4734 : #ifdef ADD_GOLDEN_EVENT_RENEWAL_20090311
; 4735 : 		|| MonsterClass == 493
; 4736 : 		|| MonsterClass == 494
; 4737 : 		|| MonsterClass == 495
; 4738 : 		|| MonsterClass == 496
; 4739 : 		|| MonsterClass == 497
; 4740 : 		|| MonsterClass == 498
; 4741 : 		|| MonsterClass == 499
; 4742 : 		|| MonsterClass == 500
; 4743 : 		|| MonsterClass == 501
; 4744 : 		|| MonsterClass == 502
; 4745 : #endif //ADD_GOLDEN_EVENT_RENEWAL_20090311
; 4746 : #endif
; 4747 : 
; 4748 : #ifdef ADD_RAKLION_20080408
; 4749 : 	//	|| MonsterClass == 459			//  
; 4750 : #endif // ADD_RAKLION_20080408
; 4751 : 		) )	// 44:      .
; 4752 : 	{			
; 4753 : 		
; 4754 : 	}

  00284	eb 14		 jmp	 SHORT $LN23@gObjSetMon
$LN22@gObjSetMon:

; 4755 : 	else 
; 4756 : 	{
; 4757 : 		lpObj->Live		= 1;

  00286	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00289	c6 40 66 01	 mov	 BYTE PTR [eax+102], 1

; 4758 : 		lpObj->m_State	= OBJST_CREATE;

  0028d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00290	c7 80 b8 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+440], 1
$LN23@gObjSetMon:

; 4759 : 	}
; 4760 : 
; 4761 : #ifdef UPDATE_NEWYEAR_LUCKYBAG_MONSTER_20070131		//    
; 4762 : 	if(MonsterClass == MON_NEWYEAR_LUCKYBAG)
; 4763 : 	{
; 4764 : 		if(g_bNewYearLuckyBagMonsterEventOn)
; 4765 : 		{
; 4766 : 			lpObj->Live		= 1;
; 4767 : 			lpObj->m_State	= OBJST_CREATE;
; 4768 : 		}
; 4769 : 		else
; 4770 : 		{
; 4771 : 			lpObj->Live		= 0;
; 4772 : 			lpObj->m_State	= OBJST_NONE;
; 4773 : 		}
; 4774 : 	}
; 4775 : #endif
; 4776 : 
; 4777 : #ifdef ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 4778 : 	if( MonsterClass >= 204 && MonsterClass <= 259		//  .
; 4779 : 		|| MonsterClass >= JEWELOFHARMONY_NPC_PURITY && MonsterClass <= JEWELOFHARMONY_NPC_RESTORE // NPC 
; 4780 : #ifdef ADD_NEW_NPC_KANTURU_20060612
; 4781 : 		|| MonsterClass == NPC_KANTURU_MACHINE			//   NPC 
; 4782 : #endif // #ifdef ADD_NEW_NPC_KANTURU_20060612
; 4783 : #ifdef ADD_PCS_LOTTERY_SYSTEM_20070117
; 4784 : 		|| MonsterClass == NPC_CHAOSCARDMASTER
; 4785 : #endif // ADD_PCS_LOTTERY_SYSTEM_20070117
; 4786 : #ifdef WHITEANGEL_GET_ITEM_EVENT_20060822
; 4787 : 		|| MonsterClass == NPC_WHITEANGEL_EVENT			//    NPC 
; 4788 : #endif
; 4789 : #ifdef THIRD_CHANGEUP_SYSTEM_20070507		// 3  NPC OBJTYPE 
; 4790 : 		|| MonsterClass == NPC_PRIEST_DEVIN				// 	
; 4791 : 		|| MonsterClass == NPC_WERWOLF_QUERELLE			//  
; 4792 : 		|| MonsterClass == NPC_THIRD_CHANGEUP_BOSS_GATE	// 3   
; 4793 : #endif	
; 4794 : #ifdef ADD_ITEM_GIVE_NPC_ALAN_20070823		//  NPC 
; 4795 : 		|| MonsterClass == 414							// 
; 4796 : #endif		
; 4797 : #ifdef ADD_NPC_XMASEVENT_20080930
; 4798 : 		|| MonsterClass == NPC_SANTA		// 
; 4799 : 		|| MonsterClass == NPC_SNOW_MAN		// 
; 4800 : 		|| (MonsterClass >= NPC_LITTLE_SANTA_1 && MonsterClass <= NPC_LITTLE_SANTA_8)	// 1~8
; 4801 : #endif
; 4802 : #ifdef ADD_NEWPVP_PKFIELD
; 4803 : 		|| MonsterClass == NPC_TITUS
; 4804 : #endif // ADD_NEWPVP_PKFIELD
; 4805 : 		)
; 4806 : #else
; 4807 : 	#ifdef CRYWOLF_NPC_WORK_20050912
; 4808 : 		if( MonsterClass >= 204 && MonsterClass <= 257) //  ,  
; 4809 : 	#else
; 4810 : 			
; 4811 : 		#ifdef ADD_NPC_SHADOW_PHANTOM_20050616
; 4812 : 			if( MonsterClass >= 216 && MonsterClass <= 257) //   
; 4813 : 		#else
; 4814 : 			#ifdef	ADD_NEW_NPC_CASTLE_20041115						// , 1-2, , (/), ,  
; 4815 : 				if( MonsterClass >= 216 && MonsterClass <= 256)
; 4816 : 			#else
; 4817 : 				#ifdef 	JEWEL_MIX_SYSTEM_20050309						//   NPC 
; 4818 : 					if( MonsterClass >= 226 && MonsterClass <= 256)
; 4819 : 				#else
; 4820 : 					#ifdef 	ADD_NEW_MAP_KALIMA_20040518						//  -  
; 4821 : 						if( MonsterClass >= 226 && MonsterClass <= 255)

  0029a	81 7d 0c e2 00
	00 00		 cmp	 DWORD PTR _MonsterClass$[ebp], 226 ; 000000e2H
  002a1	7c 17		 jl	 SHORT $LN25@gObjSetMon
  002a3	81 7d 0c ff 00
	00 00		 cmp	 DWORD PTR _MonsterClass$[ebp], 255 ; 000000ffH
  002aa	7f 0e		 jg	 SHORT $LN25@gObjSetMon

; 4822 : 					#else
; 4823 : 						if( MonsterClass >= 226 )
; 4824 : 					#endif	// ADD_NEW_MAP_KALIMA_20040518
; 4825 : 				#endif	// JEWEL_MIX_SYSTEM_20050309
; 4826 : 			#endif	// ADD_NEW_NPC_CASTLE_20041115
; 4827 : 		#endif // ADD_NPC_SHADOW_PHANTOM_20050616
; 4828 : 	#endif // CRYWOLF_NPC_WORK_20050912
; 4829 : #endif // ADD_JEWEL_OF_HARMONY_SYSTEM_20060530
; 4830 : 
; 4831 : 
; 4832 : //#ifdef DARKLORD_WORK
; 4833 : //	if( MonsterClass >= 226 )
; 4834 : //#else
; 4835 : //	if( MonsterClass >= 229 )
; 4836 : //#endif
; 4837 : 	{
; 4838 : 		lpObj->Type			= OBJTYPE_NPC;		// NPC

  002ac	b8 03 00 00 00	 mov	 eax, 3
  002b1	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002b4	66 89 41 64	 mov	 WORD PTR [ecx+100], ax

; 4839 : 	}

  002b8	eb 0c		 jmp	 SHORT $LN26@gObjSetMon
$LN25@gObjSetMon:

; 4840 : 	else 
; 4841 : 	{
; 4842 : 		lpObj->Type			= OBJTYPE_MONSTER;	// 

  002ba	b8 02 00 00 00	 mov	 eax, 2
  002bf	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002c2	66 89 41 64	 mov	 WORD PTR [ecx+100], ax
$LN26@gObjSetMon:

; 4843 : 	}
; 4844 : 	
; 4845 : #ifdef PCBANG_COUPON_EVENT_20060124
; 4846 : 	if( MonsterClass == 258 )
; 4847 : 	{
; 4848 : 		lpObj->Type			= OBJTYPE_NPC;
; 4849 : 	}
; 4850 : #endif
; 4851 : #ifdef EXPERIENCE_SERVER_NPC_STAT_RESET
; 4852 : 	if( MonsterClass == 464 )
; 4853 : 	{
; 4854 : 		lpObj->Type			= OBJTYPE_NPC;
; 4855 : 	}
; 4856 : #endif// EXPERIENCE_SERVER_NPC_STAT_RESET
; 4857 : 	
; 4858 : 
; 4859 : #ifdef UPDATE_QUARTERMASTER_NPC_20070122	//  ,  (goni)
; 4860 : 	if( MonsterClass == NPC_QUARTERMASTER_PAMELLA || MonsterClass == NPC_QUARTERMASTER_ANGELA )
; 4861 : 	{
; 4862 : 		lpObj->Type			= OBJTYPE_NPC;
; 4863 : 	}
; 4864 : #endif
; 4865 : 
; 4866 : #ifdef ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 4867 : 	if( MonsterClass == NPC_SEED_MASTER || MonsterClass == NPC_SEED_RESEARCHER )
; 4868 : 	{
; 4869 : 		lpObj->Type			= OBJTYPE_NPC;
; 4870 : 	}
; 4871 : #endif // ADD_ITEM_SOCKET_OPTION_MIX_20080415
; 4872 : 
; 4873 : #ifdef ADD_FIRECRACKER_NPC_20070306			//  NPC 
; 4874 : 	if( MonsterClass == NPC_FRIECRACKER_STORE )
; 4875 : 	{
; 4876 : 		lpObj->Type			= OBJTYPE_NPC;
; 4877 : 	}
; 4878 : #endif
; 4879 : 
; 4880 : #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312
; 4881 : 	if( MonsterClass == NPC_FRIECRACKER_STORE )
; 4882 : 	{
; 4883 : 		lpObj->Type			= OBJTYPE_NPC;
; 4884 : 	}
; 4885 : #endif // ADD_EVENT_CHERRYBLOSSOM_20080312
; 4886 : 
; 4887 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	//   NPC 
; 4888 : 	if(MonsterClass ==  NPC_PLATFORM_MIRAGE
; 4889 : 		|| MonsterClass ==  NPC_ILLUSION_HOLY_RELICS_STATUE
; 4890 : 		|| MonsterClass ==  NPC_LEADER_OF_ALLIED_FORCE
; 4891 : 		|| MonsterClass ==  NPC_ELDER_OF_ILLUSION
; 4892 : 		|| MonsterClass ==  NPC_HOLY_RELICS_BOX_ALLIED
; 4893 : 		|| MonsterClass ==  NPC_HOLY_RELICS_BOX_ILLUSION)
; 4894 : 	{
; 4895 : 		lpObj->Type			= OBJTYPE_NPC;
; 4896 : 	}
; 4897 : 
; 4898 : 	//    .
; 4899 : 	if(MonsterClass ==  NPC_PLATFORM_MIRAGE)
; 4900 : 	{
; 4901 : 		g_IllusionTempleEvent.SetMirageIndex(aIndex);
; 4902 : 	}
; 4903 : #endif
; 4904 : 
; 4905 : #ifdef ADD_SEASON_3_NEW_MAP_20070910	//  NPC
; 4906 : 	if(MonsterClass ==  NPC_SILVIA
; 4907 : 		|| MonsterClass ==  NPC_RHEA
; 4908 : 		|| MonsterClass ==  NPC_MARCE)
; 4909 : 	{
; 4910 : 		lpObj->Type			= OBJTYPE_NPC;
; 4911 : 	}
; 4912 : #endif
; 4913 : 
; 4914 : #ifdef ADD_EVENT_CHERRYBLOSSOM_20080312
; 4915 : 	if (MonsterClass == NPC_CHERRY)
; 4916 : 	{
; 4917 : 		lpObj->Type			= OBJTYPE_NPC;
; 4918 : 	}
; 4919 : #ifdef MODIFY_CHEREEY_NPC_REGISTER_NPC_GROUP_20090803
; 4920 : 	if (MonsterClass == NPC_CHERRY_TREE)
; 4921 : 	{
; 4922 : 		lpObj->Type			= OBJTYPE_NPC;
; 4923 : 	}
; 4924 : #endif // MODIFY_CHEREEY_NPC_REGISTER_NPC_GROUP_20090803
; 4925 : #endif // ADD_EVENT_CHERRYBLOSSOM_20080312
; 4926 : 
; 4927 : #ifdef UPDATE_LUCKY_COIN_EVENT_20081029	//   NPC 
; 4928 : 	if(MonsterClass ==  NPC_DELGADO)
; 4929 : 	{
; 4930 : 		lpObj->Type			= OBJTYPE_NPC;
; 4931 : 	}
; 4932 : #endif	// UPDATE_LUCKY_COIN_EVENT_20081029
; 4933 : 
; 4934 : #ifdef NEW_SKILL_FORSKYLAND
; 4935 : 	if( MonsterClass == 77 )

  002c6	83 7d 0c 4d	 cmp	 DWORD PTR _MonsterClass$[ebp], 77 ; 0000004dH
  002ca	75 6a		 jne	 SHORT $LN29@gObjSetMon

; 4936 : 	{	//    
; 4937 : #ifdef MAP_SERVER_ADD_MONSTER_20041216		//   , NPC  (     .)
; 4938 : 		int DefenceIndex=  gObjAddMonster(MAP_INDEX_ICARUS);

  002cc	6a 0a		 push	 10			; 0000000aH
  002ce	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  002d3	83 c4 04	 add	 esp, 4
  002d6	98		 cwde
  002d7	89 45 f4	 mov	 DWORD PTR _DefenceIndex$1[ebp], eax

; 4939 : #else
; 4940 : 		int DefenceIndex=  gObjAdd();
; 4941 : #endif
; 4942 : 		if( DefenceIndex >= 0 )

  002da	83 7d f4 00	 cmp	 DWORD PTR _DefenceIndex$1[ebp], 0
  002de	7c 42		 jl	 SHORT $LN28@gObjSetMon

; 4943 : 		{
; 4944 : 			if( !gObjSetMonster(DefenceIndex, 76) )

  002e0	6a 4c		 push	 76			; 0000004cH
  002e2	8b 45 f4	 mov	 eax, DWORD PTR _DefenceIndex$1[ebp]
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  002eb	83 c4 08	 add	 esp, 8
  002ee	85 c0		 test	 eax, eax
  002f0	75 14		 jne	 SHORT $LN30@gObjSetMon

; 4945 : 			{
; 4946 : 				MsgBox("  ");

  002f2	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@DGECBEHF@?C?$LF?$LA?x?$LK?$LI?$LN?$LK?$LI?w?5?$LM?$LD?A?$KE?5?$LN?G?F?P@
  002f7	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  002fc	83 c4 04	 add	 esp, 4

; 4947 : 				return FALSE;

  002ff	33 c0		 xor	 eax, eax
  00301	e9 fa 09 00 00	 jmp	 $LN1@gObjSetMon
$LN30@gObjSetMon:

; 4948 : 			}
; 4949 : 
; 4950 : 			lpObj->m_SkyBossMonSheildLinkIndex = DefenceIndex;

  00306	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00309	8b 4d f4	 mov	 ecx, DWORD PTR _DefenceIndex$1[ebp]
  0030c	89 88 c4 0e 00
	00		 mov	 DWORD PTR [eax+3780], ecx

; 4951 : 			LogAddTD("SkyLand Boss Monster Setting!!");

  00312	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@GCONPPCF@SkyLand?5Boss?5Monster?5Setting?$CB?$CB@
  00317	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0031d	83 c4 04	 add	 esp, 4

; 4952 : 		}

  00320	eb 14		 jmp	 SHORT $LN29@gObjSetMon
$LN28@gObjSetMon:

; 4953 : 		else
; 4954 : 		{			
; 4955 : 			MsgBox("  ");

  00322	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@DGECBEHF@?C?$LF?$LA?x?$LK?$LI?$LN?$LK?$LI?w?5?$LM?$LD?A?$KE?5?$LN?G?F?P@
  00327	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0032c	83 c4 04	 add	 esp, 4

; 4956 : 			return FALSE;

  0032f	33 c0		 xor	 eax, eax
  00331	e9 ca 09 00 00	 jmp	 $LN1@gObjSetMon
$LN29@gObjSetMon:

; 4957 : 		}
; 4958 : 	}
; 4959 : 	if( MonsterClass == 76 )

  00336	83 7d 0c 4c	 cmp	 DWORD PTR _MonsterClass$[ebp], 76 ; 0000004cH
  0033a	75 0e		 jne	 SHORT $LN31@gObjSetMon

; 4960 : 	{
; 4961 : 		LogAddTD("SkyLand Boss Shield Setting!!");

  0033c	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@HDDGJDLK@SkyLand?5Boss?5Shield?5Setting?$CB?$CB@
  00341	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00347	83 c4 04	 add	 esp, 4
$LN31@gObjSetMon:

; 4962 : 	}
; 4963 : #endif
; 4964 : 
; 4965 : 	lpObj->Class		= MonsterClass;

  0034a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0034d	66 8b 4d 0c	 mov	 cx, WORD PTR _MonsterClass$[ebp]
  00351	66 89 88 9c 00
	00 00		 mov	 WORD PTR [eax+156], cx

; 4966 : 
; 4967 : 	Level = lpObj->Level;

  00358	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0035b	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00362	89 4d fc	 mov	 DWORD PTR _Level$[ebp], ecx

; 4968 : 
; 4969 : 	LPMONSTER_ATTRIBUTE		lpm;
; 4970 : 		
; 4971 : 	lpm = gMAttr.GetAttr(lpObj->Class);	

  00365	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00368	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0036f	51		 push	 ecx
  00370	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  00375	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  0037a	89 45 f0	 mov	 DWORD PTR _lpm$[ebp], eax

; 4972 : 
; 4973 : 	if( lpm == NULL )

  0037d	83 7d f0 00	 cmp	 DWORD PTR _lpm$[ebp], 0
  00381	75 3b		 jne	 SHORT $LN32@gObjSetMon

; 4974 : 	{
; 4975 : 		MsgBox(lMsg.Get(509),lpObj->Class, __FILE__,__LINE__);

  00383	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjSetMonster@@YAHHH@Z@4JA
  00388	05 78 01 00 00	 add	 eax, 376		; 00000178H
  0038d	50		 push	 eax
  0038e	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00393	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00396	0f b7 91 9c 00
	00 00		 movzx	 edx, WORD PTR [ecx+156]
  0039d	52		 push	 edx
  0039e	68 fd 01 00 00	 push	 509			; 000001fdH
  003a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  003ae	50		 push	 eax
  003af	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  003b4	83 c4 10	 add	 esp, 16			; 00000010H

; 4976 : 		return FALSE;

  003b7	33 c0		 xor	 eax, eax
  003b9	e9 42 09 00 00	 jmp	 $LN1@gObjSetMon
$LN32@gObjSetMon:

; 4977 : 	}
; 4978 : 
; 4979 : 	strncpy(gObj[aIndex].Name, lpm->m_Name, MAX_IDSTRING);

  003be	6a 0a		 push	 10			; 0000000aH
  003c0	8b 45 f0	 mov	 eax, DWORD PTR _lpm$[ebp]
  003c3	83 c0 08	 add	 eax, 8
  003c6	50		 push	 eax
  003c7	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  003ce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003d4	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  003d8	50		 push	 eax
  003d9	e8 00 00 00 00	 call	 _strncpy
  003de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4980 : 
; 4981 : 	if( lpm->m_Level == 0 )

  003e1	8b 45 f0	 mov	 eax, DWORD PTR _lpm$[ebp]
  003e4	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  003e8	75 35		 jne	 SHORT $LN33@gObjSetMon

; 4982 : 	{
; 4983 : 		LogAdd(lMsg.Get(510),lpObj->Class, __FILE__,__LINE__);

  003ea	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjSetMonster@@YAHHH@Z@4JA
  003ef	05 80 01 00 00	 add	 eax, 384		; 00000180H
  003f4	50		 push	 eax
  003f5	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  003fa	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003fd	0f b7 91 9c 00
	00 00		 movzx	 edx, WORD PTR [ecx+156]
  00404	52		 push	 edx
  00405	68 fe 01 00 00	 push	 510			; 000001feH
  0040a	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0040f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00415	50		 push	 eax
  00416	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0041c	83 c4 10	 add	 esp, 16			; 00000010H
$LN33@gObjSetMon:

; 4984 : 	}
; 4985 : 	lpObj->Level				= lpm->m_Level;

  0041f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00422	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  00425	66 8b 51 1c	 mov	 dx, WORD PTR [ecx+28]
  00429	66 89 90 a0 00
	00 00		 mov	 WORD PTR [eax+160], dx

; 4986 : 	lpObj->m_AttackSpeed		= lpm->m_AttackSpeed;

  00430	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00433	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  00436	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00439	89 90 e0 02 00
	00		 mov	 DWORD PTR [eax+736], edx

; 4987 : 	lpObj->m_AttackDamageMin	= lpm->m_DamageMin;

  0043f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00442	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  00445	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00448	89 90 b4 02 00
	00		 mov	 DWORD PTR [eax+692], edx

; 4988 : 	lpObj->m_AttackDamageMax	= lpm->m_DamageMax;

  0044e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00451	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  00454	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00457	89 90 b8 02 00
	00		 mov	 DWORD PTR [eax+696], edx

; 4989 : 	lpObj->m_Defense			= lpm->m_Defense;

  0045d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00460	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  00463	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00466	89 90 e8 02 00
	00		 mov	 DWORD PTR [eax+744], edx

; 4990 : 
; 4991 : 	lpObj->m_MagicDefense		= lpm->m_MagicDefense;

  0046c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0046f	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  00472	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00475	89 90 ec 02 00
	00		 mov	 DWORD PTR [eax+748], edx

; 4992 : 
; 4993 : 	lpObj->m_AttackRating		= lpm->m_AttackRating;

  0047b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0047e	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  00481	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00484	89 90 dc 02 00
	00		 mov	 DWORD PTR [eax+732], edx

; 4994 : 	lpObj->m_SuccessfulBlocking	= lpm->m_Successfulblocking;

  0048a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0048d	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  00490	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00493	89 90 f0 02 00
	00		 mov	 DWORD PTR [eax+752], edx

; 4995 : 	lpObj->Life					= (float)lpm->m_Hp;

  00499	8b 45 f0	 mov	 eax, DWORD PTR _lpm$[ebp]
  0049c	f3 0f 2a 40 24	 cvtsi2ss xmm0, DWORD PTR [eax+36]
  004a1	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004a4	f3 0f 11 81 bc
	00 00 00	 movss	 DWORD PTR [ecx+188], xmm0

; 4996 : 	lpObj->MaxLife				= (float)lpm->m_Hp;

  004ac	8b 45 f0	 mov	 eax, DWORD PTR _lpm$[ebp]
  004af	f3 0f 2a 40 24	 cvtsi2ss xmm0, DWORD PTR [eax+36]
  004b4	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004b7	f3 0f 11 81 c0
	00 00 00	 movss	 DWORD PTR [ecx+192], xmm0

; 4997 : 	lpObj->Mana					= (float)lpm->m_Mp;

  004bf	8b 45 f0	 mov	 eax, DWORD PTR _lpm$[ebp]
  004c2	f3 0f 2a 40 28	 cvtsi2ss xmm0, DWORD PTR [eax+40]
  004c7	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004ca	f3 0f 11 81 d0
	00 00 00	 movss	 DWORD PTR [ecx+208], xmm0

; 4998 : 	lpObj->MaxMana				= (float)lpm->m_Mp;

  004d2	8b 45 f0	 mov	 eax, DWORD PTR _lpm$[ebp]
  004d5	f3 0f 2a 40 28	 cvtsi2ss xmm0, DWORD PTR [eax+40]
  004da	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004dd	f3 0f 11 81 d4
	00 00 00	 movss	 DWORD PTR [ecx+212], xmm0

; 4999 : 	lpObj->m_MoveRange			= lpm->m_MoveRange;

  004e5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004e8	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  004eb	66 8b 51 44	 mov	 dx, WORD PTR [ecx+68]
  004ef	66 89 90 f6 02
	00 00		 mov	 WORD PTR [eax+758], dx

; 5000 : 	lpObj->m_AttackSpeed		= lpm->m_AttackSpeed;

  004f6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004f9	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  004fc	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  004ff	89 90 e0 02 00
	00		 mov	 DWORD PTR [eax+736], edx

; 5001 : 	lpObj->m_MoveSpeed			= lpm->m_MoveSpeed;

  00505	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00508	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  0050b	66 8b 51 54	 mov	 dx, WORD PTR [ecx+84]
  0050f	66 89 90 f4 02
	00 00		 mov	 WORD PTR [eax+756], dx

; 5002 : 	lpObj->MaxRegenTime			= lpm->m_RegenTime*1000;

  00516	8b 45 f0	 mov	 eax, DWORD PTR _lpm$[ebp]
  00519	69 48 5c e8 03
	00 00		 imul	 ecx, DWORD PTR [eax+92], 1000
  00520	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00523	89 8a 08 02 00
	00		 mov	 DWORD PTR [edx+520], ecx

; 5003 : 	lpObj->m_AttackRange		= lpm->m_AttackRange;

  00529	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0052c	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  0052f	66 8b 51 48	 mov	 dx, WORD PTR [ecx+72]
  00533	66 89 90 f8 02
	00 00		 mov	 WORD PTR [eax+760], dx

; 5004 : 	lpObj->m_ViewRange			= lpm->m_ViewRange;

  0053a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0053d	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  00540	66 8b 51 50	 mov	 dx, WORD PTR [ecx+80]
  00544	66 89 90 fc 02
	00 00		 mov	 WORD PTR [eax+764], dx

; 5005 : 	lpObj->m_Attribute		    = lpm->m_Attribute;

  0054b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0054e	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  00551	66 8b 51 60	 mov	 dx, WORD PTR [ecx+96]
  00555	66 89 90 fe 02
	00 00		 mov	 WORD PTR [eax+766], dx

; 5006 : 	lpObj->m_AttackType			= lpm->m_AttackType;

  0055c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0055f	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  00562	66 8b 51 4c	 mov	 dx, WORD PTR [ecx+76]
  00566	66 89 90 fa 02
	00 00		 mov	 WORD PTR [eax+762], dx

; 5007 : 	lpObj->m_ItemRate			= lpm->m_ItemRate;

  0056d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00570	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  00573	66 8b 51 64	 mov	 dx, WORD PTR [ecx+100]
  00577	66 89 90 00 03
	00 00		 mov	 WORD PTR [eax+768], dx

; 5008 : 	lpObj->m_MoneyRate			= lpm->m_MoneyRate;

  0057e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00581	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  00584	66 8b 51 68	 mov	 dx, WORD PTR [ecx+104]
  00588	66 89 90 02 03
	00 00		 mov	 WORD PTR [eax+770], dx

; 5009 : 	lpObj->Dexterity			= 0;

  0058f	33 c0		 xor	 eax, eax
  00591	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00594	66 89 81 b6 00
	00 00		 mov	 WORD PTR [ecx+182], ax

; 5010 : 
; 5011 : #ifdef MODIFY_CRYWOLF_BENEFIT_01_20060315
; 5012 : 	lpObj->m_iScriptMaxLife		= lpm->m_iScriptHP;

  0059b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0059e	8b 4d f0	 mov	 ecx, DWORD PTR _lpm$[ebp]
  005a1	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  005a4	89 90 c4 00 00
	00		 mov	 DWORD PTR [eax+196], edx

; 5013 : #endif // MODIFY_CRYWOLF_BENEFIT_01_20060315
; 5014 : 
; 5015 : #ifdef ADD_NEW_MONSTER_SYSTEM_02_20050725
; 5016 : 	lpObj->m_iBasicAI			= lpm->m_iAINumber;
; 5017 : 	lpObj->m_iCurrentAI			= lpm->m_iAINumber;
; 5018 : 	lpObj->m_iCurrentAIState	= 0;
; 5019 : 	lpObj->m_iLastAIRunTime		= 0;
; 5020 : 	
; 5021 : 	lpObj->m_iGroupNumber		= 0;
; 5022 : 	lpObj->m_iSubGroupNumber	= 0;
; 5023 : 	lpObj->m_iGroupMemberGuid	= -1;
; 5024 : 	lpObj->m_iRegenType			= 0;
; 5025 : 
; 5026 : 	lpObj->m_Agro.ResetAll();
; 5027 : 	
; 5028 : 	#ifdef MODIFY_MONSTERAI_AUTOMATA_DELAY_BUGFIX_20060907
; 5029 : 		lpObj->m_iLastAutomataRuntime = 0;	//  Automata  
; 5030 : 		lpObj->m_iLastAutomataDelay	  = 0;	//   Automata Delay 
; 5031 : 	#endif // MODIFY_MONSTERAI_AUTOMATA_DELAY_BUGFIX_20060907
; 5032 : #endif // ADD_NEW_MONSTER_SYSTEM_02_20050725
; 5033 : 
; 5034 : 
; 5035 : 	(*lpObj->pInventoryCount)	= 0;

  005aa	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005ad	8b 88 64 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3172]
  005b3	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 5036 : 
; 5037 : 	memcpy(lpObj->m_Resistance,	lpm->m_Resistance, MAX_RESISTANCE);

  005b6	6a 07		 push	 7
  005b8	8b 45 f0	 mov	 eax, DWORD PTR _lpm$[ebp]
  005bb	83 c0 70	 add	 eax, 112		; 00000070H
  005be	50		 push	 eax
  005bf	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005c2	81 c1 35 03 00
	00		 add	 ecx, 821		; 00000335H
  005c8	51		 push	 ecx
  005c9	e8 00 00 00 00	 call	 _memcpy
  005ce	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5038 : 
; 5039 : 	gObjSetInventory1Pointer(lpObj);

  005d1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005d4	50		 push	 eax
  005d5	e8 00 00 00 00	 call	 ?gObjSetInventory1Pointer@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer
  005da	83 c4 04	 add	 esp, 4

; 5040 : 
; 5041 : 	if( lpObj->m_AttackType )

  005dd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005e0	0f bf 88 fa 02
	00 00		 movsx	 ecx, WORD PTR [eax+762]
  005e7	85 c9		 test	 ecx, ecx
  005e9	0f 84 5e 06 00
	00		 je	 $LN47@gObjSetMon

; 5042 : 	{
; 5043 : 		if( lpObj->m_AttackType >= 100 )

  005ef	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005f2	0f bf 88 fa 02
	00 00		 movsx	 ecx, WORD PTR [eax+762]
  005f9	83 f9 64	 cmp	 ecx, 100		; 00000064H
  005fc	7c 1e		 jl	 SHORT $LN35@gObjSetMon

; 5044 : 		{
; 5045 : 			gObjMonsterMagicAdd(lpObj, (BYTE)(lpObj->m_AttackType-100), 1);

  005fe	6a 01		 push	 1
  00600	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00603	0f bf 88 fa 02
	00 00		 movsx	 ecx, WORD PTR [eax+762]
  0060a	83 e9 64	 sub	 ecx, 100		; 00000064H
  0060d	51		 push	 ecx
  0060e	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00611	52		 push	 edx
  00612	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  00617	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5046 : 		}

  0061a	eb 19		 jmp	 SHORT $LN36@gObjSetMon
$LN35@gObjSetMon:

; 5047 : 		else gObjMonsterMagicAdd(lpObj, (BYTE)lpObj->m_AttackType, 1);

  0061c	6a 01		 push	 1
  0061e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00621	0f b6 88 fa 02
	00 00		 movzx	 ecx, BYTE PTR [eax+762]
  00628	51		 push	 ecx
  00629	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0062c	52		 push	 edx
  0062d	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  00632	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN36@gObjSetMon:

; 5048 : 
; 5049 : #ifdef ADD_NEW_MAP_KALIMA_20040518		//    
; 5050 : 		if (
; 5051 : 			lpObj->Class == 144 ||		//  1
; 5052 : 			lpObj->Class == 174 ||		//  2
; 5053 : 			lpObj->Class == 182 ||		//  3
; 5054 : 			lpObj->Class == 190 ||		//  4
; 5055 : 			lpObj->Class == 260 ||		//  5

  00635	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00638	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0063f	81 f9 90 00 00
	00		 cmp	 ecx, 144		; 00000090H
  00645	74 5a		 je	 SHORT $LN38@gObjSetMon
  00647	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0064a	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00651	81 f9 ae 00 00
	00		 cmp	 ecx, 174		; 000000aeH
  00657	74 48		 je	 SHORT $LN38@gObjSetMon
  00659	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0065c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00663	81 f9 b6 00 00
	00		 cmp	 ecx, 182		; 000000b6H
  00669	74 36		 je	 SHORT $LN38@gObjSetMon
  0066b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0066e	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00675	81 f9 be 00 00
	00		 cmp	 ecx, 190		; 000000beH
  0067b	74 24		 je	 SHORT $LN38@gObjSetMon
  0067d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00680	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00687	81 f9 04 01 00
	00		 cmp	 ecx, 260		; 00000104H
  0068d	74 12		 je	 SHORT $LN38@gObjSetMon
  0068f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00692	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00699	81 f9 0c 01 00
	00		 cmp	 ecx, 268		; 0000010cH
  0069f	75 10		 jne	 SHORT $LN37@gObjSetMon
$LN38@gObjSetMon:

; 5056 : 			lpObj->Class == 268			//  6
; 5057 : //			||	lpObj->Class == 161 ||	//  1
; 5058 : //			lpObj->Class == 181 || 		//  2
; 5059 : //			lpObj->Class == 189 || 		//  3
; 5060 : //			lpObj->Class == 197 || 		//  4
; 5061 : //			lpObj->Class == 267 || 		//  5
; 5062 : //			lpObj->Class == 275 		//  6
; 5063 : 			)
; 5064 : 		{
; 5065 : 			// 
; 5066 : //			gObjMonsterMagicAdd(lpObj, 3, 1);
; 5067 : 			//  
; 5068 : 			gObjMonsterMagicAdd(lpObj, 17, 1);

  006a1	6a 01		 push	 1
  006a3	6a 11		 push	 17			; 00000011H
  006a5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006a8	50		 push	 eax
  006a9	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  006ae	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN37@gObjSetMon:

; 5069 : 		}
; 5070 : 
; 5071 : 
; 5072 : 		if (
; 5073 : 			lpObj->Class == 145 ||		//  1
; 5074 : 			lpObj->Class == 175 ||		//  2
; 5075 : 			lpObj->Class == 183 ||		//  3
; 5076 : 			lpObj->Class == 191 ||		//  4
; 5077 : 			lpObj->Class == 261 ||		//  5
; 5078 : 			lpObj->Class == 269 ||		//  6
; 5079 : 			lpObj->Class == 146 ||		//  1
; 5080 : 			lpObj->Class == 176 || 		//  2
; 5081 : 			lpObj->Class == 184 ||		//  3
; 5082 : 			lpObj->Class == 192 ||		//  4
; 5083 : 			lpObj->Class == 262 ||		//  5
; 5084 : 			lpObj->Class == 270 ||		//  6
; 5085 : 			lpObj->Class == 147 ||		//  1
; 5086 : 			lpObj->Class == 177 ||		//  2
; 5087 : 			lpObj->Class == 185 ||		//  3
; 5088 : 			lpObj->Class == 193 ||		//  4
; 5089 : 			lpObj->Class == 263 ||		//  5
; 5090 : 			lpObj->Class == 271 ||		//  6
; 5091 : 			lpObj->Class == 148 ||		//  1
; 5092 : 			lpObj->Class == 178 ||		//  2
; 5093 : 			lpObj->Class == 186 ||		//  3
; 5094 : 			lpObj->Class == 194 ||		//  4
; 5095 : 			lpObj->Class == 264 ||		//  5
; 5096 : 			lpObj->Class == 272 ||		//  6
; 5097 : //			lpObj->Class == 149 ||		// 1
; 5098 : //			lpObj->Class == 179 ||		// 2
; 5099 : //			lpObj->Class == 187 ||		// 3
; 5100 : //			lpObj->Class == 195 ||		// 4
; 5101 : //			lpObj->Class == 265 ||		// 5
; 5102 : //			lpObj->Class == 273 ||		// 6
; 5103 : 			lpObj->Class == 160 ||		//  1
; 5104 : 			lpObj->Class == 180 ||		//  2
; 5105 : 			lpObj->Class == 188 ||		//  3
; 5106 : 			lpObj->Class == 196 ||		//  4
; 5107 : 			lpObj->Class == 266 ||		//  5

  006b1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006b4	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  006bb	81 f9 91 00 00
	00		 cmp	 ecx, 145		; 00000091H
  006c1	0f 84 5e 02 00
	00		 je	 $LN40@gObjSetMon
  006c7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006ca	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  006d1	81 f9 af 00 00
	00		 cmp	 ecx, 175		; 000000afH
  006d7	0f 84 48 02 00
	00		 je	 $LN40@gObjSetMon
  006dd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006e0	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  006e7	81 f9 b7 00 00
	00		 cmp	 ecx, 183		; 000000b7H
  006ed	0f 84 32 02 00
	00		 je	 $LN40@gObjSetMon
  006f3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006f6	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  006fd	81 f9 bf 00 00
	00		 cmp	 ecx, 191		; 000000bfH
  00703	0f 84 1c 02 00
	00		 je	 $LN40@gObjSetMon
  00709	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0070c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00713	81 f9 05 01 00
	00		 cmp	 ecx, 261		; 00000105H
  00719	0f 84 06 02 00
	00		 je	 $LN40@gObjSetMon
  0071f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00722	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00729	81 f9 0d 01 00
	00		 cmp	 ecx, 269		; 0000010dH
  0072f	0f 84 f0 01 00
	00		 je	 $LN40@gObjSetMon
  00735	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00738	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0073f	81 f9 92 00 00
	00		 cmp	 ecx, 146		; 00000092H
  00745	0f 84 da 01 00
	00		 je	 $LN40@gObjSetMon
  0074b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0074e	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00755	81 f9 b0 00 00
	00		 cmp	 ecx, 176		; 000000b0H
  0075b	0f 84 c4 01 00
	00		 je	 $LN40@gObjSetMon
  00761	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00764	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0076b	81 f9 b8 00 00
	00		 cmp	 ecx, 184		; 000000b8H
  00771	0f 84 ae 01 00
	00		 je	 $LN40@gObjSetMon
  00777	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0077a	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00781	81 f9 c0 00 00
	00		 cmp	 ecx, 192		; 000000c0H
  00787	0f 84 98 01 00
	00		 je	 $LN40@gObjSetMon
  0078d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00790	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00797	81 f9 06 01 00
	00		 cmp	 ecx, 262		; 00000106H
  0079d	0f 84 82 01 00
	00		 je	 $LN40@gObjSetMon
  007a3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007a6	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  007ad	81 f9 0e 01 00
	00		 cmp	 ecx, 270		; 0000010eH
  007b3	0f 84 6c 01 00
	00		 je	 $LN40@gObjSetMon
  007b9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007bc	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  007c3	81 f9 93 00 00
	00		 cmp	 ecx, 147		; 00000093H
  007c9	0f 84 56 01 00
	00		 je	 $LN40@gObjSetMon
  007cf	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007d2	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  007d9	81 f9 b1 00 00
	00		 cmp	 ecx, 177		; 000000b1H
  007df	0f 84 40 01 00
	00		 je	 $LN40@gObjSetMon
  007e5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007e8	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  007ef	81 f9 b9 00 00
	00		 cmp	 ecx, 185		; 000000b9H
  007f5	0f 84 2a 01 00
	00		 je	 $LN40@gObjSetMon
  007fb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007fe	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00805	81 f9 c1 00 00
	00		 cmp	 ecx, 193		; 000000c1H
  0080b	0f 84 14 01 00
	00		 je	 $LN40@gObjSetMon
  00811	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00814	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0081b	81 f9 07 01 00
	00		 cmp	 ecx, 263		; 00000107H
  00821	0f 84 fe 00 00
	00		 je	 $LN40@gObjSetMon
  00827	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0082a	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00831	81 f9 0f 01 00
	00		 cmp	 ecx, 271		; 0000010fH
  00837	0f 84 e8 00 00
	00		 je	 $LN40@gObjSetMon
  0083d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00840	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00847	81 f9 94 00 00
	00		 cmp	 ecx, 148		; 00000094H
  0084d	0f 84 d2 00 00
	00		 je	 $LN40@gObjSetMon
  00853	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00856	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0085d	81 f9 b2 00 00
	00		 cmp	 ecx, 178		; 000000b2H
  00863	0f 84 bc 00 00
	00		 je	 $LN40@gObjSetMon
  00869	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0086c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00873	81 f9 ba 00 00
	00		 cmp	 ecx, 186		; 000000baH
  00879	0f 84 a6 00 00
	00		 je	 $LN40@gObjSetMon
  0087f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00882	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00889	81 f9 c2 00 00
	00		 cmp	 ecx, 194		; 000000c2H
  0088f	0f 84 90 00 00
	00		 je	 $LN40@gObjSetMon
  00895	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00898	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0089f	81 f9 08 01 00
	00		 cmp	 ecx, 264		; 00000108H
  008a5	74 7e		 je	 SHORT $LN40@gObjSetMon
  008a7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008aa	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  008b1	81 f9 10 01 00
	00		 cmp	 ecx, 272		; 00000110H
  008b7	74 6c		 je	 SHORT $LN40@gObjSetMon
  008b9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008bc	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  008c3	81 f9 a0 00 00
	00		 cmp	 ecx, 160		; 000000a0H
  008c9	74 5a		 je	 SHORT $LN40@gObjSetMon
  008cb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008ce	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  008d5	81 f9 b4 00 00
	00		 cmp	 ecx, 180		; 000000b4H
  008db	74 48		 je	 SHORT $LN40@gObjSetMon
  008dd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008e0	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  008e7	81 f9 bc 00 00
	00		 cmp	 ecx, 188		; 000000bcH
  008ed	74 36		 je	 SHORT $LN40@gObjSetMon
  008ef	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008f2	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  008f9	81 f9 c4 00 00
	00		 cmp	 ecx, 196		; 000000c4H
  008ff	74 24		 je	 SHORT $LN40@gObjSetMon
  00901	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00904	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0090b	81 f9 0a 01 00
	00		 cmp	 ecx, 266		; 0000010aH
  00911	74 12		 je	 SHORT $LN40@gObjSetMon
  00913	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00916	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0091d	81 f9 12 01 00
	00		 cmp	 ecx, 274		; 00000112H
  00923	75 10		 jne	 SHORT $LN39@gObjSetMon
$LN40@gObjSetMon:

; 5108 : 			lpObj->Class == 274			//  6
; 5109 : //			lpObj->Class == 161 ||		//  1
; 5110 : //			lpObj->Class == 181 || 		//  2
; 5111 : //			lpObj->Class == 189 || 		//  3
; 5112 : //			lpObj->Class == 197 || 		//  4
; 5113 : //			lpObj->Class == 267 || 		//  5
; 5114 : //			lpObj->Class == 275 		//  6
; 5115 : 			)
; 5116 : 		{
; 5117 : 			//  
; 5118 : 			gObjMonsterMagicAdd(lpObj, 17, 1);

  00925	6a 01		 push	 1
  00927	6a 11		 push	 17			; 00000011H
  00929	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0092c	50		 push	 eax
  0092d	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  00932	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN39@gObjSetMon:

; 5119 : 		}
; 5120 : 		
; 5121 : 		if (
; 5122 : 			lpObj->Class == 161 ||		//  1
; 5123 : 			lpObj->Class == 181 || 		//  2
; 5124 : 			lpObj->Class == 189 || 		//  3
; 5125 : 			lpObj->Class == 197 || 		//  4
; 5126 : 			lpObj->Class == 267 || 		//  5

  00935	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00938	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0093f	81 f9 a1 00 00
	00		 cmp	 ecx, 161		; 000000a1H
  00945	74 5a		 je	 SHORT $LN42@gObjSetMon
  00947	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0094a	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00951	81 f9 b5 00 00
	00		 cmp	 ecx, 181		; 000000b5H
  00957	74 48		 je	 SHORT $LN42@gObjSetMon
  00959	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0095c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00963	81 f9 bd 00 00
	00		 cmp	 ecx, 189		; 000000bdH
  00969	74 36		 je	 SHORT $LN42@gObjSetMon
  0096b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0096e	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00975	81 f9 c5 00 00
	00		 cmp	 ecx, 197		; 000000c5H
  0097b	74 24		 je	 SHORT $LN42@gObjSetMon
  0097d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00980	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00987	81 f9 0b 01 00
	00		 cmp	 ecx, 267		; 0000010bH
  0098d	74 12		 je	 SHORT $LN42@gObjSetMon
  0098f	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00992	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00999	81 f9 13 01 00
	00		 cmp	 ecx, 275		; 00000113H
  0099f	75 69		 jne	 SHORT $LN41@gObjSetMon
$LN42@gObjSetMon:

; 5127 : 			lpObj->Class == 275 		//  6
; 5128 : 			)
; 5129 : 		{
; 5130 : // !!! .    
; 5131 : 			//  
; 5132 : 			gObjMonsterMagicAdd(lpObj, AT_SKILL_SUMMON, 1);

  009a1	6a 01		 push	 1
  009a3	68 c8 00 00 00	 push	 200			; 000000c8H
  009a8	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009ab	50		 push	 eax
  009ac	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  009b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5133 : 			//  
; 5134 : 			gObjMonsterMagicAdd(lpObj, 17, 1);

  009b4	6a 01		 push	 1
  009b6	6a 11		 push	 17			; 00000011H
  009b8	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009bb	50		 push	 eax
  009bc	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  009c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5135 : 			// 
; 5136 : 			gObjMonsterMagicAdd(lpObj, 1, 1);

  009c4	6a 01		 push	 1
  009c6	6a 01		 push	 1
  009c8	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009cb	50		 push	 eax
  009cc	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  009d1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5137 : 			//  
; 5138 : 			gObjMonsterMagicAdd(lpObj, AT_SKILL_IMMUNE_TO_MAGIC, 1);

  009d4	6a 01		 push	 1
  009d6	68 c9 00 00 00	 push	 201			; 000000c9H
  009db	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009de	50		 push	 eax
  009df	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  009e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5139 : 			//  
; 5140 : 			gObjMonsterMagicAdd(lpObj, AT_SKILL_IMMUNE_TO_HARM, 1);

  009e7	6a 01		 push	 1
  009e9	68 ca 00 00 00	 push	 202			; 000000caH
  009ee	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009f1	50		 push	 eax
  009f2	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  009f7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5141 : 			//  ( )
; 5142 : 			gObjMonsterMagicAdd(lpObj, AT_SKILL_DEFENSEDOWN, 1);

  009fa	6a 01		 push	 1
  009fc	6a 37		 push	 55			; 00000037H
  009fe	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a01	50		 push	 eax
  00a02	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  00a07	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN41@gObjSetMon:

; 5143 : 
; 5144 : 		}
; 5145 : 
; 5146 : 		if (
; 5147 : 			lpObj->Class == 149 ||		// 1
; 5148 : 			lpObj->Class == 179 ||		// 2
; 5149 : 			lpObj->Class == 187 ||		// 3
; 5150 : 			lpObj->Class == 195 ||		// 4
; 5151 : 			lpObj->Class == 265 ||		// 5

  00a0a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a0d	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00a14	81 f9 95 00 00
	00		 cmp	 ecx, 149		; 00000095H
  00a1a	74 5a		 je	 SHORT $LN44@gObjSetMon
  00a1c	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a1f	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00a26	81 f9 b3 00 00
	00		 cmp	 ecx, 179		; 000000b3H
  00a2c	74 48		 je	 SHORT $LN44@gObjSetMon
  00a2e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a31	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00a38	81 f9 bb 00 00
	00		 cmp	 ecx, 187		; 000000bbH
  00a3e	74 36		 je	 SHORT $LN44@gObjSetMon
  00a40	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a43	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00a4a	81 f9 c3 00 00
	00		 cmp	 ecx, 195		; 000000c3H
  00a50	74 24		 je	 SHORT $LN44@gObjSetMon
  00a52	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a55	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00a5c	81 f9 09 01 00
	00		 cmp	 ecx, 265		; 00000109H
  00a62	74 12		 je	 SHORT $LN44@gObjSetMon
  00a64	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a67	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00a6e	81 f9 11 01 00
	00		 cmp	 ecx, 273		; 00000111H
  00a74	75 20		 jne	 SHORT $LN43@gObjSetMon
$LN44@gObjSetMon:

; 5152 : 			lpObj->Class == 273			// 6
; 5153 : 			)
; 5154 : 		{
; 5155 : 			//  
; 5156 : 			gObjMonsterMagicAdd(lpObj, 17, 1);

  00a76	6a 01		 push	 1
  00a78	6a 11		 push	 17			; 00000011H
  00a7a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a7d	50		 push	 eax
  00a7e	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  00a83	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5157 : 			// 
; 5158 : 			gObjMonsterMagicAdd(lpObj, 1, 1);

  00a86	6a 01		 push	 1
  00a88	6a 01		 push	 1
  00a8a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a8d	50		 push	 eax
  00a8e	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  00a93	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN43@gObjSetMon:

; 5159 : 		}
; 5160 : #endif
; 5161 : 
; 5162 : #ifdef FOR_BLOODCASTLE
; 5163 : 		if( 
; 5164 : 			lpObj->Class == 66 || 
; 5165 : 			lpObj->Class == 73 || 
; 5166 : 			lpObj->Class == 77 || 
; 5167 : 			lpObj->Class == 89 ||		// 1
; 5168 : 			lpObj->Class == 95 ||		// 2
; 5169 : 			lpObj->Class == 112 ||		// 3
; 5170 : 			lpObj->Class == 118 ||		// 4
; 5171 : 			lpObj->Class == 124 ||		// 5
; 5172 : 			lpObj->Class == 130			// 6
; 5173 : #ifdef BLOODCASTLE_EXTEND_20040314		//    
; 5174 : 			|| lpObj->Class == 143		// 7
; 5175 : #endif	
; 5176 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010		// 8   
; 5177 : 			|| lpObj->Class == 433		// 8
; 5178 : #endif			
; 5179 : #ifdef CHAOSCASTLE_SYSTEM_20040408		//       .
; 5180 : 			|| lpObj->Class == 163		//   - 1
; 5181 : 			|| lpObj->Class == 165		//   - 2
; 5182 : 			|| lpObj->Class == 167		//   - 3
; 5183 : 			|| lpObj->Class == 169		//   - 4
; 5184 : 			|| lpObj->Class == 171		//   - 5
; 5185 : 			|| lpObj->Class == 173		//   - 6

  00a96	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a99	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00aa0	83 f9 42	 cmp	 ecx, 66			; 00000042H
  00aa3	0f 84 15 01 00
	00		 je	 $LN46@gObjSetMon
  00aa9	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00aac	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00ab3	83 f9 49	 cmp	 ecx, 73			; 00000049H
  00ab6	0f 84 02 01 00
	00		 je	 $LN46@gObjSetMon
  00abc	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00abf	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00ac6	83 f9 4d	 cmp	 ecx, 77			; 0000004dH
  00ac9	0f 84 ef 00 00
	00		 je	 $LN46@gObjSetMon
  00acf	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ad2	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00ad9	83 f9 59	 cmp	 ecx, 89			; 00000059H
  00adc	0f 84 dc 00 00
	00		 je	 $LN46@gObjSetMon
  00ae2	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ae5	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00aec	83 f9 5f	 cmp	 ecx, 95			; 0000005fH
  00aef	0f 84 c9 00 00
	00		 je	 $LN46@gObjSetMon
  00af5	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00af8	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00aff	83 f9 70	 cmp	 ecx, 112		; 00000070H
  00b02	0f 84 b6 00 00
	00		 je	 $LN46@gObjSetMon
  00b08	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b0b	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00b12	83 f9 76	 cmp	 ecx, 118		; 00000076H
  00b15	0f 84 a3 00 00
	00		 je	 $LN46@gObjSetMon
  00b1b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b1e	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00b25	83 f9 7c	 cmp	 ecx, 124		; 0000007cH
  00b28	0f 84 90 00 00
	00		 je	 $LN46@gObjSetMon
  00b2e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b31	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00b38	81 f9 82 00 00
	00		 cmp	 ecx, 130		; 00000082H
  00b3e	74 7e		 je	 SHORT $LN46@gObjSetMon
  00b40	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b43	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00b4a	81 f9 8f 00 00
	00		 cmp	 ecx, 143		; 0000008fH
  00b50	74 6c		 je	 SHORT $LN46@gObjSetMon
  00b52	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b55	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00b5c	81 f9 a3 00 00
	00		 cmp	 ecx, 163		; 000000a3H
  00b62	74 5a		 je	 SHORT $LN46@gObjSetMon
  00b64	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b67	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00b6e	81 f9 a5 00 00
	00		 cmp	 ecx, 165		; 000000a5H
  00b74	74 48		 je	 SHORT $LN46@gObjSetMon
  00b76	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b79	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00b80	81 f9 a7 00 00
	00		 cmp	 ecx, 167		; 000000a7H
  00b86	74 36		 je	 SHORT $LN46@gObjSetMon
  00b88	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b8b	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00b92	81 f9 a9 00 00
	00		 cmp	 ecx, 169		; 000000a9H
  00b98	74 24		 je	 SHORT $LN46@gObjSetMon
  00b9a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b9d	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00ba4	81 f9 ab 00 00
	00		 cmp	 ecx, 171		; 000000abH
  00baa	74 12		 je	 SHORT $LN46@gObjSetMon
  00bac	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00baf	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00bb6	81 f9 ad 00 00
	00		 cmp	 ecx, 173		; 000000adH
  00bbc	75 10		 jne	 SHORT $LN45@gObjSetMon
$LN46@gObjSetMon:

; 5186 : #endif
; 5187 : #ifdef ADD_CHAOSCASTLE_FOR_MASTER_LEVEL_20071010	//  7
; 5188 : 			|| lpObj->Class == 427		//   - 7
; 5189 : #endif			
; 5190 : 			)
; 5191 : 		{
; 5192 : 			//  
; 5193 : 			gObjMonsterMagicAdd(lpObj, 17, 1);

  00bbe	6a 01		 push	 1
  00bc0	6a 11		 push	 17			; 00000011H
  00bc2	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bc5	50		 push	 eax
  00bc6	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  00bcb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN45@gObjSetMon:

; 5194 : 		}
; 5195 : 
; 5196 : 		if (
; 5197 : 			lpObj->Class == 89 ||		// 1
; 5198 : 			lpObj->Class == 95 ||		// 2
; 5199 : 			lpObj->Class == 112 ||		// 3
; 5200 : 			lpObj->Class == 118 ||		// 4
; 5201 : 			lpObj->Class == 124 ||		// 5
; 5202 : 			lpObj->Class == 130			// 6
; 5203 : #ifdef BLOODCASTLE_EXTEND_20040314		//    
; 5204 : 			|| lpObj->Class == 143		// 7

  00bce	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bd1	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00bd8	83 f9 59	 cmp	 ecx, 89			; 00000059H
  00bdb	74 60		 je	 SHORT $LN48@gObjSetMon
  00bdd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00be0	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00be7	83 f9 5f	 cmp	 ecx, 95			; 0000005fH
  00bea	74 51		 je	 SHORT $LN48@gObjSetMon
  00bec	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bef	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00bf6	83 f9 70	 cmp	 ecx, 112		; 00000070H
  00bf9	74 42		 je	 SHORT $LN48@gObjSetMon
  00bfb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bfe	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00c05	83 f9 76	 cmp	 ecx, 118		; 00000076H
  00c08	74 33		 je	 SHORT $LN48@gObjSetMon
  00c0a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c0d	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00c14	83 f9 7c	 cmp	 ecx, 124		; 0000007cH
  00c17	74 24		 je	 SHORT $LN48@gObjSetMon
  00c19	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c1c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00c23	81 f9 82 00 00
	00		 cmp	 ecx, 130		; 00000082H
  00c29	74 12		 je	 SHORT $LN48@gObjSetMon
  00c2b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c2e	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00c35	81 f9 8f 00 00
	00		 cmp	 ecx, 143		; 0000008fH
  00c3b	75 10		 jne	 SHORT $LN47@gObjSetMon
$LN48@gObjSetMon:

; 5205 : #endif			
; 5206 : #ifdef ADD_BLOODCASTLE_FOR_MASTER_LEVEL_20071010		//    
; 5207 : 			|| lpObj->Class == 433		// 8
; 5208 : #endif			
; 5209 : 			)
; 5210 : 		{
; 5211 : 			//           1/2  .
; 5212 : 			gObjMonsterMagicAdd(lpObj, 3, 1);

  00c3d	6a 01		 push	 1
  00c3f	6a 03		 push	 3
  00c41	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c44	50		 push	 eax
  00c45	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMonsterMagicAdd
  00c4a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN47@gObjSetMon:

; 5213 : 		}
; 5214 : #else
; 5215 : 		if( lpObj->Class == 66 || lpObj->Class == 73 || lpObj->Class == 77)
; 5216 : 		{
; 5217 : 			gObjMonsterMagicAdd(lpObj, 17, 1);
; 5218 : 		}
; 5219 : #endif
; 5220 : 
; 5221 : 	}
; 5222 : 
; 5223 : 	gObjGiveItemSearch(lpObj, lpm->m_MaxItemLevel);

  00c4d	8b 45 f0	 mov	 eax, DWORD PTR _lpm$[ebp]
  00c50	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00c53	51		 push	 ecx
  00c54	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c57	52		 push	 edx
  00c58	e8 00 00 00 00	 call	 ?gObjGiveItemSearch@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjGiveItemSearch
  00c5d	83 c4 08	 add	 esp, 8

; 5224 : 	gObjGiveItemWarehouseSearch(lpObj, lpm->m_MaxItemLevel);

  00c60	8b 45 f0	 mov	 eax, DWORD PTR _lpm$[ebp]
  00c63	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00c66	51		 push	 ecx
  00c67	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c6a	52		 push	 edx
  00c6b	e8 00 00 00 00	 call	 ?gObjGiveItemWarehouseSearch@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjGiveItemWarehouseSearch
  00c70	83 c4 08	 add	 esp, 8

; 5225 : 	CreateFrustrum(lpObj->X, lpObj->Y, aIndex);

  00c73	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00c76	50		 push	 eax
  00c77	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c7a	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  00c81	52		 push	 edx
  00c82	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c85	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00c8c	51		 push	 ecx
  00c8d	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  00c92	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5226 : 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->X, lpObj->Y);

  00c95	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c98	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00c9f	51		 push	 ecx
  00ca0	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ca3	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  00caa	50		 push	 eax
  00cab	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00cae	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00cb5	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00cbb	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00cc1	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 5227 : 	lpObj->m_OldX = lpObj->X;

  00cc6	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cc9	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00ccc	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  00cd3	66 89 90 1c 01
	00 00		 mov	 WORD PTR [eax+284], dx

; 5228 : 	lpObj->m_OldY = lpObj->Y;

  00cda	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cdd	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00ce0	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  00ce7	66 89 90 1e 01
	00 00		 mov	 WORD PTR [eax+286], dx

; 5229 : 
; 5230 : 	//------------------------------------------------------------------------
; 5231 : 
; 5232 : #ifdef FOR_BLOODCASTLE
; 5233 : 	lpObj->LastAttackerID = -1;

  00cee	83 c8 ff	 or	 eax, -1
  00cf1	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00cf4	66 89 81 b2 02
	00 00		 mov	 WORD PTR [ecx+690], ax

; 5234 : #endif
; 5235 : 		
; 5236 : 	return TRUE;

  00cfb	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjSetMon:

; 5237 : }

  00d00	5f		 pop	 edi
  00d01	5e		 pop	 esi
  00d02	5b		 pop	 ebx
  00d03	8b e5		 mov	 esp, ebp
  00d05	5d		 pop	 ebp
  00d06	c3		 ret	 0
  00d07	90		 npad	 1
$LN55@gObjSetMon:
  00d08	00 00 00 00	 DD	 $LN5@gObjSetMon
  00d0c	00 00 00 00	 DD	 $LN18@gObjSetMon
  00d10	00 00 00 00	 DD	 $LN17@gObjSetMon
  00d14	00 00 00 00	 DD	 $LN21@gObjSetMon
  00d18	00 00 00 00	 DD	 $LN20@gObjSetMon
  00d1c	00 00 00 00	 DD	 $LN11@gObjSetMon
  00d20	00 00 00 00	 DD	 $LN19@gObjSetMon
  00d24	00 00 00 00	 DD	 $LN16@gObjSetMon
  00d28	00 00 00 00	 DD	 $LN15@gObjSetMon
  00d2c	00 00 00 00	 DD	 $LN12@gObjSetMon
  00d30	00 00 00 00	 DD	 $LN13@gObjSetMon
  00d34	00 00 00 00	 DD	 $LN14@gObjSetMon
  00d38	00 00 00 00	 DD	 $LN10@gObjSetMon
  00d3c	00 00 00 00	 DD	 $LN9@gObjSetMon
  00d40	00 00 00 00	 DD	 $LN6@gObjSetMon
  00d44	00 00 00 00	 DD	 $LN8@gObjSetMon
  00d48	00 00 00 00	 DD	 $LN7@gObjSetMon
  00d4c	00 00 00 00	 DD	 $LN2@gObjSetMon
$LN54@gObjSetMon:
  00d50	00		 DB	 0
  00d51	11		 DB	 17			; 00000011H
  00d52	11		 DB	 17			; 00000011H
  00d53	11		 DB	 17			; 00000011H
  00d54	11		 DB	 17			; 00000011H
  00d55	11		 DB	 17			; 00000011H
  00d56	11		 DB	 17			; 00000011H
  00d57	11		 DB	 17			; 00000011H
  00d58	11		 DB	 17			; 00000011H
  00d59	11		 DB	 17			; 00000011H
  00d5a	11		 DB	 17			; 00000011H
  00d5b	11		 DB	 17			; 00000011H
  00d5c	11		 DB	 17			; 00000011H
  00d5d	11		 DB	 17			; 00000011H
  00d5e	11		 DB	 17			; 00000011H
  00d5f	11		 DB	 17			; 00000011H
  00d60	11		 DB	 17			; 00000011H
  00d61	11		 DB	 17			; 00000011H
  00d62	11		 DB	 17			; 00000011H
  00d63	11		 DB	 17			; 00000011H
  00d64	11		 DB	 17			; 00000011H
  00d65	11		 DB	 17			; 00000011H
  00d66	11		 DB	 17			; 00000011H
  00d67	11		 DB	 17			; 00000011H
  00d68	11		 DB	 17			; 00000011H
  00d69	11		 DB	 17			; 00000011H
  00d6a	11		 DB	 17			; 00000011H
  00d6b	11		 DB	 17			; 00000011H
  00d6c	11		 DB	 17			; 00000011H
  00d6d	11		 DB	 17			; 00000011H
  00d6e	01		 DB	 1
  00d6f	02		 DB	 2
  00d70	11		 DB	 17			; 00000011H
  00d71	11		 DB	 17			; 00000011H
  00d72	11		 DB	 17			; 00000011H
  00d73	11		 DB	 17			; 00000011H
  00d74	03		 DB	 3
  00d75	11		 DB	 17			; 00000011H
  00d76	04		 DB	 4
  00d77	05		 DB	 5
  00d78	06		 DB	 6
  00d79	11		 DB	 17			; 00000011H
  00d7a	07		 DB	 7
  00d7b	08		 DB	 8
  00d7c	09		 DB	 9
  00d7d	0a		 DB	 10			; 0000000aH
  00d7e	0b		 DB	 11			; 0000000bH
  00d7f	11		 DB	 17			; 00000011H
  00d80	0c		 DB	 12			; 0000000cH
  00d81	11		 DB	 17			; 00000011H
  00d82	0d		 DB	 13			; 0000000dH
  00d83	0e		 DB	 14			; 0000000eH
  00d84	11		 DB	 17			; 00000011H
  00d85	05		 DB	 5
  00d86	0f		 DB	 15			; 0000000fH
  00d87	10		 DB	 16			; 00000010H
?gObjSetMonster@@YAHHH@Z ENDP				; gObjSetMonster
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSetCharacter@@YAHPAEH@Z
_TEXT	SEGMENT
tv1020 = -460						; size = 4
tv300 = -460						; size = 4
tv274 = -460						; size = 4
tv214 = -460						; size = 4
tv66 = -460						; size = 4
tv1494 = -456						; size = 4
tv1021 = -456						; size = 4
tv510 = -456						; size = 4
tv480 = -456						; size = 4
tv472 = -456						; size = 4
tv464 = -456						; size = 4
tv456 = -456						; size = 4
tv301 = -456						; size = 4
tv275 = -456						; size = 4
tv215 = -456						; size = 4
tv67 = -456						; size = 4
$T2 = -452						; size = 4
$T3 = -448						; size = 8
$T4 = -440						; size = 4
_Golds$ = -372						; size = 4
_pNotice$5 = -368					; size = 272
_weather$ = -93						; size = 1
_iX$6 = -92						; size = 4
_bAllItemExist$ = -85					; size = 1
_StrongFear$7 = -84					; size = 4
_EnergyBall$8 = -80					; size = 4
_userlevel$ = -76					; size = 4
_gt$ = -72						; size = 4
_level$ = -68						; size = 2
_dir$ = -62						; size = 1
_mapNumber$ = -61					; size = 1
_y$ = -60						; size = 2
_x$ = -56						; size = 2
_result$ = -52						; size = 4
_attr$ = -45						; size = 1
_lpObj$ = -44						; size = 4
_lpMsg$ = -40						; size = 4
_szCharName$ = -36					; size = 11
_n$ = -24						; size = 4
_itype$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lpdata$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?gObjSetCharacter@@YAHPAEH@Z PROC			; gObjSetCharacter, COMDAT

; 2961 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?gObjSetCharacter@@YAHPAEH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 01 00
	00		 sub	 esp, 448		; 000001c0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 2962 : 	int itype;
; 2963 : 	int n;
; 2964 : 	char szCharName[MAX_IDSTRING+1];
; 2965 : 
; 2966 : 	LPSDHP_DBCHAR_INFORESULT lpMsg = (LPSDHP_DBCHAR_INFORESULT)lpdata;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _lpdata$[ebp]
  00031	89 45 d8	 mov	 DWORD PTR _lpMsg$[ebp], eax

; 2967 : 	
; 2968 : 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT)  )

  00034	83 7d 0c 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  00038	7d 0c		 jge	 SHORT $LN83@gObjSetCha
  0003a	c7 85 38 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv67[ebp], 0
  00044	eb 2b		 jmp	 SHORT $LN84@gObjSetCha
$LN83@gObjSetCha:
  00046	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0004d	7e 0c		 jle	 SHORT $LN81@gObjSetCha
  0004f	c7 85 34 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
  00059	eb 0a		 jmp	 SHORT $LN82@gObjSetCha
$LN81@gObjSetCha:
  0005b	c7 85 34 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
$LN82@gObjSetCha:
  00065	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv66[ebp]
  0006b	89 85 38 fe ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
$LN84@gObjSetCha:
  00071	83 bd 38 fe ff
	ff 00		 cmp	 DWORD PTR tv67[ebp], 0
  00078	75 23		 jne	 SHORT $LN8@gObjSetCha

; 2969 : 	{
; 2970 : 		LogAdd("error : %s %d",__FILE__, __LINE__);

  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjSetCharacter@@YAHPAEH@Z@4JA
  0007f	83 c0 09	 add	 eax, 9
  00082	50		 push	 eax
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2971 : 		return FALSE;

  00096	33 c0		 xor	 eax, eax
  00098	e9 9b 15 00 00	 jmp	 $LN1@gObjSetCha
$LN8@gObjSetCha:

; 2972 : 	}
; 2973 : 	LPOBJECTSTRUCT	lpObj;
; 2974 : 
; 2975 : 	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  0009d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a4	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000aa	89 45 d4	 mov	 DWORD PTR _lpObj$[ebp], eax

; 2976 : 	if( lpObj->Connected < CSS_LOGINOK )

  000ad	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b0	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  000b4	7d 07		 jge	 SHORT $LN9@gObjSetCha

; 2977 : 	{
; 2978 : 		return FALSE;

  000b6	33 c0		 xor	 eax, eax
  000b8	e9 7b 15 00 00	 jmp	 $LN1@gObjSetCha
$LN9@gObjSetCha:

; 2979 : 	}
; 2980 : 	
; 2981 : 	//     .. .
; 2982 : 	if( gObj[aIndex].Connected == CSS_GAMEPLAYING )	

  000bd	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ca	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  000cf	75 47		 jne	 SHORT $LN10@gObjSetCha

; 2983 : 	{
; 2984 : 		LogAddC(LOGC_RED,lMsg.Get(498), gObj[aIndex].AccountID, gObj[aIndex].Name);

  000d1	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000de	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  000e2	52		 push	 edx
  000e3	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000ea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f0	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  000f4	52		 push	 edx
  000f5	68 f2 01 00 00	 push	 498			; 000001f2H
  000fa	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00105	50		 push	 eax
  00106	6a 02		 push	 2
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0010e	83 c4 10	 add	 esp, 16			; 00000010H

; 2985 : 		return FALSE;

  00111	33 c0		 xor	 eax, eax
  00113	e9 20 15 00 00	 jmp	 $LN1@gObjSetCha
$LN10@gObjSetCha:

; 2986 : 	}
; 2987 : 		
; 2988 : #ifdef NEW_SKILL_FORSKYLAND
; 2989 : 	if( (lpMsg->Class) == 0  ||	(lpMsg->Class) == 16 ||
; 2990 : 		(lpMsg->Class) == 32 ||	(lpMsg->Class) == 48 || 
; 2991 : 
; 2992 : //  
; 2993 : 		(lpMsg->Class) == 1  ||	(lpMsg->Class) == 17 ||
; 2994 : 		(lpMsg->Class) == 33 
; 2995 : #ifdef DARKLORD_WORK		
; 2996 : 		|| lpMsg->Class == 64

  00118	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0011b	0f b6 48 1d	 movzx	 ecx, BYTE PTR [eax+29]
  0011f	85 c9		 test	 ecx, ecx
  00121	74 54		 je	 SHORT $LN13@gObjSetCha
  00123	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00126	0f b6 48 1d	 movzx	 ecx, BYTE PTR [eax+29]
  0012a	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0012d	74 48		 je	 SHORT $LN13@gObjSetCha
  0012f	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00132	0f b6 48 1d	 movzx	 ecx, BYTE PTR [eax+29]
  00136	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00139	74 3c		 je	 SHORT $LN13@gObjSetCha
  0013b	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0013e	0f b6 48 1d	 movzx	 ecx, BYTE PTR [eax+29]
  00142	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00145	74 30		 je	 SHORT $LN13@gObjSetCha
  00147	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0014a	0f b6 48 1d	 movzx	 ecx, BYTE PTR [eax+29]
  0014e	83 f9 01	 cmp	 ecx, 1
  00151	74 24		 je	 SHORT $LN13@gObjSetCha
  00153	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00156	0f b6 48 1d	 movzx	 ecx, BYTE PTR [eax+29]
  0015a	83 f9 11	 cmp	 ecx, 17			; 00000011H
  0015d	74 18		 je	 SHORT $LN13@gObjSetCha
  0015f	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00162	0f b6 48 1d	 movzx	 ecx, BYTE PTR [eax+29]
  00166	83 f9 21	 cmp	 ecx, 33			; 00000021H
  00169	74 0c		 je	 SHORT $LN13@gObjSetCha
  0016b	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0016e	0f b6 48 1d	 movzx	 ecx, BYTE PTR [eax+29]
  00172	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00175	75 02		 jne	 SHORT $LN11@gObjSetCha
$LN13@gObjSetCha:

; 2997 : #endif
; 2998 : #ifdef THIRD_CHANGEUP_SYSTEM_20070507	//    - 3   
; 2999 : 		|| lpMsg->Class	== GRAND_MASTER
; 3000 : 		|| lpMsg->Class	== BLADE_MASTER
; 3001 : 		|| lpMsg->Class	== HIGH_ELF
; 3002 : 		|| lpMsg->Class	== DUEL_MASTER
; 3003 : 		|| lpMsg->Class	== LORD_EMPEROR
; 3004 : #endif
; 3005 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//  ''
; 3006 : 		|| lpMsg->Class	== 80
; 3007 : 		|| lpMsg->Class	== BLOODY_SUMMONER	// 1
; 3008 : 		|| lpMsg->Class	== DIMENSION_MASTER	// 3
; 3009 : #endif
; 3010 : 		)
; 3011 : 	{
; 3012 : 		//  .
; 3013 : 	}

  00177	eb 07		 jmp	 SHORT $LN12@gObjSetCha
$LN11@gObjSetCha:

; 3014 : 	else 
; 3015 : 	{		
; 3016 : 		return FALSE;

  00179	33 c0		 xor	 eax, eax
  0017b	e9 b8 14 00 00	 jmp	 $LN1@gObjSetCha
$LN12@gObjSetCha:

; 3017 : 	}
; 3018 : #else
; 3019 : 	if( (lpMsg->Class) == 0  ||	(lpMsg->Class) == 16 ||
; 3020 : 		(lpMsg->Class) == 32 ||	(lpMsg->Class) == 48 )
; 3021 : 	{
; 3022 : 		//  .
; 3023 : 	}
; 3024 : 	else 
; 3025 : 	{		
; 3026 : 		return FALSE;
; 3027 : 	}
; 3028 : #endif
; 3029 : 
; 3030 : 
; 3031 : 	gObjCharZeroSet(aIndex);

  00180	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 ?gObjCharZeroSet@@YAXH@Z ; gObjCharZeroSet
  00189	83 c4 04	 add	 esp, 4

; 3032 : 
; 3033 : #ifdef MODIFY_MIX_SYSTEM_20070518
; 3034 : 	if( g_MixSystem.ChaosBoxInit(lpObj) == FALSE )

  0018c	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0018f	50		 push	 eax
  00190	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MixSystem@@3VCMixSystem@@A ; g_MixSystem
  00195	e8 00 00 00 00	 call	 ?ChaosBoxInit@CMixSystem@@QAEHPAVOBJECTSTRUCT@@@Z ; CMixSystem::ChaosBoxInit
  0019a	85 c0		 test	 eax, eax
  0019c	75 1c		 jne	 SHORT $LN14@gObjSetCha

; 3035 : 	{
; 3036 : 		LogAdd("error-L1 : ChaosBox Init error %s %d", __FILE__, __LINE__);

  0019e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjSetCharacter@@YAHPAEH@Z@4JA
  001a3	83 c0 4b	 add	 eax, 75			; 0000004bH
  001a6	50		 push	 eax
  001a7	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  001ac	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CDKKBDHM@error?9L1?5?3?5ChaosBox?5Init?5error?5@
  001b1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  001b7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@gObjSetCha:

; 3037 : 	}
; 3038 : #endif
; 3039 : 
; 3040 : 	lpObj->m_PosNum     = 0;

  001ba	33 c0		 xor	 eax, eax
  001bc	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001bf	66 89 81 0c 02
	00 00		 mov	 WORD PTR [ecx+524], ax

; 3041 : 	lpObj->Level		= lpMsg->Level;

  001c6	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c9	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  001cc	66 8b 51 1e	 mov	 dx, WORD PTR [ecx+30]
  001d0	66 89 90 a0 00
	00 00		 mov	 WORD PTR [eax+160], dx

; 3042 : 	lpObj->LevelUpPoint = lpMsg->LevelUpPoint;

  001d7	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001da	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  001dd	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  001e0	89 90 a4 00 00
	00		 mov	 DWORD PTR [eax+164], edx

; 3043 : 	lpObj->DbClass		= lpMsg->Class;

  001e6	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e9	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  001ec	8a 51 1d	 mov	 dl, BYTE PTR [ecx+29]
  001ef	88 90 9e 00 00
	00		 mov	 BYTE PTR [eax+158], dl

; 3044 : 	lpObj->Class		= lpMsg->Class>>4;

  001f5	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  001f8	0f b6 48 1d	 movzx	 ecx, BYTE PTR [eax+29]
  001fc	c1 f9 04	 sar	 ecx, 4
  001ff	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00202	66 89 8a 9c 00
	00 00		 mov	 WORD PTR [edx+156], cx

; 3045 : #ifdef THIRD_CHANGEUP_SYSTEM_20070507	//   
; 3046 : 	int iChangeUp			= ( lpMsg->Class )&CHANGEUP_MASK;
; 3047 : 	lpObj->ChangeUP			= iChangeUp&0x01;		// 2 
; 3048 : 	lpObj->ThirdChangeUp	= ( iChangeUp&0x02 ) >> 1;		// 3 
; 3049 : #else
; 3050 : #ifdef NEW_SKILL_FORSKYLAND
; 3051 : 	lpObj->ChangeUP		= (lpMsg->Class)&CHANGEUP_MASK;		//   ?

  00209	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0020c	0f b6 48 1d	 movzx	 ecx, BYTE PTR [eax+29]
  00210	83 e1 07	 and	 ecx, 7
  00213	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00216	88 8a 9f 00 00
	00		 mov	 BYTE PTR [edx+159], cl

; 3052 : #else
; 3053 : 	lpObj->Skin			= lpMsg->Class&0x0F;
; 3054 : #endif
; 3055 : 
; 3056 : #endif	// THIRD_CHANGEUP_SYSTEM_20070507
; 3057 : 
; 3058 : 	
; 3059 : 	szCharName[MAX_IDSTRING] = '\0';

  0021c	b8 01 00 00 00	 mov	 eax, 1
  00221	6b c8 0a	 imul	 ecx, eax, 10
  00224	89 8d 48 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
  0022a	83 bd 48 fe ff
	ff 0b		 cmp	 DWORD PTR $T4[ebp], 11	; 0000000bH
  00231	73 02		 jae	 SHORT $LN85@gObjSetCha
  00233	eb 05		 jmp	 SHORT $LN86@gObjSetCha
$LN85@gObjSetCha:
  00235	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN86@gObjSetCha:
  0023a	8b 95 48 fe ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
  00240	c6 44 15 dc 00	 mov	 BYTE PTR _szCharName$[ebp+edx], 0

; 3060 : 	memcpy(szCharName, lpMsg->Name, MAX_IDSTRING);

  00245	6a 0a		 push	 10			; 0000000aH
  00247	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0024a	83 c0 12	 add	 eax, 18			; 00000012H
  0024d	50		 push	 eax
  0024e	8d 4d dc	 lea	 ecx, DWORD PTR _szCharName$[ebp]
  00251	51		 push	 ecx
  00252	e8 00 00 00 00	 call	 _memcpy
  00257	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3061 : 	strcpy(lpObj->Name, szCharName);

  0025a	8d 45 dc	 lea	 eax, DWORD PTR _szCharName$[ebp]
  0025d	50		 push	 eax
  0025e	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00261	83 c1 73	 add	 ecx, 115		; 00000073H
  00264	51		 push	 ecx
  00265	e8 00 00 00 00	 call	 _strcpy
  0026a	83 c4 08	 add	 esp, 8

; 3062 : 	//LogAdd("   : [%s][%s] ", lpObj->AccountID, lpObj->Name);
; 3063 : 
; 3064 : 	if( lpObj->Level < 1 )

  0026d	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00270	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00277	83 f9 01	 cmp	 ecx, 1
  0027a	7d 1e		 jge	 SHORT $LN15@gObjSetCha

; 3065 : 	{
; 3066 : 		LogAddC(LOGC_RED, "error : %s Level Zero", lpMsg->Name);

  0027c	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0027f	83 c0 12	 add	 eax, 18			; 00000012H
  00282	50		 push	 eax
  00283	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PGPOOLHE@error?5?3?5?$CFs?5Level?5Zero@
  00288	6a 02		 push	 2
  0028a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00290	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3067 : 		return FALSE;

  00293	33 c0		 xor	 eax, eax
  00295	e9 9e 13 00 00	 jmp	 $LN1@gObjSetCha
$LN15@gObjSetCha:

; 3068 : 	}
; 3069 : 
; 3070 : 	lpObj->X			= lpMsg->MapX;

  0029a	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0029d	66 0f b6 88 2d
	05 00 00	 movzx	 cx, BYTE PTR [eax+1325]
  002a5	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002a8	66 89 8a 04 01
	00 00		 mov	 WORD PTR [edx+260], cx

; 3071 : 	lpObj->Y			= lpMsg->MapY;

  002af	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  002b2	66 0f b6 88 2e
	05 00 00	 movzx	 cx, BYTE PTR [eax+1326]
  002ba	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002bd	66 89 8a 06 01
	00 00		 mov	 WORD PTR [edx+262], cx

; 3072 : 	lpObj->MapNumber	= lpMsg->MapNumber;

  002c4	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c7	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  002ca	8a 91 2c 05 00
	00		 mov	 dl, BYTE PTR [ecx+1324]
  002d0	88 90 09 01 00
	00		 mov	 BYTE PTR [eax+265], dl

; 3073 : 
; 3074 : 	lpObj->StartX       = (BYTE)lpObj->X;

  002d6	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002d9	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002dc	8a 91 04 01 00
	00		 mov	 dl, BYTE PTR [ecx+260]
  002e2	88 90 1a 01 00
	00		 mov	 BYTE PTR [eax+282], dl

; 3075 : 	lpObj->StartY       = (BYTE)lpObj->Y;

  002e8	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002eb	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002ee	8a 91 06 01 00
	00		 mov	 dl, BYTE PTR [ecx+262]
  002f4	88 90 1b 01 00
	00		 mov	 BYTE PTR [eax+283], dl

; 3076 : 	
; 3077 : 	if( !CHECK_LIMIT(lpObj->MapNumber, g_TerrainManager.Size())  )

  002fa	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002fd	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00304	85 c9		 test	 ecx, ecx
  00306	7d 0c		 jge	 SHORT $LN89@gObjSetCha
  00308	c7 85 38 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv215[ebp], 0
  00312	eb 3d		 jmp	 SHORT $LN90@gObjSetCha
$LN89@gObjSetCha:
  00314	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00317	0f b6 b2 09 01
	00 00		 movzx	 esi, BYTE PTR [edx+265]
  0031e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  00323	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size
  00328	83 e8 01	 sub	 eax, 1
  0032b	3b f0		 cmp	 esi, eax
  0032d	7e 0c		 jle	 SHORT $LN87@gObjSetCha
  0032f	c7 85 34 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv214[ebp], 0
  00339	eb 0a		 jmp	 SHORT $LN88@gObjSetCha
$LN87@gObjSetCha:
  0033b	c7 85 34 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv214[ebp], 1
$LN88@gObjSetCha:
  00345	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv214[ebp]
  0034b	89 85 38 fe ff
	ff		 mov	 DWORD PTR tv215[ebp], eax
$LN90@gObjSetCha:
  00351	83 bd 38 fe ff
	ff 00		 cmp	 DWORD PTR tv215[ebp], 0
  00358	75 63		 jne	 SHORT $LN16@gObjSetCha

; 3078 : 	{
; 3079 : 		LogAdd("error : Map Number max over. %s %d",__FILE__, __LINE__);

  0035a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjSetCharacter@@YAHPAEH@Z@4JA
  0035f	83 c0 76	 add	 eax, 118		; 00000076H
  00362	50		 push	 eax
  00363	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00368	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JILLGNNC@error?5?3?5Map?5Number?5max?5over?4?5?$CFs@
  0036d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00373	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3080 : 		lpObj->MapNumber = 0;

  00376	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00379	c6 80 09 01 00
	00 00		 mov	 BYTE PTR [eax+265], 0

; 3081 : 		MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );

  00380	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00383	05 06 01 00 00	 add	 eax, 262		; 00000106H
  00388	50		 push	 eax
  00389	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0038c	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00392	51		 push	 ecx
  00393	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00396	66 0f b6 82 09
	01 00 00	 movzx	 ax, BYTE PTR [edx+265]
  0039e	0f b7 c8	 movzx	 ecx, ax
  003a1	51		 push	 ecx
  003a2	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003a5	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  003ac	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  003b2	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  003b8	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos
$LN16@gObjSetCha:

; 3082 : 	}
; 3083 : 	
; 3084 : 	//  6        ..
; 3085 : 	//  , ..
; 3086 : #ifdef DEVILSQUARE_EXTEND_20050221		//    
; 3087 : 	if( lpObj->Level < 6 || CHECK_DEVILSQUARE(lpObj->MapNumber) )
; 3088 : #else
; 3089 : 	if( lpObj->Level < 6 || lpObj->MapNumber == 9 )

  003bd	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003c0	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  003c7	83 f9 06	 cmp	 ecx, 6
  003ca	7c 13		 jl	 SHORT $LN18@gObjSetCha
  003cc	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003cf	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  003d6	83 f9 09	 cmp	 ecx, 9
  003d9	0f 85 9b 00 00
	00		 jne	 $LN20@gObjSetCha
$LN18@gObjSetCha:

; 3090 : #endif
; 3091 : 	{
; 3092 : 		if( lpObj->Class == CLASS_ELF )	{

  003df	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003e2	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  003e9	83 f9 02	 cmp	 ecx, 2
  003ec	75 49		 jne	 SHORT $LN19@gObjSetCha

; 3093 : 			lpObj->MapNumber = 3;

  003ee	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003f1	c6 80 09 01 00
	00 03		 mov	 BYTE PTR [eax+265], 3

; 3094 : 			MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );

  003f8	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003fb	05 06 01 00 00	 add	 eax, 262		; 00000106H
  00400	50		 push	 eax
  00401	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00404	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  0040a	51		 push	 ecx
  0040b	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0040e	66 0f b6 82 09
	01 00 00	 movzx	 ax, BYTE PTR [edx+265]
  00416	0f b7 c8	 movzx	 ecx, ax
  00419	51		 push	 ecx
  0041a	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0041d	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00424	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  0042a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00430	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos

; 3095 : 		}

  00435	eb 43		 jmp	 SHORT $LN20@gObjSetCha
$LN19@gObjSetCha:

; 3096 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//  
; 3097 : 		else if( lpObj->Class == CLASS_SUMMONER )	{
; 3098 : 			lpObj->MapNumber = MAP_INDEX_ELBELAND;
; 3099 : 			MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );
; 3100 : 		}
; 3101 : #endif
; 3102 : 		else {
; 3103 : 			lpObj->MapNumber = 0;

  00437	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0043a	c6 80 09 01 00
	00 00		 mov	 BYTE PTR [eax+265], 0

; 3104 : 			MapC[lpObj->MapNumber].GetLevelPos(lpObj->Level, lpObj->X, lpObj->Y );

  00441	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00444	05 06 01 00 00	 add	 eax, 262		; 00000106H
  00449	50		 push	 eax
  0044a	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0044d	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00453	51		 push	 ecx
  00454	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00457	0f b7 82 a0 00
	00 00		 movzx	 eax, WORD PTR [edx+160]
  0045e	50		 push	 eax
  0045f	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00462	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00469	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  0046f	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00475	e8 00 00 00 00	 call	 ?GetLevelPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetLevelPos
$LN20@gObjSetCha:

; 3105 : 		}
; 3106 : 	}
; 3107 : 
; 3108 : #ifdef MODIFY_SANTACLAUSVILLAGE_VISITLEVEL
; 3109 : 	if (lpObj->MapNumber == MAP_INDEX_XMASEVENT && lpObj->Level < 15)
; 3110 : 	{
; 3111 : 		if( lpObj->Class == CLASS_ELF )	{
; 3112 : 			lpObj->MapNumber = 3;
; 3113 : 			MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );
; 3114 : 		}
; 3115 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//  
; 3116 : 		else if( lpObj->Class == CLASS_SUMMONER )	{
; 3117 : 			lpObj->MapNumber = MAP_INDEX_ELBELAND;
; 3118 : 			MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );
; 3119 : 		}
; 3120 : #endif
; 3121 : 		else {
; 3122 : 			lpObj->MapNumber = 0;
; 3123 : 			MapC[lpObj->MapNumber].GetLevelPos(lpObj->Level, lpObj->X, lpObj->Y );
; 3124 : 		}
; 3125 : 	}
; 3126 : #endif // MODIFY_SANTACLAUSVILLAGE_VISITLEVEL
; 3127 : 
; 3128 : 	
; 3129 : #ifdef FOR_BLOODCASTLE						//      
; 3130 : 	if( CHECK_BLOODCASTLE(lpObj->MapNumber) ) {

  0047a	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0047d	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00484	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00487	7d 0c		 jge	 SHORT $LN93@gObjSetCha
  00489	c7 85 38 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv275[ebp], 0
  00493	eb 31		 jmp	 SHORT $LN94@gObjSetCha
$LN93@gObjSetCha:
  00495	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00498	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0049f	83 f8 11	 cmp	 eax, 17			; 00000011H
  004a2	7e 0c		 jle	 SHORT $LN91@gObjSetCha
  004a4	c7 85 34 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv274[ebp], 0
  004ae	eb 0a		 jmp	 SHORT $LN92@gObjSetCha
$LN91@gObjSetCha:
  004b0	c7 85 34 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv274[ebp], 1
$LN92@gObjSetCha:
  004ba	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv274[ebp]
  004c0	89 8d 38 fe ff
	ff		 mov	 DWORD PTR tv275[ebp], ecx
$LN94@gObjSetCha:
  004c6	83 bd 38 fe ff
	ff 00		 cmp	 DWORD PTR tv275[ebp], 0
  004cd	74 47		 je	 SHORT $LN21@gObjSetCha

; 3131 : 		lpObj->MapNumber = 2;

  004cf	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004d2	c6 80 09 01 00
	00 02		 mov	 BYTE PTR [eax+265], 2

; 3132 : 		MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );

  004d9	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004dc	05 06 01 00 00	 add	 eax, 262		; 00000106H
  004e1	50		 push	 eax
  004e2	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  004e5	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  004eb	51		 push	 ecx
  004ec	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004ef	66 0f b6 82 09
	01 00 00	 movzx	 ax, BYTE PTR [edx+265]
  004f7	0f b7 c8	 movzx	 ecx, ax
  004fa	51		 push	 ecx
  004fb	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  004fe	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00505	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  0050b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00511	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos
$LN21@gObjSetCha:

; 3133 : 	}
; 3134 : 
; 3135 : 	lpObj->m_cBloodCastleIndex = -1;

  00516	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00519	c6 80 d2 0c 00
	00 ff		 mov	 BYTE PTR [eax+3282], -1

; 3136 : 	lpObj->m_cBloodCastleSubIndex = -1;

  00520	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00523	c6 80 d3 0c 00
	00 ff		 mov	 BYTE PTR [eax+3283], -1

; 3137 : 	lpObj->m_iBloodCastleEXP = 0;

  0052a	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0052d	c7 80 d4 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3284], 0

; 3138 : #endif
; 3139 : 
; 3140 : #ifdef BLOODCASTLE_EVENT_5TH_20050531
; 3141 : 	lpObj->m_bBloodCastleComplete = false;

  00537	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0053a	c6 80 d8 0c 00
	00 00		 mov	 BYTE PTR [eax+3288], 0

; 3142 : #endif
; 3143 : 
; 3144 : #ifdef CHAOSCASTLE_SYSTEM_20040408			//      
; 3145 : 	if( CHECK_CHAOSCASTLE(lpObj->MapNumber) ) {

  00541	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00544	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0054b	83 f9 12	 cmp	 ecx, 18			; 00000012H
  0054e	7d 0c		 jge	 SHORT $LN97@gObjSetCha
  00550	c7 85 38 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv301[ebp], 0
  0055a	eb 31		 jmp	 SHORT $LN98@gObjSetCha
$LN97@gObjSetCha:
  0055c	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0055f	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00566	83 f8 17	 cmp	 eax, 23			; 00000017H
  00569	7e 0c		 jle	 SHORT $LN95@gObjSetCha
  0056b	c7 85 34 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv300[ebp], 0
  00575	eb 0a		 jmp	 SHORT $LN96@gObjSetCha
$LN95@gObjSetCha:
  00577	c7 85 34 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv300[ebp], 1
$LN96@gObjSetCha:
  00581	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv300[ebp]
  00587	89 8d 38 fe ff
	ff		 mov	 DWORD PTR tv301[ebp], ecx
$LN98@gObjSetCha:
  0058d	83 bd 38 fe ff
	ff 00		 cmp	 DWORD PTR tv301[ebp], 0
  00594	74 47		 je	 SHORT $LN22@gObjSetCha

; 3146 : 		lpObj->MapNumber = 2;

  00596	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00599	c6 80 09 01 00
	00 02		 mov	 BYTE PTR [eax+265], 2

; 3147 : 		MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );

  005a0	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005a3	05 06 01 00 00	 add	 eax, 262		; 00000106H
  005a8	50		 push	 eax
  005a9	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005ac	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  005b2	51		 push	 ecx
  005b3	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005b6	66 0f b6 82 09
	01 00 00	 movzx	 ax, BYTE PTR [edx+265]
  005be	0f b7 c8	 movzx	 ecx, ax
  005c1	51		 push	 ecx
  005c2	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  005c5	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  005cc	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  005d2	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  005d8	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos
$LN22@gObjSetCha:

; 3148 : 	}
; 3149 : 
; 3150 : 	lpObj->m_cChaosCastleIndex		= -1;

  005dd	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005e0	c6 80 d9 0c 00
	00 ff		 mov	 BYTE PTR [eax+3289], -1

; 3151 : 	lpObj->m_cChaosCastleSubIndex	= -1;

  005e7	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005ea	c6 80 da 0c 00
	00 ff		 mov	 BYTE PTR [eax+3290], -1

; 3152 : 	lpObj->m_iChaosCastleBlowTime	= 0;

  005f1	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005f4	c7 80 dc 0c 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+3292], 0

; 3153 : 	lpObj->m_cKillUserCount			= 0;

  005fe	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00601	c6 80 e0 0c 00
	00 00		 mov	 BYTE PTR [eax+3296], 0

; 3154 : 	lpObj->m_cKillMonsterCount		= 0;

  00608	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0060b	c6 80 e1 0c 00
	00 00		 mov	 BYTE PTR [eax+3297], 0

; 3155 : #endif
; 3156 : 
; 3157 : #ifdef UPDATE_GM_FUNCTION_20070228	//    GM    
; 3158 : 	if( ( (lpMsg->CtlCode&AUTHORITY_EVENT_GM) != AUTHORITY_EVENT_GM )
; 3159 : 		&& ( lpObj->MapNumber == 40 ) )
; 3160 : 	{
; 3161 : 		lpObj->MapNumber = 2;
; 3162 : 		MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );
; 3163 : 	}
; 3164 : #endif	// UPDATE_GM_FUNCTION_20070228
; 3165 : 
; 3166 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328			//   
; 3167 : 	else if( CHECK_ILLUSION_TEMPLE(lpObj->MapNumber) )
; 3168 : 	{
; 3169 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//   NPC  
; 3170 : 		lpObj->MapNumber = 51;
; 3171 : #else
; 3172 : 		lpObj->MapNumber = 2;
; 3173 : #endif
; 3174 : 		MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );
; 3175 : 	}
; 3176 : #endif
; 3177 : 
; 3178 : #ifdef ADD_NEW_MAP_KALIMA_20040518			//     
; 3179 : //	if( CHECK_KALIMAMAP(lpObj->MapNumber) ) {
; 3180 : //		lpObj->MapNumber = 2;
; 3181 : //		MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );
; 3182 : //	}
; 3183 : #endif	
; 3184 : 
; 3185 : #ifdef CASTLE_MAIN_SCHEDULER_20041111			//      
; 3186 : #ifdef MODIFY_LOGINUSER_SET_REGEN_COORD_AT_CASTLE_MAP_20060511
; 3187 : 	//    
; 3188 : 	if ( lpObj->MapNumber == MAP_INDEX_CASTLESIEGE && g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
; 3189 : #else
; 3190 : 	if (lpObj->MapNumber == MAP_INDEX_CASTLESIEGE) 
; 3191 : #endif
; 3192 : 	{
; 3193 : 		SHORT sX, sY, sLVL;
; 3194 : 		BYTE btMAPNUM	= lpObj->MapNumber; 
; 3195 : 		BYTE btDIR;
; 3196 : 		INT iMapNumber	= gGateC.GetGate(100, sX, sY, btMAPNUM, btDIR, sLVL);
; 3197 : 		if( iMapNumber >= 0 ) 
; 3198 : 		{
; 3199 : 			lpObj->MapNumber	= btMAPNUM;
; 3200 : 			lpObj->X			= sX;
; 3201 : 			lpObj->Y			= sY;
; 3202 : 
; 3203 : #ifdef MODIFY_LOGINUSER_SET_REGEN_COORD_AT_CASTLE_MAP_20060511			
; 3204 : 			//              
; 3205 : 			//          .
; 3206 : 			lpObj->m_sDestMapNumber		= btMAPNUM;
; 3207 : 			lpObj->m_btDestX			= sX;
; 3208 : 			lpObj->m_btDestY			= sY;					
; 3209 : #endif
; 3210 : 		}
; 3211 : 	}
; 3212 : #endif
; 3213 : 
; 3214 : #ifdef ADD_CASTLE_HUNTZONE_NPC_01_20050111		//      
; 3215 : 	if (lpObj->MapNumber == MAP_INDEX_CASTLEHUNTZONE) 
; 3216 : 	{
; 3217 : 		SHORT sX, sY, sLVL;
; 3218 : 		BYTE btMAPNUM	= lpObj->MapNumber; 
; 3219 : 		BYTE btDIR;
; 3220 : 		INT iMapNumber	= gGateC.GetGate(CASTLE_HUNTZONE_GATE_01, sX, sY, btMAPNUM, btDIR, sLVL);
; 3221 : 		if( iMapNumber >= 0 ) 
; 3222 : 		{
; 3223 : 			lpObj->MapNumber	= btMAPNUM;
; 3224 : 			lpObj->X			= sX;
; 3225 : 			lpObj->Y			= sY;
; 3226 : 			
; 3227 : #ifdef MODIFY_LOGINUSER_SET_REGEN_COORD_AT_CASTLE_MAP_20060511		
; 3228 : 			lpObj->m_sDestMapNumber		= btMAPNUM;
; 3229 : 			lpObj->m_btDestX			= sX;
; 3230 : 			lpObj->m_btDestY			= sY;	
; 3231 : #endif	// #ifdef MODIFY_LOGINUSER_SET_REGEN_COORD_AT_CASTLE_MAP_20060511
; 3232 : 		}
; 3233 : 	}
; 3234 : #endif	// #ifdef ADD_CASTLE_HUNTZONE_NPC_01_20050111
; 3235 : 
; 3236 : #ifdef ADD_KANTURU_20060627		//    
; 3237 : 	if( lpObj->MapNumber == MAP_INDEX_KANTURU_BOSS )
; 3238 : 	{
; 3239 : 		SHORT sX, sY, sLVL;
; 3240 : 		BYTE btMAPNUM	= lpObj->MapNumber; 
; 3241 : 		BYTE btDIR;
; 3242 : 		INT iMapNumber	= gGateC.GetGate( KANTURU_DEFAULT_REGEN_MAP_GATE, sX, sY, btMAPNUM, btDIR, sLVL );
; 3243 : 		if( iMapNumber >= 0 ) 
; 3244 : 		{
; 3245 : 			lpObj->MapNumber	= btMAPNUM;
; 3246 : 			lpObj->X			= sX;
; 3247 : 			lpObj->Y			= sY;
; 3248 : 		}		
; 3249 : 	}
; 3250 : #endif	// #ifdef ADD_KANTURU_20060627
; 3251 : 
; 3252 : #ifdef THIRD_CHANGEUP_SYSTEM_20070507	//  3 
; 3253 : 	if( lpObj->MapNumber == MAP_INDEX_3RD_CHANGEUP_QUEST 
; 3254 : 		|| lpObj->MapNumber == MAP_INDEX_3RD_CHANGEUP_BOSS_QUEST )
; 3255 : 	{
; 3256 : 		int iGateNum = GATE_REGENPLACE_OF_BALGAS;
; 3257 : 
; 3258 : 		SHORT sX, sY, sLVL;
; 3259 : 		BYTE btMAPNUM	= lpObj->MapNumber; 
; 3260 : 		BYTE btDIR;
; 3261 : 		INT iMapNumber	= gGateC.GetGate( iGateNum, sX, sY, btMAPNUM, btDIR, sLVL );
; 3262 : 		if( iMapNumber >= 0 ) 
; 3263 : 		{
; 3264 : 			lpObj->MapNumber	= btMAPNUM;
; 3265 : 			lpObj->X			= sX;
; 3266 : 			lpObj->Y			= sY;
; 3267 : 		}		
; 3268 : 	}
; 3269 : #endif
; 3270 : 
; 3271 : #ifdef MAP_SERVER_WORK_20041030				//            ,      .
; 3272 : 	if (lpObj->m_bMapSvrMoveReq == true) {
; 3273 : 		//    .
; 3274 : 		SHORT sSvrCode			= g_MapServerManager.CheckMoveMapSvr(lpObj->m_Index, lpObj->m_sDestMapNumber, lpObj->m_sPrevMapSvrCode);
; 3275 : 		if (sSvrCode == gGameServerCode) {
; 3276 : 			//    .
; 3277 : 			lpObj->MapNumber	= lpObj->m_sDestMapNumber;
; 3278 : 			lpObj->X			= lpObj->m_btDestX;
; 3279 : 			lpObj->Y			= lpObj->m_btDestY;
; 3280 : 
; 3281 : 			lpObj->StartX       = (BYTE)lpObj->X;
; 3282 : 			lpObj->StartY       = (BYTE)lpObj->Y;
; 3283 : 		}
; 3284 : 		else {
; 3285 : 			//   ->         ??
; 3286 : 			LogAddC(LOGC_RED, "[MapServerMng] Dest Map Server doesn't have Map [%s][%s] : %d",
; 3287 : 				lpObj->AccountID,
; 3288 : 				lpObj->Name,
; 3289 : 				lpObj->m_sDestMapNumber
; 3290 : 				);
; 3291 : 			//       ->  
; 3292 : 			gObjDel(lpObj->m_Index);
; 3293 : 			return FALSE;
; 3294 : 		}
; 3295 : 	}
; 3296 : #endif
; 3297 : 	
; 3298 : #ifdef ADD_NEWPVP_PKFIELD
; 3299 : 	if( gNonPK && (g_NewPVP.IsVulcanusMap(lpObj->MapNumber) || g_NewPVP.IsPKFieldMap(lpObj->MapNumber)) )
; 3300 : 	{
; 3301 : 		SHORT sX, sY, sLVL;
; 3302 : 		BYTE btMAPNUM	= lpObj->MapNumber; 
; 3303 : 		BYTE btDIR;
; 3304 : 		INT iMapNumber	= gGateC.GetGate( LORENCIA_DEFAULT_REGEN_MAP_GATE, sX, sY, btMAPNUM, btDIR, sLVL );
; 3305 : 		if( iMapNumber >= 0 ) 
; 3306 : 		{
; 3307 : 			lpObj->MapNumber	= btMAPNUM;
; 3308 : 			lpObj->X			= sX;
; 3309 : 			lpObj->Y			= sY;
; 3310 : 		}		
; 3311 : 	}
; 3312 : #ifndef FOR_KOREA
; 3313 : 	if(g_NewPVP.IsVulcanusMap(lpObj->MapNumber) || g_NewPVP.IsPKFieldMap(lpObj->MapNumber) )
; 3314 : 	{
; 3315 : 		SHORT sX, sY, sLVL;
; 3316 : 		BYTE btMAPNUM	= lpObj->MapNumber; 
; 3317 : 		BYTE btDIR;
; 3318 : 		INT iMapNumber	= gGateC.GetGate( LORENCIA_DEFAULT_REGEN_MAP_GATE, sX, sY, btMAPNUM, btDIR, sLVL );
; 3319 : 		if( iMapNumber >= 0 ) 
; 3320 : 		{
; 3321 : 			lpObj->MapNumber	= btMAPNUM;
; 3322 : 			lpObj->X			= sX;
; 3323 : 			lpObj->Y			= sY;
; 3324 : 		}		
; 3325 : 	}	
; 3326 : #endif // NOT_FOR_KOREA
; 3327 : #endif // ADD_NEWPVP_PKFIELD
; 3328 : 
; 3329 : #ifdef TEST_SETITEM_CLEAR
; 3330 : 	lpObj->ClearInfoForSetItem = (lpMsg->Dir>>4);
; 3331 : #endif
; 3332 : 
; 3333 : 
; 3334 : 	BYTE attr = MapC[lpObj->MapNumber].GetAttr(lpObj->X, lpObj->Y);

  00612	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00615	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0061c	51		 push	 ecx
  0061d	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00620	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  00627	50		 push	 eax
  00628	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0062b	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00632	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00638	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0063e	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00643	88 45 d3	 mov	 BYTE PTR _attr$[ebp], al

; 3335 : 	if( ((attr&MAP_ATTR_BLOCK) == MAP_ATTR_BLOCK) ||

  00646	0f b6 45 d3	 movzx	 eax, BYTE PTR _attr$[ebp]
  0064a	83 e0 04	 and	 eax, 4
  0064d	75 09		 jne	 SHORT $LN24@gObjSetCha
  0064f	0f b6 45 d3	 movzx	 eax, BYTE PTR _attr$[ebp]
  00653	83 e0 08	 and	 eax, 8
  00656	74 57		 je	 SHORT $LN23@gObjSetCha
$LN24@gObjSetCha:

; 3336 : 		((attr&MAP_ATTR_HOLLOW) == MAP_ATTR_HOLLOW) )
; 3337 : 	{
; 3338 : 		LogAdd(lMsg.Get(499));

  00658	68 f3 01 00 00	 push	 499			; 000001f3H
  0065d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00662	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00668	50		 push	 eax
  00669	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0066f	83 c4 04	 add	 esp, 4

; 3339 : 		MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y);

  00672	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00675	05 06 01 00 00	 add	 eax, 262		; 00000106H
  0067a	50		 push	 eax
  0067b	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0067e	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00684	51		 push	 ecx
  00685	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00688	66 0f b6 82 09
	01 00 00	 movzx	 ax, BYTE PTR [edx+265]
  00690	0f b7 c8	 movzx	 ecx, ax
  00693	51		 push	 ecx
  00694	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00697	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0069e	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  006a4	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  006aa	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos
$LN23@gObjSetCha:

; 3340 : 	}
; 3341 : 
; 3342 : 	int  result; 	
; 3343 : 	short x, y;
; 3344 : 	BYTE  mapNumber=0;

  006af	c6 45 c3 00	 mov	 BYTE PTR _mapNumber$[ebp], 0

; 3345 : 	BYTE  dir;
; 3346 : 	short level;
; 3347 : 	int  gt;
; 3348 : 	int  userlevel = gObj[aIndex].Level;	

  006b3	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  006ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006c0	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  006c8	89 55 b4	 mov	 DWORD PTR _userlevel$[ebp], edx

; 3349 : 
; 3350 : 	x = lpObj->X;

  006cb	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006ce	66 8b 88 04 01
	00 00		 mov	 cx, WORD PTR [eax+260]
  006d5	66 89 4d c8	 mov	 WORD PTR _x$[ebp], cx

; 3351 : 	y = lpObj->Y;

  006d9	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006dc	66 8b 88 06 01
	00 00		 mov	 cx, WORD PTR [eax+262]
  006e3	66 89 4d c4	 mov	 WORD PTR _y$[ebp], cx

; 3352 : 	dir = lpObj->Dir;

  006e7	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006ea	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  006f0	88 4d c2	 mov	 BYTE PTR _dir$[ebp], cl

; 3353 : 	level = lpObj->Level;

  006f3	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006f6	66 8b 88 a0 00
	00 00		 mov	 cx, WORD PTR [eax+160]
  006fd	66 89 4d bc	 mov	 WORD PTR _level$[ebp], cx

; 3354 : 	mapNumber = lpObj->MapNumber;

  00701	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00704	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  0070a	88 4d c3	 mov	 BYTE PTR _mapNumber$[ebp], cl

; 3355 : 	
; 3356 : 	gt = 0;

  0070d	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _gt$[ebp], 0

; 3357 : 
; 3358 : #ifdef MODIFY_KANTURU_MAPNUMBER_CHECK_20060807
; 3359 : 	if( g_iBlockKanturuMapEnter == 1 )
; 3360 : 	{
; 3361 : 		if( gObj[aIndex].MapNumber >= MAP_INDEX_KANTURU1 && gObj[aIndex].MapNumber <= MAP_INDEX_KANTURU_BOSS )
; 3362 : 		{
; 3363 : 			LogAddTD("[ KANTURU ][ Forced Move From Kanturu to Lorencia ] (%s)(%s) (BeforeMap:%d(%d/%d))"
; 3364 : 				,gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y );
; 3365 : 			gObj[aIndex].MapNumber = 0;
; 3366 : 			MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );
; 3367 : 		}
; 3368 : 	}
; 3369 : 
; 3370 : 	if( g_iBlockCastleSiegeMapEnter == 1 )
; 3371 : 	{
; 3372 : 		if( gObj[aIndex].MapNumber == MAP_INDEX_CASTLESIEGE
; 3373 : 			|| gObj[aIndex].MapNumber == MAP_INDEX_CASTLEHUNTZONE
; 3374 : 			|| gObj[aIndex].MapNumber == MAP_INDEX_CRYWOLF_FIRSTZONE
; 3375 : 			|| gObj[aIndex].MapNumber == MAP_INDEX_CRYWOLF_SECONDZONE )
; 3376 : 		{
; 3377 : 			LogAddTD("[ KANTURU ][ Forced Move From CastleSiegeMap to Lorencia ] (%s)(%s) (BeforeMap:%d(%d/%d))"
; 3378 : 				,gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].MapNumber, gObj[aIndex].X, gObj[aIndex].Y );
; 3379 : 			gObj[aIndex].MapNumber = 0;
; 3380 : 			MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );
; 3381 : 		}
; 3382 : 	}
; 3383 : #endif // MODIFY_KANTURU_MAPNUMBER_CHECK_20060807
; 3384 : 
; 3385 : #ifdef ADD_RAKLION_20080408
; 3386 : 	if( lpObj->MapNumber == MAP_INDEX_RAKLION_BOSS )
; 3387 : 	{
; 3388 : 		//     .
; 3389 : 		if( g_Raklion.GetRaklionState() == RAKLION_STATE_CLOSE_DOOR
; 3390 : 			|| g_Raklion.GetRaklionState() == RAKLION_STATE_ALL_USER_DIE
; 3391 : 			|| g_Raklion.GetRaklionState() == RAKLION_STATE_NOTIFY_4
; 3392 : 			|| g_Raklion.GetRaklionState() == RAKLION_STATE_END )
; 3393 : 		{
; 3394 : 			gt = 286;
; 3395 : 		}
; 3396 : 	}
; 3397 : 	if( lpObj->MapNumber == MAP_INDEX_RAKLION_FIELD )
; 3398 : 	{	//       .
; 3399 : 		g_RaklionUtil.NotifyRaklionCurrentState( lpObj->m_Index, g_Raklion.GetRaklionState(),
; 3400 : 			g_Raklion.GetRaklionStateDetail() );
; 3401 : 	}
; 3402 : #endif // ADD_RAKLION_20080408
; 3403 : 
; 3404 : #ifdef ADD_NEWPVP_PKFIELD		//  PK 
; 3405 : 	if( lpObj->MapNumber == MAP_INDEX_PKFIELD )
; 3406 : 	{
; 3407 : 		SHORT sX, sY, sLVL;
; 3408 : 		BYTE btMAPNUM	= lpObj->MapNumber; 
; 3409 : 		BYTE btDIR;
; 3410 : 		INT iMapNumber	= gGateC.GetGate(NEWPVP_DEFAULT_REGEN_MAP_GATE, sX, sY, btMAPNUM, btDIR, sLVL );
; 3411 : 		if( iMapNumber >= 0 ) 
; 3412 : 		{
; 3413 : 			lpObj->MapNumber	= btMAPNUM;
; 3414 : 			lpObj->X			= sX;
; 3415 : 			lpObj->Y			= sY;
; 3416 : 		}		
; 3417 : 	}
; 3418 : #endif // ADD_NEWPVP_PKFIELD
; 3419 : 
; 3420 : 	if( lpObj->MapNumber == 2 ) //    ..

  00714	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00717	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0071e	83 f9 02	 cmp	 ecx, 2
  00721	75 09		 jne	 SHORT $LN25@gObjSetCha

; 3421 : 	{
; 3422 : 		gt = 22;

  00723	c7 45 b8 16 00
	00 00		 mov	 DWORD PTR _gt$[ebp], 22	; 00000016H

; 3423 : 	}

  0072a	eb 2e		 jmp	 SHORT $LN29@gObjSetCha
$LN25@gObjSetCha:

; 3424 : 	else if( lpObj->MapNumber == 3 ) //    

  0072c	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0072f	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00736	83 f9 03	 cmp	 ecx, 3
  00739	75 09		 jne	 SHORT $LN27@gObjSetCha

; 3425 : 	{
; 3426 : 		gt = 27;

  0073b	c7 45 b8 1b 00
	00 00		 mov	 DWORD PTR _gt$[ebp], 27	; 0000001bH

; 3427 : 	}

  00742	eb 16		 jmp	 SHORT $LN29@gObjSetCha
$LN27@gObjSetCha:

; 3428 : 	else if( lpObj->MapNumber == 4 ) // //1  

  00744	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00747	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0074e	83 f9 04	 cmp	 ecx, 4
  00751	75 07		 jne	 SHORT $LN29@gObjSetCha

; 3429 : 	{
; 3430 : 		gt = 42;

  00753	c7 45 b8 2a 00
	00 00		 mov	 DWORD PTR _gt$[ebp], 42	; 0000002aH
$LN29@gObjSetCha:

; 3431 : 	}
; 3432 : 
; 3433 : 	if( gt > 0 )

  0075a	83 7d b8 00	 cmp	 DWORD PTR _gt$[ebp], 0
  0075e	0f 8e 48 01 00
	00		 jle	 $LN32@gObjSetCha

; 3434 : 	{
; 3435 : 		result = gGateC.GetGate(gt, x, y, mapNumber, dir, level);

  00764	8d 45 bc	 lea	 eax, DWORD PTR _level$[ebp]
  00767	50		 push	 eax
  00768	8d 4d c2	 lea	 ecx, DWORD PTR _dir$[ebp]
  0076b	51		 push	 ecx
  0076c	8d 55 c3	 lea	 edx, DWORD PTR _mapNumber$[ebp]
  0076f	52		 push	 edx
  00770	8d 45 c4	 lea	 eax, DWORD PTR _y$[ebp]
  00773	50		 push	 eax
  00774	8d 4d c8	 lea	 ecx, DWORD PTR _x$[ebp]
  00777	51		 push	 ecx
  00778	8b 55 b8	 mov	 edx, DWORD PTR _gt$[ebp]
  0077b	52		 push	 edx
  0077c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  00781	e8 00 00 00 00	 call	 ?GetGate@CGate@@QAEHHAAF0AAE10@Z ; CGate::GetGate
  00786	89 45 cc	 mov	 DWORD PTR _result$[ebp], eax

; 3436 : 		if( result >= 0 )

  00789	83 7d cc 00	 cmp	 DWORD PTR _result$[ebp], 0
  0078d	0f 8c f7 00 00
	00		 jl	 $LN31@gObjSetCha

; 3437 : 		{
; 3438 : #ifdef DARKLORD_WORK
; 3439 : #ifdef UPDATE_NEWMAP_SWAMP_OF_CALMNESS_20080108	//   ,  Movereq.txt   
; 3440 : 			if( mapNumber != MAP_INDEX_SWAMP_OF_CALMNESS )
; 3441 : #endif	// UPDATE_NEWMAP_SWAMP_OF_CALMNESS_20080108
; 3442 : 			if( lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA )	

  00793	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00796	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0079d	83 f9 04	 cmp	 ecx, 4
  007a0	74 0f		 je	 SHORT $LN34@gObjSetCha
  007a2	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007a5	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  007ac	83 f9 03	 cmp	 ecx, 3
  007af	75 1a		 jne	 SHORT $LN35@gObjSetCha
$LN34@gObjSetCha:

; 3443 : #else
; 3444 : 			if( lpObj->Class == CLASS_MAGUMSA )
; 3445 : #endif
; 3446 : 			{
; 3447 : 				if( level > 0 )

  007b1	0f bf 45 bc	 movsx	 eax, WORD PTR _level$[ebp]
  007b5	85 c0		 test	 eax, eax
  007b7	7e 12		 jle	 SHORT $LN35@gObjSetCha

; 3448 : 				{
; 3449 : 					level = ((level/3)*2);

  007b9	0f bf 45 bc	 movsx	 eax, WORD PTR _level$[ebp]
  007bd	99		 cdq
  007be	b9 03 00 00 00	 mov	 ecx, 3
  007c3	f7 f9		 idiv	 ecx
  007c5	d1 e0		 shl	 eax, 1
  007c7	66 89 45 bc	 mov	 WORD PTR _level$[ebp], ax
$LN35@gObjSetCha:

; 3450 : 				}
; 3451 : 			}
; 3452 : 
; 3453 : 			if( (level != 0) && ( lpObj->Level < level) )

  007cb	0f bf 45 bc	 movsx	 eax, WORD PTR _level$[ebp]
  007cf	85 c0		 test	 eax, eax
  007d1	0f 84 b1 00 00
	00		 je	 $LN38@gObjSetCha
  007d7	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007da	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  007e1	0f bf 55 bc	 movsx	 edx, WORD PTR _level$[ebp]
  007e5	3b ca		 cmp	 ecx, edx
  007e7	0f 8d 9b 00 00
	00		 jge	 $LN38@gObjSetCha

; 3454 : 			{
; 3455 : 				if( lpObj->Class == CLASS_ELF )	{

  007ed	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007f0	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  007f7	83 f9 02	 cmp	 ecx, 2
  007fa	75 49		 jne	 SHORT $LN37@gObjSetCha

; 3456 : 					lpObj->MapNumber = 3;

  007fc	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  007ff	c6 80 09 01 00
	00 03		 mov	 BYTE PTR [eax+265], 3

; 3457 : 					MapC[lpObj->MapNumber].GetMapPos(lpObj->MapNumber, lpObj->X, lpObj->Y );

  00806	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00809	05 06 01 00 00	 add	 eax, 262		; 00000106H
  0080e	50		 push	 eax
  0080f	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00812	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00818	51		 push	 ecx
  00819	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0081c	66 0f b6 82 09
	01 00 00	 movzx	 ax, BYTE PTR [edx+265]
  00824	0f b7 c8	 movzx	 ecx, ax
  00827	51		 push	 ecx
  00828	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0082b	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00832	69 c8 8c 04 05
	00		 imul	 ecx, eax, 328844
  00838	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0083e	e8 00 00 00 00	 call	 ?GetMapPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetMapPos

; 3458 : 				}

  00843	eb 43		 jmp	 SHORT $LN38@gObjSetCha
$LN37@gObjSetCha:

; 3459 : 				else {
; 3460 : 					lpObj->MapNumber = 0;

  00845	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00848	c6 80 09 01 00
	00 00		 mov	 BYTE PTR [eax+265], 0

; 3461 : 					MapC[lpObj->MapNumber].GetLevelPos(lpObj->Level, lpObj->X, lpObj->Y );

  0084f	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00852	05 06 01 00 00	 add	 eax, 262		; 00000106H
  00857	50		 push	 eax
  00858	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0085b	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00861	51		 push	 ecx
  00862	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00865	0f b7 82 a0 00
	00 00		 movzx	 eax, WORD PTR [edx+160]
  0086c	50		 push	 eax
  0086d	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00870	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00877	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  0087d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00883	e8 00 00 00 00	 call	 ?GetLevelPos@MapClass@@QAEXFAAF0@Z ; MapClass::GetLevelPos
$LN38@gObjSetCha:

; 3462 : 				}
; 3463 : 			}			
; 3464 : 		}

  00888	eb 22		 jmp	 SHORT $LN32@gObjSetCha
$LN31@gObjSetCha:

; 3465 : 		else LogAdd("error : %d (%s %d)", result, __FILE__, __LINE__);

  0088a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjSetCharacter@@YAHPAEH@Z@4JA
  0088f	05 f8 01 00 00	 add	 eax, 504		; 000001f8H
  00894	50		 push	 eax
  00895	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0089a	8b 4d cc	 mov	 ecx, DWORD PTR _result$[ebp]
  0089d	51		 push	 ecx
  0089e	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DHOELAFE@error?5?3?5?$CFd?5?$CI?$CFs?5?$CFd?$CJ@
  008a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  008a9	83 c4 10	 add	 esp, 16			; 00000010H
$LN32@gObjSetCha:

; 3466 : 	}
; 3467 : 
; 3468 : 	lpMsg->MapX         = (BYTE)lpObj->X;

  008ac	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008af	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  008b2	8a 91 04 01 00
	00		 mov	 dl, BYTE PTR [ecx+260]
  008b8	88 90 2d 05 00
	00		 mov	 BYTE PTR [eax+1325], dl

; 3469 : 	lpMsg->MapY         = (BYTE)lpObj->Y;

  008be	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008c1	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  008c4	8a 91 06 01 00
	00		 mov	 dl, BYTE PTR [ecx+262]
  008ca	88 90 2e 05 00
	00		 mov	 BYTE PTR [eax+1326], dl

; 3470 : 
; 3471 : 	lpObj->TX		  = lpMsg->MapX;

  008d0	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008d3	66 0f b6 88 2d
	05 00 00	 movzx	 cx, BYTE PTR [eax+1325]
  008db	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008de	66 89 8a 20 01
	00 00		 mov	 WORD PTR [edx+288], cx

; 3472 : 	lpObj->TY		  = lpMsg->MapY;

  008e5	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  008e8	66 0f b6 88 2e
	05 00 00	 movzx	 cx, BYTE PTR [eax+1326]
  008f0	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  008f3	66 89 8a 22 01
	00 00		 mov	 WORD PTR [edx+290], cx

; 3473 : 	lpObj->m_OldX	  = lpObj->X;

  008fa	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008fd	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00900	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  00907	66 89 90 1c 01
	00 00		 mov	 WORD PTR [eax+284], dx

; 3474 : 	lpObj->m_OldY	  = lpObj->Y;

  0090e	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00911	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00914	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  0091b	66 89 90 1e 01
	00 00		 mov	 WORD PTR [eax+286], dx

; 3475 : 	lpObj->Experience = lpMsg->Exp;

  00922	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00925	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00928	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0092b	89 90 a8 00 00
	00		 mov	 DWORD PTR [eax+168], edx

; 3476 : 	lpObj->Strength   = lpMsg->Str > g_GlobalConfig.m_iMax_Stats ? g_GlobalConfig.m_iMax_Stats : lpMsg->Str;

  00931	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00934	0f b7 48 30	 movzx	 ecx, WORD PTR [eax+48]
  00938	3b 0d 98 00 00
	00		 cmp	 ecx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+152
  0093e	7e 0e		 jle	 SHORT $LN99@gObjSetCha
  00940	8b 15 98 00 00
	00		 mov	 edx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+152
  00946	89 95 38 fe ff
	ff		 mov	 DWORD PTR tv456[ebp], edx
  0094c	eb 0d		 jmp	 SHORT $LN100@gObjSetCha
$LN99@gObjSetCha:
  0094e	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00951	0f b7 48 30	 movzx	 ecx, WORD PTR [eax+48]
  00955	89 8d 38 fe ff
	ff		 mov	 DWORD PTR tv456[ebp], ecx
$LN100@gObjSetCha:
  0095b	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0095e	66 8b 85 38 fe
	ff ff		 mov	 ax, WORD PTR tv456[ebp]
  00965	66 89 82 b4 00
	00 00		 mov	 WORD PTR [edx+180], ax

; 3477 : 	lpObj->Dexterity  = lpMsg->Dex > g_GlobalConfig.m_iMax_Stats ? g_GlobalConfig.m_iMax_Stats : lpMsg->Dex;

  0096c	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0096f	0f b7 48 32	 movzx	 ecx, WORD PTR [eax+50]
  00973	3b 0d 98 00 00
	00		 cmp	 ecx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+152
  00979	7e 0e		 jle	 SHORT $LN101@gObjSetCha
  0097b	8b 15 98 00 00
	00		 mov	 edx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+152
  00981	89 95 38 fe ff
	ff		 mov	 DWORD PTR tv464[ebp], edx
  00987	eb 0d		 jmp	 SHORT $LN102@gObjSetCha
$LN101@gObjSetCha:
  00989	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0098c	0f b7 48 32	 movzx	 ecx, WORD PTR [eax+50]
  00990	89 8d 38 fe ff
	ff		 mov	 DWORD PTR tv464[ebp], ecx
$LN102@gObjSetCha:
  00996	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00999	66 8b 85 38 fe
	ff ff		 mov	 ax, WORD PTR tv464[ebp]
  009a0	66 89 82 b6 00
	00 00		 mov	 WORD PTR [edx+182], ax

; 3478 : 	lpObj->Vitality   = lpMsg->Vit > g_GlobalConfig.m_iMax_Stats ? g_GlobalConfig.m_iMax_Stats : lpMsg->Vit;

  009a7	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  009aa	0f b7 48 34	 movzx	 ecx, WORD PTR [eax+52]
  009ae	3b 0d 98 00 00
	00		 cmp	 ecx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+152
  009b4	7e 0e		 jle	 SHORT $LN103@gObjSetCha
  009b6	8b 15 98 00 00
	00		 mov	 edx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+152
  009bc	89 95 38 fe ff
	ff		 mov	 DWORD PTR tv472[ebp], edx
  009c2	eb 0d		 jmp	 SHORT $LN104@gObjSetCha
$LN103@gObjSetCha:
  009c4	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  009c7	0f b7 48 34	 movzx	 ecx, WORD PTR [eax+52]
  009cb	89 8d 38 fe ff
	ff		 mov	 DWORD PTR tv472[ebp], ecx
$LN104@gObjSetCha:
  009d1	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  009d4	66 8b 85 38 fe
	ff ff		 mov	 ax, WORD PTR tv472[ebp]
  009db	66 89 82 b8 00
	00 00		 mov	 WORD PTR [edx+184], ax

; 3479 : 	lpObj->Energy     = lpMsg->Energy > g_GlobalConfig.m_iMax_Stats ? g_GlobalConfig.m_iMax_Stats : lpMsg->Energy;

  009e2	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  009e5	0f b7 48 36	 movzx	 ecx, WORD PTR [eax+54]
  009e9	3b 0d 98 00 00
	00		 cmp	 ecx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+152
  009ef	7e 0e		 jle	 SHORT $LN105@gObjSetCha
  009f1	8b 15 98 00 00
	00		 mov	 edx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+152
  009f7	89 95 38 fe ff
	ff		 mov	 DWORD PTR tv480[ebp], edx
  009fd	eb 0d		 jmp	 SHORT $LN106@gObjSetCha
$LN105@gObjSetCha:
  009ff	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00a02	0f b7 48 36	 movzx	 ecx, WORD PTR [eax+54]
  00a06	89 8d 38 fe ff
	ff		 mov	 DWORD PTR tv480[ebp], ecx
$LN106@gObjSetCha:
  00a0c	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a0f	66 8b 85 38 fe
	ff ff		 mov	 ax, WORD PTR tv480[ebp]
  00a16	66 89 82 ba 00
	00 00		 mov	 WORD PTR [edx+186], ax

; 3480 : 	lpObj->Life       = (float)lpMsg->Life/10.0f;

  00a1d	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00a20	0f b7 48 38	 movzx	 ecx, WORD PTR [eax+56]
  00a24	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00a28	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  00a30	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a33	f3 0f 11 82 bc
	00 00 00	 movss	 DWORD PTR [edx+188], xmm0

; 3481 : 	lpObj->MaxLife    = (float)lpMsg->MaxLife/10.0f;

  00a3b	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00a3e	0f b7 48 3a	 movzx	 ecx, WORD PTR [eax+58]
  00a42	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00a46	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  00a4e	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a51	f3 0f 11 82 c0
	00 00 00	 movss	 DWORD PTR [edx+192], xmm0

; 3482 : 	lpObj->Mana       = (float)lpMsg->Mana/10.0f;

  00a59	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00a5c	0f b7 48 3c	 movzx	 ecx, WORD PTR [eax+60]
  00a60	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00a64	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  00a6c	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a6f	f3 0f 11 82 d0
	00 00 00	 movss	 DWORD PTR [edx+208], xmm0

; 3483 : 	lpObj->MaxMana    = (float)lpMsg->MaxMana/10.0f;

  00a77	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00a7a	0f b7 48 3e	 movzx	 ecx, WORD PTR [eax+62]
  00a7e	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00a82	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@41200000
  00a8a	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a8d	f3 0f 11 82 d4
	00 00 00	 movss	 DWORD PTR [edx+212], xmm0

; 3484 : 	lpObj->Money	  = lpMsg->Money;

  00a95	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a98	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00a9b	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00a9e	89 90 b0 00 00
	00		 mov	 DWORD PTR [eax+176], edx

; 3485 : 
; 3486 : #ifdef DARKLORD_WORK
; 3487 : 	lpObj->Leadership = lpMsg->Leadership > g_GlobalConfig.m_iMax_Stats ? g_GlobalConfig.m_iMax_Stats : lpMsg->Leadership;

  00aa4	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00aa7	0f b7 88 72 05
	00 00		 movzx	 ecx, WORD PTR [eax+1394]
  00aae	3b 0d 98 00 00
	00		 cmp	 ecx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+152
  00ab4	7e 0e		 jle	 SHORT $LN107@gObjSetCha
  00ab6	8b 15 98 00 00
	00		 mov	 edx, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+152
  00abc	89 95 38 fe ff
	ff		 mov	 DWORD PTR tv510[ebp], edx
  00ac2	eb 10		 jmp	 SHORT $LN108@gObjSetCha
$LN107@gObjSetCha:
  00ac4	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00ac7	0f b7 88 72 05
	00 00		 movzx	 ecx, WORD PTR [eax+1394]
  00ace	89 8d 38 fe ff
	ff		 mov	 DWORD PTR tv510[ebp], ecx
$LN108@gObjSetCha:
  00ad4	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00ad7	66 8b 85 38 fe
	ff ff		 mov	 ax, WORD PTR tv510[ebp]
  00ade	66 89 82 d8 00
	00 00		 mov	 WORD PTR [edx+216], ax

; 3488 : 	lpObj->ChatLitmitTime = lpMsg->ChatLitmitTime;

  00ae5	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ae8	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00aeb	66 8b 91 74 05
	00 00		 mov	 dx, WORD PTR [ecx+1396]
  00af2	66 89 90 dc 00
	00 00		 mov	 WORD PTR [eax+220], dx

; 3489 : 	
; 3490 : #endif
; 3491 : 	
; 3492 : #ifdef ADD_MINUS_STAT_SYSTEM_USING_FRUIT_20050712
; 3493 : 	//   
; 3494 : 	lpObj->iFruitPoint = lpMsg->iFruitPoint;
; 3495 : #endif
; 3496 : 
; 3497 : #ifdef DARKLORD_WORK
; 3498 : 	#ifdef FOR_NEW_TESTSERVER		// 
; 3499 : 		if( lpObj->Level > 1  )
; 3500 : 		{
; 3501 : 			if( lpObj->Experience < gLevelExperience[lpObj->Level-1] )
; 3502 : 			{
; 3503 : 				lpObj->Experience = gLevelExperience[lpObj->Level-1]; 
; 3504 : 			}
; 3505 : 		}
; 3506 : 	#endif
; 3507 : #endif
; 3508 : 
; 3509 : 	if( lpObj->Mana < 1.0f )

  00af9	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00afc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b04	0f 2f 80 d0 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+208]
  00b0b	76 13		 jbe	 SHORT $LN39@gObjSetCha

; 3510 : 	{
; 3511 : 		lpObj->Mana = 1.0f;

  00b0d	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b10	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b18	f3 0f 11 80 d0
	00 00 00	 movss	 DWORD PTR [eax+208], xmm0
$LN39@gObjSetCha:

; 3512 : 	}
; 3513 : 
; 3514 : 	if( lpObj->Life < 1.0f )

  00b20	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b23	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b2b	0f 2f 80 bc 00
	00 00		 comiss	 xmm0, DWORD PTR [eax+188]
  00b32	76 13		 jbe	 SHORT $LN40@gObjSetCha

; 3515 : 	{
; 3516 : 		lpObj->Life = 1.0f;

  00b34	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b37	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00b3f	f3 0f 11 80 bc
	00 00 00	 movss	 DWORD PTR [eax+188], xmm0
$LN40@gObjSetCha:

; 3517 : 	}
; 3518 : 
; 3519 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	//   -   :     .    .
; 3520 : 	lpObj->MaxLife    = DCInfo.DefClass[lpObj->Class].Life+\
; 3521 : 		((lpObj->Level+lpObj->m_nMasterLevel-1)*DCInfo.DefClass[lpObj->Class].LevelLife)+\
; 3522 : 		((lpObj->Vitality-DCInfo.DefClass[lpObj->Class].Vitality)*DCInfo.DefClass[lpObj->Class].VitalityToLife);
; 3523 : #else
; 3524 : 	lpObj->MaxLife    = DCInfo.DefClass[lpObj->Class].Life+\

  00b47	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b4a	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00b51	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  00b57	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b5a	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00b61	83 e9 01	 sub	 ecx, 1
  00b64	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00b68	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b6b	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00b72	69 c1 60 09 00
	00		 imul	 eax, ecx, 2400
  00b78	f3 0f 59 80 10
	00 00 00	 mulss	 xmm0, DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  00b80	f3 0f 58 82 14
	00 00 00	 addss	 xmm0, DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+20]
  00b88	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b8b	0f b7 91 b8 00
	00 00		 movzx	 edx, WORD PTR [ecx+184]
  00b92	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b95	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00b9c	69 c1 60 09 00
	00		 imul	 eax, ecx, 2400
  00ba2	0f b7 88 0c 00
	00 00		 movzx	 ecx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+12]
  00ba9	2b d1		 sub	 edx, ecx
  00bab	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  00baf	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00bb2	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  00bb9	69 c8 60 09 00
	00		 imul	 ecx, eax, 2400
  00bbf	f3 0f 59 89 28
	00 00 00	 mulss	 xmm1, DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+40]
  00bc7	f3 0f 58 c1	 addss	 xmm0, xmm1
  00bcb	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00bce	f3 0f 11 82 c0
	00 00 00	 movss	 DWORD PTR [edx+192], xmm0

; 3525 : 		((lpObj->Level-1)*DCInfo.DefClass[lpObj->Class].LevelLife)+\
; 3526 : 		((lpObj->Vitality-DCInfo.DefClass[lpObj->Class].Vitality)*DCInfo.DefClass[lpObj->Class].VitalityToLife);
; 3527 : #endif
; 3528 : 
; 3529 : 		//(lpObj->Vitality*DCInfo.DefClass[lpObj->Class].VitalityToLife);
; 3530 : 
; 3531 : #ifndef MODIFY_LIFEANDMANA_BUG_LEVELUP_RELOGIN_20065018 // not define 
; 3532 : 	// AddLife   Life MaxLife  ,   . 
; 3533 : 	if( lpObj->Life > lpObj->MaxLife ) 
; 3534 : 	{
; 3535 : 		lpObj->Life = lpObj->MaxLife;
; 3536 : 	}
; 3537 : #endif
; 3538 : 	//lpObj->MaxLife    += lpObj->AddLife;
; 3539 : 
; 3540 : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	//   -   :     .    .
; 3541 : 	lpObj->MaxMana    = DCInfo.DefClass[lpObj->Class].Mana+\
; 3542 : 		((lpObj->Level+lpObj->m_nMasterLevel-1)*DCInfo.DefClass[lpObj->Class].LevelMana)+\
; 3543 : 		((lpObj->Energy-DCInfo.DefClass[lpObj->Class].Energy)*DCInfo.DefClass[lpObj->Class].EnergyToMana);
; 3544 : #else
; 3545 : 	lpObj->MaxMana    = DCInfo.DefClass[lpObj->Class].Mana+\

  00bd6	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bd9	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00be0	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  00be6	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00be9	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00bf0	83 e9 01	 sub	 ecx, 1
  00bf3	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00bf7	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bfa	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00c01	69 c1 60 09 00
	00		 imul	 eax, ecx, 2400
  00c07	f3 0f 59 80 1c
	00 00 00	 mulss	 xmm0, DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  00c0f	f3 0f 58 82 20
	00 00 00	 addss	 xmm0, DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+32]
  00c17	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00c1a	0f b7 91 ba 00
	00 00		 movzx	 edx, WORD PTR [ecx+186]
  00c21	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c24	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00c2b	69 c1 60 09 00
	00		 imul	 eax, ecx, 2400
  00c31	0f b7 88 0e 00
	00 00		 movzx	 ecx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+14]
  00c38	2b d1		 sub	 edx, ecx
  00c3a	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  00c3e	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c41	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  00c48	69 c8 60 09 00
	00		 imul	 ecx, eax, 2400
  00c4e	f3 0f 59 89 2c
	00 00 00	 mulss	 xmm1, DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+44]
  00c56	f3 0f 58 c1	 addss	 xmm0, xmm1
  00c5a	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00c5d	f3 0f 11 82 d4
	00 00 00	 movss	 DWORD PTR [edx+212], xmm0

; 3546 : 		((lpObj->Level-1)*DCInfo.DefClass[lpObj->Class].LevelMana)+\
; 3547 : 		((lpObj->Energy-DCInfo.DefClass[lpObj->Class].Energy)*DCInfo.DefClass[lpObj->Class].EnergyToMana);
; 3548 : #endif
; 3549 : 
; 3550 : #ifndef MODIFY_LIFEANDMANA_BUG_LEVELUP_RELOGIN_20065018 // not define 
; 3551 : 	// AddMana   Mana MaxMana  ,   . 
; 3552 : 	if( lpObj->Mana > lpObj->MaxMana ) 
; 3553 : 	{
; 3554 : 		lpObj->Mana = lpObj->MaxMana;
; 3555 : 	}
; 3556 : #endif
; 3557 : 
; 3558 : 	lpObj->VitalityToLife = DCInfo.DefClass[lpObj->Class].VitalityToLife;

  00c65	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c68	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00c6f	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  00c75	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c78	8b 8a 28 00 00
	00		 mov	 ecx, DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+40]
  00c7e	89 88 f4 00 00
	00		 mov	 DWORD PTR [eax+244], ecx

; 3559 : 	lpObj->EnergyToMana   = DCInfo.DefClass[lpObj->Class].EnergyToMana;

  00c84	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c87	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00c8e	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  00c94	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00c97	8b 8a 2c 00 00
	00		 mov	 ecx, DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+44]
  00c9d	89 88 f8 00 00
	00		 mov	 DWORD PTR [eax+248], ecx

; 3560 : 
; 3561 : #ifdef NEW_FORSKYLAND2
; 3562 : 	// AG  
; 3563 : 	gObjSetBP(aIndex);

  00ca3	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00ca6	50		 push	 eax
  00ca7	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP
  00cac	83 c4 04	 add	 esp, 4

; 3564 : 	lpObj->BP = lpObj->MaxBP/2;

  00caf	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cb2	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [eax+236]
  00cb8	99		 cdq
  00cb9	2b c2		 sub	 eax, edx
  00cbb	d1 f8		 sar	 eax, 1
  00cbd	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00cc0	89 81 e8 00 00
	00		 mov	 DWORD PTR [ecx+232], eax

; 3565 : #endif
; 3566 : 
; 3567 : 	//   
; 3568 : 	gObjCalcMaxLifePower(aIndex);

  00cc6	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00cc9	50		 push	 eax
  00cca	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower
  00ccf	83 c4 04	 add	 esp, 4

; 3569 : 	
; 3570 : 	lpObj->m_PK_Count	  = lpMsg->PkCount;

  00cd2	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cd5	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00cd8	8a 91 30 05 00
	00		 mov	 dl, BYTE PTR [ecx+1328]
  00cde	88 90 fc 00 00
	00		 mov	 BYTE PTR [eax+252], dl

; 3571 : 	lpObj->m_PK_Level	  = lpMsg->PkLevel;

  00ce4	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ce7	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00cea	8a 91 34 05 00
	00		 mov	 dl, BYTE PTR [ecx+1332]
  00cf0	88 90 fd 00 00
	00		 mov	 BYTE PTR [eax+253], dl

; 3572 : 	lpObj->m_PK_Time	  = lpMsg->PkTime;

  00cf6	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00cf9	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00cfc	8b 91 38 05 00
	00		 mov	 edx, DWORD PTR [ecx+1336]
  00d02	89 90 00 01 00
	00		 mov	 DWORD PTR [eax+256], edx

; 3573 : 
; 3574 : 
; 3575 : 	if( gApplyHeroSystem )

  00d08	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gApplyHeroSystem@@3HA, 0 ; gApplyHeroSystem
  00d0f	74 19		 je	 SHORT $LN42@gObjSetCha

; 3576 : 	{
; 3577 : 		if( lpObj->m_PK_Level <= PK_LEVEL_DEFAULT )

  00d11	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d14	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  00d1b	83 f9 03	 cmp	 ecx, 3
  00d1e	7f 0a		 jg	 SHORT $LN42@gObjSetCha

; 3578 : 		{
; 3579 : 			lpObj->m_PK_Level = PK_LEVEL_DEFAULT-1;

  00d20	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d23	c6 80 fd 00 00
	00 02		 mov	 BYTE PTR [eax+253], 2
$LN42@gObjSetCha:

; 3580 : 			//lpMsg->PkLevel    = PK_LEVEL_DEFAULT-2;
; 3581 : 		}
; 3582 : 	}
; 3583 : 
; 3584 : 	if( lpObj->m_PK_Level == PK_LEVEL_DEFAULT )

  00d2a	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d2d	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  00d34	83 f9 03	 cmp	 ecx, 3
  00d37	75 17		 jne	 SHORT $LN43@gObjSetCha

; 3585 : 	{
; 3586 : 		lpObj->m_PK_Count	  = 0;

  00d39	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d3c	c6 80 fc 00 00
	00 00		 mov	 BYTE PTR [eax+252], 0

; 3587 : 		lpObj->m_PK_Time	  = 0;

  00d43	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d46	c7 80 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+256], 0
$LN43@gObjSetCha:

; 3588 : 	}
; 3589 : 	
; 3590 : 	lpObj->MaxRegenTime = 4000;

  00d50	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00d53	c7 80 08 02 00
	00 a0 0f 00 00	 mov	 DWORD PTR [eax+520], 4000 ; 00000fa0H

; 3591 : 	lpObj->m_MoveSpeed	= 1000;

  00d5d	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  00d62	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d65	66 89 81 f4 02
	00 00		 mov	 WORD PTR [ecx+756], ax

; 3592 : 
; 3593 : 
; 3594 : #ifdef NEW_SKILL_FORSKYLAND	
; 3595 : 	memcpy(lpObj->m_Quest, lpMsg->dbQuest, MAX_DBQUEST);

  00d6c	6a 32		 push	 50			; 00000032H
  00d6e	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00d71	05 3f 05 00 00	 add	 eax, 1343		; 0000053fH
  00d76	50		 push	 eax
  00d77	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00d7a	81 c1 90 0e 00
	00		 add	 ecx, 3728		; 00000e90H
  00d80	51		 push	 ecx
  00d81	e8 00 00 00 00	 call	 _memcpy
  00d86	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3596 : 
; 3597 : 	if( lpObj->m_Quest[0] == 0 )

  00d89	b8 01 00 00 00	 mov	 eax, 1
  00d8e	6b c8 00	 imul	 ecx, eax, 0
  00d91	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00d94	0f b6 84 0a 90
	0e 00 00	 movzx	 eax, BYTE PTR [edx+ecx+3728]
  00d9c	85 c0		 test	 eax, eax
  00d9e	75 18		 jne	 SHORT $LN44@gObjSetCha

; 3598 : 	{
; 3599 : 		memset(lpObj->m_Quest, 0xff, MAX_DBQUEST);

  00da0	6a 32		 push	 50			; 00000032H
  00da2	68 ff 00 00 00	 push	 255			; 000000ffH
  00da7	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00daa	05 90 0e 00 00	 add	 eax, 3728		; 00000e90H
  00daf	50		 push	 eax
  00db0	e8 00 00 00 00	 call	 _memset
  00db5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN44@gObjSetCha:

; 3600 : 	}
; 3601 : 	
; 3602 : 	//	memset(lpObj->m_Quest, 0xff, MAX_DBQUEST);
; 3603 : 	//#endif
; 3604 : 
; 3605 : 	#ifdef SECOND_QUEST
; 3606 : 		if( g_QuestInfo.GetQuestState(lpObj, 2) == QS_CLEAR )

  00db8	6a 02		 push	 2
  00dba	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dbd	50		 push	 eax
  00dbe	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00dc3	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAVOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  00dc8	83 f8 02	 cmp	 eax, 2
  00dcb	75 4c		 jne	 SHORT $LN47@gObjSetCha

; 3607 : 		{	// 2   
; 3608 : #ifdef QUEST_BUG_FIX
; 3609 : 			if( lpObj->Level < 220 )

  00dcd	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00dd0	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00dd7	81 f9 dc 00 00
	00		 cmp	 ecx, 220		; 000000dcH
  00ddd	7d 30		 jge	 SHORT $LN46@gObjSetCha

; 3610 : 			{	//  -_-	
; 3611 : 				g_QuestInfo.ReSetQuestState(lpObj, 2);

  00ddf	6a 02		 push	 2
  00de1	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00de4	50		 push	 eax
  00de5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00dea	e8 00 00 00 00	 call	 ?ReSetQuestState@CQuestInfo@@QAEEPAVOBJECTSTRUCT@@H@Z ; CQuestInfo::ReSetQuestState

; 3612 : 				LogAddTD("[%s][%s] Find Invalid QuestInfo (%d)", lpObj->AccountID, lpObj->Name, 2);

  00def	6a 02		 push	 2
  00df1	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00df4	83 c0 73	 add	 eax, 115		; 00000073H
  00df7	50		 push	 eax
  00df8	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00dfb	83 c1 68	 add	 ecx, 104		; 00000068H
  00dfe	51		 push	 ecx
  00dff	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PDDCMPCL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Find?5Invalid?5QuestInfo@
  00e04	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00e0a	83 c4 10	 add	 esp, 16			; 00000010H

; 3613 : 			}

  00e0d	eb 0a		 jmp	 SHORT $LN47@gObjSetCha
$LN46@gObjSetCha:

; 3614 : 			else
; 3615 : 			{
; 3616 : 				lpObj->PlusStatQuestClear = 1;

  00e0f	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e12	c6 80 8c 00 00
	00 01		 mov	 BYTE PTR [eax+140], 1
$LN47@gObjSetCha:

; 3617 : 			}
; 3618 : #endif
; 3619 : 		}
; 3620 : 
; 3621 : 		if( g_QuestInfo.GetQuestState(lpObj, 3) == QS_CLEAR )

  00e19	6a 03		 push	 3
  00e1b	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e1e	50		 push	 eax
  00e1f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00e24	e8 00 00 00 00	 call	 ?GetQuestState@CQuestInfo@@QAEHPAVOBJECTSTRUCT@@H@Z ; CQuestInfo::GetQuestState
  00e29	83 f8 02	 cmp	 eax, 2
  00e2c	75 4c		 jne	 SHORT $LN50@gObjSetCha

; 3622 : 		{	//     
; 3623 : #ifdef QUEST_BUG_FIX
; 3624 : 			if( lpObj->Level < 220 )

  00e2e	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e31	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00e38	81 f9 dc 00 00
	00		 cmp	 ecx, 220		; 000000dcH
  00e3e	7d 30		 jge	 SHORT $LN49@gObjSetCha

; 3625 : 			{	//  -_-	
; 3626 : 				g_QuestInfo.ReSetQuestState(lpObj, 3);

  00e40	6a 03		 push	 3
  00e42	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e45	50		 push	 eax
  00e46	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_QuestInfo@@3VCQuestInfo@@A ; g_QuestInfo
  00e4b	e8 00 00 00 00	 call	 ?ReSetQuestState@CQuestInfo@@QAEEPAVOBJECTSTRUCT@@H@Z ; CQuestInfo::ReSetQuestState

; 3627 : 				LogAddTD("[%s][%s] Find Invalid QuestInfo (%d)", lpObj->AccountID, lpObj->Name, 3);

  00e50	6a 03		 push	 3
  00e52	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e55	83 c0 73	 add	 eax, 115		; 00000073H
  00e58	50		 push	 eax
  00e59	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00e5c	83 c1 68	 add	 ecx, 104		; 00000068H
  00e5f	51		 push	 ecx
  00e60	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@PDDCMPCL@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Find?5Invalid?5QuestInfo@
  00e65	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00e6b	83 c4 10	 add	 esp, 16			; 00000010H

; 3628 : 			}

  00e6e	eb 0a		 jmp	 SHORT $LN50@gObjSetCha
$LN49@gObjSetCha:

; 3629 : 			else
; 3630 : 			{
; 3631 : 				lpObj->ComboSkillquestClear = 1;

  00e70	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e73	c6 80 8d 00 00
	00 01		 mov	 BYTE PTR [eax+141], 1
$LN50@gObjSetCha:

; 3632 : 			}	
; 3633 : #endif
; 3634 : 		}
; 3635 : 	#endif
; 3636 : #endif
; 3637 : 	
; 3638 : 	gObjSetInventory1Pointer(lpObj);

  00e7a	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e7d	50		 push	 eax
  00e7e	e8 00 00 00 00	 call	 ?gObjSetInventory1Pointer@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer
  00e83	83 c4 04	 add	 esp, 4

; 3639 : 
; 3640 : 	// GUILD
; 3641 : 	lpObj->GuildNumber  = 0;

  00e86	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e89	c7 80 90 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+656], 0

; 3642 : 	lpObj->lpGuild		= NULL;

  00e93	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00e96	c7 80 94 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+660], 0

; 3643 : 		
; 3644 : 	//  .(  ? )
; 3645 : 	if( lpObj->Class == CLASS_WIZARD ||
; 3646 : 		lpObj->Class == CLASS_ELF	 ||
; 3647 : 		lpObj->Class == CLASS_KNIGHT ||
; 3648 : #ifdef DARKLORD_WORK
; 3649 : 		lpObj->Class == CLASS_DARKLORD || 	

  00ea0	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ea3	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00eaa	85 c9		 test	 ecx, ecx
  00eac	74 40		 je	 SHORT $LN52@gObjSetCha
  00eae	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00eb1	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00eb8	83 f9 02	 cmp	 ecx, 2
  00ebb	74 31		 je	 SHORT $LN52@gObjSetCha
  00ebd	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ec0	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00ec7	83 f9 01	 cmp	 ecx, 1
  00eca	74 22		 je	 SHORT $LN52@gObjSetCha
  00ecc	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ecf	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00ed6	83 f9 04	 cmp	 ecx, 4
  00ed9	74 13		 je	 SHORT $LN52@gObjSetCha
  00edb	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ede	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00ee5	83 f9 03	 cmp	 ecx, 3
  00ee8	0f 85 3f 01 00
	00		 jne	 $LN51@gObjSetCha
$LN52@gObjSetCha:

; 3650 : #endif
; 3651 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912
; 3652 : 		lpObj->Class == CLASS_SUMMONER||
; 3653 : #endif
; 3654 : 		lpObj->Class == CLASS_MAGUMSA )
; 3655 : 
; 3656 : 	{
; 3657 : 		int EnergyBall=1;

  00eee	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _EnergyBall$8[ebp], 1

; 3658 : 
; 3659 : #ifdef DARKLORD_WORK
; 3660 : 		int StrongFear=1;

  00ef5	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR _StrongFear$7[ebp], 1

; 3661 : #endif
; 3662 : 
; 3663 : #ifdef ADD_SKILL_MUSE_ELF_INFINITYARROW_20060406
; 3664 : 		BOOL IsGetInitinityArrowSkill = FALSE;	// 220        .
; 3665 : #endif
; 3666 : 
; 3667 : 		//  ()    
; 3668 : 		//         
; 3669 : 		//   . (apple)
; 3670 : 		gObjMagicAddEnergyCheckOnOff(FALSE);

  00efc	6a 00		 push	 0
  00efe	e8 00 00 00 00	 call	 ?gObjMagicAddEnergyCheckOnOff@@YAXH@Z ; gObjMagicAddEnergyCheckOnOff
  00f03	83 c4 04	 add	 esp, 4

; 3671 : 		for( n=0; n<MAX_MAGIC; n++)

  00f06	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00f0d	eb 09		 jmp	 SHORT $LN4@gObjSetCha
$LN2@gObjSetCha:
  00f0f	8b 45 e8	 mov	 eax, DWORD PTR _n$[ebp]
  00f12	83 c0 01	 add	 eax, 1
  00f15	89 45 e8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjSetCha:
  00f18	83 7d e8 3c	 cmp	 DWORD PTR _n$[ebp], 60	; 0000003cH
  00f1c	0f 8d aa 00 00
	00		 jge	 $LN3@gObjSetCha

; 3672 : 		{
; 3673 : #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122	// gObjSetCharacter : DB   
; 3674 : 			itype = lpMsg->dbMagicList[n*3];
; 3675 : 			if( ( lpMsg->dbMagicList[( n * 3 ) + 1] & 0x07 ) > 0 )
; 3676 : 			{
; 3677 : 				itype = itype * ( lpMsg->dbMagicList[( n * 3 ) + 1] & 0x07 ) + lpMsg->dbMagicList[( n * 3 ) + 2];
; 3678 : 			}
; 3679 : #else
; 3680 : 			itype = lpMsg->dbMagicList[n*3];

  00f22	6b 45 e8 03	 imul	 eax, DWORD PTR _n$[ebp], 3
  00f26	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00f29	0f b6 94 01 78
	04 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1144]
  00f31	89 55 ec	 mov	 DWORD PTR _itype$[ebp], edx

; 3681 : #endif
; 3682 : 			if( itype != 0xFF )

  00f34	81 7d ec ff 00
	00 00		 cmp	 DWORD PTR _itype$[ebp], 255 ; 000000ffH
  00f3b	0f 84 86 00 00
	00		 je	 $LN56@gObjSetCha

; 3683 : 			{
; 3684 : #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122	// gObjSetCharacter : DB        
; 3685 : 	#ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//    
; 3686 : 				if( g_MasterSkillSystem.CheckMasterLevelSkill( itype ) )
; 3687 : 	#else
; 3688 : 				if( MagicDamageC.GetSkillUseType( itype ) == SKILL_USETYPE_MASTERSKILL_PASSIVE )
; 3689 : 	#endif
; 3690 : 				{
; 3691 : 					//      .
; 3692 : 					BYTE btLevel = (BYTE)( lpMsg->dbMagicList[(n * 3) + 1]>>3 );
; 3693 : 					if( gObjMagicAdd( lpObj, itype, btLevel ) > -1 )
; 3694 : 					{
; 3695 : 						g_MasterSkillSystem.CalcPassiveSkillData( lpObj, itype, btLevel );
; 3696 : 					}
; 3697 : 				}
; 3698 : 				else
; 3699 : 				{
; 3700 : #endif
; 3701 : 					if( itype == AT_SKILL_ENERGYBALL )

  00f41	83 7d ec 11	 cmp	 DWORD PTR _itype$[ebp], 17 ; 00000011H
  00f45	75 07		 jne	 SHORT $LN54@gObjSetCha

; 3702 : 					{
; 3703 : 						EnergyBall = 0;

  00f47	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _EnergyBall$8[ebp], 0
$LN54@gObjSetCha:

; 3704 : 					}
; 3705 : 
; 3706 : 	#ifdef	DARKLORD_WORK
; 3707 : 					if( itype == AT_SKILL_SPEAR )

  00f4e	83 7d ec 3c	 cmp	 DWORD PTR _itype$[ebp], 60 ; 0000003cH
  00f52	75 07		 jne	 SHORT $LN55@gObjSetCha

; 3708 : 					{	//     
; 3709 : 						StrongFear = 0;

  00f54	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _StrongFear$7[ebp], 0
$LN55@gObjSetCha:

; 3710 : 					}
; 3711 : 	#endif
; 3712 : 
; 3713 : 	#ifdef ADD_SKILL_MUSE_ELF_INFINITYARROW_20060406
; 3714 : 					if( itype == AT_SKILL_INFINITY_ARROW )
; 3715 : 					{
; 3716 : 						IsGetInitinityArrowSkill = TRUE;
; 3717 : 						gObjMagicAdd( lpObj, itype, ( lpMsg->dbMagicList[( n * 3 ) + 1] & 0x0F ) );
; 3718 : 					}
; 3719 : 	#endif
; 3720 : 		
; 3721 : 					if( (itype != AT_SKILL_BLOCKING) && 
; 3722 : 						(itype != AT_SKILL_SWORD1) && 
; 3723 : 						(itype != AT_SKILL_SWORD2) && 
; 3724 : 						(itype != AT_SKILL_SWORD3) && 
; 3725 : 						(itype != AT_SKILL_SWORD4) && 
; 3726 : 						(itype != AT_SKILL_SWORD5) && 
; 3727 : 						(itype != AT_SKILL_CROSSBOW) && 
; 3728 : 						(itype != AT_SKILL_BOW) && 
; 3729 : 						(itype != AT_SKILL_KNIGHTDINORANT) && 
; 3730 : 						(itype != AT_SKILL_SWORD6) && 
; 3731 : 						//(itype != AT_SKILL_4CROSSBOW) && 
; 3732 : 	#ifdef DARKLORD_WORK
; 3733 : 						(itype != AT_SKILL_DARKHORSE_ATTACK) && 					

  00f5b	83 7d ec 12	 cmp	 DWORD PTR _itype$[ebp], 18 ; 00000012H
  00f5f	74 66		 je	 SHORT $LN56@gObjSetCha
  00f61	83 7d ec 13	 cmp	 DWORD PTR _itype$[ebp], 19 ; 00000013H
  00f65	74 60		 je	 SHORT $LN56@gObjSetCha
  00f67	83 7d ec 14	 cmp	 DWORD PTR _itype$[ebp], 20 ; 00000014H
  00f6b	74 5a		 je	 SHORT $LN56@gObjSetCha
  00f6d	83 7d ec 15	 cmp	 DWORD PTR _itype$[ebp], 21 ; 00000015H
  00f71	74 54		 je	 SHORT $LN56@gObjSetCha
  00f73	83 7d ec 16	 cmp	 DWORD PTR _itype$[ebp], 22 ; 00000016H
  00f77	74 4e		 je	 SHORT $LN56@gObjSetCha
  00f79	83 7d ec 17	 cmp	 DWORD PTR _itype$[ebp], 23 ; 00000017H
  00f7d	74 48		 je	 SHORT $LN56@gObjSetCha
  00f7f	83 7d ec 18	 cmp	 DWORD PTR _itype$[ebp], 24 ; 00000018H
  00f83	74 42		 je	 SHORT $LN56@gObjSetCha
  00f85	83 7d ec 19	 cmp	 DWORD PTR _itype$[ebp], 25 ; 00000019H
  00f89	74 3c		 je	 SHORT $LN56@gObjSetCha
  00f8b	83 7d ec 31	 cmp	 DWORD PTR _itype$[ebp], 49 ; 00000031H
  00f8f	74 36		 je	 SHORT $LN56@gObjSetCha
  00f91	83 7d ec 38	 cmp	 DWORD PTR _itype$[ebp], 56 ; 00000038H
  00f95	74 30		 je	 SHORT $LN56@gObjSetCha
  00f97	83 7d ec 3e	 cmp	 DWORD PTR _itype$[ebp], 62 ; 0000003eH
  00f9b	74 2a		 je	 SHORT $LN56@gObjSetCha
  00f9d	83 7d ec 36	 cmp	 DWORD PTR _itype$[ebp], 54 ; 00000036H
  00fa1	74 24		 je	 SHORT $LN56@gObjSetCha

; 3734 : 	#endif
; 3735 : 	#ifdef ADD_ITEM_FENRIR_01_20051110
; 3736 : 						(itype != AT_SKILL_FENRIR_ATTACK) && 					
; 3737 : 	#endif
; 3738 : 	#ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//      
; 3739 : 						(itype != AT_SKILL_EXPLOSION_2) && 	
; 3740 : 						(itype != AT_SKILL_REQUIEM) && 	
; 3741 : 	#endif
; 3742 : 	#ifdef UPDATE_ADD_SUMMONER_SKILL_POLLUTION_20080425
; 3743 : 						(itype != AT_SKILL_PULLUTION) &&
; 3744 : 	#endif						
; 3745 : 						(itype != AT_SKILL_5CROSSBOW) )
; 3746 : 						gObjMagicAdd(lpObj, itype, (lpMsg->dbMagicList[(n*3)+1]&0x0F));

  00fa3	6b 45 e8 03	 imul	 eax, DWORD PTR _n$[ebp], 3
  00fa7	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  00faa	0f b6 94 01 79
	04 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1145]
  00fb2	83 e2 0f	 and	 edx, 15			; 0000000fH
  00fb5	52		 push	 edx
  00fb6	0f b6 45 ec	 movzx	 eax, BYTE PTR _itype$[ebp]
  00fba	50		 push	 eax
  00fbb	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00fbe	51		 push	 ecx
  00fbf	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMagicAdd
  00fc4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN56@gObjSetCha:

; 3747 : 
; 3748 : #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122
; 3749 : 				}	// if( MagicDamageC.GetSkillUseType( itype ) == SKILL_USETYPE_MASTERSKILL_PASSIVE )
; 3750 : #endif	// MASTER_LEVEL_SKILL_SYSTEM_20071122
; 3751 : 			}
; 3752 : 		}

  00fc7	e9 43 ff ff ff	 jmp	 $LN2@gObjSetCha
$LN3@gObjSetCha:

; 3753 : 		//   ..  .
; 3754 : 		if( lpObj->Class == CLASS_WIZARD )

  00fcc	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00fcf	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00fd6	85 c9		 test	 ecx, ecx
  00fd8	75 1d		 jne	 SHORT $LN58@gObjSetCha

; 3755 : 		{
; 3756 : 			if( EnergyBall == 1 )

  00fda	83 7d b0 01	 cmp	 DWORD PTR _EnergyBall$8[ebp], 1
  00fde	75 17		 jne	 SHORT $LN58@gObjSetCha

; 3757 : 			{
; 3758 : 				gObjMagicAdd(lpObj, AT_SKILL_ENERGYBALL, 0);

  00fe0	6a 00		 push	 0
  00fe2	6a 11		 push	 17			; 00000011H
  00fe4	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00fe7	50		 push	 eax
  00fe8	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMagicAdd
  00fed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3759 : 				EnergyBall = 0;

  00ff0	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _EnergyBall$8[ebp], 0
$LN58@gObjSetCha:

; 3760 : 			}
; 3761 : 		}
; 3762 : 
; 3763 : #ifdef	DARKLORD_WORK
; 3764 : 		if( lpObj->Class == CLASS_DARKLORD )

  00ff7	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ffa	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  01001	83 f9 04	 cmp	 ecx, 4
  01004	75 1d		 jne	 SHORT $LN60@gObjSetCha

; 3765 : 		{
; 3766 : 			if( StrongFear == 1 )

  01006	83 7d ac 01	 cmp	 DWORD PTR _StrongFear$7[ebp], 1
  0100a	75 17		 jne	 SHORT $LN60@gObjSetCha

; 3767 : 			{
; 3768 : 				gObjMagicAdd(lpObj, AT_SKILL_SPEAR, 0);	//  

  0100c	6a 00		 push	 0
  0100e	6a 3c		 push	 60			; 0000003cH
  01010	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01013	50		 push	 eax
  01014	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMagicAdd
  01019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3769 : 				StrongFear = 0;

  0101c	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _StrongFear$7[ebp], 0
$LN60@gObjSetCha:

; 3770 : 			}
; 3771 : 		}
; 3772 : #endif
; 3773 : 
; 3774 : #ifdef ADD_SKILL_MUSE_ELF_INFINITYARROW_20060406
; 3775 : 		if( IsGetInitinityArrowSkill == FALSE )
; 3776 : 		{
; 3777 : 			// 220          .
; 3778 : 			if( lpObj->Class == CLASS_ELF && lpObj->Level >= g_SkillAdditionInfo.GetInfinityArrowUseLevel() && lpObj->ChangeUP == 1 )
; 3779 : 			{
; 3780 : 				int iAddSkillPosition = gObjMagicAdd( lpObj, AT_SKILL_INFINITY_ARROW, 0 );
; 3781 : 				if( iAddSkillPosition > 0 )
; 3782 : 				{
; 3783 : 					LogAddTD( "[%s][%s] Add Infinity Arrow Skill (Character Level : %d)(ChangeUp: %d)"
; 3784 : 						, lpObj->AccountID, lpObj->Name, lpObj->Level, lpObj->ChangeUP );
; 3785 : 				}
; 3786 : 			}
; 3787 : 		}
; 3788 : #endif
; 3789 : 	
; 3790 : #ifdef ADD_NEW_SKILL_FOR_CASTLE_01_20041116
; 3791 : 
; 3792 : 		if( lpObj->Class == CLASS_WIZARD )
; 3793 : 		{
; 3794 : 			gObjMagicAdd(lpObj, AT_SKILL_JAVALIN, 0);
; 3795 : 		}
; 3796 : 		else if( lpObj->Class == CLASS_KNIGHT )
; 3797 : 		{
; 3798 : 			gObjMagicAdd(lpObj, AT_SKILL_RUSH, 0);
; 3799 : 		}
; 3800 : 		else if( lpObj->Class == CLASS_ELF )
; 3801 : 		{
; 3802 : 			gObjMagicAdd(lpObj, AT_SKILL_DEEPIMPACT, 0);
; 3803 : 		}
; 3804 : 		else if( lpObj->Class == CLASS_MAGUMSA )
; 3805 : 		{
; 3806 : 			gObjMagicAdd(lpObj, AT_SKILL_ONE_FLASH, 0);
; 3807 : 			gObjMagicAdd(lpObj, AT_SKILL_DEATH_CANNON, 0);
; 3808 : 		}
; 3809 : 		else if( lpObj->Class == CLASS_DARKLORD )
; 3810 : 		{
; 3811 : 			gObjMagicAdd(lpObj, AT_SKILL_SPACE_SPLIT, 0);
; 3812 : 			gObjMagicAdd(lpObj, AT_SKILL_BRAND_OF_SKILL, 0);
; 3813 : 		}
; 3814 : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//    ""
; 3815 : 		else if( lpObj->Class == CLASS_SUMMONER )
; 3816 : 		{
; 3817 : 			gObjMagicAdd(lpObj, AT_SKILL_JAVALIN, 0);
; 3818 : 		}
; 3819 : #endif		
; 3820 : 
; 3821 : 
; 3822 : #ifdef ADD_NEW_SKILL_FOR_CASTLE_02_20050531	
; 3823 : 		gObjMagicAdd(lpObj, AT_SKILL_STUN, 0);	
; 3824 : 		gObjMagicAdd(lpObj, AT_SKILL_REMOVAL_STUN, 0);	
; 3825 : 		gObjMagicAdd(lpObj, AT_SKILL_ADD_MANA, 0);	
; 3826 : 		gObjMagicAdd(lpObj, AT_SKILL_INVISIBLE, 0);	
; 3827 : 		gObjMagicAdd(lpObj, AT_SKILL_REMOVAL_INVISIBLE, 0);	
; 3828 : 		gObjMagicAdd(lpObj, AT_SKILL_REMOVAL_MAGIC, 0);
; 3829 : #endif
; 3830 : 
; 3831 : #endif
; 3832 : 
; 3833 : 		gObjMagicAddEnergyCheckOnOff(TRUE);

  01023	6a 01		 push	 1
  01025	e8 00 00 00 00	 call	 ?gObjMagicAddEnergyCheckOnOff@@YAXH@Z ; gObjMagicAddEnergyCheckOnOff
  0102a	83 c4 04	 add	 esp, 4
$LN51@gObjSetCha:

; 3834 : 	}
; 3835 : 
; 3836 : #ifdef ITEMDELETE_MODIFY_20040604
; 3837 : 	bool bAllItemExist = true;

  0102d	c6 45 ab 01	 mov	 BYTE PTR _bAllItemExist$[ebp], 1

; 3838 : #endif
; 3839 : 	
; 3840 : 	if( lpMsg->DbVersion == 0x00 ) {

  01031	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  01034	0f b6 88 3d 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1341]
  0103b	85 c9		 test	 ecx, ecx
  0103d	75 68		 jne	 SHORT $LN61@gObjSetCha

; 3841 : #ifdef ITEMDELETE_MODIFY_20040604
; 3842 : 		DbItemSetInByte( lpObj, lpMsg, MAX_ITEMDBBYTE_V00, &bAllItemExist);

  0103f	8d 45 ab	 lea	 eax, DWORD PTR _bAllItemExist$[ebp]
  01042	50		 push	 eax
  01043	6a 07		 push	 7
  01045	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  01048	51		 push	 ecx
  01049	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0104c	52		 push	 edx
  0104d	e8 00 00 00 00	 call	 ?DbItemSetInByte@@YAXPAVOBJECTSTRUCT@@PAUSDHP_DBCHAR_INFORESULT@@HPA_N@Z ; DbItemSetInByte
  01052	83 c4 10	 add	 esp, 16			; 00000010H

; 3843 : 
; 3844 : #ifdef PERSONAL_SHOP_20040113
; 3845 : 	#ifdef PERSONAL_SHOP_DBVER_0_FIX_200406016		//        .
; 3846 : 		for (INT iX = MAX_INVENTORY ; iX < MAX_INVENTORY_EXTEND ; iX++) {

  01055	c7 45 a4 4c 00
	00 00		 mov	 DWORD PTR _iX$6[ebp], 76 ; 0000004cH
  0105c	eb 09		 jmp	 SHORT $LN7@gObjSetCha
$LN5@gObjSetCha:
  0105e	8b 45 a4	 mov	 eax, DWORD PTR _iX$6[ebp]
  01061	83 c0 01	 add	 eax, 1
  01064	89 45 a4	 mov	 DWORD PTR _iX$6[ebp], eax
$LN7@gObjSetCha:
  01067	83 7d a4 6c	 cmp	 DWORD PTR _iX$6[ebp], 108 ; 0000006cH
  0106b	7d 17		 jge	 SHORT $LN6@gObjSetCha

; 3847 : 			lpObj->Inventory1[iX].Clear();

  0106d	69 4d a4 a8 00
	00 00		 imul	 ecx, DWORD PTR _iX$6[ebp], 168
  01074	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01077	03 88 6c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3180]
  0107d	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 3848 : 		}

  01082	eb da		 jmp	 SHORT $LN5@gObjSetCha
$LN6@gObjSetCha:

; 3849 : #ifdef PSHOP_INVENTORY_CLEAR_BUGFIX_20050321
; 3850 : 		memset(&lpObj->InventoryMap1[MAX_INVENTORYMAP], 0xFF, MAX_PSHOPITEM);

  01084	6a 20		 push	 32			; 00000020H
  01086	68 ff 00 00 00	 push	 255			; 000000ffH
  0108b	b8 01 00 00 00	 mov	 eax, 1
  01090	c1 e0 06	 shl	 eax, 6
  01093	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01096	03 81 70 0c 00
	00		 add	 eax, DWORD PTR [ecx+3184]
  0109c	50		 push	 eax
  0109d	e8 00 00 00 00	 call	 _memset
  010a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3851 : #else
; 3852 : 		memset(&lpObj->InventoryMap1[MAX_INVENTORY], 0xFF, sizeof(BYTE) * MAX_PSHOPITEM);
; 3853 : #endif		
; 3854 : 	#endif
; 3855 : #endif
; 3856 : 
; 3857 : #else
; 3858 : 		DbItemSetInByte( lpObj, lpMsg, MAX_ITEMDBBYTE_V00);
; 3859 : 
; 3860 : #ifdef PERSONAL_SHOP_20040113
; 3861 : 	#ifdef PERSONAL_SHOP_DBVER_0_FIX_200406016		//        .
; 3862 : 		for (INT iX = MAX_INVENTORY ; iX < MAX_INVENTORY_EXTEND ; iX++) {
; 3863 : 			lpObj->Inventory1[iX].Clear();
; 3864 : 		}
; 3865 : #ifdef PSHOP_INVENTORY_CLEAR_BUGFIX_20050321
; 3866 : 		memset(&lpObj->InventoryMap1[MAX_INVENTORYMAP], 0xFF, MAX_PSHOPITEM);
; 3867 : #else
; 3868 : 		memset(&lpObj->InventoryMap1[MAX_INVENTORY], 0xFF, sizeof(BYTE) * MAX_PSHOPITEM);
; 3869 : #endif		
; 3870 : 	#endif		
; 3871 : #endif
; 3872 : 		
; 3873 : #endif
; 3874 : 	}

  010a5	eb 16		 jmp	 SHORT $LN62@gObjSetCha
$LN61@gObjSetCha:

; 3875 : #ifdef ITEM_DBSIZE_EXTEND_20050706
; 3876 : 	else if( lpMsg->DbVersion < 0x03 ) {
; 3877 : #ifdef ITEMDELETE_MODIFY_20040604
; 3878 : 		DbItemSetInByte( lpObj, lpMsg, MAX_ITEMDBBYTE_V02, &bAllItemExist);
; 3879 : #else
; 3880 : 		DbItemSetInByte( lpObj, lpMsg, MAX_ITEMDBBYTE_V02);
; 3881 : #endif
; 3882 : 	}
; 3883 : #endif
; 3884 : 	else {
; 3885 : #ifdef ITEMDELETE_MODIFY_20040604
; 3886 : 		DbItemSetInByte( lpObj, lpMsg, MAX_ITEMDBBYTE, &bAllItemExist);

  010a7	8d 45 ab	 lea	 eax, DWORD PTR _bAllItemExist$[ebp]
  010aa	50		 push	 eax
  010ab	6a 0a		 push	 10			; 0000000aH
  010ad	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  010b0	51		 push	 ecx
  010b1	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  010b4	52		 push	 edx
  010b5	e8 00 00 00 00	 call	 ?DbItemSetInByte@@YAXPAVOBJECTSTRUCT@@PAUSDHP_DBCHAR_INFORESULT@@HPA_N@Z ; DbItemSetInByte
  010ba	83 c4 10	 add	 esp, 16			; 00000010H
$LN62@gObjSetCha:

; 3887 : #else
; 3888 : 		DbItemSetInByte( lpObj, lpMsg, MAX_ITEMDBBYTE);
; 3889 : #endif
; 3890 : 	}
; 3891 : 
; 3892 : #ifdef PERSONAL_SHOP_DELETE_UNDER_LV5_20050203		//  5           -> 
; 3893 : 	if (lpObj->Level <= 5) {
; 3894 : 		for (INT iX = MAX_INVENTORY ; iX < MAX_INVENTORY_EXTEND ; iX++) {
; 3895 : 			if (lpObj->Inventory1[iX].IsItem() == TRUE) {
; 3896 : 				//        .
; 3897 : 				BYTE NewOption[8];
; 3898 : 				for( int i=0; i<8; i++) NewOption[i]=0;
; 3899 : 
; 3900 : 				if( lpObj->Inventory1[iX].m_NewOption&0x20) NewOption[0] = 1;
; 3901 : 				if( lpObj->Inventory1[iX].m_NewOption&0x10) NewOption[1] = 1;
; 3902 : 				if( lpObj->Inventory1[iX].m_NewOption&0x08) NewOption[2] = 1;
; 3903 : 				if( lpObj->Inventory1[iX].m_NewOption&0x04) NewOption[3] = 1;
; 3904 : 				if( lpObj->Inventory1[iX].m_NewOption&0x02) NewOption[4] = 1;
; 3905 : 				if( lpObj->Inventory1[iX].m_NewOption&0x01) NewOption[5] = 1;		
; 3906 : 
; 3907 : #ifdef MODIFY_ITEM_SERIAL_EXPAND_20080227
; 3908 : 				LogAddTD("[PShop] PShop Item Delete LV <= 5 [%s][%s] [LV:%d] : serial:%u [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]", 
; 3909 : #else
; 3910 : 				LogAddTD("[PShop] PShop Item Delete LV <= 5 [%s][%s] [LV:%d] : serial:%d [%s][%d][%d][%d][%d] Ex:[%d,%d,%d,%d,%d,%d,%d] Set:[%d]", 
; 3911 : #endif // MODIFY_ITEM_SERIAL_EXPAND_20080227
; 3912 : 					lpObj->AccountID,
; 3913 : 					lpObj->Name,
; 3914 : 					lpObj->Level,
; 3915 : 					lpObj->Inventory1[iX].m_Number,
; 3916 : 					ItemAttribute[lpObj->Inventory1[iX].m_Type].Name,
; 3917 : 					lpObj->Inventory1[iX].m_Level,
; 3918 : 					lpObj->Inventory1[iX].m_Option1,
; 3919 : 					lpObj->Inventory1[iX].m_Option2,
; 3920 : 					lpObj->Inventory1[iX].m_Option3,
; 3921 : 					NewOption[0],
; 3922 : 					NewOption[1],
; 3923 : 					NewOption[2],
; 3924 : 					NewOption[3],
; 3925 : 					NewOption[4],
; 3926 : 					NewOption[5],
; 3927 : 					NewOption[6],
; 3928 : 					lpObj->Inventory1[iX].m_SetOption
; 3929 : 					);
; 3930 : 			}
; 3931 : 			lpObj->Inventory1[iX].Clear();
; 3932 : 		}
; 3933 : #ifdef PSHOP_INVENTORY_CLEAR_BUGFIX_20050321
; 3934 : 		memset(&lpObj->InventoryMap1[MAX_INVENTORYMAP], 0xFF, MAX_PSHOPITEM);
; 3935 : #else
; 3936 : 		memset(&lpObj->InventoryMap1[MAX_INVENTORY], 0xFF, sizeof(BYTE) * MAX_PSHOPITEM);
; 3937 : #endif		
; 3938 : 	}
; 3939 : #endif
; 3940 : 	
; 3941 : 	//------------------------------------------------------------------------
; 3942 : 	lpObj->Live			= 1;

  010bd	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010c0	c6 40 66 01	 mov	 BYTE PTR [eax+102], 1

; 3943 : 	lpObj->Type			= OBJTYPE_CHARACTER;

  010c4	b8 01 00 00 00	 mov	 eax, 1
  010c9	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  010cc	66 89 41 64	 mov	 WORD PTR [ecx+100], ax

; 3944 : 	lpObj->TargetNumber = -1;	//     .

  010d0	83 c8 ff	 or	 eax, -1
  010d3	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  010d6	66 89 81 ac 02
	00 00		 mov	 WORD PTR [ecx+684], ax

; 3945 : 	lpObj->Connected	= CSS_GAMEPLAYING;

  010dd	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  010e0	c7 40 04 03 00
	00 00		 mov	 DWORD PTR [eax+4], 3

; 3946 : 	
; 3947 : 	gObjMakePreviewCharSet(aIndex);			// !!>      gObjCalCharacter()  !!

  010e7	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  010ea	50		 push	 eax
  010eb	e8 00 00 00 00	 call	 ?gObjMakePreviewCharSet@@YAXH@Z ; gObjMakePreviewCharSet
  010f0	83 c4 04	 add	 esp, 4

; 3948 : 	CreateFrustrum(lpObj->X, lpObj->Y, aIndex);

  010f3	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  010f6	50		 push	 eax
  010f7	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  010fa	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  01101	52		 push	 edx
  01102	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01105	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  0110c	51		 push	 ecx
  0110d	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum
  01112	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3949 : 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->X, lpObj->Y);

  01115	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01118	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0111f	51		 push	 ecx
  01120	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01123	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  0112a	50		 push	 eax
  0112b	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0112e	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  01135	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  0113b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  01141	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 3950 : 	lpObj->m_OldX = lpObj->X;

  01146	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01149	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0114c	66 8b 91 04 01
	00 00		 mov	 dx, WORD PTR [ecx+260]
  01153	66 89 90 1c 01
	00 00		 mov	 WORD PTR [eax+284], dx

; 3951 : 	lpObj->m_OldY = lpObj->Y;

  0115a	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0115d	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01160	66 8b 91 06 01
	00 00		 mov	 dx, WORD PTR [ecx+262]
  01167	66 89 90 1e 01
	00 00		 mov	 WORD PTR [eax+286], dx

; 3952 : 	lpMsg->NextExp		= lpObj->NextExp;	//  EXP  .

  0116e	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  01171	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01174	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  0117a	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 3953 : 	
; 3954 : 	if( lpObj->Life == 0 )

  0117d	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01180	f3 0f 10 80 bc
	00 00 00	 movss	 xmm0, DWORD PTR [eax+188]
  01188	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0118f	9f		 lahf
  01190	f6 c4 44	 test	 ah, 68			; 00000044H
  01193	7a 2f		 jp	 SHORT $LN63@gObjSetCha

; 3955 : 	{
; 3956 : 		lpObj->Live		= 1;

  01195	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01198	c6 40 66 01	 mov	 BYTE PTR [eax+102], 1

; 3957 : 		lpObj->m_State  = OBJST_DYING;	//   .

  0119c	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0119f	c7 80 b8 01 00
	00 04 00 00 00	 mov	 DWORD PTR [eax+440], 4

; 3958 : 		lpObj->DieRegen	= 1;

  011a9	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  011ac	c6 80 fe 01 00
	00 01		 mov	 BYTE PTR [eax+510], 1

; 3959 : 		lpObj->RegenTime= GetTickCount();

  011b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  011b9	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  011bc	89 81 04 02 00
	00		 mov	 DWORD PTR [ecx+516], eax

; 3960 : 	}

  011c2	eb 0d		 jmp	 SHORT $LN64@gObjSetCha
$LN63@gObjSetCha:

; 3961 : 	else 
; 3962 : 	{
; 3963 : 		lpObj->m_State		= OBJST_CREATE;

  011c4	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  011c7	c7 80 b8 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+440], 1
$LN64@gObjSetCha:

; 3964 : 	}
; 3965 : 	
; 3966 : 	if( (lpMsg->CtlCode&0x08) == 0x08 ) 

  011d1	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  011d4	0f b6 88 3c 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1340]
  011db	83 e1 08	 and	 ecx, 8
  011de	74 2d		 je	 SHORT $LN65@gObjSetCha

; 3967 : 	{
; 3968 : 		lpObj->Authority = AUTHORITY_EVENT_GM;

  011e0	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  011e3	c7 80 a4 01 00
	00 20 00 00 00	 mov	 DWORD PTR [eax+420], 32	; 00000020H

; 3969 : 		LogAddC(LOGC_RED,"(%s)(%s) Set Event GM", lpObj->AccountID, lpObj->Name);

  011ed	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  011f0	83 c0 73	 add	 eax, 115		; 00000073H
  011f3	50		 push	 eax
  011f4	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  011f7	83 c1 68	 add	 ecx, 104		; 00000068H
  011fa	51		 push	 ecx
  011fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@DNBFMJJP@?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Set?5Event?5GM@
  01200	6a 02		 push	 2
  01202	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  01208	83 c4 10	 add	 esp, 16			; 00000010H

; 3970 : 		//cManager.ManagerAdd(lpObj->Name, lpObj->m_Index);
; 3971 : #ifdef UPDATE_GM_FUNCTION_20070228	//  
; 3972 : 		cManager.ManagerAdd(lpObj->Name, lpObj->m_Index);
; 3973 : #endif
; 3974 : 	}

  0120b	eb 0d		 jmp	 SHORT $LN66@gObjSetCha
$LN65@gObjSetCha:

; 3975 : 	else lpObj->Authority = AUTHORITY_USER;

  0120d	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01210	c7 80 a4 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+420], 1
$LN66@gObjSetCha:

; 3976 : 	
; 3977 : #ifdef CHINA_GM_EVENT
; 3978 : 	if( (lpMsg->CtlCode&0x10) == 0x10 ) 
; 3979 : 	{
; 3980 : 		lpObj->Authority = AUTHORITY_EVENT_GM;
; 3981 : 		LogAddC(LOGC_RED,"(%s)(%s) Set Event GM", lpObj->AccountID, lpObj->Name);
; 3982 : 		//cManager.ManagerAdd(lpObj->Name, lpObj->m_Index);
; 3983 : 	}
; 3984 : #endif
; 3985 : 
; 3986 : #ifdef MODIFY_CHN_GMEVENT_TO_TAIWAN_GM_EVENT_20070906
; 3987 : 	if( (lpMsg->CtlCode&0x10) == 0x10 ) 
; 3988 : 	{
; 3989 : 		lpObj->Authority = AUTHORITY_EVENT_GM;
; 3990 : 		LogAddC(LOGC_RED,"(%s)(%s) Set Event GM", lpObj->AccountID, lpObj->Name);
; 3991 : 		//cManager.ManagerAdd(lpObj->Name, lpObj->m_Index);
; 3992 : 	}
; 3993 : #endif // MODIFY_CHN_GMEVENT_TO_TAIWAN_GM_EVENT_20070906
; 3994 : 
; 3995 : #ifdef ADD_AUTHORITY_CODE_OF_EVENT_GM_20050602
; 3996 : 	if( (lpMsg->CtlCode&0x20) == 0x20 ) 

  0121a	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0121d	0f b6 88 3c 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1340]
  01224	83 e1 20	 and	 ecx, 32			; 00000020H
  01227	74 4e		 je	 SHORT $LN67@gObjSetCha

; 3997 : 	{
; 3998 : 		lpObj->Authority = AUTHORITY_ADMIN | AUTHORITY_EVENT_GM;

  01229	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0122c	c7 80 a4 01 00
	00 22 00 00 00	 mov	 DWORD PTR [eax+420], 34	; 00000022H

; 3999 : 		LogAddC(LOGC_RED,lMsg.Get(501), lpObj->AccountID, lpObj->Name);

  01236	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01239	83 c0 73	 add	 eax, 115		; 00000073H
  0123c	50		 push	 eax
  0123d	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  01240	83 c1 68	 add	 ecx, 104		; 00000068H
  01243	51		 push	 ecx
  01244	68 f5 01 00 00	 push	 501			; 000001f5H
  01249	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0124e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  01254	50		 push	 eax
  01255	6a 02		 push	 2
  01257	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0125d	83 c4 10	 add	 esp, 16			; 00000010H

; 4000 : 		cManager.ManagerAdd(lpObj->Name, lpObj->m_Index);

  01260	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01263	8b 08		 mov	 ecx, DWORD PTR [eax]
  01265	51		 push	 ecx
  01266	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01269	83 c2 73	 add	 edx, 115		; 00000073H
  0126c	52		 push	 edx
  0126d	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  01272	e8 00 00 00 00	 call	 ?ManagerAdd@CGMMng@@QAEHPADH@Z ; CGMMng::ManagerAdd
$LN67@gObjSetCha:

; 4001 : 	}
; 4002 : #endif
; 4003 : 
; 4004 : #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 4005 : 	if( lpObj->Authority == AUTHORITY_EVENT_GM )
; 4006 : 	{
; 4007 : 		gObjAddBuffEffect( lpObj, BUFFTYPE_GM_MARK, 0, 0, 0, 0, BUFFTIME_INFINITE );
; 4008 : 	}
; 4009 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 4010 : 
; 4011 : #if (TESTSERVER == 1) || defined(FOR_TEMP_SERVER)
; 4012 : 	if( (lpMsg->CtlCode&0x40) == 0x40 ) 
; 4013 : 	{
; 4014 : 		lpObj->Authority = AUTHORITY_SUPER_ADMIN;
; 4015 : 		LogAddC(LOGC_RED,"(%s)(%s) Set Super Admin", lpObj->AccountID, lpObj->Name);
; 4016 : 		cManager.ManagerAdd(lpObj->Name, lpObj->m_Index);
; 4017 : 	}
; 4018 : #endif
; 4019 : 
; 4020 : 	// Admin, EventGm    20081215 (grooving)
; 4021 : #ifdef MODIFIY_AUTHORITY_INTERGRATION_20081215
; 4022 : 	if( (lpMsg->CtlCode&0x20) == 0x20 ) 
; 4023 : 	{
; 4024 : 		lpObj->Authority = AUTHORITY_ADMIN | AUTHORITY_EVENT_GM;
; 4025 : 		LogAddC(LOGC_RED,"(%s)(%s) Set Japan ADMIN | EVENT_GM", lpObj->AccountID, lpObj->Name);
; 4026 : 		cManager.ManagerAdd(lpObj->Name, lpObj->m_Index);
; 4027 : 	}
; 4028 : #endif
; 4029 : 	lpObj->Penalty = 0;

  01277	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0127a	c7 80 a8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+424], 0

; 4030 : 
; 4031 : 
; 4032 : 	if( lpObj->m_cAccountItemBlock )

  01284	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01287	0f b6 88 ac 01
	00 00		 movzx	 ecx, BYTE PTR [eax+428]
  0128e	85 c9		 test	 ecx, ecx
  01290	74 15		 je	 SHORT $LN68@gObjSetCha

; 4033 : 	{	// ..
; 4034 : 		lpObj->Penalty |= CTLCODE_ACCOUNTITEMBLOCK;

  01292	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01295	8b 88 a8 01 00
	00		 mov	 ecx, DWORD PTR [eax+424]
  0129b	83 c9 08	 or	 ecx, 8
  0129e	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  012a1	89 8a a8 01 00
	00		 mov	 DWORD PTR [edx+424], ecx
$LN68@gObjSetCha:

; 4035 : 	}
; 4036 : 
; 4037 : 	if( (lpMsg->CtlCode&0x02) == 0x02 ) 

  012a7	8b 45 d8	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  012aa	0f b6 88 3c 05
	00 00		 movzx	 ecx, BYTE PTR [eax+1340]
  012b1	83 e1 02	 and	 ecx, 2
  012b4	74 31		 je	 SHORT $LN69@gObjSetCha

; 4038 : 	{
; 4039 : 		lpObj->Penalty |= CTLCODE_ITEMDONTTOUCH;

  012b6	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  012b9	8b 88 a8 01 00
	00		 mov	 ecx, DWORD PTR [eax+424]
  012bf	83 c9 04	 or	 ecx, 4
  012c2	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  012c5	89 8a a8 01 00
	00		 mov	 DWORD PTR [edx+424], ecx

; 4040 : 		LogAddL("Penalty : Item Don't touch  %s %s", lpObj->AccountID, lpObj->Name);

  012cb	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  012ce	83 c0 73	 add	 eax, 115		; 00000073H
  012d1	50		 push	 eax
  012d2	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  012d5	83 c1 68	 add	 ecx, 104		; 00000068H
  012d8	51		 push	 ecx
  012d9	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@GOGGAFJG@Penalty?5?3?5Item?5Don?8t?5touch?5?5?$CFs?5@
  012de	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddL@@3P6AXPADZZA ; LogAddL
  012e4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN69@gObjSetCha:

; 4041 : 	}	
; 4042 : 	
; 4043 : 	/*if( (lpMsg->AccountCtlCode&0x01) == 0x01 ) 
; 4044 : 	{
; 4045 : 		lpObj->Penalty |= CTLCODE_ACCOUNTITEMBLOCK;
; 4046 : 		LogAddL("Penalty : CTLCODE_ACCOUNTITEMBLOCK %s %s", lpObj->AccountID, lpObj->Name);
; 4047 : 	}
; 4048 : 	*/
; 4049 : 	
; 4050 : 	gObjAuthorityCodeSet(lpObj);

  012e7	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  012ea	50		 push	 eax
  012eb	e8 00 00 00 00	 call	 ?gObjAuthorityCodeSet@@YAXPAVOBJECTSTRUCT@@@Z ; gObjAuthorityCodeSet
  012f0	83 c4 04	 add	 esp, 4

; 4051 : 
; 4052 : 	LogAddTD(lMsg.Get(502), lpObj->m_Index, lpObj->AccountID, lpObj->Name);

  012f3	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  012f6	83 c0 73	 add	 eax, 115		; 00000073H
  012f9	50		 push	 eax
  012fa	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  012fd	83 c1 68	 add	 ecx, 104		; 00000068H
  01300	51		 push	 ecx
  01301	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01304	8b 02		 mov	 eax, DWORD PTR [edx]
  01306	50		 push	 eax
  01307	68 f6 01 00 00	 push	 502			; 000001f6H
  0130c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  01311	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  01317	50		 push	 eax
  01318	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0131e	83 c4 10	 add	 esp, 16			; 00000010H

; 4053 : 
; 4054 : 	BYTE weather = MapC[lpObj->MapNumber].GetWeather();

  01321	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01324	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0132b	69 c9 8c 04 05
	00		 imul	 ecx, ecx, 328844
  01331	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  01337	e8 00 00 00 00	 call	 ?GetWeather@MapClass@@QAEEXZ ; MapClass::GetWeather
  0133c	88 45 a3	 mov	 BYTE PTR _weather$[ebp], al

; 4055 : 	if( (weather>>4) > 0 ) CGWeatherSend(aIndex, weather);

  0133f	0f b6 45 a3	 movzx	 eax, BYTE PTR _weather$[ebp]
  01343	c1 f8 04	 sar	 eax, 4
  01346	85 c0		 test	 eax, eax
  01348	7e 11		 jle	 SHORT $LN70@gObjSetCha
  0134a	0f b6 45 a3	 movzx	 eax, BYTE PTR _weather$[ebp]
  0134e	50		 push	 eax
  0134f	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  01352	51		 push	 ecx
  01353	e8 00 00 00 00	 call	 ?CGWeatherSend@@YAXHE@Z	; CGWeatherSend
  01358	83 c4 08	 add	 esp, 8
$LN70@gObjSetCha:

; 4056 : 
; 4057 : 	//   .. ->     .
; 4058 : 	if( DragonEvent->GetState() > 0 )

  0135b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  01361	e8 00 00 00 00	 call	 ?GetState@CDragonEvent@@QAEEXZ ; CDragonEvent::GetState
  01366	0f b6 c0	 movzx	 eax, al
  01369	85 c0		 test	 eax, eax
  0136b	7e 33		 jle	 SHORT $LN72@gObjSetCha

; 4059 : 	{
; 4060 : 		if( DragonEvent->GetMapNumber() == lpObj->MapNumber )

  0136d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  01373	e8 00 00 00 00	 call	 ?GetMapNumber@CDragonEvent@@QAEEXZ ; CDragonEvent::GetMapNumber
  01378	0f b6 c0	 movzx	 eax, al
  0137b	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0137e	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  01385	3b c2		 cmp	 eax, edx
  01387	75 17		 jne	 SHORT $LN72@gObjSetCha

; 4061 : 		{
; 4062 : 			GCMapEventStateSend(lpObj->MapNumber, 1, 1);

  01389	6a 01		 push	 1
  0138b	6a 01		 push	 1
  0138d	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01390	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  01397	51		 push	 ecx
  01398	e8 00 00 00 00	 call	 ?GCMapEventStateSend@@YAXHEE@Z ; GCMapEventStateSend
  0139d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN72@gObjSetCha:

; 4063 : 		}
; 4064 : 	}
; 4065 : 
; 4066 : #ifdef CASTLE_MAIN_SCHEDULER_20041111		//     .
; 4067 : 	if (lpObj->MapNumber == MAP_INDEX_CASTLESIEGE) {
; 4068 : 		GCAnsCsNotifyStart(lpObj->m_Index, (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)?1:0);
; 4069 : 		if (g_CastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE) {
; 4070 : //			g_CastleSiege.NotifySelfCsJoinSide (lpObj->m_Index);
; 4071 : 			g_CastleSiege.NotifyCsSelfLeftTime (lpObj->m_Index);
; 4072 : 		}
; 4073 : 	}
; 4074 : #endif
; 4075 : 
; 4076 : 	//     .
; 4077 : 	gEledoradoEvent.CheckGoldDercon(lpObj->MapNumber);

  013a0	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  013a3	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  013aa	51		 push	 ecx
  013ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?gEledoradoEvent@@3VCEledoradoEvent@@A ; gEledoradoEvent
  013b0	e8 00 00 00 00	 call	 ?CheckGoldDercon@CEledoradoEvent@@QAEXH@Z ; CEledoradoEvent::CheckGoldDercon

; 4078 : 
; 4079 : 	// main.exe   ?
; 4080 : 	GCCheckMainExeKeySend(aIndex);

  013b5	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  013b8	50		 push	 eax
  013b9	e8 00 00 00 00	 call	 ?GCCheckMainExeKeySend@@YAXH@Z ; GCCheckMainExeKeySend
  013be	83 c4 04	 add	 esp, 4

; 4081 : 
; 4082 : 	//   ??
; 4083 : #ifdef UPDATE_UNIFICATIONBILL_20090203
; 4084 : 	if(m_ObjBill[aIndex].GetDeductType() > BILL_TYPE_NONE && m_ObjBill[aIndex].GetDeductType() <= BILL_TYPE_COLLOR)

  013c1	6b 4d 0c 1c	 imul	 ecx, DWORD PTR _aIndex$[ebp], 28
  013c5	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  013cb	e8 00 00 00 00	 call	 ?GetDeductType@BILL_CLASS@@QAEEXZ ; BILL_CLASS::GetDeductType
  013d0	0f b6 c0	 movzx	 eax, al
  013d3	85 c0		 test	 eax, eax
  013d5	7e 35		 jle	 SHORT $LN73@gObjSetCha
  013d7	6b 4d 0c 1c	 imul	 ecx, DWORD PTR _aIndex$[ebp], 28
  013db	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  013e1	e8 00 00 00 00	 call	 ?GetDeductType@BILL_CLASS@@QAEEXZ ; BILL_CLASS::GetDeductType
  013e6	0f b6 c0	 movzx	 eax, al
  013e9	83 f8 05	 cmp	 eax, 5
  013ec	7f 1e		 jg	 SHORT $LN73@gObjSetCha

; 4085 : 	{
; 4086 : 		gLCount[m_ObjBill[aIndex].GetDeductType()].Add();

  013ee	6b 4d 0c 1c	 imul	 ecx, DWORD PTR _aIndex$[ebp], 28
  013f2	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  013f8	e8 00 00 00 00	 call	 ?GetDeductType@BILL_CLASS@@QAEEXZ ; BILL_CLASS::GetDeductType
  013fd	0f b6 c0	 movzx	 eax, al
  01400	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR ?gLCount@@3PAVCLoginCount@@A[eax*4]
  01407	e8 00 00 00 00	 call	 ?Add@CLoginCount@@QAEXXZ ; CLoginCount::Add
$LN73@gObjSetCha:

; 4087 : 	}
; 4088 : #else	// UPDATE_UNIFICATIONBILL_20090203	
; 4089 : 	if(m_ObjBill[aIndex].GetCertify()>=0&&m_ObjBill[aIndex].GetCertify()<MAX_LOGIN_COUNT)
; 4090 : 	{
; 4091 : 		gLCount[m_ObjBill[aIndex].GetCertify()].Add();
; 4092 : 	}
; 4093 : #endif	// UPDATE_UNIFICATIONBILL_20090203
; 4094 : 	
; 4095 : #ifdef DELETE_GD_REQUEST_20080110
; 4096 : //#ifdef MASTER_LEVEL_UP_SYSTEM_20070912					//    DS   
; 4097 : //	g_MasterLevelSystem.GDReqMasterLevelInfo( lpObj );
; 4098 : //#endif
; 4099 : #endif
; 4100 : 
; 4101 : #ifndef MODIFY_ORDER_REQUEST_FRIENDLIST_20050205
; 4102 : 	#ifdef __FRIEND_WORK__
; 4103 : 		FriendListRequest(aIndex);
; 4104 : 	#endif
; 4105 : #endif
; 4106 : 
; 4107 : #ifdef ITEMDELETE_MODIFY_20040604		//  DB         .
; 4108 : 	if (bAllItemExist == false) {

  0140c	0f b6 45 ab	 movzx	 eax, BYTE PTR _bAllItemExist$[ebp]
  01410	85 c0		 test	 eax, eax
  01412	75 33		 jne	 SHORT $LN74@gObjSetCha

; 4109 : 		PMSG_NOTICE	pNotice;
; 4110 : 	#ifdef MODIFY_NOTICE_20040325
; 4111 : 		TNotice::MakeNoticeMsgEx( &pNotice, 1, "   !!!");

  01414	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@JCIHPMHF@?$LO?x?$LE?B?5?$LO?F?$MA?L?E?$NL?5?$LJ?$NP?$LA?$NP?5?$CB?$CB?$CB@
  01419	6a 01		 push	 1
  0141b	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR _pNotice$5[ebp]
  01421	50		 push	 eax
  01422	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  01427	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4112 : 	#else
; 4113 : 		pNotice.type = 1;
; 4114 : 		wsprintf(pNotice.Notice, "   !!!");
; 4115 : 		PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 4116 : 	#endif
; 4117 : 		DataSend(lpObj->m_Index, (LPBYTE)&pNotice, pNotice.h.size);

  0142a	0f b6 85 91 fe
	ff ff		 movzx	 eax, BYTE PTR _pNotice$5[ebp+1]
  01431	50		 push	 eax
  01432	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR _pNotice$5[ebp]
  01438	51		 push	 ecx
  01439	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0143c	8b 02		 mov	 eax, DWORD PTR [edx]
  0143e	50		 push	 eax
  0143f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  01444	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN74@gObjSetCha:

; 4118 : 	}
; 4119 : #endif
; 4120 : 
; 4121 : #ifdef HAPPY_POUCH //happycat@20050201
; 4122 : 	#ifdef PCBANG_ADVANTAGE_EXPAND_20060919
; 4123 : 		if( IsOKPCBangBenefitAll(lpObj) )
; 4124 : 		{
; 4125 : 			lpObj->m_lFreeKalimaTime = 900000;
; 4126 : 		}
; 4127 : 	#else
; 4128 : 		if (lpObj->m_bPCBangUser)
; 4129 : 		{
; 4130 : 			lpObj->m_lFreeKalimaTime = 900000;
; 4131 : 		}
; 4132 : 	#endif // PCBANG_ADVANTAGE_EXPAND_20060919
; 4133 : 		else
; 4134 : 		{
; 4135 : 			lpObj->m_lFreeKalimaTime = 0;
; 4136 : 		}
; 4137 : #endif	
; 4138 : 	
; 4139 : #ifdef CHARACTER_AUTO_RECUPERATION_SYSTEM_20050614
; 4140 : 	if(lpObj->Level <= g_iCharacterRecuperationMaxLevel) {
; 4141 : 		lpObj->m_iAutoRecuperationTime = GetTickCount();
; 4142 : 	}
; 4143 : 	else lpObj->m_iAutoRecuperationTime = 0;
; 4144 : #endif
; 4145 : 
; 4146 : #ifdef ADD_SHIELD_POINT_01_20060403
; 4147 : 	lpObj->dwShieldAutoRefillTimer = GetTickCount();
; 4148 : #endif
; 4149 : 
; 4150 : #ifdef UPDATE_SHIELD_OPTION_20060427
; 4151 : 	LogAddTD("[ShieldSystem][CalcSDPoint] [%s][%s] user SD Gage : %d", lpObj->AccountID, lpObj->Name, lpObj->iMaxShield + lpObj->iAddShield );
; 4152 : #endif 
; 4153 : 
; 4154 : #ifdef ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 4155 : 	g_CashShop.AddUser( lpObj );
; 4156 : 	g_CashShop.CGCashPoint( lpObj );
; 4157 : #endif // ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 4158 : 
; 4159 : #ifdef ADD_PARTIALY_CHARGE_PERIOD_SYSTEM_20070205
; 4160 : 	g_CashItemPeriodSystem.GDReqPeriodItemList( lpObj );
; 4161 : #endif // ADD_PARTIALY_CHARGE_PERIOD_SYSTEM_20070205
; 4162 : 
; 4163 : #ifdef DELETE_GD_REQUEST_20080110
; 4164 : //#ifdef MODIFY_QUEST_MONSTER_KILL_COUNT_BUGFIX_20070704	// DS    
; 4165 : //	//       .
; 4166 : //	g_QuestUtil.GDReqQuestMonsterKillInfo( lpObj );
; 4167 : //#endif
; 4168 : #endif
; 4169 : 
; 4170 : #ifdef MODIFY_RAKLION_BOSS_ZONE_BANISH_USER_2ND_20080917	//    
; 4171 : //	if( lpObj->MapNumber == MAP_INDEX_RAKLION_BOSS )		//   .
; 4172 : //	{
; 4173 : //		//      .
; 4174 : //		if( g_Raklion.GetRaklionState() != RAKLION_STATE_CLOSE_DOOR
; 4175 : //			&& g_Raklion.GetRaklionState() != RAKLION_STATE_ALL_USER_DIE
; 4176 : //			&& g_Raklion.GetRaklionState() != RAKLION_STATE_NOTIFY_4
; 4177 : //			&& g_Raklion.GetRaklionState() != RAKLION_STATE_END )
; 4178 : //		{			
; 4179 : //			g_RaklionBattleUserMng.AddUserData( lpObj->m_Index );
; 4180 : //		}
; 4181 : //	}
; 4182 : #else
; 4183 : #ifdef ADD_RAKLION_20080408
; 4184 : 	if( lpObj->MapNumber == MAP_INDEX_RAKLION_BOSS )
; 4185 : 	{
; 4186 : 		//      .
; 4187 : 		if( g_Raklion.GetRaklionState() != RAKLION_STATE_CLOSE_DOOR
; 4188 : 			&& g_Raklion.GetRaklionState() != RAKLION_STATE_ALL_USER_DIE
; 4189 : 			&& g_Raklion.GetRaklionState() != RAKLION_STATE_NOTIFY_4
; 4190 : 			&& g_Raklion.GetRaklionState() != RAKLION_STATE_END )
; 4191 : 		{			
; 4192 : 			g_RaklionBattleUserMng.AddUserData( lpObj->m_Index );
; 4193 : 		}
; 4194 : 	}
; 4195 : #endif // ADD_RAKLION_20080408
; 4196 : #endif // MODIFY_RAKLION_BOSS_ZONE_BANISH_USER_2ND_20080917
; 4197 : 
; 4198 : //     .
; 4199 : #ifdef MODIFY_DARK_SPRIT_SKILL_INITIALIZE_BUGFIX_20080702
; 4200 : 	if( lpObj->Class == CLASS_DARKLORD )

  01447	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0144a	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  01451	83 f9 04	 cmp	 ecx, 4
  01454	75 15		 jne	 SHORT $LN75@gObjSetCha

; 4201 : 		gDarkSpirit[lpObj->m_Index].SetMode(CDarkSpirit::PetItem_Mode_Normal);

  01456	6a ff		 push	 -1
  01458	6a 00		 push	 0
  0145a	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0145d	6b 08 28	 imul	 ecx, DWORD PTR [eax], 40
  01460	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  01466	e8 00 00 00 00	 call	 ?SetMode@CDarkSpirit@@QAEXW4ePetItem_Mode@1@H@Z ; CDarkSpirit::SetMode
$LN75@gObjSetCha:

; 4202 : #endif // MODIFY_DARK_SPRIT_SKILL_INITIALIZE_BUGFIX_20080702
; 4203 : 
; 4204 : 	lpObj->m_AccountType = lpMsg->AccountType;

  0146b	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0146e	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  01471	8a 91 76 05 00
	00		 mov	 dl, BYTE PTR [ecx+1398]
  01477	88 90 5d 1a 00
	00		 mov	 BYTE PTR [eax+6749], dl

; 4205 : 
; 4206 : 	lpObj->m_EndTime = lpMsg->EndTime;

  0147d	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01480	8b 4d d8	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  01483	8b 91 78 05 00
	00		 mov	 edx, DWORD PTR [ecx+1400]
  01489	89 90 60 1a 00
	00		 mov	 DWORD PTR [eax+6752], edx
  0148f	8b 89 7c 05 00
	00		 mov	 ecx, DWORD PTR [ecx+1404]
  01495	89 88 64 1a 00
	00		 mov	 DWORD PTR [eax+6756], ecx

; 4207 : 	lpObj->m_JoinTime = time(NULL);

  0149b	6a 00		 push	 0
  0149d	e8 00 00 00 00	 call	 _time
  014a2	83 c4 04	 add	 esp, 4
  014a5	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  014a8	89 81 68 1a 00
	00		 mov	 DWORD PTR [ecx+6760], eax
  014ae	89 91 6c 1a 00
	00		 mov	 DWORD PTR [ecx+6764], edx

; 4208 : 	lpObj->m_dwRequestVip = GetTickCount()+(5*60*1000);

  014b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  014ba	05 e0 93 04 00	 add	 eax, 300000		; 000493e0H
  014bf	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  014c2	89 81 70 1a 00
	00		 mov	 DWORD PTR [ecx+6768], eax

; 4209 : 	lpObj->m_bRequestVip = false;

  014c8	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014cb	c6 80 74 1a 00
	00 00		 mov	 BYTE PTR [eax+6772], 0

; 4210 : 
; 4211 : 	if(lpObj->m_EndTime <= 0)

  014d2	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014d5	89 85 38 fe ff
	ff		 mov	 DWORD PTR tv1494[ebp], eax
  014db	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR tv1494[ebp]
  014e1	83 b9 64 1a 00
	00 00		 cmp	 DWORD PTR [ecx+6756], 0
  014e8	7f 32		 jg	 SHORT $LN76@gObjSetCha
  014ea	7c 0f		 jl	 SHORT $LN110@gObjSetCha
  014ec	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv1494[ebp]
  014f2	83 ba 60 1a 00
	00 00		 cmp	 DWORD PTR [edx+6752], 0
  014f9	77 21		 ja	 SHORT $LN76@gObjSetCha
$LN110@gObjSetCha:

; 4212 : 	{
; 4213 : 		lpObj->m_AccountType = 0;

  014fb	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  014fe	c6 80 5d 1a 00
	00 00		 mov	 BYTE PTR [eax+6749], 0

; 4214 : 		lpObj->m_EndTime = 0;

  01505	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01508	c7 80 60 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6752], 0
  01512	c7 80 64 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6756], 0
$LN76@gObjSetCha:

; 4215 : 	}
; 4216 : 
; 4217 : 	if(lpObj->m_AccountType != 0)

  0151c	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0151f	0f b6 88 5d 1a
	00 00		 movzx	 ecx, BYTE PTR [eax+6749]
  01526	85 c9		 test	 ecx, ecx
  01528	74 0a		 je	 SHORT $LN77@gObjSetCha

; 4218 : 		lpObj->m_bVIPReload = true;

  0152a	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0152d	c6 80 75 1a 00
	00 01		 mov	 BYTE PTR [eax+6773], 1
$LN77@gObjSetCha:

; 4219 : 
; 4220 : 	//g_VIPSystem.CheckVIP(lpObj);
; 4221 : 
; 4222 : 	cManager.ManagementProc(lpObj,"/vipinfo",lpObj->m_Index);

  01534	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01537	8b 08		 mov	 ecx, DWORD PTR [eax]
  01539	51		 push	 ecx
  0153a	68 00 00 00 00	 push	 OFFSET ??_C@_08NKGJGPDF@?1vipinfo@
  0153f	8b 55 d4	 mov	 edx, DWORD PTR _lpObj$[ebp]
  01542	52		 push	 edx
  01543	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  01548	e8 00 00 00 00	 call	 ?ManagementProc@CGMMng@@QAEHPAVOBJECTSTRUCT@@PADH@Z ; CGMMng::ManagementProc

; 4223 : 	int Golds = Manager.KCredits(gObj[aIndex].AccountID);

  0154d	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  01554	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0155a	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0155e	52		 push	 edx
  0155f	b9 00 00 00 00	 mov	 ecx, OFFSET ?Manager@@3VCManager@@A ; Manager
  01564	e8 00 00 00 00	 call	 ?KCredits@CManager@@QAEHPAD@Z ; CManager::KCredits
  01569	89 85 8c fe ff
	ff		 mov	 DWORD PTR _Golds$[ebp], eax

; 4224 : 	MsgOutput(aIndex,"[CASH SYSTEM] Tienes %d de Cash", Golds);

  0156f	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _Golds$[ebp]
  01575	50		 push	 eax
  01576	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@EIDBCBFJ@?$FLCASH?5SYSTEM?$FN?5Tienes?5?$CFd?5de?5Cash@
  0157b	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0157e	51		 push	 ecx
  0157f	e8 00 00 00 00	 call	 ?MsgOutput@@YAXHPADZZ	; MsgOutput
  01584	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4225 : 
; 4226 : 	if(lpObj->m_AccountType != 0)

  01587	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0158a	0f b6 88 5d 1a
	00 00		 movzx	 ecx, BYTE PTR [eax+6749]
  01591	85 c9		 test	 ecx, ecx
  01593	0f 84 85 00 00
	00		 je	 $LN78@gObjSetCha

; 4227 : 	{
; 4228 : 		LogAddTD("VIP User Connected: [%s][%d][%s]",lpObj->AccountID,lpObj->m_AccountType,CTime(lpObj->m_EndTime).Format("%d/%m/%Y %H:%M:%S"));

  01599	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JJLOFGFB@?$CFd?1?$CFm?1?$CFY?5?$CFH?3?$CFM?3?$CFS@
  0159e	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  015a4	50		 push	 eax
  015a5	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  015a8	8b 91 64 1a 00
	00		 mov	 edx, DWORD PTR [ecx+6756]
  015ae	52		 push	 edx
  015af	8b 81 60 1a 00
	00		 mov	 eax, DWORD PTR [ecx+6752]
  015b5	50		 push	 eax
  015b6	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  015bc	e8 00 00 00 00	 call	 ??0CTime@ATL@@QAE@_J@Z	; ATL::CTime::CTime
  015c1	8b c8		 mov	 ecx, eax
  015c3	e8 00 00 00 00	 call	 ?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z ; ATL::CTime::Format
  015c8	89 85 38 fe ff
	ff		 mov	 DWORD PTR tv1021[ebp], eax
  015ce	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR tv1021[ebp]
  015d4	89 8d 34 fe ff
	ff		 mov	 DWORD PTR tv1020[ebp], ecx
  015da	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  015e1	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR tv1020[ebp]
  015e7	8b 02		 mov	 eax, DWORD PTR [edx]
  015e9	50		 push	 eax
  015ea	8b 4d d4	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  015ed	0f b6 91 5d 1a
	00 00		 movzx	 edx, BYTE PTR [ecx+6749]
  015f4	52		 push	 edx
  015f5	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  015f8	83 c0 68	 add	 eax, 104		; 00000068H
  015fb	50		 push	 eax
  015fc	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PBFGMDKK@VIP?5User?5Connected?3?5?$FL?$CFs?$FN?$FL?$CFd?$FN?$FL?$CFs@
  01601	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01607	83 c4 10	 add	 esp, 16			; 00000010H
  0160a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01611	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  01617	e8 00 00 00 00	 call	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >

; 4229 : 	}

  0161c	eb 15		 jmp	 SHORT $LN79@gObjSetCha
$LN78@gObjSetCha:

; 4230 : 	else
; 4231 : 		LogAddTD("Free User Connected: [%s]",lpObj->AccountID);

  0161e	8b 45 d4	 mov	 eax, DWORD PTR _lpObj$[ebp]
  01621	83 c0 68	 add	 eax, 104		; 00000068H
  01624	50		 push	 eax
  01625	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@EFNGMPBL@Free?5User?5Connected?3?5?$FL?$CFs?$FN@
  0162a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  01630	83 c4 08	 add	 esp, 8
$LN79@gObjSetCha:

; 4232 : 
; 4233 : 	return TRUE;

  01633	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjSetCha:

; 4234 : }

  01638	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0163b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01642	59		 pop	 ecx
  01643	5f		 pop	 edi
  01644	5e		 pop	 esi
  01645	5b		 pop	 ebx
  01646	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  01649	33 cd		 xor	 ecx, ebp
  0164b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01650	8b e5		 mov	 esp, ebp
  01652	5d		 pop	 ebp
  01653	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?gObjSetCharacter@@YAHPAEH@Z$0:
  00000	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?gObjSetCharacter@@YAHPAEH@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 30 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-464]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?gObjSetCharacter@@YAHPAEH@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?gObjSetCharacter@@YAHPAEH@Z ENDP			; gObjSetCharacter
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSetAccountLogin@@YAHHPADHH0@Z
_TEXT	SEGMENT
tv66 = -72						; size = 4
tv67 = -68						; size = 4
_aIndex$ = 8						; size = 4
_szId$ = 12						; size = 4
_aUserNumber$ = 16					; size = 4
_aDBNumber$ = 20					; size = 4
_JoominNumber$ = 24					; size = 4
?gObjSetAccountLogin@@YAHHPADHH0@Z PROC			; gObjSetAccountLogin, COMDAT

; 6822 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6823 : 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT) ) 

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN8@gObjSetAcc
  0000f	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN9@gObjSetAcc
$LN8@gObjSetAcc:
  00018	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN6@gObjSetAcc
  00021	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN7@gObjSetAcc
$LN6@gObjSetAcc:
  0002a	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN7@gObjSetAcc:
  00031	8b 45 b8	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 bc	 mov	 DWORD PTR tv67[ebp], eax
$LN9@gObjSetAcc:
  00037	83 7d bc 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 23		 jne	 SHORT $LN2@gObjSetAcc

; 6824 : 	{
; 6825 : 		LogAdd("error : %s %d",__FILE__, __LINE__);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjSetAccountLogin@@YAHHPADHH0@Z@4JA
  00042	83 c0 03	 add	 eax, 3
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6826 : 		return FALSE;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 07 01 00 00	 jmp	 $LN1@gObjSetAcc
$LN2@gObjSetAcc:

; 6827 : 	}
; 6828 : 
; 6829 : #ifdef MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 6830 : 	if( gObj[aIndex].Connected != CSS_LOGIN && gObj[aIndex].Connected != CSS_LOGINWAIT )

  00060	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0006d	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  00072	74 4f		 je	 SHORT $LN3@gObjSetAcc
  00074	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00081	83 7c 01 04 ff	 cmp	 DWORD PTR [ecx+eax+4], -1
  00086	74 3b		 je	 SHORT $LN3@gObjSetAcc

; 6831 : #else
; 6832 : 	if( gObj[aIndex].Connected != CSS_LOGIN )
; 6833 : #endif // MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 6834 : 	{
; 6835 : 		LogAddTD(lMsg.Get(518), aIndex, szId, aDBNumber, __FILE__, __LINE__);

  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjSetAccountLogin@@YAHHPADHH0@Z@4JA
  0008d	83 c0 0d	 add	 eax, 13			; 0000000dH
  00090	50		 push	 eax
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00096	8b 4d 14	 mov	 ecx, DWORD PTR _aDBNumber$[ebp]
  00099	51		 push	 ecx
  0009a	8b 55 0c	 mov	 edx, DWORD PTR _szId$[ebp]
  0009d	52		 push	 edx
  0009e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  000a1	50		 push	 eax
  000a2	68 06 02 00 00	 push	 518			; 00000206H
  000a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000b2	50		 push	 eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000b9	83 c4 18	 add	 esp, 24			; 00000018H

; 6836 : 		return FALSE;

  000bc	33 c0		 xor	 eax, eax
  000be	e9 a4 00 00 00	 jmp	 $LN1@gObjSetAcc
$LN3@gObjSetAcc:

; 6837 : 	}
; 6838 : 	//       .
; 6839 : 	if( strcmp(gObj[aIndex].AccountID, szId) != 0 )

  000c3	8b 45 0c	 mov	 eax, DWORD PTR _szId$[ebp]
  000c6	50		 push	 eax
  000c7	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  000ce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d4	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 _strcmp
  000de	83 c4 08	 add	 esp, 8
  000e1	85 c0		 test	 eax, eax
  000e3	74 22		 je	 SHORT $LN4@gObjSetAcc

; 6840 : 	{
; 6841 : 		LogAdd(lMsg.Get(519), szId);

  000e5	8b 45 0c	 mov	 eax, DWORD PTR _szId$[ebp]
  000e8	50		 push	 eax
  000e9	68 07 02 00 00	 push	 519			; 00000207H
  000ee	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000f9	50		 push	 eax
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00100	83 c4 08	 add	 esp, 8

; 6842 : 		return FALSE;

  00103	33 c0		 xor	 eax, eax
  00105	eb 60		 jmp	 SHORT $LN1@gObjSetAcc
$LN4@gObjSetAcc:

; 6843 : 	}
; 6844 : 
; 6845 : 	gObj[aIndex].UserNumber = aUserNumber;

  00107	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0010e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00114	8b 55 10	 mov	 edx, DWORD PTR _aUserNumber$[ebp]
  00117	89 54 01 28	 mov	 DWORD PTR [ecx+eax+40], edx

; 6846 : 	gObj[aIndex].DBNumber   = aDBNumber;

  0011b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00122	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00128	8b 55 14	 mov	 edx, DWORD PTR _aDBNumber$[ebp]
  0012b	89 54 01 2c	 mov	 DWORD PTR [ecx+eax+44], edx

; 6847 : 	gObj[aIndex].Connected  = CSS_LOGINOK;

  0012f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00136	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013c	c7 44 01 04 02
	00 00 00	 mov	 DWORD PTR [ecx+eax+4], 2

; 6848 : 	strcpy(gObj[aIndex].LastJoominNumber, JoominNumber);

  00144	8b 45 18	 mov	 eax, DWORD PTR _JoominNumber$[ebp]
  00147	50		 push	 eax
  00148	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0014f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00155	8d 44 0a 7e	 lea	 eax, DWORD PTR [edx+ecx+126]
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 _strcpy
  0015f	83 c4 08	 add	 esp, 8

; 6849 : 
; 6850 : 
; 6851 : #ifdef ADD_PROTOCOL_PCBANG_GUID	
; 6852 : 	gObj[aIndex].PcBangGuid   = aPCBangGuid;
; 6853 : #endif
; 6854 : 
; 6855 : #ifdef PCBANG_ADVANTAGE //happycat@20050201 (PC )
; 6856 : 	// 20060918 m_bPCBangUser  PC     .!
; 6857 : 	//   PCBANG_ADVANTAGE_EXPAND_20060919   
; 6858 : 	gObj[aIndex].m_bPCBangUser = bPCBangUser; 
; 6859 : 
; 6860 : 	#ifdef FOR_TAIWAN
; 6861 : 		gObj[aIndex].m_bPCBangUser = bPCBangUser;
; 6862 : 
; 6863 : 		//PC    (riverstyx)
; 6864 : 		if (gObj[aIndex].m_bPCBangUser == TRUE) 
; 6865 : 		{
; 6866 : 			LogAddTD("[PCBANG_ADVANTAGE][PCBang User Connect] [%s] - %s",
; 6867 : 				gObj[aIndex].AccountID, gObj[aIndex].Ip_addr);
; 6868 : 		}
; 6869 : 
; 6870 : 	#endif
; 6871 : #endif
; 6872 : 
; 6873 : #ifdef PCBANG_FREE_KALIMA_EVENT_20060124
; 6874 : 	gObj[aIndex].m_bPCBangCouponUser = bPCBangUser;
; 6875 : 
; 6876 : 	#if defined(PCBANG_ADVANTAGE_EXPAND_20060919) && defined(FOR_KOREA)
; 6877 : 		//  PC   .
; 6878 : 		g_iApplyPCBangAdvantage = 0;
; 6879 : 	#endif 
; 6880 : 
; 6881 : 	if( gObj[aIndex].m_bPCBangCouponUser )
; 6882 : 	{
; 6883 : 		LogAdd("[Coupon Event][PCBang User Connect] [%s][%s] - %s",
; 6884 : 			gObj[aIndex].AccountID, gObj[aIndex].Name, gObj[aIndex].Ip_addr);
; 6885 : 	}
; 6886 : #endif
; 6887 : 
; 6888 : #ifdef PCBANG_EVENT_FREE_CHAOSCASTLE_20060307
; 6889 : 	gObj[aIndex].m_bPCBangFreeChaosCastleUser	= bPCBangUser;
; 6890 : 	if( gObj[aIndex].m_bPCBangFreeChaosCastleUser )
; 6891 : 	{
; 6892 : 		LogAdd( "[FREE CHAOSCASTLE EVENT][PCBang User Connect] [%s] - %s",
; 6893 : 			gObj[aIndex].AccountID, gObj[aIndex].Ip_addr );
; 6894 : 	}
; 6895 : #endif
; 6896 : 
; 6897 : #ifdef PCBANG_POINT_SYSTEM_20070206		// PC  
; 6898 : 	g_PCBangPointSystem.SetPCBangPointUser( aIndex, bPCBangUser );
; 6899 : #endif
; 6900 : 
; 6901 : #ifdef MODIFY_CASTLE_MAP_MOVE_TRACE_LOG_20080418
; 6902 : 	LogAddTD("[BUGTRACE][gObjSetAccountLogin] (%d), Id : %s, Name : %s Login Success",
; 6903 : 		aIndex, gObj[aIndex].AccountID, gObj[aIndex].Name );
; 6904 : #endif // MODIFY_CASTLE_MAP_MOVE_TRACE_LOG_20080418
; 6905 : 
; 6906 : 	return TRUE;

  00162	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjSetAcc:

; 6907 : }

  00167	5f		 pop	 edi
  00168	5e		 pop	 esi
  00169	5b		 pop	 ebx
  0016a	8b e5		 mov	 esp, ebp
  0016c	5d		 pop	 ebp
  0016d	c3		 ret	 0
?gObjSetAccountLogin@@YAHHPADHH0@Z ENDP			; gObjSetAccountLogin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjTimeCheckSelfDefense@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_n$1 = -72						; size = 4
_szTemp$ = -68						; size = 61
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjTimeCheckSelfDefense@@YAXPAVOBJECTSTRUCT@@@Z PROC	; gObjTimeCheckSelfDefense, COMDAT

; 12553: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 12554: 	char szTemp[MAX_CHAT+1];
; 12555: 
; 12556: 	for( int n=0; n<MAXSELFDEFENSE; n++)

  00016	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0001d	eb 09		 jmp	 SHORT $LN4@gObjTimeCh
$LN2@gObjTimeCh:
  0001f	8b 45 b8	 mov	 eax, DWORD PTR _n$1[ebp]
  00022	83 c0 01	 add	 eax, 1
  00025	89 45 b8	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjTimeCh:
  00028	83 7d b8 07	 cmp	 DWORD PTR _n$1[ebp], 7
  0002c	0f 8d eb 00 00
	00		 jge	 $LN1@gObjTimeCh

; 12557: 	{
; 12558: 		if( lpObj->SelfDefense[n] >= 0 )

  00032	8b 45 b8	 mov	 eax, DWORD PTR _n$1[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00038	83 bc 81 40 02
	00 00 00	 cmp	 DWORD PTR [ecx+eax*4+576], 0
  00040	0f 8c d2 00 00
	00		 jl	 $LN5@gObjTimeCh

; 12559: 		{
; 12560: 			if( GetTickCount() > lpObj->SelfDefenseTime[n] )

  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0004c	8b 4d b8	 mov	 ecx, DWORD PTR _n$1[ebp]
  0004f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00052	3b 84 8a 5c 02
	00 00		 cmp	 eax, DWORD PTR [edx+ecx*4+604]
  00059	0f 86 b9 00 00
	00		 jbe	 $LN5@gObjTimeCh

; 12561: 			{
; 12562: 				wsprintf(szTemp, lMsg.Get(1115), lpObj->Name);

  0005f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00062	83 c0 73	 add	 eax, 115		; 00000073H
  00065	50		 push	 eax
  00066	68 5b 04 00 00	 push	 1115			; 0000045bH
  0006b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00076	50		 push	 eax
  00077	8d 4d bc	 lea	 ecx, DWORD PTR _szTemp$[ebp]
  0007a	51		 push	 ecx
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12563: 				GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  00084	6a 01		 push	 1
  00086	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	51		 push	 ecx
  0008c	8d 55 bc	 lea	 edx, DWORD PTR _szTemp$[ebp]
  0008f	52		 push	 edx
  00090	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12564: 				GCServerMsgStringSend(szTemp, lpObj->SelfDefense[n], 1);

  00098	6a 01		 push	 1
  0009a	8b 45 b8	 mov	 eax, DWORD PTR _n$1[ebp]
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a0	8b 94 81 40 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax*4+576]
  000a7	52		 push	 edx
  000a8	8d 45 bc	 lea	 eax, DWORD PTR _szTemp$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 12565: 
; 12566: 				LogAddTD("[%s][%s] ReSet SelfDefence [%s][%s]", 

  000b4	8b 45 b8	 mov	 eax, DWORD PTR _n$1[ebp]
  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ba	69 94 81 40 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax*4+576], 7072
  000c5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ca	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  000ce	51		 push	 ecx
  000cf	8b 55 b8	 mov	 edx, DWORD PTR _n$1[ebp]
  000d2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d5	69 8c 90 40 02
	00 00 a0 1b 00
	00		 imul	 ecx, DWORD PTR [eax+edx*4+576], 7072
  000e0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e6	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  000ea	50		 push	 eax
  000eb	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ee	83 c1 73	 add	 ecx, 115		; 00000073H
  000f1	51		 push	 ecx
  000f2	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000f5	83 c2 68	 add	 edx, 104		; 00000068H
  000f8	52		 push	 edx
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@HGMOIFIK@?$FL?$CFs?$FN?$FL?$CFs?$FN?5ReSet?5SelfDefence?5?$FL?$CFs?$FN@
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00104	83 c4 14	 add	 esp, 20			; 00000014H

; 12567: 						 lpObj->AccountID, lpObj->Name, 
; 12568: 						 gObj[lpObj->SelfDefense[n]].AccountID, gObj[lpObj->SelfDefense[n]].Name);
; 12569: 
; 12570: 				lpObj->SelfDefense[n] = -1;

  00107	8b 45 b8	 mov	 eax, DWORD PTR _n$1[ebp]
  0010a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0010d	c7 84 81 40 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax*4+576], -1
$LN5@gObjTimeCh:

; 12571: 			}
; 12572: 		}
; 12573: 	}

  00118	e9 02 ff ff ff	 jmp	 $LN2@gObjTimeCh
$LN1@gObjTimeCh:

; 12574: }

  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx
  00120	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00123	33 cd		 xor	 ecx, ebp
  00125	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
?gObjTimeCheckSelfDefense@@YAXPAVOBJECTSTRUCT@@@Z ENDP	; gObjTimeCheckSelfDefense
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCheckXYMapTile@@YAHPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
tv76 = -124						; size = 4
tv77 = -120						; size = 4
_pMsg$1 = -52						; size = 6
_attr4$2 = -41						; size = 1
_attr3$3 = -40						; size = 1
_attr2$4 = -39						; size = 1
_attr1$5 = -38						; size = 1
_attr$ = -37						; size = 1
_pMsg$6 = -36						; size = 6
_pMsg$7 = -28						; size = 6
_minlevel$8 = -20					; size = 4
_mapminlevel$ = -16					; size = 4
_mapnumber$ = -12					; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_iDbgName$ = 12						; size = 4
?gObjCheckXYMapTile@@YAHPAVOBJECTSTRUCT@@H@Z PROC	; gObjCheckXYMapTile, COMDAT

; 6645 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6646 : 	if( lpObj->Type != OBJTYPE_CHARACTER ) return FALSE;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00010	83 f9 01	 cmp	 ecx, 1
  00013	74 07		 je	 SHORT $LN2@gObjCheckX
  00015	33 c0		 xor	 eax, eax
  00017	e9 5f 03 00 00	 jmp	 $LN1@gObjCheckX
$LN2@gObjCheckX:

; 6647 : 
; 6648 : 	if( (lpObj->Authority&AUTHORITY_ADMIN) == AUTHORITY_ADMIN ) 

  0001c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001f	8b 88 a4 01 00
	00		 mov	 ecx, DWORD PTR [eax+420]
  00025	83 e1 02	 and	 ecx, 2
  00028	74 07		 je	 SHORT $LN3@gObjCheckX

; 6649 : 		return FALSE;

  0002a	33 c0		 xor	 eax, eax
  0002c	e9 4a 03 00 00	 jmp	 $LN1@gObjCheckX
$LN3@gObjCheckX:

; 6650 : 
; 6651 : #ifdef CHAOSCASTLE_SYSTEM_20040408		//         . (     .)
; 6652 : 	if (CHECK_CHAOSCASTLE(lpObj->MapNumber) && 

  00031	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00034	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0003b	83 f9 12	 cmp	 ecx, 18			; 00000012H
  0003e	7d 09		 jge	 SHORT $LN21@gObjCheckX
  00040	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
  00047	eb 25		 jmp	 SHORT $LN22@gObjCheckX
$LN21@gObjCheckX:
  00049	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0004c	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00053	83 f8 17	 cmp	 eax, 23			; 00000017H
  00056	7e 09		 jle	 SHORT $LN19@gObjCheckX
  00058	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
  0005f	eb 07		 jmp	 SHORT $LN20@gObjCheckX
$LN19@gObjCheckX:
  00061	c7 45 84 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
$LN20@gObjCheckX:
  00068	8b 4d 84	 mov	 ecx, DWORD PTR tv76[ebp]
  0006b	89 4d 88	 mov	 DWORD PTR tv77[ebp], ecx
$LN22@gObjCheckX:
  0006e	83 7d 88 00	 cmp	 DWORD PTR tv77[ebp], 0
  00072	74 24		 je	 SHORT $LN4@gObjCheckX
  00074	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00077	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0007e	83 e9 12	 sub	 ecx, 18			; 00000012H
  00081	51		 push	 ecx
  00082	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  00087	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState
  0008c	83 f8 02	 cmp	 eax, 2
  0008f	75 07		 jne	 SHORT $LN4@gObjCheckX

; 6653 : #ifdef ADD_CHAOSCASTLE_FOR_MASTER_LEVEL_20071010	//   
; 6654 : 		(g_ChaosCastle.GetCurrentState( g_ChaosCastle.GetChaosCastleByMapNum( lpObj->MapNumber ) ) == CHAOSCASTLE_STATE_PLAYING)
; 6655 : #else
; 6656 : 		(g_ChaosCastle.GetCurrentState(lpObj->MapNumber - MAP_INDEX_CHAOSCASTLE1) == CHAOSCASTLE_STATE_PLAYING)
; 6657 : #endif
; 6658 : 		)
; 6659 : 	{
; 6660 : 		return FALSE;

  00091	33 c0		 xor	 eax, eax
  00093	e9 e3 02 00 00	 jmp	 $LN1@gObjCheckX
$LN4@gObjCheckX:

; 6661 : 	}
; 6662 : #endif
; 6663 : 
; 6664 : 	if(lpObj->m_stateEngagePVP == PVP_USER_PLAYING)

  00098	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009b	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  000a2	75 07		 jne	 SHORT $LN5@gObjCheckX

; 6665 : 		return FALSE;

  000a4	33 c0		 xor	 eax, eax
  000a6	e9 d0 02 00 00	 jmp	 $LN1@gObjCheckX
$LN5@gObjCheckX:

; 6666 : 	
; 6667 : #if( SPEEDHACK_CHECK == 0 ) 
; 6668 : 		return FALSE;
; 6669 : #endif
; 6670 : 
; 6671 : #if (TESTSERVER == 1 )
; 6672 : 	#ifndef MODIFY_FORCEMOVE_TO_LORENCIA_20060515	// not define :  
; 6673 : 		return FALSE;
; 6674 : 	#endif
; 6675 : #endif
; 6676 : 
; 6677 : 	int x, y, mapnumber;
; 6678 : 	
; 6679 : 	x			= lpObj->X;

  000ab	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ae	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  000b5	89 4d fc	 mov	 DWORD PTR _x$[ebp], ecx

; 6680 : 	y			= lpObj->Y;

  000b8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bb	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  000c2	89 4d f8	 mov	 DWORD PTR _y$[ebp], ecx

; 6681 : 	mapnumber	= lpObj->MapNumber;

  000c5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c8	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000cf	89 4d f4	 mov	 DWORD PTR _mapnumber$[ebp], ecx

; 6682 : 	
; 6683 : 	if( mapnumber > g_TerrainManager.Size()-1 ) mapnumber = 0;

  000d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  000d7	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size
  000dc	83 e8 01	 sub	 eax, 1
  000df	39 45 f4	 cmp	 DWORD PTR _mapnumber$[ebp], eax
  000e2	7e 07		 jle	 SHORT $LN6@gObjCheckX
  000e4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _mapnumber$[ebp], 0
$LN6@gObjCheckX:

; 6684 : 
; 6685 : 	int mapminlevel=g_TerrainManager.GetMinLevel(mapnumber);

  000eb	8b 45 f4	 mov	 eax, DWORD PTR _mapnumber$[ebp]
  000ee	50		 push	 eax
  000ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  000f4	e8 00 00 00 00	 call	 ?GetMinLevel@CTerrainManager@@QAEHH@Z ; CTerrainManager::GetMinLevel
  000f9	89 45 f0	 mov	 DWORD PTR _mapminlevel$[ebp], eax

; 6686 : 
; 6687 : #ifdef MODIFY_CHECK_MOVELEVEL_20060731
; 6688 : 	//      0 .
; 6689 : 	// MapMinUserLevel  movereq.txt, gate.txt, MoveLevel.txt  
; 6690 : 	//    ,      
; 6691 : 	//         .
; 6692 : 	mapminlevel = 0;

  000fc	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _mapminlevel$[ebp], 0

; 6693 : #endif
; 6694 : 
; 6695 : #ifdef DARKLORD_WORK
; 6696 : 	if( lpObj->Class == CLASS_DARKLORD || lpObj->Class == CLASS_MAGUMSA )	

  00103	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00106	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0010d	83 f9 04	 cmp	 ecx, 4
  00110	74 0f		 je	 SHORT $LN8@gObjCheckX
  00112	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00115	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0011c	83 f9 03	 cmp	 ecx, 3
  0011f	75 32		 jne	 SHORT $LN7@gObjCheckX
$LN8@gObjCheckX:

; 6697 : #else
; 6698 : 	if( lpObj->Class == CLASS_MAGUMSA )	//  2/3 ..
; 6699 : #endif
; 6700 : 	{
; 6701 : 		if( mapminlevel > 0 )

  00121	83 7d f0 00	 cmp	 DWORD PTR _mapminlevel$[ebp], 0
  00125	7e 2c		 jle	 SHORT $LN7@gObjCheckX

; 6702 : 		{
; 6703 : 			int minlevel = g_TerrainManager.GetMinLevel(mapnumber);

  00127	8b 45 f4	 mov	 eax, DWORD PTR _mapnumber$[ebp]
  0012a	50		 push	 eax
  0012b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  00130	e8 00 00 00 00	 call	 ?GetMinLevel@CTerrainManager@@QAEHH@Z ; CTerrainManager::GetMinLevel
  00135	89 45 ec	 mov	 DWORD PTR _minlevel$8[ebp], eax

; 6704 : 			if( minlevel > 0 )

  00138	83 7d ec 00	 cmp	 DWORD PTR _minlevel$8[ebp], 0
  0013c	7e 15		 jle	 SHORT $LN7@gObjCheckX

; 6705 : 			{
; 6706 : 				mapminlevel = minlevel-((minlevel/3)*2);

  0013e	8b 45 ec	 mov	 eax, DWORD PTR _minlevel$8[ebp]
  00141	99		 cdq
  00142	b9 03 00 00 00	 mov	 ecx, 3
  00147	f7 f9		 idiv	 ecx
  00149	d1 e0		 shl	 eax, 1
  0014b	8b 55 ec	 mov	 edx, DWORD PTR _minlevel$8[ebp]
  0014e	2b d0		 sub	 edx, eax
  00150	89 55 f0	 mov	 DWORD PTR _mapminlevel$[ebp], edx
$LN7@gObjCheckX:

; 6707 : 			}
; 6708 : 		}
; 6709 : 	}
; 6710 : 	
; 6711 : 	//   6  ..
; 6712 : 	if( lpObj->Class == CLASS_ELF && lpObj->Level < 10 )	

  00153	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00156	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0015d	83 f9 02	 cmp	 ecx, 2
  00160	75 79		 jne	 SHORT $LN11@gObjCheckX
  00162	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00165	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0016c	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0016f	7d 6a		 jge	 SHORT $LN11@gObjCheckX

; 6713 : 	{
; 6714 : 		if( lpObj->MapNumber != 3 )

  00171	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00174	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0017b	83 f9 03	 cmp	 ecx, 3
  0017e	74 59		 je	 SHORT $LN13@gObjCheckX

; 6715 : 		{
; 6716 : 			PMSG_TELEPORT pMsg;
; 6717 : 			LogAddTD(lMsg.Get(517), lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y);

  00180	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00183	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0018a	51		 push	 ecx
  0018b	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0018e	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  00195	50		 push	 eax
  00196	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00199	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  001a0	52		 push	 edx
  001a1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a4	83 c0 73	 add	 eax, 115		; 00000073H
  001a7	50		 push	 eax
  001a8	68 05 02 00 00	 push	 517			; 00000205H
  001ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  001b8	50		 push	 eax
  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001bf	83 c4 14	 add	 esp, 20			; 00000014H

; 6718 : 			pMsg.MoveNumber = 27;

  001c2	c6 45 e7 1b	 mov	 BYTE PTR _pMsg$7[ebp+3], 27 ; 0000001bH

; 6719 : 			gObjMoveGate(lpObj->m_Index, pMsg.MoveNumber);

  001c6	0f b6 45 e7	 movzx	 eax, BYTE PTR _pMsg$7[ebp+3]
  001ca	50		 push	 eax
  001cb	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001ce	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d0	52		 push	 edx
  001d1	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  001d6	83 c4 08	 add	 esp, 8
$LN13@gObjCheckX:

; 6720 : 			//CGTeleportRecv(&pMsg, lpObj->m_Index);
; 6721 : 		}
; 6722 : 	}

  001d9	eb 68		 jmp	 SHORT $LN12@gObjCheckX
$LN11@gObjCheckX:

; 6723 : 	else if( mapminlevel > lpObj->Level ) //     .. .

  001db	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001de	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  001e5	39 4d f0	 cmp	 DWORD PTR _mapminlevel$[ebp], ecx
  001e8	7e 59		 jle	 SHORT $LN12@gObjCheckX

; 6724 : 	{			
; 6725 : 		//   6    .
; 6726 : 		//      6 ..  .
; 6727 : 			LogAddTD(lMsg.Get(517), lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y);

  001ea	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ed	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  001f4	51		 push	 ecx
  001f5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001f8	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  001ff	50		 push	 eax
  00200	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00203	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0020a	52		 push	 edx
  0020b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0020e	83 c0 73	 add	 eax, 115		; 00000073H
  00211	50		 push	 eax
  00212	68 05 02 00 00	 push	 517			; 00000205H
  00217	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00222	50		 push	 eax
  00223	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00229	83 c4 14	 add	 esp, 20			; 00000014H

; 6728 : 			PMSG_TELEPORT pMsg;
; 6729 : 			pMsg.MoveNumber = 17;

  0022c	c6 45 df 11	 mov	 BYTE PTR _pMsg$6[ebp+3], 17 ; 00000011H

; 6730 : 			gObjMoveGate(lpObj->m_Index, pMsg.MoveNumber);

  00230	0f b6 45 df	 movzx	 eax, BYTE PTR _pMsg$6[ebp+3]
  00234	50		 push	 eax
  00235	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00238	8b 11		 mov	 edx, DWORD PTR [ecx]
  0023a	52		 push	 edx
  0023b	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00240	83 c4 08	 add	 esp, 8
$LN12@gObjCheckX:

; 6731 : 
; 6732 : 			//CGTeleportRecv(&pMsg, lpObj->m_Index);
; 6733 : 	}
; 6734 : 	
; 6735 : 	BYTE attr =  MapC[mapnumber].GetAttr(x, y);

  00243	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00246	50		 push	 eax
  00247	8b 4d fc	 mov	 ecx, DWORD PTR _x$[ebp]
  0024a	51		 push	 ecx
  0024b	69 4d f4 8c 04
	05 00		 imul	 ecx, DWORD PTR _mapnumber$[ebp], 328844
  00252	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00258	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  0025d	88 45 db	 mov	 BYTE PTR _attr$[ebp], al

; 6736 : 
; 6737 : 	if( (attr&MAP_ATTR_BLOCK) == MAP_ATTR_BLOCK || 

  00260	0f b6 45 db	 movzx	 eax, BYTE PTR _attr$[ebp]
  00264	83 e0 04	 and	 eax, 4
  00267	75 0d		 jne	 SHORT $LN16@gObjCheckX
  00269	0f b6 45 db	 movzx	 eax, BYTE PTR _attr$[ebp]
  0026d	83 e0 08	 and	 eax, 8
  00270	0f 84 03 01 00
	00		 je	 $LN15@gObjCheckX
$LN16@gObjCheckX:

; 6738 : 		(attr&MAP_ATTR_HOLLOW) == MAP_ATTR_HOLLOW
; 6739 : 		)	//    .
; 6740 : 	{
; 6741 : 		BYTE attr1 = MapC[mapnumber].GetAttr(x+2, y);

  00276	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00279	50		 push	 eax
  0027a	8b 4d fc	 mov	 ecx, DWORD PTR _x$[ebp]
  0027d	83 c1 02	 add	 ecx, 2
  00280	51		 push	 ecx
  00281	69 4d f4 8c 04
	05 00		 imul	 ecx, DWORD PTR _mapnumber$[ebp], 328844
  00288	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0028e	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00293	88 45 da	 mov	 BYTE PTR _attr1$5[ebp], al

; 6742 : 		BYTE attr2 = MapC[mapnumber].GetAttr(  x, y+2);

  00296	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00299	83 c0 02	 add	 eax, 2
  0029c	50		 push	 eax
  0029d	8b 4d fc	 mov	 ecx, DWORD PTR _x$[ebp]
  002a0	51		 push	 ecx
  002a1	69 4d f4 8c 04
	05 00		 imul	 ecx, DWORD PTR _mapnumber$[ebp], 328844
  002a8	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  002ae	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  002b3	88 45 d9	 mov	 BYTE PTR _attr2$4[ebp], al

; 6743 : 		BYTE attr3 = MapC[mapnumber].GetAttr(x-2, y);

  002b6	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  002b9	50		 push	 eax
  002ba	8b 4d fc	 mov	 ecx, DWORD PTR _x$[ebp]
  002bd	83 e9 02	 sub	 ecx, 2
  002c0	51		 push	 ecx
  002c1	69 4d f4 8c 04
	05 00		 imul	 ecx, DWORD PTR _mapnumber$[ebp], 328844
  002c8	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  002ce	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  002d3	88 45 d8	 mov	 BYTE PTR _attr3$3[ebp], al

; 6744 : 		BYTE attr4 = MapC[mapnumber].GetAttr(  x, y-2);

  002d6	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  002d9	83 e8 02	 sub	 eax, 2
  002dc	50		 push	 eax
  002dd	8b 4d fc	 mov	 ecx, DWORD PTR _x$[ebp]
  002e0	51		 push	 ecx
  002e1	69 4d f4 8c 04
	05 00		 imul	 ecx, DWORD PTR _mapnumber$[ebp], 328844
  002e8	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  002ee	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  002f3	88 45 d7	 mov	 BYTE PTR _attr4$2[ebp], al

; 6745 : 		
; 6746 : 		if( (attr1>MAP_ATTR_SAFTYZONE) && (attr2>MAP_ATTR_SAFTYZONE) &&
; 6747 : 			(attr3>MAP_ATTR_SAFTYZONE) && (attr4>MAP_ATTR_SAFTYZONE) )

  002f6	0f b6 45 da	 movzx	 eax, BYTE PTR _attr1$5[ebp]
  002fa	83 f8 01	 cmp	 eax, 1
  002fd	7e 7a		 jle	 SHORT $LN15@gObjCheckX
  002ff	0f b6 45 d9	 movzx	 eax, BYTE PTR _attr2$4[ebp]
  00303	83 f8 01	 cmp	 eax, 1
  00306	7e 71		 jle	 SHORT $LN15@gObjCheckX
  00308	0f b6 45 d8	 movzx	 eax, BYTE PTR _attr3$3[ebp]
  0030c	83 f8 01	 cmp	 eax, 1
  0030f	7e 68		 jle	 SHORT $LN15@gObjCheckX
  00311	0f b6 45 d7	 movzx	 eax, BYTE PTR _attr4$2[ebp]
  00315	83 f8 01	 cmp	 eax, 1
  00318	7e 5f		 jle	 SHORT $LN15@gObjCheckX

; 6748 : 		{
; 6749 : 
; 6750 : #ifdef ADD_LOG_CHECK_INVLIDE_X_Y_POSITION_20060131
; 6751 : 			LogAddTD("[ CHECK POSITION ] DbgName[%d] [%s][%s] Map[%d]-(%d,%d) Invalid location causes to force to move", 

  0031a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0031d	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00324	51		 push	 ecx
  00325	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00328	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  0032f	50		 push	 eax
  00330	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00333	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0033a	52		 push	 edx
  0033b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0033e	83 c0 73	 add	 eax, 115		; 00000073H
  00341	50		 push	 eax
  00342	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00345	83 c1 68	 add	 ecx, 104		; 00000068H
  00348	51		 push	 ecx
  00349	8b 55 0c	 mov	 edx, DWORD PTR _iDbgName$[ebp]
  0034c	52		 push	 edx
  0034d	68 00 00 00 00	 push	 OFFSET ??_C@_0GB@MEEFOHBG@?$FL?5CHECK?5POSITION?5?$FN?5DbgName?$FL?$CFd?$FN?5@
  00352	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00358	83 c4 1c	 add	 esp, 28			; 0000001cH

; 6752 : 					iDbgName, lpObj->AccountID, 
; 6753 : 					lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y );
; 6754 : #else
; 6755 : 			LogAddTD(lMsg.Get(517), lpObj->Name, lpObj->MapNumber, lpObj->X, lpObj->Y);
; 6756 : #endif
; 6757 : 			
; 6758 : #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_6_200708013		//        
; 6759 : 			if(CHECK_ILLUSION_TEMPLE(lpObj->MapNumber) 
; 6760 : 				&& g_IllusionTempleEvent.GetIllusionTempleState(lpObj->MapNumber) == ILLUSION_TEMPLE_STATE_PLAYING)
; 6761 : 			{
; 6762 : 				BYTE btTeam = g_IllusionTempleEvent.GetUserTeam(lpObj->MapNumber, lpObj->m_Index);
; 6763 : 				PMSG_TELEPORT pMsg;
; 6764 : 				if( btTeam == 0xFF)
; 6765 : 				{
; 6766 : 					pMsg.MoveNumber = 17;	//   
; 6767 : 				}
; 6768 : 				else
; 6769 : 				{
; 6770 : 					if(btTeam == TEAM_ALLIED)
; 6771 : 					{	
; 6772 : 						pMsg.MoveNumber = GATE_ILLUSION_TEMPLE_ALLIED1 + (lpObj->MapNumber - MAP_INDEX_ILLUSION_TEMPLE1);
; 6773 : 					}
; 6774 : 					else if(btTeam == TEAM_ILLUSION)
; 6775 : 					{
; 6776 : 						pMsg.MoveNumber = GATE_ILLUSION_TEMPLE_ILLUSION1 + (lpObj->MapNumber - MAP_INDEX_ILLUSION_TEMPLE1);
; 6777 : 					}
; 6778 : 					else
; 6779 : 					{
; 6780 : 						pMsg.MoveNumber = 17;	//   
; 6781 : 					}
; 6782 : 				}
; 6783 : 				
; 6784 : 				gObjMoveGate(lpObj->m_Index, pMsg.MoveNumber);
; 6785 : 
; 6786 : 				return TRUE;
; 6787 : 			}
; 6788 : #endif	// MODIFY_ILLUSIONTEMPLE_BUGFIX_6_200708013
; 6789 : 
; 6790 : 			{
; 6791 : 			PMSG_TELEPORT pMsg;
; 6792 : 			pMsg.MoveNumber = 17;

  0035b	c6 45 cf 11	 mov	 BYTE PTR _pMsg$1[ebp+3], 17 ; 00000011H

; 6793 : 			
; 6794 : 			gObjMoveGate(lpObj->m_Index, pMsg.MoveNumber);

  0035f	0f b6 45 cf	 movzx	 eax, BYTE PTR _pMsg$1[ebp+3]
  00363	50		 push	 eax
  00364	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00367	8b 11		 mov	 edx, DWORD PTR [ecx]
  00369	52		 push	 edx
  0036a	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0036f	83 c4 08	 add	 esp, 8

; 6795 : 
; 6796 : 			//CGTeleportRecv(&pMsg, lpObj->m_Index);
; 6797 : 			}
; 6798 : 			return TRUE;

  00372	b8 01 00 00 00	 mov	 eax, 1
  00377	eb 02		 jmp	 SHORT $LN1@gObjCheckX
$LN15@gObjCheckX:

; 6799 : 		}
; 6800 : 	}
; 6801 : 	return FALSE;

  00379	33 c0		 xor	 eax, eax
$LN1@gObjCheckX:

; 6802 : }

  0037b	5f		 pop	 edi
  0037c	5e		 pop	 esi
  0037d	5b		 pop	 ebx
  0037e	8b e5		 mov	 esp, ebp
  00380	5d		 pop	 ebp
  00381	c3		 ret	 0
?gObjCheckXYMapTile@@YAHPAVOBJECTSTRUCT@@H@Z ENDP	; gObjCheckXYMapTile
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjIsGamePlaing@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjIsGamePlaing@@YAHPAVOBJECTSTRUCT@@@Z PROC		; gObjIsGamePlaing, COMDAT

; 6437 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6438 : 	if( lpObj->Connected < CSS_GAMEPLAYING ) return FALSE;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00010	7d 04		 jge	 SHORT $LN2@gObjIsGame
  00012	33 c0		 xor	 eax, eax
  00014	eb 05		 jmp	 SHORT $LN1@gObjIsGame
$LN2@gObjIsGame:

; 6439 : 	return TRUE;

  00016	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjIsGame:

; 6440 : }

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?gObjIsGamePlaing@@YAHPAVOBJECTSTRUCT@@@Z ENDP		; gObjIsGamePlaing
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjIsAccontConnect@@YAHHPAD@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
_accountid$ = 12					; size = 4
?gObjIsAccontConnect@@YAHHPAD@Z PROC			; gObjIsAccontConnect, COMDAT

; 6513 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6514 : 	if( aIndex < 0 || aIndex > MAX_OBJECT-1 ) return FALSE;

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@gObjIsAcco
  0000f	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00016	7e 04		 jle	 SHORT $LN2@gObjIsAcco
$LN3@gObjIsAcco:
  00018	33 c0		 xor	 eax, eax
  0001a	eb 66		 jmp	 SHORT $LN1@gObjIsAcco
$LN2@gObjIsAcco:

; 6515 : 	if( gObj[aIndex].Connected < 1 ) return FALSE;

  0001c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00023	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00029	83 7c 01 04 01	 cmp	 DWORD PTR [ecx+eax+4], 1
  0002e	7d 04		 jge	 SHORT $LN4@gObjIsAcco
  00030	33 c0		 xor	 eax, eax
  00032	eb 4e		 jmp	 SHORT $LN1@gObjIsAcco
$LN4@gObjIsAcco:

; 6516 : 	if( strlen( gObj[aIndex].AccountID ) < 1 ) return FALSE;

  00034	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00041	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 _strlen
  0004b	83 c4 04	 add	 esp, 4
  0004e	83 f8 01	 cmp	 eax, 1
  00051	73 04		 jae	 SHORT $LN5@gObjIsAcco
  00053	33 c0		 xor	 eax, eax
  00055	eb 2b		 jmp	 SHORT $LN1@gObjIsAcco
$LN5@gObjIsAcco:

; 6517 : 	if( strcmp(accountid, gObj[aIndex].AccountID) != 0 ) return FALSE;

  00057	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00064	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00068	52		 push	 edx
  00069	8b 45 0c	 mov	 eax, DWORD PTR _accountid$[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 _strcmp
  00072	83 c4 08	 add	 esp, 8
  00075	85 c0		 test	 eax, eax
  00077	74 04		 je	 SHORT $LN6@gObjIsAcco
  00079	33 c0		 xor	 eax, eax
  0007b	eb 05		 jmp	 SHORT $LN1@gObjIsAcco
$LN6@gObjIsAcco:

; 6518 : 	return TRUE;

  0007d	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjIsAcco:

; 6519 : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?gObjIsAccontConnect@@YAHHPAD@Z ENDP			; gObjIsAccontConnect
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjIsConnected@@YAHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjIsConnected@@YAHH@Z PROC				; gObjIsConnected, COMDAT

; 6482 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6483 : 	if( aIndex < 0 || aIndex > MAX_OBJECT-1 ) return FALSE;

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@gObjIsConn
  0000f	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00016	7e 04		 jle	 SHORT $LN2@gObjIsConn
$LN3@gObjIsConn:
  00018	33 c0		 xor	 eax, eax
  0001a	eb 1d		 jmp	 SHORT $LN1@gObjIsConn
$LN2@gObjIsConn:

; 6484 : 	if( gObj[aIndex].Connected < CSS_GAMEPLAYING ) return FALSE;

  0001c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00023	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00029	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  0002e	7d 04		 jge	 SHORT $LN4@gObjIsConn
  00030	33 c0		 xor	 eax, eax
  00032	eb 05		 jmp	 SHORT $LN1@gObjIsConn
$LN4@gObjIsConn:

; 6485 : 	return TRUE;

  00034	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjIsConn:

; 6486 : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?gObjIsConnected@@YAHH@Z ENDP				; gObjIsConnected
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_dbnumber$ = 12						; size = 4
?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@H@Z PROC		; gObjIsConnected, COMDAT

; 6491 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6492 : 	if( lpObj->Connected < CSS_GAMEPLAYING ) return FALSE;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00010	7d 04		 jge	 SHORT $LN2@gObjIsConn
  00012	33 c0		 xor	 eax, eax
  00014	eb 14		 jmp	 SHORT $LN1@gObjIsConn
$LN2@gObjIsConn:

; 6493 : 	if( lpObj->DBNumber != dbnumber ) return FALSE;

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00019	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0001c	3b 4d 0c	 cmp	 ecx, DWORD PTR _dbnumber$[ebp]
  0001f	74 04		 je	 SHORT $LN3@gObjIsConn
  00021	33 c0		 xor	 eax, eax
  00023	eb 05		 jmp	 SHORT $LN1@gObjIsConn
$LN3@gObjIsConn:

; 6494 : 	return TRUE;

  00025	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjIsConn:

; 6495 : }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@H@Z ENDP		; gObjIsConnected
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@@Z PROC		; gObjIsConnected, COMDAT

; 6472 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6473 : 	if( lpObj->Type != OBJTYPE_CHARACTER ) return FALSE;

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00010	83 f9 01	 cmp	 ecx, 1
  00013	74 04		 je	 SHORT $LN2@gObjIsConn
  00015	33 c0		 xor	 eax, eax
  00017	eb 21		 jmp	 SHORT $LN1@gObjIsConn
$LN2@gObjIsConn:

; 6474 : 	if( lpObj->Connected < CSS_GAMEPLAYING ) return FALSE;

  00019	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00020	7d 04		 jge	 SHORT $LN3@gObjIsConn
  00022	33 c0		 xor	 eax, eax
  00024	eb 14		 jmp	 SHORT $LN1@gObjIsConn
$LN3@gObjIsConn:

; 6475 : 	if( lpObj->CloseCount > 0 ) return FALSE;

  00026	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00029	0f be 48 0a	 movsx	 ecx, BYTE PTR [eax+10]
  0002d	85 c9		 test	 ecx, ecx
  0002f	7e 04		 jle	 SHORT $LN4@gObjIsConn
  00031	33 c0		 xor	 eax, eax
  00033	eb 05		 jmp	 SHORT $LN1@gObjIsConn
$LN4@gObjIsConn:

; 6476 : 	return TRUE;

  00035	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjIsConn:

; 6477 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?gObjIsConnected@@YAHPAVOBJECTSTRUCT@@@Z ENDP		; gObjIsConnected
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjIsConnectedGP@@YAHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjIsConnectedGP@@YAHH@Z PROC				; gObjIsConnectedGP, COMDAT

; 6445 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6446 : 	if( aIndex < 0 || aIndex > MAX_OBJECT-1 )	 return FALSE;

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@gObjIsConn
  0000f	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00016	7e 04		 jle	 SHORT $LN2@gObjIsConn
$LN3@gObjIsConn:
  00018	33 c0		 xor	 eax, eax
  0001a	eb 52		 jmp	 SHORT $LN1@gObjIsConn
$LN2@gObjIsConn:

; 6447 : 	if( gObj[aIndex].Type != OBJTYPE_CHARACTER ) return FALSE;

  0001c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00023	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00029	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  0002e	83 fa 01	 cmp	 edx, 1
  00031	74 04		 je	 SHORT $LN4@gObjIsConn
  00033	33 c0		 xor	 eax, eax
  00035	eb 37		 jmp	 SHORT $LN1@gObjIsConn
$LN4@gObjIsConn:

; 6448 : 	if( gObj[aIndex].Connected < CSS_GAMEPLAYING ) return FALSE;

  00037	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00044	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00049	7d 04		 jge	 SHORT $LN5@gObjIsConn
  0004b	33 c0		 xor	 eax, eax
  0004d	eb 1f		 jmp	 SHORT $LN1@gObjIsConn
$LN5@gObjIsConn:

; 6449 : 	if( gObj[aIndex].CloseCount > 0 ) return FALSE;

  0004f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005c	0f be 54 01 0a	 movsx	 edx, BYTE PTR [ecx+eax+10]
  00061	85 d2		 test	 edx, edx
  00063	7e 04		 jle	 SHORT $LN6@gObjIsConn
  00065	33 c0		 xor	 eax, eax
  00067	eb 05		 jmp	 SHORT $LN1@gObjIsConn
$LN6@gObjIsConn:

; 6450 : 	return TRUE;

  00069	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjIsConn:

; 6451 : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?gObjIsConnectedGP@@YAHH@Z ENDP				; gObjIsConnectedGP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjUserIdConnectCheck@@YAHPADH@Z
_TEXT	SEGMENT
_szId$ = 8						; size = 4
_index$ = 12						; size = 4
?gObjUserIdConnectCheck@@YAHPADH@Z PROC			; gObjUserIdConnectCheck, COMDAT

; 6978 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6979 : 	if( index < 0 || index > MAX_OBJECT ) {

  00009	83 7d 0c 00	 cmp	 DWORD PTR _index$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@gObjUserId
  0000f	81 7d 0c e8 1c
	00 00		 cmp	 DWORD PTR _index$[ebp], 7400 ; 00001ce8H
  00016	7e 20		 jle	 SHORT $LN2@gObjUserId
$LN3@gObjUserId:

; 6980 : 		LogAdd("error : index error !! %s %d", __FILE__, __LINE__);

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjUserIdConnectCheck@@YAHPADH@Z@4JA
  0001d	83 c0 02	 add	 eax, 2
  00020	50		 push	 eax
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@NCIMKKEA@error?5?3?5index?5error?5?$CB?$CB?5?$CFs?5?$CFd@
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6981 : 		return FALSE;

  00034	33 c0		 xor	 eax, eax
  00036	eb 74		 jmp	 SHORT $LN1@gObjUserId
$LN2@gObjUserId:

; 6982 : 	}
; 6983 : 
; 6984 : 	if( gObj[index].Connected < CSS_GAMEPLAYING ) return FALSE;

  00038	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00045	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  0004a	7d 04		 jge	 SHORT $LN4@gObjUserId
  0004c	33 c0		 xor	 eax, eax
  0004e	eb 5c		 jmp	 SHORT $LN1@gObjUserId
$LN4@gObjUserId:

; 6985 : 	if( gObj[index].Name[0] != szId[0] )		return FALSE;

  00050	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  00057	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005d	b9 01 00 00 00	 mov	 ecx, 1
  00062	6b d1 00	 imul	 edx, ecx, 0
  00065	0f be 44 10 73	 movsx	 eax, BYTE PTR [eax+edx+115]
  0006a	b9 01 00 00 00	 mov	 ecx, 1
  0006f	6b d1 00	 imul	 edx, ecx, 0
  00072	8b 4d 08	 mov	 ecx, DWORD PTR _szId$[ebp]
  00075	0f be 14 11	 movsx	 edx, BYTE PTR [ecx+edx]
  00079	3b c2		 cmp	 eax, edx
  0007b	74 04		 je	 SHORT $LN5@gObjUserId
  0007d	33 c0		 xor	 eax, eax
  0007f	eb 2b		 jmp	 SHORT $LN1@gObjUserId
$LN5@gObjUserId:

; 6986 : 	if( strcmp(gObj[index].Name, szId) == 0 )	return TRUE;

  00081	8b 45 08	 mov	 eax, DWORD PTR _szId$[ebp]
  00084	50		 push	 eax
  00085	69 4d 0c a0 1b
	00 00		 imul	 ecx, DWORD PTR _index$[ebp], 7072
  0008c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00092	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 _strcmp
  0009c	83 c4 08	 add	 esp, 8
  0009f	85 c0		 test	 eax, eax
  000a1	75 07		 jne	 SHORT $LN6@gObjUserId
  000a3	b8 01 00 00 00	 mov	 eax, 1
  000a8	eb 02		 jmp	 SHORT $LN1@gObjUserId
$LN6@gObjUserId:

; 6987 : 	
; 6988 : 	return FALSE;

  000aa	33 c0		 xor	 eax, eax
$LN1@gObjUserId:

; 6989 : }

  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?gObjUserIdConnectCheck@@YAHPADH@Z ENDP			; gObjUserIdConnectCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGetIndex@@YAHPAD@Z
_TEXT	SEGMENT
_n$1 = -4						; size = 4
_szId$ = 8						; size = 4
?gObjGetIndex@@YAHPAD@Z PROC				; gObjGetIndex, COMDAT

; 6959 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6960 : 	for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  00009	c7 45 fc 00 19
	00 00		 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  00010	eb 09		 jmp	 SHORT $LN4@gObjGetInd
$LN2@gObjGetInd:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjGetInd:
  0001b	81 7d fc e8 1c
	00 00		 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  00022	7d 6a		 jge	 SHORT $LN3@gObjGetInd

; 6961 : 	{
; 6962 : 		if( gObj[n].Connected >= CSS_GAMEPLAYING )

  00024	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00031	83 7c 01 04 03	 cmp	 DWORD PTR [ecx+eax+4], 3
  00036	7c 54		 jl	 SHORT $LN5@gObjGetInd

; 6963 : 		{
; 6964 : 			if( gObj[n].Name[0] == szId[0] )

  00038	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0003f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00045	b9 01 00 00 00	 mov	 ecx, 1
  0004a	6b d1 00	 imul	 edx, ecx, 0
  0004d	0f be 44 10 73	 movsx	 eax, BYTE PTR [eax+edx+115]
  00052	b9 01 00 00 00	 mov	 ecx, 1
  00057	6b d1 00	 imul	 edx, ecx, 0
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _szId$[ebp]
  0005d	0f be 14 11	 movsx	 edx, BYTE PTR [ecx+edx]
  00061	3b c2		 cmp	 eax, edx
  00063	75 27		 jne	 SHORT $LN5@gObjGetInd

; 6965 : 			{
; 6966 : 				if( strcmp(gObj[n].Name, szId) == 0 )

  00065	8b 45 08	 mov	 eax, DWORD PTR _szId$[ebp]
  00068	50		 push	 eax
  00069	69 4d fc a0 1b
	00 00		 imul	 ecx, DWORD PTR _n$1[ebp], 7072
  00070	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00076	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _strcmp
  00080	83 c4 08	 add	 esp, 8
  00083	85 c0		 test	 eax, eax
  00085	75 05		 jne	 SHORT $LN5@gObjGetInd

; 6967 : 				{
; 6968 : 					return n;

  00087	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  0008a	eb 05		 jmp	 SHORT $LN1@gObjGetInd
$LN5@gObjGetInd:

; 6969 : 				}
; 6970 : 			}
; 6971 : 		}
; 6972 : 	}

  0008c	eb 84		 jmp	 SHORT $LN2@gObjGetInd
$LN3@gObjGetInd:

; 6973 : 	return -1;

  0008e	83 c8 ff	 or	 eax, -1
$LN1@gObjGetInd:

; 6974 : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
?gObjGetIndex@@YAHPAD@Z ENDP				; gObjGetIndex
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGetAccountId@@YAPADH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?gObjGetAccountId@@YAPADH@Z PROC			; gObjGetAccountId, COMDAT

; 6941 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6942 : 	if( aIndex < 0 || aIndex > MAX_OBJECT-1 )

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@gObjGetAcc
  0000f	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  00016	7e 20		 jle	 SHORT $LN2@gObjGetAcc
$LN3@gObjGetAcc:

; 6943 : 	{
; 6944 : 		LogAdd("error : %s %d",__FILE__, __LINE__);

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjGetAccountId@@YAPADH@Z@4JA
  0001d	83 c0 03	 add	 eax, 3
  00020	50		 push	 eax
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6945 : 		return NULL;

  00034	33 c0		 xor	 eax, eax
  00036	eb 29		 jmp	 SHORT $LN1@gObjGetAcc
$LN2@gObjGetAcc:

; 6946 : 	}
; 6947 : 	if( gObj[aIndex].Connected == CSS_LOGINOK ) //     .

  00038	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00045	83 7c 01 04 02	 cmp	 DWORD PTR [ecx+eax+4], 2
  0004a	75 13		 jne	 SHORT $LN4@gObjGetAcc

; 6948 : 	{
; 6949 : 		return gObj[aIndex].AccountID;

  0004c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00059	8d 44 01 68	 lea	 eax, DWORD PTR [ecx+eax+104]
  0005d	eb 02		 jmp	 SHORT $LN1@gObjGetAcc
$LN4@gObjGetAcc:

; 6950 : 	}
; 6951 : 	return NULL;

  0005f	33 c0		 xor	 eax, eax
$LN1@gObjGetAcc:

; 6952 : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?gObjGetAccountId@@YAPADH@Z ENDP			; gObjGetAccountId
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?CheckInventoryEmptySpace@@YAHPAVOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
_blank$ = -9						; size = 1
_w$ = -8						; size = 4
_h$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_iItemHeight$ = 12					; size = 4
_iItemWidth$ = 16					; size = 4
?CheckInventoryEmptySpace@@YAHPAVOBJECTSTRUCT@@HH@Z PROC ; CheckInventoryEmptySpace, COMDAT

; 15712: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15713: 	int h = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _h$[ebp], 0

; 15714: 	int w = 0;

  00010	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _w$[ebp], 0

; 15715: 	BYTE blank = 0;

  00017	c6 45 f7 00	 mov	 BYTE PTR _blank$[ebp], 0

; 15716: 
; 15717: 	for( h=0; h<8; h++)

  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _h$[ebp], 0
  00022	eb 09		 jmp	 SHORT $LN4@CheckInven
$LN2@CheckInven:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  00027	83 c0 01	 add	 eax, 1
  0002a	89 45 fc	 mov	 DWORD PTR _h$[ebp], eax
$LN4@CheckInven:
  0002d	83 7d fc 08	 cmp	 DWORD PTR _h$[ebp], 8
  00031	7d 7f		 jge	 SHORT $LN3@CheckInven

; 15718: 	{		
; 15719: 		for( w=0; w<8; w++)	

  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _w$[ebp], 0
  0003a	eb 09		 jmp	 SHORT $LN7@CheckInven
$LN5@CheckInven:
  0003c	8b 45 f8	 mov	 eax, DWORD PTR _w$[ebp]
  0003f	83 c0 01	 add	 eax, 1
  00042	89 45 f8	 mov	 DWORD PTR _w$[ebp], eax
$LN7@CheckInven:
  00045	83 7d f8 08	 cmp	 DWORD PTR _w$[ebp], 8
  00049	7d 62		 jge	 SHORT $LN6@CheckInven

; 15720: 		{
; 15721: 			//  
; 15722: 			if( *(lpObj->pInventoryMap+(h*8)+w) == 0xFF )

  0004b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004e	8b 88 60 0c 00
	00		 mov	 ecx, DWORD PTR [eax+3168]
  00054	8b 55 fc	 mov	 edx, DWORD PTR _h$[ebp]
  00057	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _w$[ebp]
  0005d	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  00061	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  00067	75 42		 jne	 SHORT $LN8@CheckInven

; 15723: 			{
; 15724: #ifdef PERSONAL_SHOP_20040113
; 15725: 				blank = gObjOnlyInventoryRectCheck( lpObj->m_Index, w, h, iItemWidth, iItemHeight);

  00069	8b 45 0c	 mov	 eax, DWORD PTR _iItemHeight$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d 10	 mov	 ecx, DWORD PTR _iItemWidth$[ebp]
  00070	51		 push	 ecx
  00071	8b 55 fc	 mov	 edx, DWORD PTR _h$[ebp]
  00074	52		 push	 edx
  00075	8b 45 f8	 mov	 eax, DWORD PTR _w$[ebp]
  00078	50		 push	 eax
  00079	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0007c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007e	52		 push	 edx
  0007f	e8 00 00 00 00	 call	 ?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z ; gObjOnlyInventoryRectCheck
  00084	83 c4 14	 add	 esp, 20			; 00000014H
  00087	88 45 f7	 mov	 BYTE PTR _blank$[ebp], al

; 15726: #else
; 15727: 				blank = gObjInventoryRectCheck( lpObj->m_Index, w, h, iItemWidth, iItemHeight);
; 15728: #endif
; 15729: 
; 15730: 				if( blank == 0xFE )

  0008a	0f b6 45 f7	 movzx	 eax, BYTE PTR _blank$[ebp]
  0008e	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  00093	75 04		 jne	 SHORT $LN9@CheckInven

; 15731: 				{
; 15732: 					return FALSE;

  00095	33 c0		 xor	 eax, eax
  00097	eb 1b		 jmp	 SHORT $LN1@CheckInven
$LN9@CheckInven:

; 15733: 				}
; 15734: 
; 15735: 				if( blank != 0xFF )	//   

  00099	0f b6 45 f7	 movzx	 eax, BYTE PTR _blank$[ebp]
  0009d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000a2	74 07		 je	 SHORT $LN8@CheckInven

; 15736: 				{
; 15737: 					return TRUE;

  000a4	b8 01 00 00 00	 mov	 eax, 1
  000a9	eb 09		 jmp	 SHORT $LN1@CheckInven
$LN8@CheckInven:

; 15738: 				}
; 15739: 			}
; 15740: 		}

  000ab	eb 8f		 jmp	 SHORT $LN5@CheckInven
$LN6@CheckInven:

; 15741: 	}

  000ad	e9 72 ff ff ff	 jmp	 $LN2@CheckInven
$LN3@CheckInven:

; 15742: 
; 15743: 	return FALSE;

  000b2	33 c0		 xor	 eax, eax
$LN1@CheckInven:

; 15744: }

  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
?CheckInventoryEmptySpace@@YAHPAVOBJECTSTRUCT@@HH@Z ENDP ; CheckInventoryEmptySpace
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z
_TEXT	SEGMENT
_yy$ = -20						; size = 4
_xx$ = -16						; size = 4
_blank$ = -12						; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_sx$ = 12						; size = 4
_sy$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z PROC		; gObjOnlyInventoryRectCheck, COMDAT

; 15669: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15670: 	int x, y;
; 15671: 	int blank = 0;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _blank$[ebp], 0

; 15672: 
; 15673: 	//     
; 15674: 	if( (sx+width) > 8 ) return (BYTE)0xFF;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  00013	03 45 14	 add	 eax, DWORD PTR _width$[ebp]
  00016	83 f8 08	 cmp	 eax, 8
  00019	7e 07		 jle	 SHORT $LN8@gObjOnlyIn
  0001b	0c ff		 or	 al, 255			; 000000ffH
  0001d	e9 f4 00 00 00	 jmp	 $LN1@gObjOnlyIn
$LN8@gObjOnlyIn:

; 15675: 	if( (sy+height) > 8 ) return (BYTE)0xFE;

  00022	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00025	03 45 18	 add	 eax, DWORD PTR _height$[ebp]
  00028	83 f8 08	 cmp	 eax, 8
  0002b	7e 07		 jle	 SHORT $LN9@gObjOnlyIn
  0002d	b0 fe		 mov	 al, 254			; 000000feH
  0002f	e9 e2 00 00 00	 jmp	 $LN1@gObjOnlyIn
$LN9@gObjOnlyIn:

; 15676: 
; 15677: 	int xx, yy;
; 15678: 
; 15679: 	for( y=0; y<height; y++)

  00034	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  0003b	eb 09		 jmp	 SHORT $LN4@gObjOnlyIn
$LN2@gObjOnlyIn:
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
$LN4@gObjOnlyIn:
  00046	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00049	3b 45 18	 cmp	 eax, DWORD PTR _height$[ebp]
  0004c	0f 8d b0 00 00
	00		 jge	 $LN3@gObjOnlyIn

; 15680: 	{		
; 15681: 		yy = sy+y;

  00052	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00055	03 45 f8	 add	 eax, DWORD PTR _y$[ebp]
  00058	89 45 ec	 mov	 DWORD PTR _yy$[ebp], eax

; 15682: 		for(x=0; x<width; x++)

  0005b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00062	eb 09		 jmp	 SHORT $LN7@gObjOnlyIn
$LN5@gObjOnlyIn:
  00064	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$LN7@gObjOnlyIn:
  0006d	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00070	3b 45 14	 cmp	 eax, DWORD PTR _width$[ebp]
  00073	0f 8d 84 00 00
	00		 jge	 $LN6@gObjOnlyIn

; 15683: 		{
; 15684: 			xx = sx+x;

  00079	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  0007c	03 45 fc	 add	 eax, DWORD PTR _x$[ebp]
  0007f	89 45 f0	 mov	 DWORD PTR _xx$[ebp], eax

; 15685: 
; 15686: 			if( ExtentCheck(xx, yy, 8, 8) == TRUE )

  00082	6a 08		 push	 8
  00084	6a 08		 push	 8
  00086	8b 45 ec	 mov	 eax, DWORD PTR _yy$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _xx$[ebp]
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  00093	83 c4 10	 add	 esp, 16			; 00000010H
  00096	83 f8 01	 cmp	 eax, 1
  00099	75 3d		 jne	 SHORT $LN10@gObjOnlyIn

; 15687: 			{
; 15688: 				if( *(gObj[aIndex].pInventoryMap+((sy+y)*8)+(sx+x)) != 0xFF ) 

  0009b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a2	8b 4d 10	 mov	 ecx, DWORD PTR _sy$[ebp]
  000a5	03 4d f8	 add	 ecx, DWORD PTR _y$[ebp]
  000a8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ae	8b 84 02 60 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3168]
  000b5	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  000b8	8b 55 0c	 mov	 edx, DWORD PTR _sx$[ebp]
  000bb	03 55 fc	 add	 edx, DWORD PTR _x$[ebp]
  000be	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  000c2	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000c7	74 0d		 je	 SHORT $LN12@gObjOnlyIn

; 15689: 				{
; 15690: 					blank++;

  000c9	8b 45 f4	 mov	 eax, DWORD PTR _blank$[ebp]
  000cc	83 c0 01	 add	 eax, 1
  000cf	89 45 f4	 mov	 DWORD PTR _blank$[ebp], eax

; 15691: 					return (BYTE)0xFF;

  000d2	0c ff		 or	 al, 255			; 000000ffH
  000d4	eb 40		 jmp	 SHORT $LN1@gObjOnlyIn
$LN12@gObjOnlyIn:

; 15692: 				}
; 15693: 			}

  000d6	eb 20		 jmp	 SHORT $LN11@gObjOnlyIn
$LN10@gObjOnlyIn:

; 15694: 			else 
; 15695: 			{
; 15696: 				LogAdd("error : %s %d",__FILE__, __LINE__);

  000d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjOnlyInventoryRectCheck@@YAEHHHHH@Z@4JA
  000dd	83 c0 1b	 add	 eax, 27			; 0000001bH
  000e0	50		 push	 eax
  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15697: 				return (BYTE)0xFF;

  000f4	0c ff		 or	 al, 255			; 000000ffH
  000f6	eb 1e		 jmp	 SHORT $LN1@gObjOnlyIn
$LN11@gObjOnlyIn:

; 15698: 			}
; 15699: 		}

  000f8	e9 67 ff ff ff	 jmp	 $LN5@gObjOnlyIn
$LN6@gObjOnlyIn:

; 15700: 	}

  000fd	e9 3b ff ff ff	 jmp	 $LN2@gObjOnlyIn
$LN3@gObjOnlyIn:

; 15701: 
; 15702: 	if( blank == 0 ) return (BYTE)(MAX_EQUIPMENT+((sy*8)+sx));

  00102	83 7d f4 00	 cmp	 DWORD PTR _blank$[ebp], 0
  00106	75 0c		 jne	 SHORT $LN13@gObjOnlyIn
  00108	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  0010b	8b 4d 0c	 mov	 ecx, DWORD PTR _sx$[ebp]
  0010e	8d 44 c1 0c	 lea	 eax, DWORD PTR [ecx+eax*8+12]
  00112	eb 02		 jmp	 SHORT $LN1@gObjOnlyIn
$LN13@gObjOnlyIn:

; 15703: 
; 15704: 	return (BYTE)0xFF;

  00114	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjOnlyIn:

; 15705: }

  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	5b		 pop	 ebx
  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c3		 ret	 0
?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z ENDP		; gObjOnlyInventoryRectCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInventoryRectCheck@@YAEHHHHH@Z
_TEXT	SEGMENT
_yy$ = -20						; size = 4
_xx$ = -16						; size = 4
_blank$ = -12						; size = 4
_y$ = -8						; size = 4
_x$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_sx$ = 12						; size = 4
_sy$ = 16						; size = 4
_width$ = 20						; size = 4
_height$ = 24						; size = 4
?gObjInventoryRectCheck@@YAEHHHHH@Z PROC		; gObjInventoryRectCheck, COMDAT

; 15617: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 15618: 	int x, y;
; 15619: 	int blank = 0;

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _blank$[ebp], 0

; 15620: 
; 15621: 	//     
; 15622: #ifdef PERSONAL_SHOP_20040113		//           .
; 15623: 	if( (sx+width) > 8 ) return (BYTE)0xFF;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  00013	03 45 14	 add	 eax, DWORD PTR _width$[ebp]
  00016	83 f8 08	 cmp	 eax, 8
  00019	7e 07		 jle	 SHORT $LN8@gObjInvent
  0001b	0c ff		 or	 al, 255			; 000000ffH
  0001d	e9 f4 00 00 00	 jmp	 $LN1@gObjInvent
$LN8@gObjInvent:

; 15624: 	if( (sy+height) > 12 ) return (BYTE)0xFE;

  00022	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00025	03 45 18	 add	 eax, DWORD PTR _height$[ebp]
  00028	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0002b	7e 07		 jle	 SHORT $LN9@gObjInvent
  0002d	b0 fe		 mov	 al, 254			; 000000feH
  0002f	e9 e2 00 00 00	 jmp	 $LN1@gObjInvent
$LN9@gObjInvent:

; 15625: #else
; 15626: 	if( (sx+width) > 8 ) return (BYTE)0xFF;
; 15627: 	if( (sy+height) > 8 ) return (BYTE)0xFE;
; 15628: #endif
; 15629: 
; 15630: 	int xx, yy;
; 15631: 
; 15632: 	for( y=0; y<height; y++)

  00034	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
  0003b	eb 09		 jmp	 SHORT $LN4@gObjInvent
$LN2@gObjInvent:
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
$LN4@gObjInvent:
  00046	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00049	3b 45 18	 cmp	 eax, DWORD PTR _height$[ebp]
  0004c	0f 8d b0 00 00
	00		 jge	 $LN3@gObjInvent

; 15633: 	{		
; 15634: 		yy = sy+y;

  00052	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  00055	03 45 f8	 add	 eax, DWORD PTR _y$[ebp]
  00058	89 45 ec	 mov	 DWORD PTR _yy$[ebp], eax

; 15635: 		for(x=0; x<width; x++)

  0005b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _x$[ebp], 0
  00062	eb 09		 jmp	 SHORT $LN7@gObjInvent
$LN5@gObjInvent:
  00064	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$LN7@gObjInvent:
  0006d	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]
  00070	3b 45 14	 cmp	 eax, DWORD PTR _width$[ebp]
  00073	0f 8d 84 00 00
	00		 jge	 $LN6@gObjInvent

; 15636: 		{
; 15637: 			xx = sx+x;

  00079	8b 45 0c	 mov	 eax, DWORD PTR _sx$[ebp]
  0007c	03 45 fc	 add	 eax, DWORD PTR _x$[ebp]
  0007f	89 45 f0	 mov	 DWORD PTR _xx$[ebp], eax

; 15638: 
; 15639: #ifdef PERSONAL_SHOP_20040113
; 15640: 			if( ExtentCheck(xx, yy, 8, 12) == TRUE )

  00082	6a 0c		 push	 12			; 0000000cH
  00084	6a 08		 push	 8
  00086	8b 45 ec	 mov	 eax, DWORD PTR _yy$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _xx$[ebp]
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 ?ExtentCheck@@YAHHHHH@Z	; ExtentCheck
  00093	83 c4 10	 add	 esp, 16			; 00000010H
  00096	83 f8 01	 cmp	 eax, 1
  00099	75 3d		 jne	 SHORT $LN10@gObjInvent

; 15641: #else
; 15642: 			if( ExtentCheck(xx, yy, 8, 8) == TRUE )
; 15643: #endif
; 15644: 			{
; 15645: 				if( *(gObj[aIndex].pInventoryMap+((sy+y)*8)+(sx+x)) != 0xFF ) 

  0009b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000a2	8b 4d 10	 mov	 ecx, DWORD PTR _sy$[ebp]
  000a5	03 4d f8	 add	 ecx, DWORD PTR _y$[ebp]
  000a8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ae	8b 84 02 60 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3168]
  000b5	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  000b8	8b 55 0c	 mov	 edx, DWORD PTR _sx$[ebp]
  000bb	03 55 fc	 add	 edx, DWORD PTR _x$[ebp]
  000be	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  000c2	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000c7	74 0d		 je	 SHORT $LN12@gObjInvent

; 15646: 				{
; 15647: 					blank++;

  000c9	8b 45 f4	 mov	 eax, DWORD PTR _blank$[ebp]
  000cc	83 c0 01	 add	 eax, 1
  000cf	89 45 f4	 mov	 DWORD PTR _blank$[ebp], eax

; 15648: 					return (BYTE)0xFF;

  000d2	0c ff		 or	 al, 255			; 000000ffH
  000d4	eb 40		 jmp	 SHORT $LN1@gObjInvent
$LN12@gObjInvent:

; 15649: 				}
; 15650: 			}

  000d6	eb 20		 jmp	 SHORT $LN11@gObjInvent
$LN10@gObjInvent:

; 15651: 			else 
; 15652: 			{
; 15653: 				LogAdd("error : %s %d",__FILE__, __LINE__);

  000d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjInventoryRectCheck@@YAEHHHHH@Z@4JA
  000dd	83 c0 24	 add	 eax, 36			; 00000024H
  000e0	50		 push	 eax
  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15654: 				return (BYTE)0xFF;

  000f4	0c ff		 or	 al, 255			; 000000ffH
  000f6	eb 1e		 jmp	 SHORT $LN1@gObjInvent
$LN11@gObjInvent:

; 15655: 			}
; 15656: 		}

  000f8	e9 67 ff ff ff	 jmp	 $LN5@gObjInvent
$LN6@gObjInvent:

; 15657: 	}

  000fd	e9 3b ff ff ff	 jmp	 $LN2@gObjInvent
$LN3@gObjInvent:

; 15658: 
; 15659: 	if( blank == 0 ) return (BYTE)(MAX_EQUIPMENT+((sy*8)+sx));

  00102	83 7d f4 00	 cmp	 DWORD PTR _blank$[ebp], 0
  00106	75 0c		 jne	 SHORT $LN13@gObjInvent
  00108	8b 45 10	 mov	 eax, DWORD PTR _sy$[ebp]
  0010b	8b 4d 0c	 mov	 ecx, DWORD PTR _sx$[ebp]
  0010e	8d 44 c1 0c	 lea	 eax, DWORD PTR [ecx+eax*8+12]
  00112	eb 02		 jmp	 SHORT $LN1@gObjInvent
$LN13@gObjInvent:

; 15660: 
; 15661: 	return (BYTE)0xFF;

  00114	0c ff		 or	 al, 255			; 000000ffH
$LN1@gObjInvent:

; 15662: }

  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	5b		 pop	 ebx
  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c3		 ret	 0
?gObjInventoryRectCheck@@YAEHHHHH@Z ENDP		; gObjInventoryRectCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjJoominCheck@@YAHHPAD@Z
_TEXT	SEGMENT
tv67 = -72						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
_szInJN$ = 12						; size = 4
?gObjJoominCheck@@YAHHPAD@Z PROC			; gObjJoominCheck, COMDAT

; 6523 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6524 : 	if(g_GlobalConfig.m_bPersonalID == false)

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A, 0
  00010	75 0a		 jne	 SHORT $LN4@gObjJoomin

; 6525 : 		return TRUE;

  00012	b8 01 00 00 00	 mov	 eax, 1
  00017	e9 f9 01 00 00	 jmp	 $LN1@gObjJoomin
$LN4@gObjJoomin:

; 6526 : 
; 6527 : 	LPOBJECTSTRUCT lpObj;
; 6528 : 
; 6529 : 	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  0001c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00023	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00029	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 6530 : 
; 6531 : 	switch( gLanguage )

  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gLanguage@@3HA ; gLanguage
  00031	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
  00034	8b 4d b8	 mov	 ecx, DWORD PTR tv67[ebp]
  00037	83 e9 01	 sub	 ecx, 1
  0003a	89 4d b8	 mov	 DWORD PTR tv67[ebp], ecx
  0003d	83 7d b8 07	 cmp	 DWORD PTR tv67[ebp], 7
  00041	0f 87 aa 01 00
	00		 ja	 $LN19@gObjJoomin
  00047	8b 55 b8	 mov	 edx, DWORD PTR tv67[ebp]
  0004a	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN22@gObjJoomin[edx*4]
$LN5@gObjJoomin:

; 6532 : 	{
; 6533 : 	case 1 :
; 6534 : 	case 5 :		// , 
; 6535 : #ifdef MODIFY_JOOMINCHECK_FOR_USA
; 6536 : 	case 8:			// (K2)
; 6537 : #endif	
; 6538 : #ifdef UPDATE_USERPASSWORD_LENGTH_20090424
; 6539 : 		LogAddTD("[%s][%s][%s]",lpObj->AccountID, szInJN, lpObj->LastJoominNumber);
; 6540 : 		if( strncmp( szInJN, lpObj->LastJoominNumber, MAX_JOOMINNUMBER_LENGTH) == 0 )
; 6541 : 		{
; 6542 : 			return TRUE;
; 6543 : 		}
; 6544 : 		break;
; 6545 : #endif	// UPDATE_USERPASSWORD_LENGTH_20090424
; 6546 : #ifdef MODIFY_GAMEPASSWORD_20041126
; 6547 : 	case 6 :		// 
; 6548 : #endif
; 6549 : 		if( strncmp( szInJN, lpObj->LastJoominNumber, 7) == 0 )

  00051	6a 07		 push	 7
  00053	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00056	83 c0 7e	 add	 eax, 126		; 0000007eH
  00059	50		 push	 eax
  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR _szInJN$[ebp]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 _strncmp
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	85 c0		 test	 eax, eax
  00068	75 0a		 jne	 SHORT $LN7@gObjJoomin

; 6550 : 		{
; 6551 : 			return TRUE;

  0006a	b8 01 00 00 00	 mov	 eax, 1
  0006f	e9 a1 01 00 00	 jmp	 $LN1@gObjJoomin
$LN7@gObjJoomin:

; 6552 : 		}
; 6553 : 
; 6554 : 	case 2 :		// 		
; 6555 : 		if( strncmp( szInJN, lpObj->LastJoominNumber+5, 8) == 0 )

  00074	6a 08		 push	 8
  00076	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00079	05 83 00 00 00	 add	 eax, 131		; 00000083H
  0007e	50		 push	 eax
  0007f	8b 4d 0c	 mov	 ecx, DWORD PTR _szInJN$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _strncmp
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008b	85 c0		 test	 eax, eax
  0008d	75 0a		 jne	 SHORT $LN9@gObjJoomin

; 6556 : 		{
; 6557 : 			return TRUE;

  0008f	b8 01 00 00 00	 mov	 eax, 1
  00094	e9 7c 01 00 00	 jmp	 $LN1@gObjJoomin
$LN9@gObjJoomin:

; 6558 : 		}
; 6559 : 
; 6560 : #ifdef BUGFIX_X_RESIDENT_REGISTRATION_OF_USER_20050419	
; 6561 : 	case 3 : // 
; 6562 : 		if( _stricmp(szInJN, lpObj->LastJoominNumber+6) == 0 )

  00099	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009c	05 84 00 00 00	 add	 eax, 132		; 00000084H
  000a1	50		 push	 eax
  000a2	8b 4d 0c	 mov	 ecx, DWORD PTR _szInJN$[ebp]
  000a5	51		 push	 ecx
  000a6	e8 00 00 00 00	 call	 __stricmp
  000ab	83 c4 08	 add	 esp, 8
  000ae	85 c0		 test	 eax, eax
  000b0	75 0a		 jne	 SHORT $LN10@gObjJoomin

; 6563 : 		{
; 6564 : 			return TRUE;

  000b2	b8 01 00 00 00	 mov	 eax, 1
  000b7	e9 59 01 00 00	 jmp	 $LN1@gObjJoomin
$LN10@gObjJoomin:

; 6565 : 		}
; 6566 : 		break;

  000bc	e9 52 01 00 00	 jmp	 $LN2@gObjJoomin
$LN11@gObjJoomin:

; 6567 : 
; 6568 : #endif // BUGFIX_X_RESIDENT_REGISTRATION_OF_USER_20050419
; 6569 : 		
; 6570 : 	case 4 :		// 
; 6571 : 
; 6572 : 		//     .
; 6573 : #if !defined(AUTH_GAMESERVER) && (defined(TESTSERVER) == 1)
; 6574 : 
; 6575 : 		return TRUE;

  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	e9 4a 01 00 00	 jmp	 $LN1@gObjJoomin

; 6576 : #endif
; 6577 : 
; 6578 : 		if( strlen( szInJN ) < 2 )

  000cb	8b 45 0c	 mov	 eax, DWORD PTR _szInJN$[ebp]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 _strlen
  000d4	83 c4 04	 add	 esp, 4
  000d7	83 f8 02	 cmp	 eax, 2
  000da	73 07		 jae	 SHORT $LN12@gObjJoomin

; 6579 : 		{
; 6580 : 			return FALSE;

  000dc	33 c0		 xor	 eax, eax
  000de	e9 32 01 00 00	 jmp	 $LN1@gObjJoomin
$LN12@gObjJoomin:

; 6581 : 		}
; 6582 : 		//  ?
; 6583 : 		if( (szInJN[0] >= 'A' && szInJN[0] <= 'Z') || 

  000e3	b8 01 00 00 00	 mov	 eax, 1
  000e8	6b c8 00	 imul	 ecx, eax, 0
  000eb	8b 55 0c	 mov	 edx, DWORD PTR _szInJN$[ebp]
  000ee	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  000f2	83 f8 41	 cmp	 eax, 65			; 00000041H
  000f5	7c 14		 jl	 SHORT $LN15@gObjJoomin
  000f7	b8 01 00 00 00	 mov	 eax, 1
  000fc	6b c8 00	 imul	 ecx, eax, 0
  000ff	8b 55 0c	 mov	 edx, DWORD PTR _szInJN$[ebp]
  00102	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00106	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  00109	7e 30		 jle	 SHORT $LN14@gObjJoomin
$LN15@gObjJoomin:
  0010b	b8 01 00 00 00	 mov	 eax, 1
  00110	6b c8 00	 imul	 ecx, eax, 0
  00113	8b 55 0c	 mov	 edx, DWORD PTR _szInJN$[ebp]
  00116	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0011a	83 f8 61	 cmp	 eax, 97			; 00000061H
  0011d	0f 8c cc 00 00
	00		 jl	 $LN13@gObjJoomin
  00123	b8 01 00 00 00	 mov	 eax, 1
  00128	6b c8 00	 imul	 ecx, eax, 0
  0012b	8b 55 0c	 mov	 edx, DWORD PTR _szInJN$[ebp]
  0012e	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00132	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00135	0f 8f b4 00 00
	00		 jg	 $LN13@gObjJoomin
$LN14@gObjJoomin:

; 6584 : 			(szInJN[0] >= 'a' && szInJN[0] <= 'z') )
; 6585 : 		{
; 6586 : 			//    
; 6587 : 			if( szInJN[0] >= 'A' && szInJN[0] <= 'Z' ) 

  0013b	b8 01 00 00 00	 mov	 eax, 1
  00140	6b c8 00	 imul	 ecx, eax, 0
  00143	8b 55 0c	 mov	 edx, DWORD PTR _szInJN$[ebp]
  00146	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0014a	83 f8 41	 cmp	 eax, 65			; 00000041H
  0014d	7c 34		 jl	 SHORT $LN16@gObjJoomin
  0014f	b8 01 00 00 00	 mov	 eax, 1
  00154	6b c8 00	 imul	 ecx, eax, 0
  00157	8b 55 0c	 mov	 edx, DWORD PTR _szInJN$[ebp]
  0015a	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0015e	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  00161	7f 20		 jg	 SHORT $LN16@gObjJoomin

; 6588 : 			{
; 6589 : 				szInJN[0] = 'a'+(szInJN[0]-'A');

  00163	b8 01 00 00 00	 mov	 eax, 1
  00168	6b c8 00	 imul	 ecx, eax, 0
  0016b	8b 55 0c	 mov	 edx, DWORD PTR _szInJN$[ebp]
  0016e	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00172	83 c0 20	 add	 eax, 32			; 00000020H
  00175	b9 01 00 00 00	 mov	 ecx, 1
  0017a	6b d1 00	 imul	 edx, ecx, 0
  0017d	8b 4d 0c	 mov	 ecx, DWORD PTR _szInJN$[ebp]
  00180	88 04 11	 mov	 BYTE PTR [ecx+edx], al
$LN16@gObjJoomin:

; 6590 : 			}
; 6591 : 			if( lpObj->LastJoominNumber[0] >= 'A' && lpObj->LastJoominNumber[0] <= 'Z' ) 

  00183	b8 01 00 00 00	 mov	 eax, 1
  00188	6b c8 00	 imul	 ecx, eax, 0
  0018b	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0018e	0f be 44 0a 7e	 movsx	 eax, BYTE PTR [edx+ecx+126]
  00193	83 f8 41	 cmp	 eax, 65			; 00000041H
  00196	7c 37		 jl	 SHORT $LN17@gObjJoomin
  00198	b8 01 00 00 00	 mov	 eax, 1
  0019d	6b c8 00	 imul	 ecx, eax, 0
  001a0	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001a3	0f be 44 0a 7e	 movsx	 eax, BYTE PTR [edx+ecx+126]
  001a8	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  001ab	7f 22		 jg	 SHORT $LN17@gObjJoomin

; 6592 : 			{
; 6593 : 				lpObj->LastJoominNumber[0] = 'a'+(lpObj->LastJoominNumber[0]-'A');

  001ad	b8 01 00 00 00	 mov	 eax, 1
  001b2	6b c8 00	 imul	 ecx, eax, 0
  001b5	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001b8	0f be 44 0a 7e	 movsx	 eax, BYTE PTR [edx+ecx+126]
  001bd	83 c0 20	 add	 eax, 32			; 00000020H
  001c0	b9 01 00 00 00	 mov	 ecx, 1
  001c5	6b d1 00	 imul	 edx, ecx, 0
  001c8	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001cb	88 44 11 7e	 mov	 BYTE PTR [ecx+edx+126], al
$LN17@gObjJoomin:

; 6594 : 			}
; 6595 : 
; 6596 : 			//   
; 6597 : 			if( strncmp(lpObj->LastJoominNumber, szInJN, 10) == 0 )

  001cf	6a 0a		 push	 10			; 0000000aH
  001d1	8b 45 0c	 mov	 eax, DWORD PTR _szInJN$[ebp]
  001d4	50		 push	 eax
  001d5	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001d8	83 c1 7e	 add	 ecx, 126		; 0000007eH
  001db	51		 push	 ecx
  001dc	e8 00 00 00 00	 call	 _strncmp
  001e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e4	85 c0		 test	 eax, eax
  001e6	75 07		 jne	 SHORT $LN13@gObjJoomin

; 6598 : 			{
; 6599 : 				return TRUE;

  001e8	b8 01 00 00 00	 mov	 eax, 1
  001ed	eb 26		 jmp	 SHORT $LN1@gObjJoomin
$LN13@gObjJoomin:

; 6600 : 			}
; 6601 : 		}
; 6602 : 		break;

  001ef	eb 22		 jmp	 SHORT $LN2@gObjJoomin
$LN19@gObjJoomin:

; 6603 : 	default :
; 6604 : #if TESTSERVER == 1
; 6605 : 		return TRUE;
; 6606 : #endif 
; 6607 : 		if( strncmp( szInJN, lpObj->LastJoominNumber+6, 7) == 0 )

  001f1	6a 07		 push	 7
  001f3	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001f6	05 84 00 00 00	 add	 eax, 132		; 00000084H
  001fb	50		 push	 eax
  001fc	8b 4d 0c	 mov	 ecx, DWORD PTR _szInJN$[ebp]
  001ff	51		 push	 ecx
  00200	e8 00 00 00 00	 call	 _strncmp
  00205	83 c4 0c	 add	 esp, 12			; 0000000cH
  00208	85 c0		 test	 eax, eax
  0020a	75 07		 jne	 SHORT $LN2@gObjJoomin

; 6608 : 		{
; 6609 : 			return TRUE;

  0020c	b8 01 00 00 00	 mov	 eax, 1
  00211	eb 02		 jmp	 SHORT $LN1@gObjJoomin
$LN2@gObjJoomin:

; 6610 : 		}
; 6611 : 		break;
; 6612 : 	}	
; 6613 : 	return FALSE;

  00213	33 c0		 xor	 eax, eax
$LN1@gObjJoomin:

; 6614 : }

  00215	5f		 pop	 edi
  00216	5e		 pop	 esi
  00217	5b		 pop	 ebx
  00218	8b e5		 mov	 esp, ebp
  0021a	5d		 pop	 ebp
  0021b	c3		 ret	 0
$LN22@gObjJoomin:
  0021c	00 00 00 00	 DD	 $LN5@gObjJoomin
  00220	00 00 00 00	 DD	 $LN7@gObjJoomin
  00224	00 00 00 00	 DD	 $LN9@gObjJoomin
  00228	00 00 00 00	 DD	 $LN11@gObjJoomin
  0022c	00 00 00 00	 DD	 $LN5@gObjJoomin
  00230	00 00 00 00	 DD	 $LN5@gObjJoomin
  00234	00 00 00 00	 DD	 $LN19@gObjJoomin
  00238	00 00 00 00	 DD	 $LN5@gObjJoomin
?gObjJoominCheck@@YAHHPAD@Z ENDP			; gObjJoominCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjViewportClose@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_n$1 = -16						; size = 4
_MVL$ = -12						; size = 4
_i$ = -8						; size = 4
_tObjNum$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?gObjViewportClose@@YAXPAVOBJECTSTRUCT@@@Z PROC		; gObjViewportClose, COMDAT

; 20546: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 20547: 	int tObjNum;
; 20548: 	int i;
; 20549: 
; 20550: 	int MVL = MAXVIEWPORTOBJECT;

  00009	c7 45 f4 4b 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 75 ; 0000004bH

; 20551: 	if( lpObj->Type == OBJTYPE_MONSTER ) MVL = MAX_MONVIEWPORTOBJECT;

  00010	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00013	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00017	83 f9 02	 cmp	 ecx, 2
  0001a	75 07		 jne	 SHORT $LN9@gObjViewpo
  0001c	c7 45 f4 14 00
	00 00		 mov	 DWORD PTR _MVL$[ebp], 20 ; 00000014H
$LN9@gObjViewpo:

; 20552: 
; 20553: 	if( lpObj->Connected == CSS_GAMEPLAYING )	//  ..

  00023	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00026	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  0002a	0f 85 7c 01 00
	00		 jne	 $LN10@gObjViewpo

; 20554: 	{
; 20555: 		for( int n=0; n<MVL; n++) 

  00030	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  00037	eb 09		 jmp	 SHORT $LN4@gObjViewpo
$LN2@gObjViewpo:
  00039	8b 45 f0	 mov	 eax, DWORD PTR _n$1[ebp]
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f0	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjViewpo:
  00042	8b 45 f0	 mov	 eax, DWORD PTR _n$1[ebp]
  00045	3b 45 f4	 cmp	 eax, DWORD PTR _MVL$[ebp]
  00048	0f 8d 5e 01 00
	00		 jge	 $LN10@gObjViewpo

; 20556: 		{
; 20557: 			if( lpObj->VpPlayer2[n].state )

  0004e	6b 45 f0 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00055	0f be 94 01 e8
	06 00 00	 movsx	 edx, BYTE PTR [ecx+eax+1768]
  0005d	85 d2		 test	 edx, edx
  0005f	0f 84 42 01 00
	00		 je	 $LN11@gObjViewpo

; 20558: 			{
; 20559: 				if( lpObj->VpPlayer2[n].type != OBJTYPE_ITEM ) 

  00065	6b 45 f0 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0006c	0f b6 94 01 ec
	06 00 00	 movzx	 edx, BYTE PTR [ecx+eax+1772]
  00074	83 fa 05	 cmp	 edx, 5
  00077	0f 84 2a 01 00
	00		 je	 $LN11@gObjViewpo

; 20560: 				{
; 20561: 					//       .
; 20562: 					tObjNum = lpObj->VpPlayer2[n].number;

  0007d	6b 45 f0 0c	 imul	 eax, DWORD PTR _n$1[ebp], 12
  00081	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00084	0f bf 94 01 ea
	06 00 00	 movsx	 edx, WORD PTR [ecx+eax+1770]
  0008c	89 55 fc	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 20563: 					i = 0;

  0008f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN5@gObjViewpo:

; 20564: 					while(1)

  00096	b8 01 00 00 00	 mov	 eax, 1
  0009b	85 c0		 test	 eax, eax
  0009d	74 7c		 je	 SHORT $LN6@gObjViewpo

; 20565: 					{
; 20566: 						if( gObj[tObjNum].VpPlayer[i].number == lpObj->m_Index && gObj[tObjNum].VpPlayer[i].type == lpObj->Type )

  0009f	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000a6	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ac	6b 4d f8 0c	 imul	 ecx, DWORD PTR _i$[ebp], 12
  000b0	0f bf 94 08 66
	03 00 00	 movsx	 edx, WORD PTR [eax+ecx+870]
  000b8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bb	3b 10		 cmp	 edx, DWORD PTR [eax]
  000bd	75 3f		 jne	 SHORT $LN13@gObjViewpo
  000bf	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000c6	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cc	6b 4d f8 0c	 imul	 ecx, DWORD PTR _i$[ebp], 12
  000d0	0f b6 94 08 68
	03 00 00	 movzx	 edx, BYTE PTR [eax+ecx+872]
  000d8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000db	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  000df	3b d1		 cmp	 edx, ecx
  000e1	75 1b		 jne	 SHORT $LN13@gObjViewpo

; 20567: 						{
; 20568: 							gObj[tObjNum].VpPlayer[i].state  = STVP_DESTROY;

  000e3	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  000ea	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f0	6b 4d f8 0c	 imul	 ecx, DWORD PTR _i$[ebp], 12
  000f4	c6 84 08 64 03
	00 00 03	 mov	 BYTE PTR [eax+ecx+868], 3

; 20569: 							break;

  000fc	eb 1d		 jmp	 SHORT $LN6@gObjViewpo
$LN13@gObjViewpo:

; 20570: 						}
; 20571: 						if(i< MVL-1 ) i++;

  000fe	8b 45 f4	 mov	 eax, DWORD PTR _MVL$[ebp]
  00101	83 e8 01	 sub	 eax, 1
  00104	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  00107	7d 0b		 jge	 SHORT $LN14@gObjViewpo
  00109	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0010c	83 c0 01	 add	 eax, 1
  0010f	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00112	eb 02		 jmp	 SHORT $LN15@gObjViewpo
$LN14@gObjViewpo:

; 20572: 						else {
; 20573: 							#if _DEBUG
; 20574: 							LogAdd(lMsg.Get(541), lpObj->m_Index,tObjNum);
; 20575: 							#endif
; 20576: 							break;

  00114	eb 05		 jmp	 SHORT $LN6@gObjViewpo
$LN15@gObjViewpo:

; 20577: 						}
; 20578: 					}

  00116	e9 7b ff ff ff	 jmp	 $LN5@gObjViewpo
$LN6@gObjViewpo:

; 20579: 					i = 0;

  0011b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN7@gObjViewpo:

; 20580: 					while(1)

  00122	b8 01 00 00 00	 mov	 eax, 1
  00127	85 c0		 test	 eax, eax
  00129	74 7c		 je	 SHORT $LN11@gObjViewpo

; 20581: 					{
; 20582: 						if( gObj[tObjNum].VpPlayer2[i].number == lpObj->m_Index && gObj[tObjNum].VpPlayer2[i].type == lpObj->Type )

  0012b	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00132	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00138	6b 4d f8 0c	 imul	 ecx, DWORD PTR _i$[ebp], 12
  0013c	0f bf 94 08 ea
	06 00 00	 movsx	 edx, WORD PTR [eax+ecx+1770]
  00144	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00147	3b 10		 cmp	 edx, DWORD PTR [eax]
  00149	75 3f		 jne	 SHORT $LN16@gObjViewpo
  0014b	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00152	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00158	6b 4d f8 0c	 imul	 ecx, DWORD PTR _i$[ebp], 12
  0015c	0f b6 94 08 ec
	06 00 00	 movzx	 edx, BYTE PTR [eax+ecx+1772]
  00164	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00167	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0016b	3b d1		 cmp	 edx, ecx
  0016d	75 1b		 jne	 SHORT $LN16@gObjViewpo

; 20583: 						{
; 20584: 							gObj[tObjNum].VpPlayer2[i].state  = 0;

  0016f	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00176	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0017c	6b 4d f8 0c	 imul	 ecx, DWORD PTR _i$[ebp], 12
  00180	c6 84 08 e8 06
	00 00 00	 mov	 BYTE PTR [eax+ecx+1768], 0

; 20585: 							break;

  00188	eb 1d		 jmp	 SHORT $LN11@gObjViewpo
$LN16@gObjViewpo:

; 20586: 						}
; 20587: 						if(i< MVL-1 ) i++;

  0018a	8b 45 f4	 mov	 eax, DWORD PTR _MVL$[ebp]
  0018d	83 e8 01	 sub	 eax, 1
  00190	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  00193	7d 0b		 jge	 SHORT $LN17@gObjViewpo
  00195	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00198	83 c0 01	 add	 eax, 1
  0019b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  0019e	eb 02		 jmp	 SHORT $LN18@gObjViewpo
$LN17@gObjViewpo:

; 20588: 						else {
; 20589: 							#if _DEBUG
; 20590: 							LogAdd(lMsg.Get(541),lpObj->m_Index,tObjNum);
; 20591: 							#endif
; 20592: 							break;

  001a0	eb 05		 jmp	 SHORT $LN11@gObjViewpo
$LN18@gObjViewpo:

; 20593: 						}
; 20594: 					}

  001a2	e9 7b ff ff ff	 jmp	 $LN7@gObjViewpo
$LN11@gObjViewpo:

; 20595: 
; 20596: 				}
; 20597: 			}
; 20598: 		}

  001a7	e9 8d fe ff ff	 jmp	 $LN2@gObjViewpo
$LN10@gObjViewpo:

; 20599: 	}
; 20600: 	gObjClearViewport(lpObj);

  001ac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 ?gObjClearViewport@@YAXPAVOBJECTSTRUCT@@@Z ; gObjClearViewport
  001b5	83 c4 04	 add	 esp, 4

; 20601: }

  001b8	5f		 pop	 edi
  001b9	5e		 pop	 esi
  001ba	5b		 pop	 ebx
  001bb	8b e5		 mov	 esp, ebp
  001bd	5d		 pop	 ebp
  001be	c3		 ret	 0
?gObjViewportClose@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; gObjViewportClose
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjUserKill@@YAXH@Z
_TEXT	SEGMENT
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjUserKill@@YAXH@Z PROC				; gObjUserKill, COMDAT

; 5619 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5620 : 	LPOBJECTSTRUCT	lpObj;
; 5621 : 
; 5622 : 	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  00009	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 5623 : 	
; 5624 : 	if( lpObj->CloseCount < 1 )

  00019	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	0f be 48 0a	 movsx	 ecx, BYTE PTR [eax+10]
  00020	83 f9 01	 cmp	 ecx, 1
  00023	7d 0e		 jge	 SHORT $LN1@gObjUserKi

; 5625 : 	{
; 5626 : 		lpObj->CloseCount = 6;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00028	c6 40 0a 06	 mov	 BYTE PTR [eax+10], 6

; 5627 : 		lpObj->CloseType  = CL_EXIT;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002f	c6 40 0b 00	 mov	 BYTE PTR [eax+11], 0
$LN1@gObjUserKi:

; 5628 : 	}
; 5629 : }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?gObjUserKill@@YAXH@Z ENDP				; gObjUserKill
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjBillRequest@@YAXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv78 = -380						; size = 4
$T1 = -376						; size = 4
$T2 = -372						; size = 4
$T3 = -368						; size = 4
$T4 = -364						; size = 4
$T5 = -360						; size = 4
$T6 = -356						; size = 4
$T7 = -352						; size = 4
$T8 = -348						; size = 4
$T9 = -344						; size = 4
$T10 = -340						; size = 4
$T11 = -336						; size = 4
$T12 = -332						; size = 4
$T13 = -328						; size = 4
$T14 = -324						; size = 4
$T15 = -320						; size = 4
_user_minute$16 = -252					; size = 4
_user_hour$17 = -248					; size = 4
_user_day$18 = -244					; size = 4
_user_mon$19 = -240					; size = 4
_user_year$20 = -236					; size = 4
_szTemp$21 = -232					; size = 20
_user_minute$22 = -212					; size = 4
_user_hour$23 = -208					; size = 4
_user_day$24 = -204					; size = 4
_user_mon$25 = -200					; size = 4
_user_year$26 = -196					; size = 4
_szTemp$27 = -192					; size = 20
_user_minute$28 = -172					; size = 4
_user_hour$29 = -168					; size = 4
_user_day$30 = -164					; size = 4
_user_mon$31 = -160					; size = 4
_user_year$32 = -156					; size = 4
_szTemp$33 = -152					; size = 20
_szMsg$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjBillRequest@@YAXPAVOBJECTSTRUCT@@@Z PROC		; gObjBillRequest, COMDAT

; 5697 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 7c 01 00
	00		 sub	 esp, 380		; 0000017cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 5698 : 	char szMsg[128]		= "";

  00016	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  0001b	88 85 7c ff ff
	ff		 mov	 BYTE PTR _szMsg$[ebp], al
  00021	6a 7f		 push	 127			; 0000007fH
  00023	6a 00		 push	 0
  00025	8d 85 7d ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$[ebp+1]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _memset
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5699 : 	
; 5700 : 	switch(m_ObjBill[lpObj->m_Index].GetDeductType())

  00034	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00037	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  0003a	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00040	e8 00 00 00 00	 call	 ?GetDeductType@BILL_CLASS@@QAEEXZ ; BILL_CLASS::GetDeductType
  00045	0f b6 c8	 movzx	 ecx, al
  00048	89 8d 84 fe ff
	ff		 mov	 DWORD PTR tv78[ebp], ecx
  0004e	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR tv78[ebp]
  00054	83 ea 01	 sub	 edx, 1
  00057	89 95 84 fe ff
	ff		 mov	 DWORD PTR tv78[ebp], edx
  0005d	83 bd 84 fe ff
	ff 04		 cmp	 DWORD PTR tv78[ebp], 4
  00064	0f 87 45 0b 00
	00		 ja	 $LN2@gObjBillRe
  0006a	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  00070	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN53@gObjBillRe[eax*4]
$LN4@gObjBillRe:

; 5701 : 	{
; 5702 : 	case BILL_TYPE_PERSONAL_AMOUNT:	// 
; 5703 : 		{
; 5704 : 			char szTemp[20]		= "";

  00077	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  0007c	88 85 68 ff ff
	ff		 mov	 BYTE PTR _szTemp$33[ebp], al
  00082	33 c0		 xor	 eax, eax
  00084	89 85 69 ff ff
	ff		 mov	 DWORD PTR _szTemp$33[ebp+1], eax
  0008a	89 85 6d ff ff
	ff		 mov	 DWORD PTR _szTemp$33[ebp+5], eax
  00090	89 85 71 ff ff
	ff		 mov	 DWORD PTR _szTemp$33[ebp+9], eax
  00096	89 85 75 ff ff
	ff		 mov	 DWORD PTR _szTemp$33[ebp+13], eax
  0009c	66 89 85 79 ff
	ff ff		 mov	 WORD PTR _szTemp$33[ebp+17], ax
  000a3	88 85 7b ff ff
	ff		 mov	 BYTE PTR _szTemp$33[ebp+19], al

; 5705 : 			
; 5706 : 			szTemp[5] = '\0';

  000a9	b8 01 00 00 00	 mov	 eax, 1
  000ae	6b c8 05	 imul	 ecx, eax, 5
  000b1	89 8d c0 fe ff
	ff		 mov	 DWORD PTR $T15[ebp], ecx
  000b7	83 bd c0 fe ff
	ff 14		 cmp	 DWORD PTR $T15[ebp], 20	; 00000014H
  000be	73 02		 jae	 SHORT $LN23@gObjBillRe
  000c0	eb 05		 jmp	 SHORT $LN24@gObjBillRe
$LN23@gObjBillRe:
  000c2	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN24@gObjBillRe:
  000c7	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR $T15[ebp]
  000cd	c6 84 15 68 ff
	ff ff 00	 mov	 BYTE PTR _szTemp$33[ebp+edx], 0

; 5707 : 			strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays(), 4);

  000d5	6a 04		 push	 4
  000d7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000da	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  000dd	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  000e3	e8 00 00 00 00	 call	 ?GetEndsDays@BILL_CLASS@@QAEPADXZ ; BILL_CLASS::GetEndsDays
  000e8	50		 push	 eax
  000e9	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$33[ebp]
  000ef	51		 push	 ecx
  000f0	e8 00 00 00 00	 call	 _strncpy
  000f5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5708 : 			int user_year = atoi(szTemp);

  000f8	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$33[ebp]
  000fe	50		 push	 eax
  000ff	e8 00 00 00 00	 call	 _atoi
  00104	83 c4 04	 add	 esp, 4
  00107	89 85 64 ff ff
	ff		 mov	 DWORD PTR _user_year$32[ebp], eax

; 5709 : 			
; 5710 : 			strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays()+4, 2);

  0010d	6a 02		 push	 2
  0010f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00112	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00115	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  0011b	e8 00 00 00 00	 call	 ?GetEndsDays@BILL_CLASS@@QAEPADXZ ; BILL_CLASS::GetEndsDays
  00120	83 c0 04	 add	 eax, 4
  00123	50		 push	 eax
  00124	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$33[ebp]
  0012a	51		 push	 ecx
  0012b	e8 00 00 00 00	 call	 _strncpy
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5711 : 			szTemp[2] = '\0';

  00133	b8 01 00 00 00	 mov	 eax, 1
  00138	d1 e0		 shl	 eax, 1
  0013a	89 85 bc fe ff
	ff		 mov	 DWORD PTR $T14[ebp], eax
  00140	83 bd bc fe ff
	ff 14		 cmp	 DWORD PTR $T14[ebp], 20	; 00000014H
  00147	73 02		 jae	 SHORT $LN25@gObjBillRe
  00149	eb 05		 jmp	 SHORT $LN26@gObjBillRe
$LN25@gObjBillRe:
  0014b	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN26@gObjBillRe:
  00150	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR $T14[ebp]
  00156	c6 84 0d 68 ff
	ff ff 00	 mov	 BYTE PTR _szTemp$33[ebp+ecx], 0

; 5712 : 			int user_mon = atoi(szTemp);

  0015e	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$33[ebp]
  00164	50		 push	 eax
  00165	e8 00 00 00 00	 call	 _atoi
  0016a	83 c4 04	 add	 esp, 4
  0016d	89 85 60 ff ff
	ff		 mov	 DWORD PTR _user_mon$31[ebp], eax

; 5713 : 			
; 5714 : 			strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays()+6, 2);

  00173	6a 02		 push	 2
  00175	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00178	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  0017b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00181	e8 00 00 00 00	 call	 ?GetEndsDays@BILL_CLASS@@QAEPADXZ ; BILL_CLASS::GetEndsDays
  00186	83 c0 06	 add	 eax, 6
  00189	50		 push	 eax
  0018a	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$33[ebp]
  00190	51		 push	 ecx
  00191	e8 00 00 00 00	 call	 _strncpy
  00196	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5715 : 			szTemp[2] = '\0';

  00199	b8 01 00 00 00	 mov	 eax, 1
  0019e	d1 e0		 shl	 eax, 1
  001a0	89 85 b8 fe ff
	ff		 mov	 DWORD PTR $T13[ebp], eax
  001a6	83 bd b8 fe ff
	ff 14		 cmp	 DWORD PTR $T13[ebp], 20	; 00000014H
  001ad	73 02		 jae	 SHORT $LN27@gObjBillRe
  001af	eb 05		 jmp	 SHORT $LN28@gObjBillRe
$LN27@gObjBillRe:
  001b1	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN28@gObjBillRe:
  001b6	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR $T13[ebp]
  001bc	c6 84 0d 68 ff
	ff ff 00	 mov	 BYTE PTR _szTemp$33[ebp+ecx], 0

; 5716 : 			int user_day = atoi(szTemp);

  001c4	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$33[ebp]
  001ca	50		 push	 eax
  001cb	e8 00 00 00 00	 call	 _atoi
  001d0	83 c4 04	 add	 esp, 4
  001d3	89 85 5c ff ff
	ff		 mov	 DWORD PTR _user_day$30[ebp], eax

; 5717 : 
; 5718 : 			strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays()+8, 2);

  001d9	6a 02		 push	 2
  001db	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001de	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  001e1	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  001e7	e8 00 00 00 00	 call	 ?GetEndsDays@BILL_CLASS@@QAEPADXZ ; BILL_CLASS::GetEndsDays
  001ec	83 c0 08	 add	 eax, 8
  001ef	50		 push	 eax
  001f0	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$33[ebp]
  001f6	51		 push	 ecx
  001f7	e8 00 00 00 00	 call	 _strncpy
  001fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5719 : 			szTemp[2] = '\0';

  001ff	b8 01 00 00 00	 mov	 eax, 1
  00204	d1 e0		 shl	 eax, 1
  00206	89 85 b4 fe ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
  0020c	83 bd b4 fe ff
	ff 14		 cmp	 DWORD PTR $T12[ebp], 20	; 00000014H
  00213	73 02		 jae	 SHORT $LN29@gObjBillRe
  00215	eb 05		 jmp	 SHORT $LN30@gObjBillRe
$LN29@gObjBillRe:
  00217	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN30@gObjBillRe:
  0021c	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR $T12[ebp]
  00222	c6 84 0d 68 ff
	ff ff 00	 mov	 BYTE PTR _szTemp$33[ebp+ecx], 0

; 5720 : 			int user_hour = atoi(szTemp);

  0022a	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$33[ebp]
  00230	50		 push	 eax
  00231	e8 00 00 00 00	 call	 _atoi
  00236	83 c4 04	 add	 esp, 4
  00239	89 85 58 ff ff
	ff		 mov	 DWORD PTR _user_hour$29[ebp], eax

; 5721 : 
; 5722 : 			strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays()+10, 2);

  0023f	6a 02		 push	 2
  00241	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00244	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00247	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  0024d	e8 00 00 00 00	 call	 ?GetEndsDays@BILL_CLASS@@QAEPADXZ ; BILL_CLASS::GetEndsDays
  00252	83 c0 0a	 add	 eax, 10			; 0000000aH
  00255	50		 push	 eax
  00256	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$33[ebp]
  0025c	51		 push	 ecx
  0025d	e8 00 00 00 00	 call	 _strncpy
  00262	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5723 : 			szTemp[2] = '\0';

  00265	b8 01 00 00 00	 mov	 eax, 1
  0026a	d1 e0		 shl	 eax, 1
  0026c	89 85 b0 fe ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
  00272	83 bd b0 fe ff
	ff 14		 cmp	 DWORD PTR $T11[ebp], 20	; 00000014H
  00279	73 02		 jae	 SHORT $LN31@gObjBillRe
  0027b	eb 05		 jmp	 SHORT $LN32@gObjBillRe
$LN31@gObjBillRe:
  0027d	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN32@gObjBillRe:
  00282	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  00288	c6 84 0d 68 ff
	ff ff 00	 mov	 BYTE PTR _szTemp$33[ebp+ecx], 0

; 5724 : 			int user_minute = atoi(szTemp);

  00290	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$33[ebp]
  00296	50		 push	 eax
  00297	e8 00 00 00 00	 call	 _atoi
  0029c	83 c4 04	 add	 esp, 4
  0029f	89 85 54 ff ff
	ff		 mov	 DWORD PTR _user_minute$28[ebp], eax

; 5725 : 			
; 5726 : 			wsprintf(szMsg, lMsg.Get(1509),user_year, user_mon, user_day, user_hour, user_minute);

  002a5	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _user_minute$28[ebp]
  002ab	50		 push	 eax
  002ac	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _user_hour$29[ebp]
  002b2	51		 push	 ecx
  002b3	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _user_day$30[ebp]
  002b9	52		 push	 edx
  002ba	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _user_mon$31[ebp]
  002c0	50		 push	 eax
  002c1	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _user_year$32[ebp]
  002c7	51		 push	 ecx
  002c8	68 e5 05 00 00	 push	 1509			; 000005e5H
  002cd	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002d8	50		 push	 eax
  002d9	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _szMsg$[ebp]
  002df	52		 push	 edx
  002e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  002e6	83 c4 1c	 add	 esp, 28			; 0000001cH

; 5727 : 			
; 5728 : 		}		
; 5729 : 		break;

  002e9	e9 c1 08 00 00	 jmp	 $LN2@gObjBillRe
$LN5@gObjBillRe:

; 5730 : 	case BILL_TYPE_PCBANG_AMOUNT:	// PC 
; 5731 : 		{
; 5732 : 			char szTemp[20]		= "";

  002ee	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  002f3	88 85 40 ff ff
	ff		 mov	 BYTE PTR _szTemp$27[ebp], al
  002f9	33 c0		 xor	 eax, eax
  002fb	89 85 41 ff ff
	ff		 mov	 DWORD PTR _szTemp$27[ebp+1], eax
  00301	89 85 45 ff ff
	ff		 mov	 DWORD PTR _szTemp$27[ebp+5], eax
  00307	89 85 49 ff ff
	ff		 mov	 DWORD PTR _szTemp$27[ebp+9], eax
  0030d	89 85 4d ff ff
	ff		 mov	 DWORD PTR _szTemp$27[ebp+13], eax
  00313	66 89 85 51 ff
	ff ff		 mov	 WORD PTR _szTemp$27[ebp+17], ax
  0031a	88 85 53 ff ff
	ff		 mov	 BYTE PTR _szTemp$27[ebp+19], al

; 5733 : 			
; 5734 : 			szTemp[4] = '\0';

  00320	b8 01 00 00 00	 mov	 eax, 1
  00325	c1 e0 02	 shl	 eax, 2
  00328	89 85 ac fe ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
  0032e	83 bd ac fe ff
	ff 14		 cmp	 DWORD PTR $T10[ebp], 20	; 00000014H
  00335	73 02		 jae	 SHORT $LN33@gObjBillRe
  00337	eb 05		 jmp	 SHORT $LN34@gObjBillRe
$LN33@gObjBillRe:
  00339	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN34@gObjBillRe:
  0033e	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR $T10[ebp]
  00344	c6 84 0d 40 ff
	ff ff 00	 mov	 BYTE PTR _szTemp$27[ebp+ecx], 0

; 5735 : 			strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays(), 4);

  0034c	6a 04		 push	 4
  0034e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00351	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00354	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  0035a	e8 00 00 00 00	 call	 ?GetEndsDays@BILL_CLASS@@QAEPADXZ ; BILL_CLASS::GetEndsDays
  0035f	50		 push	 eax
  00360	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$27[ebp]
  00366	51		 push	 ecx
  00367	e8 00 00 00 00	 call	 _strncpy
  0036c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5736 : 			int user_year = atoi(szTemp);

  0036f	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$27[ebp]
  00375	50		 push	 eax
  00376	e8 00 00 00 00	 call	 _atoi
  0037b	83 c4 04	 add	 esp, 4
  0037e	89 85 3c ff ff
	ff		 mov	 DWORD PTR _user_year$26[ebp], eax

; 5737 : 			
; 5738 : 			strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays()+4, 2);

  00384	6a 02		 push	 2
  00386	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00389	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  0038c	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00392	e8 00 00 00 00	 call	 ?GetEndsDays@BILL_CLASS@@QAEPADXZ ; BILL_CLASS::GetEndsDays
  00397	83 c0 04	 add	 eax, 4
  0039a	50		 push	 eax
  0039b	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$27[ebp]
  003a1	51		 push	 ecx
  003a2	e8 00 00 00 00	 call	 _strncpy
  003a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5739 : 			szTemp[2] = '\0';

  003aa	b8 01 00 00 00	 mov	 eax, 1
  003af	d1 e0		 shl	 eax, 1
  003b1	89 85 a8 fe ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
  003b7	83 bd a8 fe ff
	ff 14		 cmp	 DWORD PTR $T9[ebp], 20	; 00000014H
  003be	73 02		 jae	 SHORT $LN35@gObjBillRe
  003c0	eb 05		 jmp	 SHORT $LN36@gObjBillRe
$LN35@gObjBillRe:
  003c2	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN36@gObjBillRe:
  003c7	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR $T9[ebp]
  003cd	c6 84 0d 40 ff
	ff ff 00	 mov	 BYTE PTR _szTemp$27[ebp+ecx], 0

; 5740 : 			int user_mon = atoi(szTemp);

  003d5	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$27[ebp]
  003db	50		 push	 eax
  003dc	e8 00 00 00 00	 call	 _atoi
  003e1	83 c4 04	 add	 esp, 4
  003e4	89 85 38 ff ff
	ff		 mov	 DWORD PTR _user_mon$25[ebp], eax

; 5741 : 			
; 5742 : 			strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays()+6, 2);

  003ea	6a 02		 push	 2
  003ec	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003ef	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  003f2	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  003f8	e8 00 00 00 00	 call	 ?GetEndsDays@BILL_CLASS@@QAEPADXZ ; BILL_CLASS::GetEndsDays
  003fd	83 c0 06	 add	 eax, 6
  00400	50		 push	 eax
  00401	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$27[ebp]
  00407	51		 push	 ecx
  00408	e8 00 00 00 00	 call	 _strncpy
  0040d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5743 : 			szTemp[2] = '\0';

  00410	b8 01 00 00 00	 mov	 eax, 1
  00415	d1 e0		 shl	 eax, 1
  00417	89 85 a4 fe ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
  0041d	83 bd a4 fe ff
	ff 14		 cmp	 DWORD PTR $T8[ebp], 20	; 00000014H
  00424	73 02		 jae	 SHORT $LN37@gObjBillRe
  00426	eb 05		 jmp	 SHORT $LN38@gObjBillRe
$LN37@gObjBillRe:
  00428	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN38@gObjBillRe:
  0042d	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR $T8[ebp]
  00433	c6 84 0d 40 ff
	ff ff 00	 mov	 BYTE PTR _szTemp$27[ebp+ecx], 0

; 5744 : 			int user_day = atoi(szTemp);

  0043b	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$27[ebp]
  00441	50		 push	 eax
  00442	e8 00 00 00 00	 call	 _atoi
  00447	83 c4 04	 add	 esp, 4
  0044a	89 85 34 ff ff
	ff		 mov	 DWORD PTR _user_day$24[ebp], eax

; 5745 : 
; 5746 : 			strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays()+8, 2);

  00450	6a 02		 push	 2
  00452	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00455	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00458	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  0045e	e8 00 00 00 00	 call	 ?GetEndsDays@BILL_CLASS@@QAEPADXZ ; BILL_CLASS::GetEndsDays
  00463	83 c0 08	 add	 eax, 8
  00466	50		 push	 eax
  00467	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$27[ebp]
  0046d	51		 push	 ecx
  0046e	e8 00 00 00 00	 call	 _strncpy
  00473	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5747 : 			szTemp[2] = '\0';

  00476	b8 01 00 00 00	 mov	 eax, 1
  0047b	d1 e0		 shl	 eax, 1
  0047d	89 85 a0 fe ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
  00483	83 bd a0 fe ff
	ff 14		 cmp	 DWORD PTR $T7[ebp], 20	; 00000014H
  0048a	73 02		 jae	 SHORT $LN39@gObjBillRe
  0048c	eb 05		 jmp	 SHORT $LN40@gObjBillRe
$LN39@gObjBillRe:
  0048e	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN40@gObjBillRe:
  00493	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  00499	c6 84 0d 40 ff
	ff ff 00	 mov	 BYTE PTR _szTemp$27[ebp+ecx], 0

; 5748 : 			int user_hour = atoi(szTemp);

  004a1	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$27[ebp]
  004a7	50		 push	 eax
  004a8	e8 00 00 00 00	 call	 _atoi
  004ad	83 c4 04	 add	 esp, 4
  004b0	89 85 30 ff ff
	ff		 mov	 DWORD PTR _user_hour$23[ebp], eax

; 5749 : 			
; 5750 : 			strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays()+10, 2);

  004b6	6a 02		 push	 2
  004b8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  004bb	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  004be	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  004c4	e8 00 00 00 00	 call	 ?GetEndsDays@BILL_CLASS@@QAEPADXZ ; BILL_CLASS::GetEndsDays
  004c9	83 c0 0a	 add	 eax, 10			; 0000000aH
  004cc	50		 push	 eax
  004cd	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$27[ebp]
  004d3	51		 push	 ecx
  004d4	e8 00 00 00 00	 call	 _strncpy
  004d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5751 : 			szTemp[2] = '\0';

  004dc	b8 01 00 00 00	 mov	 eax, 1
  004e1	d1 e0		 shl	 eax, 1
  004e3	89 85 9c fe ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
  004e9	83 bd 9c fe ff
	ff 14		 cmp	 DWORD PTR $T6[ebp], 20	; 00000014H
  004f0	73 02		 jae	 SHORT $LN41@gObjBillRe
  004f2	eb 05		 jmp	 SHORT $LN42@gObjBillRe
$LN41@gObjBillRe:
  004f4	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN42@gObjBillRe:
  004f9	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
  004ff	c6 84 0d 40 ff
	ff ff 00	 mov	 BYTE PTR _szTemp$27[ebp+ecx], 0

; 5752 : 			int user_minute = atoi(szTemp);

  00507	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$27[ebp]
  0050d	50		 push	 eax
  0050e	e8 00 00 00 00	 call	 _atoi
  00513	83 c4 04	 add	 esp, 4
  00516	89 85 2c ff ff
	ff		 mov	 DWORD PTR _user_minute$22[ebp], eax

; 5753 : 			
; 5754 : 			wsprintf(szMsg, lMsg.Get(1510), user_year, user_mon, user_day, user_hour, user_minute);

  0051c	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _user_minute$22[ebp]
  00522	50		 push	 eax
  00523	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR _user_hour$23[ebp]
  00529	51		 push	 ecx
  0052a	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _user_day$24[ebp]
  00530	52		 push	 edx
  00531	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR _user_mon$25[ebp]
  00537	50		 push	 eax
  00538	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _user_year$26[ebp]
  0053e	51		 push	 ecx
  0053f	68 e6 05 00 00	 push	 1510			; 000005e6H
  00544	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00549	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0054f	50		 push	 eax
  00550	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _szMsg$[ebp]
  00556	52		 push	 edx
  00557	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0055d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 5755 : 		}
; 5756 : 		break;

  00560	e9 4a 06 00 00	 jmp	 $LN2@gObjBillRe
$LN6@gObjBillRe:

; 5757 : 	case BILL_TYPE_PCBANG_QUANTITY:	// PC 
; 5758 : 		{
; 5759 : 			if(m_ObjBill[lpObj->m_Index].GetRestPoint() == 0 && m_ObjBill[lpObj->m_Index].GetRestTime() != 0)

  00565	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00568	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  0056b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00571	e8 00 00 00 00	 call	 ?GetRestPoint@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestPoint
  00576	85 c0		 test	 eax, eax
  00578	75 4d		 jne	 SHORT $LN7@gObjBillRe
  0057a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0057d	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00580	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00586	e8 00 00 00 00	 call	 ?GetRestTime@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestTime
  0058b	85 c0		 test	 eax, eax
  0058d	74 38		 je	 SHORT $LN7@gObjBillRe

; 5760 : 			{
; 5761 : 				wsprintf(szMsg, lMsg.Get(1506), m_ObjBill[lpObj->m_Index].GetRestTime());			

  0058f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00592	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00595	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  0059b	e8 00 00 00 00	 call	 ?GetRestTime@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestTime
  005a0	50		 push	 eax
  005a1	68 e2 05 00 00	 push	 1506			; 000005e2H
  005a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  005ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  005b1	50		 push	 eax
  005b2	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _szMsg$[ebp]
  005b8	51		 push	 ecx
  005b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  005bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5762 : 			}

  005c2	e9 a4 00 00 00	 jmp	 $LN8@gObjBillRe
$LN7@gObjBillRe:

; 5763 : 			else if(m_ObjBill[lpObj->m_Index].GetRestPoint() != 0 && m_ObjBill[lpObj->m_Index].GetRestTime() == 0 )

  005c7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005ca	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  005cd	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  005d3	e8 00 00 00 00	 call	 ?GetRestPoint@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestPoint
  005d8	85 c0		 test	 eax, eax
  005da	74 4a		 je	 SHORT $LN9@gObjBillRe
  005dc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005df	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  005e2	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  005e8	e8 00 00 00 00	 call	 ?GetRestTime@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestTime
  005ed	85 c0		 test	 eax, eax
  005ef	75 35		 jne	 SHORT $LN9@gObjBillRe

; 5764 : 			{
; 5765 : 				wsprintf(szMsg, lMsg.Get(1507), m_ObjBill[lpObj->m_Index].GetRestPoint());			

  005f1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005f4	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  005f7	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  005fd	e8 00 00 00 00	 call	 ?GetRestPoint@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestPoint
  00602	50		 push	 eax
  00603	68 e3 05 00 00	 push	 1507			; 000005e3H
  00608	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0060d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00613	50		 push	 eax
  00614	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _szMsg$[ebp]
  0061a	51		 push	 ecx
  0061b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00621	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5766 : 			}

  00624	eb 45		 jmp	 SHORT $LN8@gObjBillRe
$LN9@gObjBillRe:

; 5767 : 			else
; 5768 : 			{
; 5769 : 				wsprintf(szMsg, lMsg.Get(1508), m_ObjBill[lpObj->m_Index].GetRestTime(), m_ObjBill[lpObj->m_Index].GetRestPoint());	

  00626	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00629	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  0062c	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00632	e8 00 00 00 00	 call	 ?GetRestPoint@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestPoint
  00637	50		 push	 eax
  00638	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0063b	6b 09 1c	 imul	 ecx, DWORD PTR [ecx], 28
  0063e	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00644	e8 00 00 00 00	 call	 ?GetRestTime@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestTime
  00649	50		 push	 eax
  0064a	68 e4 05 00 00	 push	 1508			; 000005e4H
  0064f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00654	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0065a	50		 push	 eax
  0065b	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _szMsg$[ebp]
  00661	52		 push	 edx
  00662	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00668	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@gObjBillRe:

; 5770 : 			}
; 5771 : 			
; 5772 : 		}
; 5773 : 		break;

  0066b	e9 3f 05 00 00	 jmp	 $LN2@gObjBillRe
$LN11@gObjBillRe:

; 5774 : 	case BILL_TYPE_PERSONAL_QUANTITY:	//  	
; 5775 : 		{
; 5776 : 			if(m_ObjBill[lpObj->m_Index].GetRestPoint() == 0 && m_ObjBill[lpObj->m_Index].GetRestTime() != 0)

  00670	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00673	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00676	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  0067c	e8 00 00 00 00	 call	 ?GetRestPoint@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestPoint
  00681	85 c0		 test	 eax, eax
  00683	75 71		 jne	 SHORT $LN12@gObjBillRe
  00685	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00688	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  0068b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00691	e8 00 00 00 00	 call	 ?GetRestTime@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestTime
  00696	85 c0		 test	 eax, eax
  00698	74 5c		 je	 SHORT $LN12@gObjBillRe

; 5777 : 			{
; 5778 : 				wsprintf(szMsg, lMsg.Get(1503), m_ObjBill[lpObj->m_Index].GetRestTime() / 60, m_ObjBill[lpObj->m_Index].GetRestTime() % 60 );			

  0069a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0069d	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  006a0	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  006a6	e8 00 00 00 00	 call	 ?GetRestTime@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestTime
  006ab	33 d2		 xor	 edx, edx
  006ad	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  006b2	f7 f1		 div	 ecx
  006b4	52		 push	 edx
  006b5	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  006b8	6b 0a 1c	 imul	 ecx, DWORD PTR [edx], 28
  006bb	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  006c1	e8 00 00 00 00	 call	 ?GetRestTime@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestTime
  006c6	33 d2		 xor	 edx, edx
  006c8	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  006cd	f7 f1		 div	 ecx
  006cf	50		 push	 eax
  006d0	68 df 05 00 00	 push	 1503			; 000005dfH
  006d5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  006da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  006e0	50		 push	 eax
  006e1	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _szMsg$[ebp]
  006e7	52		 push	 edx
  006e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  006ee	83 c4 10	 add	 esp, 16			; 00000010H

; 5779 : 			}

  006f1	e9 c8 00 00 00	 jmp	 $LN13@gObjBillRe
$LN12@gObjBillRe:

; 5780 : 			else if(m_ObjBill[lpObj->m_Index].GetRestPoint() != 0 && m_ObjBill[lpObj->m_Index].GetRestTime() == 0 )

  006f6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006f9	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  006fc	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00702	e8 00 00 00 00	 call	 ?GetRestPoint@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestPoint
  00707	85 c0		 test	 eax, eax
  00709	74 4a		 je	 SHORT $LN14@gObjBillRe
  0070b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0070e	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00711	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00717	e8 00 00 00 00	 call	 ?GetRestTime@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestTime
  0071c	85 c0		 test	 eax, eax
  0071e	75 35		 jne	 SHORT $LN14@gObjBillRe

; 5781 : 			{
; 5782 : 				wsprintf(szMsg, lMsg.Get(1504), m_ObjBill[lpObj->m_Index].GetRestPoint());			

  00720	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00723	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00726	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  0072c	e8 00 00 00 00	 call	 ?GetRestPoint@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestPoint
  00731	50		 push	 eax
  00732	68 e0 05 00 00	 push	 1504			; 000005e0H
  00737	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  0073c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00742	50		 push	 eax
  00743	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _szMsg$[ebp]
  00749	51		 push	 ecx
  0074a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00750	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5783 : 			}

  00753	eb 69		 jmp	 SHORT $LN13@gObjBillRe
$LN14@gObjBillRe:

; 5784 : 			else
; 5785 : 			{
; 5786 : 				wsprintf(szMsg, lMsg.Get(1505), 

  00755	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00758	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  0075b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00761	e8 00 00 00 00	 call	 ?GetRestPoint@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestPoint
  00766	50		 push	 eax
  00767	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0076a	6b 09 1c	 imul	 ecx, DWORD PTR [ecx], 28
  0076d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00773	e8 00 00 00 00	 call	 ?GetRestTime@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestTime
  00778	33 d2		 xor	 edx, edx
  0077a	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0077f	f7 f1		 div	 ecx
  00781	52		 push	 edx
  00782	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00785	6b 0a 1c	 imul	 ecx, DWORD PTR [edx], 28
  00788	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  0078e	e8 00 00 00 00	 call	 ?GetRestTime@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestTime
  00793	33 d2		 xor	 edx, edx
  00795	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0079a	f7 f1		 div	 ecx
  0079c	50		 push	 eax
  0079d	68 e1 05 00 00	 push	 1505			; 000005e1H
  007a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  007a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  007ad	50		 push	 eax
  007ae	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _szMsg$[ebp]
  007b4	52		 push	 edx
  007b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  007bb	83 c4 14	 add	 esp, 20			; 00000014H
$LN13@gObjBillRe:

; 5787 : 					m_ObjBill[lpObj->m_Index].GetRestTime() / 60, m_ObjBill[lpObj->m_Index].GetRestTime() % 60, m_ObjBill[lpObj->m_Index].GetRestPoint());	
; 5788 : 			}		
; 5789 : 		}
; 5790 : 		break;

  007be	e9 ec 03 00 00	 jmp	 $LN2@gObjBillRe
$LN16@gObjBillRe:

; 5791 : 	case BILL_TYPE_COLLOR:		//  
; 5792 : 		{
; 5793 : 			char szTemp[20]		= "";

  007c3	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  007c8	88 85 18 ff ff
	ff		 mov	 BYTE PTR _szTemp$21[ebp], al
  007ce	33 c0		 xor	 eax, eax
  007d0	89 85 19 ff ff
	ff		 mov	 DWORD PTR _szTemp$21[ebp+1], eax
  007d6	89 85 1d ff ff
	ff		 mov	 DWORD PTR _szTemp$21[ebp+5], eax
  007dc	89 85 21 ff ff
	ff		 mov	 DWORD PTR _szTemp$21[ebp+9], eax
  007e2	89 85 25 ff ff
	ff		 mov	 DWORD PTR _szTemp$21[ebp+13], eax
  007e8	66 89 85 29 ff
	ff ff		 mov	 WORD PTR _szTemp$21[ebp+17], ax
  007ef	88 85 2b ff ff
	ff		 mov	 BYTE PTR _szTemp$21[ebp+19], al

; 5794 : 			
; 5795 : 			szTemp[4] = '\0';

  007f5	b8 01 00 00 00	 mov	 eax, 1
  007fa	c1 e0 02	 shl	 eax, 2
  007fd	89 85 98 fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  00803	83 bd 98 fe ff
	ff 14		 cmp	 DWORD PTR $T5[ebp], 20	; 00000014H
  0080a	73 02		 jae	 SHORT $LN43@gObjBillRe
  0080c	eb 05		 jmp	 SHORT $LN44@gObjBillRe
$LN43@gObjBillRe:
  0080e	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN44@gObjBillRe:
  00813	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  00819	c6 84 0d 18 ff
	ff ff 00	 mov	 BYTE PTR _szTemp$21[ebp+ecx], 0

; 5796 : 			strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays(), 4);

  00821	6a 04		 push	 4
  00823	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00826	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00829	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  0082f	e8 00 00 00 00	 call	 ?GetEndsDays@BILL_CLASS@@QAEPADXZ ; BILL_CLASS::GetEndsDays
  00834	50		 push	 eax
  00835	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$21[ebp]
  0083b	51		 push	 ecx
  0083c	e8 00 00 00 00	 call	 _strncpy
  00841	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5797 : 			int user_year = atoi(szTemp);

  00844	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$21[ebp]
  0084a	50		 push	 eax
  0084b	e8 00 00 00 00	 call	 _atoi
  00850	83 c4 04	 add	 esp, 4
  00853	89 85 14 ff ff
	ff		 mov	 DWORD PTR _user_year$20[ebp], eax

; 5798 : 			
; 5799 : 			strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays()+4, 2);

  00859	6a 02		 push	 2
  0085b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0085e	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00861	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00867	e8 00 00 00 00	 call	 ?GetEndsDays@BILL_CLASS@@QAEPADXZ ; BILL_CLASS::GetEndsDays
  0086c	83 c0 04	 add	 eax, 4
  0086f	50		 push	 eax
  00870	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$21[ebp]
  00876	51		 push	 ecx
  00877	e8 00 00 00 00	 call	 _strncpy
  0087c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5800 : 			szTemp[2] = '\0';

  0087f	b8 01 00 00 00	 mov	 eax, 1
  00884	d1 e0		 shl	 eax, 1
  00886	89 85 94 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  0088c	83 bd 94 fe ff
	ff 14		 cmp	 DWORD PTR $T4[ebp], 20	; 00000014H
  00893	73 02		 jae	 SHORT $LN45@gObjBillRe
  00895	eb 05		 jmp	 SHORT $LN46@gObjBillRe
$LN45@gObjBillRe:
  00897	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN46@gObjBillRe:
  0089c	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
  008a2	c6 84 0d 18 ff
	ff ff 00	 mov	 BYTE PTR _szTemp$21[ebp+ecx], 0

; 5801 : 			int user_mon = atoi(szTemp);

  008aa	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$21[ebp]
  008b0	50		 push	 eax
  008b1	e8 00 00 00 00	 call	 _atoi
  008b6	83 c4 04	 add	 esp, 4
  008b9	89 85 10 ff ff
	ff		 mov	 DWORD PTR _user_mon$19[ebp], eax

; 5802 : 			
; 5803 : 			strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays()+6, 2);

  008bf	6a 02		 push	 2
  008c1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  008c4	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  008c7	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  008cd	e8 00 00 00 00	 call	 ?GetEndsDays@BILL_CLASS@@QAEPADXZ ; BILL_CLASS::GetEndsDays
  008d2	83 c0 06	 add	 eax, 6
  008d5	50		 push	 eax
  008d6	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$21[ebp]
  008dc	51		 push	 ecx
  008dd	e8 00 00 00 00	 call	 _strncpy
  008e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5804 : 			szTemp[2] = '\0';

  008e5	b8 01 00 00 00	 mov	 eax, 1
  008ea	d1 e0		 shl	 eax, 1
  008ec	89 85 90 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  008f2	83 bd 90 fe ff
	ff 14		 cmp	 DWORD PTR $T3[ebp], 20	; 00000014H
  008f9	73 02		 jae	 SHORT $LN47@gObjBillRe
  008fb	eb 05		 jmp	 SHORT $LN48@gObjBillRe
$LN47@gObjBillRe:
  008fd	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN48@gObjBillRe:
  00902	8b 8d 90 fe ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  00908	c6 84 0d 18 ff
	ff ff 00	 mov	 BYTE PTR _szTemp$21[ebp+ecx], 0

; 5805 : 			int user_day = atoi(szTemp);

  00910	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$21[ebp]
  00916	50		 push	 eax
  00917	e8 00 00 00 00	 call	 _atoi
  0091c	83 c4 04	 add	 esp, 4
  0091f	89 85 0c ff ff
	ff		 mov	 DWORD PTR _user_day$18[ebp], eax

; 5806 : 			
; 5807 : 			strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays()+8, 2);

  00925	6a 02		 push	 2
  00927	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0092a	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  0092d	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00933	e8 00 00 00 00	 call	 ?GetEndsDays@BILL_CLASS@@QAEPADXZ ; BILL_CLASS::GetEndsDays
  00938	83 c0 08	 add	 eax, 8
  0093b	50		 push	 eax
  0093c	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$21[ebp]
  00942	51		 push	 ecx
  00943	e8 00 00 00 00	 call	 _strncpy
  00948	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5808 : 			szTemp[2] = '\0';

  0094b	b8 01 00 00 00	 mov	 eax, 1
  00950	d1 e0		 shl	 eax, 1
  00952	89 85 8c fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00958	83 bd 8c fe ff
	ff 14		 cmp	 DWORD PTR $T2[ebp], 20	; 00000014H
  0095f	73 02		 jae	 SHORT $LN49@gObjBillRe
  00961	eb 05		 jmp	 SHORT $LN50@gObjBillRe
$LN49@gObjBillRe:
  00963	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN50@gObjBillRe:
  00968	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  0096e	c6 84 0d 18 ff
	ff ff 00	 mov	 BYTE PTR _szTemp$21[ebp+ecx], 0

; 5809 : 			int user_hour = atoi(szTemp);

  00976	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$21[ebp]
  0097c	50		 push	 eax
  0097d	e8 00 00 00 00	 call	 _atoi
  00982	83 c4 04	 add	 esp, 4
  00985	89 85 08 ff ff
	ff		 mov	 DWORD PTR _user_hour$17[ebp], eax

; 5810 : 			
; 5811 : 			strncpy(szTemp, m_ObjBill[lpObj->m_Index].GetEndsDays()+10, 2);

  0098b	6a 02		 push	 2
  0098d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00990	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00993	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00999	e8 00 00 00 00	 call	 ?GetEndsDays@BILL_CLASS@@QAEPADXZ ; BILL_CLASS::GetEndsDays
  0099e	83 c0 0a	 add	 eax, 10			; 0000000aH
  009a1	50		 push	 eax
  009a2	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR _szTemp$21[ebp]
  009a8	51		 push	 ecx
  009a9	e8 00 00 00 00	 call	 _strncpy
  009ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5812 : 			szTemp[2] = '\0';

  009b1	b8 01 00 00 00	 mov	 eax, 1
  009b6	d1 e0		 shl	 eax, 1
  009b8	89 85 88 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  009be	83 bd 88 fe ff
	ff 14		 cmp	 DWORD PTR $T1[ebp], 20	; 00000014H
  009c5	73 02		 jae	 SHORT $LN51@gObjBillRe
  009c7	eb 05		 jmp	 SHORT $LN52@gObjBillRe
$LN51@gObjBillRe:
  009c9	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN52@gObjBillRe:
  009ce	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  009d4	c6 84 0d 18 ff
	ff ff 00	 mov	 BYTE PTR _szTemp$21[ebp+ecx], 0

; 5813 : 			int user_minute = atoi(szTemp);

  009dc	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _szTemp$21[ebp]
  009e2	50		 push	 eax
  009e3	e8 00 00 00 00	 call	 _atoi
  009e8	83 c4 04	 add	 esp, 4
  009eb	89 85 04 ff ff
	ff		 mov	 DWORD PTR _user_minute$16[ebp], eax

; 5814 : 			
; 5815 : 			if(m_ObjBill[lpObj->m_Index].GetRestPoint() == 0 && m_ObjBill[lpObj->m_Index].GetRestTime() != 0)

  009f1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  009f4	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  009f7	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  009fd	e8 00 00 00 00	 call	 ?GetRestPoint@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestPoint
  00a02	85 c0		 test	 eax, eax
  00a04	0f 85 94 00 00
	00		 jne	 $LN17@gObjBillRe
  00a0a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a0d	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00a10	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00a16	e8 00 00 00 00	 call	 ?GetRestTime@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestTime
  00a1b	85 c0		 test	 eax, eax
  00a1d	74 7f		 je	 SHORT $LN17@gObjBillRe

; 5816 : 			{
; 5817 : 				wsprintf(szMsg, lMsg.Get(1512),user_year, user_mon, user_day, user_hour, user_minute, 

  00a1f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00a22	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00a25	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00a2b	e8 00 00 00 00	 call	 ?GetRestTime@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestTime
  00a30	33 d2		 xor	 edx, edx
  00a32	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00a37	f7 f1		 div	 ecx
  00a39	52		 push	 edx
  00a3a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00a3d	6b 0a 1c	 imul	 ecx, DWORD PTR [edx], 28
  00a40	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00a46	e8 00 00 00 00	 call	 ?GetRestTime@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestTime
  00a4b	33 d2		 xor	 edx, edx
  00a4d	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00a52	f7 f1		 div	 ecx
  00a54	50		 push	 eax
  00a55	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _user_minute$16[ebp]
  00a5b	52		 push	 edx
  00a5c	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _user_hour$17[ebp]
  00a62	50		 push	 eax
  00a63	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _user_day$18[ebp]
  00a69	51		 push	 ecx
  00a6a	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _user_mon$19[ebp]
  00a70	52		 push	 edx
  00a71	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _user_year$20[ebp]
  00a77	50		 push	 eax
  00a78	68 e8 05 00 00	 push	 1512			; 000005e8H
  00a7d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00a82	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00a88	50		 push	 eax
  00a89	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _szMsg$[ebp]
  00a8f	51		 push	 ecx
  00a90	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00a96	83 c4 24	 add	 esp, 36			; 00000024H

; 5818 : 					m_ObjBill[lpObj->m_Index].GetRestTime() / 60, m_ObjBill[lpObj->m_Index].GetRestTime() % 60);
; 5819 : 			}

  00a99	e9 11 01 00 00	 jmp	 $LN2@gObjBillRe
$LN17@gObjBillRe:

; 5820 : 			else if(m_ObjBill[lpObj->m_Index].GetRestPoint() != 0 && m_ObjBill[lpObj->m_Index].GetRestTime() == 0 )

  00a9e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00aa1	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00aa4	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00aaa	e8 00 00 00 00	 call	 ?GetRestPoint@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestPoint
  00aaf	85 c0		 test	 eax, eax
  00ab1	74 70		 je	 SHORT $LN19@gObjBillRe
  00ab3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00ab6	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00ab9	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00abf	e8 00 00 00 00	 call	 ?GetRestTime@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestTime
  00ac4	85 c0		 test	 eax, eax
  00ac6	75 5b		 jne	 SHORT $LN19@gObjBillRe

; 5821 : 			{
; 5822 : 				wsprintf(szMsg, lMsg.Get(1513),user_year, user_mon, user_day, user_hour, user_minute, 

  00ac8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00acb	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00ace	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00ad4	e8 00 00 00 00	 call	 ?GetRestPoint@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestPoint
  00ad9	50		 push	 eax
  00ada	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR _user_minute$16[ebp]
  00ae0	51		 push	 ecx
  00ae1	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR _user_hour$17[ebp]
  00ae7	52		 push	 edx
  00ae8	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _user_day$18[ebp]
  00aee	50		 push	 eax
  00aef	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR _user_mon$19[ebp]
  00af5	51		 push	 ecx
  00af6	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR _user_year$20[ebp]
  00afc	52		 push	 edx
  00afd	68 e9 05 00 00	 push	 1513			; 000005e9H
  00b02	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00b07	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00b0d	50		 push	 eax
  00b0e	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$[ebp]
  00b14	50		 push	 eax
  00b15	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00b1b	83 c4 20	 add	 esp, 32			; 00000020H

; 5823 : 					m_ObjBill[lpObj->m_Index].GetRestPoint());
; 5824 : 			}

  00b1e	e9 8c 00 00 00	 jmp	 $LN2@gObjBillRe
$LN19@gObjBillRe:

; 5825 : 			else
; 5826 : 			{
; 5827 : 				wsprintf(szMsg, lMsg.Get(1511),user_year, user_mon, user_day, user_hour, user_minute, 

  00b23	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00b26	6b 08 1c	 imul	 ecx, DWORD PTR [eax], 28
  00b29	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00b2f	e8 00 00 00 00	 call	 ?GetRestPoint@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestPoint
  00b34	50		 push	 eax
  00b35	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00b38	6b 09 1c	 imul	 ecx, DWORD PTR [ecx], 28
  00b3b	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00b41	e8 00 00 00 00	 call	 ?GetRestTime@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestTime
  00b46	33 d2		 xor	 edx, edx
  00b48	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00b4d	f7 f1		 div	 ecx
  00b4f	52		 push	 edx
  00b50	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00b53	6b 0a 1c	 imul	 ecx, DWORD PTR [edx], 28
  00b56	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00b5c	e8 00 00 00 00	 call	 ?GetRestTime@BILL_CLASS@@QAEKXZ ; BILL_CLASS::GetRestTime
  00b61	33 d2		 xor	 edx, edx
  00b63	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00b68	f7 f1		 div	 ecx
  00b6a	50		 push	 eax
  00b6b	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR _user_minute$16[ebp]
  00b71	52		 push	 edx
  00b72	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR _user_hour$17[ebp]
  00b78	50		 push	 eax
  00b79	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _user_day$18[ebp]
  00b7f	51		 push	 ecx
  00b80	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR _user_mon$19[ebp]
  00b86	52		 push	 edx
  00b87	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _user_year$20[ebp]
  00b8d	50		 push	 eax
  00b8e	68 e7 05 00 00	 push	 1511			; 000005e7H
  00b93	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00b98	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00b9e	50		 push	 eax
  00b9f	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _szMsg$[ebp]
  00ba5	51		 push	 ecx
  00ba6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00bac	83 c4 28	 add	 esp, 40			; 00000028H
$LN2@gObjBillRe:

; 5828 : 					m_ObjBill[lpObj->m_Index].GetRestTime() / 60, m_ObjBill[lpObj->m_Index].GetRestTime() % 60, m_ObjBill[lpObj->m_Index].GetRestPoint());
; 5829 : 			}		
; 5830 : 		}
; 5831 : 		break;
; 5832 : 	default:
; 5833 : 		break;
; 5834 : 	}
; 5835 : 	LogAdd(szMsg);

  00baf	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _szMsg$[ebp]
  00bb5	50		 push	 eax
  00bb6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00bbc	83 c4 04	 add	 esp, 4

; 5836 : 	GCServerMsgStringSend(szMsg, lpObj->m_Index, 1);

  00bbf	6a 01		 push	 1
  00bc1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00bc4	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bc6	51		 push	 ecx
  00bc7	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _szMsg$[ebp]
  00bcd	52		 push	 edx
  00bce	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00bd3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN22@gObjBillRe:

; 5837 : }

  00bd6	5f		 pop	 edi
  00bd7	5e		 pop	 esi
  00bd8	5b		 pop	 ebx
  00bd9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bdc	33 cd		 xor	 ecx, ebp
  00bde	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00be3	8b e5		 mov	 esp, ebp
  00be5	5d		 pop	 ebp
  00be6	c3		 ret	 0
  00be7	90		 npad	 1
$LN53@gObjBillRe:
  00be8	00 00 00 00	 DD	 $LN4@gObjBillRe
  00bec	00 00 00 00	 DD	 $LN5@gObjBillRe
  00bf0	00 00 00 00	 DD	 $LN6@gObjBillRe
  00bf4	00 00 00 00	 DD	 $LN11@gObjBillRe
  00bf8	00 00 00 00	 DD	 $LN16@gObjBillRe
?gObjBillRequest@@YAXPAVOBJECTSTRUCT@@@Z ENDP		; gObjBillRequest
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGetSocket@@YAHI@Z
_TEXT	SEGMENT
_n$1 = -4						; size = 4
_socket$ = 8						; size = 4
?gObjGetSocket@@YAHI@Z PROC				; gObjGetSocket, COMDAT

; 2227 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2228 : 	for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)

  00009	c7 45 fc 00 19
	00 00		 mov	 DWORD PTR _n$1[ebp], 6400 ; 00001900H
  00010	eb 09		 jmp	 SHORT $LN4@gObjGetSoc
$LN2@gObjGetSoc:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _n$1[ebp], eax
$LN4@gObjGetSoc:
  0001b	81 7d fc e8 1c
	00 00		 cmp	 DWORD PTR _n$1[ebp], 7400 ; 00001ce8H
  00022	7d 31		 jge	 SHORT $LN3@gObjGetSoc

; 2229 : 	{
; 2230 : 		if( gObj[n].Connected )

  00024	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00031	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  00036	74 1b		 je	 SHORT $LN5@gObjGetSoc

; 2231 : 		{
; 2232 : 			if( gObj[n].m_socket == socket )

  00038	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$1[ebp], 7072
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00045	8b 54 01 14	 mov	 edx, DWORD PTR [ecx+eax+20]
  00049	3b 55 08	 cmp	 edx, DWORD PTR _socket$[ebp]
  0004c	75 05		 jne	 SHORT $LN5@gObjGetSoc

; 2233 : 			{
; 2234 : 				return n;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR _n$1[ebp]
  00051	eb 05		 jmp	 SHORT $LN1@gObjGetSoc
$LN5@gObjGetSoc:

; 2235 : 			}
; 2236 : 		}
; 2237 : 	}

  00053	eb bd		 jmp	 SHORT $LN2@gObjGetSoc
$LN3@gObjGetSoc:

; 2238 : 	return -1;

  00055	83 c8 ff	 or	 eax, -1
$LN1@gObjGetSoc:

; 2239 : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?gObjGetSocket@@YAHI@Z ENDP				; gObjGetSocket
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGameClose@@YAHH@Z
_TEXT	SEGMENT
tv235 = -84						; size = 4
tv179 = -84						; size = 4
tv236 = -80						; size = 4
tv180 = -80						; size = 4
_pMsg$1 = -12						; size = 4
_pindex$2 = -8						; size = 4
_lpObj$ = -4						; size = 4
_aIndex$ = 8						; size = 4
?gObjGameClose@@YAHH@Z PROC				; gObjGameClose, COMDAT

; 5986 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5987 : 	if( aIndex < 0 || aIndex > MAX_OBJECT ) {

  00009	83 7d 08 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@gObjGameCl
  0000f	81 7d 08 e8 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7400 ; 00001ce8H
  00016	7e 28		 jle	 SHORT $LN2@gObjGameCl
$LN3@gObjGameCl:

; 5988 : 		LogAdd("(%s)(%d) = index over error (%d)", __FILE__, __LINE__, aIndex);

  00018	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0001b	50		 push	 eax
  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??gObjGameClose@@YAHH@Z@4JA
  00022	83 c1 02	 add	 ecx, 2
  00025	51		 push	 ecx
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PNMAPJFE@?$CI?$CFs?$CJ?$CI?$CFd?$CJ?5?$DN?5index?5over?5error?5?$CI?$CFd@
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00036	83 c4 10	 add	 esp, 16			; 00000010H

; 5989 : 		return 0;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 5b 04 00 00	 jmp	 $LN1@gObjGameCl
$LN2@gObjGameCl:

; 5990 : 	}
; 5991 : 	LPOBJECTSTRUCT	lpObj = (LPOBJECTSTRUCT)&gObj[aIndex];

  00040	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00047	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004d	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 5992 : 	
; 5993 : 	//     ..
; 5994 : 	if( lpObj->Connected != CSS_GAMEPLAYING ) 

  00050	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00053	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00057	74 07		 je	 SHORT $LN4@gObjGameCl

; 5995 : 	{
; 5996 : 		return FALSE;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 3b 04 00 00	 jmp	 $LN1@gObjGameCl
$LN4@gObjGameCl:

; 5997 : 	}
; 5998 : 	if( lpObj->Type != OBJTYPE_CHARACTER ) 

  00060	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00063	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00067	83 f9 01	 cmp	 ecx, 1
  0006a	74 2f		 je	 SHORT $LN5@gObjGameCl

; 5999 : 	{
; 6000 : 		LogAddTD(lMsg.Get(515), lpObj->AccountID, lpObj->Name );

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006f	83 c0 73	 add	 eax, 115		; 00000073H
  00072	50		 push	 eax
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00076	83 c1 68	 add	 ecx, 104		; 00000068H
  00079	51		 push	 ecx
  0007a	68 03 02 00 00	 push	 515			; 00000203H
  0007f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0008a	50		 push	 eax
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6001 : 		return FALSE;

  00094	33 c0		 xor	 eax, eax
  00096	e9 00 04 00 00	 jmp	 $LN1@gObjGameCl
$LN5@gObjGameCl:

; 6002 : 	}
; 6003 : 
; 6004 : #ifdef PCBANG_KUZIMO
; 6005 : 	lpObj->m_kWeeklyTimer.Release();
; 6006 : #endif
; 6007 : 	
; 6008 : 
; 6009 : #ifdef MU_CHN_HACKLOG_MODIFY_20040930 //     5    .
; 6010 : 	#ifdef CHECK_ATTACK_AREA
; 6011 : 	if( lpObj->m_NotAttackAreaCount > 5 )	{
; 6012 : 		INT iCheckTickCount = (GetTickCount() - lpObj->AutoSaveTime) / 1000;
; 6013 : 		if (iCheckTickCount < 1)
; 6014 : 			iCheckTickCount = 1;
; 6015 : 		#ifdef CHINA_HACKUSER_KICK_SYSTEM		
; 6016 : 				ChinaHackLogFile.Output("[%s][%s] Try Attack In Not Attack Area (%d)", 
; 6017 : 										  lpObj->AccountID, 
; 6018 : 										  lpObj->Name, 
; 6019 : 										  lpObj->m_NotAttackAreaCount * 1000 / iCheckTickCount);
; 6020 : 		#else // else CHINA_HACKUSER_KICK_SYSTEM		
; 6021 : 				LogAddTD("[%s][%s] Try Attack In Not Attack Area (%d)", 
; 6022 : 						  lpObj->AccountID, 
; 6023 : 						  lpObj->Name, 
; 6024 : 						  lpObj->m_NotAttackAreaCount * 1000 / iCheckTickCount);
; 6025 : 		#endif // CHINA_HACKUSER_KICK_SYSTEM		
; 6026 : 	}
; 6027 : 	#endif // CHECK_ATTACK_AREA
; 6028 : #endif
; 6029 : 
; 6030 : #ifdef MU_CHN_HACKLOG3_MODIFY_20041117  //     5    .
; 6031 : 	#ifdef CHECK_ATTACK_AREA
; 6032 : 	if( lpObj->m_NotAttackAreaCount > 5 )	{
; 6033 : 		INT iCheckTickCount = (GetTickCount() - lpObj->AutoSaveTime) / 1000;
; 6034 : 		if (iCheckTickCount < 1)
; 6035 : 			iCheckTickCount = 1;		
; 6036 : 		#ifdef CHINA_HACKUSER_KICK_SYSTEM		
; 6037 : 			ChinaHackLogFile.Output("[%s][%s] Try Attack In Not Attack Area (%d)", 
; 6038 : 									  lpObj->AccountID, 
; 6039 : 									  lpObj->Name, 
; 6040 : 									  lpObj->m_NotAttackAreaCount * 1000 / iCheckTickCount
; 6041 : 									  );
; 6042 : 		#else // else CHINA_HACKUSER_KICK_SYSTEM
; 6043 : 			LogAddTD("[%s][%s] Try Attack In Not Attack Area (%d, %d)", 
; 6044 : 					  lpObj->AccountID, 
; 6045 : 					  lpObj->Name, 
; 6046 : 					  lpObj->m_NotAttackAreaCount,
; 6047 : 					  (GetTickCount()-lpObj->dwPlayTime)/1000 );
; 6048 : 		#endif // CHINA_HACKUSER_KICK_SYSTEM
; 6049 : 	}
; 6050 : 	#endif // CHECK_ATTACK_AREA
; 6051 : #endif
; 6052 : 
; 6053 : #ifdef MODIFY_HACKLOG_OF_ATTACK_20050518 //     5    .
; 6054 : 	#ifdef CHECK_ATTACK_AREA
; 6055 : 	if( lpObj->m_NotAttackAreaCount > 5 )	{
; 6056 : 		
; 6057 : 		#ifdef CHINA_HACKUSER_KICK_SYSTEM
; 6058 : 			INT iCheckTickCount = (GetTickCount() - lpObj->AutoSaveTime) / 1000;
; 6059 : 			if (iCheckTickCount < 1)
; 6060 : 				iCheckTickCount = 1;
; 6061 : 			ChinaHackLogFile.Output("[%s][%s] Try Attack In Not Attack Area (%d) @%d", 
; 6062 : 									  lpObj->AccountID, 
; 6063 : 									  lpObj->Name, 
; 6064 : 									  lpObj->m_NotAttackAreaCount * 1000 / iCheckTickCount,
; 6065 : 									  lpObj->MapNumber);
; 6066 : 		#else // else CHINA_HACKUSER_KICK_SYSTEM
; 6067 : 			LogAddTD("[%s][%s] Try Attack In Not Attack Area (%d, %d) @%d", 
; 6068 : 					  lpObj->AccountID, 
; 6069 : 					  lpObj->Name,
; 6070 : 					  lpObj->m_NotAttackAreaCount,
; 6071 : 					  (GetTickCount()-lpObj->dwPlayTime)/1000,
; 6072 : 					  lpObj->MapNumber);
; 6073 : 		#endif // CHINA_HACKUSER_KICK_SYSTEM
; 6074 : 	}
; 6075 : 	#endif // CHECK_ATTACK_AREA
; 6076 : 
; 6077 : #endif // MU_CHN_HACKLOG_MODIFY_20040930 || MU_CHN_HACKLOG3_MODIFY_20041117
; 6078 : 	
; 6079 : 	//if( lpObj->Class == CLASS_ELF )
; 6080 : 	{
; 6081 : 		if( lpObj->m_RecallMon >= 0 ) gObjMonsterCallKill(lpObj->m_Index);

  0009b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009e	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  000a5	7c 0e		 jl	 SHORT $LN6@gObjGameCl
  000a7	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ac	51		 push	 ecx
  000ad	e8 00 00 00 00	 call	 ?gObjMonsterCallKill@@YAXH@Z ; gObjMonsterCallKill
  000b2	83 c4 04	 add	 esp, 4
$LN6@gObjGameCl:

; 6082 : 	}
; 6083 : 
; 6084 : 
; 6085 : 	gObjMagicTextSave(lpObj);

  000b5	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ?gObjMagicTextSave@@YAXPAVOBJECTSTRUCT@@@Z ; gObjMagicTextSave
  000be	83 c4 04	 add	 esp, 4

; 6086 : 
; 6087 : #ifdef CHAOS_MIX_TRANSACTION_BUXFIX_20040610		//       RollBack / Commit  .
; 6088 : #ifdef DARKLORD_WORK
; 6089 : 	if ( (lpObj->m_IfState.use && lpObj->m_IfState.type == I_CHAOSBOX) || 

  000c1	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c4	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000ca	80 e1 03	 and	 cl, 3
  000cd	0f b6 d1	 movzx	 edx, cl
  000d0	85 d2		 test	 edx, edx
  000d2	74 17		 je	 SHORT $LN9@gObjGameCl
  000d4	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d7	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000dd	c0 e9 04	 shr	 cl, 4
  000e0	80 e1 0f	 and	 cl, 15			; 0000000fH
  000e3	0f b6 d1	 movzx	 edx, cl
  000e6	83 fa 07	 cmp	 edx, 7
  000e9	74 2a		 je	 SHORT $LN8@gObjGameCl
$LN9@gObjGameCl:
  000eb	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ee	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  000f4	80 e1 03	 and	 cl, 3
  000f7	0f b6 d1	 movzx	 edx, cl
  000fa	85 d2		 test	 edx, edx
  000fc	74 40		 je	 SHORT $LN7@gObjGameCl
  000fe	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00101	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00107	c0 e9 04	 shr	 cl, 4
  0010a	80 e1 0f	 and	 cl, 15			; 0000000fH
  0010d	0f b6 d1	 movzx	 edx, cl
  00110	83 fa 0d	 cmp	 edx, 13			; 0000000dH
  00113	75 29		 jne	 SHORT $LN7@gObjGameCl
$LN8@gObjGameCl:

; 6090 : 		(lpObj->m_IfState.use && lpObj->m_IfState.type == I_DARK_TRAINER) ) {	
; 6091 : #else
; 6092 : 	if (lpObj->m_IfState.use && lpObj->m_IfState.type == I_CHAOSBOX) {
; 6093 : #endif
; 6094 : 
; 6095 : #ifdef MODIFY_CASTLE_NPC_UPGRADE_PROCESS_20060619
; 6096 : 		if( lpObj->bIsChaosMixCompleted == true || lpObj->m_bIsCastleNPCUpgradeCompleted == true ) 
; 6097 : 		{
; 6098 : #else
; 6099 : 		if (lpObj->bIsChaosMixCompleted == true) {

  00115	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00118	0f b6 88 81 10
	00 00		 movzx	 ecx, BYTE PTR [eax+4225]
  0011f	83 f9 01	 cmp	 ecx, 1
  00122	75 0e		 jne	 SHORT $LN10@gObjGameCl

; 6100 : #endif
; 6101 : 			gObjInventoryCommit(aIndex);

  00124	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 ?gObjInventoryCommit@@YAHH@Z ; gObjInventoryCommit
  0012d	83 c4 04	 add	 esp, 4

; 6102 : 		}

  00130	eb 0c		 jmp	 SHORT $LN7@gObjGameCl
$LN10@gObjGameCl:

; 6103 : 		else {
; 6104 : 			gObjInventoryRollback(aIndex);

  00132	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 ?gObjInventoryRollback@@YAHH@Z ; gObjInventoryRollback
  0013b	83 c4 04	 add	 esp, 4
$LN7@gObjGameCl:

; 6105 : 		}
; 6106 : 	}
; 6107 : #endif
; 6108 : 
; 6109 : 	// Trade ..
; 6110 : 	gObjTradeSave(lpObj, aIndex);

  0013e	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00141	50		 push	 eax
  00142	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00145	51		 push	 ecx
  00146	e8 00 00 00 00	 call	 ?gObjTradeSave@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjTradeSave
  0014b	83 c4 08	 add	 esp, 8

; 6111 : 
; 6112 : #ifdef SECOND_QUEST
; 6113 : 	if( lpObj->m_IfState.use && lpObj->m_IfState.type == I_QUEST && lpObj->TargetShopNumber == NPC_QEUSTNPC2 )

  0014e	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00151	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00157	80 e1 03	 and	 cl, 3
  0015a	0f b6 d1	 movzx	 edx, cl
  0015d	85 d2		 test	 edx, edx
  0015f	74 33		 je	 SHORT $LN12@gObjGameCl
  00161	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00164	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0016a	c0 e9 04	 shr	 cl, 4
  0016d	80 e1 0f	 and	 cl, 15			; 0000000fH
  00170	0f b6 d1	 movzx	 edx, cl
  00173	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00176	75 1c		 jne	 SHORT $LN12@gObjGameCl
  00178	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017b	0f bf 88 ae 02
	00 00		 movsx	 ecx, WORD PTR [eax+686]
  00182	81 f9 e5 00 00
	00		 cmp	 ecx, 229		; 000000e5H
  00188	75 0a		 jne	 SHORT $LN12@gObjGameCl

; 6114 : 	{	//     NPC 2  NPC
; 6115 : 		gQeustNpcTeleport.TalkRefDel();

  0018a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gQeustNpcTeleport@@3VCQeustNpcTeleport@@A ; gQeustNpcTeleport
  0018f	e8 00 00 00 00	 call	 ?TalkRefDel@CQeustNpcTeleport@@QAEXXZ ; CQeustNpcTeleport::TalkRefDel
$LN12@gObjGameCl:

; 6116 : 	}
; 6117 : #endif
; 6118 : /*
; 6119 : #ifdef UPDATE_GM_FUNCTION_20070228
; 6120 : 	if( (lpObj->Authority&AUTHORITY_ADMIN) != AUTHORITY_ADMIN
; 6121 : 		&& (lpObj->Authority&AUTHORITY_EVENT_GM) != AUTHORITY_EVENT_GM )
; 6122 : #else
; 6123 : 	if( (lpObj->Authority&AUTHORITY_ADMIN) == AUTHORITY_ADMIN )
; 6124 : #endif
; 6125 : */
; 6126 : 	if( CheckAuthority(AUTHORITY_SUPER_ADMIN | AUTHORITY_ADMIN | AUTHORITY_EVENT_GM, lpObj) == true )

  00194	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00197	50		 push	 eax
  00198	6a 62		 push	 98			; 00000062H
  0019a	e8 00 00 00 00	 call	 ?CheckAuthority@@YA_NKPAVOBJECTSTRUCT@@@Z ; CheckAuthority
  0019f	83 c4 08	 add	 esp, 8
  001a2	0f b6 c8	 movzx	 ecx, al
  001a5	83 f9 01	 cmp	 ecx, 1
  001a8	75 11		 jne	 SHORT $LN13@gObjGameCl

; 6127 : 	{
; 6128 : 		cManager.ManagerDel(lpObj->Name);

  001aa	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001ad	83 c0 73	 add	 eax, 115		; 00000073H
  001b0	50		 push	 eax
  001b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  001b6	e8 00 00 00 00	 call	 ?ManagerDel@CGMMng@@QAEXPAD@Z ; CGMMng::ManagerDel
$LN13@gObjGameCl:

; 6129 : 	}
; 6130 : 
; 6131 : #ifdef DUEL_SYSTEM_20031028
; 6132 : 
; 6133 : 	#ifdef ADD_NEWPVP_PKFIELD
; 6134 : 	g_NewPVP.Reset(*lpObj);
; 6135 : 	#else
; 6136 : 	if (CHECK_LIMIT(lpObj->m_iDuelUserRequested, MAX_OBJECT)) {

  001bb	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001be	83 b8 e8 0c 00
	00 00		 cmp	 DWORD PTR [eax+3304], 0
  001c5	7d 09		 jge	 SHORT $LN29@gObjGameCl
  001c7	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv180[ebp], 0
  001ce	eb 25		 jmp	 SHORT $LN30@gObjGameCl
$LN29@gObjGameCl:
  001d0	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001d3	81 b9 e8 0c 00
	00 e7 1c 00 00	 cmp	 DWORD PTR [ecx+3304], 7399 ; 00001ce7H
  001dd	7e 09		 jle	 SHORT $LN27@gObjGameCl
  001df	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv179[ebp], 0
  001e6	eb 07		 jmp	 SHORT $LN28@gObjGameCl
$LN27@gObjGameCl:
  001e8	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv179[ebp], 1
$LN28@gObjGameCl:
  001ef	8b 55 ac	 mov	 edx, DWORD PTR tv179[ebp]
  001f2	89 55 b0	 mov	 DWORD PTR tv180[ebp], edx
$LN30@gObjGameCl:
  001f5	83 7d b0 00	 cmp	 DWORD PTR tv180[ebp], 0
  001f9	74 1c		 je	 SHORT $LN14@gObjGameCl

; 6137 : 		//     ->     
; 6138 : 		gObjSendDuelEnd(&gObj[lpObj->m_iDuelUserRequested]);

  001fb	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001fe	69 88 e8 0c 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR [eax+3304], 7072
  00208	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 ?gObjSendDuelEnd@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSendDuelEnd
  00214	83 c4 04	 add	 esp, 4
$LN14@gObjGameCl:

; 6139 : 	}
; 6140 : 	
; 6141 : 	if (gObjDuelCheck(lpObj)) {		

  00217	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0021a	50		 push	 eax
  0021b	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@@Z ; gObjDuelCheck
  00220	83 c4 04	 add	 esp, 4
  00223	85 c0		 test	 eax, eax
  00225	74 1c		 je	 SHORT $LN15@gObjGameCl

; 6142 : 		//    ->     
; 6143 : 		
; 6144 : #ifdef WORLD_TOURNAMENT_EVENT_SETTING		
; 6145 : 		gObj[lpObj->m_iDuelUser].m_btDuelScore = max(gObj[lpObj->m_iDuelUser].m_btDuelScore, lpObj->m_btDuelScore+1);
; 6146 : #endif	
; 6147 : 		gObjSendDuelEnd(&gObj[lpObj->m_iDuelUser]);

  00227	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0022a	69 88 ec 0c 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR [eax+3308], 7072
  00234	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0023a	51		 push	 ecx
  0023b	e8 00 00 00 00	 call	 ?gObjSendDuelEnd@@YAXPAVOBJECTSTRUCT@@@Z ; gObjSendDuelEnd
  00240	83 c4 04	 add	 esp, 4
$LN15@gObjGameCl:

; 6148 : 	}
; 6149 : 	#endif // ADD_NEWPVP_PKFIELD
; 6150 : 	gObjResetDuel(lpObj);

  00243	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00246	50		 push	 eax
  00247	e8 00 00 00 00	 call	 ?gObjResetDuel@@YAXPAVOBJECTSTRUCT@@@Z ; gObjResetDuel
  0024c	83 c4 04	 add	 esp, 4

; 6151 : 
; 6152 : #endif // DUEL_SYSTEM_20031028
; 6153 : 
; 6154 : #ifdef MODIFY_GAMEGUARD_NOT_AUTH_MAPSERVER_MOVE_20060513
; 6155 : 	lpObj->m_bCheckGGAuth = true;
; 6156 : #endif
; 6157 : 
; 6158 : 	//   ..
; 6159 : 	if( lpObj->PartyNumber >= 0 )

  0024f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00252	83 b8 88 02 00
	00 00		 cmp	 DWORD PTR [eax+648], 0
  00259	7c 42		 jl	 SHORT $LN16@gObjGameCl

; 6160 : 	{
; 6161 : 		//        . (apple)
; 6162 : 		// PartyClass::PartyMemberLifeSend()   5,4,3,2,1        .
; 6163 : 		int pindex = gParty.GetIndex(lpObj->PartyNumber, lpObj->m_Index, lpObj->DBNumber);

  0025b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0025e	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00261	51		 push	 ecx
  00262	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00265	8b 02		 mov	 eax, DWORD PTR [edx]
  00267	50		 push	 eax
  00268	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0026b	8b 91 88 02 00
	00		 mov	 edx, DWORD PTR [ecx+648]
  00271	52		 push	 edx
  00272	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  00277	e8 00 00 00 00	 call	 ?GetIndex@PartyClass@@QAEHHHH@Z ; PartyClass::GetIndex
  0027c	89 45 f8	 mov	 DWORD PTR _pindex$2[ebp], eax

; 6164 : 		if( pindex >= 0 )

  0027f	83 7d f8 00	 cmp	 DWORD PTR _pindex$2[ebp], 0
  00283	7c 18		 jl	 SHORT $LN16@gObjGameCl

; 6165 : 		{
; 6166 : 			PMSG_PARTYDELUSER pMsg;
; 6167 : 			pMsg.Number = pindex;

  00285	8a 45 f8	 mov	 al, BYTE PTR _pindex$2[ebp]
  00288	88 45 f7	 mov	 BYTE PTR _pMsg$1[ebp+3], al

; 6168 : 			CGPartyDelUser( &pMsg, lpObj->m_Index);

  0028b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00290	51		 push	 ecx
  00291	8d 55 f4	 lea	 edx, DWORD PTR _pMsg$1[ebp]
  00294	52		 push	 edx
  00295	e8 00 00 00 00	 call	 ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ; CGPartyDelUser
  0029a	83 c4 08	 add	 esp, 8
$LN16@gObjGameCl:

; 6169 : 		}		
; 6170 : 	}
; 6171 : 
; 6172 : #ifdef __FRIEND_WORK__
; 6173 : 	//   ..
; 6174 : 	if( lpObj->GuildNumber > 0 )

  0029d	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002a0	83 b8 90 02 00
	00 00		 cmp	 DWORD PTR [eax+656], 0
  002a7	7e 41		 jle	 SHORT $LN18@gObjGameCl

; 6175 : 	{
; 6176 : 		if( lpObj->lpGuild->WarState == 1 )

  002a9	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ac	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  002b2	0f b6 91 91 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1425]
  002b9	83 fa 01	 cmp	 edx, 1
  002bc	75 0c		 jne	 SHORT $LN20@gObjGameCl

; 6177 : 		{
; 6178 : 			gObjGuildWarMasterClose(lpObj);

  002be	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c1	50		 push	 eax
  002c2	e8 00 00 00 00	 call	 ?gObjGuildWarMasterClose@@YAHPAVOBJECTSTRUCT@@@Z ; gObjGuildWarMasterClose
  002c7	83 c4 04	 add	 esp, 4
$LN20@gObjGameCl:

; 6179 : 		}
; 6180 : 		GDCharClose(0, lpObj->lpGuild->Name, lpObj->Name);	//#BUGFIX_20040218_01

  002ca	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002cd	83 c0 73	 add	 eax, 115		; 00000073H
  002d0	50		 push	 eax
  002d1	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002d4	8b 91 94 02 00
	00		 mov	 edx, DWORD PTR [ecx+660]
  002da	83 c2 04	 add	 edx, 4
  002dd	52		 push	 edx
  002de	6a 00		 push	 0
  002e0	e8 00 00 00 00	 call	 ?GDCharClose@@YAXHPAD0@Z ; GDCharClose
  002e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6181 : 	}

  002e8	eb 13		 jmp	 SHORT $LN19@gObjGameCl
$LN18@gObjGameCl:

; 6182 : 	else GDCharClose(1, NULL, lpObj->Name);	//#BUGFIX_20040218_01

  002ea	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002ed	83 c0 73	 add	 eax, 115		; 00000073H
  002f0	50		 push	 eax
  002f1	6a 00		 push	 0
  002f3	6a 01		 push	 1
  002f5	e8 00 00 00 00	 call	 ?GDCharClose@@YAXHPAD0@Z ; GDCharClose
  002fa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@gObjGameCl:

; 6183 : #endif
; 6184 : 
; 6185 : 	//   ...  
; 6186 : 	if( lpObj->WarehouseSave == TRUE )

  002fd	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00300	83 b8 a8 0c 00
	00 01		 cmp	 DWORD PTR [eax+3240], 1
  00307	75 0e		 jne	 SHORT $LN21@gObjGameCl

; 6187 : 	{
; 6188 : 		// 2002/09/09     .
; 6189 : 		/*if( lpObj->m_IfState.type == I_WAREHOUSE && 
; 6190 : 			lpObj->m_IfState.state == 1 )
; 6191 : 		{*/
; 6192 : 			GDSetWarehouseList(lpObj->m_Index);

  00309	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0030c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030e	51		 push	 ecx
  0030f	e8 00 00 00 00	 call	 ?GDSetWarehouseList@@YAXH@Z ; GDSetWarehouseList
  00314	83 c4 04	 add	 esp, 4
$LN21@gObjGameCl:

; 6193 : 		//}
; 6194 : 	}	
; 6195 : 
; 6196 : #ifdef FOR_BLOODCASTLE
; 6197 : 	if (CHECK_BLOODCASTLE(lpObj->MapNumber)) {					// DB     .

  00317	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0031a	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00321	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00324	7d 09		 jge	 SHORT $LN33@gObjGameCl
  00326	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv236[ebp], 0
  0032d	eb 25		 jmp	 SHORT $LN34@gObjGameCl
$LN33@gObjGameCl:
  0032f	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00332	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00339	83 f8 11	 cmp	 eax, 17			; 00000011H
  0033c	7e 09		 jle	 SHORT $LN31@gObjGameCl
  0033e	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv235[ebp], 0
  00345	eb 07		 jmp	 SHORT $LN32@gObjGameCl
$LN31@gObjGameCl:
  00347	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv235[ebp], 1
$LN32@gObjGameCl:
  0034e	8b 4d ac	 mov	 ecx, DWORD PTR tv235[ebp]
  00351	89 4d b0	 mov	 DWORD PTR tv236[ebp], ecx
$LN34@gObjGameCl:
  00354	83 7d b0 00	 cmp	 DWORD PTR tv236[ebp], 0
  00358	74 10		 je	 SHORT $LN22@gObjGameCl

; 6198 : 		g_BloodCastle.SearchUserDropQuestItem(lpObj->m_Index);

  0035a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0035d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0035f	51		 push	 ecx
  00360	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  00365	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem
$LN22@gObjGameCl:

; 6199 : 	}
; 6200 : #endif
; 6201 : 	
; 6202 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328		// DB       
; 6203 : 		if(CHECK_ILLUSION_TEMPLE(lpObj->MapNumber))
; 6204 : 		{
; 6205 : 			g_IllusionTempleEvent.DropRelicsItem(lpObj->MapNumber, lpObj->m_Index);
; 6206 : 			g_IllusionTempleEvent.LeaveIllusionTemple(lpObj->m_Index, lpObj->MapNumber);
; 6207 : 		}
; 6208 : #endif
; 6209 : 
; 6210 : #ifdef MODIFY_SAVE_CHAOSBOX_ITEMLIST_AT_LOGOUT_20070328
; 6211 : 	gObjSaveChaosBoxItemList( lpObj );
; 6212 : #endif // MODIFY_SAVE_CHAOSBOX_ITEMLIST_AT_LOGOUT_20070328
; 6213 : 
; 6214 : #ifdef ITEM_DUPLICATE_PREVENT_PATCH_20040719		//    -   
; 6215 : 	if (gObjFixInventoryPointer(aIndex) == false) {

  0036a	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0036d	50		 push	 eax
  0036e	e8 00 00 00 00	 call	 ?gObjFixInventoryPointer@@YA_NH@Z ; gObjFixInventoryPointer
  00373	83 c4 04	 add	 esp, 4
  00376	0f b6 c8	 movzx	 ecx, al
  00379	85 c9		 test	 ecx, ecx
  0037b	75 1e		 jne	 SHORT $LN23@gObjGameCl

; 6216 : 		LogAdd("[Fix Inv.Ptr] False Location - %s, %d", __FILE__, __LINE__);

  0037d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjGameClose@@YAHH@Z@4JA
  00382	05 e6 00 00 00	 add	 eax, 230		; 000000e6H
  00387	50		 push	 eax
  00388	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0038d	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NFDFKIHI@?$FLFix?5Inv?4Ptr?$FN?5False?5Location?5?9?5@
  00392	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00398	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN23@gObjGameCl:

; 6217 : 	}
; 6218 : #endif
; 6219 : 
; 6220 : #ifdef MODIFY_PERIODITEM_EFFECT_DURING_CLOSETIME_20070416
; 6221 : 	#ifdef MODIFY_PERIODITEM_SLOT_EXTEND_20070423
; 6222 : 	g_CashItemPeriodSystem.ClearPeriodItemEffect( lpObj, PERIOD_ITEM_CLEAR_ALL );
; 6223 : 	#else
; 6224 : 	g_CashItemPeriodSystem.GDReqPeriodItemUpdate( lpObj );
; 6225 : 	g_CashItemPeriodSystem.ClearPeriodItemEffect( lpObj );
; 6226 : 	#endif // MODIFY_PERIODITEM_SLOT_EXTEND_20070423
; 6227 : #endif // MODIFY_PERIODITEM_EFFECT_DURING_CLOSETIME_20070416
; 6228 : 
; 6229 : #ifdef MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 6230 : 	#ifdef MODIFY_BUFFSYSTEM_BUGFIX_02_20071204
; 6231 : 	gObjClearBuffEffect( lpObj, CLEAR_TYPE_LOGOUT );
; 6232 : 	#else
; 6233 : 	g_BuffEffectSlot.ClearEffect( lpObj, CLEAR_TYPE_LOGOUT );
; 6234 : 	#endif // MODIFY_BUFFSYSTEM_BUGFIX_02_20071204
; 6235 : #endif // MODIFY_BUFF_SYSTEM_EXTENTION_20070917
; 6236 : 
; 6237 : 	//  
; 6238 : 	GJSetCharacterInfo(lpObj, aIndex);

  0039b	6a 00		 push	 0
  0039d	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003a0	50		 push	 eax
  003a1	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003a4	51		 push	 ecx
  003a5	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAVOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo
  003aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6239 : 	
; 6240 : 	//  
; 6241 : 	gObjViewportClose(lpObj);

  003ad	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003b0	50		 push	 eax
  003b1	e8 00 00 00 00	 call	 ?gObjViewportClose@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportClose
  003b6	83 c4 04	 add	 esp, 4

; 6242 : 	LogAddTD(lMsg.Get(516), lpObj->m_Index, lpObj->AccountID, lpObj->Name);

  003b9	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003bc	83 c0 73	 add	 eax, 115		; 00000073H
  003bf	50		 push	 eax
  003c0	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003c3	83 c1 68	 add	 ecx, 104		; 00000068H
  003c6	51		 push	 ecx
  003c7	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  003ca	8b 02		 mov	 eax, DWORD PTR [edx]
  003cc	50		 push	 eax
  003cd	68 04 02 00 00	 push	 516			; 00000204H
  003d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  003d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  003dd	50		 push	 eax
  003de	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  003e4	83 c4 10	 add	 esp, 16			; 00000010H

; 6243 : 
; 6244 : #ifdef MODIFY_WHISPER_CASH_BUGFIX_20060704
; 6245 : 	if ( lpObj->Name != NULL )

  003e7	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003ea	83 c0 73	 add	 eax, 115		; 00000073H
  003ed	74 11		 je	 SHORT $LN24@gObjGameCl

; 6246 : 		WhisperCash.DelCash(lpObj->Name);

  003ef	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003f2	83 c0 73	 add	 eax, 115		; 00000073H
  003f5	50		 push	 eax
  003f6	b9 00 00 00 00	 mov	 ecx, OFFSET ?WhisperCash@@3VCWhisperCash@@A ; WhisperCash
  003fb	e8 00 00 00 00	 call	 ?DelCash@CWhisperCash@@QAEXPAD@Z ; CWhisperCash::DelCash
$LN24@gObjGameCl:

; 6247 : #endif // MODIFY_WHISPER_CASH_BUGFIX_20060704
; 6248 : 
; 6249 : #ifdef ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 6250 : 	g_CashShop.DeleteUser( lpObj );
; 6251 : #endif // ADD_PARTIALY_CHARGE_CASH_SHOP_20070117
; 6252 : 
; 6253 : #ifdef ADD_PARTIALY_CHARGE_PERIOD_SYSTEM_20070205
; 6254 : 	if( lpObj->m_iPeriodItemEffectIndex != -1 )
; 6255 : 	{
; 6256 : 	#ifdef MODIFY_PERIODITEM_SLOT_EXTEND_20070423
; 6257 : 		g_CashItemPeriodSystem.ClearPeriodItemEffect( lpObj, PERIOD_ITEM_CLEAR_ALL );
; 6258 : 	#else
; 6259 : 		g_CashItemPeriodSystem.GDReqPeriodItemUpdate( lpObj );
; 6260 : 		g_CashItemPeriodSystem.ClearPeriodItemEffect( lpObj );
; 6261 : 	#endif // MODIFY_PERIODITEM_SLOT_EXTEND_20070423
; 6262 : 	}
; 6263 : #endif // ADD_PARTIALY_CHARGE_PERIOD_SYSTEM_20070205
; 6264 : 	
; 6265 : #ifdef LOGINSERVER_MULOG
; 6266 : 	memcpy(lpObj->BackName, lpObj->Name, MAX_IDSTRING);

  00400	6a 0a		 push	 10			; 0000000aH
  00402	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00405	83 c0 73	 add	 eax, 115		; 00000073H
  00408	50		 push	 eax
  00409	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0040c	81 c1 dc 0e 00
	00		 add	 ecx, 3804		; 00000edcH
  00412	51		 push	 ecx
  00413	e8 00 00 00 00	 call	 _memcpy
  00418	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6267 : 	lpObj->BackName[MAX_IDSTRING] = 0;

  0041b	b8 01 00 00 00	 mov	 eax, 1
  00420	6b c8 0a	 imul	 ecx, eax, 10
  00423	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00426	c6 84 0a dc 0e
	00 00 00	 mov	 BYTE PTR [edx+ecx+3804], 0

; 6268 : #endif
; 6269 : 	
; 6270 : 	memset(lpObj->Name, 0, MAX_IDSTRING);

  0042e	6a 0a		 push	 10			; 0000000aH
  00430	6a 00		 push	 0
  00432	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00435	83 c0 73	 add	 eax, 115		; 00000073H
  00438	50		 push	 eax
  00439	e8 00 00 00 00	 call	 _memset
  0043e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6271 : 
; 6272 : 	lpObj->Connected = CSS_CHARACTERVIEW;

  00441	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00444	c7 40 04 02 00
	00 00		 mov	 DWORD PTR [eax+4], 2

; 6273 : 		
; 6274 : #ifdef UPDATE_RESEND_GETCHARlIST_DISABLE_20090605
; 6275 : 	lpObj->m_bRequestPaket		= FALSE;
; 6276 : 	lpObj->m_nRequestPacketCnt	= 0;
; 6277 : #endif	// UPDATE_RESEND_GETCHARlIST_DISABLE_20090605
; 6278 : 
; 6279 : #ifdef UPDATE_UNIFICATIONBILL_20090203
; 6280 : 	if(m_ObjBill[aIndex].GetDeductType() > BILL_TYPE_NONE && m_ObjBill[aIndex].GetDeductType() <= BILL_TYPE_COLLOR)

  0044b	6b 4d 08 1c	 imul	 ecx, DWORD PTR _aIndex$[ebp], 28
  0044f	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00455	e8 00 00 00 00	 call	 ?GetDeductType@BILL_CLASS@@QAEEXZ ; BILL_CLASS::GetDeductType
  0045a	0f b6 c0	 movzx	 eax, al
  0045d	85 c0		 test	 eax, eax
  0045f	7e 35		 jle	 SHORT $LN25@gObjGameCl
  00461	6b 4d 08 1c	 imul	 ecx, DWORD PTR _aIndex$[ebp], 28
  00465	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  0046b	e8 00 00 00 00	 call	 ?GetDeductType@BILL_CLASS@@QAEEXZ ; BILL_CLASS::GetDeductType
  00470	0f b6 c0	 movzx	 eax, al
  00473	83 f8 05	 cmp	 eax, 5
  00476	7f 1e		 jg	 SHORT $LN25@gObjGameCl

; 6281 : 		gLCount[m_ObjBill[aIndex].GetDeductType()].Delete();

  00478	6b 4d 08 1c	 imul	 ecx, DWORD PTR _aIndex$[ebp], 28
  0047c	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00482	e8 00 00 00 00	 call	 ?GetDeductType@BILL_CLASS@@QAEEXZ ; BILL_CLASS::GetDeductType
  00487	0f b6 c0	 movzx	 eax, al
  0048a	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR ?gLCount@@3PAVCLoginCount@@A[eax*4]
  00491	e8 00 00 00 00	 call	 ?Delete@CLoginCount@@QAEXXZ ; CLoginCount::Delete
$LN25@gObjGameCl:

; 6282 : #else	// UPDATE_UNIFICATIONBILL_20090203
; 6283 : 	if(m_ObjBill[aIndex].GetCertify()>=0&&m_ObjBill[aIndex].GetCertify()<MAX_LOGIN_COUNT)
; 6284 : 		gLCount[m_ObjBill[aIndex].GetCertify()].Delete();
; 6285 : #endif	// UPDATE_UNIFICATIONBILL_20090203
; 6286 : 
; 6287 : 	return TRUE;

  00496	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjGameCl:

; 6288 : }

  0049b	5f		 pop	 edi
  0049c	5e		 pop	 esi
  0049d	5b		 pop	 ebx
  0049e	8b e5		 mov	 esp, ebp
  004a0	5d		 pop	 ebp
  004a1	c3		 ret	 0
?gObjGameClose@@YAHH@Z ENDP				; gObjGameClose
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjDel@@YAFH@Z
_TEXT	SEGMENT
tv86 = -84						; size = 4
tv87 = -80						; size = 4
_UserConnectState$ = -12				; size = 4
_lpObj$ = -8						; size = 4
_i$ = -4						; size = 4
_index$ = 8						; size = 4
?gObjDel@@YAFH@Z PROC					; gObjDel, COMDAT

; 6294 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6295 : 	int i=0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 6296 : 	LPOBJECTSTRUCT	lpObj;
; 6297 : 	int UserConnectState;
; 6298 : 
; 6299 : 	if( index < 0 || index > MAX_OBJECT ) {

  00010	83 7d 08 00	 cmp	 DWORD PTR _index$[ebp], 0
  00014	7c 09		 jl	 SHORT $LN3@gObjDel
  00016	81 7d 08 e8 1c
	00 00		 cmp	 DWORD PTR _index$[ebp], 7400 ; 00001ce8H
  0001d	7e 28		 jle	 SHORT $LN2@gObjDel
$LN3@gObjDel:

; 6300 : 		LogAdd("(%s)(%d) = index over error (%d)", __FILE__, __LINE__, index);

  0001f	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00022	50		 push	 eax
  00023	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??gObjDel@@YAFH@Z@4JA
  00029	83 c1 06	 add	 ecx, 6
  0002c	51		 push	 ecx
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PNMAPJFE@?$CI?$CFs?$CJ?$CI?$CFd?$CJ?5?$DN?5index?5over?5error?5?$CI?$CFd@
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003d	83 c4 10	 add	 esp, 16			; 00000010H

; 6301 : 		return 0;

  00040	33 c0		 xor	 eax, eax
  00042	e9 0d 02 00 00	 jmp	 $LN1@gObjDel
$LN2@gObjDel:

; 6302 : 	}
; 6303 : 	lpObj = (LPOBJECTSTRUCT)&gObj[index];

  00047	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  0004e	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00054	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 6304 : 	if( lpObj->Connected < 1
; 6305 : #ifdef MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 6306 : 		&& lpObj->Connected != CSS_LOGINWAIT

  00057	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005a	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  0005e	7d 10		 jge	 SHORT $LN4@gObjDel
  00060	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00063	83 78 04 ff	 cmp	 DWORD PTR [eax+4], -1
  00067	74 07		 je	 SHORT $LN4@gObjDel

; 6307 : #endif // MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 6308 : 		)
; 6309 : 		return 0;

  00069	33 c0		 xor	 eax, eax
  0006b	e9 e4 01 00 00	 jmp	 $LN1@gObjDel
$LN4@gObjDel:

; 6310 : 	
; 6311 : #ifdef CLEAR_STANDATTR_OBJDEL_20050325
; 6312 : 	if (CHECK_LIMIT(lpObj->MapNumber, g_TerrainManager.Size())) {

  00070	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00073	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0007a	85 c9		 test	 ecx, ecx
  0007c	7d 09		 jge	 SHORT $LN13@gObjDel
  0007e	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
  00085	eb 31		 jmp	 SHORT $LN14@gObjDel
$LN13@gObjDel:
  00087	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0008a	0f b6 b2 09 01
	00 00		 movzx	 esi, BYTE PTR [edx+265]
  00091	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  00096	e8 00 00 00 00	 call	 ?Size@CTerrainManager@@QAE?BHXZ ; CTerrainManager::Size
  0009b	83 e8 01	 sub	 eax, 1
  0009e	3b f0		 cmp	 esi, eax
  000a0	7e 09		 jle	 SHORT $LN11@gObjDel
  000a2	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
  000a9	eb 07		 jmp	 SHORT $LN12@gObjDel
$LN11@gObjDel:
  000ab	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv86[ebp], 1
$LN12@gObjDel:
  000b2	8b 45 ac	 mov	 eax, DWORD PTR tv86[ebp]
  000b5	89 45 b0	 mov	 DWORD PTR tv87[ebp], eax
$LN14@gObjDel:
  000b8	83 7d b0 00	 cmp	 DWORD PTR tv87[ebp], 0
  000bc	74 62		 je	 SHORT $LN5@gObjDel

; 6313 : 		MapC[lpObj->MapNumber].ClearStandAttr(lpObj->m_OldX, lpObj->m_OldY);

  000be	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c1	0f bf 88 1e 01
	00 00		 movsx	 ecx, WORD PTR [eax+286]
  000c8	51		 push	 ecx
  000c9	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000cc	0f bf 82 1c 01
	00 00		 movsx	 eax, WORD PTR [edx+284]
  000d3	50		 push	 eax
  000d4	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000d7	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  000de	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  000e4	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000ea	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr

; 6314 : 		MapC[lpObj->MapNumber].ClearStandAttr(lpObj->X, lpObj->Y);

  000ef	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f2	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  000f9	51		 push	 ecx
  000fa	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000fd	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  00104	50		 push	 eax
  00105	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00108	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  0010f	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00115	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0011b	e8 00 00 00 00	 call	 ?ClearStandAttr@MapClass@@QAEXHH@Z ; MapClass::ClearStandAttr
$LN5@gObjDel:

; 6315 : 	}
; 6316 : #endif
; 6317 : 	
; 6318 : 	UserConnectState = lpObj->Connected;

  00120	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00123	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00126	89 4d f4	 mov	 DWORD PTR _UserConnectState$[ebp], ecx

; 6319 : 	if( lpObj->Type == OBJTYPE_CHARACTER )

  00129	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012c	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00130	83 f9 01	 cmp	 ecx, 1
  00133	0f 85 f5 00 00
	00		 jne	 $LN6@gObjDel

; 6320 : 	{		
; 6321 : 		if(lpObj->m_stateEngagePVP != PVP_USER_NONE)

  00139	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013c	83 b8 80 1a 00
	00 00		 cmp	 DWORD PTR [eax+6784], 0
  00143	74 0e		 je	 SHORT $LN7@gObjDel

; 6322 : 		{
; 6323 : 			g_PvpEvent.DeleteUser(index);

  00145	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00148	50		 push	 eax
  00149	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_PvpEvent@@3VCEngagePVP@@A ; g_PvpEvent
  0014e	e8 00 00 00 00	 call	 ?DeleteUser@CEngagePVP@@QAEXH@Z ; CEngagePVP::DeleteUser
$LN7@gObjDel:

; 6324 : 		}
; 6325 : 
; 6326 : 		gObjGameClose(index);

  00153	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 ?gObjGameClose@@YAHH@Z	; gObjGameClose
  0015c	83 c4 04	 add	 esp, 4

; 6327 : 		if( UserConnectState >= CSS_LOGINOK
; 6328 : #ifdef MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 6329 : 			|| UserConnectState == CSS_LOGINWAIT

  0015f	83 7d f4 02	 cmp	 DWORD PTR _UserConnectState$[ebp], 2
  00163	7d 06		 jge	 SHORT $LN9@gObjDel
  00165	83 7d f4 ff	 cmp	 DWORD PTR _UserConnectState$[ebp], -1
  00169	75 72		 jne	 SHORT $LN8@gObjDel
$LN9@gObjDel:

; 6330 : #endif // MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 6331 : 			)
; 6332 : 		{
; 6333 : 			//    .		
; 6334 : #ifdef MAP_SERVER_WORK_20041030					//         .
; 6335 : 			if (lpObj->m_bMapSvrMoveQuit == false) {
; 6336 : #endif
; 6337 : #ifdef LOGINSERVER_MULOG
; 6338 : 			GJPUserClose(lpObj);				//    .

  0016b	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 ?GJPUserClose@@YAXPAVOBJECTSTRUCT@@@Z ; GJPUserClose
  00174	83 c4 04	 add	 esp, 4

; 6339 : #else
; 6340 : #if defined(CHN_PLAYTIME_LIMIT_SYSTEM_20050818) || defined(VTM_PLAYTIME_LIMIT_SYSTEM_20060626)
; 6341 : 			GJPUserClose(lpObj->AccountID, lpObj->m_iPlayTimeLimit);
; 6342 : #else
; 6343 : 			GJPUserClose(lpObj->AccountID);		//    .
; 6344 : #endif
; 6345 : #endif
; 6346 : 			LogAddTD("(%d)logout-send : %s [%s]", index, lpObj->AccountID, lpObj->Ip_addr);

  00177	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017a	83 c0 18	 add	 eax, 24			; 00000018H
  0017d	50		 push	 eax
  0017e	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00181	83 c1 68	 add	 ecx, 104		; 00000068H
  00184	51		 push	 ecx
  00185	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  00188	52		 push	 edx
  00189	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@FHEGNDKC@?$CI?$CFd?$CJlogout?9send?5?3?5?$CFs?5?$FL?$CFs?$FN@
  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00194	83 c4 10	 add	 esp, 16			; 00000010H

; 6347 : 
; 6348 : #ifdef MODIFY_CONNNECT_HACK_ATTACK_20090409
; 6349 : 			LogAddTD_TempLog(", (%d)logout-send :, Account [%s], IP [%s]", index, lpObj->AccountID, lpObj->Ip_addr);

  00197	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0019a	83 c0 18	 add	 eax, 24			; 00000018H
  0019d	50		 push	 eax
  0019e	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001a1	83 c1 68	 add	 ecx, 104		; 00000068H
  001a4	51		 push	 ecx
  001a5	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  001a8	52		 push	 edx
  001a9	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@DMPMEDAE@?0?5?$CI?$CFd?$CJlogout?9send?5?3?0?5Account?5?$FL?$CF@
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD_TempLog@@3P6AXPADZZA ; LogAddTD_TempLog
  001b4	83 c4 10	 add	 esp, 16			; 00000010H

; 6350 : #endif
; 6351 : 
; 6352 : #ifdef MAP_SERVER_WORK_20041030
; 6353 : 			}
; 6354 : 			else {
; 6355 : 				LogAddTD("[MapServerMng] User Quit without JoinServer logout-send [%s][%s]",
; 6356 : 					lpObj->AccountID,
; 6357 : 					lpObj->Name
; 6358 : 					);
; 6359 : 			}
; 6360 : #endif
; 6361 : 
; 6362 : 			memset(lpObj->AccountID, 0, MAX_IDSTRING);

  001b7	6a 0a		 push	 10			; 0000000aH
  001b9	6a 00		 push	 0
  001bb	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001be	83 c0 68	 add	 eax, 104		; 00000068H
  001c1	50		 push	 eax
  001c2	e8 00 00 00 00	 call	 _memset
  001c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6363 : #ifdef UPDATE_USERPASSWORD_LENGTH_20090424
; 6364 : 			memset(lpObj->LastJoominNumber, 0, MAX_JOOMINNUMBER_LENGTH);
; 6365 : #else
; 6366 : 			memset(lpObj->LastJoominNumber, 0, 14);

  001ca	6a 0e		 push	 14			; 0000000eH
  001cc	6a 00		 push	 0
  001ce	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d1	83 c0 7e	 add	 eax, 126		; 0000007eH
  001d4	50		 push	 eax
  001d5	e8 00 00 00 00	 call	 _memset
  001da	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@gObjDel:

; 6367 : #endif	// UPDATE_USERPASSWORD_LENGTH_20090424
; 6368 : 
; 6369 : 		}
; 6370 : 		LogAddTD("(%d)logout : %s [%s]", index, lpObj->AccountID, lpObj->Ip_addr);

  001dd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001e0	83 c0 18	 add	 eax, 24			; 00000018H
  001e3	50		 push	 eax
  001e4	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001e7	83 c1 68	 add	 ecx, 104		; 00000068H
  001ea	51		 push	 ecx
  001eb	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  001ee	52		 push	 edx
  001ef	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FJCKJIOE@?$CI?$CFd?$CJlogout?5?3?5?$CFs?5?$FL?$CFs?$FN@
  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001fa	83 c4 10	 add	 esp, 16			; 00000010H

; 6371 : 
; 6372 : #ifdef MODIFY_CONNNECT_HACK_ATTACK_20090409
; 6373 : 		LogAddTD_TempLog(", (%d)logout :, Account [%s], IP [%s]", index, lpObj->AccountID, lpObj->Ip_addr);

  001fd	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00200	83 c0 18	 add	 eax, 24			; 00000018H
  00203	50		 push	 eax
  00204	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00207	83 c1 68	 add	 ecx, 104		; 00000068H
  0020a	51		 push	 ecx
  0020b	8b 55 08	 mov	 edx, DWORD PTR _index$[ebp]
  0020e	52		 push	 edx
  0020f	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@GAOPIMKK@?0?5?$CI?$CFd?$CJlogout?5?3?0?5Account?5?$FL?$CFs?$FN?0?5I@
  00214	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD_TempLog@@3P6AXPADZZA ; LogAddTD_TempLog
  0021a	83 c4 10	 add	 esp, 16			; 00000010H

; 6374 : #endif
; 6375 : 
; 6376 : 		IpCache.DelIp(lpObj->Ip_addr);

  0021d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00220	83 c0 18	 add	 eax, 24			; 00000018H
  00223	50		 push	 eax
  00224	b9 00 00 00 00	 mov	 ecx, OFFSET ?IpCache@@3VCIpCache@@A ; IpCache
  00229	e8 00 00 00 00	 call	 ?DelIp@CIpCache@@QAEXPAD@Z ; CIpCache::DelIp
$LN6@gObjDel:

; 6377 : 	}
; 6378 : 	lpObj->Connected = 0;

  0022e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00231	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 6379 : 
; 6380 : #ifdef MODIFY_0708_BUFFIX_20070820
; 6381 : 	lpObj->m_bSkillKeyRecv			= FALSE;

  00238	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0023b	c7 80 40 1a 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+6720], 0

; 6382 : #endif
; 6383 : #ifdef GMCOMMAND_EX
; 6384 : 	lpObj->m_bGMSummon				= FALSE;

  00245	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00248	c6 80 5c 1a 00
	00 00		 mov	 BYTE PTR [eax+6748], 0

; 6385 : #endif // GMCOMMAND_EX
; 6386 : 
; 6387 : 	return 1;

  0024f	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjDel:

; 6388 : }

  00254	5f		 pop	 edi
  00255	5e		 pop	 esi
  00256	5b		 pop	 ebx
  00257	8b e5		 mov	 esp, ebp
  00259	5d		 pop	 ebp
  0025a	c3		 ret	 0
?gObjDel@@YAFH@Z ENDP					; gObjDel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjAddMonster@@YAFH@Z
_TEXT	SEGMENT
_totalcount$ = -8					; size = 4
_count$ = -4						; size = 4
_iMapNumber$ = 8					; size = 4
?gObjAddMonster@@YAFH@Z PROC				; gObjAddMonster, COMDAT

; 5462 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5463 : #ifdef MAP_SERVER_WORK_20041030
; 5464 : 	if (!g_MapServerManager.CheckMapCanMove(iMapNumber))
; 5465 : 		return -1;
; 5466 : #endif
; 5467 : 
; 5468 : #ifdef MODIFY_ADDMONSTER_ADDLOCK_20080117
; 5469 : 	EnterCriticalSection(&gAddMonCriticalSection);
; 5470 : #endif
; 5471 : 
; 5472 : 	int count, totalcount=0;	

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _totalcount$[ebp], 0

; 5473 : 	
; 5474 : 	count = gObjMonCount;

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObjMonCount@@3HA ; gObjMonCount
  00015	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN2@gObjAddMon:

; 5475 : 	while( true )

  00018	b8 01 00 00 00	 mov	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 e3 00 00
	00		 je	 $LN3@gObjAddMon

; 5476 : 	{
; 5477 : 		if( gObj[count].Connected == 0 ) 

  00025	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 7072
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00032	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  00037	75 72		 jne	 SHORT $LN4@gObjAddMon

; 5478 : 		{
; 5479 : 			gObjCharZeroSet(count);

  00039	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?gObjCharZeroSet@@YAXH@Z ; gObjCharZeroSet
  00042	83 c4 04	 add	 esp, 4

; 5480 : 			gObj[count].m_Index  = count;

  00045	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 7072
  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00052	8b 55 fc	 mov	 edx, DWORD PTR _count$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 5481 : 			gObj[count].Connected = CSS_LOGIN;

  00058	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 7072
  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00065	c7 44 01 04 01
	00 00 00	 mov	 DWORD PTR [ecx+eax+4], 1

; 5482 : 			gObjMonCount++;

  0006d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObjMonCount@@3HA ; gObjMonCount
  00072	83 c0 01	 add	 eax, 1
  00075	a3 00 00 00 00	 mov	 DWORD PTR ?gObjMonCount@@3HA, eax ; gObjMonCount

; 5483 : 			
; 5484 : #ifdef MODIFY_ADDMONSTER_BUGFIX_20080423
; 5485 : 			if( gObjMonCount < count)

  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObjMonCount@@3HA ; gObjMonCount
  0007f	3b 45 fc	 cmp	 eax, DWORD PTR _count$[ebp]
  00082	7d 0b		 jge	 SHORT $LN5@gObjAddMon

; 5486 : 			{
; 5487 : 				gObjMonCount = count + 1;

  00084	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00087	83 c0 01	 add	 eax, 1
  0008a	a3 00 00 00 00	 mov	 DWORD PTR ?gObjMonCount@@3HA, eax ; gObjMonCount
$LN5@gObjAddMon:

; 5488 : 			}
; 5489 : #endif	// MODIFY_ADDMONSTER_BUGFIX_20080423
; 5490 : 
; 5491 : 			if( gObjMonCount >= MAX_MONSTER ) gObjMonCount = 0;

  0008f	81 3d 00 00 00
	00 a8 16 00 00	 cmp	 DWORD PTR ?gObjMonCount@@3HA, 5800 ; gObjMonCount, 000016a8H
  00099	7c 0a		 jl	 SHORT $LN6@gObjAddMon
  0009b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObjMonCount@@3HA, 0 ; gObjMonCount
$LN6@gObjAddMon:

; 5492 : 
; 5493 : #ifdef MODIFY_ADDMONSTER_ADDLOCK_20080117
; 5494 : 			LeaveCriticalSection(&gAddMonCriticalSection);
; 5495 : #endif
; 5496 : 
; 5497 : 			return (short)count;

  000a5	66 8b 45 fc	 mov	 ax, WORD PTR _count$[ebp]
  000a9	eb 60		 jmp	 SHORT $LN1@gObjAddMon
$LN4@gObjAddMon:

; 5498 : 		}
; 5499 : 		count++;

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  000ae	83 c0 01	 add	 eax, 1
  000b1	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 5500 : 		if( count >= MAX_MONSTER ) count = 0;

  000b4	81 7d fc a8 16
	00 00		 cmp	 DWORD PTR _count$[ebp], 5800 ; 000016a8H
  000bb	7c 07		 jl	 SHORT $LN7@gObjAddMon
  000bd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
$LN7@gObjAddMon:

; 5501 : 		totalcount++;

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _totalcount$[ebp]
  000c7	83 c0 01	 add	 eax, 1
  000ca	89 45 f8	 mov	 DWORD PTR _totalcount$[ebp], eax

; 5502 : 		if( totalcount >= MAX_MONSTER )

  000cd	81 7d f8 a8 16
	00 00		 cmp	 DWORD PTR _totalcount$[ebp], 5800 ; 000016a8H
  000d4	7c 2d		 jl	 SHORT $LN8@gObjAddMon

; 5503 : 		{
; 5504 : #ifdef MODIFY_ADDMONSTER_ADDLOCK_20080117
; 5505 : 			LeaveCriticalSection(&gAddMonCriticalSection);
; 5506 : #endif
; 5507 : 
; 5508 : 			LogAdd(lMsg.Get(511),__FILE__, __LINE__);

  000d6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjAddMonster@@YAFH@Z@4JA
  000db	83 c0 2e	 add	 eax, 46			; 0000002eH
  000de	50		 push	 eax
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000e4	68 ff 01 00 00	 push	 511			; 000001ffH
  000e9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000f4	50		 push	 eax
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000fb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5509 : 			return -1;

  000fe	83 c8 ff	 or	 eax, -1
  00101	eb 08		 jmp	 SHORT $LN1@gObjAddMon
$LN8@gObjAddMon:

; 5510 : 		}
; 5511 : 	}

  00103	e9 10 ff ff ff	 jmp	 $LN2@gObjAddMon
$LN3@gObjAddMon:

; 5512 : 
; 5513 : #ifdef MODIFY_ADDMONSTER_ADDLOCK_20080117
; 5514 : 	LeaveCriticalSection(&gAddMonCriticalSection);
; 5515 : #endif
; 5516 : 
; 5517 : 	return -1;

  00108	83 c8 ff	 or	 eax, -1
$LN1@gObjAddMon:

; 5518 : }

  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
?gObjAddMonster@@YAFH@Z ENDP				; gObjAddMonster
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjAddSearch@@YAFIPAD@Z
_TEXT	SEGMENT
_totalcount$ = -8					; size = 4
_count$ = -4						; size = 4
_aSocket$ = 8						; size = 4
_ip$ = 12						; size = 4
?gObjAddSearch@@YAFIPAD@Z PROC				; gObjAddSearch, COMDAT

; 5253 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5254 : 	int count, totalcount=0;	

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _totalcount$[ebp], 0

; 5255 : 
; 5256 : 	//       .
; 5257 : 	if( gDisconnect == 1 ) return -1;

  00010	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gDisconnect@@3HA, 1 ; gDisconnect
  00017	75 08		 jne	 SHORT $LN4@gObjAddSea
  00019	83 c8 ff	 or	 eax, -1
  0001c	e9 8f 00 00 00	 jmp	 $LN1@gObjAddSea
$LN4@gObjAddSea:

; 5258 : 
; 5259 : 	if( gObjTotalUser > gServerMaxUser )

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObjTotalUser@@3HA ; gObjTotalUser
  00026	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?gServerMaxUser@@3HA ; gServerMaxUser
  0002c	7e 25		 jle	 SHORT $LN7@gObjAddSea

; 5260 : 	{
; 5261 : 		if( acceptIP.IsIp(ip) == FALSE )	//  ..

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _ip$[ebp]
  00031	50		 push	 eax
  00032	b9 00 00 00 00	 mov	 ecx, OFFSET ?acceptIP@@3VCAcceptIp@@A ; acceptIP
  00037	e8 00 00 00 00	 call	 ?IsIp@CAcceptIp@@QAEHPAD@Z ; CAcceptIp::IsIp
  0003c	85 c0		 test	 eax, eax
  0003e	75 13		 jne	 SHORT $LN7@gObjAddSea

; 5262 : 		{
; 5263 : 			GCJoinSocketResult(0x04, aSocket);

  00040	8b 45 08	 mov	 eax, DWORD PTR _aSocket$[ebp]
  00043	50		 push	 eax
  00044	6a 04		 push	 4
  00046	e8 00 00 00 00	 call	 ?GCJoinSocketResult@@YAXEI@Z ; GCJoinSocketResult
  0004b	83 c4 08	 add	 esp, 8

; 5264 : 			//LogAdd("   . %s", ip);
; 5265 : 			return -1;

  0004e	83 c8 ff	 or	 eax, -1
  00051	eb 5d		 jmp	 SHORT $LN1@gObjAddSea
$LN7@gObjAddSea:

; 5266 : 		}
; 5267 : 	}
; 5268 : 	
; 5269 : 	if( bCanConnectMember == 0 )
; 5270 : 	{
; 5271 : #if (LOCALCONNECT == 1 )	
; 5272 : 	gObjTotalUser = gServerMaxUser;
; 5273 : #ifdef MODIFY_WEBZEN_PUBLIC_IPADDRESS_20050822
; 5274 : 		if( strcmp(ip, WEBZEN_PUBLIC_IPADDRESS) == 0 ||  
; 5275 : #else
; 5276 : 		if( strcmp(ip, "218.234.76.33") == 0 ||  
; 5277 : #endif
; 5278 : 			strncmp(ip, "10.1.2.", 6) == 0 )
; 5279 : 		{
; 5280 : 		}
; 5281 : 		else
; 5282 : 		{
; 5283 : 			return -1;
; 5284 : 		}
; 5285 : #endif
; 5286 : 	}
; 5287 : 	count = gObjCount;

  00053	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObjCount@@3HA ; gObjCount
  00058	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN2@gObjAddSea:

; 5288 : 	
; 5289 : 	while( true )

  0005b	b8 01 00 00 00	 mov	 eax, 1
  00060	85 c0		 test	 eax, eax
  00062	74 49		 je	 SHORT $LN3@gObjAddSea

; 5290 : 	{
; 5291 : 		if( gObj[count].Connected == 0 ) 

  00064	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 7072
  0006b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00071	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  00076	75 06		 jne	 SHORT $LN8@gObjAddSea

; 5292 : 		{
; 5293 : 			return (short)count;

  00078	66 8b 45 fc	 mov	 ax, WORD PTR _count$[ebp]
  0007c	eb 32		 jmp	 SHORT $LN1@gObjAddSea
$LN8@gObjAddSea:

; 5294 : 		}
; 5295 : 		count++;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00081	83 c0 01	 add	 eax, 1
  00084	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 5296 : 
; 5297 : 		if( count >= MAX_OBJECT ) count = ALLOC_USEROBJECTSTART;

  00087	81 7d fc e8 1c
	00 00		 cmp	 DWORD PTR _count$[ebp], 7400 ; 00001ce8H
  0008e	7c 07		 jl	 SHORT $LN9@gObjAddSea
  00090	c7 45 fc 00 19
	00 00		 mov	 DWORD PTR _count$[ebp], 6400 ; 00001900H
$LN9@gObjAddSea:

; 5298 : 		totalcount++;

  00097	8b 45 f8	 mov	 eax, DWORD PTR _totalcount$[ebp]
  0009a	83 c0 01	 add	 eax, 1
  0009d	89 45 f8	 mov	 DWORD PTR _totalcount$[ebp], eax

; 5299 : 		if( totalcount >= MAX_USER )

  000a0	81 7d f8 e8 03
	00 00		 cmp	 DWORD PTR _totalcount$[ebp], 1000 ; 000003e8H
  000a7	7c 02		 jl	 SHORT $LN10@gObjAddSea

; 5300 : 		{
; 5301 : 			//LogAdd("   . %s %d", __FILE__, __LINE__);
; 5302 : 			break;

  000a9	eb 02		 jmp	 SHORT $LN3@gObjAddSea
$LN10@gObjAddSea:

; 5303 : 		}
; 5304 : 	}

  000ab	eb ae		 jmp	 SHORT $LN2@gObjAddSea
$LN3@gObjAddSea:

; 5305 : 	return -1;

  000ad	83 c8 ff	 or	 eax, -1
$LN1@gObjAddSea:

; 5306 : }

  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
?gObjAddSearch@@YAFIPAD@Z ENDP				; gObjAddSearch
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjAddCallMon@@YAFXZ
_TEXT	SEGMENT
_totalcount$ = -8					; size = 4
_count$ = -4						; size = 4
?gObjAddCallMon@@YAFXZ PROC				; gObjAddCallMon, COMDAT

; 5581 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5582 : 	int count, totalcount=0;	

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _totalcount$[ebp], 0

; 5583 : 	
; 5584 : 	count = gObjCallMonCount;

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObjCallMonCount@@3HA ; gObjCallMonCount
  00015	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN2@gObjAddCal:

; 5585 : 
; 5586 : 	while( true )

  00018	b8 01 00 00 00	 mov	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	0f 84 e3 00 00
	00		 je	 $LN3@gObjAddCal

; 5587 : 	{
; 5588 : 		if( gObj[count].Connected == 0 ) 

  00025	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 7072
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00032	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  00037	75 72		 jne	 SHORT $LN4@gObjAddCal

; 5589 : 		{
; 5590 : 			gObjCharZeroSet(count);

  00039	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?gObjCharZeroSet@@YAXH@Z ; gObjCharZeroSet
  00042	83 c4 04	 add	 esp, 4

; 5591 : 			gObj[count].m_Index  = count;

  00045	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 7072
  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00052	8b 55 fc	 mov	 edx, DWORD PTR _count$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 5592 : 			gObj[count].Connected = CSS_LOGIN;

  00058	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _count$[ebp], 7072
  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00065	c7 44 01 04 01
	00 00 00	 mov	 DWORD PTR [ecx+eax+4], 1

; 5593 : 			gObjCallMonCount++;

  0006d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObjCallMonCount@@3HA ; gObjCallMonCount
  00072	83 c0 01	 add	 eax, 1
  00075	a3 00 00 00 00	 mov	 DWORD PTR ?gObjCallMonCount@@3HA, eax ; gObjCallMonCount

; 5594 : 
; 5595 : #ifdef MODIFY_ADDMONSTER_BUGFIX_20080423
; 5596 : 			if( gObjCallMonCount < count)

  0007a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObjCallMonCount@@3HA ; gObjCallMonCount
  0007f	3b 45 fc	 cmp	 eax, DWORD PTR _count$[ebp]
  00082	7d 0b		 jge	 SHORT $LN5@gObjAddCal

; 5597 : 			{
; 5598 : 				gObjCallMonCount = count + 1;

  00084	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00087	83 c0 01	 add	 eax, 1
  0008a	a3 00 00 00 00	 mov	 DWORD PTR ?gObjCallMonCount@@3HA, eax ; gObjCallMonCount
$LN5@gObjAddCal:

; 5599 : 			}
; 5600 : #endif	// MODIFY_ADDMONSTER_BUGFIX_20080423
; 5601 : 			
; 5602 : 			if( gObjCallMonCount >= ALLOC_USEROBJECTSTART ) gObjCallMonCount = MAX_MONSTER;

  0008f	81 3d 00 00 00
	00 00 19 00 00	 cmp	 DWORD PTR ?gObjCallMonCount@@3HA, 6400 ; gObjCallMonCount, 00001900H
  00099	7c 0a		 jl	 SHORT $LN6@gObjAddCal
  0009b	c7 05 00 00 00
	00 a8 16 00 00	 mov	 DWORD PTR ?gObjCallMonCount@@3HA, 5800 ; gObjCallMonCount, 000016a8H
$LN6@gObjAddCal:

; 5603 : 			return (short)count;

  000a5	66 8b 45 fc	 mov	 ax, WORD PTR _count$[ebp]
  000a9	eb 60		 jmp	 SHORT $LN1@gObjAddCal
$LN4@gObjAddCal:

; 5604 : 		}
; 5605 : 		count++;

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  000ae	83 c0 01	 add	 eax, 1
  000b1	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 5606 : 		if( count >= ALLOC_USEROBJECTSTART ) count = MAX_MONSTER;

  000b4	81 7d fc 00 19
	00 00		 cmp	 DWORD PTR _count$[ebp], 6400 ; 00001900H
  000bb	7c 07		 jl	 SHORT $LN7@gObjAddCal
  000bd	c7 45 fc a8 16
	00 00		 mov	 DWORD PTR _count$[ebp], 5800 ; 000016a8H
$LN7@gObjAddCal:

; 5607 : 		totalcount++;

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _totalcount$[ebp]
  000c7	83 c0 01	 add	 eax, 1
  000ca	89 45 f8	 mov	 DWORD PTR _totalcount$[ebp], eax

; 5608 : 		if( totalcount >= MAX_CALLMONSTER )

  000cd	81 7d f8 58 02
	00 00		 cmp	 DWORD PTR _totalcount$[ebp], 600 ; 00000258H
  000d4	7c 2d		 jl	 SHORT $LN8@gObjAddCal

; 5609 : 		{
; 5610 : 			LogAdd(lMsg.Get(511),__FILE__, __LINE__);

  000d6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjAddCallMon@@YAFXZ@4JA
  000db	83 c0 1d	 add	 eax, 29			; 0000001dH
  000de	50		 push	 eax
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000e4	68 ff 01 00 00	 push	 511			; 000001ffH
  000e9	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000f4	50		 push	 eax
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000fb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5611 : 			return -1;

  000fe	83 c8 ff	 or	 eax, -1
  00101	eb 08		 jmp	 SHORT $LN1@gObjAddCal
$LN8@gObjAddCal:

; 5612 : 		}
; 5613 : 	}

  00103	e9 10 ff ff ff	 jmp	 $LN2@gObjAddCal
$LN3@gObjAddCal:

; 5614 : 	return -1;

  00108	83 c8 ff	 or	 eax, -1
$LN1@gObjAddCal:

; 5615 : }

  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
?gObjAddCallMon@@YAFXZ ENDP				; gObjAddCallMon
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjAdd@@YAFIPADH@Z
_TEXT	SEGMENT
tv128 = -68						; size = 4
_aSocket$ = 8						; size = 4
_ip$ = 12						; size = 4
_aIndex$ = 16						; size = 4
?gObjAdd@@YAFIPADH@Z PROC				; gObjAdd, COMDAT

; 5312 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5313 : 	if( gObj[aIndex].Connected ) return -1;

  00009	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00016	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  0001b	74 08		 je	 SHORT $LN2@gObjAdd
  0001d	83 c8 ff	 or	 eax, -1
  00020	e9 bb 01 00 00	 jmp	 $LN1@gObjAdd
$LN2@gObjAdd:

; 5314 : 	
; 5315 : 	gObjCharZeroSet(aIndex);

  00025	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?gObjCharZeroSet@@YAXH@Z ; gObjCharZeroSet
  0002e	83 c4 04	 add	 esp, 4

; 5316 : 	gNSerialCheck[aIndex].init();

  00031	8b 45 10	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00034	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR ?gNSerialCheck@@3PAVNSerialCheck@@A[eax*8]
  0003b	e8 00 00 00 00	 call	 ?init@NSerialCheck@@QAEXXZ ; NSerialCheck::init

; 5317 : 	gObj[aIndex].LoginMsgSnd	= 0;

  00040	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004d	c6 44 01 08 00	 mov	 BYTE PTR [ecx+eax+8], 0

; 5318 : 	gObj[aIndex].LoginMsgCount= 0;

  00052	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00059	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005f	c6 44 01 09 00	 mov	 BYTE PTR [ecx+eax+9], 0

; 5319 : 	
; 5320 : 	memset(gObj[aIndex].AccountID, 0, MAX_IDSTRING);

  00064	6a 0a		 push	 10			; 0000000aH
  00066	6a 00		 push	 0
  00068	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00075	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 _memset
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5321 : 	
; 5322 : 	gObj[aIndex].m_Index		= aIndex;

  00082	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00089	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008f	8b 55 10	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00092	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 5323 : 	gObj[aIndex].m_socket		= aSocket;

  00095	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0009c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000a2	8b 55 08	 mov	 edx, DWORD PTR _aSocket$[ebp]
  000a5	89 54 01 14	 mov	 DWORD PTR [ecx+eax+20], edx

; 5324 : 	gObj[aIndex].AutoSaveTime	= gObj[aIndex].ConnectCheckTime = GetTickCount();

  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000af	89 45 bc	 mov	 DWORD PTR tv128[ebp], eax
  000b2	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bf	8b 55 bc	 mov	 edx, DWORD PTR tv128[ebp]
  000c2	89 54 01 38	 mov	 DWORD PTR [ecx+eax+56], edx
  000c6	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d3	8b 55 bc	 mov	 edx, DWORD PTR tv128[ebp]
  000d6	89 54 01 34	 mov	 DWORD PTR [ecx+eax+52], edx

; 5325 : 	gObj[aIndex].Connected		= CSS_LOGIN;

  000da	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e7	c7 44 01 04 01
	00 00 00	 mov	 DWORD PTR [ecx+eax+4], 1

; 5326 : 	gObj[aIndex].CheckSpeedHack	= 0;

  000ef	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  000f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000fc	c6 44 01 40 00	 mov	 BYTE PTR [ecx+eax+64], 0

; 5327 : 	gObj[aIndex].LoginMsgCount  = 0;

  00101	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00108	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010e	c6 44 01 09 00	 mov	 BYTE PTR [ecx+eax+9], 0

; 5328 : 	gObj[aIndex].Magumsa		= 0;

  00113	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0011a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00120	c6 44 01 30 00	 mov	 BYTE PTR [ecx+eax+48], 0

; 5329 : 	gObj[aIndex].Type			= OBJTYPE_CHARACTER;

  00125	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0012c	b9 01 00 00 00	 mov	 ecx, 1
  00131	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00137	66 89 4c 02 64	 mov	 WORD PTR [edx+eax+100], cx

; 5330 : 
; 5331 : #ifdef HACKTOOL_KUZIMO
; 5332 : 	gObj[aIndex].m_kRecvPacketStatistics.Init();

  0013c	68 e8 03 00 00	 push	 1000			; 000003e8H
  00141	69 45 10 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00148	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0014e	8d 8c 01 44 1a
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+6724]
  00155	e8 00 00 00 00	 call	 ?Init@PacketStatistics@@QAEXK@Z ; PacketStatistics::Init

; 5333 : #endif
; 5334 : 
; 5335 : #ifdef ITEMSAVE_MODIFY_FORSTATICS	
; 5336 : 	gObj[aIndex].SaveTimeForStatics = GetTickCount()+(1000*60*60);	//    

  0015a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00160	05 80 ee 36 00	 add	 eax, 3600000		; 0036ee80H
  00165	69 4d 10 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  0016c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00172	89 44 0a 4c	 mov	 DWORD PTR [edx+ecx+76], eax

; 5337 : #endif
; 5338 : 
; 5339 : #ifdef HAPPY_POUCH				//happycat@20050201
; 5340 : 	gObj[aIndex].m_bPCBangUser	= FALSE;
; 5341 : #endif
; 5342 : 
; 5343 : #ifdef PCBANG_EVENT_FREE_CHAOSCASTLE_20060307
; 5344 : 	gObj[aIndex].m_bPCBangFreeChaosCastleUser	= FALSE;
; 5345 : #endif
; 5346 : 
; 5347 : #ifdef PCBANG_FREE_KALIMA_EVENT_20060124
; 5348 : 	gObj[aIndex].m_bPCBangCouponUser = FALSE;
; 5349 : #endif
; 5350 : 
; 5351 : #ifdef PCBANG_POINT_SYSTEM_20070206	// PC   
; 5352 : 	gObj[aIndex].m_bPCBangPointUser = FALSE;
; 5353 : 	gObj[aIndex].m_PCBangPointInfo.Clear();
; 5354 : #endif
; 5355 : 
; 5356 : 	m_ObjBill[aIndex].Init();

  00176	6b 4d 10 1c	 imul	 ecx, DWORD PTR _aIndex$[ebp], 28
  0017a	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?m_ObjBill@@3PAVBILL_CLASS@@A ; m_ObjBill
  00180	e8 00 00 00 00	 call	 ?Init@BILL_CLASS@@QAEXXZ ; BILL_CLASS::Init

; 5357 : 	strcpy(gObj[aIndex].Ip_addr, ip);

  00185	8b 45 0c	 mov	 eax, DWORD PTR _ip$[ebp]
  00188	50		 push	 eax
  00189	69 4d 10 a0 1b
	00 00		 imul	 ecx, DWORD PTR _aIndex$[ebp], 7072
  00190	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00196	8d 44 0a 18	 lea	 eax, DWORD PTR [edx+ecx+24]
  0019a	50		 push	 eax
  0019b	e8 00 00 00 00	 call	 _strcpy
  001a0	83 c4 08	 add	 esp, 8

; 5358 : 	
; 5359 : 	LogAddTD("connect : [%d][%s]", aIndex, ip);

  001a3	8b 45 0c	 mov	 eax, DWORD PTR _ip$[ebp]
  001a6	50		 push	 eax
  001a7	8b 4d 10	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  001aa	51		 push	 ecx
  001ab	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@LOIPIKDB@connect?5?3?5?$FL?$CFd?$FN?$FL?$CFs?$FN@
  001b0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5360 : 	
; 5361 : 	gObjCount++;

  001b9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObjCount@@3HA ; gObjCount
  001be	83 c0 01	 add	 eax, 1
  001c1	a3 00 00 00 00	 mov	 DWORD PTR ?gObjCount@@3HA, eax ; gObjCount

; 5362 : 	
; 5363 : 	if( gObjCount >= MAX_OBJECT ) gObjCount = ALLOC_USEROBJECTSTART;

  001c6	81 3d 00 00 00
	00 e8 1c 00 00	 cmp	 DWORD PTR ?gObjCount@@3HA, 7400 ; gObjCount, 00001ce8H
  001d0	7c 0a		 jl	 SHORT $LN3@gObjAdd
  001d2	c7 05 00 00 00
	00 00 19 00 00	 mov	 DWORD PTR ?gObjCount@@3HA, 6400 ; gObjCount, 00001900H
$LN3@gObjAdd:

; 5364 : 	return (short)aIndex;

  001dc	66 8b 45 10	 mov	 ax, WORD PTR _aIndex$[ebp]
$LN1@gObjAdd:

; 5365 : }

  001e0	5f		 pop	 edi
  001e1	5e		 pop	 esi
  001e2	5b		 pop	 ebx
  001e3	8b e5		 mov	 esp, ebp
  001e5	5d		 pop	 ebp
  001e6	c3		 ret	 0
?gObjAdd@@YAFIPADH@Z ENDP				; gObjAdd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjDestroy@@YAXIH@Z
_TEXT	SEGMENT
_aSocket$ = 8						; size = 4
_client$ = 12						; size = 4
?gObjDestroy@@YAXIH@Z PROC				; gObjDestroy, COMDAT

; 5242 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5243 : 	if( client < 0 || client > MAX_OBJECT-1 ) return;

  00009	83 7d 0c 00	 cmp	 DWORD PTR _client$[ebp], 0
  0000d	7c 09		 jl	 SHORT $LN3@gObjDestro
  0000f	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _client$[ebp], 7399 ; 00001ce7H
  00016	7e 02		 jle	 SHORT $LN2@gObjDestro
$LN3@gObjDestro:
  00018	eb 15		 jmp	 SHORT $LN1@gObjDestro
$LN2@gObjDestro:

; 5244 : 	gObj[client].Connected = 0;

  0001a	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _client$[ebp], 7072
  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00027	c7 44 01 04 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+4], 0
$LN1@gObjDestro:

; 5245 : }

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?gObjDestroy@@YAXIH@Z ENDP				; gObjDestroy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjSometimeClose@@YAFH@Z
_TEXT	SEGMENT
_pindex$1 = -12						; size = 4
_pMsg$2 = -8						; size = 4
_lpObj$ = -4						; size = 4
_index$ = 8						; size = 4
?gObjSometimeClose@@YAFH@Z PROC				; gObjSometimeClose, COMDAT

; 6394 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 6395 : 	if( gDisconnect == 1 ) return -1;

  00009	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gDisconnect@@3HA, 1 ; gDisconnect
  00010	75 08		 jne	 SHORT $LN2@gObjSometi
  00012	83 c8 ff	 or	 eax, -1
  00015	e9 c8 00 00 00	 jmp	 $LN1@gObjSometi
$LN2@gObjSometi:

; 6396 : 
; 6397 : 	if( index < 0 || index > MAX_OBJECT ) 

  0001a	83 7d 08 00	 cmp	 DWORD PTR _index$[ebp], 0
  0001e	7c 09		 jl	 SHORT $LN4@gObjSometi
  00020	81 7d 08 e8 1c
	00 00		 cmp	 DWORD PTR _index$[ebp], 7400 ; 00001ce8H
  00027	7e 28		 jle	 SHORT $LN3@gObjSometi
$LN4@gObjSometi:

; 6398 : 	{
; 6399 : 		LogAdd("(%s)(%d) = index over error (%d)", __FILE__, __LINE__, index);

  00029	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0002c	50		 push	 eax
  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??gObjSometimeClose@@YAFH@Z@4JA
  00033	83 c1 05	 add	 ecx, 5
  00036	51		 push	 ecx
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PNMAPJFE@?$CI?$CFs?$CJ?$CI?$CFd?$CJ?5?$DN?5index?5over?5error?5?$CI?$CFd@
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00047	83 c4 10	 add	 esp, 16			; 00000010H

; 6400 : 		return 0;

  0004a	33 c0		 xor	 eax, eax
  0004c	e9 91 00 00 00	 jmp	 $LN1@gObjSometi
$LN3@gObjSometi:

; 6401 : 	}
; 6402 : //	gObjAddMsgSendDelay(&gObj[index], 5, index, 1000*5);	// 5    .
; 6403 : 	
; 6404 : 	LPOBJECTSTRUCT	lpObj;
; 6405 : 	lpObj = (LPOBJECTSTRUCT)&gObj[index];

  00051	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  00058	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0005e	89 45 fc	 mov	 DWORD PTR _lpObj$[ebp], eax

; 6406 : 
; 6407 : 	gObjTradeSave(lpObj, index);

  00061	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00064	50		 push	 eax
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 ?gObjTradeSave@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjTradeSave
  0006e	83 c4 08	 add	 esp, 8

; 6408 : 
; 6409 : 	if( lpObj->Connected > 1 )

  00071	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00074	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  00078	7e 63		 jle	 SHORT $LN5@gObjSometi

; 6410 : 	{
; 6411 : 		if( lpObj->Type == OBJTYPE_CHARACTER )	

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007d	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00081	83 f9 01	 cmp	 ecx, 1
  00084	75 57		 jne	 SHORT $LN5@gObjSometi

; 6412 : 		{
; 6413 : 			if( lpObj->Connected == 3 )

  00086	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00089	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  0008d	75 4e		 jne	 SHORT $LN5@gObjSometi

; 6414 : 			{
; 6415 : 				//   ..
; 6416 : 				if( lpObj->PartyNumber >= 0 )

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00092	83 b8 88 02 00
	00 00		 cmp	 DWORD PTR [eax+648], 0
  00099	7c 42		 jl	 SHORT $LN5@gObjSometi

; 6417 : 				{
; 6418 : 					//gParty.Delete(lpObj->PartyNumber, lpObj->m_Index, lpObj->DBNumber);
; 6419 : 					PMSG_PARTYDELUSER pMsg;
; 6420 : 					
; 6421 : 					int pindex = gParty.GetIndex(lpObj->PartyNumber, lpObj->m_Index, lpObj->DBNumber);

  0009b	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009e	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  000a1	51		 push	 ecx
  000a2	8b 55 fc	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000a5	8b 02		 mov	 eax, DWORD PTR [edx]
  000a7	50		 push	 eax
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ab	8b 91 88 02 00
	00		 mov	 edx, DWORD PTR [ecx+648]
  000b1	52		 push	 edx
  000b2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  000b7	e8 00 00 00 00	 call	 ?GetIndex@PartyClass@@QAEHHHH@Z ; PartyClass::GetIndex
  000bc	89 45 f4	 mov	 DWORD PTR _pindex$1[ebp], eax

; 6422 : 					if( pindex >= 0 )

  000bf	83 7d f4 00	 cmp	 DWORD PTR _pindex$1[ebp], 0
  000c3	7c 18		 jl	 SHORT $LN5@gObjSometi

; 6423 : 					{
; 6424 : 						pMsg.Number = pindex;

  000c5	8a 45 f4	 mov	 al, BYTE PTR _pindex$1[ebp]
  000c8	88 45 fb	 mov	 BYTE PTR _pMsg$2[ebp+3], al

; 6425 : 						CGPartyDelUser( &pMsg, lpObj->m_Index);

  000cb	8b 45 fc	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d0	51		 push	 ecx
  000d1	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$2[ebp]
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 ?CGPartyDelUser@@YAXPAUPMSG_PARTYDELUSER@@H@Z ; CGPartyDelUser
  000da	83 c4 08	 add	 esp, 8
$LN5@gObjSometi:

; 6426 : 					}		
; 6427 : 				}
; 6428 : 			}
; 6429 : 		}
; 6430 : 	}
; 6431 : 	return 1;

  000dd	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjSometi:

; 6432 : }

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
?gObjSometimeClose@@YAFH@Z ENDP				; gObjSometimeClose
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMemFree@@YAFH@Z
_TEXT	SEGMENT
tv95 = -80						; size = 4
tv128 = -76						; size = 4
_lpObj$ = -8						; size = 4
_i$ = -4						; size = 4
_index$ = 8						; size = 4
?gObjMemFree@@YAFH@Z PROC				; gObjMemFree, COMDAT

; 5917 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5918 : 	int i=0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 5919 : 	LPOBJECTSTRUCT	lpObj;
; 5920 : 
; 5921 : 	if( gDisconnect == 1 ) return -1;

  00010	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?gDisconnect@@3HA, 1 ; gDisconnect
  00017	75 08		 jne	 SHORT $LN2@gObjMemFre
  00019	83 c8 ff	 or	 eax, -1
  0001c	e9 27 01 00 00	 jmp	 $LN1@gObjMemFre
$LN2@gObjMemFre:

; 5922 : 
; 5923 : 	if( index < 0 || index > MAX_OBJECT ) {

  00021	83 7d 08 00	 cmp	 DWORD PTR _index$[ebp], 0
  00025	7c 09		 jl	 SHORT $LN4@gObjMemFre
  00027	81 7d 08 e8 1c
	00 00		 cmp	 DWORD PTR _index$[ebp], 7400 ; 00001ce8H
  0002e	7e 28		 jle	 SHORT $LN3@gObjMemFre
$LN4@gObjMemFre:

; 5924 : 		LogAdd("(%s)(%d) = index over error (%d)", __FILE__, __LINE__, index);

  00030	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00033	50		 push	 eax
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??gObjMemFree@@YAFH@Z@4JA
  0003a	83 c1 07	 add	 ecx, 7
  0003d	51		 push	 ecx
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PNMAPJFE@?$CI?$CFs?$CJ?$CI?$CFd?$CJ?5?$DN?5index?5over?5error?5?$CI?$CFd@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0004e	83 c4 10	 add	 esp, 16			; 00000010H

; 5925 : 		return 0;

  00051	33 c0		 xor	 eax, eax
  00053	e9 f0 00 00 00	 jmp	 $LN1@gObjMemFre
$LN3@gObjMemFre:

; 5926 : 	}
; 5927 : 	
; 5928 : 	lpObj = (LPOBJECTSTRUCT)&gObj[index];

  00058	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _index$[ebp], 7072
  0005f	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00065	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 5929 : 	if( lpObj->Connected < 1
; 5930 : #ifdef MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 5931 : 		&& lpObj->Connected != CSS_LOGINWAIT

  00068	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006b	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  0006f	7d 10		 jge	 SHORT $LN5@gObjMemFre
  00071	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00074	83 78 04 ff	 cmp	 DWORD PTR [eax+4], -1
  00078	74 07		 je	 SHORT $LN5@gObjMemFre

; 5932 : #endif // MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 5933 : 		)
; 5934 : 		return 0;

  0007a	33 c0		 xor	 eax, eax
  0007c	e9 c7 00 00 00	 jmp	 $LN1@gObjMemFre
$LN5@gObjMemFre:

; 5935 : 	
; 5936 : 	gObjTradeSave(lpObj, index);

  00081	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00084	50		 push	 eax
  00085	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00088	51		 push	 ecx
  00089	e8 00 00 00 00	 call	 ?gObjTradeSave@@YAXPAVOBJECTSTRUCT@@H@Z ; gObjTradeSave
  0008e	83 c4 08	 add	 esp, 8

; 5937 : 
; 5938 : 	//  .
; 5939 : 	if( lpObj->Connected >= CSS_LOGINOK
; 5940 : #ifdef MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 5941 : 		|| lpObj->Connected == CSS_LOGINWAIT

  00091	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00094	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  00098	7d 0d		 jge	 SHORT $LN7@gObjMemFre
  0009a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009d	83 78 04 ff	 cmp	 DWORD PTR [eax+4], -1
  000a1	0f 85 86 00 00
	00		 jne	 $LN6@gObjMemFre
$LN7@gObjMemFre:

; 5942 : #endif // MODIFY_USER_CLOSE_AT_AUTH_WAITTIME_20070801
; 5943 : 		)
; 5944 : 	{
; 5945 : 		// ..
; 5946 : 		if( lpObj->Type == OBJTYPE_CHARACTER )	

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000aa	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  000ae	83 f9 01	 cmp	 ecx, 1
  000b1	75 7a		 jne	 SHORT $LN6@gObjMemFre

; 5947 : 		{
; 5948 : 			//   ..  .
; 5949 : 			if( lpObj->Connected == CSS_GAMEPLAYING )

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b6	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  000ba	75 65		 jne	 SHORT $LN9@gObjMemFre

; 5950 : 			{
; 5951 : #ifdef FOR_BLOODCASTLE
; 5952 : 				if (CHECK_BLOODCASTLE(lpObj->MapNumber)) {					// DB     .

  000bc	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bf	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000c6	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  000c9	7d 09		 jge	 SHORT $LN14@gObjMemFre
  000cb	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv128[ebp], 0
  000d2	eb 25		 jmp	 SHORT $LN15@gObjMemFre
$LN14@gObjMemFre:
  000d4	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000d7	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  000de	83 f8 11	 cmp	 eax, 17			; 00000011H
  000e1	7e 09		 jle	 SHORT $LN12@gObjMemFre
  000e3	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], 0
  000ea	eb 07		 jmp	 SHORT $LN13@gObjMemFre
$LN12@gObjMemFre:
  000ec	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv95[ebp], 1
$LN13@gObjMemFre:
  000f3	8b 4d b0	 mov	 ecx, DWORD PTR tv95[ebp]
  000f6	89 4d b4	 mov	 DWORD PTR tv128[ebp], ecx
$LN15@gObjMemFre:
  000f9	83 7d b4 00	 cmp	 DWORD PTR tv128[ebp], 0
  000fd	74 10		 je	 SHORT $LN10@gObjMemFre

; 5953 : 					g_BloodCastle.SearchUserDropQuestItem(lpObj->m_Index);

  000ff	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00102	8b 08		 mov	 ecx, DWORD PTR [eax]
  00104	51		 push	 ecx
  00105	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0010a	e8 00 00 00 00	 call	 ?SearchUserDropQuestItem@CBloodCastle@@QAEXH@Z ; CBloodCastle::SearchUserDropQuestItem
$LN10@gObjMemFre:

; 5954 : 				}
; 5955 : #endif
; 5956 : 
; 5957 : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328		//    
; 5958 : 				if(CHECK_ILLUSION_TEMPLE(lpObj->MapNumber))
; 5959 : 				{
; 5960 : 					g_IllusionTempleEvent.DropRelicsItem(lpObj->MapNumber, lpObj->m_Index);
; 5961 : 					g_IllusionTempleEvent.LeaveIllusionTemple(lpObj->m_Index, lpObj->MapNumber);
; 5962 : 				}
; 5963 : #endif
; 5964 : 				GJSetCharacterInfo(lpObj, index);

  0010f	6a 00		 push	 0
  00111	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00114	50		 push	 eax
  00115	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00118	51		 push	 ecx
  00119	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAVOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo
  0011e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@gObjMemFre:

; 5965 : 			}
; 5966 : 
; 5967 : #ifdef LOGINSERVER_MULOG
; 5968 : 			GJPUserClose((LPOBJECTSTRUCT)lpObj);				//    .

  00121	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 ?GJPUserClose@@YAXPAVOBJECTSTRUCT@@@Z ; GJPUserClose
  0012a	83 c4 04	 add	 esp, 4
$LN6@gObjMemFre:

; 5969 : #else
; 5970 : #if defined(CHN_PLAYTIME_LIMIT_SYSTEM_20050818) || defined(VTM_PLAYTIME_LIMIT_SYSTEM_20060626)
; 5971 : 			GJPUserClose(lpObj->AccountID, lpObj->m_iPlayTimeLimit);
; 5972 : #else
; 5973 : 			GJPUserClose(lpObj->AccountID);						//    .
; 5974 : #endif
; 5975 : 
; 5976 : #endif
; 5977 : 		}
; 5978 : 	}	
; 5979 : 	gObjViewportClose(lpObj);

  0012d	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 ?gObjViewportClose@@YAXPAVOBJECTSTRUCT@@@Z ; gObjViewportClose
  00136	83 c4 04	 add	 esp, 4

; 5980 : 	lpObj->Connected = 0;	//  

  00139	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 5981 : 	return 1;

  00143	b8 01 00 00 00	 mov	 eax, 1
$LN1@gObjMemFre:

; 5982 : }

  00148	5f		 pop	 edi
  00149	5e		 pop	 esi
  0014a	5b		 pop	 ebx
  0014b	8b e5		 mov	 esp, ebp
  0014d	5d		 pop	 ebp
  0014e	c3		 ret	 0
?gObjMemFree@@YAFH@Z ENDP				; gObjMemFree
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjEnd@@YAXXZ
_TEXT	SEGMENT
tv85 = -120						; size = 4
tv84 = -116						; size = 4
$T1 = -112						; size = 4
$T2 = -108						; size = 4
$T3 = -104						; size = 4
$T4 = -100						; size = 4
$T5 = -96						; size = 4
$T6 = -92						; size = 4
$T7 = -88						; size = 4
$T8 = -84						; size = 4
$T9 = -80						; size = 4
$T10 = -76						; size = 4
$T11 = -72						; size = 4
_n$12 = -4						; size = 4
?gObjEnd@@YAXXZ PROC					; gObjEnd, COMDAT

; 1177 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1178 : 	gObjAllDisconnect();

  00009	e8 00 00 00 00	 call	 ?gObjAllDisconnect@@YAXXZ ; gObjAllDisconnect

; 1179 : 	gObjAllLogOut();

  0000e	e8 00 00 00 00	 call	 ?gObjAllLogOut@@YAXXZ	; gObjAllLogOut

; 1180 : 	//gObjAllDel();
; 1181 : 
; 1182 : 	//CloseHandle(hThread_gObjMove);
; 1183 : 
; 1184 : 	for( int n=0; n<MAX_OBJECT; n++)

  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$12[ebp], 0
  0001a	eb 09		 jmp	 SHORT $LN4@gObjEnd
$LN2@gObjEnd:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _n$12[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 fc	 mov	 DWORD PTR _n$12[ebp], eax
$LN4@gObjEnd:
  00025	81 7d fc e8 1c
	00 00		 cmp	 DWORD PTR _n$12[ebp], 7400 ; 00001ce8H
  0002c	0f 8d c1 02 00
	00		 jge	 $LN1@gObjEnd

; 1185 : 	{
; 1186 : 		if( gObj[n].m_lpMagicBack != NULL) 

  00032	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003f	83 bc 01 0c 03
	00 00 00	 cmp	 DWORD PTR [ecx+eax+780], 0
  00047	74 66		 je	 SHORT $LN5@gObjEnd

; 1187 : 			delete [] gObj[n].m_lpMagicBack;

  00049	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  00050	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00056	8b 94 01 0c 03
	00 00		 mov	 edx, DWORD PTR [ecx+eax+780]
  0005d	89 55 b8	 mov	 DWORD PTR $T11[ebp], edx
  00060	8b 45 b8	 mov	 eax, DWORD PTR $T11[ebp]
  00063	89 45 b4	 mov	 DWORD PTR $T10[ebp], eax
  00066	83 7d b4 00	 cmp	 DWORD PTR $T10[ebp], 0
  0006a	74 3c		 je	 SHORT $LN19@gObjEnd
  0006c	8b 4d b4	 mov	 ecx, DWORD PTR $T10[ebp]
  0006f	83 79 fc 00	 cmp	 DWORD PTR [ecx-4], 0
  00073	74 13		 je	 SHORT $LN17@gObjEnd
  00075	6a 03		 push	 3
  00077	8b 55 b8	 mov	 edx, DWORD PTR $T11[ebp]
  0007a	8b 02		 mov	 eax, DWORD PTR [edx]
  0007c	8b 4d b8	 mov	 ecx, DWORD PTR $T11[ebp]
  0007f	8b 10		 mov	 edx, DWORD PTR [eax]
  00081	ff d2		 call	 edx
  00083	89 45 8c	 mov	 DWORD PTR tv84[ebp], eax
  00086	eb 18		 jmp	 SHORT $LN18@gObjEnd
$LN17@gObjEnd:
  00088	6a 04		 push	 4
  0008a	8b 45 b4	 mov	 eax, DWORD PTR $T10[ebp]
  0008d	83 e8 04	 sub	 eax, 4
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  00096	83 c4 08	 add	 esp, 8
  00099	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
$LN18@gObjEnd:
  000a0	8b 4d 8c	 mov	 ecx, DWORD PTR tv84[ebp]
  000a3	89 4d 88	 mov	 DWORD PTR tv85[ebp], ecx
  000a6	eb 07		 jmp	 SHORT $LN5@gObjEnd
$LN19@gObjEnd:
  000a8	c7 45 88 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
$LN5@gObjEnd:

; 1188 : #ifdef UPGRADE_GAMESERVER_01_20041006
; 1189 : 		if( n >= ALLOC_USEROBJECTSTART )

  000af	81 7d fc 00 19
	00 00		 cmp	 DWORD PTR _n$12[ebp], 6400 ; 00001900H
  000b6	0f 8c 17 02 00
	00		 jl	 $LN6@gObjEnd

; 1190 : 		{
; 1191 : 			
; 1192 : 			if( gObj[n].Inventory1 != NULL )

  000bc	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c9	83 bc 01 6c 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3180], 0
  000d1	74 23		 je	 SHORT $LN7@gObjEnd

; 1193 : 				delete [] gObj[n].Inventory1;

  000d3	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  000da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e0	8b 94 01 6c 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3180]
  000e7	89 55 b0	 mov	 DWORD PTR $T9[ebp], edx
  000ea	8b 45 b0	 mov	 eax, DWORD PTR $T9[ebp]
  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000f3	83 c4 04	 add	 esp, 4
$LN7@gObjEnd:

; 1194 : 			if( gObj[n].Inventory2 != NULL )

  000f6	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  000fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00103	83 bc 01 78 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3192], 0
  0010b	74 23		 je	 SHORT $LN8@gObjEnd

; 1195 : 				delete [] gObj[n].Inventory2;

  0010d	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  00114	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011a	8b 94 01 78 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3192]
  00121	89 55 ac	 mov	 DWORD PTR $T8[ebp], edx
  00124	8b 45 ac	 mov	 eax, DWORD PTR $T8[ebp]
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0012d	83 c4 04	 add	 esp, 4
$LN8@gObjEnd:

; 1196 : 			if( gObj[n].InventoryMap1 != NULL )

  00130	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  00137	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013d	83 bc 01 70 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3184], 0
  00145	74 23		 je	 SHORT $LN9@gObjEnd

; 1197 : 				delete [] gObj[n].InventoryMap1;

  00147	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  0014e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00154	8b 94 01 70 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3184]
  0015b	89 55 a8	 mov	 DWORD PTR $T7[ebp], edx
  0015e	8b 45 a8	 mov	 eax, DWORD PTR $T7[ebp]
  00161	50		 push	 eax
  00162	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00167	83 c4 04	 add	 esp, 4
$LN9@gObjEnd:

; 1198 : 			if( gObj[n].InventoryMap2 != NULL )

  0016a	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  00171	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00177	83 bc 01 7c 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3196], 0
  0017f	74 23		 je	 SHORT $LN10@gObjEnd

; 1199 : 				delete [] gObj[n].InventoryMap2;

  00181	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  00188	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018e	8b 94 01 7c 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3196]
  00195	89 55 a4	 mov	 DWORD PTR $T6[ebp], edx
  00198	8b 45 a4	 mov	 eax, DWORD PTR $T6[ebp]
  0019b	50		 push	 eax
  0019c	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  001a1	83 c4 04	 add	 esp, 4
$LN10@gObjEnd:

; 1200 : 			if( gObj[n].PerSocketContext != NULL )

  001a4	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  001ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001b1	83 7c 01 10 00	 cmp	 DWORD PTR [ecx+eax+16], 0
  001b6	74 25		 je	 SHORT $LN11@gObjEnd

; 1201 : 				delete gObj[n].PerSocketContext;

  001b8	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  001bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c5	8b 54 01 10	 mov	 edx, DWORD PTR [ecx+eax+16]
  001c9	89 55 a0	 mov	 DWORD PTR $T5[ebp], edx
  001cc	68 6c 00 02 00	 push	 131180			; 0002006cH
  001d1	8b 45 a0	 mov	 eax, DWORD PTR $T5[ebp]
  001d4	50		 push	 eax
  001d5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001da	83 c4 08	 add	 esp, 8
$LN11@gObjEnd:

; 1202 : 			if( gObj[n].Trade != NULL ) 

  001dd	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  001e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001ea	83 bc 01 84 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3204], 0
  001f2	74 28		 je	 SHORT $LN12@gObjEnd

; 1203 : 				delete gObj[n].Trade;

  001f4	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  001fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00201	8b 94 01 84 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3204]
  00208	89 55 9c	 mov	 DWORD PTR $T4[ebp], edx
  0020b	68 a8 00 00 00	 push	 168			; 000000a8H
  00210	8b 45 9c	 mov	 eax, DWORD PTR $T4[ebp]
  00213	50		 push	 eax
  00214	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00219	83 c4 08	 add	 esp, 8
$LN12@gObjEnd:

; 1204 : 			if( gObj[n].TradeMap != NULL )

  0021c	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  00223	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00229	83 bc 01 88 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3208], 0
  00231	74 25		 je	 SHORT $LN13@gObjEnd

; 1205 : 				delete gObj[n].TradeMap;

  00233	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  0023a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00240	8b 94 01 88 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3208]
  00247	89 55 98	 mov	 DWORD PTR $T3[ebp], edx
  0024a	6a 01		 push	 1
  0024c	8b 45 98	 mov	 eax, DWORD PTR $T3[ebp]
  0024f	50		 push	 eax
  00250	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00255	83 c4 08	 add	 esp, 8
$LN13@gObjEnd:

; 1206 : 			if( gObj[n].pWarehouse != NULL )

  00258	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  0025f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00265	83 bc 01 94 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3220], 0
  0026d	74 28		 je	 SHORT $LN14@gObjEnd

; 1207 : 				delete gObj[n].pWarehouse;

  0026f	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  00276	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0027c	8b 94 01 94 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3220]
  00283	89 55 94	 mov	 DWORD PTR $T2[ebp], edx
  00286	68 a8 00 00 00	 push	 168			; 000000a8H
  0028b	8b 45 94	 mov	 eax, DWORD PTR $T2[ebp]
  0028e	50		 push	 eax
  0028f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00294	83 c4 08	 add	 esp, 8
$LN14@gObjEnd:

; 1208 : 			if( gObj[n].pWarehouseMap != NULL )

  00297	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  0029e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002a4	83 bc 01 98 0c
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3224], 0
  002ac	74 25		 je	 SHORT $LN6@gObjEnd

; 1209 : 				delete gObj[n].pWarehouseMap;

  002ae	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  002b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002bb	8b 94 01 98 0c
	00 00		 mov	 edx, DWORD PTR [ecx+eax+3224]
  002c2	89 55 90	 mov	 DWORD PTR $T1[ebp], edx
  002c5	6a 01		 push	 1
  002c7	8b 45 90	 mov	 eax, DWORD PTR $T1[ebp]
  002ca	50		 push	 eax
  002cb	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  002d0	83 c4 08	 add	 esp, 8
$LN6@gObjEnd:

; 1210 : 		}
; 1211 : #else
; 1212 : 		if( gObj[n].Inventory1 != NULL )
; 1213 : 			delete [] gObj[n].Inventory1;
; 1214 : 		if( gObj[n].Inventory2 != NULL )
; 1215 : 			delete [] gObj[n].Inventory2;
; 1216 : 		if( gObj[n].InventoryMap1 != NULL )
; 1217 : 			delete [] gObj[n].InventoryMap1;
; 1218 : 		if( gObj[n].InventoryMap2 != NULL )
; 1219 : 			delete [] gObj[n].InventoryMap2;
; 1220 : 		if( gObj[n].PerSocketContext != NULL )
; 1221 : 			delete gObj[n].PerSocketContext;
; 1222 : 		if( gObj[n].Trade != NULL ) 
; 1223 : 			delete gObj[n].Trade;
; 1224 : 		if( gObj[n].TradeMap != NULL )
; 1225 : 			delete gObj[n].TradeMap;
; 1226 : 		if( gObj[n].pWarehouse != NULL )
; 1227 : 			delete gObj[n].pWarehouse;
; 1228 : 		if( gObj[n].pWarehouseMap != NULL )
; 1229 : 			delete gObj[n].pWarehouseMap;
; 1230 : #endif
; 1231 : 		/*
; 1232 : 		if( gObj[n].pChaosBox != NULL )
; 1233 : 			delete gObj[n].pChaosBox;
; 1234 : 		if( gObj[n].pChaosBoxMap != NULL )
; 1235 : 			delete gObj[n].pChaosBoxMap;
; 1236 : 		*/
; 1237 : 		
; 1238 : #ifdef PERSONAL_SHOP_20040113	
; 1239 : 		DeleteCriticalSection (& gObj[n].m_critPShopTrade);

  002d3	69 45 fc a0 1b
	00 00		 imul	 eax, DWORD PTR _n$12[ebp], 7072
  002da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002e0	8d 94 01 34 0d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+3380]
  002e7	52		 push	 edx
  002e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 1240 : #endif
; 1241 : 	}

  002ee	e9 29 fd ff ff	 jmp	 $LN2@gObjEnd
$LN1@gObjEnd:

; 1242 : 
; 1243 : #ifdef MODIFY_ADDMONSTER_ADDLOCK_20080117
; 1244 : 	DeleteCriticalSection(&gAddMonCriticalSection);
; 1245 : #endif
; 1246 : }

  002f3	5f		 pop	 edi
  002f4	5e		 pop	 esi
  002f5	5b		 pop	 ebx
  002f6	8b e5		 mov	 esp, ebp
  002f8	5d		 pop	 ebp
  002f9	c3		 ret	 0
?gObjEnd@@YAXXZ ENDP					; gObjEnd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjInit@@YAXXZ
_TEXT	SEGMENT
tv274 = -172						; size = 4
tv250 = -172						; size = 4
tv205 = -172						; size = 4
tv189 = -172						; size = 4
tv172 = -172						; size = 4
tv153 = -172						; size = 4
tv77 = -172						; size = 4
$T2 = -168						; size = 4
$T3 = -164						; size = 4
$T4 = -160						; size = 4
$T5 = -156						; size = 4
$T6 = -152						; size = 4
$T7 = -148						; size = 4
$T8 = -144						; size = 4
$T9 = -140						; size = 4
$T10 = -136						; size = 4
$T11 = -132						; size = 4
$T12 = -128						; size = 4
$T13 = -124						; size = 4
$T14 = -120						; size = 4
$T15 = -116						; size = 4
$T16 = -112						; size = 4
$T17 = -108						; size = 4
$T18 = -104						; size = 4
$T19 = -100						; size = 4
$T20 = -96						; size = 4
$T21 = -92						; size = 4
_n$22 = -24						; size = 4
_pTempInventoryMap$ = -20				; size = 4
_pTempInventory$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?gObjInit@@YAXXZ PROC					; gObjInit, COMDAT

; 1026 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?gObjInit@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c5		 xor	 eax, ebp
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1027 : 	gObjCount = ALLOC_USEROBJECTSTART;

  0002b	c7 05 00 00 00
	00 00 19 00 00	 mov	 DWORD PTR ?gObjCount@@3HA, 6400 ; gObjCount, 00001900H

; 1028 : 	gObjMonCount = 0;

  00035	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gObjMonCount@@3HA, 0 ; gObjMonCount

; 1029 : 	gObjCallMonCount = MAX_MONSTER;	

  0003f	c7 05 00 00 00
	00 a8 16 00 00	 mov	 DWORD PTR ?gObjCallMonCount@@3HA, 5800 ; gObjCallMonCount, 000016a8H

; 1030 : 
; 1031 : #ifdef UPGRADE_GAMESERVER_01_20041006
; 1032 : 	//  .. ^^;
; 1033 : 	CItem *pTempInventory		= new CItem [MAX_INVENTORY_EXTEND];

  00049	68 e0 46 00 00	 push	 18144			; 000046e0H
  0004e	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00053	83 c4 04	 add	 esp, 4
  00056	89 45 a0	 mov	 DWORD PTR $T20[ebp], eax
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	83 7d a0 00	 cmp	 DWORD PTR $T20[ebp], 0
  00064	74 20		 je	 SHORT $LN10@gObjInit
  00066	68 00 00 00 00	 push	 OFFSET ??0CItem@@QAE@XZ	; CItem::CItem
  0006b	6a 6c		 push	 108			; 0000006cH
  0006d	68 a8 00 00 00	 push	 168			; 000000a8H
  00072	8b 45 a0	 mov	 eax, DWORD PTR $T20[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z
  0007b	8b 4d a0	 mov	 ecx, DWORD PTR $T20[ebp]
  0007e	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv77[ebp], ecx
  00084	eb 0a		 jmp	 SHORT $LN11@gObjInit
$LN10@gObjInit:
  00086	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv77[ebp], 0
$LN11@gObjInit:
  00090	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  00096	89 55 a4	 mov	 DWORD PTR $T21[ebp], edx
  00099	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a0	8b 45 a4	 mov	 eax, DWORD PTR $T21[ebp]
  000a3	89 45 f0	 mov	 DWORD PTR _pTempInventory$[ebp], eax

; 1034 : 	BYTE  *pTempInventoryMap	= new BYTE  [MAX_INVENTORYMAP + MAX_PSHOPITEMMAP];

  000a6	6a 60		 push	 96			; 00000060H
  000a8	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000ad	83 c4 04	 add	 esp, 4
  000b0	89 45 9c	 mov	 DWORD PTR $T19[ebp], eax
  000b3	8b 45 9c	 mov	 eax, DWORD PTR $T19[ebp]
  000b6	89 45 ec	 mov	 DWORD PTR _pTempInventoryMap$[ebp], eax

; 1035 : 
; 1036 : #endif
; 1037 : 
; 1038 : #ifdef MODIFY_ADDMONSTER_ADDLOCK_20080117
; 1039 : 	InitializeCriticalSection(&gAddMonCriticalSection);
; 1040 : #endif
; 1041 : 
; 1042 : 	for( int n=0; n<MAX_OBJECT; n++)

  000b9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _n$22[ebp], 0
  000c0	eb 09		 jmp	 SHORT $LN4@gObjInit
$LN2@gObjInit:
  000c2	8b 45 e8	 mov	 eax, DWORD PTR _n$22[ebp]
  000c5	83 c0 01	 add	 eax, 1
  000c8	89 45 e8	 mov	 DWORD PTR _n$22[ebp], eax
$LN4@gObjInit:
  000cb	81 7d e8 e8 1c
	00 00		 cmp	 DWORD PTR _n$22[ebp], 7400 ; 00001ce8H
  000d2	0f 8d 16 05 00
	00		 jge	 $LN3@gObjInit

; 1043 : 	{
; 1044 : 		memset(&gObj[n], 0, sizeof(OBJECTSTRUCT));

  000d8	68 a0 1b 00 00	 push	 7072			; 00001ba0H
  000dd	6a 00		 push	 0
  000df	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  000e6	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ec	50		 push	 eax
  000ed	e8 00 00 00 00	 call	 _memset
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1045 : 		gObj[n].Type = 255;

  000f5	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  000fc	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00101	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00107	66 89 4c 02 64	 mov	 WORD PTR [edx+eax+100], cx

; 1046 : 		gObj[n].m_socket = INVALID_SOCKET;

  0010c	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  00113	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00119	c7 44 01 14 ff
	ff ff ff	 mov	 DWORD PTR [ecx+eax+20], -1

; 1047 : 		gObj[n].PathTime = GetTickCount();

  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00127	69 4d e8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _n$22[ebp], 7072
  0012e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00134	89 84 0a 9c 01
	00 00		 mov	 DWORD PTR [edx+ecx+412], eax

; 1048 : 		gObj[n].m_RecallMon= -1;

  0013b	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  00142	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00148	c7 84 01 a4 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+676], -1

; 1049 : 		
; 1050 : 		gObj[n].m_lpMagicBack = new CMagicInf [MAX_MAGIC];

  00153	68 c4 03 00 00	 push	 964			; 000003c4H
  00158	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0015d	83 c4 04	 add	 esp, 4
  00160	89 45 94	 mov	 DWORD PTR $T17[ebp], eax
  00163	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0016a	83 7d 94 00	 cmp	 DWORD PTR $T17[ebp], 0
  0016e	74 31		 je	 SHORT $LN12@gObjInit
  00170	8b 45 94	 mov	 eax, DWORD PTR $T17[ebp]
  00173	c7 00 3c 00 00
	00		 mov	 DWORD PTR [eax], 60	; 0000003cH
  00179	68 00 00 00 00	 push	 OFFSET ??1CMagicInf@@UAE@XZ ; CMagicInf::~CMagicInf
  0017e	68 00 00 00 00	 push	 OFFSET ??0CMagicInf@@QAE@XZ ; CMagicInf::CMagicInf
  00183	6a 3c		 push	 60			; 0000003cH
  00185	6a 10		 push	 16			; 00000010H
  00187	8b 4d 94	 mov	 ecx, DWORD PTR $T17[ebp]
  0018a	83 c1 04	 add	 ecx, 4
  0018d	51		 push	 ecx
  0018e	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00193	8b 55 94	 mov	 edx, DWORD PTR $T17[ebp]
  00196	83 c2 04	 add	 edx, 4
  00199	89 95 54 ff ff
	ff		 mov	 DWORD PTR tv153[ebp], edx
  0019f	eb 0a		 jmp	 SHORT $LN13@gObjInit
$LN12@gObjInit:
  001a1	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
$LN13@gObjInit:
  001ab	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR tv153[ebp]
  001b1	89 45 98	 mov	 DWORD PTR $T18[ebp], eax
  001b4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001bb	69 4d e8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _n$22[ebp], 7072
  001c2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c8	8b 45 98	 mov	 eax, DWORD PTR $T18[ebp]
  001cb	89 84 0a 0c 03
	00 00		 mov	 DWORD PTR [edx+ecx+780], eax

; 1051 : 		_ASSERT( gObj[n].m_lpMagicBack );		
; 1052 : 
; 1053 : 		gObj[n].Magic	   = new CMagicInf [MAX_MAGIC];

  001d2	68 c4 03 00 00	 push	 964			; 000003c4H
  001d7	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  001dc	83 c4 04	 add	 esp, 4
  001df	89 45 8c	 mov	 DWORD PTR $T15[ebp], eax
  001e2	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  001e9	83 7d 8c 00	 cmp	 DWORD PTR $T15[ebp], 0
  001ed	74 31		 je	 SHORT $LN14@gObjInit
  001ef	8b 45 8c	 mov	 eax, DWORD PTR $T15[ebp]
  001f2	c7 00 3c 00 00
	00		 mov	 DWORD PTR [eax], 60	; 0000003cH
  001f8	68 00 00 00 00	 push	 OFFSET ??1CMagicInf@@UAE@XZ ; CMagicInf::~CMagicInf
  001fd	68 00 00 00 00	 push	 OFFSET ??0CMagicInf@@QAE@XZ ; CMagicInf::CMagicInf
  00202	6a 3c		 push	 60			; 0000003cH
  00204	6a 10		 push	 16			; 00000010H
  00206	8b 4d 8c	 mov	 ecx, DWORD PTR $T15[ebp]
  00209	83 c1 04	 add	 ecx, 4
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00212	8b 55 8c	 mov	 edx, DWORD PTR $T15[ebp]
  00215	83 c2 04	 add	 edx, 4
  00218	89 95 54 ff ff
	ff		 mov	 DWORD PTR tv172[ebp], edx
  0021e	eb 0a		 jmp	 SHORT $LN15@gObjInit
$LN14@gObjInit:
  00220	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv172[ebp], 0
$LN15@gObjInit:
  0022a	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR tv172[ebp]
  00230	89 45 90	 mov	 DWORD PTR $T16[ebp], eax
  00233	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0023a	69 4d e8 a0 1b
	00 00		 imul	 ecx, DWORD PTR _n$22[ebp], 7072
  00241	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00247	8b 45 90	 mov	 eax, DWORD PTR $T16[ebp]
  0024a	89 84 0a 10 03
	00 00		 mov	 DWORD PTR [edx+ecx+784], eax

; 1054 : 		_ASSERT( gObj[n].Magic );
; 1055 : 
; 1056 : #ifdef PERSONAL_SHOP_20040113
; 1057 : 
; 1058 : #ifdef UPGRADE_GAMESERVER_01_20041006
; 1059 : 		//    .
; 1060 : 		if( n >= ALLOC_USEROBJECTSTART )

  00251	81 7d e8 00 19
	00 00		 cmp	 DWORD PTR _n$22[ebp], 6400 ; 00001900H
  00258	0f 8c 3e 01 00
	00		 jl	 $LN5@gObjInit

; 1061 : 		{
; 1062 : 			gObj[n].Inventory1 = new CItem [MAX_INVENTORY_EXTEND];

  0025e	68 e0 46 00 00	 push	 18144			; 000046e0H
  00263	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00268	83 c4 04	 add	 esp, 4
  0026b	89 45 84	 mov	 DWORD PTR $T13[ebp], eax
  0026e	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00275	83 7d 84 00	 cmp	 DWORD PTR $T13[ebp], 0
  00279	74 20		 je	 SHORT $LN16@gObjInit
  0027b	68 00 00 00 00	 push	 OFFSET ??0CItem@@QAE@XZ	; CItem::CItem
  00280	6a 6c		 push	 108			; 0000006cH
  00282	68 a8 00 00 00	 push	 168			; 000000a8H
  00287	8b 45 84	 mov	 eax, DWORD PTR $T13[ebp]
  0028a	50		 push	 eax
  0028b	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z
  00290	8b 4d 84	 mov	 ecx, DWORD PTR $T13[ebp]
  00293	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv189[ebp], ecx
  00299	eb 0a		 jmp	 SHORT $LN17@gObjInit
$LN16@gObjInit:
  0029b	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv189[ebp], 0
$LN17@gObjInit:
  002a5	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv189[ebp]
  002ab	89 55 88	 mov	 DWORD PTR $T14[ebp], edx
  002ae	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002b5	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  002bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c2	8b 55 88	 mov	 edx, DWORD PTR $T14[ebp]
  002c5	89 94 01 6c 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3180], edx

; 1063 : 			_ASSERT( gObj[n].Inventory1 );		
; 1064 : 			
; 1065 : 			gObj[n].Inventory2 = new CItem [MAX_INVENTORY_EXTEND];

  002cc	68 e0 46 00 00	 push	 18144			; 000046e0H
  002d1	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  002d6	83 c4 04	 add	 esp, 4
  002d9	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
  002df	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  002e6	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR $T11[ebp], 0
  002ed	74 26		 je	 SHORT $LN18@gObjInit
  002ef	68 00 00 00 00	 push	 OFFSET ??0CItem@@QAE@XZ	; CItem::CItem
  002f4	6a 6c		 push	 108			; 0000006cH
  002f6	68 a8 00 00 00	 push	 168			; 000000a8H
  002fb	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR $T11[ebp]
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z
  00307	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  0030d	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv205[ebp], ecx
  00313	eb 0a		 jmp	 SHORT $LN19@gObjInit
$LN18@gObjInit:
  00315	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv205[ebp], 0
$LN19@gObjInit:
  0031f	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv205[ebp]
  00325	89 55 80	 mov	 DWORD PTR $T12[ebp], edx
  00328	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0032f	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  00336	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0033c	8b 55 80	 mov	 edx, DWORD PTR $T12[ebp]
  0033f	89 94 01 78 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3192], edx

; 1066 : 			_ASSERT( gObj[n].Inventory2 );
; 1067 : 			
; 1068 : 			gObj[n].InventoryMap1 = new BYTE [MAX_INVENTORYMAP + MAX_PSHOPITEMMAP];

  00346	6a 60		 push	 96			; 00000060H
  00348	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0034d	83 c4 04	 add	 esp, 4
  00350	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
  00356	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  0035d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00363	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR $T10[ebp]
  00369	89 94 01 70 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3184], edx

; 1069 : 			_ASSERT( gObj[n].InventoryMap1 );
; 1070 : 			
; 1071 : 			gObj[n].InventoryMap2 = new BYTE [MAX_INVENTORYMAP + MAX_PSHOPITEMMAP];

  00370	6a 60		 push	 96			; 00000060H
  00372	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00377	83 c4 04	 add	 esp, 4
  0037a	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
  00380	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  00387	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0038d	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR $T9[ebp]
  00393	89 94 01 7c 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3196], edx

; 1072 : 			_ASSERT( gObj[n].InventoryMap2 );
; 1073 : 		}

  0039a	eb 5c		 jmp	 SHORT $LN6@gObjInit
$LN5@gObjInit:

; 1074 : 		else
; 1075 : 		{
; 1076 : 			gObj[n].Inventory1 = pTempInventory;

  0039c	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  003a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003a9	8b 55 f0	 mov	 edx, DWORD PTR _pTempInventory$[ebp]
  003ac	89 94 01 6c 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3180], edx

; 1077 : 			_ASSERT( gObj[n].Inventory1 );		
; 1078 : 			
; 1079 : 			gObj[n].Inventory2 = pTempInventory;

  003b3	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  003ba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003c0	8b 55 f0	 mov	 edx, DWORD PTR _pTempInventory$[ebp]
  003c3	89 94 01 78 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3192], edx

; 1080 : 			_ASSERT( gObj[n].Inventory2 );
; 1081 : 			
; 1082 : 			gObj[n].InventoryMap1 = pTempInventoryMap;

  003ca	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  003d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003d7	8b 55 ec	 mov	 edx, DWORD PTR _pTempInventoryMap$[ebp]
  003da	89 94 01 70 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3184], edx

; 1083 : 			_ASSERT( gObj[n].InventoryMap1 );
; 1084 : 			
; 1085 : 			gObj[n].InventoryMap2 = pTempInventoryMap;

  003e1	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  003e8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003ee	8b 55 ec	 mov	 edx, DWORD PTR _pTempInventoryMap$[ebp]
  003f1	89 94 01 7c 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3196], edx
$LN6@gObjInit:

; 1086 : 			_ASSERT( gObj[n].InventoryMap2 );
; 1087 : 		}
; 1088 : #else
; 1089 : 		gObj[n].Inventory1 = new CItem [MAX_INVENTORY_EXTEND];
; 1090 : 		_ASSERT( gObj[n].Inventory1 );		
; 1091 : 		
; 1092 : 		gObj[n].Inventory2 = new CItem [MAX_INVENTORY_EXTEND];
; 1093 : 		_ASSERT( gObj[n].Inventory2 );
; 1094 : 
; 1095 : 		gObj[n].InventoryMap1 = new BYTE [MAX_INVENTORYMAP + MAX_PSHOPITEMMAP];
; 1096 : 		_ASSERT( gObj[n].InventoryMap1 );
; 1097 : 
; 1098 : 		gObj[n].InventoryMap2 = new BYTE [MAX_INVENTORYMAP + MAX_PSHOPITEMMAP];
; 1099 : 		_ASSERT( gObj[n].InventoryMap2 );
; 1100 : #endif //UPGRADE_GAMESERVER_01_20041006
; 1101 : 
; 1102 : #else
; 1103 : 		gObj[n].Inventory1 = new CItem [MAX_INVENTORY];
; 1104 : 		_ASSERT( gObj[n].Inventory1 );
; 1105 : 		
; 1106 : 		gObj[n].Inventory2 = new CItem [MAX_INVENTORY];
; 1107 : 		_ASSERT( gObj[n].Inventory2 );
; 1108 : 
; 1109 : 		gObj[n].InventoryMap1 = new BYTE [MAX_INVENTORYMAP];
; 1110 : 		_ASSERT( gObj[n].InventoryMap1 );
; 1111 : 
; 1112 : 		gObj[n].InventoryMap2 = new BYTE [MAX_INVENTORYMAP];
; 1113 : 		_ASSERT( gObj[n].InventoryMap2 );
; 1114 : #endif //PERSONAL_SHOP_20040113
; 1115 : 
; 1116 : 
; 1117 : #ifdef UPGRADE_GAMESERVER_01_20041006
; 1118 : 		//  ,   .
; 1119 : 		if( n >= ALLOC_USEROBJECTSTART )

  003f8	81 7d e8 00 19
	00 00		 cmp	 DWORD PTR _n$22[ebp], 6400 ; 00001900H
  003ff	0f 8c 54 01 00
	00		 jl	 $LN7@gObjInit

; 1120 : 		{
; 1121 : 			gObj[n].Trade			= new CItem [MAX_TRADEITEM];

  00405	68 00 15 00 00	 push	 5376			; 00001500H
  0040a	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0040f	83 c4 04	 add	 esp, 4
  00412	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
  00418	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  0041f	83 bd 6c ff ff
	ff 00		 cmp	 DWORD PTR $T7[ebp], 0
  00426	74 26		 je	 SHORT $LN20@gObjInit
  00428	68 00 00 00 00	 push	 OFFSET ??0CItem@@QAE@XZ	; CItem::CItem
  0042d	6a 20		 push	 32			; 00000020H
  0042f	68 a8 00 00 00	 push	 168			; 000000a8H
  00434	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  0043a	50		 push	 eax
  0043b	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z
  00440	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  00446	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv250[ebp], ecx
  0044c	eb 0a		 jmp	 SHORT $LN21@gObjInit
$LN20@gObjInit:
  0044e	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv250[ebp], 0
$LN21@gObjInit:
  00458	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv250[ebp]
  0045e	89 95 70 ff ff
	ff		 mov	 DWORD PTR $T8[ebp], edx
  00464	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0046b	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  00472	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00478	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR $T8[ebp]
  0047e	89 94 01 84 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3204], edx

; 1122 : 			_ASSERT( gObj[n].Trade );
; 1123 : 			
; 1124 : 			gObj[n].TradeMap		= new BYTE [MAX_TRADEITEM];

  00485	6a 20		 push	 32			; 00000020H
  00487	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0048c	83 c4 04	 add	 esp, 4
  0048f	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
  00495	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  0049c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004a2	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR $T6[ebp]
  004a8	89 94 01 88 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3208], edx

; 1125 : 			_ASSERT( gObj[n].TradeMap );
; 1126 : 			
; 1127 : 			gObj[n].pWarehouse		= new CItem [MAX_WAREHOUSEITEMS];

  004af	68 c0 4e 00 00	 push	 20160			; 00004ec0H
  004b4	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  004b9	83 c4 04	 add	 esp, 4
  004bc	89 85 60 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  004c2	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6
  004c9	83 bd 60 ff ff
	ff 00		 cmp	 DWORD PTR $T4[ebp], 0
  004d0	74 26		 je	 SHORT $LN22@gObjInit
  004d2	68 00 00 00 00	 push	 OFFSET ??0CItem@@QAE@XZ	; CItem::CItem
  004d7	6a 78		 push	 120			; 00000078H
  004d9	68 a8 00 00 00	 push	 168			; 000000a8H
  004de	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  004e4	50		 push	 eax
  004e5	e8 00 00 00 00	 call	 ??_H@YGXPAXIIP6EPAX0@Z@Z
  004ea	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
  004f0	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv274[ebp], ecx
  004f6	eb 0a		 jmp	 SHORT $LN23@gObjInit
$LN22@gObjInit:
  004f8	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv274[ebp], 0
$LN23@gObjInit:
  00502	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv274[ebp]
  00508	89 95 64 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], edx
  0050e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00515	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  0051c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00522	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR $T5[ebp]
  00528	89 94 01 94 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3220], edx

; 1128 : 			_ASSERT( gObj[n].pWarehouse );
; 1129 : 			
; 1130 : 			gObj[n].pWarehouseMap	= new BYTE [MAX_WAREHOUSEITEMS];

  0052f	6a 78		 push	 120			; 00000078H
  00531	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00536	83 c4 04	 add	 esp, 4
  00539	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  0053f	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  00546	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0054c	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  00552	89 94 01 98 0c
	00 00		 mov	 DWORD PTR [ecx+eax+3224], edx
$LN7@gObjInit:

; 1131 : 			_ASSERT( gObj[n].pWarehouseMap );
; 1132 : 		}
; 1133 : #else
; 1134 : 		gObj[n].Trade			= new CItem [MAX_TRADEITEM];
; 1135 : 		_ASSERT( gObj[n].Trade );
; 1136 : 
; 1137 : 		gObj[n].TradeMap		= new BYTE [MAX_TRADEITEM];
; 1138 : 		_ASSERT( gObj[n].TradeMap );
; 1139 : 
; 1140 : 		gObj[n].pWarehouse		= new CItem [MAX_WAREHOUSEITEMS];
; 1141 : 		_ASSERT( gObj[n].pWarehouse );
; 1142 : 	
; 1143 : 
; 1144 : 		gObj[n].pWarehouseMap	= new BYTE [MAX_WAREHOUSEITEMS];
; 1145 : 		_ASSERT( gObj[n].pWarehouseMap );
; 1146 : #endif
; 1147 : 		
; 1148 : 		gObj[n].WarehouseCount  = 0;

  00559	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  00560	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00566	c6 84 01 9c 0c
	00 00 00	 mov	 BYTE PTR [ecx+eax+3228], 0

; 1149 : 		gObj[n].pChaosBox		= NULL;

  0056e	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  00575	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0057b	c7 84 01 ac 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax+3244], 0

; 1150 : 
; 1151 : 		/*gObj[n].pChaosBox       = new CItem [MAX_CHAOSBOXSIZE];
; 1152 : 		_ASSERT( gObj[n].pChaosBox );
; 1153 : 		gObj[n].pChaosBoxMap	= new BYTE [MAX_CHAOSBOXSIZE];
; 1154 : 		_ASSERT( gObj[n].pChaosBoxMap );
; 1155 : 		*/
; 1156 : 
; 1157 : #ifdef UPGRADE_GAMESERVER_01_20041006
; 1158 : 		//  SOCKET_CONTEXT .
; 1159 : 		if( n >= ALLOC_USEROBJECTSTART )

  00586	81 7d e8 00 19
	00 00		 cmp	 DWORD PTR _n$22[ebp], 6400 ; 00001900H
  0058d	7c 2a		 jl	 SHORT $LN8@gObjInit

; 1160 : 			gObj[n].PerSocketContext = new PER_SOCKET_CONTEXT;

  0058f	68 6c 00 02 00	 push	 131180			; 0002006cH
  00594	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00599	83 c4 04	 add	 esp, 4
  0059c	89 85 58 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  005a2	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  005a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005af	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  005b5	89 54 01 10	 mov	 DWORD PTR [ecx+eax+16], edx
$LN8@gObjInit:

; 1161 : #else
; 1162 : 		gObj[n].PerSocketContext = new PER_SOCKET_CONTEXT;
; 1163 : #endif
; 1164 : 
; 1165 : 
; 1166 : #ifdef PERSONAL_SHOP_20040113	
; 1167 : 		InitializeCriticalSection (& gObj[n].m_critPShopTrade);

  005b9	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  005c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005c6	8d 94 01 34 0d
	00 00		 lea	 edx, DWORD PTR [ecx+eax+3380]
  005cd	52		 push	 edx
  005ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 1168 : #endif
; 1169 : #ifdef GMCOMMAND_EX
; 1170 : 		gObj[n].m_bGMSummon = FALSE;

  005d4	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$22[ebp], 7072
  005db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005e1	c6 84 01 5c 1a
	00 00 00	 mov	 BYTE PTR [ecx+eax+6748], 0

; 1171 : #endif // GMCOMMAND_EX
; 1172 : 	}

  005e9	e9 d4 fa ff ff	 jmp	 $LN2@gObjInit
$LN3@gObjInit:

; 1173 : 	InitFrustrum();

  005ee	e8 00 00 00 00	 call	 ?InitFrustrum@@YAXXZ	; InitFrustrum

; 1174 : }

  005f3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005f6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005fd	59		 pop	 ecx
  005fe	5f		 pop	 edi
  005ff	5e		 pop	 esi
  00600	5b		 pop	 ebx
  00601	8b e5		 mov	 esp, ebp
  00603	5d		 pop	 ebp
  00604	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?gObjInit@@YAXXZ$0:
  00000	68 e0 46 00 00	 push	 18144			; 000046e0H
  00005	8b 45 a0	 mov	 eax, DWORD PTR $T20[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__unwindfunclet$?gObjInit@@YAXXZ$1:
  00012	68 c4 03 00 00	 push	 964			; 000003c4H
  00017	8b 45 94	 mov	 eax, DWORD PTR $T17[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  00020	83 c4 08	 add	 esp, 8
  00023	c3		 ret	 0
__unwindfunclet$?gObjInit@@YAXXZ$2:
  00024	68 c4 03 00 00	 push	 964			; 000003c4H
  00029	8b 45 8c	 mov	 eax, DWORD PTR $T15[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  00032	83 c4 08	 add	 esp, 8
  00035	c3		 ret	 0
__unwindfunclet$?gObjInit@@YAXXZ$3:
  00036	68 e0 46 00 00	 push	 18144			; 000046e0H
  0003b	8b 45 84	 mov	 eax, DWORD PTR $T13[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  00044	83 c4 08	 add	 esp, 8
  00047	c3		 ret	 0
__unwindfunclet$?gObjInit@@YAXXZ$4:
  00048	68 e0 46 00 00	 push	 18144			; 000046e0H
  0004d	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR $T11[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  00059	83 c4 08	 add	 esp, 8
  0005c	c3		 ret	 0
__unwindfunclet$?gObjInit@@YAXXZ$5:
  0005d	68 00 15 00 00	 push	 5376			; 00001500H
  00062	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0006e	83 c4 08	 add	 esp, 8
  00071	c3		 ret	 0
__unwindfunclet$?gObjInit@@YAXXZ$6:
  00072	68 c0 4e 00 00	 push	 20160			; 00004ec0H
  00077	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  00083	83 c4 08	 add	 esp, 8
  00086	c3		 ret	 0
  00087	cc		 int	 3
  00088	cc		 int	 3
  00089	cc		 int	 3
  0008a	cc		 int	 3
  0008b	cc		 int	 3
__ehhandler$?gObjInit@@YAXXZ:
  0008c	90		 npad	 1
  0008d	90		 npad	 1
  0008e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00092	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00095	8b 8a 50 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-176]
  0009b	33 c8		 xor	 ecx, eax
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?gObjInit@@YAXXZ
  000a7	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?gObjInit@@YAXXZ ENDP					; gObjInit
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjStateAttackProc@@YAXPAVOBJECTSTRUCT@@HHHH@Z
_TEXT	SEGMENT
tv66 = -76						; size = 4
tv73 = -72						; size = 4
tv67 = -72						; size = 4
_lpMagic$1 = -4						; size = 4
_lpObj$ = 8						; size = 4
_aMsgCode$ = 12						; size = 4
_aIndex$ = 16						; size = 4
_SubCode$ = 20						; size = 4
_SubCode2$ = 24						; size = 4
?gObjStateAttackProc@@YAXPAVOBJECTSTRUCT@@HHHH@Z PROC	; gObjStateAttackProc, COMDAT

; 7337 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7338 : 	if( !CHECK_LIMIT(aIndex, MAX_OBJECT)  )

  00009	83 7d 10 00	 cmp	 DWORD PTR _aIndex$[ebp], 0
  0000d	7d 09		 jge	 SHORT $LN11@gObjStateA
  0000f	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00016	eb 1f		 jmp	 SHORT $LN12@gObjStateA
$LN11@gObjStateA:
  00018	81 7d 10 e7 1c
	00 00		 cmp	 DWORD PTR _aIndex$[ebp], 7399 ; 00001ce7H
  0001f	7e 09		 jle	 SHORT $LN9@gObjStateA
  00021	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN10@gObjStateA
$LN9@gObjStateA:
  0002a	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN10@gObjStateA:
  00031	8b 45 b4	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 b8	 mov	 DWORD PTR tv67[ebp], eax
$LN12@gObjStateA:
  00037	83 7d b8 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003b	75 21		 jne	 SHORT $LN4@gObjStateA

; 7339 : 	{
; 7340 : 		LogAdd("error : %s %d",__FILE__, __LINE__);

  0003d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjStateAttackProc@@YAXPAVOBJECTSTRUCT@@HHHH@Z@4JA
  00042	83 c0 03	 add	 eax, 3
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd@
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7341 : 		return;

  00059	e9 8a 00 00 00	 jmp	 $LN1@gObjStateA
$LN4@gObjStateA:

; 7342 : 	}
; 7343 : 	
; 7344 : 	switch( aMsgCode )

  0005e	8b 45 0c	 mov	 eax, DWORD PTR _aMsgCode$[ebp]
  00061	89 45 b8	 mov	 DWORD PTR tv73[ebp], eax
  00064	83 7d b8 32	 cmp	 DWORD PTR tv73[ebp], 50	; 00000032H
  00068	74 08		 je	 SHORT $LN5@gObjStateA
  0006a	83 7d b8 33	 cmp	 DWORD PTR tv73[ebp], 51	; 00000033H
  0006e	74 4b		 je	 SHORT $LN7@gObjStateA
  00070	eb 76		 jmp	 SHORT $LN1@gObjStateA
$LN5@gObjStateA:

; 7345 : 	{
; 7346 : 	case MSG_ATTACKPROC_ENTIREMAGIC :			// .
; 7347 : 		{	
; 7348 : 			if( lpObj->Live )

  00072	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00075	0f b6 48 66	 movzx	 ecx, BYTE PTR [eax+102]
  00079	85 c9		 test	 ecx, ecx
  0007b	74 3c		 je	 SHORT $LN6@gObjStateA

; 7349 : 			{
; 7350 : 				CMagicInf *		lpMagic;
; 7351 : 				lpMagic = gObjGetMagicSearch(lpObj, SubCode);		

  0007d	0f b6 45 14	 movzx	 eax, BYTE PTR _SubCode$[ebp]
  00081	50		 push	 eax
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 ?gObjGetMagicSearch@@YAPAVCMagicInf@@PAVOBJECTSTRUCT@@E@Z ; gObjGetMagicSearch
  0008b	83 c4 08	 add	 esp, 8
  0008e	89 45 fc	 mov	 DWORD PTR _lpMagic$1[ebp], eax

; 7352 : 				gObjAttack(lpObj, &gObj[aIndex], lpMagic, 0, 1, 0, SubCode2);				

  00091	8b 45 18	 mov	 eax, DWORD PTR _SubCode2$[ebp]
  00094	50		 push	 eax
  00095	6a 00		 push	 0
  00097	6a 01		 push	 1
  00099	6a 00		 push	 0
  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _lpMagic$1[ebp]
  0009e	51		 push	 ecx
  0009f	69 55 10 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  000a6	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ac	52		 push	 edx
  000ad	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ?gObjAttack@@YAHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HEHH@Z ; gObjAttack
  000b6	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN6@gObjStateA:

; 7353 : 			}			
; 7354 : 		}
; 7355 : 
; 7356 : 		break;

  000b9	eb 2d		 jmp	 SHORT $LN1@gObjStateA
$LN7@gObjStateA:

; 7357 : 
; 7358 : #ifdef ADD_ITEM_FENRIR_01_20051110
; 7359 : 	case MSG_ATTACKPROC_FENRIR :
; 7360 : 		{
; 7361 : 			if( lpObj->Live )
; 7362 : 			{
; 7363 : 				CMagicInf *		lpMagic;
; 7364 : 				lpMagic = gObjGetMagicSearch(lpObj, SubCode);
; 7365 : 				
; 7366 : 				//    .
; 7367 : 				//            .
; 7368 : 				gObjAttack(lpObj, &gObj[aIndex], lpMagic, 1, 1 );		
; 7369 : 			}
; 7370 : 		}
; 7371 : 		break;
; 7372 : 
; 7373 : #endif
; 7374 : 
; 7375 : #ifdef DARKLORD_WORK
; 7376 : 	case MSG_ATTACKPROC_DARKSPRITATTACK :		//  
; 7377 : 
; 7378 : #ifdef MODIFY_DARKSPIRIT_TAGET_ATTACK_01_20040906
; 7379 : 		gDarkSpirit[lpObj->m_Index].Attack(lpObj, &gObj[aIndex], NULL, SubCode, SubCode2);

  000bb	8b 45 18	 mov	 eax, DWORD PTR _SubCode2$[ebp]
  000be	50		 push	 eax
  000bf	8b 4d 14	 mov	 ecx, DWORD PTR _SubCode$[ebp]
  000c2	51		 push	 ecx
  000c3	6a 00		 push	 0
  000c5	69 55 10 a0 1b
	00 00		 imul	 edx, DWORD PTR _aIndex$[ebp], 7072
  000cc	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d2	52		 push	 edx
  000d3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000da	6b 09 28	 imul	 ecx, DWORD PTR [ecx], 40
  000dd	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  000e3	e8 00 00 00 00	 call	 ?Attack@CDarkSpirit@@QAEHPAVOBJECTSTRUCT@@0PAVCMagicInf@@HH@Z ; CDarkSpirit::Attack
$LN1@gObjStateA:

; 7380 : #else
; 7381 : 		gDarkSpirit[lpObj->m_Index].Attack(lpObj, &gObj[aIndex], NULL, SubCode);		
; 7382 : #endif // MODIFY_DARKSPIRIT_TAGET_ATTACK_01_20040906
; 7383 : 		
; 7384 : 	break;
; 7385 : #endif // DARKLORD_WORK
; 7386 : 
; 7387 : 	}
; 7388 : }

  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	5b		 pop	 ebx
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c3		 ret	 0
?gObjStateAttackProc@@YAXPAVOBJECTSTRUCT@@HHHH@Z ENDP	; gObjStateAttackProc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjAddAttackProcMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHHH@Z
_TEXT	SEGMENT
_aChgIndex$1 = -8					; size = 4
_n$2 = -4						; size = 4
_lpObj$ = 8						; size = 4
_aMsgCode$ = 12						; size = 4
_aIndex$ = 16						; size = 4
_delay$ = 20						; size = 4
_SubCode$ = 24						; size = 4
_SubCode2$ = 28						; size = 4
?gObjAddAttackProcMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHHH@Z PROC ; gObjAddAttackProcMsgSendDelay, COMDAT

; 7150 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 7151 : 	for( int n=0; n<MAXATTACKMESSAGE; n++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$2[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@gObjAddAtt
$LN2@gObjAddAtt:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _n$2[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _n$2[ebp], eax
$LN4@gObjAddAtt:
  0001b	83 7d fc 32	 cmp	 DWORD PTR _n$2[ebp], 50	; 00000032H
  0001f	0f 8d 99 00 00
	00		 jge	 $LN1@gObjAddAtt

; 7152 : 	{
; 7153 : 		int aChgIndex = lpObj->m_Index-ALLOC_USEROBJECTSTART;

  00025	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	81 e9 00 19 00
	00		 sub	 ecx, 6400		; 00001900H
  00030	89 4d f8	 mov	 DWORD PTR _aChgIndex$1[ebp], ecx

; 7154 : 
; 7155 : 		if( gSMAttackProcMsg[aChgIndex][n].MsgCode < 0 )

  00033	69 45 f8 e8 03
	00 00		 imul	 eax, DWORD PTR _aChgIndex$1[ebp], 1000
  0003a	6b 4d fc 14	 imul	 ecx, DWORD PTR _n$2[ebp], 20
  0003e	83 bc 08 00 00
	00 00 00	 cmp	 DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[eax+ecx], 0
  00046	7d 71		 jge	 SHORT $LN5@gObjAddAtt

; 7156 : 		{
; 7157 : 			gSMAttackProcMsg[aChgIndex][n].MsgCode = aMsgCode;

  00048	69 45 f8 e8 03
	00 00		 imul	 eax, DWORD PTR _aChgIndex$1[ebp], 1000
  0004f	6b 4d fc 14	 imul	 ecx, DWORD PTR _n$2[ebp], 20
  00053	8b 55 0c	 mov	 edx, DWORD PTR _aMsgCode$[ebp]
  00056	89 94 08 00 00
	00 00		 mov	 DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[eax+ecx], edx

; 7158 : 			gSMAttackProcMsg[aChgIndex][n].MsgTime = GetTickCount()+delay;

  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00063	03 45 14	 add	 eax, DWORD PTR _delay$[ebp]
  00066	69 4d f8 e8 03
	00 00		 imul	 ecx, DWORD PTR _aChgIndex$1[ebp], 1000
  0006d	6b 55 fc 14	 imul	 edx, DWORD PTR _n$2[ebp], 20
  00071	89 84 11 08 00
	00 00		 mov	 DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[ecx+edx+8], eax

; 7159 : 			gSMAttackProcMsg[aChgIndex][n].SendUser= aIndex;

  00078	69 45 f8 e8 03
	00 00		 imul	 eax, DWORD PTR _aChgIndex$1[ebp], 1000
  0007f	6b 4d fc 14	 imul	 ecx, DWORD PTR _n$2[ebp], 20
  00083	8b 55 10	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00086	89 94 08 04 00
	00 00		 mov	 DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[eax+ecx+4], edx

; 7160 : 			gSMAttackProcMsg[aChgIndex][n].SubCode = SubCode;

  0008d	69 45 f8 e8 03
	00 00		 imul	 eax, DWORD PTR _aChgIndex$1[ebp], 1000
  00094	6b 4d fc 14	 imul	 ecx, DWORD PTR _n$2[ebp], 20
  00098	8b 55 18	 mov	 edx, DWORD PTR _SubCode$[ebp]
  0009b	89 94 08 0c 00
	00 00		 mov	 DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[eax+ecx+12], edx

; 7161 : 			gSMAttackProcMsg[aChgIndex][n].SubCode2 = SubCode2;	

  000a2	69 45 f8 e8 03
	00 00		 imul	 eax, DWORD PTR _aChgIndex$1[ebp], 1000
  000a9	6b 4d fc 14	 imul	 ecx, DWORD PTR _n$2[ebp], 20
  000ad	8b 55 1c	 mov	 edx, DWORD PTR _SubCode2$[ebp]
  000b0	89 94 08 10 00
	00 00		 mov	 DWORD PTR ?gSMAttackProcMsg@@3PAY0DC@UExMessageStateMachine@@A[eax+ecx+16], edx

; 7162 : 			return;

  000b7	eb 05		 jmp	 SHORT $LN1@gObjAddAtt
$LN5@gObjAddAtt:

; 7163 : 		}
; 7164 : 	}	

  000b9	e9 54 ff ff ff	 jmp	 $LN2@gObjAddAtt
$LN1@gObjAddAtt:

; 7165 : }

  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	5b		 pop	 ebx
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
?gObjAddAttackProcMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHHH@Z ENDP ; gObjAddAttackProcMsgSendDelay
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.h
;	COMDAT ?CheckAuthority@@YA_NKPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv69 = -66						; size = 1
tv71 = -65						; size = 1
_dwComposeAuthority$ = 8				; size = 4
_pMyObject$ = 12					; size = 4
?CheckAuthority@@YA_NKPAVOBJECTSTRUCT@@@Z PROC		; CheckAuthority, COMDAT

; 1646 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1647 : 	return ((pMyObject->Authority & AUTHORITY_DISABLE) ? false : ((pMyObject->Authority & dwComposeAuthority) ? true : false));

  00009	8b 45 0c	 mov	 eax, DWORD PTR _pMyObject$[ebp]
  0000c	8b 88 a4 01 00
	00		 mov	 ecx, DWORD PTR [eax+420]
  00012	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00018	74 06		 je	 SHORT $LN5@CheckAutho
  0001a	c6 45 bf 00	 mov	 BYTE PTR tv71[ebp], 0
  0001e	eb 1e		 jmp	 SHORT $LN6@CheckAutho
$LN5@CheckAutho:
  00020	8b 55 0c	 mov	 edx, DWORD PTR _pMyObject$[ebp]
  00023	8b 82 a4 01 00
	00		 mov	 eax, DWORD PTR [edx+420]
  00029	23 45 08	 and	 eax, DWORD PTR _dwComposeAuthority$[ebp]
  0002c	74 06		 je	 SHORT $LN3@CheckAutho
  0002e	c6 45 be 01	 mov	 BYTE PTR tv69[ebp], 1
  00032	eb 04		 jmp	 SHORT $LN4@CheckAutho
$LN3@CheckAutho:
  00034	c6 45 be 00	 mov	 BYTE PTR tv69[ebp], 0
$LN4@CheckAutho:
  00038	8a 4d be	 mov	 cl, BYTE PTR tv69[ebp]
  0003b	88 4d bf	 mov	 BYTE PTR tv71[ebp], cl
$LN6@CheckAutho:
  0003e	8a 45 bf	 mov	 al, BYTE PTR tv71[ebp]

; 1648 : 	//return(((pMyObject->Authority & dwComposeAuthority) == pMyObject->Authority)? true : false);
; 1649 : }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?CheckAuthority@@YA_NKPAVOBJECTSTRUCT@@@Z ENDP		; CheckAuthority
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002e	83 e0 02	 and	 eax, 2
  00031	74 60		 je	 SHORT $LN2@vector
  00033	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  00038	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0003e	51		 push	 ecx
  0003f	68 a0 1b 00 00	 push	 7072			; 00001ba0H
  00044	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0004d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00050	83 e0 01	 and	 eax, 1
  00053	74 36		 je	 SHORT $LN3@vector
  00055	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00058	83 e0 04	 and	 eax, 4
  0005b	75 11		 jne	 SHORT $LN4@vector
  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00060	83 e8 04	 sub	 eax, 4
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ??_VZeroMemBase@@SAXPAX@Z ; ZeroMemBase::operator delete[]
  00069	83 c4 04	 add	 esp, 4
  0006c	eb 1d		 jmp	 SHORT $LN3@vector
$LN4@vector:
  0006e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00071	69 48 fc a0 1b
	00 00		 imul	 ecx, DWORD PTR [eax-4], 7072
  00078	83 c1 04	 add	 ecx, 4
  0007b	51		 push	 ecx
  0007c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0007f	83 ea 04	 sub	 edx, 4
  00082	52		 push	 edx
  00083	e8 00 00 00 00	 call	 ?__global_array_delete@@YAXPAXI@Z ; __global_array_delete
  00088	83 c4 08	 add	 esp, 8
$LN3@vector:
  0008b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	83 e8 04	 sub	 eax, 4
  00091	eb 24		 jmp	 SHORT $LN8@vector
$LN2@vector:
  00093	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ??1OBJECTSTRUCT@@QAE@XZ
  0009b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0009e	83 e0 01	 and	 eax, 1
  000a1	74 11		 je	 SHORT $LN6@vector
  000a3	68 a0 1b 00 00	 push	 7072			; 00001ba0H
  000a8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000b1	83 c4 08	 add	 esp, 8
$LN6@vector:
  000b4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
$LN8@vector:
  000b7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ba	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c1	59		 pop	 ecx
  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 04 00	 ret	 4
  000cb	cc		 int	 3
  000cc	cc		 int	 3
  000cd	cc		 int	 3
  000ce	cc		 int	 3
  000cf	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Odtp /ZI
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	81 c1 44 1a 00
	00		 add	 ecx, 6724		; 00001a44H
  00015	e8 00 00 00 00	 call	 ??1PacketStatistics@@QAE@XZ ; PacketStatistics::~PacketStatistics
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	81 c1 84 10 00
	00		 add	 ecx, 4228		; 00001084H
  00023	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0OBJECTSTRUCT@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	81 c1 84 10 00
	00		 add	 ecx, 4228		; 00001084H
  00034	e8 00 00 00 00	 call	 ??0CSkillDelay@@QAE@XZ	; CSkillDelay::CSkillDelay
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	81 c1 44 1a 00
	00		 add	 ecx, 6724		; 00001a44H
  00049	e8 00 00 00 00	 call	 ??0PacketStatistics@@QAE@XZ ; PacketStatistics::PacketStatistics
  0004e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00055	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00062	59		 pop	 ecx
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0OBJECTSTRUCT@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 84 10 00
	00		 add	 ecx, 4228		; 00001084H
  00009	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
__ehhandler$??0OBJECTSTRUCT@@QAE@XZ:
  00013	90		 npad	 1
  00014	90		 npad	 1
  00015	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00019	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001c	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0OBJECTSTRUCT@@QAE@XZ
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::OBJECTSTRUCT
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ??_VZeroMemBase@@SAXPAX@Z
_TEXT	SEGMENT
_pMalloc$ = 8						; size = 4
??_VZeroMemBase@@SAXPAX@Z PROC				; ZeroMemBase::operator delete[], COMDAT

; 282  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 283  : 		free(pMalloc);

  00009	8b 45 08	 mov	 eax, DWORD PTR _pMalloc$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _free
  00012	83 c4 04	 add	 esp, 4

; 284  : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??_VZeroMemBase@@SAXPAX@Z ENDP				; ZeroMemBase::operator delete[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ??_UZeroMemBase@@SAPAXI@Z
_TEXT	SEGMENT
_pvTemp$ = -4						; size = 4
_stAllocateBlock$ = 8					; size = 4
??_UZeroMemBase@@SAPAXI@Z PROC				; ZeroMemBase::operator new[], COMDAT

; 272  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 273  : 		void *pvTemp = malloc( stAllocateBlock );

  00009	8b 45 08	 mov	 eax, DWORD PTR _stAllocateBlock$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _malloc
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR _pvTemp$[ebp], eax

; 274  : 
; 275  : 		if(pvTemp != NULL)

  00018	83 7d fc 00	 cmp	 DWORD PTR _pvTemp$[ebp], 0
  0001c	74 12		 je	 SHORT $LN2@operator

; 276  : 			memset(pvTemp, 0x00, stAllocateBlock);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _stAllocateBlock$[ebp]
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _pvTemp$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _memset
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@operator:

; 277  : 
; 278  : 		return(pvTemp);

  00030	8b 45 fc	 mov	 eax, DWORD PTR _pvTemp$[ebp]

; 279  : 	}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??_UZeroMemBase@@SAPAXI@Z ENDP				; ZeroMemBase::operator new[]
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.h
;	COMDAT ?GetDeductType@BILL_CLASS@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDeductType@BILL_CLASS@@QAEEXZ PROC			; BILL_CLASS::GetDeductType, COMDAT
; _this$ = ecx

; 417  : 	BYTE	GetDeductType()	{ return btDeductType; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8a 00		 mov	 al, BYTE PTR [eax]
  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?GetDeductType@BILL_CLASS@@QAEEXZ ENDP			; BILL_CLASS::GetDeductType
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.h
;	COMDAT ?GetRestPoint@BILL_CLASS@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRestPoint@BILL_CLASS@@QAEKXZ PROC			; BILL_CLASS::GetRestPoint, COMDAT
; _this$ = ecx

; 416  : 	DWORD	GetRestPoint()	{ return dwRestPoint; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetRestPoint@BILL_CLASS@@QAEKXZ ENDP			; BILL_CLASS::GetRestPoint
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.h
;	COMDAT ?GetRestTime@BILL_CLASS@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRestTime@BILL_CLASS@@QAEKXZ PROC			; BILL_CLASS::GetRestTime, COMDAT
; _this$ = ecx

; 415  : 	DWORD	GetRestTime()	{ return dwRestTime; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetRestTime@BILL_CLASS@@QAEKXZ ENDP			; BILL_CLASS::GetRestTime
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.h
;	COMDAT ?GetEndsDays@BILL_CLASS@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEndsDays@BILL_CLASS@@QAEPADXZ PROC			; BILL_CLASS::GetEndsDays, COMDAT
; _this$ = ecx

; 412  : 	char* GetEndsDays() { return EndsDays; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetEndsDays@BILL_CLASS@@QAEPADXZ ENDP			; BILL_CLASS::GetEndsDays
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.h
;	COMDAT ?Init@BILL_CLASS@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Init@BILL_CLASS@@QAEXXZ PROC				; BILL_CLASS::Init, COMDAT
; _this$ = ecx

; 343  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 344  : #ifdef UPDATE_UNIFICATIONBILL_20090203
; 345  : 		btDeductType	= BILL_TYPE_NONE;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c6 00 00	 mov	 BYTE PTR [eax], 0

; 346  : 		dwRestPoint		= 0;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 347  : 		dwRestTime		= 0;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 348  : #else	// UPDATE_UNIFICATIONBILL_20090203
; 349  : 		cCertifyType	= -1;
; 350  : 		PayCode			= 0;
; 351  : 		EndTime			= 0;
; 352  : #endif	// UPDATE_UNIFICATIONBILL_20090203
; 353  : 
; 354  : 		EndsDays[0]		= '\0';

  00026	b8 01 00 00 00	 mov	 eax, 1
  0002b	6b c8 00	 imul	 ecx, eax, 0
  0002e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00031	c6 44 0a 0c 00	 mov	 BYTE PTR [edx+ecx+12], 0

; 355  : 	};

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?Init@BILL_CLASS@@QAEXXZ ENDP				; BILL_CLASS::Init
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.h
;	COMDAT ??0BILL_CLASS@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BILL_CLASS@@QAE@XZ PROC				; BILL_CLASS::BILL_CLASS, COMDAT
; _this$ = ecx

; 337  : 	BILL_CLASS()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 338  : 	{
; 339  : 		Init();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?Init@BILL_CLASS@@QAEXXZ ; BILL_CLASS::Init

; 340  : 	};

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0BILL_CLASS@@QAE@XZ ENDP				; BILL_CLASS::BILL_CLASS
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjWeaponMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z
_TEXT	SEGMENT
_n$ = -8						; size = 4
_skill$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_aSkill$ = 12						; size = 1
_Level$ = 16						; size = 1
?gObjWeaponMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z PROC	; gObjWeaponMagicAdd, COMDAT

; 28268: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 28269: 	int skill=-1;

  00009	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _skill$[ebp], -1

; 28270: 	int n;
; 28271: 
; 28272: 	skill = -1;

  00010	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _skill$[ebp], -1

; 28273: 
; 28274: #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122	// SkillGetRequireClass(...) 3 
; 28275: 	if( MagicDamageC.SkillGetRequireClass(lpObj->Class, lpObj->ChangeUP, lpObj->ThirdChangeUp, aSkill) < 1 ) return -1;
; 28276: #else
; 28277: #ifdef NEW_SKILL_FORSKYLAND
; 28278: 	if( MagicDamageC.SkillGetRequireClass(lpObj->Class, lpObj->ChangeUP, aSkill) < 1 ) return -1;

  00017	0f b6 45 0c	 movzx	 eax, BYTE PTR _aSkill$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0001f	0f b6 91 9f 00
	00 00		 movzx	 edx, BYTE PTR [ecx+159]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002a	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00031	51		 push	 ecx
  00032	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00037	e8 00 00 00 00	 call	 ?SkillGetRequireClass@CMagicDamage@@QAEHHHH@Z ; CMagicDamage::SkillGetRequireClass
  0003c	83 f8 01	 cmp	 eax, 1
  0003f	7d 08		 jge	 SHORT $LN5@gObjWeapon
  00041	83 c8 ff	 or	 eax, -1
  00044	e9 d2 00 00 00	 jmp	 $LN1@gObjWeapon
$LN5@gObjWeapon:

; 28279: #else
; 28280: 	if( MagicDamageC.SkillGetRequireClass(lpObj->Class, aSkill) < 1 ) return -1;
; 28281: #endif
; 28282: #endif	// MASTER_LEVEL_SKILL_SYSTEM_20071122
; 28283: 
; 28284: #ifdef MODIFY_WEAPONSKILL_STRENGTHEN_ICON_BUGFIX_2ND_20090514
; 28285: 	//////////////////////////////////////////////////////////////////////////
; 28286: 	//       .
; 28287: 	//////////////////////////////////////////////////////////////////////////
; 28288: #else // MODIFY_WEAPONSKILL_STRENGTHEN_ICON_BUGFIX_2ND_20090514
; 28289: 	#ifdef MODIFY_WEAPONSKILL_STRENGTHEN_ICON_BUGFIX_20080807
; 28290: 	if( g_MasterSkillSystem.MLS_WeaponSkillAdd(lpObj, aSkill, Level) )
; 28291: 	{
; 28292: 		return -1;
; 28293: 	}
; 28294: 	#else	// MODIFY_WEAPONSKILL_STRENGTHEN_ICON_BUGFIX_20080807
; 28295: 	#ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	//   
; 28296: 	//         .
; 28297: 	//         () .
; 28298: 	if( g_MasterSkillSystem.IsExistMLSBasedSkill( lpObj, aSkill ) )
; 28299: 		return -1;
; 28300: 	#endif
; 28301: 	#endif	// MODIFY_WEAPONSKILL_STRENGTHEN_ICON_BUGFIX_20080807
; 28302: #endif // MODIFY_WEAPONSKILL_STRENGTHEN_ICON_BUGFIX_2ND_20090514
; 28303: 
; 28304: 	for( n=0; n<MAX_MAGIC; n++)

  00049	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00050	eb 09		 jmp	 SHORT $LN4@gObjWeapon
$LN2@gObjWeapon:
  00052	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00055	83 c0 01	 add	 eax, 1
  00058	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
$LN4@gObjWeapon:
  0005b	83 7d f8 3c	 cmp	 DWORD PTR _n$[ebp], 60	; 0000003cH
  0005f	0f 8d 8b 00 00
	00		 jge	 $LN3@gObjWeapon

; 28305: 	{
; 28306: 		if( lpObj->Magic[n].IsMagic() == FALSE )

  00065	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00068	c1 e1 04	 shl	 ecx, 4
  0006b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006e	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  00074	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  00079	85 c0		 test	 eax, eax
  0007b	75 6e		 jne	 SHORT $LN6@gObjWeapon

; 28307: 		{
; 28308: 			skill = lpObj->Magic[n].Set(aSkill, Level);

  0007d	0f b6 45 10	 movzx	 eax, BYTE PTR _Level$[ebp]
  00081	50		 push	 eax
  00082	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _aSkill$[ebp]
  00086	51		 push	 ecx
  00087	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  0008a	c1 e1 04	 shl	 ecx, 4
  0008d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00090	03 8a 10 03 00
	00		 add	 ecx, DWORD PTR [edx+784]
  00096	e8 00 00 00 00	 call	 ?Set@CMagicInf@@QAEHEE@Z ; CMagicInf::Set
  0009b	89 45 fc	 mov	 DWORD PTR _skill$[ebp], eax

; 28309: 			if( skill < 0 ) 

  0009e	83 7d fc 00	 cmp	 DWORD PTR _skill$[ebp], 0
  000a2	7d 2d		 jge	 SHORT $LN7@gObjWeapon

; 28310: 			{
; 28311: 				LogAdd(lMsg.Get(553),__FILE__, __LINE__);

  000a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjWeaponMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z@4JA
  000a9	83 c0 2b	 add	 eax, 43			; 0000002bH
  000ac	50		 push	 eax
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000b2	68 29 02 00 00	 push	 553			; 00000229H
  000b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000c2	50		 push	 eax
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28312: 				return -1;

  000cc	83 c8 ff	 or	 eax, -1
  000cf	eb 4a		 jmp	 SHORT $LN1@gObjWeapon
$LN7@gObjWeapon:

; 28313: 			}			
; 28314: 			lpObj->MagicCount++;

  000d1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d4	8a 88 14 03 00
	00		 mov	 cl, BYTE PTR [eax+788]
  000da	80 c1 01	 add	 cl, 1
  000dd	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000e0	88 8a 14 03 00
	00		 mov	 BYTE PTR [edx+788], cl

; 28315: 			return n;

  000e6	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000e9	eb 30		 jmp	 SHORT $LN1@gObjWeapon
$LN6@gObjWeapon:

; 28316: 		}
; 28317: 	}

  000eb	e9 62 ff ff ff	 jmp	 $LN2@gObjWeapon
$LN3@gObjWeapon:

; 28318: 	LogAdd(lMsg.Get(554),__FILE__, __LINE__);

  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??gObjWeaponMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z@4JA
  000f5	83 c0 32	 add	 eax, 50			; 00000032H
  000f8	50		 push	 eax
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BCNNLIDP@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  000fe	68 2a 02 00 00	 push	 554			; 0000022aH
  00103	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0010e	50		 push	 eax
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH

; 28319: 	return -1;

  00118	83 c8 ff	 or	 eax, -1
$LN1@gObjWeapon:

; 28320: }

  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx
  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
?gObjWeaponMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ENDP	; gObjWeaponMagicAdd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjMagicAddEnergyCheckOnOff@@YAXH@Z
_TEXT	SEGMENT
_flag$ = 8						; size = 4
?gObjMagicAddEnergyCheckOnOff@@YAXH@Z PROC		; gObjMagicAddEnergyCheckOnOff, COMDAT

; 28023: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 28024: 	g_EnergyCheckOff = flag;

  00009	8b 45 08	 mov	 eax, DWORD PTR _flag$[ebp]
  0000c	a3 00 00 00 00	 mov	 DWORD PTR ?g_EnergyCheckOff@@3HA, eax ; g_EnergyCheckOff

; 28025: }

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?gObjMagicAddEnergyCheckOnOff@@YAXH@Z ENDP		; gObjMagicAddEnergyCheckOnOff
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gCheckSkillDistance@@YAHHHH@Z
_TEXT	SEGMENT
_lpTargetObj$ = -12					; size = 4
_lpObj$ = -8						; size = 4
_iSkillDistance$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_aTargetIndex$ = 12					; size = 4
_iSkillNum$ = 16					; size = 4
?gCheckSkillDistance@@YAHHHH@Z PROC			; gCheckSkillDistance, COMDAT

; 33929: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 33930: 	//      true 
; 33931: 	if ( g_iSkillDistanceCheck == 0 )

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_iSkillDistanceCheck@@3HA, 0 ; g_iSkillDistanceCheck
  00010	75 0a		 jne	 SHORT $LN2@gCheckSkil

; 33932: 		return TRUE;

  00012	b8 01 00 00 00	 mov	 eax, 1
  00017	e9 fb 00 00 00	 jmp	 $LN1@gCheckSkil
$LN2@gCheckSkil:

; 33933: 
; 33934: 	//      
; 33935: #ifdef MODIFY_SKILL_CHECK_DISTANCE_UPDATE_20060417
; 33936: 	if ( iSkillNum == AT_SKILL_EXPHELL )

  0001c	83 7d 10 28	 cmp	 DWORD PTR _iSkillNum$[ebp], 40 ; 00000028H
  00020	75 0a		 jne	 SHORT $LN3@gCheckSkil

; 33937: 	{
; 33938: 		return TRUE;

  00022	b8 01 00 00 00	 mov	 eax, 1
  00027	e9 eb 00 00 00	 jmp	 $LN1@gCheckSkil
$LN3@gCheckSkil:

; 33939: 	}
; 33940: #endif
; 33941: 	
; 33942: 	//    
; 33943: 	int iSkillDistance = MagicDamageC.GetSkillDistance(iSkillNum);

  0002c	8b 45 10	 mov	 eax, DWORD PTR _iSkillNum$[ebp]
  0002f	50		 push	 eax
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  00035	e8 00 00 00 00	 call	 ?GetSkillDistance@CMagicDamage@@QAEHH@Z ; CMagicDamage::GetSkillDistance
  0003a	89 45 fc	 mov	 DWORD PTR _iSkillDistance$[ebp], eax

; 33944: 	if ( iSkillDistance == -1 )

  0003d	83 7d fc ff	 cmp	 DWORD PTR _iSkillDistance$[ebp], -1
  00041	75 07		 jne	 SHORT $LN4@gCheckSkil

; 33945: 		return FALSE;

  00043	33 c0		 xor	 eax, eax
  00045	e9 cd 00 00 00	 jmp	 $LN1@gCheckSkil
$LN4@gCheckSkil:

; 33946: 
; 33947: 	//  
; 33948: 	iSkillDistance += g_iSkillDistanceCheckTemp;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _iSkillDistance$[ebp]
  0004d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?g_iSkillDistanceCheckTemp@@3HA ; g_iSkillDistanceCheckTemp
  00053	89 45 fc	 mov	 DWORD PTR _iSkillDistance$[ebp], eax

; 33949: 
; 33950: 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00056	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0005d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00063	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 33951: 	LPOBJECTSTRUCT lpTargetObj = &gObj[aTargetIndex];

  00066	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _aTargetIndex$[ebp], 7072
  0006d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00073	89 45 f4	 mov	 DWORD PTR _lpTargetObj$[ebp], eax

; 33952: 
; 33953: 	//   
; 33954: 	if ( abs(lpObj->X - lpTargetObj->X) > iSkillDistance 
; 33955: 		|| abs(lpObj->Y - lpTargetObj->Y) > iSkillDistance )

  00076	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00079	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  00080	8b 55 f4	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00083	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  0008a	2b c8		 sub	 ecx, eax
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 _abs
  00092	83 c4 04	 add	 esp, 4
  00095	3b 45 fc	 cmp	 eax, DWORD PTR _iSkillDistance$[ebp]
  00098	7f 24		 jg	 SHORT $LN6@gCheckSkil
  0009a	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009d	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  000a4	8b 55 f4	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  000a7	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  000ae	2b c8		 sub	 ecx, eax
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 _abs
  000b6	83 c4 04	 add	 esp, 4
  000b9	3b 45 fc	 cmp	 eax, DWORD PTR _iSkillDistance$[ebp]
  000bc	7e 54		 jle	 SHORT $LN5@gCheckSkil
$LN6@gCheckSkil:

; 33956: 	{
; 33957: 		//   .
; 33958: 		LogAddTD("[SKILL DISTANCE CHECK] [%s][%s] Invalid Skill attacker(%d, %d), defender(%d, %d), skillnum:%d skilldistance:%d", 

  000be	8b 45 fc	 mov	 eax, DWORD PTR _iSkillDistance$[ebp]
  000c1	50		 push	 eax
  000c2	8b 4d 10	 mov	 ecx, DWORD PTR _iSkillNum$[ebp]
  000c5	51		 push	 ecx
  000c6	8b 55 f4	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  000c9	0f bf 82 06 01
	00 00		 movsx	 eax, WORD PTR [edx+262]
  000d0	50		 push	 eax
  000d1	8b 4d f4	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  000d4	0f bf 91 04 01
	00 00		 movsx	 edx, WORD PTR [ecx+260]
  000db	52		 push	 edx
  000dc	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000df	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  000e6	51		 push	 ecx
  000e7	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ea	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  000f1	50		 push	 eax
  000f2	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000f5	83 c1 73	 add	 ecx, 115		; 00000073H
  000f8	51		 push	 ecx
  000f9	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000fc	83 c2 68	 add	 edx, 104		; 00000068H
  000ff	52		 push	 edx
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_0GP@MDNOLJFE@?$FLSKILL?5DISTANCE?5CHECK?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN@
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0010b	83 c4 24	 add	 esp, 36			; 00000024H

; 33959: 				  lpObj->AccountID, 
; 33960: 				  lpObj->Name, 
; 33961: 				  lpObj->X,
; 33962: 				  lpObj->Y,
; 33963: 				  lpTargetObj->X,
; 33964: 				  lpTargetObj->Y,
; 33965: 				  iSkillNum,
; 33966: 				  iSkillDistance);
; 33967: 		return FALSE;

  0010e	33 c0		 xor	 eax, eax
  00110	eb 05		 jmp	 SHORT $LN1@gCheckSkil
$LN5@gCheckSkil:

; 33968: 	}
; 33969: 
; 33970: 	return TRUE;

  00112	b8 01 00 00 00	 mov	 eax, 1
$LN1@gCheckSkil:

; 33971: }

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
?gCheckSkillDistance@@YAHHHH@Z ENDP			; gCheckSkillDistance
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z
_TEXT	SEGMENT
_lpItem$ = 8						; size = 4
?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z PROC		; gObjCheckSerial0ItemList, COMDAT

; 33846: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 33847: #ifdef MODIFY_SERIAL_CHECK_OPTION_RELOAD_20080212
; 33848: 	if(gItemSerialCheck==FALSE) return FALSE;

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gItemSerialCheck@@3HA, 0 ; gItemSerialCheck
  00010	75 07		 jne	 SHORT $LN2@gObjCheckS
  00012	33 c0		 xor	 eax, eax
  00014	e9 db 00 00 00	 jmp	 $LN1@gObjCheckS
$LN2@gObjCheckS:

; 33849: #else
; 33850: 	if(gItemSerialCheck==FALSE) return TRUE;
; 33851: #endif // MODIFY_SERIAL_CHECK_OPTION_RELOAD_20080212
; 33852: 	
; 33853: 	if( lpItem->m_Type == MAKE_ITEMNUM(14, 13)		// 
; 33854: 		|| lpItem->m_Type == MAKE_ITEMNUM(14, 14)	// 
; 33855: 		|| lpItem->m_Type == MAKE_ITEMNUM(14, 16)	// 
; 33856: 		|| lpItem->m_Type == MAKE_ITEMNUM(14, 22)	// 
; 33857: 		|| lpItem->m_Type == MAKE_ITEMNUM(12, 15)	// 
; 33858: 		|| lpItem->m_Type == MAKE_ITEMNUM(12, 30)	//  
; 33859: 		|| lpItem->m_Type == MAKE_ITEMNUM(12, 31)	//  
; 33860: 		|| lpItem->m_Type == MAKE_ITEMNUM(14, 31)	//  

  00019	8b 45 08	 mov	 eax, DWORD PTR _lpItem$[ebp]
  0001c	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00020	6a 0d		 push	 13			; 0000000dH
  00022	6a 0e		 push	 14			; 0000000eH
  00024	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00029	83 c4 08	 add	 esp, 8
  0002c	3b f0		 cmp	 esi, eax
  0002e	0f 84 a5 00 00
	00		 je	 $LN4@gObjCheckS
  00034	8b 45 08	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00037	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0003b	6a 0e		 push	 14			; 0000000eH
  0003d	6a 0e		 push	 14			; 0000000eH
  0003f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00044	83 c4 08	 add	 esp, 8
  00047	3b f0		 cmp	 esi, eax
  00049	0f 84 8a 00 00
	00		 je	 $LN4@gObjCheckS
  0004f	8b 45 08	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00052	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00056	6a 10		 push	 16			; 00000010H
  00058	6a 0e		 push	 14			; 0000000eH
  0005a	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0005f	83 c4 08	 add	 esp, 8
  00062	3b f0		 cmp	 esi, eax
  00064	74 73		 je	 SHORT $LN4@gObjCheckS
  00066	8b 45 08	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00069	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0006d	6a 16		 push	 22			; 00000016H
  0006f	6a 0e		 push	 14			; 0000000eH
  00071	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00076	83 c4 08	 add	 esp, 8
  00079	3b f0		 cmp	 esi, eax
  0007b	74 5c		 je	 SHORT $LN4@gObjCheckS
  0007d	8b 45 08	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00080	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00084	6a 0f		 push	 15			; 0000000fH
  00086	6a 0c		 push	 12			; 0000000cH
  00088	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0008d	83 c4 08	 add	 esp, 8
  00090	3b f0		 cmp	 esi, eax
  00092	74 45		 je	 SHORT $LN4@gObjCheckS
  00094	8b 45 08	 mov	 eax, DWORD PTR _lpItem$[ebp]
  00097	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0009b	6a 1e		 push	 30			; 0000001eH
  0009d	6a 0c		 push	 12			; 0000000cH
  0009f	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000a4	83 c4 08	 add	 esp, 8
  000a7	3b f0		 cmp	 esi, eax
  000a9	74 2e		 je	 SHORT $LN4@gObjCheckS
  000ab	8b 45 08	 mov	 eax, DWORD PTR _lpItem$[ebp]
  000ae	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  000b2	6a 1f		 push	 31			; 0000001fH
  000b4	6a 0c		 push	 12			; 0000000cH
  000b6	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000bb	83 c4 08	 add	 esp, 8
  000be	3b f0		 cmp	 esi, eax
  000c0	74 17		 je	 SHORT $LN4@gObjCheckS
  000c2	8b 45 08	 mov	 eax, DWORD PTR _lpItem$[ebp]
  000c5	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  000c9	6a 1f		 push	 31			; 0000001fH
  000cb	6a 0e		 push	 14			; 0000000eH
  000cd	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000d2	83 c4 08	 add	 esp, 8
  000d5	3b f0		 cmp	 esi, eax
  000d7	75 19		 jne	 SHORT $LN3@gObjCheckS
$LN4@gObjCheckS:

; 33861: 	  )
; 33862: 	{
; 33863: 		if( lpItem->GetNumber() == 0 )

  000d9	8b 4d 08	 mov	 ecx, DWORD PTR _lpItem$[ebp]
  000dc	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  000e1	85 c0		 test	 eax, eax
  000e3	75 09		 jne	 SHORT $LN5@gObjCheckS

; 33864: 			return TRUE;

  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	eb 08		 jmp	 SHORT $LN1@gObjCheckS
  000ec	eb 04		 jmp	 SHORT $LN3@gObjCheckS
$LN5@gObjCheckS:

; 33865: 		else
; 33866: 			return FALSE;

  000ee	33 c0		 xor	 eax, eax
  000f0	eb 02		 jmp	 SHORT $LN1@gObjCheckS
$LN3@gObjCheckS:

; 33867: 	}
; 33868: 
; 33869: 	return FALSE;

  000f2	33 c0		 xor	 eax, eax
$LN1@gObjCheckS:

; 33870: }

  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ENDP		; gObjCheckSerial0ItemList
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCheckInventorySerial0Item@@YAHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_i$1 = -12						; size = 4
_iCount$ = -8						; size = 4
_iItemSerial$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?gObjCheckInventorySerial0Item@@YAHPAVOBJECTSTRUCT@@@Z PROC ; gObjCheckInventorySerial0Item, COMDAT

; 33873: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 33874: 
; 33875: #ifdef MODIFY_SERIAL_CHECK_OPTION_RELOAD_20080212
; 33876: 	if(gItemSerialCheck==FALSE) return FALSE;

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gItemSerialCheck@@3HA, 0 ; gItemSerialCheck
  00010	75 07		 jne	 SHORT $LN5@gObjCheckI
  00012	33 c0		 xor	 eax, eax
  00014	e9 ce 00 00 00	 jmp	 $LN1@gObjCheckI
$LN5@gObjCheckI:

; 33877: #else
; 33878: 	if(gItemSerialCheck==FALSE) return TRUE;
; 33879: #endif // MODIFY_SERIAL_CHECK_OPTION_RELOAD_20080212
; 33880: 
; 33881: 	int iItemSerial;
; 33882: 	int iCount = 0;

  00019	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 0

; 33883: 	
; 33884: #ifdef PERSONAL_SHOP_20040113
; 33885: 	for( int i=0; i<MAX_INVENTORY_EXTEND; i++)

  00020	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00027	eb 09		 jmp	 SHORT $LN4@gObjCheckI
$LN2@gObjCheckI:
  00029	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 f4	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@gObjCheckI:
  00032	83 7d f4 6c	 cmp	 DWORD PTR _i$1[ebp], 108 ; 0000006cH
  00036	0f 8d 9c 00 00
	00		 jge	 $LN3@gObjCheckI

; 33886: #else
; 33887: 	for( int i=0; i<MAX_INVENTORY; i++)
; 33888: #endif
; 33889: 	{
; 33890: 		// 1. >   
; 33891: 		if( !lpObj->pInventory[i].IsItem() )

  0003c	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _i$1[ebp], 168
  00043	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00046	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0004c	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00051	85 c0		 test	 eax, eax
  00053	75 02		 jne	 SHORT $LN6@gObjCheckI

; 33892: 		{
; 33893: 			continue;

  00055	eb d2		 jmp	 SHORT $LN2@gObjCheckI
$LN6@gObjCheckI:

; 33894: 		}
; 33895: 
; 33896: 		// 2. >     
; 33897: 		if( !gObjCheckSerial0ItemList(&lpObj->pInventory[i]) )

  00057	69 45 f4 a8 00
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 168
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00061	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ?gObjCheckSerial0ItemList@@YAHPAVCItem@@@Z ; gObjCheckSerial0ItemList
  0006d	83 c4 04	 add	 esp, 4
  00070	85 c0		 test	 eax, eax
  00072	75 02		 jne	 SHORT $LN7@gObjCheckI

; 33898: 		{
; 33899: 			continue;

  00074	eb b3		 jmp	 SHORT $LN2@gObjCheckI
$LN7@gObjCheckI:

; 33900: 		}
; 33901: 		
; 33902: 		// 3. >  0  
; 33903: 		iItemSerial = lpObj->pInventory[i].GetNumber();

  00076	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _i$1[ebp], 168
  0007d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00080	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00086	e8 00 00 00 00	 call	 ?GetNumber@CItem@@QAEKXZ ; CItem::GetNumber
  0008b	89 45 fc	 mov	 DWORD PTR _iItemSerial$[ebp], eax

; 33904: 
; 33905: 		// 4. >  
; 33906: 		if( iItemSerial==0 )	

  0008e	83 7d fc 00	 cmp	 DWORD PTR _iItemSerial$[ebp], 0
  00092	75 3f		 jne	 SHORT $LN8@gObjCheckI

; 33907: 		{	
; 33908: 			LogAddTD( "[ANTI-HACK][Serial 0 Item] (%s)(%s) Item(%s) Pos(%d)",

  00094	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  00097	50		 push	 eax
  00098	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _i$1[ebp], 168
  0009f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000a2	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  000a8	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000ad	50		 push	 eax
  000ae	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b1	83 c0 73	 add	 eax, 115		; 00000073H
  000b4	50		 push	 eax
  000b5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000b8	83 c1 68	 add	 ecx, 104		; 00000068H
  000bb	51		 push	 ecx
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@GBAGDNJH@?$FLANTI?9HACK?$FN?$FLSerial?50?5Item?$FN?5?$CI?$CFs?$CJ@
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c7	83 c4 14	 add	 esp, 20			; 00000014H

; 33909: 				lpObj->AccountID, lpObj->Name, lpObj->pInventory[i].GetName(), i );
; 33910: 
; 33911: 			//gObjUserKill(lpObj->m_Index);
; 33912: 			iCount++;

  000ca	8b 45 f8	 mov	 eax, DWORD PTR _iCount$[ebp]
  000cd	83 c0 01	 add	 eax, 1
  000d0	89 45 f8	 mov	 DWORD PTR _iCount$[ebp], eax
$LN8@gObjCheckI:

; 33913: 		}
; 33914: 	}

  000d3	e9 51 ff ff ff	 jmp	 $LN2@gObjCheckI
$LN3@gObjCheckI:

; 33915: 	
; 33916: 	if( iCount > 0 )

  000d8	83 7d f8 00	 cmp	 DWORD PTR _iCount$[ebp], 0
  000dc	7e 07		 jle	 SHORT $LN9@gObjCheckI

; 33917: 		return TRUE;

  000de	b8 01 00 00 00	 mov	 eax, 1
  000e3	eb 02		 jmp	 SHORT $LN1@gObjCheckI
$LN9@gObjCheckI:

; 33918: 	
; 33919: 	return FALSE;

  000e5	33 c0		 xor	 eax, eax
$LN1@gObjCheckI:

; 33920: }

  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
?gObjCheckInventorySerial0Item@@YAHPAVOBJECTSTRUCT@@@Z ENDP ; gObjCheckInventorySerial0Item
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z
_TEXT	SEGMENT
tv88 = -80						; size = 4
tv78 = -80						; size = 4
tv71 = -80						; size = 4
_btMapAttr$1 = -9					; size = 1
_iUY$ = -8						; size = 4
_iUX$ = -4						; size = 4
_iMapNumber$ = 8					; size = 4
_cX$ = 12						; size = 4
_cY$ = 16						; size = 4
_iRangeX$ = 20						; size = 4
_iRangeY$ = 24						; size = 4
_iLoopCount$ = 28					; size = 4
?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z PROC	; gObjGetRandomItemDropLocation, COMDAT

; 32587: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 32588: 	INT iUX = cX;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _cX$[ebp]
  0000c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0000f	89 4d fc	 mov	 DWORD PTR _iUX$[ebp], ecx

; 32589: 	INT iUY = cY;

  00012	8b 45 10	 mov	 eax, DWORD PTR _cY$[ebp]
  00015	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00018	89 4d f8	 mov	 DWORD PTR _iUY$[ebp], ecx

; 32590: 
; 32591: 	if (iRangeX <= 0)		iRangeX	= 1;

  0001b	83 7d 14 00	 cmp	 DWORD PTR _iRangeX$[ebp], 0
  0001f	7f 07		 jg	 SHORT $LN4@gObjGetRan
  00021	c7 45 14 01 00
	00 00		 mov	 DWORD PTR _iRangeX$[ebp], 1
$LN4@gObjGetRan:

; 32592: 	if (iRangeY <= 0)		iRangeY	= 1;

  00028	83 7d 18 00	 cmp	 DWORD PTR _iRangeY$[ebp], 0
  0002c	7f 07		 jg	 SHORT $LN5@gObjGetRan
  0002e	c7 45 18 01 00
	00 00		 mov	 DWORD PTR _iRangeY$[ebp], 1
$LN5@gObjGetRan:

; 32593: 	if (iLoopCount <= 0)	iLoopCount	= 1;

  00035	83 7d 1c 00	 cmp	 DWORD PTR _iLoopCount$[ebp], 0
  00039	7f 07		 jg	 SHORT $LN2@gObjGetRan
  0003b	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR _iLoopCount$[ebp], 1
$LN2@gObjGetRan:

; 32594: 
; 32595: 	while (iLoopCount-- > 0) {

  00042	8b 45 1c	 mov	 eax, DWORD PTR _iLoopCount$[ebp]
  00045	89 45 b0	 mov	 DWORD PTR tv71[ebp], eax
  00048	8b 4d 1c	 mov	 ecx, DWORD PTR _iLoopCount$[ebp]
  0004b	83 e9 01	 sub	 ecx, 1
  0004e	89 4d 1c	 mov	 DWORD PTR _iLoopCount$[ebp], ecx
  00051	83 7d b0 00	 cmp	 DWORD PTR tv71[ebp], 0
  00055	0f 8e bf 00 00
	00		 jle	 $LN3@gObjGetRan

; 32596: 		cX = (rand() % (iRangeX + 1)) * ((rand() % 2) ? 1 : -1) + iUX;

  0005b	e8 00 00 00 00	 call	 _rand
  00060	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00065	79 05		 jns	 SHORT $LN13@gObjGetRan
  00067	48		 dec	 eax
  00068	83 c8 fe	 or	 eax, -2			; fffffffeH
  0006b	40		 inc	 eax
$LN13@gObjGetRan:
  0006c	85 c0		 test	 eax, eax
  0006e	74 09		 je	 SHORT $LN9@gObjGetRan
  00070	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  00077	eb 07		 jmp	 SHORT $LN10@gObjGetRan
$LN9@gObjGetRan:
  00079	c7 45 b0 ff ff
	ff ff		 mov	 DWORD PTR tv78[ebp], -1
$LN10@gObjGetRan:
  00080	e8 00 00 00 00	 call	 _rand
  00085	8b 4d 14	 mov	 ecx, DWORD PTR _iRangeX$[ebp]
  00088	83 c1 01	 add	 ecx, 1
  0008b	99		 cdq
  0008c	f7 f9		 idiv	 ecx
  0008e	0f af 55 b0	 imul	 edx, DWORD PTR tv78[ebp]
  00092	03 55 fc	 add	 edx, DWORD PTR _iUX$[ebp]
  00095	8b 45 0c	 mov	 eax, DWORD PTR _cX$[ebp]
  00098	88 10		 mov	 BYTE PTR [eax], dl

; 32597: 		cY = (rand() % (iRangeY + 1)) * ((rand() % 2) ? 1 : -1) + iUY;

  0009a	e8 00 00 00 00	 call	 _rand
  0009f	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000a4	79 05		 jns	 SHORT $LN14@gObjGetRan
  000a6	48		 dec	 eax
  000a7	83 c8 fe	 or	 eax, -2			; fffffffeH
  000aa	40		 inc	 eax
$LN14@gObjGetRan:
  000ab	85 c0		 test	 eax, eax
  000ad	74 09		 je	 SHORT $LN11@gObjGetRan
  000af	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
  000b6	eb 07		 jmp	 SHORT $LN12@gObjGetRan
$LN11@gObjGetRan:
  000b8	c7 45 b0 ff ff
	ff ff		 mov	 DWORD PTR tv88[ebp], -1
$LN12@gObjGetRan:
  000bf	e8 00 00 00 00	 call	 _rand
  000c4	8b 4d 18	 mov	 ecx, DWORD PTR _iRangeY$[ebp]
  000c7	83 c1 01	 add	 ecx, 1
  000ca	99		 cdq
  000cb	f7 f9		 idiv	 ecx
  000cd	0f af 55 b0	 imul	 edx, DWORD PTR tv88[ebp]
  000d1	03 55 f8	 add	 edx, DWORD PTR _iUY$[ebp]
  000d4	8b 45 10	 mov	 eax, DWORD PTR _cY$[ebp]
  000d7	88 10		 mov	 BYTE PTR [eax], dl

; 32598: 
; 32599: 		BYTE btMapAttr = MapC[iMapNumber].GetAttr(cX, cY);

  000d9	8b 45 10	 mov	 eax, DWORD PTR _cY$[ebp]
  000dc	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000df	51		 push	 ecx
  000e0	8b 55 0c	 mov	 edx, DWORD PTR _cX$[ebp]
  000e3	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000e6	50		 push	 eax
  000e7	69 4d 08 8c 04
	05 00		 imul	 ecx, DWORD PTR _iMapNumber$[ebp], 328844
  000ee	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000f4	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000f9	88 45 f7	 mov	 BYTE PTR _btMapAttr$1[ebp], al

; 32600: 	
; 32601: 		if( ((btMapAttr&MAP_ATTR_BLOCK) != MAP_ATTR_BLOCK) &&

  000fc	0f b6 45 f7	 movzx	 eax, BYTE PTR _btMapAttr$1[ebp]
  00100	83 e0 04	 and	 eax, 4
  00103	75 10		 jne	 SHORT $LN7@gObjGetRan
  00105	0f b6 45 f7	 movzx	 eax, BYTE PTR _btMapAttr$1[ebp]
  00109	83 e0 08	 and	 eax, 8
  0010c	75 07		 jne	 SHORT $LN7@gObjGetRan

; 32602: 			((btMapAttr&MAP_ATTR_HOLLOW) != MAP_ATTR_HOLLOW) ) 
; 32603: 		{		
; 32604: 			return TRUE;

  0010e	b8 01 00 00 00	 mov	 eax, 1
  00113	eb 07		 jmp	 SHORT $LN1@gObjGetRan
$LN7@gObjGetRan:

; 32605: 		}
; 32606: 	}

  00115	e9 28 ff ff ff	 jmp	 $LN2@gObjGetRan
$LN3@gObjGetRan:

; 32607: 
; 32608: 	return FALSE;

  0011a	33 c0		 xor	 eax, eax
$LN1@gObjGetRan:

; 32609: }

  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z ENDP	; gObjGetRandomItemDropLocation
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjCheckAttackTypeMagic@@YAHHH@Z
_TEXT	SEGMENT
_iClass$ = 8						; size = 4
_iSkill$ = 12						; size = 4
?gObjCheckAttackTypeMagic@@YAHHH@Z PROC			; gObjCheckAttackTypeMagic, COMDAT

; 32639: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 32640: #ifdef SKILL_ADD_PHYSICS_MAGIC_TYPE_20040812
; 32641: 	if (iSkill == 0)

  00009	83 7d 0c 00	 cmp	 DWORD PTR _iSkill$[ebp], 0
  0000d	75 06		 jne	 SHORT $LN2@gObjCheckA

; 32642: 		return CMagicDamage::SKILL_TYPE_PHYSICS;

  0000f	33 c0		 xor	 eax, eax
  00011	eb 15		 jmp	 SHORT $LN1@gObjCheckA
  00013	eb 10		 jmp	 SHORT $LN3@gObjCheckA
$LN2@gObjCheckA:

; 32643: 	else
; 32644: 		return MagicDamageC.GetSkillType(iSkill);

  00015	8b 45 0c	 mov	 eax, DWORD PTR _iSkill$[ebp]
  00018	50		 push	 eax
  00019	b9 00 00 00 00	 mov	 ecx, OFFSET ?MagicDamageC@@3VCMagicDamage@@A ; MagicDamageC
  0001e	e8 00 00 00 00	 call	 ?GetSkillType@CMagicDamage@@QAEHH@Z ; CMagicDamage::GetSkillType
  00023	eb 03		 jmp	 SHORT $LN1@gObjCheckA
$LN3@gObjCheckA:

; 32645: 
; 32646: 	return CMagicDamage::SKILL_TYPE_NONE;

  00025	83 c8 ff	 or	 eax, -1
$LN1@gObjCheckA:

; 32647: #else
; 32648: 	if (iClass == CLASS_KNIGHT || iClass == CLASS_ELF) {
; 32649: 		//     
; 32650: 		return FALSE;
; 32651: 	}
; 32652: 
; 32653: 	if (iClass == CLASS_WIZARD) {
; 32654: 		//       
; 32655: 		if (iSkill > 0) {
; 32656: 			return TRUE;
; 32657: 		} else {
; 32658: 			return FALSE;
; 32659: 		}
; 32660: 	}
; 32661: 
; 32662: 	if (iClass == CLASS_MAGUMSA) {
; 32663: 		//      .
; 32664: 		if (iSkill > 0) {
; 32665: 			switch(iSkill) {
; 32666: 			case AT_SKILL_DEFENSEDOWN :					// 
; 32667: 			case AT_SKILL_SWORD6 :						// 
; 32668: 				return FALSE;
; 32669: 				break;
; 32670: 			default:
; 32671: 				return TRUE;
; 32672: 				break;
; 32673: 			}
; 32674: 		} else {
; 32675: 			return FALSE;
; 32676: 		}
; 32677: 	}
; 32678: 
; 32679: 	if (iClass == CLASS_DARKLORD) {
; 32680: 		//      .
; 32681: 		if (iSkill > 0) {
; 32682: 			switch(iSkill) {
; 32683: 			case AT_SKILL_SPEAR :						// 
; 32684: 			case AT_SKILL_DARKHORSE_ATTACK :			// 
; 32685: 				return FALSE;
; 32686: 				break;
; 32687: 			default:
; 32688: 				return TRUE;
; 32689: 				break;
; 32690: 			}
; 32691: 		} else {
; 32692: 			return FALSE;
; 32693: 		}
; 32694: 	}
; 32695: 
; 32696: 	return FALSE;
; 32697: #endif
; 32698: }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?gObjCheckAttackTypeMagic@@YAHHH@Z ENDP			; gObjCheckAttackTypeMagic
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?gObjGetRandomFreeLocation@@YAHHAAE0HHH@Z
_TEXT	SEGMENT
tv88 = -80						; size = 4
tv78 = -80						; size = 4
tv71 = -80						; size = 4
_btMapAttr$1 = -9					; size = 1
_iUY$ = -8						; size = 4
_iUX$ = -4						; size = 4
_iMapNumber$ = 8					; size = 4
_cX$ = 12						; size = 4
_cY$ = 16						; size = 4
_iRangeX$ = 20						; size = 4
_iRangeY$ = 24						; size = 4
_iLoopCount$ = 28					; size = 4
?gObjGetRandomFreeLocation@@YAHHAAE0HHH@Z PROC		; gObjGetRandomFreeLocation, COMDAT

; 32616: {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 32617: 	INT iUX = cX;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _cX$[ebp]
  0000c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0000f	89 4d fc	 mov	 DWORD PTR _iUX$[ebp], ecx

; 32618: 	INT iUY = cY;

  00012	8b 45 10	 mov	 eax, DWORD PTR _cY$[ebp]
  00015	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00018	89 4d f8	 mov	 DWORD PTR _iUY$[ebp], ecx

; 32619: 
; 32620: 	if (iRangeX <= 0)		iRangeX	= 1;

  0001b	83 7d 14 00	 cmp	 DWORD PTR _iRangeX$[ebp], 0
  0001f	7f 07		 jg	 SHORT $LN4@gObjGetRan
  00021	c7 45 14 01 00
	00 00		 mov	 DWORD PTR _iRangeX$[ebp], 1
$LN4@gObjGetRan:

; 32621: 	if (iRangeY <= 0)		iRangeY	= 1;

  00028	83 7d 18 00	 cmp	 DWORD PTR _iRangeY$[ebp], 0
  0002c	7f 07		 jg	 SHORT $LN5@gObjGetRan
  0002e	c7 45 18 01 00
	00 00		 mov	 DWORD PTR _iRangeY$[ebp], 1
$LN5@gObjGetRan:

; 32622: 	if (iLoopCount <= 0)	iLoopCount	= 1;

  00035	83 7d 1c 00	 cmp	 DWORD PTR _iLoopCount$[ebp], 0
  00039	7f 07		 jg	 SHORT $LN2@gObjGetRan
  0003b	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR _iLoopCount$[ebp], 1
$LN2@gObjGetRan:

; 32623: 
; 32624: 	while (iLoopCount-- > 0) {

  00042	8b 45 1c	 mov	 eax, DWORD PTR _iLoopCount$[ebp]
  00045	89 45 b0	 mov	 DWORD PTR tv71[ebp], eax
  00048	8b 4d 1c	 mov	 ecx, DWORD PTR _iLoopCount$[ebp]
  0004b	83 e9 01	 sub	 ecx, 1
  0004e	89 4d 1c	 mov	 DWORD PTR _iLoopCount$[ebp], ecx
  00051	83 7d b0 00	 cmp	 DWORD PTR tv71[ebp], 0
  00055	0f 8e b5 00 00
	00		 jle	 $LN3@gObjGetRan

; 32625: 		cX = (rand() % (iRangeX + 1)) * ((rand() % 2) ? 1 : -1) + iUX;

  0005b	e8 00 00 00 00	 call	 _rand
  00060	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00065	79 05		 jns	 SHORT $LN13@gObjGetRan
  00067	48		 dec	 eax
  00068	83 c8 fe	 or	 eax, -2			; fffffffeH
  0006b	40		 inc	 eax
$LN13@gObjGetRan:
  0006c	85 c0		 test	 eax, eax
  0006e	74 09		 je	 SHORT $LN9@gObjGetRan
  00070	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  00077	eb 07		 jmp	 SHORT $LN10@gObjGetRan
$LN9@gObjGetRan:
  00079	c7 45 b0 ff ff
	ff ff		 mov	 DWORD PTR tv78[ebp], -1
$LN10@gObjGetRan:
  00080	e8 00 00 00 00	 call	 _rand
  00085	8b 4d 14	 mov	 ecx, DWORD PTR _iRangeX$[ebp]
  00088	83 c1 01	 add	 ecx, 1
  0008b	99		 cdq
  0008c	f7 f9		 idiv	 ecx
  0008e	0f af 55 b0	 imul	 edx, DWORD PTR tv78[ebp]
  00092	03 55 fc	 add	 edx, DWORD PTR _iUX$[ebp]
  00095	8b 45 0c	 mov	 eax, DWORD PTR _cX$[ebp]
  00098	88 10		 mov	 BYTE PTR [eax], dl

; 32626: 		cY = (rand() % (iRangeY + 1)) * ((rand() % 2) ? 1 : -1) + iUY;

  0009a	e8 00 00 00 00	 call	 _rand
  0009f	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000a4	79 05		 jns	 SHORT $LN14@gObjGetRan
  000a6	48		 dec	 eax
  000a7	83 c8 fe	 or	 eax, -2			; fffffffeH
  000aa	40		 inc	 eax
$LN14@gObjGetRan:
  000ab	85 c0		 test	 eax, eax
  000ad	74 09		 je	 SHORT $LN11@gObjGetRan
  000af	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
  000b6	eb 07		 jmp	 SHORT $LN12@gObjGetRan
$LN11@gObjGetRan:
  000b8	c7 45 b0 ff ff
	ff ff		 mov	 DWORD PTR tv88[ebp], -1
$LN12@gObjGetRan:
  000bf	e8 00 00 00 00	 call	 _rand
  000c4	8b 4d 18	 mov	 ecx, DWORD PTR _iRangeY$[ebp]
  000c7	83 c1 01	 add	 ecx, 1
  000ca	99		 cdq
  000cb	f7 f9		 idiv	 ecx
  000cd	0f af 55 b0	 imul	 edx, DWORD PTR tv88[ebp]
  000d1	03 55 f8	 add	 edx, DWORD PTR _iUY$[ebp]
  000d4	8b 45 10	 mov	 eax, DWORD PTR _cY$[ebp]
  000d7	88 10		 mov	 BYTE PTR [eax], dl

; 32627: 
; 32628: 		BYTE btMapAttr = MapC[iMapNumber].GetAttr(cX, cY);

  000d9	8b 45 10	 mov	 eax, DWORD PTR _cY$[ebp]
  000dc	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000df	51		 push	 ecx
  000e0	8b 55 0c	 mov	 edx, DWORD PTR _cX$[ebp]
  000e3	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000e6	50		 push	 eax
  000e7	69 4d 08 8c 04
	05 00		 imul	 ecx, DWORD PTR _iMapNumber$[ebp], 328844
  000ee	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000f4	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000f9	88 45 f7	 mov	 BYTE PTR _btMapAttr$1[ebp], al

; 32629: 		if( btMapAttr == MAP_ATTR_NONE )	//   

  000fc	0f b6 45 f7	 movzx	 eax, BYTE PTR _btMapAttr$1[ebp]
  00100	85 c0		 test	 eax, eax
  00102	75 07		 jne	 SHORT $LN7@gObjGetRan

; 32630: 			return TRUE;

  00104	b8 01 00 00 00	 mov	 eax, 1
  00109	eb 07		 jmp	 SHORT $LN1@gObjGetRan
$LN7@gObjGetRan:

; 32631: 	}

  0010b	e9 32 ff ff ff	 jmp	 $LN2@gObjGetRan
$LN3@gObjGetRan:

; 32632: 
; 32633: 	return FALSE;

  00110	33 c0		 xor	 eax, eax
$LN1@gObjGetRan:

; 32634: }

  00112	5f		 pop	 edi
  00113	5e		 pop	 esi
  00114	5b		 pop	 ebx
  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c3		 ret	 0
?gObjGetRandomFreeLocation@@YAHHAAE0HHH@Z ENDP		; gObjGetRandomFreeLocation
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_ECMagicInf@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_ECMagicInf@@UAEPAXI@Z PROC				; CMagicInf::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_ECMagicInf@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002e	83 e0 02	 and	 eax, 2
  00031	74 43		 je	 SHORT $LN2@vector
  00033	68 00 00 00 00	 push	 OFFSET ??1CMagicInf@@UAE@XZ ; CMagicInf::~CMagicInf
  00038	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0003e	51		 push	 ecx
  0003f	6a 10		 push	 16			; 00000010H
  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	52		 push	 edx
  00045	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0004a	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0004d	83 e0 01	 and	 eax, 1
  00050	74 1c		 je	 SHORT $LN3@vector
  00052	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00058	c1 e1 04	 shl	 ecx, 4
  0005b	83 c1 04	 add	 ecx, 4
  0005e	51		 push	 ecx
  0005f	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00062	83 ea 04	 sub	 edx, 4
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0006b	83 c4 08	 add	 esp, 8
$LN3@vector:
  0006e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00071	83 e8 04	 sub	 eax, 4
  00074	eb 21		 jmp	 SHORT $LN5@vector
$LN2@vector:
  00076	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	e8 00 00 00 00	 call	 ??1CMagicInf@@UAE@XZ	; CMagicInf::~CMagicInf
  0007e	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00081	83 e0 01	 and	 eax, 1
  00084	74 0e		 je	 SHORT $LN4@vector
  00086	6a 10		 push	 16			; 00000010H
  00088	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00091	83 c4 08	 add	 esp, 8
$LN4@vector:
  00094	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@vector:
  00097	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a1	59		 pop	 ecx
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 04 00	 ret	 4
  000ab	cc		 int	 3
  000ac	cc		 int	 3
  000ad	cc		 int	 3
  000ae	cc		 int	 3
  000af	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_ECMagicInf@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_ECMagicInf@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_ECMagicInf@@UAEPAXI@Z ENDP				; CMagicInf::`vector deleting destructor'
; Function compile flags: /Odtp /ZI
;	COMDAT ??4CMagicInf@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4CMagicInf@@QAEAAV0@ABV0@@Z PROC			; CMagicInf::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00012	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  00015	88 50 04	 mov	 BYTE PTR [eax+4], dl
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0001e	8a 51 05	 mov	 dl, BYTE PTR [ecx+5]
  00021	88 50 05	 mov	 BYTE PTR [eax+5], dl
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0002a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00036	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00039	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??4CMagicInf@@QAEAAV0@ABV0@@Z ENDP			; CMagicInf::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 1072 :     void _Adopt(const void*) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\cmath
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__Xx$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 242  : _NODISCARD _Check_return_ inline float sqrt(_In_ float _Xx) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 243  :     return _CSTD sqrtf(_Xx);

  00009	51		 push	 ecx
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR __Xx$[ebp]
  0000f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00014	e8 00 00 00 00	 call	 _sqrtf
  00019	83 c4 04	 add	 esp, 4

; 244  : }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\afxstr.h
;	COMDAT ?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT
?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ PROC ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager, COMDAT

; 51   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 52   : 		return( AfxGetStringManager() );

  00009	e8 00 00 00 00	 call	 ?AfxGetStringManager@@YGPAUIAtlStringMgr@ATL@@XZ ; AfxGetStringManager

; 53   : 	}

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ ENDP ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\afxstr.h
;	COMDAT ?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_nID$ = 8						; size = 4
?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z PROC ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance, COMDAT

; 46   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 47   : 		return( AfxFindStringResourceHandle( nID ) );

  00009	8b 45 08	 mov	 eax, DWORD PTR _nID$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?AfxFindStringResourceHandle@@YGPAUHINSTANCE__@@I@Z ; AfxFindStringResourceHandle

; 48   : 	}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z ENDP ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\cstringt.h
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z
_TEXT	SEGMENT
_pszDest$ = 8						; size = 4
_nDestLength$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nSrcLength$ = 20					; size = 4
?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z PROC ; ATL::ChTraitsCRT<char>::ConvertToBaseType, COMDAT

; 362  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 363  : 		// nLen is in XCHARs
; 364  : 		::WideCharToMultiByte( _AtlGetConversionACP(), 0, pszSrc, nSrcLength, pszDest, nDestLength, NULL, NULL );

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	8b 45 0c	 mov	 eax, DWORD PTR _nDestLength$[ebp]
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _pszDest$[ebp]
  00014	51		 push	 ecx
  00015	8b 55 14	 mov	 edx, DWORD PTR _nSrcLength$[ebp]
  00018	52		 push	 edx
  00019	8b 45 10	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  0001c	50		 push	 eax
  0001d	6a 00		 push	 0
  0001f	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 365  : 	}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z ENDP ; ATL::ChTraitsCRT<char>::ConvertToBaseType
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\cstringt.h
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z
_TEXT	SEGMENT
_pszSource$ = 8						; size = 4
_nLength$ = 12						; size = 4
?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z PROC	; ATL::ChTraitsCRT<char>::GetBaseTypeLength, COMDAT

; 340  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 341  : 		// Returns required buffer length in XCHARs
; 342  : 		return ::WideCharToMultiByte( _AtlGetConversionACP(), 0, pszSource, nLength, NULL, 0, NULL, NULL );

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	6a 00		 push	 0
  00011	8b 45 0c	 mov	 eax, DWORD PTR _nLength$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _pszSource$[ebp]
  00018	51		 push	 ecx
  00019	6a 00		 push	 0
  0001b	e8 00 00 00 00	 call	 ?_AtlGetConversionACP@ATL@@YGIXZ ; ATL::_AtlGetConversionACP
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 343  : 	}

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z ENDP	; ATL::ChTraitsCRT<char>::GetBaseTypeLength
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atltime.h
;	COMDAT ?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z
_TEXT	SEGMENT
$T1 = -244						; size = 4
$T2 = -240						; size = 4
_ptmTemp$ = -172					; size = 36
_szBuffer$ = -136					; size = 128
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_pFormat$ = 12						; size = 4
?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z PROC ; ATL::CTime::Format, COMDAT
; _this$ = ecx

; 1057 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00019	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0

; 1058 : 	if(pFormat == NULL)

  00023	83 7d 0c 00	 cmp	 DWORD PTR _pFormat$[ebp], 0
  00027	75 23		 jne	 SHORT $LN2@Format

; 1059 : 	{
; 1060 : 		return pFormat;

  00029	8b 45 0c	 mov	 eax, DWORD PTR _pFormat$[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00030	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
  00035	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  0003b	83 c9 01	 or	 ecx, 1
  0003e	89 8d 0c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00044	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00047	e9 94 00 00 00	 jmp	 $LN5@Format
$LN2@Format:

; 1061 : 	}
; 1062 : 
; 1063 : 	TCHAR szBuffer[maxTimeBufferSize];
; 1064 : 	struct tm ptmTemp;
; 1065 : 
; 1066 : 	if (_localtime64_s(&ptmTemp, &m_time) != 0)

  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	50		 push	 eax
  00050	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _ptmTemp$[ebp]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 __localtime64_s
  0005c	83 c4 08	 add	 esp, 8
  0005f	85 c0		 test	 eax, eax
  00061	74 0a		 je	 SHORT $LN3@Format

; 1067 : 	{
; 1068 : 		AtlThrow(E_INVALIDARG);

  00063	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00068	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN3@Format:

; 1069 : 	}
; 1070 : 
; 1071 : 	if (!_tcsftime(szBuffer, maxTimeBufferSize, pFormat, &ptmTemp))

  0006d	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _ptmTemp$[ebp]
  00073	50		 push	 eax
  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _pFormat$[ebp]
  00077	51		 push	 ecx
  00078	68 80 00 00 00	 push	 128			; 00000080H
  0007d	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR _szBuffer$[ebp]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 _strftime
  00089	83 c4 10	 add	 esp, 16			; 00000010H
  0008c	85 c0		 test	 eax, eax
  0008e	75 2f		 jne	 SHORT $LN4@Format

; 1072 : 	{
; 1073 : 		szBuffer[0] = '\0';

  00090	b8 01 00 00 00	 mov	 eax, 1
  00095	6b c8 00	 imul	 ecx, eax, 0
  00098	89 8d 10 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  0009e	81 bd 10 ff ff
	ff 80 00 00 00	 cmp	 DWORD PTR $T2[ebp], 128	; 00000080H
  000a8	73 02		 jae	 SHORT $LN6@Format
  000aa	eb 05		 jmp	 SHORT $LN7@Format
$LN6@Format:
  000ac	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN7@Format:
  000b1	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR $T2[ebp]
  000b7	c6 84 15 78 ff
	ff ff 00	 mov	 BYTE PTR _szBuffer$[ebp+edx], 0
$LN4@Format:

; 1074 : 	}
; 1075 : 
; 1076 : 	return szBuffer;

  000bf	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  000c5	50		 push	 eax
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000c9	e8 00 00 00 00	 call	 ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
  000ce	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  000d4	83 c9 01	 or	 ecx, 1
  000d7	89 8d 0c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  000dd	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@Format:

; 1077 : }

  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx
  000e3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e6	33 cd		 xor	 ecx, ebp
  000e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c2 08 00	 ret	 8
?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z ENDP ; ATL::CTime::Format
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atltime.h
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_time$ = 8						; size = 8
??0CTime@ATL@@QAE@_J@Z PROC				; ATL::CTime::CTime, COMDAT
; _this$ = ecx

; 418  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 417  : 	m_time( time )

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _time$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx
  00014	8b 55 0c	 mov	 edx, DWORD PTR _time$[ebp+4]
  00017	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 419  : }

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
??0CTime@ATL@@QAE@_J@Z ENDP				; ATL::CTime::CTime
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\cstringt.h
;	COMDAT ?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z
_TEXT	SEGMENT
_nID$1 = -12						; size = 4
_bRet$ = -5						; size = 1
_this$ = -4						; size = 4
_pv$ = 8						; size = 4
?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z PROC ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad, COMDAT
; _this$ = ecx

; 2665 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2666 : 		bool bRet = false;

  0000c	c6 45 fb 00	 mov	 BYTE PTR _bRet$[ebp], 0

; 2667 : 
; 2668 : 		if( (pv != NULL) && IS_INTRESOURCE( pv ) )

  00010	83 7d 08 00	 cmp	 DWORD PTR _pv$[ebp], 0
  00014	74 28		 je	 SHORT $LN2@CheckImpli
  00016	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00019	c1 e8 10	 shr	 eax, 16			; 00000010H
  0001c	85 c0		 test	 eax, eax
  0001e	75 1e		 jne	 SHORT $LN2@CheckImpli

; 2669 : 		{
; 2670 : 			UINT nID = LOWORD( reinterpret_cast< DWORD_PTR >( pv ) );

  00020	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  00023	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00028	0f b7 c8	 movzx	 ecx, ax
  0002b	89 4d f4	 mov	 DWORD PTR _nID$1[ebp], ecx

; 2671 : 			(nID);
; 2672 : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 2673 : 			if( !LoadString( nID ) )

  0002e	8b 45 f4	 mov	 eax, DWORD PTR _nID$1[ebp]
  00031	50		 push	 eax
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA

; 2674 : 			{
; 2675 : 				ATLTRACE( atlTraceString, 2, _T( "Warning: implicit LoadString(%u) failed\n" ), nID );
; 2676 : 			}
; 2677 : 			bRet = true;

  0003a	c6 45 fb 01	 mov	 BYTE PTR _bRet$[ebp], 1
$LN2@CheckImpli:

; 2678 : #else
; 2679 : 			ATLTRACE( atlTraceString, 2, _T( "Warning: LoadString(%u) not supported under the current WINAPI_FAMILY.\n" ), nID );
; 2680 : #endif
; 2681 : 		}
; 2682 : 
; 2683 : 		return( bRet );

  0003e	8a 45 fb	 mov	 al, BYTE PTR _bRet$[ebp]

; 2684 : 	}

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\cstringt.h
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_pszBuffer$ = -16					; size = 4
_nLength$ = -12						; size = 4
_pImage$ = -8						; size = 4
_this$ = -4						; size = 4
_hInstance$ = 8						; size = 4
_nID$ = 12						; size = 4
?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z PROC ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA, COMDAT
; _this$ = ecx

; 2344 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2345 : 		const ATLSTRINGRESOURCEIMAGE* pImage = AtlGetStringResourceImage( hInstance, nID );

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _nID$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _hInstance$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z ; ATL::AtlGetStringResourceImage
  00019	83 c4 08	 add	 esp, 8
  0001c	89 45 f8	 mov	 DWORD PTR _pImage$[ebp], eax

; 2346 : 		if( pImage == NULL )

  0001f	83 7d f8 00	 cmp	 DWORD PTR _pImage$[ebp], 0
  00023	75 04		 jne	 SHORT $LN2@LoadString

; 2347 : 		{
; 2348 : 			return( FALSE );

  00025	33 c0		 xor	 eax, eax
  00027	eb 57		 jmp	 SHORT $LN1@LoadString
$LN2@LoadString:

; 2349 : 		}
; 2350 : 
; 2351 : 		int nLength = StringTraits::GetBaseTypeLength( pImage->achString, pImage->nLength );

  00029	8b 45 f8	 mov	 eax, DWORD PTR _pImage$[ebp]
  0002c	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0002f	51		 push	 ecx
  00030	8b 55 f8	 mov	 edx, DWORD PTR _pImage$[ebp]
  00033	83 c2 02	 add	 edx, 2
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z ; ATL::ChTraitsCRT<char>::GetBaseTypeLength
  0003c	83 c4 08	 add	 esp, 8
  0003f	89 45 f4	 mov	 DWORD PTR _nLength$[ebp], eax

; 2352 : 		PXSTR pszBuffer = this->GetBuffer( nLength );

  00042	8b 45 f4	 mov	 eax, DWORD PTR _nLength$[ebp]
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
  0004e	89 45 f0	 mov	 DWORD PTR _pszBuffer$[ebp], eax

; 2353 : 		StringTraits::ConvertToBaseType( pszBuffer, nLength, pImage->achString, pImage->nLength );

  00051	8b 45 f8	 mov	 eax, DWORD PTR _pImage$[ebp]
  00054	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00057	51		 push	 ecx
  00058	8b 55 f8	 mov	 edx, DWORD PTR _pImage$[ebp]
  0005b	83 c2 02	 add	 edx, 2
  0005e	52		 push	 edx
  0005f	8b 45 f4	 mov	 eax, DWORD PTR _nLength$[ebp]
  00062	50		 push	 eax
  00063	8b 4d f0	 mov	 ecx, DWORD PTR _pszBuffer$[ebp]
  00066	51		 push	 ecx
  00067	e8 00 00 00 00	 call	 ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z ; ATL::ChTraitsCRT<char>::ConvertToBaseType
  0006c	83 c4 10	 add	 esp, 16			; 00000010H

; 2354 : 		this->ReleaseBufferSetLength( nLength );

  0006f	8b 45 f4	 mov	 eax, DWORD PTR _nLength$[ebp]
  00072	50		 push	 eax
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength

; 2355 : 
; 2356 : 		return( TRUE );

  0007b	b8 01 00 00 00	 mov	 eax, 1
$LN1@LoadString:

; 2357 : 	}

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 08 00	 ret	 8
?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\cstringt.h
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z
_TEXT	SEGMENT
_hInst$ = -8						; size = 4
_this$ = -4						; size = 4
_nID$ = 8						; size = 4
?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z PROC ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA, COMDAT
; _this$ = ecx

; 2330 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2331 : 		HINSTANCE hInst = StringTraits::FindStringResourceInstance( nID );

  0000c	8b 45 08	 mov	 eax, DWORD PTR _nID$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?FindStringResourceInstance@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::FindStringResourceInstance
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 f8	 mov	 DWORD PTR _hInst$[ebp], eax

; 2332 : 		if( hInst == NULL )

  0001b	83 7d f8 00	 cmp	 DWORD PTR _hInst$[ebp], 0
  0001f	75 04		 jne	 SHORT $LN2@LoadString

; 2333 : 		{
; 2334 : 			return( FALSE );

  00021	33 c0		 xor	 eax, eax
  00023	eb 10		 jmp	 SHORT $LN1@LoadString
$LN2@LoadString:

; 2335 : 		}
; 2336 : 
; 2337 : 		return( LoadString( hInst, nID ) );

  00025	8b 45 08	 mov	 eax, DWORD PTR _nID$[ebp]
  00028	50		 push	 eax
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _hInst$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
$LN1@LoadString:

; 2338 : 	}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
?LoadStringA@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::LoadStringA
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\cstringt.h
;	COMDAT ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszSrc$ = 8						; size = 4
??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z PROC ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=, COMDAT
; _this$ = ecx

; 1314 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1315 : 		CThisSimpleString::operator=( pszSrc );

  0000c	8b 45 08	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z ; ATL::CSimpleStringT<char,0>::operator=

; 1316 : 
; 1317 : 		return( *this );

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1318 : 	}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\cstringt.h
;	COMDAT ??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ PROC ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 1294 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1295 : 	}

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\cstringt.h
;	COMDAT ??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pszSrc$ = 8						; size = 4
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z PROC ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 1045 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1044 : 		CThisSimpleString( StringTraits::GetDefaultManager() )

  0002b	e8 00 00 00 00	 call	 ?GetDefaultManager@?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ ; StrTraitMFC<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
  00030	50		 push	 eax
  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1046 : 		if( !CheckImplicitLoad( pszSrc ) )

  00040	8b 45 08	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00043	50		 push	 eax
  00044	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CheckImplicitLoad
  0004c	0f b6 c8	 movzx	 ecx, al
  0004f	85 c9		 test	 ecx, ecx
  00051	75 0c		 jne	 SHORT $LN1@CStringT

; 1047 : 		{
; 1048 : 			*this = pszSrc;

  00053	8b 45 08	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00056	50		 push	 eax
  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ??4?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::operator=
$LN1@CStringT:

; 1049 : 		}
; 1050 : 	}

  0005f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00066	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00073	59		 pop	 ecx
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$CStringT@DV?$StrTraitMFC@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z ENDP ; ATL::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >::CStringT<char,StrTraitMFC<char,ATL::ChTraitsCRT<char> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nLength$ = 8						; size = 4
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC	; ATL::CSimpleStringT<char,0>::SetLength, COMDAT
; _this$ = ecx

; 867  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 868  : 		ATLASSERT( nLength >= 0 );
; 869  : 		ATLASSERT( nLength <= GetData()->nAllocLength );
; 870  : 
; 871  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

  0000c	83 7d 08 00	 cmp	 DWORD PTR _nLength$[ebp], 0
  00010	7c 10		 jl	 SHORT $LN3@SetLength
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _nLength$[ebp]
  0001d	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00020	7e 0a		 jle	 SHORT $LN2@SetLength
$LN3@SetLength:

; 872  : 			AtlThrow(E_INVALIDARG);

  00022	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00027	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN2@SetLength:

; 873  : 
; 874  : 		GetData()->nDataLength = nLength;

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _nLength$[ebp]
  00037	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 875  : 		m_pszData[nLength] = 0;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	8b 55 08	 mov	 edx, DWORD PTR _nLength$[ebp]
  00042	c6 04 11 00	 mov	 BYTE PTR [ecx+edx], 0
$LN4@SetLength:

; 876  : 	}

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetLength
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_pNewData$ = -16					; size = 4
_pStringMgr$ = -12					; size = 4
_pOldData$ = -8						; size = 4
_this$ = -4						; size = 4
_nLength$ = 8						; size = 4
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC	; ATL::CSimpleStringT<char,0>::Reallocate, COMDAT
; _this$ = ecx

; 849  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 850  : 		CStringData* pOldData = GetData();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00014	89 45 f8	 mov	 DWORD PTR _pOldData$[ebp], eax

; 851  : 		ATLASSERT( pOldData->nAllocLength < nLength );
; 852  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;

  00017	8b 45 f8	 mov	 eax, DWORD PTR _pOldData$[ebp]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	89 4d f4	 mov	 DWORD PTR _pStringMgr$[ebp], ecx

; 853  : 		if ( pOldData->nAllocLength >= nLength || nLength <= 0)

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _pOldData$[ebp]
  00022	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00025	3b 4d 08	 cmp	 ecx, DWORD PTR _nLength$[ebp]
  00028	7d 06		 jge	 SHORT $LN3@Reallocate
  0002a	83 7d 08 00	 cmp	 DWORD PTR _nLength$[ebp], 0
  0002e	7f 07		 jg	 SHORT $LN2@Reallocate
$LN3@Reallocate:

; 854  : 		{
; 855  : 			ThrowMemoryException();

  00030	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException

; 856  : 			return;

  00035	eb 31		 jmp	 SHORT $LN5@Reallocate
$LN2@Reallocate:

; 857  : 		}
; 858  : 		CStringData* pNewData = pStringMgr->Reallocate( pOldData, nLength, sizeof( XCHAR ) );

  00037	6a 01		 push	 1
  00039	8b 45 08	 mov	 eax, DWORD PTR _nLength$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _pOldData$[ebp]
  00040	51		 push	 ecx
  00041	8b 55 f4	 mov	 edx, DWORD PTR _pStringMgr$[ebp]
  00044	8b 02		 mov	 eax, DWORD PTR [edx]
  00046	8b 4d f4	 mov	 ecx, DWORD PTR _pStringMgr$[ebp]
  00049	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0004c	ff d2		 call	 edx
  0004e	89 45 f0	 mov	 DWORD PTR _pNewData$[ebp], eax

; 859  : 		if( pNewData == NULL )

  00051	83 7d f0 00	 cmp	 DWORD PTR _pNewData$[ebp], 0
  00055	75 05		 jne	 SHORT $LN4@Reallocate

; 860  : 		{
; 861  : 			ThrowMemoryException();

  00057	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$LN4@Reallocate:

; 862  : 		}
; 863  : 		Attach( pNewData );

  0005c	8b 45 f0	 mov	 eax, DWORD PTR _pNewData$[ebp]
  0005f	50		 push	 eax
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
$LN5@Reallocate:

; 864  : 	}

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::Reallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nNewLength$1 = -12					; size = 4
_pOldData$ = -8						; size = 4
_this$ = -4						; size = 4
_nLength$ = 8						; size = 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC	; ATL::CSimpleStringT<char,0>::PrepareWrite2, COMDAT
; _this$ = ecx

; 818  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 819  : 		CStringData* pOldData = GetData();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00014	89 45 f8	 mov	 DWORD PTR _pOldData$[ebp], eax

; 820  : 		if( pOldData->nDataLength > nLength )

  00017	8b 45 f8	 mov	 eax, DWORD PTR _pOldData$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	3b 4d 08	 cmp	 ecx, DWORD PTR _nLength$[ebp]
  00020	7e 09		 jle	 SHORT $LN2@PrepareWri

; 821  : 		{
; 822  : 			nLength = pOldData->nDataLength;

  00022	8b 45 f8	 mov	 eax, DWORD PTR _pOldData$[ebp]
  00025	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00028	89 4d 08	 mov	 DWORD PTR _nLength$[ebp], ecx
$LN2@PrepareWri:

; 823  : 		}
; 824  : 		if( pOldData->IsShared() )

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _pOldData$[ebp]
  0002e	e8 00 00 00 00	 call	 ?IsShared@CStringData@ATL@@QBE_NXZ ; ATL::CStringData::IsShared
  00033	0f b6 c0	 movzx	 eax, al
  00036	85 c0		 test	 eax, eax
  00038	74 0e		 je	 SHORT $LN3@PrepareWri

; 825  : 		{
; 826  : 			Fork( nLength );

  0003a	8b 45 08	 mov	 eax, DWORD PTR _nLength$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Fork

; 827  : 		}

  00046	eb 52		 jmp	 SHORT $LN1@PrepareWri
$LN3@PrepareWri:

; 828  : 		else if( pOldData->nAllocLength < nLength )

  00048	8b 45 f8	 mov	 eax, DWORD PTR _pOldData$[ebp]
  0004b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004e	3b 4d 08	 cmp	 ecx, DWORD PTR _nLength$[ebp]
  00051	7d 47		 jge	 SHORT $LN1@PrepareWri

; 829  : 		{
; 830  : 			// Grow exponentially, until we hit 1G, then by 1M thereafter.
; 831  : 			int nNewLength = pOldData->nAllocLength;

  00053	8b 45 f8	 mov	 eax, DWORD PTR _pOldData$[ebp]
  00056	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00059	89 4d f4	 mov	 DWORD PTR _nNewLength$1[ebp], ecx

; 832  : 			if( nNewLength > 1024 * 1024 * 1024 )

  0005c	81 7d f4 00 00
	00 40		 cmp	 DWORD PTR _nNewLength$1[ebp], 1073741824 ; 40000000H
  00063	7e 0d		 jle	 SHORT $LN6@PrepareWri

; 833  : 			{
; 834  : 				nNewLength += 1024 * 1024;

  00065	8b 45 f4	 mov	 eax, DWORD PTR _nNewLength$1[ebp]
  00068	05 00 00 10 00	 add	 eax, 1048576		; 00100000H
  0006d	89 45 f4	 mov	 DWORD PTR _nNewLength$1[ebp], eax

; 835  : 			}

  00070	eb 0e		 jmp	 SHORT $LN7@PrepareWri
$LN6@PrepareWri:

; 836  : 			else
; 837  : 			{
; 838  : 				// Exponential growth factor is 1.5.
; 839  : 				nNewLength = nNewLength + nNewLength / 2;

  00072	8b 45 f4	 mov	 eax, DWORD PTR _nNewLength$1[ebp]
  00075	99		 cdq
  00076	2b c2		 sub	 eax, edx
  00078	d1 f8		 sar	 eax, 1
  0007a	03 45 f4	 add	 eax, DWORD PTR _nNewLength$1[ebp]
  0007d	89 45 f4	 mov	 DWORD PTR _nNewLength$1[ebp], eax
$LN7@PrepareWri:

; 840  : 			}
; 841  : 			if( nNewLength < nLength )

  00080	8b 45 f4	 mov	 eax, DWORD PTR _nNewLength$1[ebp]
  00083	3b 45 08	 cmp	 eax, DWORD PTR _nLength$[ebp]
  00086	7d 06		 jge	 SHORT $LN8@PrepareWri

; 842  : 			{
; 843  : 				nNewLength = nLength;

  00088	8b 45 08	 mov	 eax, DWORD PTR _nLength$[ebp]
  0008b	89 45 f4	 mov	 DWORD PTR _nNewLength$1[ebp], eax
$LN8@PrepareWri:

; 844  : 			}
; 845  : 			Reallocate( nNewLength );

  0008e	8b 45 f4	 mov	 eax, DWORD PTR _nNewLength$1[ebp]
  00091	50		 push	 eax
  00092	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Reallocate
$LN1@PrepareWri:

; 846  : 		}
; 847  : 	}

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 04 00	 ret	 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::PrepareWrite2
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT
_nTooShort$ = -16					; size = 4
_nShared$ = -12						; size = 4
_pOldData$ = -8						; size = 4
_this$ = -4						; size = 4
_nLength$ = 8						; size = 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z PROC ; ATL::CSimpleStringT<char,0>::PrepareWrite, COMDAT
; _this$ = ecx

; 803  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 804  : 		if (nLength < 0)

  0000c	83 7d 08 00	 cmp	 DWORD PTR _nLength$[ebp], 0
  00010	7d 0a		 jge	 SHORT $LN2@PrepareWri

; 805  : 			AtlThrow(E_INVALIDARG);

  00012	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00017	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN2@PrepareWri:

; 806  : 
; 807  : 		CStringData* pOldData = GetData();

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00024	89 45 f8	 mov	 DWORD PTR _pOldData$[ebp], eax

; 808  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

  00027	8b 45 f8	 mov	 eax, DWORD PTR _pOldData$[ebp]
  0002a	b9 01 00 00 00	 mov	 ecx, 1
  0002f	2b 48 0c	 sub	 ecx, DWORD PTR [eax+12]
  00032	89 4d f4	 mov	 DWORD PTR _nShared$[ebp], ecx

; 809  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

  00035	8b 45 f8	 mov	 eax, DWORD PTR _pOldData$[ebp]
  00038	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003b	2b 4d 08	 sub	 ecx, DWORD PTR _nLength$[ebp]
  0003e	89 4d f0	 mov	 DWORD PTR _nTooShort$[ebp], ecx

; 810  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

  00041	8b 45 f4	 mov	 eax, DWORD PTR _nShared$[ebp]
  00044	0b 45 f0	 or	 eax, DWORD PTR _nTooShort$[ebp]
  00047	7d 0c		 jge	 SHORT $LN3@PrepareWri

; 811  : 		{
; 812  : 			PrepareWrite2( nLength );

  00049	8b 45 08	 mov	 eax, DWORD PTR _nLength$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$LN3@PrepareWri:

; 813  : 		}
; 814  : 
; 815  : 		return( m_pszData );

  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@PrepareWri:

; 816  : 	}

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ENDP ; ATL::CSimpleStringT<char,0>::PrepareWrite
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ PROC ; ATL::CSimpleStringT<char,0>::GetData, COMDAT
; _this$ = ecx

; 799  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 800  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	83 e8 10	 sub	 eax, 16			; 00000010H

; 801  : 	}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ENDP ; ATL::CSimpleStringT<char,0>::GetData
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
tv84 = -88						; size = 4
tv76 = -88						; size = 4
_nCharsToCopy$ = -20					; size = 4
_pNewData$ = -16					; size = 4
_nOldLength$ = -12					; size = 4
_pOldData$ = -8						; size = 4
_this$ = -4						; size = 4
_nLength$ = 8						; size = 4
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC		; ATL::CSimpleStringT<char,0>::Fork, COMDAT
; _this$ = ecx

; 783  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 784  : 		CStringData* pOldData = GetData();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00014	89 45 f8	 mov	 DWORD PTR _pOldData$[ebp], eax

; 785  : 		int nOldLength = pOldData->nDataLength;

  00017	8b 45 f8	 mov	 eax, DWORD PTR _pOldData$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	89 4d f4	 mov	 DWORD PTR _nOldLength$[ebp], ecx

; 786  : 		CStringData* pNewData = pOldData->pStringMgr->Clone()->Allocate( nLength, sizeof( XCHAR ) );

  00020	8b 45 f8	 mov	 eax, DWORD PTR _pOldData$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	8b 55 f8	 mov	 edx, DWORD PTR _pOldData$[ebp]
  00028	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002a	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0002c	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0002f	ff d2		 call	 edx
  00031	89 45 a8	 mov	 DWORD PTR tv76[ebp], eax
  00034	6a 01		 push	 1
  00036	8b 45 08	 mov	 eax, DWORD PTR _nLength$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d a8	 mov	 ecx, DWORD PTR tv76[ebp]
  0003d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003f	8b 4d a8	 mov	 ecx, DWORD PTR tv76[ebp]
  00042	8b 02		 mov	 eax, DWORD PTR [edx]
  00044	ff d0		 call	 eax
  00046	89 45 f0	 mov	 DWORD PTR _pNewData$[ebp], eax

; 787  : 		if( pNewData == NULL )

  00049	83 7d f0 00	 cmp	 DWORD PTR _pNewData$[ebp], 0
  0004d	75 05		 jne	 SHORT $LN2@Fork

; 788  : 		{
; 789  : 			ThrowMemoryException();

  0004f	e8 00 00 00 00	 call	 ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$LN2@Fork:

; 790  : 		}
; 791  : 		int nCharsToCopy = ((nOldLength < nLength) ? nOldLength : nLength)+1;  // Copy '\0'

  00054	8b 45 f4	 mov	 eax, DWORD PTR _nOldLength$[ebp]
  00057	3b 45 08	 cmp	 eax, DWORD PTR _nLength$[ebp]
  0005a	7d 08		 jge	 SHORT $LN4@Fork
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR _nOldLength$[ebp]
  0005f	89 4d a8	 mov	 DWORD PTR tv84[ebp], ecx
  00062	eb 06		 jmp	 SHORT $LN5@Fork
$LN4@Fork:
  00064	8b 55 08	 mov	 edx, DWORD PTR _nLength$[ebp]
  00067	89 55 a8	 mov	 DWORD PTR tv84[ebp], edx
$LN5@Fork:
  0006a	8b 45 a8	 mov	 eax, DWORD PTR tv84[ebp]
  0006d	83 c0 01	 add	 eax, 1
  00070	89 45 ec	 mov	 DWORD PTR _nCharsToCopy$[ebp], eax

; 792  : 		CopyChars( PXSTR( pNewData->data() ), nCharsToCopy,

  00073	8b 45 ec	 mov	 eax, DWORD PTR _nCharsToCopy$[ebp]
  00076	50		 push	 eax
  00077	8b 4d f8	 mov	 ecx, DWORD PTR _pOldData$[ebp]
  0007a	e8 00 00 00 00	 call	 ?data@CStringData@ATL@@QAEPAXXZ ; ATL::CStringData::data
  0007f	50		 push	 eax
  00080	8b 4d ec	 mov	 ecx, DWORD PTR _nCharsToCopy$[ebp]
  00083	51		 push	 ecx
  00084	8b 4d f0	 mov	 ecx, DWORD PTR _pNewData$[ebp]
  00087	e8 00 00 00 00	 call	 ?data@CStringData@ATL@@QAEPAXXZ ; ATL::CStringData::data
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADIPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
  00092	83 c4 10	 add	 esp, 16			; 00000010H

; 793  : 			PCXSTR( pOldData->data() ), nCharsToCopy );
; 794  : 		pNewData->nDataLength = nOldLength;

  00095	8b 45 f0	 mov	 eax, DWORD PTR _pNewData$[ebp]
  00098	8b 4d f4	 mov	 ecx, DWORD PTR _nOldLength$[ebp]
  0009b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 795  : 		pOldData->Release();

  0009e	8b 4d f8	 mov	 ecx, DWORD PTR _pOldData$[ebp]
  000a1	e8 00 00 00 00	 call	 ?Release@CStringData@ATL@@QAEXXZ ; ATL::CStringData::Release

; 796  : 		Attach( pNewData );

  000a6	8b 45 f0	 mov	 eax, DWORD PTR _pNewData$[ebp]
  000a9	50		 push	 eax
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	e8 00 00 00 00	 call	 ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
$LN3@Fork:

; 797  : 	}

  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 04 00	 ret	 4
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP		; ATL::CSimpleStringT<char,0>::Fork
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pData$ = 8						; size = 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z PROC ; ATL::CSimpleStringT<char,0>::Attach, COMDAT
; _this$ = ecx

; 779  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 780  : 		m_pszData = static_cast< PXSTR >( pData->data() );

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pData$[ebp]
  0000f	e8 00 00 00 00	 call	 ?data@CStringData@ATL@@QAEPAXXZ ; ATL::CStringData::data
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	89 01		 mov	 DWORD PTR [ecx], eax

; 781  : 	}

  00019	5f		 pop	 edi
  0001a	5e		 pop	 esi
  0001b	5b		 pop	 ebx
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ENDP ; ATL::CSimpleStringT<char,0>::Attach
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ PROC ; ATL::CSimpleStringT<char,0>::ThrowMemoryException, COMDAT

; 772  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 773  : 		AtlThrow( E_OUTOFMEMORY );

  00009	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0000e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN2@ThrowMemor:

; 774  : 	}

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ENDP ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z PROC	; ATL::CSimpleStringT<char,0>::StringLength, COMDAT

; 721  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 722  : 		if( psz == NULL )

  00009	83 7d 08 00	 cmp	 DWORD PTR _psz$[ebp], 0
  0000d	75 04		 jne	 SHORT $LN2@StringLeng

; 723  : 		{
; 724  : 			return( 0 );

  0000f	33 c0		 xor	 eax, eax
  00011	eb 0c		 jmp	 SHORT $LN1@StringLeng
$LN2@StringLeng:

; 725  : 		}
; 726  : 		return( int( strlen( psz ) ) );

  00013	8b 45 08	 mov	 eax, DWORD PTR _psz$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 _strlen
  0001c	83 c4 04	 add	 esp, 4
$LN1@StringLeng:

; 727  : 	}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ENDP	; ATL::CSimpleStringT<char,0>::StringLength
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADIPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_nDestLen$ = 12						; size = 4
_pchSrc$ = 16						; size = 4
_nChars$ = 20						; size = 4
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADIPBDH@Z PROC ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped, COMDAT

; 716  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 717  : 		memmove_s( pchDest, nDestLen*sizeof( XCHAR ),

  00009	8b 45 14	 mov	 eax, DWORD PTR _nChars$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _pchSrc$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR _nDestLen$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _pchDest$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _memmove_s
  0001e	83 c4 10	 add	 esp, 16			; 00000010H

; 718  : 			pchSrc, nChars*sizeof( XCHAR ) );
; 719  : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADIPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADIPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_nDestLen$ = 12						; size = 4
_pchSrc$ = 16						; size = 4
_nChars$ = 20						; size = 4
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADIPBDH@Z PROC ; ATL::CSimpleStringT<char,0>::CopyChars, COMDAT

; 695  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 696  : 		memcpy_s( pchDest, nDestLen*sizeof( XCHAR ),

  00009	8b 45 14	 mov	 eax, DWORD PTR _nChars$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR _pchSrc$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR _nDestLen$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR _pchDest$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _memcpy_s
  0001e	83 c4 10	 add	 esp, 16			; 00000010H

; 697  : 			pchSrc, nChars*sizeof( XCHAR ) );
; 698  : 	}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADIPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyChars
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT
_pszBuffer$1 = -16					; size = 4
_nOffset$2 = -12					; size = 4
_nOldLength$3 = -8					; size = 4
_this$ = -4						; size = 4
_pszSrc$ = 8						; size = 4
_nLength$ = 12						; size = 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z PROC	; ATL::CSimpleStringT<char,0>::SetString, COMDAT
; _this$ = ecx

; 607  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 608  : 		if( nLength == 0 )

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _nLength$[ebp], 0
  00010	75 0d		 jne	 SHORT $LN2@SetString

; 609  : 		{
; 610  : 			Empty();

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ; ATL::CSimpleStringT<char,0>::Empty

; 611  : 		}

  0001a	e9 8d 00 00 00	 jmp	 $LN7@SetString
$LN2@SetString:

; 612  : 		else
; 613  : 		{
; 614  : 			// It is possible that pszSrc points to a location inside of our
; 615  : 			// buffer.  GetBuffer() might change m_pszData if (1) the buffer
; 616  : 			// is shared or (2) the buffer is too small to hold the new
; 617  : 			// string.  We detect this aliasing, and modify pszSrc to point
; 618  : 			// into the newly allocated buffer instead.
; 619  : 
; 620  : 			if(pszSrc == NULL)

  0001f	83 7d 08 00	 cmp	 DWORD PTR _pszSrc$[ebp], 0
  00023	75 0a		 jne	 SHORT $LN4@SetString

; 621  : 				AtlThrow(E_INVALIDARG);

  00025	68 57 00 07 80	 push	 -2147024809		; 80070057H
  0002a	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN4@SetString:

; 622  : 
; 623  : 			UINT nOldLength = GetLength();

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetLength
  00037	89 45 f8	 mov	 DWORD PTR _nOldLength$3[ebp], eax

; 624  : 			UINT_PTR nOffset = pszSrc-GetString();

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ; ATL::CSimpleStringT<char,0>::GetString
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _pszSrc$[ebp]
  00045	2b c8		 sub	 ecx, eax
  00047	89 4d f4	 mov	 DWORD PTR _nOffset$2[ebp], ecx

; 625  : 			// If 0 <= nOffset <= nOldLength, then pszSrc points into our
; 626  : 			// buffer
; 627  : 
; 628  : 			PXSTR pszBuffer = GetBuffer( nLength );

  0004a	8b 45 0c	 mov	 eax, DWORD PTR _nLength$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
  00056	89 45 f0	 mov	 DWORD PTR _pszBuffer$1[ebp], eax

; 629  : 			if( nOffset <= nOldLength )

  00059	8b 45 f4	 mov	 eax, DWORD PTR _nOffset$2[ebp]
  0005c	3b 45 f8	 cmp	 eax, DWORD PTR _nOldLength$3[ebp]
  0005f	77 22		 ja	 SHORT $LN5@SetString

; 630  : 			{
; 631  : 				CopyCharsOverlapped( pszBuffer, GetAllocLength(),

  00061	8b 45 0c	 mov	 eax, DWORD PTR _nLength$[ebp]
  00064	50		 push	 eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR _pszBuffer$1[ebp]
  00068	03 4d f4	 add	 ecx, DWORD PTR _nOffset$2[ebp]
  0006b	51		 push	 ecx
  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?GetAllocLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetAllocLength
  00074	50		 push	 eax
  00075	8b 55 f0	 mov	 edx, DWORD PTR _pszBuffer$1[ebp]
  00078	52		 push	 edx
  00079	e8 00 00 00 00	 call	 ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADIPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyCharsOverlapped
  0007e	83 c4 10	 add	 esp, 16			; 00000010H

; 632  : 					pszBuffer+nOffset, nLength );
; 633  : 			}

  00081	eb 1d		 jmp	 SHORT $LN6@SetString
$LN5@SetString:

; 634  : 			else
; 635  : 			{
; 636  : 				CopyChars( pszBuffer, GetAllocLength(), pszSrc, nLength );

  00083	8b 45 0c	 mov	 eax, DWORD PTR _nLength$[ebp]
  00086	50		 push	 eax
  00087	8b 4d 08	 mov	 ecx, DWORD PTR _pszSrc$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	e8 00 00 00 00	 call	 ?GetAllocLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ; ATL::CSimpleStringT<char,0>::GetAllocLength
  00093	50		 push	 eax
  00094	8b 55 f0	 mov	 edx, DWORD PTR _pszBuffer$1[ebp]
  00097	52		 push	 edx
  00098	e8 00 00 00 00	 call	 ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADIPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
  0009d	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@SetString:

; 637  : 			}
; 638  : 			ReleaseBufferSetLength( nLength );

  000a0	8b 45 0c	 mov	 eax, DWORD PTR _nLength$[ebp]
  000a3	50		 push	 eax
  000a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	e8 00 00 00 00	 call	 ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
$LN7@SetString:

; 639  : 		}
; 640  : 	}

  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 08 00	 ret	 8
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetString
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszSrc$ = 8						; size = 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z PROC	; ATL::CSimpleStringT<char,0>::SetString, COMDAT
; _this$ = ecx

; 601  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 602  : 		SetString( pszSrc, StringLength( pszSrc ) );

  0000c	8b 45 08	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z ; ATL::CSimpleStringT<char,0>::StringLength
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _pszSrc$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z ; ATL::CSimpleStringT<char,0>::SetString

; 603  : 	}

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z ENDP	; ATL::CSimpleStringT<char,0>::SetString
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nNewLength$ = 8					; size = 4
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z PROC ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength, COMDAT
; _this$ = ecx

; 566  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 567  : 		ATLASSERT( nNewLength >= 0 );
; 568  : 		SetLength( nNewLength );

  0000c	8b 45 08	 mov	 eax, DWORD PTR _nNewLength$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::SetLength

; 569  : 	}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ENDP ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ PROC	; ATL::CSimpleStringT<char,0>::GetString, COMDAT
; _this$ = ecx

; 528  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 529  : 		return( m_pszData );

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 530  : 	}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ENDP	; ATL::CSimpleStringT<char,0>::GetString
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ PROC	; ATL::CSimpleStringT<char,0>::GetLength, COMDAT
; _this$ = ecx

; 518  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 519  : 		return( GetData()->nDataLength );

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 520  : 	}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ENDP	; ATL::CSimpleStringT<char,0>::GetLength
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nMinBufferLength$ = 8					; size = 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z PROC	; ATL::CSimpleStringT<char,0>::GetBuffer, COMDAT
; _this$ = ecx

; 507  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 508  : 		return( PrepareWrite( nMinBufferLength ) );

  0000c	8b 45 08	 mov	 eax, DWORD PTR _nMinBufferLength$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite

; 509  : 	}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ENDP	; ATL::CSimpleStringT<char,0>::GetBuffer
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetAllocLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAllocLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ PROC	; ATL::CSimpleStringT<char,0>::GetAllocLength, COMDAT
; _this$ = ecx

; 485  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 486  : 		return( GetData()->nAllocLength );

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00014	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 487  : 	}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?GetAllocLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ ENDP	; ATL::CSimpleStringT<char,0>::GetAllocLength
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT
_pNewData$1 = -16					; size = 4
_pStringMgr$ = -12					; size = 4
_pOldData$ = -8						; size = 4
_this$ = -4						; size = 4
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ PROC		; ATL::CSimpleStringT<char,0>::Empty, COMDAT
; _this$ = ecx

; 436  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 437  : 		CStringData* pOldData = GetData();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00014	89 45 f8	 mov	 DWORD PTR _pOldData$[ebp], eax

; 438  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;

  00017	8b 45 f8	 mov	 eax, DWORD PTR _pOldData$[ebp]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	89 4d f4	 mov	 DWORD PTR _pStringMgr$[ebp], ecx

; 439  : 		if( pOldData->nDataLength == 0 )

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _pOldData$[ebp]
  00022	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00026	75 02		 jne	 SHORT $LN2@Empty

; 440  : 		{
; 441  : 			return;

  00028	eb 3f		 jmp	 SHORT $LN1@Empty
$LN2@Empty:

; 442  : 		}
; 443  : 
; 444  : 		if( pOldData->IsLocked() )

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _pOldData$[ebp]
  0002d	e8 00 00 00 00	 call	 ?IsLocked@CStringData@ATL@@QBE_NXZ ; ATL::CStringData::IsLocked
  00032	0f b6 c0	 movzx	 eax, al
  00035	85 c0		 test	 eax, eax
  00037	74 0c		 je	 SHORT $LN3@Empty

; 445  : 		{
; 446  : 			// Don't reallocate a locked buffer that's shrinking
; 447  : 			SetLength( 0 );

  00039	6a 00		 push	 0
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::SetLength

; 448  : 		}

  00043	eb 24		 jmp	 SHORT $LN1@Empty
$LN3@Empty:

; 449  : 		else
; 450  : 		{
; 451  : 			pOldData->Release();

  00045	8b 4d f8	 mov	 ecx, DWORD PTR _pOldData$[ebp]
  00048	e8 00 00 00 00	 call	 ?Release@CStringData@ATL@@QAEXXZ ; ATL::CStringData::Release

; 452  : 			CStringData* pNewData = pStringMgr->GetNilString();

  0004d	8b 45 f4	 mov	 eax, DWORD PTR _pStringMgr$[ebp]
  00050	8b 10		 mov	 edx, DWORD PTR [eax]
  00052	8b 4d f4	 mov	 ecx, DWORD PTR _pStringMgr$[ebp]
  00055	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00058	ff d0		 call	 eax
  0005a	89 45 f0	 mov	 DWORD PTR _pNewData$1[ebp], eax

; 453  : 			Attach( pNewData );

  0005d	8b 45 f0	 mov	 eax, DWORD PTR _pNewData$1[ebp]
  00060	50		 push	 eax
  00061	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
$LN1@Empty:

; 454  : 		}
; 455  : 	}

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ ENDP		; ATL::CSimpleStringT<char,0>::Empty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszSrc$ = 8						; size = 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z PROC	; ATL::CSimpleStringT<char,0>::operator=, COMDAT
; _this$ = ecx

; 313  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 314  : 		SetString( pszSrc );

  0000c	8b 45 08	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z ; ATL::CSimpleStringT<char,0>::SetString

; 315  : 
; 316  : 		return( *this );

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 317  : 	}

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z ENDP	; ATL::CSimpleStringT<char,0>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT
_pData$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ PROC		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 260  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 261  : 		CStringData* pData = GetData();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
  00014	89 45 f8	 mov	 DWORD PTR _pData$[ebp], eax

; 262  : 		pData->Release();

  00017	8b 4d f8	 mov	 ecx, DWORD PTR _pData$[ebp]
  0001a	e8 00 00 00 00	 call	 ?Release@CStringData@ATL@@QAEXXZ ; ATL::CStringData::Release

; 263  : 	}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ENDP		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT
tv65 = -80						; size = 4
_pData$ = -12						; size = 4
___atl_condVal$1 = -8					; size = 4
_this$ = -4						; size = 4
_pStringMgr$ = 8					; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z PROC ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 203  : 	explicit CSimpleStringT(_Inout_ IAtlStringMgr* pStringMgr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@CSimpleStr:

; 204  : 	{
; 205  : 		ATLENSURE( pStringMgr != NULL );

  0000c	83 7d 08 00	 cmp	 DWORD PTR _pStringMgr$[ebp], 0
  00010	74 09		 je	 SHORT $LN10@CSimpleStr
  00012	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  00019	eb 07		 jmp	 SHORT $LN11@CSimpleStr
$LN10@CSimpleStr:
  0001b	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
$LN11@CSimpleStr:
  00022	8b 45 b0	 mov	 eax, DWORD PTR tv65[ebp]
  00025	89 45 f8	 mov	 DWORD PTR ___atl_condVal$1[ebp], eax
$LN5@CSimpleStr:
  00028	33 c0		 xor	 eax, eax
  0002a	75 fc		 jne	 SHORT $LN5@CSimpleStr
  0002c	83 7d f8 00	 cmp	 DWORD PTR ___atl_condVal$1[ebp], 0
  00030	75 0a		 jne	 SHORT $LN2@CSimpleStr
  00032	68 05 40 00 80	 push	 -2147467259		; 80004005H
  00037	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN2@CSimpleStr:
  0003c	33 c0		 xor	 eax, eax
  0003e	75 cc		 jne	 SHORT $LN4@CSimpleStr

; 206  : 		CStringData* pData = pStringMgr->GetNilString();

  00040	8b 45 08	 mov	 eax, DWORD PTR _pStringMgr$[ebp]
  00043	8b 10		 mov	 edx, DWORD PTR [eax]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _pStringMgr$[ebp]
  00048	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0004b	ff d0		 call	 eax
  0004d	89 45 f4	 mov	 DWORD PTR _pData$[ebp], eax

; 207  : 		Attach( pData );

  00050	8b 45 f4	 mov	 eax, DWORD PTR _pData$[ebp]
  00053	50		 push	 eax
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach

; 208  : 	}

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN9@CSimpleStr:
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ENDP ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Release@CStringData@ATL@@QAEXXZ PROC			; ATL::CStringData::Release, COMDAT
; _this$ = ecx

; 85   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 86   : 		ATLASSERT( nRefs != 0 );
; 87   : 
; 88   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00012	83 c9 ff	 or	 ecx, -1
  00015	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00019	49		 dec	 ecx
  0001a	85 c9		 test	 ecx, ecx
  0001c	7f 15		 jg	 SHORT $LN1@Release

; 89   : 		{
; 90   : 			pStringMgr->Free( this );

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	8b 11		 mov	 edx, DWORD PTR [ecx]
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 12		 mov	 edx, DWORD PTR [edx]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00031	ff d0		 call	 eax
$LN1@Release:

; 91   : 		}
; 92   : 	}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?Release@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::Release
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -72						; size = 4
_this$ = -4						; size = 4
?IsShared@CStringData@ATL@@QBE_NXZ PROC			; ATL::CStringData::IsShared, COMDAT
; _this$ = ecx

; 72   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 73   : 		return( nRefs > 1 );

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 0c 01	 cmp	 DWORD PTR [eax+12], 1
  00013	7e 09		 jle	 SHORT $LN3@IsShared
  00015	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  0001c	eb 07		 jmp	 SHORT $LN4@IsShared
$LN3@IsShared:
  0001e	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@IsShared:
  00025	8a 45 b8	 mov	 al, BYTE PTR tv66[ebp]

; 74   : 	}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?IsShared@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsShared
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -72						; size = 4
_this$ = -4						; size = 4
?IsLocked@CStringData@ATL@@QBE_NXZ PROC			; ATL::CStringData::IsLocked, COMDAT
; _this$ = ecx

; 68   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 69   : 		return nRefs < 0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00013	7d 09		 jge	 SHORT $LN3@IsLocked
  00015	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  0001c	eb 07		 jmp	 SHORT $LN4@IsLocked
$LN3@IsLocked:
  0001e	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@IsLocked:
  00025	8a 45 b8	 mov	 al, BYTE PTR tv66[ebp]

; 70   : 	}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?IsLocked@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsLocked
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlsimpstr.h
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?data@CStringData@ATL@@QAEPAXXZ PROC			; ATL::CStringData::data, COMDAT
; _this$ = ecx

; 58   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 		return (this+1);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 c0 10	 add	 eax, 16			; 00000010H

; 60   : 	}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?data@CStringData@ATL@@QAEPAXXZ ENDP			; ATL::CStringData::data
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlcore.h
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_hResource$ = -4					; size = 4
_hInstance$ = 8						; size = 4
_id$ = 12						; size = 4
?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z PROC ; ATL::AtlGetStringResourceImage, COMDAT

; 370  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 371  : 	HRSRC hResource;
; 372  : 	/*
; 373  : 		The and operation (& static_cast<WORD>(~0)) protects the expression from being greater
; 374  : 		than WORD - this would cause a runtime error when the application is compiled with /RTCc flag.
; 375  : 	*/
; 376  : 	hResource = ::FindResourceW(hInstance, MAKEINTRESOURCEW( (((id>>4)+1) & static_cast<WORD>(~0)) ), (LPWSTR) RT_STRING);

  00009	6a 06		 push	 6
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _id$[ebp]
  0000e	c1 e8 04	 shr	 eax, 4
  00011	83 c0 01	 add	 eax, 1
  00014	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00019	0f b7 c8	 movzx	 ecx, ax
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR _hInstance$[ebp]
  00020	52		 push	 edx
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceW@12
  00027	89 45 fc	 mov	 DWORD PTR _hResource$[ebp], eax

; 377  : 	if( hResource == NULL )

  0002a	83 7d fc 00	 cmp	 DWORD PTR _hResource$[ebp], 0
  0002e	75 04		 jne	 SHORT $LN2@AtlGetStri

; 378  : 	{
; 379  : 		return( NULL );

  00030	33 c0		 xor	 eax, eax
  00032	eb 14		 jmp	 SHORT $LN1@AtlGetStri
$LN2@AtlGetStri:

; 380  : 	}
; 381  : 
; 382  : 	return _AtlGetStringResourceImage( hInstance, hResource, id );

  00034	8b 45 0c	 mov	 eax, DWORD PTR _id$[ebp]
  00037	50		 push	 eax
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _hResource$[ebp]
  0003b	51		 push	 ecx
  0003c	8b 55 08	 mov	 edx, DWORD PTR _hInstance$[ebp]
  0003f	52		 push	 edx
  00040	e8 00 00 00 00	 call	 ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ; ATL::_AtlGetStringResourceImage
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@AtlGetStri:

; 383  : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z ENDP ; ATL::AtlGetStringResourceImage
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlcore.h
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT
_iIndex$ = -20						; size = 4
_hGlobal$ = -16						; size = 4
_nResourceSize$ = -12					; size = 4
_pImageEnd$ = -8					; size = 4
_pImage$ = -4						; size = 4
_hInstance$ = 8						; size = 4
_hResource$ = 12					; size = 4
_id$ = 16						; size = 4
?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z PROC ; ATL::_AtlGetStringResourceImage, COMDAT

; 327  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 328  : 	const ATLSTRINGRESOURCEIMAGE* pImage;
; 329  : 	const ATLSTRINGRESOURCEIMAGE* pImageEnd;
; 330  : 	ULONG nResourceSize;
; 331  : 	HGLOBAL hGlobal;
; 332  : 	UINT iIndex;
; 333  : 
; 334  : 	hGlobal = ::LoadResource( hInstance, hResource );

  00009	8b 45 0c	 mov	 eax, DWORD PTR _hResource$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _hInstance$[ebp]
  00010	51		 push	 ecx
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadResource@8
  00017	89 45 f0	 mov	 DWORD PTR _hGlobal$[ebp], eax

; 335  : 	if( hGlobal == NULL )

  0001a	83 7d f0 00	 cmp	 DWORD PTR _hGlobal$[ebp], 0
  0001e	75 07		 jne	 SHORT $LN4@AtlGetStri

; 336  : 	{
; 337  : 		return( NULL );

  00020	33 c0		 xor	 eax, eax
  00022	e9 80 00 00 00	 jmp	 $LN1@AtlGetStri
$LN4@AtlGetStri:

; 338  : 	}
; 339  : 
; 340  : 	pImage = (const ATLSTRINGRESOURCEIMAGE*)::LockResource( hGlobal );

  00027	8b 45 f0	 mov	 eax, DWORD PTR _hGlobal$[ebp]
  0002a	50		 push	 eax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LockResource@4
  00031	89 45 fc	 mov	 DWORD PTR _pImage$[ebp], eax

; 341  : 	if( pImage == NULL )

  00034	83 7d fc 00	 cmp	 DWORD PTR _pImage$[ebp], 0
  00038	75 04		 jne	 SHORT $LN5@AtlGetStri

; 342  : 	{
; 343  : 		return( NULL );

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 69		 jmp	 SHORT $LN1@AtlGetStri
$LN5@AtlGetStri:

; 344  : 	}
; 345  : 
; 346  : 	nResourceSize = ::SizeofResource( hInstance, hResource );

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _hResource$[ebp]
  00041	50		 push	 eax
  00042	8b 4d 08	 mov	 ecx, DWORD PTR _hInstance$[ebp]
  00045	51		 push	 ecx
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SizeofResource@8
  0004c	89 45 f4	 mov	 DWORD PTR _nResourceSize$[ebp], eax

; 347  : 	pImageEnd = (const ATLSTRINGRESOURCEIMAGE*)(LPBYTE( pImage )+nResourceSize);

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _pImage$[ebp]
  00052	03 45 f4	 add	 eax, DWORD PTR _nResourceSize$[ebp]
  00055	89 45 f8	 mov	 DWORD PTR _pImageEnd$[ebp], eax

; 348  : 	iIndex = id&0x000f;

  00058	8b 45 10	 mov	 eax, DWORD PTR _id$[ebp]
  0005b	83 e0 0f	 and	 eax, 15			; 0000000fH
  0005e	89 45 ec	 mov	 DWORD PTR _iIndex$[ebp], eax
$LN2@AtlGetStri:

; 349  : 
; 350  : 	while( (iIndex > 0) && (pImage < pImageEnd) )

  00061	83 7d ec 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  00065	76 23		 jbe	 SHORT $LN3@AtlGetStri
  00067	8b 45 fc	 mov	 eax, DWORD PTR _pImage$[ebp]
  0006a	3b 45 f8	 cmp	 eax, DWORD PTR _pImageEnd$[ebp]
  0006d	73 1b		 jae	 SHORT $LN3@AtlGetStri

; 351  : 	{
; 352  : 		pImage = (const ATLSTRINGRESOURCEIMAGE*)(LPBYTE( pImage )+(sizeof( ATLSTRINGRESOURCEIMAGE )+(pImage->nLength*sizeof( WCHAR ))));

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _pImage$[ebp]
  00072	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00075	8b 55 fc	 mov	 edx, DWORD PTR _pImage$[ebp]
  00078	8d 44 4a 02	 lea	 eax, DWORD PTR [edx+ecx*2+2]
  0007c	89 45 fc	 mov	 DWORD PTR _pImage$[ebp], eax

; 353  : 		iIndex--;

  0007f	8b 45 ec	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00082	83 e8 01	 sub	 eax, 1
  00085	89 45 ec	 mov	 DWORD PTR _iIndex$[ebp], eax

; 354  : 	}

  00088	eb d7		 jmp	 SHORT $LN2@AtlGetStri
$LN3@AtlGetStri:

; 355  : 	if( pImage >= pImageEnd )

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _pImage$[ebp]
  0008d	3b 45 f8	 cmp	 eax, DWORD PTR _pImageEnd$[ebp]
  00090	72 04		 jb	 SHORT $LN6@AtlGetStri

; 356  : 	{
; 357  : 		return( NULL );

  00092	33 c0		 xor	 eax, eax
  00094	eb 11		 jmp	 SHORT $LN1@AtlGetStri
$LN6@AtlGetStri:

; 358  : 	}
; 359  : 	if( pImage->nLength == 0 )

  00096	8b 45 fc	 mov	 eax, DWORD PTR _pImage$[ebp]
  00099	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0009c	85 c9		 test	 ecx, ecx
  0009e	75 04		 jne	 SHORT $LN7@AtlGetStri

; 360  : 	{
; 361  : 		return( NULL );

  000a0	33 c0		 xor	 eax, eax
  000a2	eb 03		 jmp	 SHORT $LN1@AtlGetStri
$LN7@AtlGetStri:

; 362  : 	}
; 363  : 
; 364  : 	return( pImage );

  000a4	8b 45 fc	 mov	 eax, DWORD PTR _pImage$[ebp]
$LN1@AtlGetStri:

; 365  : }

  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ENDP ; ATL::_AtlGetStringResourceImage
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv71 = -68						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 759  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 760  :             return (float)sqrt(_X);

  00009	f3 0f 5a 45 08	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0000e	83 ec 08	 sub	 esp, 8
  00011	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00016	e8 00 00 00 00	 call	 _sqrt
  0001b	83 c4 08	 add	 esp, 8
  0001e	d9 5d bc	 fstp	 DWORD PTR tv71[ebp]
  00021	d9 45 bc	 fld	 DWORD PTR tv71[ebp]

; 761  :         }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC			; ATL::_AtlGetConversionACP, COMDAT

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 99   : #ifdef _CONVERSION_DONT_USE_THREAD_LOCALE
; 100  : 	return CP_ACP;
; 101  : #else
; 102  : 	return CP_THREAD_ACP;

  00009	b8 03 00 00 00	 mov	 eax, 3

; 103  : #endif
; 104  : }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 66   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 67   : #ifdef _AFX
; 68   : 	if( hr == E_OUTOFMEMORY )

  00009	81 7d 08 0e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
  00010	75 07		 jne	 SHORT $LN2@AtlThrowIm

; 69   : 	{
; 70   : 		AfxThrowMemoryException();

  00012	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException

; 71   : 	}

  00017	eb 09		 jmp	 SHORT $LN4@AtlThrowIm
$LN2@AtlThrowIm:

; 72   : 	else
; 73   : 	{
; 74   : 		AfxThrowOleException( hr );

  00019	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$LN4@AtlThrowIm:

; 75   : 	}
; 76   : #else
; 77   : 	throw CAtlException( hr );
; 78   : #endif
; 79   : };

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 535  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 536  :             return _time64(_Time);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __time64
  00012	83 c4 04	 add	 esp, 4

; 537  :         }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vsprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vsprintf PROC						; COMDAT

; 1477 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1478 :         #pragma warning(push)
; 1479 :         #pragma warning(disable: 4996) // Deprecation
; 1480 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, NULL, _ArgList);

  00009	8b 45 10	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00012	51		 push	 ecx
  00013	6a ff		 push	 -1
  00015	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 __vsnprintf_l
  0001e	83 c4 14	 add	 esp, 20			; 00000014H

; 1481 :         #pragma warning(pop)
; 1482 :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
_vsprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1389 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1395 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_memcpy_s.h
;	COMDAT _memmove_s
_TEXT	SEGMENT
tv74 = -80						; size = 4
tv70 = -80						; size = 4
tv66 = -80						; size = 4
__Expr_val$1 = -12					; size = 4
__Expr_val$2 = -8					; size = 4
__Expr_val$3 = -4					; size = 4
__Destination$ = 8					; size = 4
__DestinationSize$ = 12					; size = 4
__Source$ = 16						; size = 4
__SourceSize$ = 20					; size = 4
_memmove_s PROC						; COMDAT

; 70   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 71   :         if (_SourceSize == 0)

  00009	83 7d 14 00	 cmp	 DWORD PTR __SourceSize$[ebp], 0
  0000d	75 07		 jne	 SHORT $LN2@memmove_s

; 72   :         {
; 73   :             return 0;

  0000f	33 c0		 xor	 eax, eax
  00011	e9 c6 00 00 00	 jmp	 $LN1@memmove_s
$LN2@memmove_s:

; 74   :         }
; 75   : 
; 76   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL,            EINVAL);

  00016	83 7d 08 00	 cmp	 DWORD PTR __Destination$[ebp], 0
  0001a	74 09		 je	 SHORT $LN7@memmove_s
  0001c	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00023	eb 07		 jmp	 SHORT $LN8@memmove_s
$LN7@memmove_s:
  00025	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN8@memmove_s:
  0002c	8b 45 b0	 mov	 eax, DWORD PTR tv66[ebp]
  0002f	89 45 fc	 mov	 DWORD PTR __Expr_val$3[ebp], eax
  00032	83 7d fc 00	 cmp	 DWORD PTR __Expr_val$3[ebp], 0
  00036	75 1a		 jne	 SHORT $LN3@memmove_s
  00038	e8 00 00 00 00	 call	 __errno
  0003d	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  00043	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00048	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  0004d	e9 8a 00 00 00	 jmp	 $LN1@memmove_s
$LN3@memmove_s:

; 77   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  00052	83 7d 10 00	 cmp	 DWORD PTR __Source$[ebp], 0
  00056	74 09		 je	 SHORT $LN9@memmove_s
  00058	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
  0005f	eb 07		 jmp	 SHORT $LN10@memmove_s
$LN9@memmove_s:
  00061	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN10@memmove_s:
  00068	8b 45 b0	 mov	 eax, DWORD PTR tv70[ebp]
  0006b	89 45 f8	 mov	 DWORD PTR __Expr_val$2[ebp], eax
  0006e	83 7d f8 00	 cmp	 DWORD PTR __Expr_val$2[ebp], 0
  00072	75 17		 jne	 SHORT $LN4@memmove_s
  00074	e8 00 00 00 00	 call	 __errno
  00079	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  0007f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00084	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00089	eb 51		 jmp	 SHORT $LN1@memmove_s
$LN4@memmove_s:

; 78   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

  0008b	8b 45 0c	 mov	 eax, DWORD PTR __DestinationSize$[ebp]
  0008e	3b 45 14	 cmp	 eax, DWORD PTR __SourceSize$[ebp]
  00091	72 09		 jb	 SHORT $LN11@memmove_s
  00093	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  0009a	eb 07		 jmp	 SHORT $LN12@memmove_s
$LN11@memmove_s:
  0009c	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN12@memmove_s:
  000a3	8b 4d b0	 mov	 ecx, DWORD PTR tv74[ebp]
  000a6	89 4d f4	 mov	 DWORD PTR __Expr_val$1[ebp], ecx
  000a9	83 7d f4 00	 cmp	 DWORD PTR __Expr_val$1[ebp], 0
  000ad	75 17		 jne	 SHORT $LN5@memmove_s
  000af	e8 00 00 00 00	 call	 __errno
  000b4	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  000ba	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  000bf	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  000c4	eb 16		 jmp	 SHORT $LN1@memmove_s
$LN5@memmove_s:

; 79   : 
; 80   : #pragma warning(suppress:4996) // Deprecation
; 81   :         memmove(_Destination, _Source, _SourceSize);

  000c6	8b 45 14	 mov	 eax, DWORD PTR __SourceSize$[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d 10	 mov	 ecx, DWORD PTR __Source$[ebp]
  000cd	51		 push	 ecx
  000ce	8b 55 08	 mov	 edx, DWORD PTR __Destination$[ebp]
  000d1	52		 push	 edx
  000d2	e8 00 00 00 00	 call	 _memmove
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 82   :         return 0;

  000da	33 c0		 xor	 eax, eax
$LN1@memmove_s:

; 83   :     }

  000dc	5f		 pop	 edi
  000dd	5e		 pop	 esi
  000de	5b		 pop	 ebx
  000df	8b e5		 mov	 esp, ebp
  000e1	5d		 pop	 ebp
  000e2	c3		 ret	 0
_memmove_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_memcpy_s.h
;	COMDAT _memcpy_s
_TEXT	SEGMENT
tv79 = -80						; size = 4
tv75 = -80						; size = 4
tv66 = -80						; size = 4
__Expr_val$1 = -12					; size = 4
__Expr_val$2 = -8					; size = 4
__Expr_val$3 = -4					; size = 4
__Destination$ = 8					; size = 4
__DestinationSize$ = 12					; size = 4
__Source$ = 16						; size = 4
__SourceSize$ = 20					; size = 4
_memcpy_s PROC						; COMDAT

; 41   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 42   :         if (_SourceSize == 0)

  00009	83 7d 14 00	 cmp	 DWORD PTR __SourceSize$[ebp], 0
  0000d	75 07		 jne	 SHORT $LN2@memcpy_s

; 43   :         {
; 44   :             return 0;

  0000f	33 c0		 xor	 eax, eax
  00011	e9 f1 00 00 00	 jmp	 $LN1@memcpy_s
$LN2@memcpy_s:

; 45   :         }
; 46   : 
; 47   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  00016	83 7d 08 00	 cmp	 DWORD PTR __Destination$[ebp], 0
  0001a	74 09		 je	 SHORT $LN9@memcpy_s
  0001c	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00023	eb 07		 jmp	 SHORT $LN10@memcpy_s
$LN9@memcpy_s:
  00025	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN10@memcpy_s:
  0002c	8b 45 b0	 mov	 eax, DWORD PTR tv66[ebp]
  0002f	89 45 fc	 mov	 DWORD PTR __Expr_val$3[ebp], eax
  00032	83 7d fc 00	 cmp	 DWORD PTR __Expr_val$3[ebp], 0
  00036	75 1a		 jne	 SHORT $LN3@memcpy_s
  00038	e8 00 00 00 00	 call	 __errno
  0003d	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  00043	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00048	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  0004d	e9 b5 00 00 00	 jmp	 $LN1@memcpy_s
$LN3@memcpy_s:

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  00052	83 7d 10 00	 cmp	 DWORD PTR __Source$[ebp], 0
  00056	74 0c		 je	 SHORT $LN5@memcpy_s
  00058	8b 45 0c	 mov	 eax, DWORD PTR __DestinationSize$[ebp]
  0005b	3b 45 14	 cmp	 eax, DWORD PTR __SourceSize$[ebp]
  0005e	0f 83 8d 00 00
	00		 jae	 $LN4@memcpy_s
$LN5@memcpy_s:

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

  00064	8b 45 0c	 mov	 eax, DWORD PTR __DestinationSize$[ebp]
  00067	50		 push	 eax
  00068	6a 00		 push	 0
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR __Destination$[ebp]
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 _memset
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  00076	83 7d 10 00	 cmp	 DWORD PTR __Source$[ebp], 0
  0007a	74 09		 je	 SHORT $LN11@memcpy_s
  0007c	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  00083	eb 07		 jmp	 SHORT $LN12@memcpy_s
$LN11@memcpy_s:
  00085	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN12@memcpy_s:
  0008c	8b 45 b0	 mov	 eax, DWORD PTR tv75[ebp]
  0008f	89 45 f8	 mov	 DWORD PTR __Expr_val$2[ebp], eax
  00092	83 7d f8 00	 cmp	 DWORD PTR __Expr_val$2[ebp], 0
  00096	75 17		 jne	 SHORT $LN6@memcpy_s
  00098	e8 00 00 00 00	 call	 __errno
  0009d	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  000a3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  000a8	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  000ad	eb 58		 jmp	 SHORT $LN1@memcpy_s
$LN6@memcpy_s:

; 53   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

  000af	8b 45 0c	 mov	 eax, DWORD PTR __DestinationSize$[ebp]
  000b2	3b 45 14	 cmp	 eax, DWORD PTR __SourceSize$[ebp]
  000b5	72 09		 jb	 SHORT $LN13@memcpy_s
  000b7	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  000be	eb 07		 jmp	 SHORT $LN14@memcpy_s
$LN13@memcpy_s:
  000c0	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv79[ebp], 0
$LN14@memcpy_s:
  000c7	8b 4d b0	 mov	 ecx, DWORD PTR tv79[ebp]
  000ca	89 4d f4	 mov	 DWORD PTR __Expr_val$1[ebp], ecx
  000cd	83 7d f4 00	 cmp	 DWORD PTR __Expr_val$1[ebp], 0
  000d1	75 17		 jne	 SHORT $LN7@memcpy_s
  000d3	e8 00 00 00 00	 call	 __errno
  000d8	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  000de	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  000e3	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  000e8	eb 1d		 jmp	 SHORT $LN1@memcpy_s
$LN7@memcpy_s:

; 54   : 
; 55   :             // Unreachable, but required to suppress /analyze warnings:
; 56   :             return EINVAL;

  000ea	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  000ef	eb 16		 jmp	 SHORT $LN1@memcpy_s
$LN4@memcpy_s:

; 57   :         }
; 58   : #pragma warning(suppress:4996) // Deprecation
; 59   :         memcpy(_Destination, _Source, _SourceSize);

  000f1	8b 45 14	 mov	 eax, DWORD PTR __SourceSize$[ebp]
  000f4	50		 push	 eax
  000f5	8b 4d 10	 mov	 ecx, DWORD PTR __Source$[ebp]
  000f8	51		 push	 ecx
  000f9	8b 55 08	 mov	 edx, DWORD PTR __Destination$[ebp]
  000fc	52		 push	 edx
  000fd	e8 00 00 00 00	 call	 _memcpy
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH

; 60   :         return 0;

  00105	33 c0		 xor	 eax, eax
$LN1@memcpy_s:

; 61   :     }

  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5b		 pop	 ebx
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
_memcpy_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\user.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -68						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	89 45 bc	 mov	 DWORD PTR tv66[ebp], eax
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR ___n$[ebp]
  00012	83 e9 01	 sub	 ecx, 1
  00015	89 4d 10	 mov	 DWORD PTR ___n$[ebp], ecx
  00018	83 7d bc 00	 cmp	 DWORD PTR tv66[ebp], 0
  0001c	76 11		 jbe	 SHORT $LN1@vector
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00021	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00024	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00027	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  0002a	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  0002d	eb da		 jmp	 SHORT $LN2@vector
$LN1@vector:
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
