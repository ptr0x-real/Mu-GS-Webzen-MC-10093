; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
PUBLIC	?GetMapName@CTerrainManager@@QAEPADH@Z		; CTerrainManager::GetMapName
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::end
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::find
PUBLIC	?_Getcomp@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Getcomp
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,_TERRAIN_INFO>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,1>,1>::_Get_first
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,std::_Iterator_base0>
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator*
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator==
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator*
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator->
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@SAPAU?$pair@$$CBHU_TERRAIN_INFO@@@2@AAU32@@Z ; std::pointer_traits<std::pair<int const ,_TERRAIN_INFO> *>::pointer_to
PUBLIC	??$_Find@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Find<int>
PUBLIC	??$addressof@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@YAPAU?$pair@$$CBHU_TERRAIN_INFO@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_TERRAIN_INFO> >
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Find_lower_bound<int>
PUBLIC	??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Lower_bound_duplicate<int>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@ABV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > const >
PUBLIC	??$_Kfn@$$CBHU_TERRAIN_INFO@@@?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_TERRAIN_INFO@@@1@@Z ; std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0>::_Kfn<int const ,_TERRAIN_INFO>
PUBLIC	??0CRingMonsterHerd@@QAE@XZ			; CRingMonsterHerd::CRingMonsterHerd
PUBLIC	??1CRingMonsterHerd@@UAE@XZ			; CRingMonsterHerd::~CRingMonsterHerd
PUBLIC	?Start@CRingMonsterHerd@@UAEHXZ			; CRingMonsterHerd::Start
PUBLIC	?MonsterHerdItemDrop@CRingMonsterHerd@@UAEHPAVOBJECTSTRUCT@@@Z ; CRingMonsterHerd::MonsterHerdItemDrop
PUBLIC	?MonsterAttackAction@CRingMonsterHerd@@UAEXPAVOBJECTSTRUCT@@0@Z ; CRingMonsterHerd::MonsterAttackAction
PUBLIC	?SendEventGiftWinner@CRingMonsterHerd@@QAEXHH@Z	; CRingMonsterHerd::SendEventGiftWinner
PUBLIC	?GetX@CRingMonsterHerd@@QAEEXZ			; CRingMonsterHerd::GetX
PUBLIC	?GetY@CRingMonsterHerd@@QAEEXZ			; CRingMonsterHerd::GetY
PUBLIC	??_GCRingMonsterHerd@@UAEPAXI@Z			; CRingMonsterHerd::`scalar deleting destructor'
PUBLIC	??0?$allocator@URINGMONSTER_DATA@@@std@@QAE@XZ	; std::allocator<RINGMONSTER_DATA>::allocator<RINGMONSTER_DATA>
PUBLIC	?deallocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEXQAURINGMONSTER_DATA@@I@Z ; std::allocator<RINGMONSTER_DATA>::deallocate
PUBLIC	?allocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEPAURINGMONSTER_DATA@@I@Z ; std::allocator<RINGMONSTER_DATA>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@SAIABV?$allocator@URINGMONSTER_DATA@@@2@@Z ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_DATA> >::max_size
PUBLIC	??0?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
PUBLIC	??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::~vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
PUBLIC	?push_back@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXABURINGMONSTER_DATA@@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::push_back
PUBLIC	?erase@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::erase
PUBLIC	?begin@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::begin
PUBLIC	?end@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::end
PUBLIC	?empty@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE_NXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::empty
PUBLIC	?max_size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::max_size
PUBLIC	?capacity@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::capacity
PUBLIC	?_Umove@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEPAURINGMONSTER_DATA@@PAU3@00@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove
PUBLIC	?_Umove_if_noexcept1@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@00U?$integral_constant@_N$00@2@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@00@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@ABEII@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXQAURINGMONSTER_DATA@@II@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Change_array
PUBLIC	?_Tidy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Tidy
PUBLIC	?_Xlength@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@CAXXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@ABEXPAURINGMONSTER_DATA@@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Orphan_range
PUBLIC	?_Getal@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_DATA@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Getal
PUBLIC	?_Getal@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@ABEABV?$allocator@URINGMONSTER_DATA@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_DATA@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@2@$00@std@@QAEAAV?$allocator@URINGMONSTER_DATA@@@2@XZ ; std::_Compressed_pair<std::allocator<RINGMONSTER_DATA>,std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_DATA@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@2@$00@std@@QBEABV?$allocator@URINGMONSTER_DATA@@@2@XZ ; std::_Compressed_pair<std::allocator<RINGMONSTER_DATA>,std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >,1>::_Get_first
PUBLIC	??0?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAE@XZ ; std::allocator<RINGMONSTER_EVENT_TIME>::allocator<RINGMONSTER_EVENT_TIME>
PUBLIC	?deallocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXQAURINGMONSTER_EVENT_TIME@@I@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::deallocate
PUBLIC	?allocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@I@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@SAIABV?$allocator@URINGMONSTER_EVENT_TIME@@@2@@Z ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_EVENT_TIME> >::max_size
PUBLIC	??0?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >
PUBLIC	??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::~vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >
PUBLIC	?push_back@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXABURINGMONSTER_EVENT_TIME@@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::push_back
PUBLIC	?erase@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::erase
PUBLIC	?begin@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::begin
PUBLIC	?end@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::end
PUBLIC	?empty@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE_NXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::empty
PUBLIC	?max_size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::max_size
PUBLIC	?capacity@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::capacity
PUBLIC	?_Umove@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEPAURINGMONSTER_EVENT_TIME@@PAU3@00@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove
PUBLIC	?_Umove_if_noexcept1@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@00U?$integral_constant@_N$00@2@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@00@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@ABEII@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXQAURINGMONSTER_EVENT_TIME@@II@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Change_array
PUBLIC	?_Tidy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Tidy
PUBLIC	?_Xlength@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@CAXXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@ABEXPAURINGMONSTER_EVENT_TIME@@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Orphan_range
PUBLIC	?_Getal@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Getal
PUBLIC	?_Getal@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@ABEABV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@2@$00@std@@QAEAAV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ; std::_Compressed_pair<std::allocator<RINGMONSTER_EVENT_TIME>,std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@2@$00@std@@QBEABV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ; std::_Compressed_pair<std::allocator<RINGMONSTER_EVENT_TIME>,std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >,1>::_Get_first
PUBLIC	??0CRingAttackEvent@@QAE@XZ			; CRingAttackEvent::CRingAttackEvent
PUBLIC	??1CRingAttackEvent@@UAE@XZ			; CRingAttackEvent::~CRingAttackEvent
PUBLIC	?StartEvent@CRingAttackEvent@@QAEXXZ		; CRingAttackEvent::StartEvent
PUBLIC	?StopEvent@CRingAttackEvent@@QAEXXZ		; CRingAttackEvent::StopEvent
PUBLIC	?EnableEvent@CRingAttackEvent@@QAEXH@Z		; CRingAttackEvent::EnableEvent
PUBLIC	?Load@CRingAttackEvent@@UAEHPAD@Z		; CRingAttackEvent::Load
PUBLIC	?Run@CRingAttackEvent@@QAEXXZ			; CRingAttackEvent::Run
PUBLIC	?CheckSync@CRingAttackEvent@@QAEXXZ		; CRingAttackEvent::CheckSync
PUBLIC	?SetState@CRingAttackEvent@@QAEXH@Z		; CRingAttackEvent::SetState
PUBLIC	?ProcState_None@CRingAttackEvent@@QAEXXZ	; CRingAttackEvent::ProcState_None
PUBLIC	?ProcState_Closed@CRingAttackEvent@@QAEXXZ	; CRingAttackEvent::ProcState_Closed
PUBLIC	?ProcState_Playing@CRingAttackEvent@@QAEXXZ	; CRingAttackEvent::ProcState_Playing
PUBLIC	?SetState_None@CRingAttackEvent@@QAEXXZ		; CRingAttackEvent::SetState_None
PUBLIC	?SetState_Closed@CRingAttackEvent@@QAEXXZ	; CRingAttackEvent::SetState_Closed
PUBLIC	?SetState_Playing@CRingAttackEvent@@QAEXXZ	; CRingAttackEvent::SetState_Playing
PUBLIC	?Move@CRingAttackEvent@@QAEXXZ			; CRingAttackEvent::Move
PUBLIC	?SetMenualStart@CRingAttackEvent@@QAEXH@Z	; CRingAttackEvent::SetMenualStart
PUBLIC	?Start_Menual@CRingAttackEvent@@QAEXXZ		; CRingAttackEvent::Start_Menual
PUBLIC	?End_Menual@CRingAttackEvent@@QAEXXZ		; CRingAttackEvent::End_Menual
PUBLIC	??_GCRingAttackEvent@@UAEPAXI@Z			; CRingAttackEvent::`scalar deleting destructor'
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEABURINGMONSTER_DATA@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::_Compat
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEAAURINGMONSTER_DATA@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator++
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEABURINGMONSTER_EVENT_TIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::_Compat
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAURINGMONSTER_EVENT_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator++
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >
PUBLIC	??$_Move_unchecked@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00@Z ; std::_Move_unchecked<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>
PUBLIC	??$emplace_back@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@ABURINGMONSTER_EVENT_TIME@@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::emplace_back<RINGMONSTER_EVENT_TIME const &>
PUBLIC	??$forward@ABURINGMONSTER_EVENT_TIME@@@std@@YAABURINGMONSTER_EVENT_TIME@@ABU1@@Z ; std::forward<RINGMONSTER_EVENT_TIME const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAE@ABURINGMONSTER_EVENT_TIME@@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Emplace_back_with_unused_capacity<RINGMONSTER_EVENT_TIME const &>
PUBLIC	??$_Unfancy@URINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@@Z ; std::_Unfancy<RINGMONSTER_EVENT_TIME>
PUBLIC	??$construct@URINGMONSTER_EVENT_TIME@@ABU1@@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@SAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@1@QAURINGMONSTER_EVENT_TIME@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_EVENT_TIME> >::construct<RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME const &>
PUBLIC	??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Emplace_reallocate<RINGMONSTER_EVENT_TIME const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<RINGMONSTER_EVENT_TIME>,std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >,1>::_Compressed_pair<std::allocator<RINGMONSTER_EVENT_TIME>,std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >
PUBLIC	??$_Move_unchecked@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00@Z ; std::_Move_unchecked<RINGMONSTER_DATA *,RINGMONSTER_DATA *>
PUBLIC	??$emplace_back@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@ABURINGMONSTER_DATA@@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::emplace_back<RINGMONSTER_DATA const &>
PUBLIC	??$forward@ABURINGMONSTER_DATA@@@std@@YAABURINGMONSTER_DATA@@ABU1@@Z ; std::forward<RINGMONSTER_DATA const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAE@ABURINGMONSTER_DATA@@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Emplace_back_with_unused_capacity<RINGMONSTER_DATA const &>
PUBLIC	??$_Unfancy@URINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@PAU1@@Z ; std::_Unfancy<RINGMONSTER_DATA>
PUBLIC	??$construct@URINGMONSTER_DATA@@ABU1@@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@SAXAAV?$allocator@URINGMONSTER_DATA@@@1@QAURINGMONSTER_DATA@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_DATA> >::construct<RINGMONSTER_DATA,RINGMONSTER_DATA const &>
PUBLIC	??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Emplace_reallocate<RINGMONSTER_DATA const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@URINGMONSTER_DATA@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<RINGMONSTER_DATA>,std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >,1>::_Compressed_pair<std::allocator<RINGMONSTER_DATA>,std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@QAU1@AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z ; std::_Destroy_range<std::allocator<RINGMONSTER_EVENT_TIME> >
PUBLIC	??$_Destroy_range@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAXPAURINGMONSTER_DATA@@QAU1@AAV?$allocator@URINGMONSTER_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<RINGMONSTER_DATA> >
PUBLIC	??$_Copy_memmove@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00@Z ; std::_Copy_memmove<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>
PUBLIC	??$move@AAURINGMONSTER_EVENT_TIME@@@std@@YA$$QAURINGMONSTER_EVENT_TIME@@AAU1@@Z ; std::move<RINGMONSTER_EVENT_TIME &>
PUBLIC	??$_Copy_memmove@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00@Z ; std::_Copy_memmove<RINGMONSTER_DATA *,RINGMONSTER_DATA *>
PUBLIC	??$move@AAURINGMONSTER_DATA@@@std@@YA$$QAURINGMONSTER_DATA@@AAU1@@Z ; std::move<RINGMONSTER_DATA &>
PUBLIC	??$_Uninitialized_move@PAURINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAPAURINGMONSTER_EVENT_TIME@@QAU1@0PAU1@AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z ; std::_Uninitialized_move<RINGMONSTER_EVENT_TIME *,std::allocator<RINGMONSTER_EVENT_TIME> >
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Uninitialized_move@PAURINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAPAURINGMONSTER_DATA@@QAU1@0PAU1@AAV?$allocator@URINGMONSTER_DATA@@@0@@Z ; std::_Uninitialized_move<RINGMONSTER_DATA *,std::allocator<RINGMONSTER_DATA> >
PUBLIC	??$_Get_size_of_n@$0M@@std@@YAII@Z		; std::_Get_size_of_n<12>
PUBLIC	??$_Get_unwrapped@ABQAURINGMONSTER_EVENT_TIME@@@std@@YA@ABQAURINGMONSTER_EVENT_TIME@@@Z ; std::_Get_unwrapped<RINGMONSTER_EVENT_TIME * const &>
PUBLIC	??$_Get_unwrapped@ABQAURINGMONSTER_DATA@@@std@@YA@ABQAURINGMONSTER_DATA@@@Z ; std::_Get_unwrapped<RINGMONSTER_DATA * const &>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_07NBCGADJA@Unknown@			; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7CRingMonsterHerd@@6B@			; CRingMonsterHerd::`vftable'
PUBLIC	??_7CRingAttackEvent@@6B@			; CRingAttackEvent::`vftable'
PUBLIC	??_C@_0DL@ELDBHEBB@?$FLRing?5Event?$FN?5White?5Wizard?5Kille@ ; `string'
PUBLIC	??_C@_0EA@DGMJBKOB@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5t@ ; `string'
PUBLIC	??_C@_0CN@EBKICF@?$FLRing?5Event?$FN?5?9?5Error?5?3?5No?5Monst@ ; `string'
PUBLIC	??_C@_0DP@FPIHCFEB@?$FLRing?5Event?$FN?5?9?5Monster?5Start?5Po@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_0CG@OKIEPGH@?$FLRing?5Event?$FN?5Info?5file?5Load?5Fai@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end@				; `string'
PUBLIC	??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB@	; `string'
PUBLIC	??_C@_0CD@BNKPBCAA@?$FLRing?5Event?$FN?5No?5Schedule?5Time?5D@ ; `string'
PUBLIC	??_C@_0EG@KMBELKMF@?$FLRing?5Event?$FN?5Sync?5Start?5Time?4?5?$FL@ ; `string'
PUBLIC	??_C@_0CM@NAOFHPPM@?$FLRing?5Event?$FN?5?9?5Before?53?5minutes@ ; `string'
PUBLIC	??_C@_0BN@HLGPJCPM@?$FLRing?5Event?$FN?5?9?5Event?5Started@ ; `string'
PUBLIC	??_C@_0EG@MJJALBNB@?$FLRing?5Event?$FN?5?9?5per?530?8S?5Inform?5@ ; `string'
PUBLIC	??_C@_0DK@PFGAPPAF@?$FLRing?5Event?$FN?5?9?5Monster?5Herd?5Mov@ ; `string'
PUBLIC	??_C@_0BL@KELOKDGN@?$FLRing?5Event?$FN?5?9?5Event?5Ended@ ; `string'
PUBLIC	??_C@_0DB@PHNKOJF@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$FLStart?$FN?5@ ; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CRingMonsterHerd@@6B@			; CRingMonsterHerd::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCRingMonsterHerd@@@8			; CRingMonsterHerd `RTTI Type Descriptor'
PUBLIC	??_R3CRingMonsterHerd@@8			; CRingMonsterHerd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CRingMonsterHerd@@8			; CRingMonsterHerd::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CRingMonsterHerd@@8		; CRingMonsterHerd::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@MonsterHerd@@8			; MonsterHerd::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVMonsterHerd@@@8				; MonsterHerd `RTTI Type Descriptor'
PUBLIC	??_R3MonsterHerd@@8				; MonsterHerd::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MonsterHerd@@8				; MonsterHerd::`RTTI Base Class Array'
PUBLIC	??_R4CRingAttackEvent@@6B@			; CRingAttackEvent::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCRingAttackEvent@@@8			; CRingAttackEvent `RTTI Type Descriptor'
PUBLIC	??_R3CRingAttackEvent@@8			; CRingAttackEvent::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CRingAttackEvent@@8			; CRingAttackEvent::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CRingAttackEvent@@8		; CRingAttackEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_strcmp:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__GetLocalTime@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_rand:PROC
EXTRN	_atof:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	__imp_?Get@CMsg@@QAEPADH@Z:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?ItemGetNumberMake@@YAHHH@Z:PROC		; ItemGetNumberMake
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
EXTRN	?DataSendAll@@YAXPAEH@Z:PROC			; DataSendAll
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z:PROC ; gObjMonsterTopHitDamageUser
EXTRN	??0MonsterHerd@@QAE@XZ:PROC			; MonsterHerd::MonsterHerd
EXTRN	??1MonsterHerd@@UAE@XZ:PROC			; MonsterHerd::~MonsterHerd
EXTRN	?SetTotalInfo@MonsterHerd@@UAEHHHHH@Z:PROC	; MonsterHerd::SetTotalInfo
EXTRN	?AddMonster@MonsterHerd@@UAEHHHH@Z:PROC		; MonsterHerd::AddMonster
EXTRN	?SetRadius@MonsterHerd@@UAEXH@Z:PROC		; MonsterHerd::SetRadius
EXTRN	?SetPosition@MonsterHerd@@UAEXEE@Z:PROC		; MonsterHerd::SetPosition
EXTRN	?Start@MonsterHerd@@UAEHXZ:PROC			; MonsterHerd::Start
EXTRN	?Stop@MonsterHerd@@UAEXXZ:PROC			; MonsterHerd::Stop
EXTRN	?CheckInRadius@MonsterHerd@@UAEHH@Z:PROC	; MonsterHerd::CheckInRadius
EXTRN	?GetCurrentLocation@MonsterHerd@@UAEHAAE0@Z:PROC ; MonsterHerd::GetCurrentLocation
EXTRN	?GetRandomLocation@MonsterHerd@@UAEHAAE0@Z:PROC	; MonsterHerd::GetRandomLocation
EXTRN	?CheckLocation@MonsterHerd@@UAEHAAE0@Z:PROC	; MonsterHerd::CheckLocation
EXTRN	?MoveHerd@MonsterHerd@@UAEHEE@Z:PROC		; MonsterHerd::MoveHerd
EXTRN	?GetMonsterData@MonsterHerd@@UAEPAU_MONSTER_HERD_DATA@@H@Z:PROC ; MonsterHerd::GetMonsterData
EXTRN	?BeenAttacked@MonsterHerd@@UAEXPAVOBJECTSTRUCT@@0@Z:PROC ; MonsterHerd::BeenAttacked
EXTRN	?OrderAttack@MonsterHerd@@UAEXPAVOBJECTSTRUCT@@0H@Z:PROC ; MonsterHerd::OrderAttack
EXTRN	?MonsterBaseAct@MonsterHerd@@UAEXPAVOBJECTSTRUCT@@@Z:PROC ; MonsterHerd::MonsterBaseAct
EXTRN	?MonsterMoveAction@MonsterHerd@@UAEXPAVOBJECTSTRUCT@@@Z:PROC ; MonsterHerd::MonsterMoveAction
EXTRN	?MonsterDieAction@MonsterHerd@@UAEXPAVOBJECTSTRUCT@@@Z:PROC ; MonsterHerd::MonsterDieAction
EXTRN	?MonsterRegenAction@MonsterHerd@@UAEHPAVOBJECTSTRUCT@@@Z:PROC ; MonsterHerd::MonsterRegenAction
EXTRN	?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z:PROC	; ItemSerialCreateSend
EXTRN	??_ECRingMonsterHerd@@UAEPAXI@Z:PROC		; CRingMonsterHerd::`vector deleting destructor'
EXTRN	??_ECRingAttackEvent@@UAEPAXI@Z:PROC		; CRingAttackEvent::`vector deleting destructor'
EXTRN	?MoneyItemDrop@MapClass@@QAEHHHH@Z:PROC		; MapClass::MoneyItemDrop
EXTRN	?DataSendEventChip@@YAXPADH@Z:PROC		; DataSendEventChip
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?g_TerrainManager@@3VCTerrainManager@@A:BYTE	; g_TerrainManager
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?MapC@@3PAVMapClass@@A:DWORD			; MapC
EXTRN	?g_iRingOrcKillGiftRate@@3HA:DWORD		; g_iRingOrcKillGiftRate
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?SMDFile@@3PAU_iobuf@@A DD 01H DUP (?)			; SMDFile
?TokenNumber@@3MA DD 01H DUP (?)			; TokenNumber
?TokenString@@3PADA DB 064H DUP (?)			; TokenString
?CurrentToken@@3W4SMDToken@@A DD 01H DUP (?)		; CurrentToken
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@CRingAttackEvent@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CRingAttackEvent@@8 DD FLAT:??_R0?AVCRingAttackEvent@@@8 ; CRingAttackEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CRingAttackEvent@@8
rdata$r	ENDS
;	COMDAT ??_R2CRingAttackEvent@@8
rdata$r	SEGMENT
??_R2CRingAttackEvent@@8 DD FLAT:??_R1A@?0A@EA@CRingAttackEvent@@8 ; CRingAttackEvent::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CRingAttackEvent@@8
rdata$r	SEGMENT
??_R3CRingAttackEvent@@8 DD 00H				; CRingAttackEvent::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CRingAttackEvent@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCRingAttackEvent@@@8
data$r	SEGMENT
??_R0?AVCRingAttackEvent@@@8 DD FLAT:??_7type_info@@6B@	; CRingAttackEvent `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCRingAttackEvent@@', 00H
data$r	ENDS
;	COMDAT ??_R4CRingAttackEvent@@6B@
rdata$r	SEGMENT
??_R4CRingAttackEvent@@6B@ DD 00H			; CRingAttackEvent::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCRingAttackEvent@@@8
	DD	FLAT:??_R3CRingAttackEvent@@8
rdata$r	ENDS
;	COMDAT ??_R2MonsterHerd@@8
rdata$r	SEGMENT
??_R2MonsterHerd@@8 DD FLAT:??_R1A@?0A@EA@MonsterHerd@@8 ; MonsterHerd::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3MonsterHerd@@8
rdata$r	SEGMENT
??_R3MonsterHerd@@8 DD 00H				; MonsterHerd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMonsterHerd@@@8
data$r	SEGMENT
??_R0?AVMonsterHerd@@@8 DD FLAT:??_7type_info@@6B@	; MonsterHerd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMonsterHerd@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MonsterHerd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MonsterHerd@@8 DD FLAT:??_R0?AVMonsterHerd@@@8 ; MonsterHerd::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CRingMonsterHerd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CRingMonsterHerd@@8 DD FLAT:??_R0?AVCRingMonsterHerd@@@8 ; CRingMonsterHerd::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CRingMonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R2CRingMonsterHerd@@8
rdata$r	SEGMENT
??_R2CRingMonsterHerd@@8 DD FLAT:??_R1A@?0A@EA@CRingMonsterHerd@@8 ; CRingMonsterHerd::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@MonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R3CRingMonsterHerd@@8
rdata$r	SEGMENT
??_R3CRingMonsterHerd@@8 DD 00H				; CRingMonsterHerd::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CRingMonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCRingMonsterHerd@@@8
data$r	SEGMENT
??_R0?AVCRingMonsterHerd@@@8 DD FLAT:??_7type_info@@6B@	; CRingMonsterHerd `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCRingMonsterHerd@@', 00H
data$r	ENDS
;	COMDAT ??_R4CRingMonsterHerd@@6B@
rdata$r	SEGMENT
??_R4CRingMonsterHerd@@6B@ DD 00H			; CRingMonsterHerd::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCRingMonsterHerd@@@8
	DD	FLAT:??_R3CRingMonsterHerd@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@PHNKOJF@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$FLStart?$FN?5@
CONST	SEGMENT
??_C@_0DB@PHNKOJF@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$FLStart?$FN?5@ DB 0a1H
	DB	0dbH, 0a1H, 0dcH, '[Event Management] [Start] RingAttack Event'
	DB	'!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KELOKDGN@?$FLRing?5Event?$FN?5?9?5Event?5Ended@
CONST	SEGMENT
??_C@_0BL@KELOKDGN@?$FLRing?5Event?$FN?5?9?5Event?5Ended@ DB '[Ring Event'
	DB	'] - Event Ended', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@PFGAPPAF@?$FLRing?5Event?$FN?5?9?5Monster?5Herd?5Mov@
CONST	SEGMENT
??_C@_0DK@PFGAPPAF@?$FLRing?5Event?$FN?5?9?5Monster?5Herd?5Mov@ DB '[Ring'
	DB	' Event] - Monster Herd Move MapNumber:%d, X:%d, Y:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@MJJALBNB@?$FLRing?5Event?$FN?5?9?5per?530?8S?5Inform?5@
CONST	SEGMENT
??_C@_0EG@MJJALBNB@?$FLRing?5Event?$FN?5?9?5per?530?8S?5Inform?5@ DB '[Ri'
	DB	'ng Event] - per 30''S Inform MapNumber:%d, X:%d, Y:%d, Boss L'
	DB	'ive:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HLGPJCPM@?$FLRing?5Event?$FN?5?9?5Event?5Started@
CONST	SEGMENT
??_C@_0BN@HLGPJCPM@?$FLRing?5Event?$FN?5?9?5Event?5Started@ DB '[Ring Eve'
	DB	'nt] - Event Started', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NAOFHPPM@?$FLRing?5Event?$FN?5?9?5Before?53?5minutes@
CONST	SEGMENT
??_C@_0CM@NAOFHPPM@?$FLRing?5Event?$FN?5?9?5Before?53?5minutes@ DB '[Ring'
	DB	' Event] - Before 3 minutes - Advertise', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@KMBELKMF@?$FLRing?5Event?$FN?5Sync?5Start?5Time?4?5?$FL@
CONST	SEGMENT
??_C@_0EG@KMBELKMF@?$FLRing?5Event?$FN?5Sync?5Start?5Time?4?5?$FL@ DB '[R'
	DB	'ing Event] Sync Start Time. [%d] min remain (START HOUR:%d, M'
	DB	'IN:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BNKPBCAA@?$FLRing?5Event?$FN?5No?5Schedule?5Time?5D@
CONST	SEGMENT
??_C@_0CD@BNKPBCAA@?$FLRing?5Event?$FN?5No?5Schedule?5Time?5D@ DB '[Ring '
	DB	'Event] No Schedule Time Data', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB@
CONST	SEGMENT
??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB@ DB '%s file load!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end@
CONST	SEGMENT
??_C@_03JBJLGPFL@end@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OKIEPGH@?$FLRing?5Event?$FN?5Info?5file?5Load?5Fai@
CONST	SEGMENT
??_C@_0CG@OKIEPGH@?$FLRing?5Event?$FN?5Info?5file?5Load?5Fai@ DB '[Ring E'
	DB	'vent] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@FPIHCFEB@?$FLRing?5Event?$FN?5?9?5Monster?5Start?5Po@
CONST	SEGMENT
??_C@_0DP@FPIHCFEB@?$FLRing?5Event?$FN?5?9?5Monster?5Start?5Po@ DB '[Ring'
	DB	' Event] - Monster Start Position MapNumber:%d, X:%d, Y:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EBKICF@?$FLRing?5Event?$FN?5?9?5Error?5?3?5No?5Monst@
CONST	SEGMENT
??_C@_0CN@EBKICF@?$FLRing?5Event?$FN?5?9?5Error?5?3?5No?5Monst@ DB '[Ring'
	DB	' Event] - Error : No Monster Data Exist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@DGMJBKOB@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5t@
CONST	SEGMENT
??_C@_0EA@DGMJBKOB@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5t@ DB '['
	DB	'Ring Event] [%s][%s] Request to Register Gift - Gift Kind (%d'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@ELDBHEBB@?$FLRing?5Event?$FN?5White?5Wizard?5Kille@
CONST	SEGMENT
??_C@_0DL@ELDBHEBB@?$FLRing?5Event?$FN?5White?5Wizard?5Kille@ DB '[Ring E'
	DB	'vent] White Wizard Killed by [%s][%s], MapNumber:%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CRingAttackEvent@@6B@
CONST	SEGMENT
??_7CRingAttackEvent@@6B@ DD FLAT:??_R4CRingAttackEvent@@6B@ ; CRingAttackEvent::`vftable'
	DD	FLAT:??_ECRingAttackEvent@@UAEPAXI@Z
	DD	FLAT:?Load@CRingAttackEvent@@UAEHPAD@Z
CONST	ENDS
;	COMDAT ??_7CRingMonsterHerd@@6B@
CONST	SEGMENT
??_7CRingMonsterHerd@@6B@ DD FLAT:??_R4CRingMonsterHerd@@6B@ ; CRingMonsterHerd::`vftable'
	DD	FLAT:??_ECRingMonsterHerd@@UAEPAXI@Z
	DD	FLAT:?SetTotalInfo@MonsterHerd@@UAEHHHHH@Z
	DD	FLAT:?AddMonster@MonsterHerd@@UAEHHHH@Z
	DD	FLAT:?SetRadius@MonsterHerd@@UAEXH@Z
	DD	FLAT:?SetPosition@MonsterHerd@@UAEXEE@Z
	DD	FLAT:?Start@CRingMonsterHerd@@UAEHXZ
	DD	FLAT:?Stop@MonsterHerd@@UAEXXZ
	DD	FLAT:?CheckInRadius@MonsterHerd@@UAEHH@Z
	DD	FLAT:?GetCurrentLocation@MonsterHerd@@UAEHAAE0@Z
	DD	FLAT:?GetRandomLocation@MonsterHerd@@UAEHAAE0@Z
	DD	FLAT:?CheckLocation@MonsterHerd@@UAEHAAE0@Z
	DD	FLAT:?MoveHerd@MonsterHerd@@UAEHEE@Z
	DD	FLAT:?MonsterHerdItemDrop@CRingMonsterHerd@@UAEHPAVOBJECTSTRUCT@@@Z
	DD	FLAT:?GetMonsterData@MonsterHerd@@UAEPAU_MONSTER_HERD_DATA@@H@Z
	DD	FLAT:?BeenAttacked@MonsterHerd@@UAEXPAVOBJECTSTRUCT@@0@Z
	DD	FLAT:?OrderAttack@MonsterHerd@@UAEXPAVOBJECTSTRUCT@@0H@Z
	DD	FLAT:?MonsterBaseAct@MonsterHerd@@UAEXPAVOBJECTSTRUCT@@@Z
	DD	FLAT:?MonsterMoveAction@MonsterHerd@@UAEXPAVOBJECTSTRUCT@@@Z
	DD	FLAT:?MonsterAttackAction@CRingMonsterHerd@@UAEXPAVOBJECTSTRUCT@@0@Z
	DD	FLAT:?MonsterDieAction@MonsterHerd@@UAEXPAVOBJECTSTRUCT@@@Z
	DD	FLAT:?MonsterRegenAction@MonsterHerd@@UAEHPAVOBJECTSTRUCT@@@Z
CONST	ENDS
_DATA	SEGMENT
?g_RingEventMapNum@@3PAHA DD 00H			; g_RingEventMapNum
	DD	02H
	DD	03H
?g_RingMapPosition@@3PAY03HA DD 042H			; g_RingMapPosition
	DD	02cH
	DD	0bfH
	DD	0c5H
	DD	06fH
	DD	0eH
	DD	0e8H
	DD	07dH
	DD	088H
	DD	035H
	DD	0dfH
	DD	0b5H
?iTIME_SEC_NOTIFY@?1??ProcState_Playing@CRingAttackEvent@@QAEXXZ@4HA DD 0ffffffffH ; `CRingAttackEvent::ProcState_Playing'::`2'::iTIME_SEC_NOTIFY
?g_RingMapDestPosition@@3PAY07HA DD 085H		; g_RingMapDestPosition
	DD	04fH
	DD	057H
	DD	07eH
	DD	085H
	DD	0b2H
	DD	0b4H
	DD	07eH
	DD	0a4H
	DD	02aH
	DD	0ddH
	DD	055H
	DD	0a4H
	DD	02aH
	DD	0ddH
	DD	055H
	DD	0a0H
	DD	04bH
	DD	0a0H
	DD	04bH
	DD	098H
	DD	075H
	DD	0d1H
	DD	085H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z$2
__ehfuncinfo$??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z$2
__ehfuncinfo$??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CRingAttackEvent@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?erase@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?erase@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAURINGMONSTER_DATA@@@std@@YA@ABQAURINGMONSTER_DATA@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAURINGMONSTER_DATA@@@std@@YA@ABQAURINGMONSTER_DATA@@@Z PROC ; std::_Get_unwrapped<RINGMONSTER_DATA * const &>, COMDAT

; 1229 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1230 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1231 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1232 :         return _It + 0;

  00009	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]

; 1233 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1234 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1235 :     } else {
; 1236 :         return static_cast<_Iter&&>(_It);
; 1237 :     }
; 1238 : }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Get_unwrapped@ABQAURINGMONSTER_DATA@@@std@@YA@ABQAURINGMONSTER_DATA@@@Z ENDP ; std::_Get_unwrapped<RINGMONSTER_DATA * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAURINGMONSTER_EVENT_TIME@@@std@@YA@ABQAURINGMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAURINGMONSTER_EVENT_TIME@@@std@@YA@ABQAURINGMONSTER_EVENT_TIME@@@Z PROC ; std::_Get_unwrapped<RINGMONSTER_EVENT_TIME * const &>, COMDAT

; 1229 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1230 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1231 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1232 :         return _It + 0;

  00009	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]

; 1233 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1234 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1235 :     } else {
; 1236 :         return static_cast<_Iter&&>(_It);
; 1237 :     }
; 1238 : }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Get_unwrapped@ABQAURINGMONSTER_EVENT_TIME@@@std@@YA@ABQAURINGMONSTER_EVENT_TIME@@@Z ENDP ; std::_Get_unwrapped<RINGMONSTER_EVENT_TIME * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0M@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0M@@std@@YAII@Z PROC			; std::_Get_size_of_n<12>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000d	c7 45 f8 55 55
	55 15		 mov	 DWORD PTR __Max_possible$1[ebp], 357913941 ; 15555555H

; 60   :         if (_Count > _Max_possible) {

  00014	81 7d 08 55 55
	55 15		 cmp	 DWORD PTR __Count$[ebp], 357913941 ; 15555555H
  0001b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00022	6b 45 08 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
$LN3@Get_size_o:

; 66   : }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Get_size_of_n@$0M@@std@@YAII@Z ENDP			; std::_Get_size_of_n<12>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAURINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAPAURINGMONSTER_DATA@@QAU1@0PAU1@AAV?$allocator@URINGMONSTER_DATA@@@0@@Z
_TEXT	SEGMENT
__ULast$ = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAURINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAPAURINGMONSTER_DATA@@QAU1@0PAU1@AAV?$allocator@URINGMONSTER_DATA@@@0@@Z PROC ; std::_Uninitialized_move<RINGMONSTER_DATA *,std::allocator<RINGMONSTER_DATA> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);

  00009	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAURINGMONSTER_DATA@@@std@@YA@ABQAURINGMONSTER_DATA@@@Z ; std::_Get_unwrapped<RINGMONSTER_DATA * const &>
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1652 :     const auto _ULast = _Get_unwrapped(_Last);

  00018	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAURINGMONSTER_DATA@@@std@@YA@ABQAURINGMONSTER_DATA@@@Z ; std::_Get_unwrapped<RINGMONSTER_DATA * const &>
  00021	83 c4 04	 add	 esp, 4
  00024	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00027	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Unfancy@URINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@PAU1@@Z ; std::_Unfancy<RINGMONSTER_DATA>
  00030	83 c4 04	 add	 esp, 4
  00033	50		 push	 eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR __ULast$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 fc	 mov	 edx, DWORD PTR __UFirst$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00@Z ; std::_Copy_memmove<RINGMONSTER_DATA *,RINGMONSTER_DATA *>
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1656 :         return _Dest + (_ULast - _UFirst);

  00044	8b 45 f8	 mov	 eax, DWORD PTR __ULast$[ebp]
  00047	2b 45 fc	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0004a	99		 cdq
  0004b	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00050	f7 f9		 idiv	 ecx
  00052	6b c0 0c	 imul	 eax, eax, 12
  00055	03 45 10	 add	 eax, DWORD PTR __Dest$[ebp]

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
??$_Uninitialized_move@PAURINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAPAURINGMONSTER_DATA@@QAU1@0PAU1@AAV?$allocator@URINGMONSTER_DATA@@@0@@Z ENDP ; std::_Uninitialized_move<RINGMONSTER_DATA *,std::allocator<RINGMONSTER_DATA> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000d	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 60   :         if (_Count > _Max_possible) {

  00014	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  0001b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00022	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00025	c1 e0 03	 shl	 eax, 3
$LN3@Get_size_o:

; 66   : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAURINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAPAURINGMONSTER_EVENT_TIME@@QAU1@0PAU1@AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z
_TEXT	SEGMENT
__ULast$ = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAURINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAPAURINGMONSTER_EVENT_TIME@@QAU1@0PAU1@AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z PROC ; std::_Uninitialized_move<RINGMONSTER_EVENT_TIME *,std::allocator<RINGMONSTER_EVENT_TIME> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);

  00009	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAURINGMONSTER_EVENT_TIME@@@std@@YA@ABQAURINGMONSTER_EVENT_TIME@@@Z ; std::_Get_unwrapped<RINGMONSTER_EVENT_TIME * const &>
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1652 :     const auto _ULast = _Get_unwrapped(_Last);

  00018	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAURINGMONSTER_EVENT_TIME@@@std@@YA@ABQAURINGMONSTER_EVENT_TIME@@@Z ; std::_Get_unwrapped<RINGMONSTER_EVENT_TIME * const &>
  00021	83 c4 04	 add	 esp, 4
  00024	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00027	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Unfancy@URINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@@Z ; std::_Unfancy<RINGMONSTER_EVENT_TIME>
  00030	83 c4 04	 add	 esp, 4
  00033	50		 push	 eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR __ULast$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 fc	 mov	 edx, DWORD PTR __UFirst$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00@Z ; std::_Copy_memmove<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1656 :         return _Dest + (_ULast - _UFirst);

  00044	8b 45 f8	 mov	 eax, DWORD PTR __ULast$[ebp]
  00047	2b 45 fc	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0004a	c1 f8 03	 sar	 eax, 3
  0004d	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00050	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
??$_Uninitialized_move@PAURINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAPAURINGMONSTER_EVENT_TIME@@QAU1@0PAU1@AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z ENDP ; std::_Uninitialized_move<RINGMONSTER_EVENT_TIME *,std::allocator<RINGMONSTER_EVENT_TIME> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$move@AAURINGMONSTER_DATA@@@std@@YA$$QAURINGMONSTER_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAURINGMONSTER_DATA@@@std@@YA$$QAURINGMONSTER_DATA@@AAU1@@Z PROC ; std::move<RINGMONSTER_DATA &>, COMDAT

; 1466 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1467 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1468 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAURINGMONSTER_DATA@@@std@@YA$$QAURINGMONSTER_DATA@@AAU1@@Z ENDP ; std::move<RINGMONSTER_DATA &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00@Z
_TEXT	SEGMENT
__Count$ = -16						; size = 4
__Dest_ch$ = -12					; size = 4
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00@Z PROC ; std::_Copy_memmove<RINGMONSTER_DATA *,RINGMONSTER_DATA *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	89 45 f4	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001e	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00021	89 45 f0	 mov	 DWORD PTR __Count$[ebp], eax

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00024	8b 45 f0	 mov	 eax, DWORD PTR __Count$[ebp]
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR __First_ch$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 f4	 mov	 edx, DWORD PTR __Dest_ch$[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 _memmove
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00038	8b 45 f4	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0003b	03 45 f0	 add	 eax, DWORD PTR __Count$[ebp]

; 4120 : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$_Copy_memmove@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00@Z ENDP ; std::_Copy_memmove<RINGMONSTER_DATA *,RINGMONSTER_DATA *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$move@AAURINGMONSTER_EVENT_TIME@@@std@@YA$$QAURINGMONSTER_EVENT_TIME@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAURINGMONSTER_EVENT_TIME@@@std@@YA$$QAURINGMONSTER_EVENT_TIME@@AAU1@@Z PROC ; std::move<RINGMONSTER_EVENT_TIME &>, COMDAT

; 1466 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1467 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1468 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAURINGMONSTER_EVENT_TIME@@@std@@YA$$QAURINGMONSTER_EVENT_TIME@@AAU1@@Z ENDP ; std::move<RINGMONSTER_EVENT_TIME &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00@Z
_TEXT	SEGMENT
__Count$ = -16						; size = 4
__Dest_ch$ = -12					; size = 4
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00@Z PROC ; std::_Copy_memmove<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	89 45 f4	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001e	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00021	89 45 f0	 mov	 DWORD PTR __Count$[ebp], eax

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00024	8b 45 f0	 mov	 eax, DWORD PTR __Count$[ebp]
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR __First_ch$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 f4	 mov	 edx, DWORD PTR __Dest_ch$[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 _memmove
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00038	8b 45 f4	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0003b	03 45 f0	 add	 eax, DWORD PTR __Count$[ebp]

; 4120 : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$_Copy_memmove@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00@Z ENDP ; std::_Copy_memmove<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAXPAURINGMONSTER_DATA@@QAU1@AAV?$allocator@URINGMONSTER_DATA@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAXPAURINGMONSTER_DATA@@QAU1@AAV?$allocator@URINGMONSTER_DATA@@@0@@Z PROC ; std::_Destroy_range<std::allocator<RINGMONSTER_DATA> >, COMDAT

; 955  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_range@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAXPAURINGMONSTER_DATA@@QAU1@AAV?$allocator@URINGMONSTER_DATA@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<RINGMONSTER_DATA> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@QAU1@AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@QAU1@AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z PROC ; std::_Destroy_range<std::allocator<RINGMONSTER_EVENT_TIME> >, COMDAT

; 955  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_range@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@QAU1@AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<RINGMONSTER_EVENT_TIME> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@URINGMONSTER_DATA@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@URINGMONSTER_DATA@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<RINGMONSTER_DATA>,std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >,1>::_Compressed_pair<std::allocator<RINGMONSTER_DATA>,std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >,1><>, COMDAT
; _this$ = ecx

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@URINGMONSTER_DATA@@@std@@QAE@XZ ; std::allocator<RINGMONSTER_DATA>::allocator<RINGMONSTER_DATA>
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@URINGMONSTER_DATA@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<RINGMONSTER_DATA>,std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >,1>::_Compressed_pair<std::allocator<RINGMONSTER_DATA>,std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z
_TEXT	SEGMENT
__Constructed_first$ = -64				; size = 4
__Constructed_last$ = -60				; size = 4
__Newvec$ = -56						; size = 4
__Newcapacity$ = -52					; size = 4
__Newsize$ = -48					; size = 4
__Oldsize$ = -44					; size = 4
__Whereoff$ = -40					; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
__My_data$ = -28					; size = 4
__Al$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Emplace_reallocate<RINGMONSTER_DATA const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 70	 sub	 esp, 112		; 00000070H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Getal@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_DATA@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Getal
  00037	89 45 e8	 mov	 DWORD PTR __Al$[ebp], eax

; 728  :         auto& _My_data    = _Mypair._Myval2;

  0003a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00040	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00043	89 45 e0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  00046	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	83 c0 04	 add	 eax, 4
  0004c	89 45 dc	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0004f	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00055	2b 08		 sub	 ecx, DWORD PTR [eax]
  00057	8b c1		 mov	 eax, ecx
  00059	99		 cdq
  0005a	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0005f	f7 f9		 idiv	 ecx
  00061	89 45 d8	 mov	 DWORD PTR __Whereoff$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00064	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00067	8b 4d e0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006a	8b 00		 mov	 eax, DWORD PTR [eax]
  0006c	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006e	99		 cdq
  0006f	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00074	f7 f9		 idiv	 ecx
  00076	89 45 d4	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  00079	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ?max_size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::max_size
  00081	39 45 d4	 cmp	 DWORD PTR __Oldsize$[ebp], eax
  00084	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  00086	e8 00 00 00 00	 call	 ?_Xlength@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@CAXXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0008b	8b 45 d4	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  0008e	83 c0 01	 add	 eax, 1
  00091	89 45 d0	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  00094	8b 45 d0	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	50		 push	 eax
  00098	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@ABEII@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Calculate_growth
  000a0	89 45 cc	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 743  : 
; 744  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

  000a3	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000a6	50		 push	 eax
  000a7	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  000aa	e8 00 00 00 00	 call	 ?allocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEPAURINGMONSTER_DATA@@I@Z ; std::allocator<RINGMONSTER_DATA>::allocate
  000af	89 45 c8	 mov	 DWORD PTR __Newvec$[ebp], eax

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000b2	6b 45 d8 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  000b6	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000b9	8d 54 01 0c	 lea	 edx, DWORD PTR [ecx+eax+12]
  000bd	89 55 c4	 mov	 DWORD PTR __Constructed_last$[ebp], edx

; 746  :         pointer _Constructed_first      = _Constructed_last;

  000c0	8b 45 c4	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  000c3	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  000c6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000cd	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ??$forward@ABURINGMONSTER_DATA@@@std@@YAABURINGMONSTER_DATA@@ABU1@@Z ; std::forward<RINGMONSTER_DATA const &>
  000d6	83 c4 04	 add	 esp, 4
  000d9	50		 push	 eax
  000da	6b 4d d8 0c	 imul	 ecx, DWORD PTR __Whereoff$[ebp], 12
  000de	03 4d c8	 add	 ecx, DWORD PTR __Newvec$[ebp]
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 ??$_Unfancy@URINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@PAU1@@Z ; std::_Unfancy<RINGMONSTER_DATA>
  000e7	83 c4 04	 add	 esp, 4
  000ea	50		 push	 eax
  000eb	8b 55 e8	 mov	 edx, DWORD PTR __Al$[ebp]
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 ??$construct@URINGMONSTER_DATA@@ABU1@@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@SAXAAV?$allocator@URINGMONSTER_DATA@@@1@QAURINGMONSTER_DATA@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_DATA> >::construct<RINGMONSTER_DATA,RINGMONSTER_DATA const &>
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  000f7	6b 45 d8 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  000fb	03 45 c8	 add	 eax, DWORD PTR __Newvec$[ebp]
  000fe	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00101	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00104	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00107	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00109	75 1a		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  0010b	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0010e	50		 push	 eax
  0010f	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00112	8b 11		 mov	 edx, DWORD PTR [ecx]
  00114	52		 push	 edx
  00115	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00118	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011a	51		 push	 ecx
  0011b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011e	e8 00 00 00 00	 call	 ?_Umove_if_noexcept@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@00@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove_if_noexcept

; 754  :         } else { // provide basic guarantee

  00123	eb 3a		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  00125	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00128	50		 push	 eax
  00129	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0012c	51		 push	 ecx
  0012d	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00130	8b 02		 mov	 eax, DWORD PTR [edx]
  00132	50		 push	 eax
  00133	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	e8 00 00 00 00	 call	 ?_Umove@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEPAURINGMONSTER_DATA@@PAU3@00@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove

; 756  :             _Constructed_first = _Newvec;

  0013b	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0013e	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00141	6b 45 d8 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  00145	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00148	8d 54 01 0c	 lea	 edx, DWORD PTR [ecx+eax+12]
  0014c	52		 push	 edx
  0014d	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	51		 push	 ecx
  00153	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  00156	52		 push	 edx
  00157	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	e8 00 00 00 00	 call	 ?_Umove@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEPAURINGMONSTER_DATA@@PAU3@00@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove
$LN5@Emplace_re:
  0015f	eb 2f		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00161	8b 45 c4	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00164	50		 push	 eax
  00165	8b 4d c0	 mov	 ecx, DWORD PTR __Constructed_first$[ebp]
  00168	51		 push	 ecx
  00169	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0016c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00171	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00174	50		 push	 eax
  00175	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00178	51		 push	 ecx
  00179	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  0017c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEXQAURINGMONSTER_DATA@@I@Z ; std::allocator<RINGMONSTER_DATA>::deallocate

; 762  :         _RERAISE;

  00181	6a 00		 push	 0
  00183	6a 00		 push	 0
  00185	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  0018a	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0018f	c3		 ret	 0
$LN7@Emplace_re:
  00190	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00197	eb 07		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z$1
$LN10@Emplace_re:
  00199	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z$1:

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001a0	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  001a3	50		 push	 eax
  001a4	8b 4d d0	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  001a7	51		 push	 ecx
  001a8	8b 55 c8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  001ab	52		 push	 edx
  001ac	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001af	e8 00 00 00 00	 call	 ?_Change_array@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXQAURINGMONSTER_DATA@@II@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  001b4	6b 45 d8 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  001b8	03 45 c8	 add	 eax, DWORD PTR __Newvec$[ebp]
$LN6@Emplace_re:

; 767  :     }

  001bb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001be	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001c5	59		 pop	 ecx
  001c6	5f		 pop	 edi
  001c7	5e		 pop	 esi
  001c8	5b		 pop	 ebx
  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c2 08 00	 ret	 8
  001cf	cc		 int	 3
  001d0	cc		 int	 3
  001d1	cc		 int	 3
  001d2	cc		 int	 3
  001d3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 7c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-132]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Emplace_reallocate<RINGMONSTER_DATA const &>
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@URINGMONSTER_DATA@@ABU1@@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@SAXAAV?$allocator@URINGMONSTER_DATA@@@1@QAURINGMONSTER_DATA@@ABU3@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@URINGMONSTER_DATA@@ABU1@@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@SAXAAV?$allocator@URINGMONSTER_DATA@@@1@QAURINGMONSTER_DATA@@ABU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_DATA> >::construct<RINGMONSTER_DATA,RINGMONSTER_DATA const &>, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	50		 push	 eax
  0000d	6a 0c		 push	 12			; 0000000cH
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00014	83 c4 08	 add	 esp, 8
  00017	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ??$forward@ABURINGMONSTER_DATA@@@std@@YAABURINGMONSTER_DATA@@ABU1@@Z ; std::forward<RINGMONSTER_DATA const &>
  00023	83 c4 04	 add	 esp, 4
  00026	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	89 0a		 mov	 DWORD PTR [edx], ecx
  0002d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00030	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00033	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00036	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 695  :     }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??$construct@URINGMONSTER_DATA@@ABU1@@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@SAXAAV?$allocator@URINGMONSTER_DATA@@@1@QAURINGMONSTER_DATA@@ABU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_DATA> >::construct<RINGMONSTER_DATA,RINGMONSTER_DATA const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$_Unfancy@URINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@PAU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@URINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@PAU1@@Z PROC ; std::_Unfancy<RINGMONSTER_DATA>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 289  :     return _Ptr;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Unfancy@URINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@PAU1@@Z ENDP ; std::_Unfancy<RINGMONSTER_DATA>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAE@ABURINGMONSTER_DATA@@@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAE@ABURINGMONSTER_DATA@@@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Emplace_back_with_unused_capacity<RINGMONSTER_DATA const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 686  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$forward@ABURINGMONSTER_DATA@@@std@@YAABURINGMONSTER_DATA@@ABU1@@Z ; std::forward<RINGMONSTER_DATA const &>
  00024	83 c4 04	 add	 esp, 4
  00027	50		 push	 eax
  00028	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ??$_Unfancy@URINGMONSTER_DATA@@@std@@YAPAURINGMONSTER_DATA@@PAU1@@Z ; std::_Unfancy<RINGMONSTER_DATA>
  00033	83 c4 04	 add	 esp, 4
  00036	50		 push	 eax
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Getal@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_DATA@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Getal
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$construct@URINGMONSTER_DATA@@ABU1@@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@SAXAAV?$allocator@URINGMONSTER_DATA@@@1@QAURINGMONSTER_DATA@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_DATA> >::construct<RINGMONSTER_DATA,RINGMONSTER_DATA const &>
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 688  :         _Orphan_range(_Mylast, _Mylast);

  00048	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	51		 push	 ecx
  0004e	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	50		 push	 eax
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@ABEXPAURINGMONSTER_DATA@@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Orphan_range

; 689  :         _Ty& _Result = *_Mylast;

  0005c	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	89 4d f0	 mov	 DWORD PTR __Result$[ebp], ecx

; 690  :         ++_Mylast;

  00064	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0006c	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0006f	89 0a		 mov	 DWORD PTR [edx], ecx

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAE@ABURINGMONSTER_DATA@@@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Emplace_back_with_unused_capacity<RINGMONSTER_DATA const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABURINGMONSTER_DATA@@@std@@YAABURINGMONSTER_DATA@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABURINGMONSTER_DATA@@@std@@YAABURINGMONSTER_DATA@@ABU1@@Z PROC ; std::forward<RINGMONSTER_DATA const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABURINGMONSTER_DATA@@@std@@YAABURINGMONSTER_DATA@@ABU1@@Z ENDP ; std::forward<RINGMONSTER_DATA const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$emplace_back@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@ABURINGMONSTER_DATA@@@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@ABURINGMONSTER_DATA@@@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::emplace_back<RINGMONSTER_DATA const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001e	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00021	8b 10		 mov	 edx, DWORD PTR [eax]
  00023	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00026	74 17		 je	 SHORT $LN2@emplace_ba

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00028	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$forward@ABURINGMONSTER_DATA@@@std@@YAABURINGMONSTER_DATA@@ABU1@@Z ; std::forward<RINGMONSTER_DATA const &>
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAE@ABURINGMONSTER_DATA@@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Emplace_back_with_unused_capacity<RINGMONSTER_DATA const &>
  0003d	eb 1e		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$forward@ABURINGMONSTER_DATA@@@std@@YAABURINGMONSTER_DATA@@ABU1@@Z ; std::forward<RINGMONSTER_DATA const &>
  00048	83 c4 04	 add	 esp, 4
  0004b	50		 push	 eax
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	52		 push	 edx
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEPAURINGMONSTER_DATA@@QAU2@ABU2@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Emplace_reallocate<RINGMONSTER_DATA const &>
  0005a	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
??$emplace_back@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@ABURINGMONSTER_DATA@@@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::emplace_back<RINGMONSTER_DATA const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Move_unchecked@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_unchecked@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00@Z PROC ; std::_Move_unchecked<RINGMONSTER_DATA *,RINGMONSTER_DATA *>, COMDAT

; 4364 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4365 :     // move [_First, _Last) to [_Dest, ...)
; 4366 :     // note: _Move_unchecked has callers other than the move family
; 4367 :     if constexpr (_Ptr_move_cat<_InIt, _OutIt>::_Trivially_copyable) {
; 4368 : #ifdef __cpp_lib_is_constant_evaluated
; 4369 :         if (!_STD is_constant_evaluated())
; 4370 : #endif // __cpp_lib_is_constant_evaluated
; 4371 :         {
; 4372 :             return _Copy_memmove(_First, _Last, _Dest);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00@Z ; std::_Copy_memmove<RINGMONSTER_DATA *,RINGMONSTER_DATA *>
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	eb 40		 jmp	 SHORT $LN1@Move_unche

; 4373 :         }
; 4374 :     }
; 4375 : 
; 4376 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

  0001f	eb 12		 jmp	 SHORT $LN4@Move_unche
$LN2@Move_unche:
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	83 c0 0c	 add	 eax, 12			; 0000000cH
  00027	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0002d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00030	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN4@Move_unche:
  00033	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00036	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00039	74 21		 je	 SHORT $LN3@Move_unche

; 4377 :         *_Dest = _STD move(*_First);

  0003b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??$move@AAURINGMONSTER_DATA@@@std@@YA$$QAURINGMONSTER_DATA@@AAU1@@Z ; std::move<RINGMONSTER_DATA &>
  00044	83 c4 04	 add	 esp, 4
  00047	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0004a	8b 10		 mov	 edx, DWORD PTR [eax]
  0004c	89 11		 mov	 DWORD PTR [ecx], edx
  0004e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00051	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00054	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00057	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 4378 :     }

  0005a	eb c5		 jmp	 SHORT $LN2@Move_unche
$LN3@Move_unche:

; 4379 : 
; 4380 :     return _Dest;

  0005c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN1@Move_unche:

; 4381 : }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
??$_Move_unchecked@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00@Z ENDP ; std::_Move_unchecked<RINGMONSTER_DATA *,RINGMONSTER_DATA *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<RINGMONSTER_EVENT_TIME>,std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >,1>::_Compressed_pair<std::allocator<RINGMONSTER_EVENT_TIME>,std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >,1><>, COMDAT
; _this$ = ecx

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAE@XZ ; std::allocator<RINGMONSTER_EVENT_TIME>::allocator<RINGMONSTER_EVENT_TIME>
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<RINGMONSTER_EVENT_TIME>,std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >,1>::_Compressed_pair<std::allocator<RINGMONSTER_EVENT_TIME>,std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z
_TEXT	SEGMENT
__Constructed_first$ = -64				; size = 4
__Constructed_last$ = -60				; size = 4
__Newvec$ = -56						; size = 4
__Newcapacity$ = -52					; size = 4
__Newsize$ = -48					; size = 4
__Oldsize$ = -44					; size = 4
__Whereoff$ = -40					; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
__My_data$ = -28					; size = 4
__Al$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Emplace_reallocate<RINGMONSTER_EVENT_TIME const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 70	 sub	 esp, 112		; 00000070H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Getal@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Getal
  00037	89 45 e8	 mov	 DWORD PTR __Al$[ebp], eax

; 728  :         auto& _My_data    = _Mypair._Myval2;

  0003a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00040	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00043	89 45 e0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  00046	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	83 c0 04	 add	 eax, 4
  0004c	89 45 dc	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0004f	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00055	2b 08		 sub	 ecx, DWORD PTR [eax]
  00057	c1 f9 03	 sar	 ecx, 3
  0005a	89 4d d8	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  0005d	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00060	8b 4d e0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00063	8b 10		 mov	 edx, DWORD PTR [eax]
  00065	2b 11		 sub	 edx, DWORD PTR [ecx]
  00067	c1 fa 03	 sar	 edx, 3
  0006a	89 55 d4	 mov	 DWORD PTR __Oldsize$[ebp], edx

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  0006d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?max_size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::max_size
  00075	39 45 d4	 cmp	 DWORD PTR __Oldsize$[ebp], eax
  00078	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  0007a	e8 00 00 00 00	 call	 ?_Xlength@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@CAXXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0007f	8b 45 d4	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  00082	83 c0 01	 add	 eax, 1
  00085	89 45 d0	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  00088	8b 45 d0	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0008b	50		 push	 eax
  0008c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@ABEII@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Calculate_growth
  00094	89 45 cc	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 743  : 
; 744  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

  00097	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  0009e	e8 00 00 00 00	 call	 ?allocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@I@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::allocate
  000a3	89 45 c8	 mov	 DWORD PTR __Newvec$[ebp], eax

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000a6	8b 45 d8	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  000a9	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ac	8d 54 c1 08	 lea	 edx, DWORD PTR [ecx+eax*8+8]
  000b0	89 55 c4	 mov	 DWORD PTR __Constructed_last$[ebp], edx

; 746  :         pointer _Constructed_first      = _Constructed_last;

  000b3	8b 45 c4	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  000b6	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  000b9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000c0	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 ??$forward@ABURINGMONSTER_EVENT_TIME@@@std@@YAABURINGMONSTER_EVENT_TIME@@ABU1@@Z ; std::forward<RINGMONSTER_EVENT_TIME const &>
  000c9	83 c4 04	 add	 esp, 4
  000cc	50		 push	 eax
  000cd	8b 4d d8	 mov	 ecx, DWORD PTR __Whereoff$[ebp]
  000d0	8b 55 c8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  000d3	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ??$_Unfancy@URINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@@Z ; std::_Unfancy<RINGMONSTER_EVENT_TIME>
  000dc	83 c4 04	 add	 esp, 4
  000df	50		 push	 eax
  000e0	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  000e3	51		 push	 ecx
  000e4	e8 00 00 00 00	 call	 ??$construct@URINGMONSTER_EVENT_TIME@@ABU1@@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@SAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@1@QAURINGMONSTER_EVENT_TIME@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_EVENT_TIME> >::construct<RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME const &>
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  000ec	8b 45 d8	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  000ef	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000f2	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  000f5	89 55 c0	 mov	 DWORD PTR __Constructed_first$[ebp], edx

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000f8	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000fb	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  000fe	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00100	75 1a		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00102	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00105	50		 push	 eax
  00106	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00109	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010b	52		 push	 edx
  0010c	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0010f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00111	51		 push	 ecx
  00112	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	e8 00 00 00 00	 call	 ?_Umove_if_noexcept@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@00@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove_if_noexcept

; 754  :         } else { // provide basic guarantee

  0011a	eb 39		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0011c	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0011f	50		 push	 eax
  00120	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00123	51		 push	 ecx
  00124	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00127	8b 02		 mov	 eax, DWORD PTR [edx]
  00129	50		 push	 eax
  0012a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012d	e8 00 00 00 00	 call	 ?_Umove@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEPAURINGMONSTER_EVENT_TIME@@PAU3@00@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove

; 756  :             _Constructed_first = _Newvec;

  00132	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00135	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00138	8b 45 d8	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0013b	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0013e	8d 54 c1 08	 lea	 edx, DWORD PTR [ecx+eax*8+8]
  00142	52		 push	 edx
  00143	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00146	8b 08		 mov	 ecx, DWORD PTR [eax]
  00148	51		 push	 ecx
  00149	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  0014c	52		 push	 edx
  0014d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00150	e8 00 00 00 00	 call	 ?_Umove@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEPAURINGMONSTER_EVENT_TIME@@PAU3@00@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove
$LN5@Emplace_re:
  00155	eb 2f		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00157	8b 45 c4	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0015a	50		 push	 eax
  0015b	8b 4d c0	 mov	 ecx, DWORD PTR __Constructed_first$[ebp]
  0015e	51		 push	 ecx
  0015f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00162	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00167	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0016a	50		 push	 eax
  0016b	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0016e	51		 push	 ecx
  0016f	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  00172	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXQAURINGMONSTER_EVENT_TIME@@I@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::deallocate

; 762  :         _RERAISE;

  00177	6a 00		 push	 0
  00179	6a 00		 push	 0
  0017b	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00180	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00185	c3		 ret	 0
$LN7@Emplace_re:
  00186	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0018d	eb 07		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z$1
$LN10@Emplace_re:
  0018f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z$1:

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00196	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00199	50		 push	 eax
  0019a	8b 4d d0	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  0019d	51		 push	 ecx
  0019e	8b 55 c8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  001a1	52		 push	 edx
  001a2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a5	e8 00 00 00 00	 call	 ?_Change_array@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXQAURINGMONSTER_EVENT_TIME@@II@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  001aa	8b 45 d8	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001ad	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001b0	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
$LN6@Emplace_re:

; 767  :     }

  001b3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001b6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001bd	59		 pop	 ecx
  001be	5f		 pop	 edi
  001bf	5e		 pop	 esi
  001c0	5b		 pop	 ebx
  001c1	8b e5		 mov	 esp, ebp
  001c3	5d		 pop	 ebp
  001c4	c2 08 00	 ret	 8
  001c7	cc		 int	 3
  001c8	cc		 int	 3
  001c9	cc		 int	 3
  001ca	cc		 int	 3
  001cb	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 7c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-132]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Emplace_reallocate<RINGMONSTER_EVENT_TIME const &>
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@URINGMONSTER_EVENT_TIME@@ABU1@@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@SAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@1@QAURINGMONSTER_EVENT_TIME@@ABU3@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@URINGMONSTER_EVENT_TIME@@ABU1@@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@SAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@1@QAURINGMONSTER_EVENT_TIME@@ABU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_EVENT_TIME> >::construct<RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME const &>, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	50		 push	 eax
  0000d	6a 08		 push	 8
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00014	83 c4 08	 add	 esp, 8
  00017	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ??$forward@ABURINGMONSTER_EVENT_TIME@@@std@@YAABURINGMONSTER_EVENT_TIME@@ABU1@@Z ; std::forward<RINGMONSTER_EVENT_TIME const &>
  00023	83 c4 04	 add	 esp, 4
  00026	8b 10		 mov	 edx, DWORD PTR [eax]
  00028	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002b	8b 4d bc	 mov	 ecx, DWORD PTR $T1[ebp]
  0002e	89 11		 mov	 DWORD PTR [ecx], edx
  00030	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 695  :     }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$construct@URINGMONSTER_EVENT_TIME@@ABU1@@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@SAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@1@QAURINGMONSTER_EVENT_TIME@@ABU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_EVENT_TIME> >::construct<RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$_Unfancy@URINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@URINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@@Z PROC ; std::_Unfancy<RINGMONSTER_EVENT_TIME>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 289  :     return _Ptr;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Unfancy@URINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@@Z ENDP ; std::_Unfancy<RINGMONSTER_EVENT_TIME>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAE@ABURINGMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAE@ABURINGMONSTER_EVENT_TIME@@@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Emplace_back_with_unused_capacity<RINGMONSTER_EVENT_TIME const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 686  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$forward@ABURINGMONSTER_EVENT_TIME@@@std@@YAABURINGMONSTER_EVENT_TIME@@ABU1@@Z ; std::forward<RINGMONSTER_EVENT_TIME const &>
  00024	83 c4 04	 add	 esp, 4
  00027	50		 push	 eax
  00028	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ??$_Unfancy@URINGMONSTER_EVENT_TIME@@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@@Z ; std::_Unfancy<RINGMONSTER_EVENT_TIME>
  00033	83 c4 04	 add	 esp, 4
  00036	50		 push	 eax
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Getal@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Getal
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$construct@URINGMONSTER_EVENT_TIME@@ABU1@@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@SAXAAV?$allocator@URINGMONSTER_EVENT_TIME@@@1@QAURINGMONSTER_EVENT_TIME@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_EVENT_TIME> >::construct<RINGMONSTER_EVENT_TIME,RINGMONSTER_EVENT_TIME const &>
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 688  :         _Orphan_range(_Mylast, _Mylast);

  00048	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	51		 push	 ecx
  0004e	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	50		 push	 eax
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@ABEXPAURINGMONSTER_EVENT_TIME@@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Orphan_range

; 689  :         _Ty& _Result = *_Mylast;

  0005c	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	89 4d f0	 mov	 DWORD PTR __Result$[ebp], ecx

; 690  :         ++_Mylast;

  00064	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	83 c1 08	 add	 ecx, 8
  0006c	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0006f	89 0a		 mov	 DWORD PTR [edx], ecx

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAE@ABURINGMONSTER_EVENT_TIME@@@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Emplace_back_with_unused_capacity<RINGMONSTER_EVENT_TIME const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABURINGMONSTER_EVENT_TIME@@@std@@YAABURINGMONSTER_EVENT_TIME@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABURINGMONSTER_EVENT_TIME@@@std@@YAABURINGMONSTER_EVENT_TIME@@ABU1@@Z PROC ; std::forward<RINGMONSTER_EVENT_TIME const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABURINGMONSTER_EVENT_TIME@@@std@@YAABURINGMONSTER_EVENT_TIME@@ABU1@@Z ENDP ; std::forward<RINGMONSTER_EVENT_TIME const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$emplace_back@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@ABURINGMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@ABURINGMONSTER_EVENT_TIME@@@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::emplace_back<RINGMONSTER_EVENT_TIME const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001e	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00021	8b 10		 mov	 edx, DWORD PTR [eax]
  00023	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00026	74 17		 je	 SHORT $LN2@emplace_ba

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00028	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$forward@ABURINGMONSTER_EVENT_TIME@@@std@@YAABURINGMONSTER_EVENT_TIME@@ABU1@@Z ; std::forward<RINGMONSTER_EVENT_TIME const &>
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAE@ABURINGMONSTER_EVENT_TIME@@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Emplace_back_with_unused_capacity<RINGMONSTER_EVENT_TIME const &>
  0003d	eb 1e		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$forward@ABURINGMONSTER_EVENT_TIME@@@std@@YAABURINGMONSTER_EVENT_TIME@@ABU1@@Z ; std::forward<RINGMONSTER_EVENT_TIME const &>
  00048	83 c4 04	 add	 esp, 4
  0004b	50		 push	 eax
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	52		 push	 edx
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@QAU2@ABU2@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Emplace_reallocate<RINGMONSTER_EVENT_TIME const &>
  0005a	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
??$emplace_back@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@ABURINGMONSTER_EVENT_TIME@@@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::emplace_back<RINGMONSTER_EVENT_TIME const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Move_unchecked@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_unchecked@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00@Z PROC ; std::_Move_unchecked<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>, COMDAT

; 4364 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4365 :     // move [_First, _Last) to [_Dest, ...)
; 4366 :     // note: _Move_unchecked has callers other than the move family
; 4367 :     if constexpr (_Ptr_move_cat<_InIt, _OutIt>::_Trivially_copyable) {
; 4368 : #ifdef __cpp_lib_is_constant_evaluated
; 4369 :         if (!_STD is_constant_evaluated())
; 4370 : #endif // __cpp_lib_is_constant_evaluated
; 4371 :         {
; 4372 :             return _Copy_memmove(_First, _Last, _Dest);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00@Z ; std::_Copy_memmove<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	eb 3a		 jmp	 SHORT $LN1@Move_unche

; 4373 :         }
; 4374 :     }
; 4375 : 
; 4376 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

  0001f	eb 12		 jmp	 SHORT $LN4@Move_unche
$LN2@Move_unche:
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	83 c0 08	 add	 eax, 8
  00027	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0002d	83 c1 08	 add	 ecx, 8
  00030	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$LN4@Move_unche:
  00033	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00036	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00039	74 1b		 je	 SHORT $LN3@Move_unche

; 4377 :         *_Dest = _STD move(*_First);

  0003b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??$move@AAURINGMONSTER_EVENT_TIME@@@std@@YA$$QAURINGMONSTER_EVENT_TIME@@AAU1@@Z ; std::move<RINGMONSTER_EVENT_TIME &>
  00044	83 c4 04	 add	 esp, 4
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0004f	89 08		 mov	 DWORD PTR [eax], ecx
  00051	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 4378 :     }

  00054	eb cb		 jmp	 SHORT $LN2@Move_unche
$LN3@Move_unche:

; 4379 : 
; 4380 :     return _Dest;

  00056	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN1@Move_unche:

; 4381 : }

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
??$_Move_unchecked@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00@Z ENDP ; std::_Move_unchecked<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 264  :     _Vector_iterator operator++(int) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 265  :         _Vector_iterator _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 266  :         _Mybase::operator++();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator++

; 267  :         return _Tmp;

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 268  :     }

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAURINGMONSTER_EVENT_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAURINGMONSTER_EVENT_TIME@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 251  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 252  :         return const_cast<reference>(_Mybase::operator*());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEABURINGMONSTER_EVENT_TIME@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator*

; 253  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAURINGMONSTER_EVENT_TIME@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::_Compat, COMDAT
; _this$ = ecx

; 173  :     void _Compat(const _Vector_const_iterator& _Right) const { // test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 174  : #if _ITERATOR_DEBUG_LEVEL == 0
; 175  :         (void) _Right;
; 176  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 177  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 178  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 179  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator!=, COMDAT
; _this$ = ecx

; 152  :     _NODISCARD bool operator!=(const _Vector_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  :         return !(*this == _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator==
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 09		 jne	 SHORT $LN3@operator
  0001f	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00028	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002f	8a 45 b8	 mov	 al, BYTE PTR tv69[ebp]

; 154  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator==, COMDAT
; _this$ = ecx

; 147  :     _NODISCARD bool operator==(const _Vector_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 148  :         _Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::_Compat

; 149  :         return _Ptr == _Right._Ptr;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00022	75 09		 jne	 SHORT $LN3@operator
  00024	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  0002b	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002d	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00034	8a 45 b8	 mov	 al, BYTE PTR tv69[ebp]

; 150  :     }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator++, COMDAT
; _this$ = ecx

; 68   :     _Vector_const_iterator& operator++() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 69   : #if _ITERATOR_DEBUG_LEVEL != 0
; 70   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 71   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 72   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 73   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 74   : 
; 75   :         ++_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 08	 add	 ecx, 8
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 76   :         return *this;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 77   :     }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEABURINGMONSTER_EVENT_TIME@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEABURINGMONSTER_EVENT_TIME@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator*, COMDAT
; _this$ = ecx

; 46   :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 47   : #if _ITERATOR_DEBUG_LEVEL != 0
; 48   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 49   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 50   :         _STL_VERIFY(
; 51   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 52   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 53   : 
; 54   :         return *_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 55   :     }

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEABURINGMONSTER_EVENT_TIME@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >, COMDAT
; _this$ = ecx

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 43   :         this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 44   :     }

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator++, COMDAT
; _this$ = ecx

; 264  :     _Vector_iterator operator++(int) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 265  :         _Vector_iterator _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 266  :         _Mybase::operator++();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator++

; 267  :         return _Tmp;

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 268  :     }

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEAAURINGMONSTER_DATA@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEAAURINGMONSTER_DATA@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator*, COMDAT
; _this$ = ecx

; 251  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 252  :         return const_cast<reference>(_Mybase::operator*());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEABURINGMONSTER_DATA@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator*

; 253  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEAAURINGMONSTER_DATA@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::_Compat, COMDAT
; _this$ = ecx

; 173  :     void _Compat(const _Vector_const_iterator& _Right) const { // test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 174  : #if _ITERATOR_DEBUG_LEVEL == 0
; 175  :         (void) _Right;
; 176  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 177  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 178  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 179  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator!=, COMDAT
; _this$ = ecx

; 152  :     _NODISCARD bool operator!=(const _Vector_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  :         return !(*this == _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator==
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 09		 jne	 SHORT $LN3@operator
  0001f	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00028	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002f	8a 45 b8	 mov	 al, BYTE PTR tv69[ebp]

; 154  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator==, COMDAT
; _this$ = ecx

; 147  :     _NODISCARD bool operator==(const _Vector_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 148  :         _Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::_Compat

; 149  :         return _Ptr == _Right._Ptr;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00022	75 09		 jne	 SHORT $LN3@operator
  00024	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  0002b	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002d	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00034	8a 45 b8	 mov	 al, BYTE PTR tv69[ebp]

; 150  :     }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator++, COMDAT
; _this$ = ecx

; 68   :     _Vector_const_iterator& operator++() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 69   : #if _ITERATOR_DEBUG_LEVEL != 0
; 70   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 71   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 72   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 73   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 74   : 
; 75   :         ++_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 76   :         return *this;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 77   :     }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEABURINGMONSTER_DATA@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEABURINGMONSTER_DATA@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator*, COMDAT
; _this$ = ecx

; 46   :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 47   : #if _ITERATOR_DEBUG_LEVEL != 0
; 48   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 49   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 50   :         _STL_VERIFY(
; 51   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 52   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 53   : 
; 54   :         return *_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 55   :     }

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEABURINGMONSTER_DATA@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >, COMDAT
; _this$ = ecx

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 43   :         this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 44   :     }

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Include\ReadScript.h
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
tv93 = -184						; size = 4
$T1 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 26   : 	unsigned char ch;
; 27   : 	TokenString[0] = '\0';

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	6b c8 00	 imul	 ecx, eax, 0
  0001e	89 8d 4c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00024	83 bd 4c ff ff
	ff 64		 cmp	 DWORD PTR $T1[ebp], 100	; 00000064H
  0002b	73 02		 jae	 SHORT $LN31@GetToken
  0002d	eb 05		 jmp	 SHORT $LN32@GetToken
$LN31@GetToken:
  0002f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN32@GetToken:
  00034	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0003a	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?TokenString@@3PADA[edx], 0
$LN4@GetToken:

; 28   : 	do
; 29   : 	{
; 30   : 		if ( (ch =(unsigned char) fgetc(SMDFile)) == (BYTE)EOF) return END;

  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _fgetc
  0004c	83 c4 04	 add	 esp, 4
  0004f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00052	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00056	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0005c	75 0a		 jne	 SHORT $LN15@GetToken
  0005e	b8 02 00 00 00	 mov	 eax, 2
  00063	e9 d9 02 00 00	 jmp	 $LN7@GetToken
$LN15@GetToken:

; 31   : 		if (ch=='/' && (ch =(unsigned char) fgetc(SMDFile) )=='/')	

  00068	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0006c	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0006f	75 56		 jne	 SHORT $LN17@GetToken
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _fgetc
  0007c	83 c4 04	 add	 esp, 4
  0007f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00082	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00086	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00089	75 3c		 jne	 SHORT $LN17@GetToken
$LN5@GetToken:

; 32   : 		{
; 33   : 			while((ch != '\n') && (ch != (BYTE)EOF)) {			// 2003.09.02 H.J.I 

  0008b	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0008f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00092	74 1e		 je	 SHORT $LN6@GetToken
  00094	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00098	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0009d	74 13		 je	 SHORT $LN6@GetToken

; 34   : 				ch = (unsigned char) fgetc( SMDFile);

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _fgetc
  000aa	83 c4 04	 add	 esp, 4
  000ad	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 35   : 			}

  000b0	eb d9		 jmp	 SHORT $LN5@GetToken
$LN6@GetToken:

; 36   : 
; 37   : 			if (ch == (BYTE)EOF)

  000b2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000b6	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000bb	75 0a		 jne	 SHORT $LN17@GetToken

; 38   : 				return END;

  000bd	b8 02 00 00 00	 mov	 eax, 2
  000c2	e9 7a 02 00 00	 jmp	 $LN7@GetToken
$LN17@GetToken:

; 39   : 		}
; 40   : 	} while(  isspace(ch) );

  000c7	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _isspace
  000d1	83 c4 04	 add	 esp, 4
  000d4	85 c0		 test	 eax, eax
  000d6	0f 85 65 ff ff
	ff		 jne	 $LN4@GetToken

; 41   : 	
; 42   : 	char *p, TempString[100];
; 43   : 	switch(ch)

  000dc	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000e0	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], eax
  000e6	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv93[ebp]
  000ec	83 e9 22	 sub	 ecx, 34			; 00000022H
  000ef	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], ecx
  000f5	83 bd 48 ff ff
	ff 5b		 cmp	 DWORD PTR tv93[ebp], 91	; 0000005bH
  000fc	0f 87 86 01 00
	00		 ja	 $LN27@GetToken
  00102	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv93[ebp]
  00108	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN33@GetToken[edx]
  0010f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN34@GetToken[eax*4]
$LN18@GetToken:

; 44   : 	{	
; 45   : 	case '#':
; 46   : 		return CurrentToken = COMMAND;

  00116	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 35 ; 00000023H
  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00125	e9 17 02 00 00	 jmp	 $LN7@GetToken
$LN19@GetToken:

; 47   : 	case ';':
; 48   : 		return CurrentToken = SEMICOLON;

  0012a	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 59 ; 0000003bH
  00134	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00139	e9 03 02 00 00	 jmp	 $LN7@GetToken
$LN20@GetToken:

; 49   : 	case ',':
; 50   : 		return CurrentToken = COMMA;

  0013e	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 44 ; 0000002cH
  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0014d	e9 ef 01 00 00	 jmp	 $LN7@GetToken
$LN21@GetToken:

; 51   : 	case '{':
; 52   : 		return CurrentToken = LP;

  00152	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 123 ; 0000007bH
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00161	e9 db 01 00 00	 jmp	 $LN7@GetToken
$LN22@GetToken:

; 53   : 	case '}':
; 54   : 		return CurrentToken = RP;

  00166	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 125 ; 0000007dH
  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00175	e9 c7 01 00 00	 jmp	 $LN7@GetToken
$LN23@GetToken:

; 55   : 	case '0':	case '1':	case '2':	case '3':	case '4':
; 56   : 	case '5':	case '6':	case '7':	case '8':	case '9':
; 57   : 	case '.':	case '-':
; 58   : 		ungetc(ch,SMDFile);

  0017a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0017f	50		 push	 eax
  00180	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 _ungetc
  0018a	83 c4 08	 add	 esp, 8

; 59   : 		p = TempString;

  0018d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00190	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN9@GetToken:

; 60   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || isdigit(ch) || ch=='-') )

  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _getc
  0019e	83 c4 04	 add	 esp, 4
  001a1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  001a4	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  001a8	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  001ae	74 36		 je	 SHORT $LN10@GetToken
  001b0	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001b4	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001b7	74 1a		 je	 SHORT $LN24@GetToken
  001b9	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001bd	50		 push	 eax
  001be	e8 00 00 00 00	 call	 _isdigit
  001c3	83 c4 04	 add	 esp, 4
  001c6	85 c0		 test	 eax, eax
  001c8	75 09		 jne	 SHORT $LN24@GetToken
  001ca	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001ce	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  001d1	75 13		 jne	 SHORT $LN10@GetToken
$LN24@GetToken:

; 61   : 			*p++ = ch;

  001d3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001d6	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  001d9	88 08		 mov	 BYTE PTR [eax], cl
  001db	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  001de	83 c2 01	 add	 edx, 1
  001e1	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  001e4	eb ad		 jmp	 SHORT $LN9@GetToken
$LN10@GetToken:

; 62   : 		*p = 0;

  001e6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001e9	c6 00 00	 mov	 BYTE PTR [eax], 0

; 63   : 		TokenNumber = (float)atof(TempString);

  001ec	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _atof
  001f5	83 c4 04	 add	 esp, 4
  001f8	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?TokenNumber@@3MA

; 64   : 		//			sscanf(TempString," %f ",&TokenNumber);
; 65   : 		return CurrentToken = NUMBER;

  001fe	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 1
  00208	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0020d	e9 2f 01 00 00	 jmp	 $LN7@GetToken
$LN25@GetToken:

; 66   : 	case '"':
; 67   : 		p = TokenString;

  00212	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA
$LN11@GetToken:

; 68   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch!='"'))// || isalnum(ch)) )

  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _getc
  00224	83 c4 04	 add	 esp, 4
  00227	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0022a	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  0022e	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00234	74 1c		 je	 SHORT $LN12@GetToken
  00236	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0023a	83 f8 22	 cmp	 eax, 34			; 00000022H
  0023d	74 13		 je	 SHORT $LN12@GetToken

; 69   : 			*p++ = ch;

  0023f	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00242	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00245	88 08		 mov	 BYTE PTR [eax], cl
  00247	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  0024a	83 c2 01	 add	 edx, 1
  0024d	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00250	eb c7		 jmp	 SHORT $LN11@GetToken
$LN12@GetToken:

; 70   : 		if (ch!='"')

  00252	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00256	83 f8 22	 cmp	 eax, 34			; 00000022H
  00259	74 13		 je	 SHORT $LN26@GetToken

; 71   : 			ungetc(ch,SMDFile);

  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00260	50		 push	 eax
  00261	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00265	51		 push	 ecx
  00266	e8 00 00 00 00	 call	 _ungetc
  0026b	83 c4 08	 add	 esp, 8
$LN26@GetToken:

; 72   : 		*p = 0;

  0026e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00271	c6 00 00	 mov	 BYTE PTR [eax], 0

; 73   : 		return CurrentToken = NAME;

  00274	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0027e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00283	e9 b9 00 00 00	 jmp	 $LN7@GetToken
$LN27@GetToken:

; 74   : 	default:
; 75   : 		if (isalpha(ch))	

  00288	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0028c	50		 push	 eax
  0028d	e8 00 00 00 00	 call	 _isalpha
  00292	83 c4 04	 add	 esp, 4
  00295	85 c0		 test	 eax, eax
  00297	0f 84 95 00 00
	00		 je	 $LN28@GetToken

; 76   : 		{
; 77   : 			p = TokenString;

  0029d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA

; 78   : 			*p++ = ch;

  002a4	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002a7	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002aa	88 08		 mov	 BYTE PTR [eax], cl
  002ac	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  002af	83 c2 01	 add	 edx, 1
  002b2	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
$LN13@GetToken:

; 79   : 			while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || ch=='_' || isalnum(ch)) )

  002b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  002ba	50		 push	 eax
  002bb	e8 00 00 00 00	 call	 _getc
  002c0	83 c4 04	 add	 esp, 4
  002c3	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  002c6	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  002ca	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  002d0	74 36		 je	 SHORT $LN14@GetToken
  002d2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002d6	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  002d9	74 1a		 je	 SHORT $LN29@GetToken
  002db	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002df	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  002e2	74 11		 je	 SHORT $LN29@GetToken
  002e4	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 _isalnum
  002ee	83 c4 04	 add	 esp, 4
  002f1	85 c0		 test	 eax, eax
  002f3	74 13		 je	 SHORT $LN14@GetToken
$LN29@GetToken:

; 80   : 				*p++ = ch;

  002f5	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002f8	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002fb	88 08		 mov	 BYTE PTR [eax], cl
  002fd	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00300	83 c2 01	 add	 edx, 1
  00303	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00306	eb ad		 jmp	 SHORT $LN13@GetToken
$LN14@GetToken:

; 81   : 			ungetc(ch,SMDFile);

  00308	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0030d	50		 push	 eax
  0030e	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00312	51		 push	 ecx
  00313	e8 00 00 00 00	 call	 _ungetc
  00318	83 c4 08	 add	 esp, 8

; 82   : 			*p = 0;

  0031b	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0031e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 83   : 			return CurrentToken = NAME;

  00321	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0032b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00330	eb 0f		 jmp	 SHORT $LN7@GetToken
$LN28@GetToken:

; 84   : 		}
; 85   : 		return CurrentToken = SMD_ERROR;

  00332	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 60 ; 0000003cH
  0033c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
$LN7@GetToken:

; 86   : 	}
; 87   : }

  00341	5f		 pop	 edi
  00342	5e		 pop	 esi
  00343	5b		 pop	 ebx
  00344	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00347	33 cd		 xor	 ecx, ebp
  00349	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034e	8b e5		 mov	 esp, ebp
  00350	5d		 pop	 ebp
  00351	c3		 ret	 0
  00352	66 90		 npad	 2
$LN34@GetToken:
  00354	00 00 00 00	 DD	 $LN25@GetToken
  00358	00 00 00 00	 DD	 $LN18@GetToken
  0035c	00 00 00 00	 DD	 $LN20@GetToken
  00360	00 00 00 00	 DD	 $LN23@GetToken
  00364	00 00 00 00	 DD	 $LN19@GetToken
  00368	00 00 00 00	 DD	 $LN21@GetToken
  0036c	00 00 00 00	 DD	 $LN22@GetToken
  00370	00 00 00 00	 DD	 $LN27@GetToken
$LN33@GetToken:
  00374	00		 DB	 0
  00375	01		 DB	 1
  00376	07		 DB	 7
  00377	07		 DB	 7
  00378	07		 DB	 7
  00379	07		 DB	 7
  0037a	07		 DB	 7
  0037b	07		 DB	 7
  0037c	07		 DB	 7
  0037d	07		 DB	 7
  0037e	02		 DB	 2
  0037f	03		 DB	 3
  00380	03		 DB	 3
  00381	07		 DB	 7
  00382	03		 DB	 3
  00383	03		 DB	 3
  00384	03		 DB	 3
  00385	03		 DB	 3
  00386	03		 DB	 3
  00387	03		 DB	 3
  00388	03		 DB	 3
  00389	03		 DB	 3
  0038a	03		 DB	 3
  0038b	03		 DB	 3
  0038c	07		 DB	 7
  0038d	04		 DB	 4
  0038e	07		 DB	 7
  0038f	07		 DB	 7
  00390	07		 DB	 7
  00391	07		 DB	 7
  00392	07		 DB	 7
  00393	07		 DB	 7
  00394	07		 DB	 7
  00395	07		 DB	 7
  00396	07		 DB	 7
  00397	07		 DB	 7
  00398	07		 DB	 7
  00399	07		 DB	 7
  0039a	07		 DB	 7
  0039b	07		 DB	 7
  0039c	07		 DB	 7
  0039d	07		 DB	 7
  0039e	07		 DB	 7
  0039f	07		 DB	 7
  003a0	07		 DB	 7
  003a1	07		 DB	 7
  003a2	07		 DB	 7
  003a3	07		 DB	 7
  003a4	07		 DB	 7
  003a5	07		 DB	 7
  003a6	07		 DB	 7
  003a7	07		 DB	 7
  003a8	07		 DB	 7
  003a9	07		 DB	 7
  003aa	07		 DB	 7
  003ab	07		 DB	 7
  003ac	07		 DB	 7
  003ad	07		 DB	 7
  003ae	07		 DB	 7
  003af	07		 DB	 7
  003b0	07		 DB	 7
  003b1	07		 DB	 7
  003b2	07		 DB	 7
  003b3	07		 DB	 7
  003b4	07		 DB	 7
  003b5	07		 DB	 7
  003b6	07		 DB	 7
  003b7	07		 DB	 7
  003b8	07		 DB	 7
  003b9	07		 DB	 7
  003ba	07		 DB	 7
  003bb	07		 DB	 7
  003bc	07		 DB	 7
  003bd	07		 DB	 7
  003be	07		 DB	 7
  003bf	07		 DB	 7
  003c0	07		 DB	 7
  003c1	07		 DB	 7
  003c2	07		 DB	 7
  003c3	07		 DB	 7
  003c4	07		 DB	 7
  003c5	07		 DB	 7
  003c6	07		 DB	 7
  003c7	07		 DB	 7
  003c8	07		 DB	 7
  003c9	07		 DB	 7
  003ca	07		 DB	 7
  003cb	07		 DB	 7
  003cc	07		 DB	 7
  003cd	05		 DB	 5
  003ce	07		 DB	 7
  003cf	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCRingAttackEvent@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCRingAttackEvent@@UAEPAXI@Z PROC			; CRingAttackEvent::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CRingAttackEvent@@UAE@XZ ; CRingAttackEvent::~CRingAttackEvent
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 11		 je	 SHORT $LN2@scalar
  0001c	68 38 01 00 00	 push	 312			; 00000138H
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??_GCRingAttackEvent@@UAEPAXI@Z ENDP			; CRingAttackEvent::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?End_Menual@CRingAttackEvent@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?End_Menual@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::End_Menual, COMDAT
; _this$ = ecx

; 861  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 862  : 	SetMenualStart(FALSE);

  0000c	6a 00		 push	 0
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?SetMenualStart@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetMenualStart

; 863  : }

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?End_Menual@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::End_Menual
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?Start_Menual@CRingAttackEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$ = -272						; size = 6
_szTemp$ = -264						; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?Start_Menual@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::Start_Menual, COMDAT
; _this$ = ecx

; 836  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 837  : 	SetMenualStart(TRUE);

  00019	6a 01		 push	 1
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?SetMenualStart@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetMenualStart

; 838  : 
; 839  : 	StopEvent ();

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?StopEvent@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::StopEvent

; 840  : 
; 841  : 	LogAddTD("[Event Management] [Start] RingAttack Event!");

  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@PHNKOJF@?$KB?$NL?$KB?$NM?$FLEvent?5Management?$FN?5?$FLStart?$FN?5@
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00036	83 c4 04	 add	 esp, 4

; 842  : 	
; 843  : 	m_iTIME_MIN_PLAY	= 30;	//   

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c7 80 e4 00 00
	00 1e 00 00 00	 mov	 DWORD PTR [eax+228], 30	; 0000001eH

; 844  : 
; 845  : 	CHAR szTemp[256];
; 846  : 	wsprintf(szTemp, lMsg.Get(1208));		// "         ."

  00046	68 b8 04 00 00	 push	 1208			; 000004b8H
  0004b	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00056	50		 push	 eax
  00057	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0005d	50		 push	 eax
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00064	83 c4 08	 add	 esp, 8

; 847  : 	AllSendServerMsg (szTemp);

  00067	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00073	83 c4 04	 add	 esp, 4

; 848  : 
; 849  : 	PMSG_ANS_CL_EFFECT pMsg;
; 850  : 	PHeadSetB((LPBYTE)&pMsg, 0x9E, sizeof(pMsg));

  00076	6a 06		 push	 6
  00078	68 9e 00 00 00	 push	 158			; 0000009eH
  0007d	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH

; 851  : 	pMsg.wEffectNum = 1;		//     

  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	66 89 85 f4 fe
	ff ff		 mov	 WORD PTR _pMsg$[ebp+4], ax

; 852  : 	DataSendAll ((LPBYTE)&pMsg, pMsg.h.size);

  00098	0f b6 85 f1 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0009f	50		 push	 eax
  000a0	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 ?DataSendAll@@YAXPAEH@Z	; DataSendAll
  000ac	83 c4 08	 add	 esp, 8

; 853  : 
; 854  : 	SetState (RINGEVENT_STATE_PLAYING);

  000af	6a 02		 push	 2
  000b1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState

; 855  : 
; 856  : 	
; 857  : }

  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	5b		 pop	 ebx
  000bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bf	33 cd		 xor	 ecx, ebp
  000c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
?Start_Menual@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::Start_Menual
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.h
;	COMDAT ?SetMenualStart@CRingAttackEvent@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bMenualStart$ = 8					; size = 4
?SetMenualStart@CRingAttackEvent@@QAEXH@Z PROC		; CRingAttackEvent::SetMenualStart, COMDAT
; _this$ = ecx

; 181  : 	void	SetMenualStart		(BOOL bMenualStart)	{	m_bMenualStart = bMenualStart;	}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _bMenualStart$[ebp]
  00012	89 88 34 01 00
	00		 mov	 DWORD PTR [eax+308], ecx
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?SetMenualStart@CRingAttackEvent@@QAEXH@Z ENDP		; CRingAttackEvent::SetMenualStart
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?Move@CRingAttackEvent@@QAEXXZ
_TEXT	SEGMENT
tv89 = -92						; size = 4
_iRADIUS$1 = -24					; size = 4
_iDIVIDE$2 = -20					; size = 4
_iCount$3 = -16						; size = 4
_i$4 = -12						; size = 4
_iCY$5 = -8						; size = 1
_iCX$6 = -7						; size = 1
_iRandY$7 = -6						; size = 1
_iRandX$8 = -5						; size = 1
_this$ = -4						; size = 4
?Move@CRingAttackEvent@@QAEXXZ PROC			; CRingAttackEvent::Move, COMDAT
; _this$ = ecx

; 763  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 764  : 	if (m_bDoEvent) {

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 b8 d0 00 00
	00 00		 cmp	 DWORD PTR [eax+208], 0
  00016	0f 84 4c 02 00
	00		 je	 $LN1@Move

; 765  : 		if (m_bMonsterToDest)		//        .

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 b8 d8 00 00
	00 00		 cmp	 DWORD PTR [eax+216], 0
  00026	74 05		 je	 SHORT $LN8@Move

; 766  : 			return;

  00028	e9 3b 02 00 00	 jmp	 $LN1@Move
$LN8@Move:

; 767  : 
; 768  : 		UCHAR iRandX, iRandY;
; 769  : 		UCHAR iCX, iCY;
; 770  : 
; 771  : 		for (INT i = 0 ; i < RINGEVENT_MAX_MAP ; i++ ) {

  0002d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$4[ebp], 0
  00034	eb 09		 jmp	 SHORT $LN4@Move
$LN2@Move:
  00036	8b 45 f4	 mov	 eax, DWORD PTR _i$4[ebp]
  00039	83 c0 01	 add	 eax, 1
  0003c	89 45 f4	 mov	 DWORD PTR _i$4[ebp], eax
$LN4@Move:
  0003f	83 7d f4 03	 cmp	 DWORD PTR _i$4[ebp], 3
  00043	0f 8d 1f 02 00
	00		 jge	 $LN1@Move

; 772  : 			INT iCount = 1000;

  00049	c7 45 f0 e8 03
	00 00		 mov	 DWORD PTR _iCount$3[ebp], 1000 ; 000003e8H

; 773  : 
; 774  : 			if (!m_RingMonsterHerd[i].GetCurrentLocation(iCX, iCY))

  00050	8d 45 f8	 lea	 eax, DWORD PTR _iCY$5[ebp]
  00053	50		 push	 eax
  00054	8d 4d f9	 lea	 ecx, DWORD PTR _iCX$6[ebp]
  00057	51		 push	 ecx
  00058	6b 55 f4 44	 imul	 edx, DWORD PTR _i$4[ebp], 68
  0005c	6b 45 f4 44	 imul	 eax, DWORD PTR _i$4[ebp], 68
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	8d 4c 01 04	 lea	 ecx, DWORD PTR [ecx+eax+4]
  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 54 10 04	 mov	 edx, DWORD PTR [eax+edx+4]
  0006e	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00071	ff d0		 call	 eax
  00073	85 c0		 test	 eax, eax
  00075	75 05		 jne	 SHORT $LN5@Move

; 775  : 				break;

  00077	e9 ec 01 00 00	 jmp	 $LN1@Move
$LN5@Move:

; 776  : 
; 777  : 			while (iCount--) {

  0007c	8b 45 f0	 mov	 eax, DWORD PTR _iCount$3[ebp]
  0007f	89 45 a4	 mov	 DWORD PTR tv89[ebp], eax
  00082	8b 4d f0	 mov	 ecx, DWORD PTR _iCount$3[ebp]
  00085	83 e9 01	 sub	 ecx, 1
  00088	89 4d f0	 mov	 DWORD PTR _iCount$3[ebp], ecx
  0008b	83 7d a4 00	 cmp	 DWORD PTR tv89[ebp], 0
  0008f	0f 84 03 01 00
	00		 je	 $LN6@Move

; 778  : 				iRandX = rand()%m_iMOVE_RAND_SIZE * (-1*(rand()%3 -1)) + iCX;

  00095	e8 00 00 00 00	 call	 _rand
  0009a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	99		 cdq
  0009e	f7 b9 f8 00 00
	00		 idiv	 DWORD PTR [ecx+248]
  000a4	8b da		 mov	 ebx, edx
  000a6	e8 00 00 00 00	 call	 _rand
  000ab	99		 cdq
  000ac	b9 03 00 00 00	 mov	 ecx, 3
  000b1	f7 f9		 idiv	 ecx
  000b3	83 ea 01	 sub	 edx, 1
  000b6	6b d2 ff	 imul	 edx, edx, -1
  000b9	0f af da	 imul	 ebx, edx
  000bc	0f b6 45 f9	 movzx	 eax, BYTE PTR _iCX$6[ebp]
  000c0	03 d8		 add	 ebx, eax
  000c2	88 5d fb	 mov	 BYTE PTR _iRandX$8[ebp], bl

; 779  : 				iRandY = rand()%m_iMOVE_RAND_SIZE * (-1*(rand()%3 -1)) + iCY;

  000c5	e8 00 00 00 00	 call	 _rand
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cd	99		 cdq
  000ce	f7 b9 f8 00 00
	00		 idiv	 DWORD PTR [ecx+248]
  000d4	8b da		 mov	 ebx, edx
  000d6	e8 00 00 00 00	 call	 _rand
  000db	99		 cdq
  000dc	b9 03 00 00 00	 mov	 ecx, 3
  000e1	f7 f9		 idiv	 ecx
  000e3	83 ea 01	 sub	 edx, 1
  000e6	6b d2 ff	 imul	 edx, edx, -1
  000e9	0f af da	 imul	 ebx, edx
  000ec	0f b6 45 f8	 movzx	 eax, BYTE PTR _iCY$5[ebp]
  000f0	03 d8		 add	 ebx, eax
  000f2	88 5d fa	 mov	 BYTE PTR _iRandY$7[ebp], bl

; 780  : 
; 781  : 				if (iRandX < g_RingMapPosition[i][0] || iRandX > g_RingMapPosition[i][2])

  000f5	0f b6 45 fb	 movzx	 eax, BYTE PTR _iRandX$8[ebp]
  000f9	8b 4d f4	 mov	 ecx, DWORD PTR _i$4[ebp]
  000fc	c1 e1 04	 shl	 ecx, 4
  000ff	ba 04 00 00 00	 mov	 edx, 4
  00104	6b d2 00	 imul	 edx, edx, 0
  00107	3b 84 11 00 00
	00 00		 cmp	 eax, DWORD PTR ?g_RingMapPosition@@3PAY03HA[ecx+edx]
  0010e	7c 1a		 jl	 SHORT $LN11@Move
  00110	0f b6 45 fb	 movzx	 eax, BYTE PTR _iRandX$8[ebp]
  00114	8b 4d f4	 mov	 ecx, DWORD PTR _i$4[ebp]
  00117	c1 e1 04	 shl	 ecx, 4
  0011a	ba 04 00 00 00	 mov	 edx, 4
  0011f	d1 e2		 shl	 edx, 1
  00121	3b 84 11 00 00
	00 00		 cmp	 eax, DWORD PTR ?g_RingMapPosition@@3PAY03HA[ecx+edx]
  00128	7e 05		 jle	 SHORT $LN10@Move
$LN11@Move:

; 782  : 					continue;

  0012a	e9 4d ff ff ff	 jmp	 $LN5@Move
$LN10@Move:

; 783  : 				if (iRandY < g_RingMapPosition[i][1] || iRandY > g_RingMapPosition[i][3])

  0012f	0f b6 45 fa	 movzx	 eax, BYTE PTR _iRandY$7[ebp]
  00133	8b 4d f4	 mov	 ecx, DWORD PTR _i$4[ebp]
  00136	c1 e1 04	 shl	 ecx, 4
  00139	ba 04 00 00 00	 mov	 edx, 4
  0013e	c1 e2 00	 shl	 edx, 0
  00141	3b 84 11 00 00
	00 00		 cmp	 eax, DWORD PTR ?g_RingMapPosition@@3PAY03HA[ecx+edx]
  00148	7c 1b		 jl	 SHORT $LN13@Move
  0014a	0f b6 45 fa	 movzx	 eax, BYTE PTR _iRandY$7[ebp]
  0014e	8b 4d f4	 mov	 ecx, DWORD PTR _i$4[ebp]
  00151	c1 e1 04	 shl	 ecx, 4
  00154	ba 04 00 00 00	 mov	 edx, 4
  00159	6b d2 03	 imul	 edx, edx, 3
  0015c	3b 84 11 00 00
	00 00		 cmp	 eax, DWORD PTR ?g_RingMapPosition@@3PAY03HA[ecx+edx]
  00163	7e 05		 jle	 SHORT $LN12@Move
$LN13@Move:

; 784  : 					continue;

  00165	e9 12 ff ff ff	 jmp	 $LN5@Move
$LN12@Move:

; 785  : 
; 786  : 				if (m_RingMonsterHerd[i].CheckLocation(iRandX, iRandY))

  0016a	8d 45 fa	 lea	 eax, DWORD PTR _iRandY$7[ebp]
  0016d	50		 push	 eax
  0016e	8d 4d fb	 lea	 ecx, DWORD PTR _iRandX$8[ebp]
  00171	51		 push	 ecx
  00172	6b 55 f4 44	 imul	 edx, DWORD PTR _i$4[ebp], 68
  00176	6b 45 f4 44	 imul	 eax, DWORD PTR _i$4[ebp], 68
  0017a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0017d	8d 4c 01 04	 lea	 ecx, DWORD PTR [ecx+eax+4]
  00181	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00184	8b 54 10 04	 mov	 edx, DWORD PTR [eax+edx+4]
  00188	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0018b	ff d0		 call	 eax
  0018d	85 c0		 test	 eax, eax
  0018f	74 02		 je	 SHORT $LN14@Move

; 787  : 					break;

  00191	eb 05		 jmp	 SHORT $LN6@Move
$LN14@Move:

; 788  : 			}

  00193	e9 e4 fe ff ff	 jmp	 $LN5@Move
$LN6@Move:

; 789  : 
; 790  : 			if (m_RingMonsterHerd[i].MoveHerd(iRandX, iRandY)) {

  00198	0f b6 45 fa	 movzx	 eax, BYTE PTR _iRandY$7[ebp]
  0019c	50		 push	 eax
  0019d	0f b6 4d fb	 movzx	 ecx, BYTE PTR _iRandX$8[ebp]
  001a1	51		 push	 ecx
  001a2	6b 55 f4 44	 imul	 edx, DWORD PTR _i$4[ebp], 68
  001a6	6b 45 f4 44	 imul	 eax, DWORD PTR _i$4[ebp], 68
  001aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ad	8d 4c 01 04	 lea	 ecx, DWORD PTR [ecx+eax+4]
  001b1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001b4	8b 54 10 04	 mov	 edx, DWORD PTR [eax+edx+4]
  001b8	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  001bb	ff d0		 call	 eax
  001bd	85 c0		 test	 eax, eax
  001bf	74 23		 je	 SHORT $LN15@Move

; 791  : #if TESTSERVER == 1
; 792  : 	#ifndef FOR_ONAIR				
; 793  : 				PMSG_NOTICE	pNotice;
; 794  : 
; 795  : 			#ifdef MODIFY_NOTICE_20040325
; 796  : 				TNotice::MakeNoticeMsgEx( &pNotice, 1, " [%s] X:%d, Y:%d", g_TerrainManager.GetMapName(g_RingEventMapNum[i]), iRandX, iRandY);
; 797  : //				TNotice::SendNoticeToAllUser( &pNotice );
; 798  : 			#else
; 799  : 				pNotice.type = 1;
; 800  : 				wsprintf(pNotice.Notice, " [%s] X:%d, Y:%d", g_TerrainManager.GetMapName(g_RingEventMapNum[i]), iRandX, iRandY);
; 801  : 				PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 802  : 
; 803  : 				for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)
; 804  : 				{
; 805  : 					if( gObj[n].Connected == 3 && (gObj[n].Type == OBJTYPE_CHARACTER) )
; 806  : 					{
; 807  : //						DataSend(n, (LPBYTE)&pNotice, pNotice.h.size);
; 808  : 					}
; 809  : 				}
; 810  : 			#endif
; 811  : 	#endif
; 812  : #endif
; 813  : 				LogAddTD("[Ring Event] - Monster Herd Move MapNumber:%d, X:%d, Y:%d",

  001c1	0f b6 45 fa	 movzx	 eax, BYTE PTR _iRandY$7[ebp]
  001c5	50		 push	 eax
  001c6	0f b6 4d fb	 movzx	 ecx, BYTE PTR _iRandX$8[ebp]
  001ca	51		 push	 ecx
  001cb	8b 55 f4	 mov	 edx, DWORD PTR _i$4[ebp]
  001ce	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?g_RingEventMapNum@@3PAHA[edx*4]
  001d5	50		 push	 eax
  001d6	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@PFGAPPAF@?$FLRing?5Event?$FN?5?9?5Monster?5Herd?5Mov@
  001db	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001e1	83 c4 10	 add	 esp, 16			; 00000010H
$LN15@Move:

; 814  : 					g_RingEventMapNum[i],
; 815  : 					iRandX,
; 816  : 					iRandY
; 817  : 					);
; 818  : 			}
; 819  : 
; 820  : 			INT iDIVIDE = m_iRADIUS_MAX - m_iRADIUS_MIN;

  001e4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001e7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ea	8b 90 00 01 00
	00		 mov	 edx, DWORD PTR [eax+256]
  001f0	2b 91 fc 00 00
	00		 sub	 edx, DWORD PTR [ecx+252]
  001f6	89 55 ec	 mov	 DWORD PTR _iDIVIDE$2[ebp], edx

; 821  : 			if (iDIVIDE <= 0)

  001f9	83 7d ec 00	 cmp	 DWORD PTR _iDIVIDE$2[ebp], 0
  001fd	7f 07		 jg	 SHORT $LN16@Move

; 822  : 				iDIVIDE = 1;

  001ff	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _iDIVIDE$2[ebp], 1
$LN16@Move:

; 823  : 			INT iRADIUS = iDIVIDE + m_iRADIUS_MIN;

  00206	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00209	8b 4d ec	 mov	 ecx, DWORD PTR _iDIVIDE$2[ebp]
  0020c	03 88 fc 00 00
	00		 add	 ecx, DWORD PTR [eax+252]
  00212	89 4d e8	 mov	 DWORD PTR _iRADIUS$1[ebp], ecx

; 824  : 			if (iRADIUS <= RINGEVENT_MIN_RADIUS)

  00215	83 7d e8 03	 cmp	 DWORD PTR _iRADIUS$1[ebp], 3
  00219	7f 07		 jg	 SHORT $LN17@Move

; 825  : 				iRADIUS = RINGEVENT_MIN_RADIUS;

  0021b	c7 45 e8 03 00
	00 00		 mov	 DWORD PTR _iRADIUS$1[ebp], 3
$LN17@Move:

; 826  : 
; 827  : 			m_RingMonsterHerd[i].SetRadius(rand()%(m_iRADIUS_MAX - m_iRADIUS_MIN) + m_iRADIUS_MIN);

  00222	e8 00 00 00 00	 call	 _rand
  00227	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0022a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0022d	8b 89 00 01 00
	00		 mov	 ecx, DWORD PTR [ecx+256]
  00233	2b 8a fc 00 00
	00		 sub	 ecx, DWORD PTR [edx+252]
  00239	99		 cdq
  0023a	f7 f9		 idiv	 ecx
  0023c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0023f	03 90 fc 00 00
	00		 add	 edx, DWORD PTR [eax+252]
  00245	52		 push	 edx
  00246	6b 4d f4 44	 imul	 ecx, DWORD PTR _i$4[ebp], 68
  0024a	6b 55 f4 44	 imul	 edx, DWORD PTR _i$4[ebp], 68
  0024e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00251	8d 54 10 04	 lea	 edx, DWORD PTR [eax+edx+4]
  00255	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00258	8b 44 08 04	 mov	 eax, DWORD PTR [eax+ecx+4]
  0025c	8b ca		 mov	 ecx, edx
  0025e	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00261	ff d2		 call	 edx

; 828  : 		}

  00263	e9 ce fd ff ff	 jmp	 $LN2@Move
$LN1@Move:

; 829  : 	}
; 830  : }

  00268	5f		 pop	 edi
  00269	5e		 pop	 esi
  0026a	5b		 pop	 ebx
  0026b	8b e5		 mov	 esp, ebp
  0026d	5d		 pop	 ebp
  0026e	c3		 ret	 0
?Move@CRingAttackEvent@@QAEXXZ ENDP			; CRingAttackEvent::Move
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?SetState_Playing@CRingAttackEvent@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetState_Playing@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::SetState_Playing, COMDAT
; _this$ = ecx

; 755  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 756  : 	m_iTIME_MSEC_REMAIN = m_iTIME_MIN_PLAY * 60 * 1000;			// RINGEVENT_STATE_PLAYING -> RINGEVENT_STATE_PLAYEND   

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	6b 88 e4 00 00
	00 3c		 imul	 ecx, DWORD PTR [eax+228], 60
  00016	69 d1 e8 03 00
	00		 imul	 edx, ecx, 1000
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	89 90 dc 00 00
	00		 mov	 DWORD PTR [eax+220], edx

; 757  : 
; 758  : 	StartEvent();			//   

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?StartEvent@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::StartEvent

; 759  : }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?SetState_Playing@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::SetState_Playing
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?SetState_Closed@CRingAttackEvent@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetState_Closed@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::SetState_Closed, COMDAT
; _this$ = ecx

; 744  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 745  : 	StopEvent();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?StopEvent@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::StopEvent

; 746  : 
; 747  : 	if (m_bDoEvent)

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 b8 d0 00 00
	00 00		 cmp	 DWORD PTR [eax+208], 0
  0001e	74 0a		 je	 SHORT $LN2@SetState_C

; 748  : 		CheckSync();		//     .

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?CheckSync@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::CheckSync
  00028	eb 0a		 jmp	 SHORT $LN1@SetState_C
$LN2@SetState_C:

; 749  : 	else
; 750  : 		SetState (RINGEVENT_STATE_NONE);

  0002a	6a 00		 push	 0
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState
$LN1@SetState_C:

; 751  : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?SetState_Closed@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::SetState_Closed
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?SetState_None@CRingAttackEvent@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetState_None@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::SetState_None, COMDAT
; _this$ = ecx

; 738  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 739  : 	StopEvent();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?StopEvent@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::StopEvent

; 740  : }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?SetState_None@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::SetState_None
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?ProcState_Playing@CRingAttackEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$1 = -296						; size = 6
_szTemp$2 = -288					; size = 256
_ucRAND$3 = -31						; size = 1
_iRandY$4 = -30						; size = 1
_iRandX$5 = -29						; size = 1
_i$6 = -28						; size = 4
_n$7 = -24						; size = 4
_bLive$8 = -20						; size = 4
_i$9 = -16						; size = 4
_iTICK_MSEC$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?ProcState_Playing@CRingAttackEvent@@QAEXXZ PROC	; CRingAttackEvent::ProcState_Playing, COMDAT
; _this$ = ecx

; 590  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 591  : //#if TESTSERVER == 1		// 30     
; 592  : 	static INT	iTIME_SEC_NOTIFY = -1;
; 593  : //#endif
; 594  : 
; 595  : 	INT iTICK_MSEC = (GetTickCount() - m_iTIME_TICK_COUNT);

  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	2b 81 ec 00 00
	00		 sub	 eax, DWORD PTR [ecx+236]
  00028	89 45 f4	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 596  : 	
; 597  : 	if (iTICK_MSEC >= 1000) {

  0002b	81 7d f4 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  00032	7c 3d		 jl	 SHORT $LN11@ProcState_

; 598  : 		m_iTIME_MSEC_REMAIN -= iTICK_MSEC;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 88 dc 00 00
	00		 mov	 ecx, DWORD PTR [eax+220]
  0003d	2b 4d f4	 sub	 ecx, DWORD PTR _iTICK_MSEC$[ebp]
  00040	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00043	89 8a dc 00 00
	00		 mov	 DWORD PTR [edx+220], ecx

; 599  : 		m_iTIME_TICK_COUNT = GetTickCount();

  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	89 81 ec 00 00
	00		 mov	 DWORD PTR [ecx+236], eax

; 600  : 
; 601  : #if TESTSERVER == 1
; 602  : 		//LogAddTD("[Ring Event] - PLAYING Check Time. [%d] sec remain", m_iTIME_MSEC_REMAIN / 1000);
; 603  : #endif
; 604  : 
; 605  : 		if (rand()%10 == 0) {	//    .

  00058	e8 00 00 00 00	 call	 _rand
  0005d	99		 cdq
  0005e	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00063	f7 f9		 idiv	 ecx
  00065	85 d2		 test	 edx, edx
  00067	75 08		 jne	 SHORT $LN11@ProcState_

; 606  : 			Move ();

  00069	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?Move@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::Move
$LN11@ProcState_:

; 607  : 		}
; 608  : 	}
; 609  : 
; 610  : //#if TESTSERVER == 1		// 30     
; 611  : 	if ((m_iTIME_MSEC_REMAIN/1000) % 30 == 0 &&

  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 80 dc 00 00
	00		 mov	 eax, DWORD PTR [eax+220]
  0007a	99		 cdq
  0007b	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00080	f7 f9		 idiv	 ecx
  00082	99		 cdq
  00083	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  00088	f7 f9		 idiv	 ecx
  0008a	85 d2		 test	 edx, edx
  0008c	0f 85 42 01 00
	00		 jne	 $LN13@ProcState_
  00092	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00095	8b 80 dc 00 00
	00		 mov	 eax, DWORD PTR [eax+220]
  0009b	99		 cdq
  0009c	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  000a1	f7 f9		 idiv	 ecx
  000a3	99		 cdq
  000a4	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  000a9	f7 f9		 idiv	 ecx
  000ab	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?iTIME_SEC_NOTIFY@?1??ProcState_Playing@CRingAttackEvent@@QAEXXZ@4HA
  000b1	0f 84 1d 01 00
	00		 je	 $LN13@ProcState_

; 612  : 		(m_iTIME_MSEC_REMAIN/1000) / 30 != iTIME_SEC_NOTIFY
; 613  : 		)
; 614  : 	{
; 615  : 		iTIME_SEC_NOTIFY = (m_iTIME_MSEC_REMAIN/1000) / 30;

  000b7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ba	8b 80 dc 00 00
	00		 mov	 eax, DWORD PTR [eax+220]
  000c0	99		 cdq
  000c1	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  000c6	f7 f9		 idiv	 ecx
  000c8	99		 cdq
  000c9	b9 1e 00 00 00	 mov	 ecx, 30			; 0000001eH
  000ce	f7 f9		 idiv	 ecx
  000d0	a3 00 00 00 00	 mov	 DWORD PTR ?iTIME_SEC_NOTIFY@?1??ProcState_Playing@CRingAttackEvent@@QAEXXZ@4HA, eax

; 616  : 		
; 617  : 		for (INT i = 0 ; i < RINGEVENT_MAX_MAP ; i++ ) {

  000d5	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$9[ebp], 0
  000dc	eb 09		 jmp	 SHORT $LN4@ProcState_
$LN2@ProcState_:
  000de	8b 45 f0	 mov	 eax, DWORD PTR _i$9[ebp]
  000e1	83 c0 01	 add	 eax, 1
  000e4	89 45 f0	 mov	 DWORD PTR _i$9[ebp], eax
$LN4@ProcState_:
  000e7	83 7d f0 03	 cmp	 DWORD PTR _i$9[ebp], 3
  000eb	0f 8d e3 00 00
	00		 jge	 $LN13@ProcState_

; 618  : 			BOOL bLive = FALSE;

  000f1	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _bLive$8[ebp], 0

; 619  : 			
; 620  : 			for( int n=0; n<ALLOC_USEROBJECTSTART; n++) {

  000f8	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _n$7[ebp], 0
  000ff	eb 09		 jmp	 SHORT $LN7@ProcState_
$LN5@ProcState_:
  00101	8b 45 e8	 mov	 eax, DWORD PTR _n$7[ebp]
  00104	83 c0 01	 add	 eax, 1
  00107	89 45 e8	 mov	 DWORD PTR _n$7[ebp], eax
$LN7@ProcState_:
  0010a	81 7d e8 00 19
	00 00		 cmp	 DWORD PTR _n$7[ebp], 6400 ; 00001900H
  00111	7d 77		 jge	 SHORT $LN6@ProcState_

; 621  : 				if (gObj[n].Class == 135) {				//   

  00113	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$7[ebp], 7072
  0011a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00120	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  00128	81 fa 87 00 00
	00		 cmp	 edx, 135		; 00000087H
  0012e	75 55		 jne	 SHORT $LN14@ProcState_

; 622  : 					if (gObj[n].m_bIsInMonsterHerd) {	//  

  00130	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$7[ebp], 7072
  00137	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0013d	83 bc 01 ec 0e
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3820], 0
  00145	74 3e		 je	 SHORT $LN14@ProcState_

; 623  : 						if (gObj[n].Live &&				//    

  00147	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$7[ebp], 7072
  0014e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00154	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  00159	85 d2		 test	 edx, edx
  0015b	74 28		 je	 SHORT $LN14@ProcState_
  0015d	69 45 e8 a0 1b
	00 00		 imul	 eax, DWORD PTR _n$7[ebp], 7072
  00164	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016a	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00172	8b 45 f0	 mov	 eax, DWORD PTR _i$9[ebp]
  00175	3b 14 85 00 00
	00 00		 cmp	 edx, DWORD PTR ?g_RingEventMapNum@@3PAHA[eax*4]
  0017c	75 07		 jne	 SHORT $LN14@ProcState_

; 624  : 							gObj[n].MapNumber == g_RingEventMapNum[i]
; 625  : 							) 
; 626  : 						{				
; 627  : 							bLive = TRUE;

  0017e	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _bLive$8[ebp], 1
$LN14@ProcState_:

; 628  : 						}
; 629  : 					}
; 630  : 				}
; 631  : 			}

  00185	e9 77 ff ff ff	 jmp	 $LN5@ProcState_
$LN6@ProcState_:

; 632  : 
; 633  : 			LogAddTD("[Ring Event] - per 30'S Inform MapNumber:%d, X:%d, Y:%d, Boss Live:%d",

  0018a	8b 45 ec	 mov	 eax, DWORD PTR _bLive$8[ebp]
  0018d	50		 push	 eax
  0018e	6b 4d f0 44	 imul	 ecx, DWORD PTR _i$9[ebp], 68
  00192	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00195	8d 4c 0a 04	 lea	 ecx, DWORD PTR [edx+ecx+4]
  00199	e8 00 00 00 00	 call	 ?GetY@CRingMonsterHerd@@QAEEXZ ; CRingMonsterHerd::GetY
  0019e	0f b6 c0	 movzx	 eax, al
  001a1	50		 push	 eax
  001a2	6b 4d f0 44	 imul	 ecx, DWORD PTR _i$9[ebp], 68
  001a6	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001a9	8d 4c 0a 04	 lea	 ecx, DWORD PTR [edx+ecx+4]
  001ad	e8 00 00 00 00	 call	 ?GetX@CRingMonsterHerd@@QAEEXZ ; CRingMonsterHerd::GetX
  001b2	0f b6 c0	 movzx	 eax, al
  001b5	50		 push	 eax
  001b6	8b 4d f0	 mov	 ecx, DWORD PTR _i$9[ebp]
  001b9	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?g_RingEventMapNum@@3PAHA[ecx*4]
  001c0	52		 push	 edx
  001c1	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@MJJALBNB@?$FLRing?5Event?$FN?5?9?5per?530?8S?5Inform?5@
  001c6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001cc	83 c4 14	 add	 esp, 20			; 00000014H

; 634  : 				g_RingEventMapNum[i],
; 635  : 				m_RingMonsterHerd[i].GetX(),
; 636  : 				m_RingMonsterHerd[i].GetY(),
; 637  : 				bLive
; 638  : 				);
; 639  : 
; 640  : #if TESTSERVER == 1			// 30     
; 641  : 	#ifndef FOR_ONAIR
; 642  : 			PMSG_NOTICE	pNotice;
; 643  : 
; 644  : 			#ifdef MODIFY_NOTICE_20040325
; 645  : 				TNotice::MakeNoticeMsgEx( &pNotice, 1, "[%s] X:%d, Y:%d", g_TerrainManager.GetMapName(g_RingEventMapNum[i]), m_RingMonsterHerd[i].GetX(), m_RingMonsterHerd[i].GetY());
; 646  : //				TNotice::SendNoticeToAllUser( &pNotice );
; 647  : 			#else
; 648  : 				pNotice.type = 1;
; 649  : 				wsprintf(pNotice.Notice, "[%s] X:%d, Y:%d", g_TerrainManager.GetMapName(g_RingEventMapNum[i]), m_RingMonsterHerd[i].GetX(), m_RingMonsterHerd[i].GetY());
; 650  : 				PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 651  : 
; 652  : 				for( int m=ALLOC_USEROBJECTSTART; m<MAX_OBJECT; m++)
; 653  : 				{
; 654  : 					if( gObj[m].Connected == 3 && (gObj[m].Type == OBJTYPE_CHARACTER) )
; 655  : 					{
; 656  : //						DataSend(n, (LPBYTE)&pNotice, pNotice.h.size);
; 657  : 					}
; 658  : 				}
; 659  : 			#endif
; 660  : 				
; 661  : 	#endif
; 662  : #endif
; 663  : 		}

  001cf	e9 0a ff ff ff	 jmp	 $LN2@ProcState_
$LN13@ProcState_:

; 664  : 	}
; 665  : //#endif
; 666  : 
; 667  : 
; 668  : 	if (m_iTIME_MSEC_REMAIN <= m_iTIME_MONSTER_TO_DEST * 60 * 1000 &&		// n    .

  001d4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001d7	6b 88 e8 00 00
	00 3c		 imul	 ecx, DWORD PTR [eax+232], 60
  001de	69 d1 e8 03 00
	00		 imul	 edx, ecx, 1000
  001e4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001e7	39 90 dc 00 00
	00		 cmp	 DWORD PTR [eax+220], edx
  001ed	0f 8f ca 00 00
	00		 jg	 $LN17@ProcState_
  001f3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001f6	83 b8 d8 00 00
	00 00		 cmp	 DWORD PTR [eax+216], 0
  001fd	0f 85 ba 00 00
	00		 jne	 $LN17@ProcState_

; 669  : 		m_bMonsterToDest == FALSE
; 670  : 		)
; 671  : 	{
; 672  : 		for (INT i = 0 ; i < RINGEVENT_MAX_MAP ; i++ ) {

  00203	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$6[ebp], 0
  0020a	eb 09		 jmp	 SHORT $LN10@ProcState_
$LN8@ProcState_:
  0020c	8b 45 e4	 mov	 eax, DWORD PTR _i$6[ebp]
  0020f	83 c0 01	 add	 eax, 1
  00212	89 45 e4	 mov	 DWORD PTR _i$6[ebp], eax
$LN10@ProcState_:
  00215	83 7d e4 03	 cmp	 DWORD PTR _i$6[ebp], 3
  00219	0f 8d 91 00 00
	00		 jge	 $LN9@ProcState_

; 673  : 
; 674  : 			UCHAR iRandX, iRandY;
; 675  : 
; 676  : 			UCHAR ucRAND = rand()%4;

  0021f	e8 00 00 00 00	 call	 _rand
  00224	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00229	79 05		 jns	 SHORT $LN23@ProcState_
  0022b	48		 dec	 eax
  0022c	83 c8 fc	 or	 eax, -4			; fffffffcH
  0022f	40		 inc	 eax
$LN23@ProcState_:
  00230	88 45 e1	 mov	 BYTE PTR _ucRAND$3[ebp], al

; 677  : 
; 678  : 			iRandX = g_RingMapDestPosition[i][ucRAND*2];

  00233	8b 45 e4	 mov	 eax, DWORD PTR _i$6[ebp]
  00236	c1 e0 05	 shl	 eax, 5
  00239	0f b6 4d e1	 movzx	 ecx, BYTE PTR _ucRAND$3[ebp]
  0023d	d1 e1		 shl	 ecx, 1
  0023f	8a 94 88 00 00
	00 00		 mov	 dl, BYTE PTR ?g_RingMapDestPosition@@3PAY07HA[eax+ecx*4]
  00246	88 55 e3	 mov	 BYTE PTR _iRandX$5[ebp], dl

; 679  : 			iRandY = g_RingMapDestPosition[i][ucRAND*2+1];

  00249	8b 45 e4	 mov	 eax, DWORD PTR _i$6[ebp]
  0024c	c1 e0 05	 shl	 eax, 5
  0024f	0f b6 4d e1	 movzx	 ecx, BYTE PTR _ucRAND$3[ebp]
  00253	d1 e1		 shl	 ecx, 1
  00255	8a 94 88 04 00
	00 00		 mov	 dl, BYTE PTR ?g_RingMapDestPosition@@3PAY07HA[eax+ecx*4+4]
  0025c	88 55 e2	 mov	 BYTE PTR _iRandY$4[ebp], dl

; 680  : 			
; 681  : 			if (m_RingMonsterHerd[i].MoveHerd(iRandX, iRandY)) {

  0025f	0f b6 45 e2	 movzx	 eax, BYTE PTR _iRandY$4[ebp]
  00263	50		 push	 eax
  00264	0f b6 4d e3	 movzx	 ecx, BYTE PTR _iRandX$5[ebp]
  00268	51		 push	 ecx
  00269	6b 55 e4 44	 imul	 edx, DWORD PTR _i$6[ebp], 68
  0026d	6b 45 e4 44	 imul	 eax, DWORD PTR _i$6[ebp], 68
  00271	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00274	8d 4c 01 04	 lea	 ecx, DWORD PTR [ecx+eax+4]
  00278	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0027b	8b 54 10 04	 mov	 edx, DWORD PTR [eax+edx+4]
  0027f	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00282	ff d0		 call	 eax
  00284	85 c0		 test	 eax, eax
  00286	74 23		 je	 SHORT $LN18@ProcState_

; 682  : #if TESTSERVER == 1
; 683  : 	#ifndef FOR_ONAIR				
; 684  : 				PMSG_NOTICE	pNotice;
; 685  : 
; 686  : 			#ifdef MODIFY_NOTICE_20040325
; 687  : 				TNotice::MakeNoticeMsgEx( &pNotice, 1, " [%s] X:%d, Y:%d", g_TerrainManager.GetMapName(g_RingEventMapNum[i]), iRandX, iRandY);
; 688  : //				TNotice::SendNoticeToAllUser( &pNotice );
; 689  : 			#else
; 690  : 				pNotice.type = 1;
; 691  : 				wsprintf(pNotice.Notice, " [%s] X:%d, Y:%d", g_TerrainManager.GetMapName(g_RingEventMapNum[i]), iRandX, iRandY);
; 692  : 				PHeadSetB((LPBYTE)&pNotice, 0x0D, 4+(strlen(pNotice.Notice)+1));
; 693  : 
; 694  : 				for( int n=ALLOC_USEROBJECTSTART; n<MAX_OBJECT; n++)
; 695  : 				{
; 696  : 					if( gObj[n].Connected == 3 && (gObj[n].Type == OBJTYPE_CHARACTER) )
; 697  : 					{
; 698  : //						DataSend(n, (LPBYTE)&pNotice, pNotice.h.size);
; 699  : 					}
; 700  : 				}
; 701  : 			#endif
; 702  : 	#endif
; 703  : #endif
; 704  : 
; 705  : 				LogAddTD("[Ring Event] - Monster Herd Move MapNumber:%d, X:%d, Y:%d",

  00288	0f b6 45 e2	 movzx	 eax, BYTE PTR _iRandY$4[ebp]
  0028c	50		 push	 eax
  0028d	0f b6 4d e3	 movzx	 ecx, BYTE PTR _iRandX$5[ebp]
  00291	51		 push	 ecx
  00292	8b 55 e4	 mov	 edx, DWORD PTR _i$6[ebp]
  00295	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?g_RingEventMapNum@@3PAHA[edx*4]
  0029c	50		 push	 eax
  0029d	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@PFGAPPAF@?$FLRing?5Event?$FN?5?9?5Monster?5Herd?5Mov@
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002a8	83 c4 10	 add	 esp, 16			; 00000010H
$LN18@ProcState_:

; 706  : 					g_RingEventMapNum[i],
; 707  : 					iRandX,
; 708  : 					iRandY
; 709  : 					);
; 710  : 			}
; 711  : 		}

  002ab	e9 5c ff ff ff	 jmp	 $LN8@ProcState_
$LN9@ProcState_:

; 712  : 
; 713  : 		m_bMonsterToDest = TRUE;

  002b0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002b3	c7 80 d8 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+216], 1
$LN17@ProcState_:

; 714  : 	}
; 715  : 	
; 716  : 	if (m_iTIME_MSEC_REMAIN <= 0) {

  002bd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002c0	83 b8 dc 00 00
	00 00		 cmp	 DWORD PTR [eax+220], 0
  002c7	0f 8f 99 00 00
	00		 jg	 $LN1@ProcState_

; 717  : 		//  . -> 
; 718  : 		CHAR szTemp[256];
; 719  : 		wsprintf(szTemp, lMsg.Get(1209));		// "   ."

  002cd	68 b9 04 00 00	 push	 1209			; 000004b9H
  002d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002dd	50		 push	 eax
  002de	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$2[ebp]
  002e4	50		 push	 eax
  002e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  002eb	83 c4 08	 add	 esp, 8

; 720  : 		AllSendServerMsg (szTemp);

  002ee	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$2[ebp]
  002f4	50		 push	 eax
  002f5	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  002fa	83 c4 04	 add	 esp, 4

; 721  : 	
; 722  : 		PMSG_ANS_CL_EFFECT pMsg;
; 723  : 		PHeadSetB((LPBYTE)&pMsg, 0x9E, sizeof(pMsg));

  002fd	6a 06		 push	 6
  002ff	68 9e 00 00 00	 push	 158			; 0000009eH
  00304	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$1[ebp]
  0030a	50		 push	 eax
  0030b	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00310	83 c4 0c	 add	 esp, 12			; 0000000cH

; 724  : 		pMsg.wEffectNum = 2;		//     

  00313	b8 02 00 00 00	 mov	 eax, 2
  00318	66 89 85 dc fe
	ff ff		 mov	 WORD PTR _pMsg$1[ebp+4], ax

; 725  : 		DataSendAll ((LPBYTE)&pMsg, pMsg.h.size);

  0031f	0f b6 85 d9 fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  00326	50		 push	 eax
  00327	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$1[ebp]
  0032d	51		 push	 ecx
  0032e	e8 00 00 00 00	 call	 ?DataSendAll@@YAXPAEH@Z	; DataSendAll
  00333	83 c4 08	 add	 esp, 8

; 726  : 
; 727  : 		if (m_bDoEvent)

  00336	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00339	83 b8 d0 00 00
	00 00		 cmp	 DWORD PTR [eax+208], 0
  00340	74 0c		 je	 SHORT $LN20@ProcState_

; 728  : 			SetState (RINGEVENT_STATE_CLOSED);

  00342	6a 01		 push	 1
  00344	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00347	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState
  0034c	eb 0a		 jmp	 SHORT $LN21@ProcState_
$LN20@ProcState_:

; 729  : 		else
; 730  : 			SetState (RINGEVENT_STATE_NONE);

  0034e	6a 00		 push	 0
  00350	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00353	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState
$LN21@ProcState_:

; 731  : 
; 732  : 		LogAddTD("[Ring Event] - Event Ended");

  00358	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KELOKDGN@?$FLRing?5Event?$FN?5?9?5Event?5Ended@
  0035d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00363	83 c4 04	 add	 esp, 4
$LN1@ProcState_:

; 733  : 	}
; 734  : }

  00366	5f		 pop	 edi
  00367	5e		 pop	 esi
  00368	5b		 pop	 ebx
  00369	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0036c	33 cd		 xor	 ecx, ebp
  0036e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00373	8b e5		 mov	 esp, ebp
  00375	5d		 pop	 ebp
  00376	c3		 ret	 0
?ProcState_Playing@CRingAttackEvent@@QAEXXZ ENDP	; CRingAttackEvent::ProcState_Playing
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?ProcState_Closed@CRingAttackEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$1 = -540						; size = 6
_szTemp$2 = -532					; size = 256
_pMsg$3 = -276						; size = 6
_szTemp$4 = -268					; size = 256
_iTICK_MSEC$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?ProcState_Closed@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::ProcState_Closed, COMDAT
; _this$ = ecx

; 526  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 9c 02 00
	00		 sub	 esp, 668		; 0000029cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 527  : 	INT iTICK_MSEC = (GetTickCount() - m_iTIME_TICK_COUNT);

  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	2b 81 ec 00 00
	00		 sub	 eax, DWORD PTR [ecx+236]
  00028	89 45 f4	 mov	 DWORD PTR _iTICK_MSEC$[ebp], eax

; 528  : 	
; 529  : 	if (iTICK_MSEC >= 1000) {

  0002b	81 7d f4 e8 03
	00 00		 cmp	 DWORD PTR _iTICK_MSEC$[ebp], 1000 ; 000003e8H
  00032	0f 8c 22 01 00
	00		 jl	 $LN2@ProcState_

; 530  : 		m_iTIME_MSEC_REMAIN -= iTICK_MSEC;

  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 88 dc 00 00
	00		 mov	 ecx, DWORD PTR [eax+220]
  00041	2b 4d f4	 sub	 ecx, DWORD PTR _iTICK_MSEC$[ebp]
  00044	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00047	89 8a dc 00 00
	00		 mov	 DWORD PTR [edx+220], ecx

; 531  : 		m_iTIME_TICK_COUNT = GetTickCount();

  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00053	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	89 81 ec 00 00
	00		 mov	 DWORD PTR [ecx+236], eax

; 532  : 
; 533  : #if TESTSERVER == 1
; 534  : 		//LogAddTD("[Ring Event] - CLOSED Check Time. [%d] sec remain", m_iTIME_MSEC_REMAIN / 1000);
; 535  : #endif
; 536  : 		if (m_bDoEvent) {

  0005c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	83 b8 d0 00 00
	00 00		 cmp	 DWORD PTR [eax+208], 0
  00066	0f 84 ee 00 00
	00		 je	 $LN2@ProcState_

; 537  : 			// > .     . !!
; 538  : 			if ((m_iTIME_MSEC_REMAIN <= m_iTIME_MIN_OPEN * 60 * 1000) && (m_iTIME_MSEC_REMAIN > 0) && (m_iTIME_MSEC_REMAIN / (60*1000) != m_iTIME_NOTIFY_COUNT )) {	

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	6b 88 e0 00 00
	00 3c		 imul	 ecx, DWORD PTR [eax+224], 60
  00076	69 d1 e8 03 00
	00		 imul	 edx, ecx, 1000
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	39 90 dc 00 00
	00		 cmp	 DWORD PTR [eax+220], edx
  00085	0f 8f cf 00 00
	00		 jg	 $LN2@ProcState_
  0008b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	83 b8 dc 00 00
	00 00		 cmp	 DWORD PTR [eax+220], 0
  00095	0f 8e bf 00 00
	00		 jle	 $LN2@ProcState_
  0009b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b 80 dc 00 00
	00		 mov	 eax, DWORD PTR [eax+220]
  000a4	99		 cdq
  000a5	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  000aa	f7 f9		 idiv	 ecx
  000ac	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000af	3b 82 f0 00 00
	00		 cmp	 eax, DWORD PTR [edx+240]
  000b5	0f 84 9f 00 00
	00		 je	 $LN2@ProcState_

; 539  : 				m_iTIME_NOTIFY_COUNT = m_iTIME_MSEC_REMAIN / (60*1000);

  000bb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000be	8b 80 dc 00 00
	00		 mov	 eax, DWORD PTR [eax+220]
  000c4	99		 cdq
  000c5	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  000ca	f7 f9		 idiv	 ecx
  000cc	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000cf	89 82 f0 00 00
	00		 mov	 DWORD PTR [edx+240], eax

; 540  : 
; 541  : #if TESTSERVER == 1
; 542  : 				CHAR szTemp[256];
; 543  : 				wsprintf(szTemp, lMsg.Get(1206), m_iTIME_NOTIFY_COUNT+1);	// "      . (%d)"
; 544  : 				AllSendServerMsg (szTemp);
; 545  : 				
; 546  : 				PMSG_ANS_CL_EFFECT pMsg;
; 547  : 				PHeadSetB((LPBYTE)&pMsg, 0x9E, sizeof(pMsg));
; 548  : 				pMsg.wEffectNum = 0;			//  n    
; 549  : 				DataSendAll ((LPBYTE)&pMsg, pMsg.h.size);
; 550  : #else
; 551  : 				if (m_iTIME_NOTIFY_COUNT + 1 == 3) {	// 3    .

  000d5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	8b 88 f0 00 00
	00		 mov	 ecx, DWORD PTR [eax+240]
  000de	83 c1 01	 add	 ecx, 1
  000e1	83 f9 03	 cmp	 ecx, 3
  000e4	75 74		 jne	 SHORT $LN2@ProcState_

; 552  : 					CHAR szTemp[256];
; 553  : 					wsprintf(szTemp, lMsg.Get(1207));	// "      ."

  000e6	68 b7 04 00 00	 push	 1207			; 000004b7H
  000eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000f6	50		 push	 eax
  000f7	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$4[ebp]
  000fd	50		 push	 eax
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00104	83 c4 08	 add	 esp, 8

; 554  : 					AllSendServerMsg (szTemp);

  00107	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$4[ebp]
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00113	83 c4 04	 add	 esp, 4

; 555  : 
; 556  : 					PMSG_ANS_CL_EFFECT pMsg;
; 557  : 					PHeadSetB((LPBYTE)&pMsg, 0x9E, sizeof(pMsg));

  00116	6a 06		 push	 6
  00118	68 9e 00 00 00	 push	 158			; 0000009eH
  0011d	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pMsg$3[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  00129	83 c4 0c	 add	 esp, 12			; 0000000cH

; 558  : 					pMsg.wEffectNum = 0;		//  n    

  0012c	33 c0		 xor	 eax, eax
  0012e	66 89 85 f0 fe
	ff ff		 mov	 WORD PTR _pMsg$3[ebp+4], ax

; 559  : 					DataSendAll ((LPBYTE)&pMsg, pMsg.h.size);

  00135	0f b6 85 ed fe
	ff ff		 movzx	 eax, BYTE PTR _pMsg$3[ebp+1]
  0013c	50		 push	 eax
  0013d	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _pMsg$3[ebp]
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 ?DataSendAll@@YAXPAEH@Z	; DataSendAll
  00149	83 c4 08	 add	 esp, 8

; 560  : 
; 561  : 					LogAddTD("[Ring Event] - Before 3 minutes - Advertise");

  0014c	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@NAOFHPPM@?$FLRing?5Event?$FN?5?9?5Before?53?5minutes@
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00157	83 c4 04	 add	 esp, 4
$LN2@ProcState_:

; 562  : 				}
; 563  : #endif
; 564  : 			}
; 565  : 		}
; 566  : 	}
; 567  : 	
; 568  : 	if (m_iTIME_MSEC_REMAIN <= 0) {

  0015a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0015d	83 b8 dc 00 00
	00 00		 cmp	 DWORD PTR [eax+220], 0
  00164	0f 8f 99 00 00
	00		 jg	 $LN1@ProcState_

; 569  : 		//   . ->  
; 570  : 		CHAR szTemp[256];
; 571  : 		wsprintf(szTemp, lMsg.Get(1208));		// "         ."

  0016a	68 b8 04 00 00	 push	 1208			; 000004b8H
  0016f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00174	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  0017a	50		 push	 eax
  0017b	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _szTemp$2[ebp]
  00181	50		 push	 eax
  00182	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00188	83 c4 08	 add	 esp, 8

; 572  : 		AllSendServerMsg (szTemp);

  0018b	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _szTemp$2[ebp]
  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  00197	83 c4 04	 add	 esp, 4

; 573  : 
; 574  : 		PMSG_ANS_CL_EFFECT pMsg;
; 575  : 		PHeadSetB((LPBYTE)&pMsg, 0x9E, sizeof(pMsg));

  0019a	6a 06		 push	 6
  0019c	68 9e 00 00 00	 push	 158			; 0000009eH
  001a1	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _pMsg$1[ebp]
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  001ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 576  : 		pMsg.wEffectNum = 1;		//     

  001b0	b8 01 00 00 00	 mov	 eax, 1
  001b5	66 89 85 e8 fd
	ff ff		 mov	 WORD PTR _pMsg$1[ebp+4], ax

; 577  : 		DataSendAll ((LPBYTE)&pMsg, pMsg.h.size);

  001bc	0f b6 85 e5 fd
	ff ff		 movzx	 eax, BYTE PTR _pMsg$1[ebp+1]
  001c3	50		 push	 eax
  001c4	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _pMsg$1[ebp]
  001ca	51		 push	 ecx
  001cb	e8 00 00 00 00	 call	 ?DataSendAll@@YAXPAEH@Z	; DataSendAll
  001d0	83 c4 08	 add	 esp, 8

; 578  : 
; 579  : 		if (m_bDoEvent)

  001d3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001d6	83 b8 d0 00 00
	00 00		 cmp	 DWORD PTR [eax+208], 0
  001dd	74 0c		 je	 SHORT $LN7@ProcState_

; 580  : 			SetState (RINGEVENT_STATE_PLAYING);

  001df	6a 02		 push	 2
  001e1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e4	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState
  001e9	eb 0a		 jmp	 SHORT $LN8@ProcState_
$LN7@ProcState_:

; 581  : 		else
; 582  : 			SetState (RINGEVENT_STATE_NONE);

  001eb	6a 00		 push	 0
  001ed	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f0	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState
$LN8@ProcState_:

; 583  : 
; 584  : 		LogAddTD("[Ring Event] - Event Started");

  001f5	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@HLGPJCPM@?$FLRing?5Event?$FN?5?9?5Event?5Started@
  001fa	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00200	83 c4 04	 add	 esp, 4
$LN1@ProcState_:

; 585  : 	}
; 586  : }

  00203	5f		 pop	 edi
  00204	5e		 pop	 esi
  00205	5b		 pop	 ebx
  00206	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00209	33 cd		 xor	 ecx, ebp
  0020b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00210	8b e5		 mov	 esp, ebp
  00212	5d		 pop	 ebp
  00213	c3		 ret	 0
?ProcState_Closed@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::ProcState_Closed
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?ProcState_None@CRingAttackEvent@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ProcState_None@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::ProcState_None, COMDAT
; _this$ = ecx

; 520  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 	
; 522  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?ProcState_None@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::ProcState_None
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?SetState@CRingAttackEvent@@QAEXH@Z
_TEXT	SEGMENT
tv70 = -72						; size = 4
_this$ = -4						; size = 4
_iSTATE$ = 8						; size = 4
?SetState@CRingAttackEvent@@QAEXH@Z PROC		; CRingAttackEvent::SetState, COMDAT
; _this$ = ecx

; 497  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 498  : 	if ((m_iEVENT_STATE < RINGEVENT_STATE_NONE) || (m_iEVENT_STATE > RINGEVENT_STATE_PLAYING))

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 b8 f4 00 00
	00 00		 cmp	 DWORD PTR [eax+244], 0
  00016	7c 0c		 jl	 SHORT $LN5@SetState
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 b8 f4 00 00
	00 02		 cmp	 DWORD PTR [eax+244], 2
  00022	7e 02		 jle	 SHORT $LN4@SetState
$LN5@SetState:

; 499  : 		return;

  00024	eb 48		 jmp	 SHORT $LN1@SetState
$LN4@SetState:

; 500  : 
; 501  : 	m_iEVENT_STATE = iSTATE;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _iSTATE$[ebp]
  0002c	89 88 f4 00 00
	00		 mov	 DWORD PTR [eax+244], ecx

; 502  : 
; 503  : 	switch(m_iEVENT_STATE) {

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 88 f4 00 00
	00		 mov	 ecx, DWORD PTR [eax+244]
  0003b	89 4d b8	 mov	 DWORD PTR tv70[ebp], ecx
  0003e	83 7d b8 00	 cmp	 DWORD PTR tv70[ebp], 0
  00042	74 0e		 je	 SHORT $LN6@SetState
  00044	83 7d b8 01	 cmp	 DWORD PTR tv70[ebp], 1
  00048	74 12		 je	 SHORT $LN7@SetState
  0004a	83 7d b8 02	 cmp	 DWORD PTR tv70[ebp], 2
  0004e	74 16		 je	 SHORT $LN8@SetState
  00050	eb 1c		 jmp	 SHORT $LN1@SetState
$LN6@SetState:

; 504  : 	case RINGEVENT_STATE_NONE :
; 505  : 		SetState_None();

  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?SetState_None@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::SetState_None

; 506  : 		break;

  0005a	eb 12		 jmp	 SHORT $LN1@SetState
$LN7@SetState:

; 507  : 	case RINGEVENT_STATE_CLOSED :
; 508  : 		SetState_Closed();

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ?SetState_Closed@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::SetState_Closed

; 509  : 		break;

  00064	eb 08		 jmp	 SHORT $LN1@SetState
$LN8@SetState:

; 510  : 	case RINGEVENT_STATE_PLAYING :
; 511  : 		SetState_Playing();

  00066	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	e8 00 00 00 00	 call	 ?SetState_Playing@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::SetState_Playing
$LN1@SetState:

; 512  : 		break;
; 513  : 	default:
; 514  : 		break;
; 515  : 	}
; 516  : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 04 00	 ret	 4
?SetState@CRingAttackEvent@@QAEXH@Z ENDP		; CRingAttackEvent::SetState
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?CheckSync@CRingAttackEvent@@QAEXXZ
_TEXT	SEGMENT
tv186 = -136						; size = 4
$T1 = -132						; size = 4
$T2 = -128						; size = 4
$T3 = -124						; size = 4
$T4 = -120						; size = 4
$T5 = -116						; size = 4
_pRET$6 = -48						; size = 4
_pRET$7 = -44						; size = 4
_it$ = -40						; size = 4
_bTIME_CHANGED$ = -36					; size = 4
_iMIN_MINUTE$ = -32					; size = 4
_iMIN_HOUR$ = -28					; size = 4
_sysTime$ = -24						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?CheckSync@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::CheckSync, COMDAT
; _this$ = ecx

; 393  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 394  : 
; 395  : #if TESTSERVER == 1
; 396  : 	//  
; 397  : 	m_iTIME_MSEC_REMAIN = (m_iTIME_MIN_OPEN + 1) * 60 * 1000;
; 398  : 	m_iTIME_TICK_COUNT = GetTickCount();
; 399  : 
; 400  : 	//   !!!!!
; 401  : 	m_iTIME_MSEC_REMAIN = 5000;
; 402  : #else
; 403  : 	//    
; 404  : 
; 405  : 	if (m_vtEventTime.empty()) {

  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	81 c1 28 01 00
	00		 add	 ecx, 296		; 00000128H
  00022	e8 00 00 00 00	 call	 ?empty@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE_NXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::empty
  00027	0f b6 c0	 movzx	 eax, al
  0002a	85 c0		 test	 eax, eax
  0002c	74 1f		 je	 SHORT $LN10@CheckSync

; 406  : 		LogAddC(2, "[Ring Event] No Schedule Time Data");

  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@BNKPBCAA@?$FLRing?5Event?$FN?5No?5Schedule?5Time?5D@
  00033	6a 02		 push	 2
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0003b	83 c4 08	 add	 esp, 8

; 407  : 		SetState(RINGEVENT_STATE_NONE);

  0003e	6a 00		 push	 0
  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState

; 408  : 		return;

  00048	e9 58 02 00 00	 jmp	 $LN1@CheckSync
$LN10@CheckSync:

; 409  : 	}
; 410  : 
; 411  : 	SYSTEMTIME sysTime;
; 412  : 	GetLocalTime (& sysTime);

  0004d	8d 45 e8	 lea	 eax, DWORD PTR _sysTime$[ebp]
  00050	50		 push	 eax
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 413  : 
; 414  : 	INT iMIN_HOUR = 24;

  00057	c7 45 e4 18 00
	00 00		 mov	 DWORD PTR _iMIN_HOUR$[ebp], 24 ; 00000018H

; 415  : 	INT iMIN_MINUTE = 60;

  0005e	c7 45 e0 3c 00
	00 00		 mov	 DWORD PTR _iMIN_MINUTE$[ebp], 60 ; 0000003cH

; 416  : 	BOOL bTIME_CHANGED = FALSE;

  00065	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 0

; 417  : 
; 418  : 	vector <RINGMONSTER_EVENT_TIME>::iterator it = m_vtEventTime.begin();

  0006c	8d 45 d8	 lea	 eax, DWORD PTR _it$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	81 c1 28 01 00
	00		 add	 ecx, 296		; 00000128H
  00079	e8 00 00 00 00	 call	 ?begin@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::begin
  0007e	eb 0e		 jmp	 SHORT $LN4@CheckSync
$LN2@CheckSync:

; 419  : 
; 420  : 	for (;it != m_vtEventTime.end();it++) {

  00080	6a 00		 push	 0
  00082	8d 45 8c	 lea	 eax, DWORD PTR $T5[ebp]
  00085	50		 push	 eax
  00086	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  00089	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator++
$LN4@CheckSync:
  0008e	8d 45 88	 lea	 eax, DWORD PTR $T4[ebp]
  00091	50		 push	 eax
  00092	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	81 c1 28 01 00
	00		 add	 ecx, 296		; 00000128H
  0009b	e8 00 00 00 00	 call	 ?end@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::end
  000a0	50		 push	 eax
  000a1	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  000a4	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator!=
  000a9	0f b6 c8	 movzx	 ecx, al
  000ac	85 c9		 test	 ecx, ecx
  000ae	74 5c		 je	 SHORT $LN3@CheckSync

; 421  : 		RINGMONSTER_EVENT_TIME & pRET = *it;

  000b0	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  000b3	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAURINGMONSTER_EVENT_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator*
  000b8	89 45 d4	 mov	 DWORD PTR _pRET$7[ebp], eax

; 422  : 		if (sysTime.wHour * 60 + sysTime.wMinute < pRET.m_iHour * 60 +pRET.m_iMinute)

  000bb	0f b7 45 f0	 movzx	 eax, WORD PTR _sysTime$[ebp+8]
  000bf	6b c8 3c	 imul	 ecx, eax, 60
  000c2	0f b7 55 f2	 movzx	 edx, WORD PTR _sysTime$[ebp+10]
  000c6	03 ca		 add	 ecx, edx
  000c8	8b 45 d4	 mov	 eax, DWORD PTR _pRET$7[ebp]
  000cb	6b 10 3c	 imul	 edx, DWORD PTR [eax], 60
  000ce	8b 45 d4	 mov	 eax, DWORD PTR _pRET$7[ebp]
  000d1	03 50 04	 add	 edx, DWORD PTR [eax+4]
  000d4	3b ca		 cmp	 ecx, edx
  000d6	7d 2f		 jge	 SHORT $LN11@CheckSync

; 423  : 		{
; 424  : 			if (iMIN_HOUR * 60 + iMIN_MINUTE > pRET.m_iHour * 60 +pRET.m_iMinute) {

  000d8	6b 45 e4 3c	 imul	 eax, DWORD PTR _iMIN_HOUR$[ebp], 60
  000dc	03 45 e0	 add	 eax, DWORD PTR _iMIN_MINUTE$[ebp]
  000df	8b 4d d4	 mov	 ecx, DWORD PTR _pRET$7[ebp]
  000e2	6b 11 3c	 imul	 edx, DWORD PTR [ecx], 60
  000e5	8b 4d d4	 mov	 ecx, DWORD PTR _pRET$7[ebp]
  000e8	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000eb	3b c2		 cmp	 eax, edx
  000ed	7e 18		 jle	 SHORT $LN11@CheckSync

; 425  : 				bTIME_CHANGED = TRUE;

  000ef	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 1

; 426  : 				
; 427  : 				iMIN_HOUR = pRET.m_iHour;

  000f6	8b 45 d4	 mov	 eax, DWORD PTR _pRET$7[ebp]
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	89 4d e4	 mov	 DWORD PTR _iMIN_HOUR$[ebp], ecx

; 428  : 				iMIN_MINUTE = pRET.m_iMinute;

  000fe	8b 45 d4	 mov	 eax, DWORD PTR _pRET$7[ebp]
  00101	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00104	89 4d e0	 mov	 DWORD PTR _iMIN_MINUTE$[ebp], ecx
$LN11@CheckSync:

; 429  : 			}
; 430  : 		}
; 431  : 	}

  00107	e9 74 ff ff ff	 jmp	 $LN2@CheckSync
$LN3@CheckSync:

; 432  : 
; 433  : 	if (bTIME_CHANGED == FALSE) {

  0010c	83 7d dc 00	 cmp	 DWORD PTR _bTIME_CHANGED$[ebp], 0
  00110	0f 85 96 00 00
	00		 jne	 $LN13@CheckSync

; 434  : 		it = m_vtEventTime.begin();

  00116	8d 45 84	 lea	 eax, DWORD PTR $T3[ebp]
  00119	50		 push	 eax
  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	81 c1 28 01 00
	00		 add	 ecx, 296		; 00000128H
  00123	e8 00 00 00 00	 call	 ?begin@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::begin
  00128	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012a	89 4d d8	 mov	 DWORD PTR _it$[ebp], ecx

; 435  : 		iMIN_HOUR = 24;

  0012d	c7 45 e4 18 00
	00 00		 mov	 DWORD PTR _iMIN_HOUR$[ebp], 24 ; 00000018H

; 436  : 		iMIN_MINUTE = 60;

  00134	c7 45 e0 3c 00
	00 00		 mov	 DWORD PTR _iMIN_MINUTE$[ebp], 60 ; 0000003cH
  0013b	eb 0e		 jmp	 SHORT $LN7@CheckSync
$LN5@CheckSync:

; 437  : 		
; 438  : 		for (;it != m_vtEventTime.end();it++) {

  0013d	6a 00		 push	 0
  0013f	8d 45 80	 lea	 eax, DWORD PTR $T2[ebp]
  00142	50		 push	 eax
  00143	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  00146	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator++
$LN7@CheckSync:
  0014b	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00151	50		 push	 eax
  00152	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00155	81 c1 28 01 00
	00		 add	 ecx, 296		; 00000128H
  0015b	e8 00 00 00 00	 call	 ?end@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::end
  00160	50		 push	 eax
  00161	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  00164	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator!=
  00169	0f b6 c8	 movzx	 ecx, al
  0016c	85 c9		 test	 ecx, ecx
  0016e	74 3c		 je	 SHORT $LN13@CheckSync

; 439  : 			RINGMONSTER_EVENT_TIME & pRET = *it;

  00170	8d 4d d8	 lea	 ecx, DWORD PTR _it$[ebp]
  00173	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QBEAAURINGMONSTER_EVENT_TIME@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >::operator*
  00178	89 45 d0	 mov	 DWORD PTR _pRET$6[ebp], eax

; 440  : 			if (iMIN_HOUR * 60 + iMIN_MINUTE > pRET.m_iHour * 60 +pRET.m_iMinute)

  0017b	6b 45 e4 3c	 imul	 eax, DWORD PTR _iMIN_HOUR$[ebp], 60
  0017f	03 45 e0	 add	 eax, DWORD PTR _iMIN_MINUTE$[ebp]
  00182	8b 4d d0	 mov	 ecx, DWORD PTR _pRET$6[ebp]
  00185	6b 11 3c	 imul	 edx, DWORD PTR [ecx], 60
  00188	8b 4d d0	 mov	 ecx, DWORD PTR _pRET$6[ebp]
  0018b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0018e	3b c2		 cmp	 eax, edx
  00190	7e 18		 jle	 SHORT $LN14@CheckSync

; 441  : 			{
; 442  : 				bTIME_CHANGED = TRUE+1;

  00192	c7 45 dc 02 00
	00 00		 mov	 DWORD PTR _bTIME_CHANGED$[ebp], 2

; 443  : 				
; 444  : 				iMIN_HOUR = pRET.m_iHour;

  00199	8b 45 d0	 mov	 eax, DWORD PTR _pRET$6[ebp]
  0019c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019e	89 4d e4	 mov	 DWORD PTR _iMIN_HOUR$[ebp], ecx

; 445  : 				iMIN_MINUTE = pRET.m_iMinute;

  001a1	8b 45 d0	 mov	 eax, DWORD PTR _pRET$6[ebp]
  001a4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001a7	89 4d e0	 mov	 DWORD PTR _iMIN_MINUTE$[ebp], ecx
$LN14@CheckSync:

; 446  : 			}
; 447  : 		}

  001aa	eb 91		 jmp	 SHORT $LN5@CheckSync
$LN13@CheckSync:

; 448  : 	}
; 449  : 
; 450  : 	switch(bTIME_CHANGED) {

  001ac	8b 45 dc	 mov	 eax, DWORD PTR _bTIME_CHANGED$[ebp]
  001af	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv186[ebp], eax
  001b5	83 bd 78 ff ff
	ff 01		 cmp	 DWORD PTR tv186[ebp], 1
  001bc	74 0b		 je	 SHORT $LN15@CheckSync
  001be	83 bd 78 ff ff
	ff 02		 cmp	 DWORD PTR tv186[ebp], 2
  001c5	74 3b		 je	 SHORT $LN16@CheckSync
  001c7	eb 77		 jmp	 SHORT $LN17@CheckSync
$LN15@CheckSync:

; 451  : 	case TRUE :			//      .
; 452  : 		m_iTIME_MSEC_REMAIN = ( ((60*iMIN_HOUR) * 60 + iMIN_MINUTE*60) - ((((60*sysTime.wHour) * 60) + sysTime.wMinute * 60 + sysTime.wSecond))) * 1000;

  001c9	6b 45 e4 3c	 imul	 eax, DWORD PTR _iMIN_HOUR$[ebp], 60
  001cd	6b c8 3c	 imul	 ecx, eax, 60
  001d0	6b 55 e0 3c	 imul	 edx, DWORD PTR _iMIN_MINUTE$[ebp], 60
  001d4	03 ca		 add	 ecx, edx
  001d6	0f b7 45 f0	 movzx	 eax, WORD PTR _sysTime$[ebp+8]
  001da	6b d0 3c	 imul	 edx, eax, 60
  001dd	6b c2 3c	 imul	 eax, edx, 60
  001e0	0f b7 55 f2	 movzx	 edx, WORD PTR _sysTime$[ebp+10]
  001e4	6b d2 3c	 imul	 edx, edx, 60
  001e7	03 c2		 add	 eax, edx
  001e9	0f b7 55 f4	 movzx	 edx, WORD PTR _sysTime$[ebp+12]
  001ed	03 c2		 add	 eax, edx
  001ef	2b c8		 sub	 ecx, eax
  001f1	69 c1 e8 03 00
	00		 imul	 eax, ecx, 1000
  001f7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001fa	89 81 dc 00 00
	00		 mov	 DWORD PTR [ecx+220], eax

; 453  : 		break;

  00200	eb 5a		 jmp	 SHORT $LN8@CheckSync
$LN16@CheckSync:

; 454  : 	case TRUE + 1 :		//       (  )
; 455  : 		m_iTIME_MSEC_REMAIN = ( ((60*(iMIN_HOUR+24)) * 60 + iMIN_MINUTE*60) - ((((60*sysTime.wHour) * 60) + sysTime.wMinute * 60 + sysTime.wSecond))) * 1000;

  00202	8b 45 e4	 mov	 eax, DWORD PTR _iMIN_HOUR$[ebp]
  00205	83 c0 18	 add	 eax, 24			; 00000018H
  00208	6b c8 3c	 imul	 ecx, eax, 60
  0020b	6b d1 3c	 imul	 edx, ecx, 60
  0020e	6b 45 e0 3c	 imul	 eax, DWORD PTR _iMIN_MINUTE$[ebp], 60
  00212	03 d0		 add	 edx, eax
  00214	0f b7 4d f0	 movzx	 ecx, WORD PTR _sysTime$[ebp+8]
  00218	6b c1 3c	 imul	 eax, ecx, 60
  0021b	6b c8 3c	 imul	 ecx, eax, 60
  0021e	0f b7 45 f2	 movzx	 eax, WORD PTR _sysTime$[ebp+10]
  00222	6b c0 3c	 imul	 eax, eax, 60
  00225	03 c8		 add	 ecx, eax
  00227	0f b7 45 f4	 movzx	 eax, WORD PTR _sysTime$[ebp+12]
  0022b	03 c8		 add	 ecx, eax
  0022d	2b d1		 sub	 edx, ecx
  0022f	69 ca e8 03 00
	00		 imul	 ecx, edx, 1000
  00235	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00238	89 8a dc 00 00
	00		 mov	 DWORD PTR [edx+220], ecx

; 456  : 		break;

  0023e	eb 1c		 jmp	 SHORT $LN8@CheckSync
$LN17@CheckSync:

; 457  : 	default:			// 
; 458  : 		LogAddC(2, "[Ring Event] No Schedule Time Data");

  00240	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@BNKPBCAA@?$FLRing?5Event?$FN?5No?5Schedule?5Time?5D@
  00245	6a 02		 push	 2
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0024d	83 c4 08	 add	 esp, 8

; 459  : 		SetState(RINGEVENT_STATE_NONE);

  00250	6a 00		 push	 0
  00252	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00255	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState

; 460  : 		return;

  0025a	eb 49		 jmp	 SHORT $LN1@CheckSync
$LN8@CheckSync:

; 461  : 	}
; 462  : 	
; 463  : 	m_iTIME_TICK_COUNT = GetTickCount();

  0025c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00262	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00265	89 81 ec 00 00
	00		 mov	 DWORD PTR [ecx+236], eax

; 464  : 	
; 465  : 	LogAddTD("[Ring Event] Sync Start Time. [%d] min remain (START HOUR:%d, MIN:%d)", m_iTIME_MSEC_REMAIN / (60 * 1000), iMIN_HOUR, iMIN_MINUTE);

  0026b	8b 45 e0	 mov	 eax, DWORD PTR _iMIN_MINUTE$[ebp]
  0026e	50		 push	 eax
  0026f	8b 4d e4	 mov	 ecx, DWORD PTR _iMIN_HOUR$[ebp]
  00272	51		 push	 ecx
  00273	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00276	8b 82 dc 00 00
	00		 mov	 eax, DWORD PTR [edx+220]
  0027c	99		 cdq
  0027d	b9 60 ea 00 00	 mov	 ecx, 60000		; 0000ea60H
  00282	f7 f9		 idiv	 ecx
  00284	50		 push	 eax
  00285	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@KMBELKMF@?$FLRing?5Event?$FN?5Sync?5Start?5Time?4?5?$FL@
  0028a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00290	83 c4 10	 add	 esp, 16			; 00000010H

; 466  : 	
; 467  : /*	
; 468  : 	//  4    
; 469  : 
; 470  : 	struct tm * today;
; 471  : 	time_t ltime;
; 472  : 	
; 473  : 	time( &ltime );
; 474  : 	today = localtime( &ltime );
; 475  : 
; 476  : 	INT iTimeMod = today->tm_hour%4;
; 477  : 
; 478  : 	m_iTIME_MSEC_REMAIN = (((60*4) * 60) - ((((60*iTimeMod) * 60) + today->tm_min * 60 + today->tm_sec))) * 1000;
; 479  : 
; 480  : 	if( m_iTIME_MSEC_REMAIN < 0 )
; 481  : 	{
; 482  : 		m_iTIME_MSEC_REMAIN += (60 * 60) * 1000;
; 483  : 	}
; 484  : 	
; 485  : 	m_iTIME_TICK_COUNT = GetTickCount();
; 486  : 
; 487  : 	LogAddTD("[Ring Event] Sync Start Time. [%d] min remain", m_iTIME_MSEC_REMAIN / (60 * 1000));
; 488  : */
; 489  : #endif
; 490  : 
; 491  : 	m_iTIME_NOTIFY_COUNT = m_iTIME_MIN_OPEN;

  00293	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00296	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00299	8b 91 e0 00 00
	00		 mov	 edx, DWORD PTR [ecx+224]
  0029f	89 90 f0 00 00
	00		 mov	 DWORD PTR [eax+240], edx
$LN1@CheckSync:

; 492  : 
; 493  : }

  002a5	5f		 pop	 edi
  002a6	5e		 pop	 esi
  002a7	5b		 pop	 ebx
  002a8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ab	33 cd		 xor	 ecx, ebp
  002ad	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b2	8b e5		 mov	 esp, ebp
  002b4	5d		 pop	 ebp
  002b5	c3		 ret	 0
?CheckSync@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::CheckSync
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?Run@CRingAttackEvent@@QAEXXZ
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
?Run@CRingAttackEvent@@QAEXXZ PROC			; CRingAttackEvent::Run, COMDAT
; _this$ = ecx

; 367  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 368  : 
; 369  : #ifdef EVENT_MANAGEMENT_20040711
; 370  : 	if (m_bMenualStart)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 b8 34 01 00
	00 00		 cmp	 DWORD PTR [eax+308], 0
  00016	74 02		 je	 SHORT $LN4@Run

; 371  : 		return;

  00018	eb 48		 jmp	 SHORT $LN1@Run
$LN4@Run:

; 372  : #endif
; 373  : 
; 374  : 	if (m_bDoEvent) {

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 b8 d0 00 00
	00 00		 cmp	 DWORD PTR [eax+208], 0
  00024	74 3c		 je	 SHORT $LN1@Run

; 375  : 		switch (m_iEVENT_STATE) {

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 88 f4 00 00
	00		 mov	 ecx, DWORD PTR [eax+244]
  0002f	89 4d b8	 mov	 DWORD PTR tv69[ebp], ecx
  00032	83 7d b8 00	 cmp	 DWORD PTR tv69[ebp], 0
  00036	74 0e		 je	 SHORT $LN6@Run
  00038	83 7d b8 01	 cmp	 DWORD PTR tv69[ebp], 1
  0003c	74 12		 je	 SHORT $LN7@Run
  0003e	83 7d b8 02	 cmp	 DWORD PTR tv69[ebp], 2
  00042	74 16		 je	 SHORT $LN8@Run
  00044	eb 1c		 jmp	 SHORT $LN1@Run
$LN6@Run:

; 376  : 		case RINGEVENT_STATE_NONE :
; 377  : 			ProcState_None();

  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?ProcState_None@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::ProcState_None

; 378  : 			break;

  0004e	eb 12		 jmp	 SHORT $LN1@Run
$LN7@Run:

; 379  : 		case RINGEVENT_STATE_CLOSED :
; 380  : 			ProcState_Closed();

  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?ProcState_Closed@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::ProcState_Closed

; 381  : 			break;

  00058	eb 08		 jmp	 SHORT $LN1@Run
$LN8@Run:

; 382  : 		case RINGEVENT_STATE_PLAYING :
; 383  : 			ProcState_Playing();

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?ProcState_Playing@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::ProcState_Playing
$LN1@Run:

; 384  : 			break;
; 385  : 		default:
; 386  : 			break;
; 387  : 		}
; 388  : 	}
; 389  : }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?Run@CRingAttackEvent@@QAEXXZ ENDP			; CRingAttackEvent::Run
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?Load@CRingAttackEvent@@UAEHPAD@Z
_TEXT	SEGMENT
$T1 = -140						; size = 4
$T2 = -136						; size = 4
$T3 = -132						; size = 4
$T4 = -128						; size = 4
$T5 = -124						; size = 4
$T6 = -120						; size = 4
$T7 = -116						; size = 4
$T8 = -112						; size = 4
$T9 = -108						; size = 4
$T10 = -104						; size = 4
_pRET$11 = -36						; size = 8
_pRMD$12 = -28						; size = 12
_type$ = -16						; size = 4
_Token$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpszFileName$ = 8					; size = 4
?Load@CRingAttackEvent@@UAEHPAD@Z PROC			; CRingAttackEvent::Load, COMDAT
; _this$ = ecx

; 281  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 282  : 	// *> .     .
; 283  : 	if((SMDFile=fopen(lpszFileName, "r")) == NULL)	

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  0001e	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _fopen
  00027	83 c4 08	 add	 esp, 8
  0002a	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax
  0002f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, 0
  00036	75 18		 jne	 SHORT $LN6@Load

; 284  : 	{
; 285  : 		MsgBox("[Ring Event] Info file Load Fail [%s]", lpszFileName);

  00038	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  0003b	50		 push	 eax
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@OKIEPGH@?$FLRing?5Event?$FN?5Info?5file?5Load?5Fai@
  00041	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00046	83 c4 08	 add	 esp, 8

; 286  : 		return FALSE;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 0a 03 00 00	 jmp	 $LN1@Load
$LN6@Load:

; 287  : 	}
; 288  : 
; 289  : 	EnterCriticalSection (& m_critMonsterAddData);

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	05 10 01 00 00	 add	 eax, 272		; 00000110H
  00058	50		 push	 eax
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 290  : 	m_vtMonsterAddData.erase(m_vtMonsterAddData.begin(), m_vtMonsterAddData.end());

  0005f	8d 45 94	 lea	 eax, DWORD PTR $T9[ebp]
  00062	50		 push	 eax
  00063	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  0006c	e8 00 00 00 00	 call	 ?end@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::end
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	89 4d 98	 mov	 DWORD PTR $T10[ebp], ecx
  00076	8d 55 8c	 lea	 edx, DWORD PTR $T7[ebp]
  00079	52		 push	 edx
  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00083	e8 00 00 00 00	 call	 ?begin@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::begin
  00088	8b 00		 mov	 eax, DWORD PTR [eax]
  0008a	89 45 90	 mov	 DWORD PTR $T8[ebp], eax
  0008d	8b 4d 98	 mov	 ecx, DWORD PTR $T10[ebp]
  00090	51		 push	 ecx
  00091	8b 55 90	 mov	 edx, DWORD PTR $T8[ebp]
  00094	52		 push	 edx
  00095	8d 45 88	 lea	 eax, DWORD PTR $T6[ebp]
  00098	50		 push	 eax
  00099	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  000a2	e8 00 00 00 00	 call	 ?erase@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::erase

; 291  : 	LeaveCriticalSection (& m_critMonsterAddData);

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	05 10 01 00 00	 add	 eax, 272		; 00000110H
  000af	50		 push	 eax
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 292  : 
; 293  : 	m_vtEventTime.erase(m_vtEventTime.begin(), m_vtEventTime.end());

  000b6	8d 45 80	 lea	 eax, DWORD PTR $T4[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	81 c1 28 01 00
	00		 add	 ecx, 296		; 00000128H
  000c3	e8 00 00 00 00	 call	 ?end@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::end
  000c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ca	89 4d 84	 mov	 DWORD PTR $T5[ebp], ecx
  000cd	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  000d3	52		 push	 edx
  000d4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	81 c1 28 01 00
	00		 add	 ecx, 296		; 00000128H
  000dd	e8 00 00 00 00	 call	 ?begin@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::begin
  000e2	8b 00		 mov	 eax, DWORD PTR [eax]
  000e4	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  000ea	8b 4d 84	 mov	 ecx, DWORD PTR $T5[ebp]
  000ed	51		 push	 ecx
  000ee	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  000f4	52		 push	 edx
  000f5	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  000fb	50		 push	 eax
  000fc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	81 c1 28 01 00
	00		 add	 ecx, 296		; 00000128H
  00105	e8 00 00 00 00	 call	 ?erase@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::erase

; 294  : 
; 295  : 	m_bHasData = FALSE;

  0010a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0010d	c7 80 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+212], 0

; 296  : 
; 297  : 	SMDToken Token;
; 298  : 	
; 299  : 	int type = -1;

  00117	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _type$[ebp], -1
$LN2@Load:

; 300  : 	
; 301  : 	while( true )

  0011e	b8 01 00 00 00	 mov	 eax, 1
  00123	85 c0		 test	 eax, eax
  00125	0f 84 fd 01 00
	00		 je	 $LN3@Load

; 302  : 	{
; 303  : 		Token = (*GetToken)();

  0012b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00130	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 304  : 		if(Token == END) break;

  00133	83 7d f4 02	 cmp	 DWORD PTR _Token$[ebp], 2
  00137	75 05		 jne	 SHORT $LN7@Load
  00139	e9 ea 01 00 00	 jmp	 $LN3@Load
$LN7@Load:

; 305  : 		type = (int)TokenNumber;

  0013e	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00146	89 45 f0	 mov	 DWORD PTR _type$[ebp], eax
$LN4@Load:

; 306  : 		while(1)

  00149	b8 01 00 00 00	 mov	 eax, 1
  0014e	85 c0		 test	 eax, eax
  00150	0f 84 cd 01 00
	00		 je	 $LN5@Load

; 307  : 		{				
; 308  : 			if( type == 0 )

  00156	83 7d f0 00	 cmp	 DWORD PTR _type$[ebp], 0
  0015a	75 6b		 jne	 SHORT $LN8@Load

; 309  : 			{	//   
; 310  : 				Token = (*GetToken)();

  0015c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00161	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 311  : 				if(strcmp("end",TokenString)==NULL) break;

  00164	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  00169	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  0016e	e8 00 00 00 00	 call	 _strcmp
  00173	83 c4 08	 add	 esp, 8
  00176	85 c0		 test	 eax, eax
  00178	75 05		 jne	 SHORT $LN10@Load
  0017a	e9 a4 01 00 00	 jmp	 $LN5@Load
$LN10@Load:

; 312  : 
; 313  : 				m_iTIME_MIN_OPEN = (int)TokenNumber;		//     ?

  0017f	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00187	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018a	89 81 e0 00 00
	00		 mov	 DWORD PTR [ecx+224], eax

; 314  : 				Token = (*GetToken)(); m_iTIME_MIN_PLAY = (int)TokenNumber;				//  

  00190	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00195	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00198	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001a0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a3	89 81 e4 00 00
	00		 mov	 DWORD PTR [ecx+228], eax

; 315  : 				Token = (*GetToken)(); m_iTIME_MONSTER_TO_DEST = (int)TokenNumber;		//       ?

  001a9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001ae	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  001b1	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001b9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001bc	89 81 e8 00 00
	00		 mov	 DWORD PTR [ecx+232], eax

; 316  : 			}

  001c2	e9 57 01 00 00	 jmp	 $LN17@Load
$LN8@Load:

; 317  : 			else if( type == 1 )

  001c7	83 7d f0 01	 cmp	 DWORD PTR _type$[ebp], 1
  001cb	75 6b		 jne	 SHORT $LN11@Load

; 318  : 			{	//     
; 319  : 				Token = (*GetToken)();

  001cd	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001d2	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 320  : 				if(strcmp("end",TokenString)==NULL) break;

  001d5	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  001da	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  001df	e8 00 00 00 00	 call	 _strcmp
  001e4	83 c4 08	 add	 esp, 8
  001e7	85 c0		 test	 eax, eax
  001e9	75 05		 jne	 SHORT $LN13@Load
  001eb	e9 33 01 00 00	 jmp	 $LN5@Load
$LN13@Load:

; 321  : 
; 322  : 				m_iMOVE_RAND_SIZE = (int)TokenNumber;									//     

  001f0	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001f8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001fb	89 81 f8 00 00
	00		 mov	 DWORD PTR [ecx+248], eax

; 323  : 				Token = (*GetToken)(); m_iRADIUS_MIN			= TokenNumber;			//     

  00201	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00206	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00209	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00211	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00214	89 81 fc 00 00
	00		 mov	 DWORD PTR [ecx+252], eax

; 324  : 				Token = (*GetToken)(); m_iRADIUS_MAX			= TokenNumber;			//     

  0021a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0021f	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00222	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0022a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0022d	89 81 00 01 00
	00		 mov	 DWORD PTR [ecx+256], eax

; 325  : 
; 326  : 			}

  00233	e9 e6 00 00 00	 jmp	 $LN17@Load
$LN11@Load:

; 327  : 			else if( type == 2 )

  00238	83 7d f0 02	 cmp	 DWORD PTR _type$[ebp], 2
  0023c	0f 85 86 00 00
	00		 jne	 $LN14@Load

; 328  : 			{	//     
; 329  : 				RINGMONSTER_DATA pRMD;
; 330  : 
; 331  : 				Token = (*GetToken)();

  00242	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00247	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 332  : 				if(strcmp("end",TokenString)==NULL) break;

  0024a	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  0024f	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  00254	e8 00 00 00 00	 call	 _strcmp
  00259	83 c4 08	 add	 esp, 8
  0025c	85 c0		 test	 eax, eax
  0025e	75 05		 jne	 SHORT $LN16@Load
  00260	e9 be 00 00 00	 jmp	 $LN5@Load
$LN16@Load:

; 333  : 
; 334  : 				pRMD.m_iType = (int)TokenNumber;										//  			

  00265	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0026d	89 45 e4	 mov	 DWORD PTR _pRMD$12[ebp], eax

; 335  : 				Token = (*GetToken)(); pRMD.m_bDoRegen			= (BOOL)TokenNumber;	//  

  00270	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00275	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00278	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00280	89 45 e8	 mov	 DWORD PTR _pRMD$12[ebp+4], eax

; 336  : 				Token = (*GetToken)(); pRMD.m_bDoAttackFirst	= (BOOL)TokenNumber;	//  

  00283	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00288	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  0028b	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00293	89 45 ec	 mov	 DWORD PTR _pRMD$12[ebp+8], eax

; 337  : 				
; 338  : 				EnterCriticalSection (& m_critMonsterAddData);

  00296	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00299	05 10 01 00 00	 add	 eax, 272		; 00000110H
  0029e	50		 push	 eax
  0029f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 339  : 				m_vtMonsterAddData.push_back(pRMD);

  002a5	8d 45 e4	 lea	 eax, DWORD PTR _pRMD$12[ebp]
  002a8	50		 push	 eax
  002a9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002ac	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  002b2	e8 00 00 00 00	 call	 ?push_back@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXABURINGMONSTER_DATA@@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::push_back

; 340  : 				LeaveCriticalSection (& m_critMonsterAddData);

  002b7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002ba	05 10 01 00 00	 add	 eax, 272		; 00000110H
  002bf	50		 push	 eax
  002c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 341  : 			}

  002c6	eb 56		 jmp	 SHORT $LN17@Load
$LN14@Load:

; 342  : 			else if( type == 3 )

  002c8	83 7d f0 03	 cmp	 DWORD PTR _type$[ebp], 3
  002cc	75 50		 jne	 SHORT $LN17@Load

; 343  : 			{	//     
; 344  : 				RINGMONSTER_EVENT_TIME pRET;
; 345  : 
; 346  : 				Token = (*GetToken)();

  002ce	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002d3	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax

; 347  : 				if(strcmp("end",TokenString)==NULL) break;

  002d6	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  002db	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  002e0	e8 00 00 00 00	 call	 _strcmp
  002e5	83 c4 08	 add	 esp, 8
  002e8	85 c0		 test	 eax, eax
  002ea	75 02		 jne	 SHORT $LN18@Load
  002ec	eb 35		 jmp	 SHORT $LN5@Load
$LN18@Load:

; 348  : 
; 349  : 				pRET.m_iHour = (int)TokenNumber;										//   

  002ee	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002f6	89 45 dc	 mov	 DWORD PTR _pRET$11[ebp], eax

; 350  : 				Token = (*GetToken)(); pRET.m_iMinute			= (int)TokenNumber;		//   

  002f9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002fe	89 45 f4	 mov	 DWORD PTR _Token$[ebp], eax
  00301	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00309	89 45 e0	 mov	 DWORD PTR _pRET$11[ebp+4], eax

; 351  : 				
; 352  : 				m_vtEventTime.push_back(pRET);

  0030c	8d 45 dc	 lea	 eax, DWORD PTR _pRET$11[ebp]
  0030f	50		 push	 eax
  00310	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00313	81 c1 28 01 00
	00		 add	 ecx, 296		; 00000128H
  00319	e8 00 00 00 00	 call	 ?push_back@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXABURINGMONSTER_EVENT_TIME@@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::push_back
$LN17@Load:

; 353  : 			}
; 354  : 		}

  0031e	e9 26 fe ff ff	 jmp	 $LN4@Load
$LN5@Load:

; 355  : 	}

  00323	e9 f6 fd ff ff	 jmp	 $LN2@Load
$LN3@Load:

; 356  : 	fclose(SMDFile);

  00328	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0032d	50		 push	 eax
  0032e	e8 00 00 00 00	 call	 _fclose
  00333	83 c4 04	 add	 esp, 4

; 357  : 
; 358  : 	LogAdd("%s file load!", lpszFileName);

  00336	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00339	50		 push	 eax
  0033a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CEHBAEMJ@?$CFs?5file?5load?$CB@
  0033f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00345	83 c4 08	 add	 esp, 8

; 359  : 
; 360  : 	m_bHasData = TRUE;

  00348	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0034b	c7 80 d4 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+212], 1

; 361  : 
; 362  : 	return TRUE;

  00355	b8 01 00 00 00	 mov	 eax, 1
$LN1@Load:

; 363  : }

  0035a	5f		 pop	 edi
  0035b	5e		 pop	 esi
  0035c	5b		 pop	 ebx
  0035d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00360	33 cd		 xor	 ecx, ebp
  00362	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00367	8b e5		 mov	 esp, ebp
  00369	5d		 pop	 ebp
  0036a	c2 04 00	 ret	 4
?Load@CRingAttackEvent@@UAEHPAD@Z ENDP			; CRingAttackEvent::Load
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?EnableEvent@CRingAttackEvent@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bDoEvent$ = 8						; size = 4
?EnableEvent@CRingAttackEvent@@QAEXH@Z PROC		; CRingAttackEvent::EnableEvent, COMDAT
; _this$ = ecx

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 270  : 	m_bDoEvent = bDoEvent;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _bDoEvent$[ebp]
  00012	89 88 d0 00 00
	00		 mov	 DWORD PTR [eax+208], ecx

; 271  : 
; 272  : 	if (m_bDoEvent) {

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 b8 d0 00 00
	00 00		 cmp	 DWORD PTR [eax+208], 0
  00022	74 0c		 je	 SHORT $LN2@EnableEven

; 273  : 		SetState (RINGEVENT_STATE_CLOSED);

  00024	6a 01		 push	 1
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState

; 274  : 	}

  0002e	eb 0a		 jmp	 SHORT $LN1@EnableEven
$LN2@EnableEven:

; 275  : 	else {
; 276  : 		SetState (RINGEVENT_STATE_NONE);

  00030	6a 00		 push	 0
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?SetState@CRingAttackEvent@@QAEXH@Z ; CRingAttackEvent::SetState
$LN1@EnableEven:

; 277  : 	}
; 278  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?EnableEvent@CRingAttackEvent@@QAEXH@Z ENDP		; CRingAttackEvent::EnableEvent
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?StopEvent@CRingAttackEvent@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?StopEvent@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::StopEvent, COMDAT
; _this$ = ecx

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 	for (INT i = 0 ; i < RINGEVENT_MAX_MAP ; i++ )

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@StopEvent
$LN2@StopEvent:
  00015	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@StopEvent:
  0001e	83 7d f8 03	 cmp	 DWORD PTR _i$1[ebp], 3
  00022	7d 1d		 jge	 SHORT $LN3@StopEvent

; 263  : 		m_RingMonsterHerd[i].Stop();

  00024	6b 45 f8 44	 imul	 eax, DWORD PTR _i$1[ebp], 68
  00028	6b 4d f8 44	 imul	 ecx, DWORD PTR _i$1[ebp], 68
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	8d 4c 0a 04	 lea	 ecx, DWORD PTR [edx+ecx+4]
  00033	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  0003a	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0003d	ff d2		 call	 edx
  0003f	eb d4		 jmp	 SHORT $LN2@StopEvent
$LN3@StopEvent:

; 264  : 
; 265  : 	m_bMonsterToDest = FALSE;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	c7 80 d8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+216], 0

; 266  : }

  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?StopEvent@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::StopEvent
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?StartEvent@CRingAttackEvent@@QAEXXZ
_TEXT	SEGMENT
tv198 = -104						; size = 4
tv70 = -104						; size = 4
$T1 = -100						; size = 4
$T2 = -96						; size = 4
_pRMD$3 = -28						; size = 4
_it$4 = -24						; size = 4
_iCount$5 = -20						; size = 4
_i$6 = -16						; size = 4
_iRandY$ = -12						; size = 4
_iRandX$ = -8						; size = 4
_this$ = -4						; size = 4
?StartEvent@CRingAttackEvent@@QAEXXZ PROC		; CRingAttackEvent::StartEvent, COMDAT
; _this$ = ecx

; 190  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 191  : 	if (!m_bHasData)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 b8 d4 00 00
	00 00		 cmp	 DWORD PTR [eax+212], 0
  00016	75 05		 jne	 SHORT $LN12@StartEvent

; 192  : 		return;

  00018	e9 44 02 00 00	 jmp	 $LN1@StartEvent
$LN12@StartEvent:

; 193  : 
; 194  : 	INT iRandX, iRandY;
; 195  : 	
; 196  : #ifdef SEASON4_PATCH_GROOVING
; 197  : 	//--->
; 198  : 	// grooving 20080624
; 199  : 	//     
; 200  : 	// , ,         
; 201  : 	INT iSkipMap = 0;
; 202  : 	iSkipMap = rand() % 3;
; 203  : 	//<---
; 204  : 
; 205  : #endif
; 206  : 
; 207  : 	for (INT i = 0 ; i < RINGEVENT_MAX_MAP ; i++ ) {

  0001d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$6[ebp], 0
  00024	eb 09		 jmp	 SHORT $LN4@StartEvent
$LN2@StartEvent:
  00026	8b 45 f0	 mov	 eax, DWORD PTR _i$6[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 f0	 mov	 DWORD PTR _i$6[ebp], eax
$LN4@StartEvent:
  0002f	83 7d f0 03	 cmp	 DWORD PTR _i$6[ebp], 3
  00033	0f 8d 28 02 00
	00		 jge	 $LN1@StartEvent

; 208  : 
; 209  : #ifdef SEASON4_PATCH_GROOVING
; 210  : 		//--->
; 211  : 		// grooving 20080624
; 212  : 		//     
; 213  : 		if( iSkipMap == i )
; 214  : 			continue;
; 215  : 		//<---
; 216  : #endif
; 217  : 		INT iCount = 1000;

  00039	c7 45 ec e8 03
	00 00		 mov	 DWORD PTR _iCount$5[ebp], 1000 ; 000003e8H
$LN5@StartEvent:

; 218  : 
; 219  : 		while (iCount--) {

  00040	8b 45 ec	 mov	 eax, DWORD PTR _iCount$5[ebp]
  00043	89 45 98	 mov	 DWORD PTR tv70[ebp], eax
  00046	8b 4d ec	 mov	 ecx, DWORD PTR _iCount$5[ebp]
  00049	83 e9 01	 sub	 ecx, 1
  0004c	89 4d ec	 mov	 DWORD PTR _iCount$5[ebp], ecx
  0004f	83 7d 98 00	 cmp	 DWORD PTR tv70[ebp], 0
  00053	0f 84 d0 00 00
	00		 je	 $LN6@StartEvent

; 220  : 			iRandX = rand()%(g_RingMapPosition[i][2]-g_RingMapPosition[i][0])+g_RingMapPosition[i][0];

  00059	e8 00 00 00 00	 call	 _rand
  0005e	8b 4d f0	 mov	 ecx, DWORD PTR _i$6[ebp]
  00061	c1 e1 04	 shl	 ecx, 4
  00064	ba 04 00 00 00	 mov	 edx, 4
  00069	d1 e2		 shl	 edx, 1
  0006b	8b 75 f0	 mov	 esi, DWORD PTR _i$6[ebp]
  0006e	c1 e6 04	 shl	 esi, 4
  00071	bf 04 00 00 00	 mov	 edi, 4
  00076	6b ff 00	 imul	 edi, edi, 0
  00079	8b 8c 11 00 00
	00 00		 mov	 ecx, DWORD PTR ?g_RingMapPosition@@3PAY03HA[ecx+edx]
  00080	2b 8c 3e 00 00
	00 00		 sub	 ecx, DWORD PTR ?g_RingMapPosition@@3PAY03HA[esi+edi]
  00087	99		 cdq
  00088	f7 f9		 idiv	 ecx
  0008a	8b 45 f0	 mov	 eax, DWORD PTR _i$6[ebp]
  0008d	c1 e0 04	 shl	 eax, 4
  00090	b9 04 00 00 00	 mov	 ecx, 4
  00095	6b c9 00	 imul	 ecx, ecx, 0
  00098	03 94 08 00 00
	00 00		 add	 edx, DWORD PTR ?g_RingMapPosition@@3PAY03HA[eax+ecx]
  0009f	89 55 f8	 mov	 DWORD PTR _iRandX$[ebp], edx

; 221  : 			iRandY = rand()%(g_RingMapPosition[i][3]-g_RingMapPosition[i][1])+g_RingMapPosition[i][1];

  000a2	e8 00 00 00 00	 call	 _rand
  000a7	8b 4d f0	 mov	 ecx, DWORD PTR _i$6[ebp]
  000aa	c1 e1 04	 shl	 ecx, 4
  000ad	ba 04 00 00 00	 mov	 edx, 4
  000b2	6b d2 03	 imul	 edx, edx, 3
  000b5	8b 75 f0	 mov	 esi, DWORD PTR _i$6[ebp]
  000b8	c1 e6 04	 shl	 esi, 4
  000bb	bf 04 00 00 00	 mov	 edi, 4
  000c0	c1 e7 00	 shl	 edi, 0
  000c3	8b 8c 11 00 00
	00 00		 mov	 ecx, DWORD PTR ?g_RingMapPosition@@3PAY03HA[ecx+edx]
  000ca	2b 8c 3e 00 00
	00 00		 sub	 ecx, DWORD PTR ?g_RingMapPosition@@3PAY03HA[esi+edi]
  000d1	99		 cdq
  000d2	f7 f9		 idiv	 ecx
  000d4	8b 45 f0	 mov	 eax, DWORD PTR _i$6[ebp]
  000d7	c1 e0 04	 shl	 eax, 4
  000da	b9 04 00 00 00	 mov	 ecx, 4
  000df	c1 e1 00	 shl	 ecx, 0
  000e2	03 94 08 00 00
	00 00		 add	 edx, DWORD PTR ?g_RingMapPosition@@3PAY03HA[eax+ecx]
  000e9	89 55 f4	 mov	 DWORD PTR _iRandY$[ebp], edx

; 222  : 
; 223  : 			if (m_RingMonsterHerd[i].SetTotalInfo(g_RingEventMapNum[i], RINGEVENT_MIN_RADIUS, iRandX, iRandY)) {

  000ec	8b 45 f4	 mov	 eax, DWORD PTR _iRandY$[ebp]
  000ef	50		 push	 eax
  000f0	8b 4d f8	 mov	 ecx, DWORD PTR _iRandX$[ebp]
  000f3	51		 push	 ecx
  000f4	6a 03		 push	 3
  000f6	8b 55 f0	 mov	 edx, DWORD PTR _i$6[ebp]
  000f9	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?g_RingEventMapNum@@3PAHA[edx*4]
  00100	50		 push	 eax
  00101	6b 4d f0 44	 imul	 ecx, DWORD PTR _i$6[ebp], 68
  00105	6b 55 f0 44	 imul	 edx, DWORD PTR _i$6[ebp], 68
  00109	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0010c	8d 54 10 04	 lea	 edx, DWORD PTR [eax+edx+4]
  00110	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00113	8b 44 08 04	 mov	 eax, DWORD PTR [eax+ecx+4]
  00117	8b ca		 mov	 ecx, edx
  00119	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0011c	ff d2		 call	 edx
  0011e	85 c0		 test	 eax, eax
  00120	74 02		 je	 SHORT $LN13@StartEvent

; 224  : 				break;

  00122	eb 05		 jmp	 SHORT $LN6@StartEvent
$LN13@StartEvent:

; 225  : 			}
; 226  : 		}

  00124	e9 17 ff ff ff	 jmp	 $LN5@StartEvent
$LN6@StartEvent:

; 227  : 
; 228  : 		if (!iCount) {

  00129	83 7d ec 00	 cmp	 DWORD PTR _iCount$5[ebp], 0
  0012d	75 02		 jne	 SHORT $LN14@StartEvent

; 229  : 			//  
; 230  : 		}

  0012f	eb 4b		 jmp	 SHORT $LN15@StartEvent
$LN14@StartEvent:

; 231  : 		else {
; 232  : 			if (m_vtMonsterAddData.empty()) {

  00131	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00134	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  0013a	e8 00 00 00 00	 call	 ?empty@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE_NXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::empty
  0013f	0f b6 c0	 movzx	 eax, al
  00142	85 c0		 test	 eax, eax
  00144	74 15		 je	 SHORT $LN16@StartEvent

; 233  : 				//   . - 
; 234  : 				LogAddTD("[Ring Event] - Error : No Monster Data Exist");

  00146	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@EBKICF@?$FLRing?5Event?$FN?5?9?5Error?5?3?5No?5Monst@
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00151	83 c4 04	 add	 esp, 4

; 235  : 				continue;

  00154	e9 cd fe ff ff	 jmp	 $LN2@StartEvent

; 236  : 			}

  00159	eb 21		 jmp	 SHORT $LN15@StartEvent
$LN16@StartEvent:

; 237  : 			else {
; 238  : 				LogAddTD("[Ring Event] - Monster Start Position MapNumber:%d, X:%d, Y:%d", g_RingEventMapNum[i], iRandX, iRandY);

  0015b	8b 45 f4	 mov	 eax, DWORD PTR _iRandY$[ebp]
  0015e	50		 push	 eax
  0015f	8b 4d f8	 mov	 ecx, DWORD PTR _iRandX$[ebp]
  00162	51		 push	 ecx
  00163	8b 55 f0	 mov	 edx, DWORD PTR _i$6[ebp]
  00166	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?g_RingEventMapNum@@3PAHA[edx*4]
  0016d	50		 push	 eax
  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@FPIHCFEB@?$FLRing?5Event?$FN?5?9?5Monster?5Start?5Po@
  00173	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00179	83 c4 10	 add	 esp, 16			; 00000010H
$LN15@StartEvent:

; 239  : 			}
; 240  : 		}
; 241  : 
; 242  : 		EnterCriticalSection (& m_critMonsterAddData);

  0017c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0017f	05 10 01 00 00	 add	 eax, 272		; 00000110H
  00184	50		 push	 eax
  00185	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 243  : 		vector <RINGMONSTER_DATA>::iterator it = m_vtMonsterAddData.begin();

  0018b	8d 45 e8	 lea	 eax, DWORD PTR _it$4[ebp]
  0018e	50		 push	 eax
  0018f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00192	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00198	e8 00 00 00 00	 call	 ?begin@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::begin
  0019d	eb 0e		 jmp	 SHORT $LN9@StartEvent
$LN7@StartEvent:

; 244  : 
; 245  : 		for (;it!=m_vtMonsterAddData.end();it++) {

  0019f	6a 00		 push	 0
  001a1	8d 45 a0	 lea	 eax, DWORD PTR $T2[ebp]
  001a4	50		 push	 eax
  001a5	8d 4d e8	 lea	 ecx, DWORD PTR _it$4[ebp]
  001a8	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator++
$LN9@StartEvent:
  001ad	8d 45 9c	 lea	 eax, DWORD PTR $T1[ebp]
  001b0	50		 push	 eax
  001b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b4	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  001ba	e8 00 00 00 00	 call	 ?end@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::end
  001bf	50		 push	 eax
  001c0	8d 4d e8	 lea	 ecx, DWORD PTR _it$4[ebp]
  001c3	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator!=
  001c8	0f b6 c8	 movzx	 ecx, al
  001cb	85 c9		 test	 ecx, ecx
  001cd	74 63		 je	 SHORT $LN8@StartEvent

; 246  : 			RINGMONSTER_DATA & pRMD = *it;

  001cf	8d 4d e8	 lea	 ecx, DWORD PTR _it$4[ebp]
  001d2	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QBEAAURINGMONSTER_DATA@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >::operator*
  001d7	89 45 e4	 mov	 DWORD PTR _pRMD$3[ebp], eax

; 247  : 
; 248  : 			iCount = 100;

  001da	c7 45 ec 64 00
	00 00		 mov	 DWORD PTR _iCount$5[ebp], 100 ; 00000064H
$LN10@StartEvent:

; 249  : 			while (iCount--) {

  001e1	8b 45 ec	 mov	 eax, DWORD PTR _iCount$5[ebp]
  001e4	89 45 98	 mov	 DWORD PTR tv198[ebp], eax
  001e7	8b 4d ec	 mov	 ecx, DWORD PTR _iCount$5[ebp]
  001ea	83 e9 01	 sub	 ecx, 1
  001ed	89 4d ec	 mov	 DWORD PTR _iCount$5[ebp], ecx
  001f0	83 7d 98 00	 cmp	 DWORD PTR tv198[ebp], 0
  001f4	74 37		 je	 SHORT $LN11@StartEvent

; 250  : 				if (m_RingMonsterHerd[i].AddMonster(pRMD.m_iType, pRMD.m_bDoRegen, pRMD.m_bDoAttackFirst))

  001f6	8b 45 e4	 mov	 eax, DWORD PTR _pRMD$3[ebp]
  001f9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001fc	51		 push	 ecx
  001fd	8b 55 e4	 mov	 edx, DWORD PTR _pRMD$3[ebp]
  00200	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00203	50		 push	 eax
  00204	8b 4d e4	 mov	 ecx, DWORD PTR _pRMD$3[ebp]
  00207	8b 11		 mov	 edx, DWORD PTR [ecx]
  00209	52		 push	 edx
  0020a	6b 45 f0 44	 imul	 eax, DWORD PTR _i$6[ebp], 68
  0020e	6b 4d f0 44	 imul	 ecx, DWORD PTR _i$6[ebp], 68
  00212	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00215	8d 4c 0a 04	 lea	 ecx, DWORD PTR [edx+ecx+4]
  00219	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0021c	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00220	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00223	ff d2		 call	 edx
  00225	85 c0		 test	 eax, eax
  00227	74 02		 je	 SHORT $LN18@StartEvent

; 251  : 					break;

  00229	eb 02		 jmp	 SHORT $LN11@StartEvent
$LN18@StartEvent:

; 252  : 			}

  0022b	eb b4		 jmp	 SHORT $LN10@StartEvent
$LN11@StartEvent:

; 253  : 		}

  0022d	e9 6d ff ff ff	 jmp	 $LN7@StartEvent
$LN8@StartEvent:

; 254  : 		LeaveCriticalSection (& m_critMonsterAddData);

  00232	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00235	05 10 01 00 00	 add	 eax, 272		; 00000110H
  0023a	50		 push	 eax
  0023b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 255  : 
; 256  : 		m_RingMonsterHerd[i].Start();

  00241	6b 45 f0 44	 imul	 eax, DWORD PTR _i$6[ebp], 68
  00245	6b 4d f0 44	 imul	 ecx, DWORD PTR _i$6[ebp], 68
  00249	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0024c	8d 4c 0a 04	 lea	 ecx, DWORD PTR [edx+ecx+4]
  00250	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00253	8b 44 02 04	 mov	 eax, DWORD PTR [edx+eax+4]
  00257	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0025a	ff d2		 call	 edx

; 257  : 	}

  0025c	e9 c5 fd ff ff	 jmp	 $LN2@StartEvent
$LN1@StartEvent:

; 258  : }

  00261	5f		 pop	 edi
  00262	5e		 pop	 esi
  00263	5b		 pop	 ebx
  00264	8b e5		 mov	 esp, ebp
  00266	5d		 pop	 ebp
  00267	c3		 ret	 0
?StartEvent@CRingAttackEvent@@QAEXXZ ENDP		; CRingAttackEvent::StartEvent
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ??1CRingAttackEvent@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CRingAttackEvent@@UAE@XZ PROC			; CRingAttackEvent::~CRingAttackEvent, COMDAT
; _this$ = ecx

; 185  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CRingAttackEvent@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CRingAttackEvent@@6B@

; 186  : 	DeleteCriticalSection (& m_critMonsterAddData);

  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	05 10 01 00 00	 add	 eax, 272		; 00000110H
  0003c	50		 push	 eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 187  : }

  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	81 c1 28 01 00
	00		 add	 ecx, 296		; 00000128H
  0004c	e8 00 00 00 00	 call	 ??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::~vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >
  00051	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  0005a	e8 00 00 00 00	 call	 ??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::~vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
  0005f	68 00 00 00 00	 push	 OFFSET ??1CRingMonsterHerd@@UAE@XZ ; CRingMonsterHerd::~CRingMonsterHerd
  00064	6a 03		 push	 3
  00066	6a 44		 push	 68			; 00000044H
  00068	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	83 c0 04	 add	 eax, 4
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00074	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00077	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007e	59		 pop	 ecx
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
  00086	cc		 int	 3
  00087	cc		 int	 3
  00088	cc		 int	 3
  00089	cc		 int	 3
  0008a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CRingAttackEvent@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CRingAttackEvent@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CRingAttackEvent@@UAE@XZ ENDP			; CRingAttackEvent::~CRingAttackEvent
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ??0CRingAttackEvent@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRingAttackEvent@@QAE@XZ PROC			; CRingAttackEvent::CRingAttackEvent, COMDAT
; _this$ = ecx

; 173  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CRingAttackEvent@@6B@
  00015	68 00 00 00 00	 push	 OFFSET ??1CRingMonsterHerd@@UAE@XZ ; CRingMonsterHerd::~CRingMonsterHerd
  0001a	68 00 00 00 00	 push	 OFFSET ??0CRingMonsterHerd@@QAE@XZ ; CRingMonsterHerd::CRingMonsterHerd
  0001f	6a 03		 push	 3
  00021	6a 44		 push	 68			; 00000044H
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 c0 04	 add	 eax, 4
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00038	e8 00 00 00 00	 call	 ??0?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	81 c1 28 01 00
	00		 add	 ecx, 296		; 00000128H
  00046	e8 00 00 00 00	 call	 ??0?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >

; 174  : 	m_bDoEvent = FALSE;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	c7 80 d0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+208], 0

; 175  : 	m_bHasData = FALSE;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 80 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+212], 0

; 176  : 
; 177  : 	m_iRADIUS_MIN = RINGEVENT_MIN_RADIUS;

  00065	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00068	c7 80 fc 00 00
	00 03 00 00 00	 mov	 DWORD PTR [eax+252], 3

; 178  : 	m_iRADIUS_MAX = RINGEVENT_MAX_RADIUS;

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c7 80 00 01 00
	00 06 00 00 00	 mov	 DWORD PTR [eax+256], 6

; 179  : 	m_iMOVE_RAND_SIZE = RINGEVENT_MAX_MOVE;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00082	c7 80 f8 00 00
	00 0f 00 00 00	 mov	 DWORD PTR [eax+248], 15	; 0000000fH

; 180  : 
; 181  : 	InitializeCriticalSection (& m_critMonsterAddData);

  0008c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	05 10 01 00 00	 add	 eax, 272		; 00000110H
  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 182  : }

  0009b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
??0CRingAttackEvent@@QAE@XZ ENDP			; CRingAttackEvent::CRingAttackEvent
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@2@$00@std@@QBEABV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@2@$00@std@@QBEABV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<RINGMONSTER_EVENT_TIME>,std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1348 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1349 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@2@$00@std@@QBEABV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<RINGMONSTER_EVENT_TIME>,std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@2@$00@std@@QAEAAV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@2@$00@std@@QAEAAV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<RINGMONSTER_EVENT_TIME>,std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1344 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1345 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@2@$00@std@@QAEAAV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<RINGMONSTER_EVENT_TIME>,std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@ABEABV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@ABEABV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Getal, COMDAT
; _this$ = ecx

; 1735 :     const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1736 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@2@$00@std@@QBEABV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ; std::_Compressed_pair<std::allocator<RINGMONSTER_EVENT_TIME>,std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >,1>::_Get_first

; 1737 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@ABEABV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Getal, COMDAT
; _this$ = ecx

; 1731 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1732 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@2@$00@std@@QAEAAV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ; std::_Compressed_pair<std::allocator<RINGMONSTER_EVENT_TIME>,std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >,1>::_Get_first

; 1733 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Orphan_range@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@ABEXPAURINGMONSTER_EVENT_TIME@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@ABEXPAURINGMONSTER_EVENT_TIME@@0@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1711 :     void _Orphan_range(pointer _First, pointer _Last) const { // orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1712 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1713 :         _Lockit _Lock(_LOCK_DEBUG);
; 1714 : 
; 1715 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;
; 1716 :         while (*_Pnext) {
; 1717 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 1718 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator
; 1719 :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 1720 :             } else { // orphan the iterator
; 1721 :                 (*_Pnext)->_Myproxy = nullptr;
; 1722 :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 1723 :             }
; 1724 :         }
; 1725 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1726 :         (void) _First;
; 1727 :         (void) _Last;
; 1728 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1729 :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@ABEXPAURINGMONSTER_EVENT_TIME@@0@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@CAXXZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Xlength, COMDAT

; 1703 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1704 :         _Xlength_error("vector too long");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  0000e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1705 :     }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Xlength@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@CAXXZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Tidy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -32						; size = 4
__Mylast$ = -28						; size = 4
__Myfirst$ = -24					; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXXZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Tidy, COMDAT
; _this$ = ecx

; 1685 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1686 :         auto& _My_data    = _Mypair._Myval2;

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 1687 :         pointer& _Myfirst = _My_data._Myfirst;

  00031	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00034	89 45 e8	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1688 :         pointer& _Mylast  = _My_data._Mylast;

  00037	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003a	83 c0 04	 add	 eax, 4
  0003d	89 45 e4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1689 :         pointer& _Myend   = _My_data._Myend;

  00040	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00043	83 c0 08	 add	 eax, 8
  00046	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1690 : 
; 1691 :         _My_data._Orphan_all();

  00049	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1692 : 
; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00054	83 38 00	 cmp	 DWORD PTR [eax], 0
  00057	74 52		 je	 SHORT $LN3@Tidy

; 1694 :             _Destroy(_Myfirst, _Mylast);

  00059	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	51		 push	 ecx
  0005f	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00062	8b 02		 mov	 eax, DWORD PTR [edx]
  00064	50		 push	 eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Destroy

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0006d	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00070	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00073	8b 10		 mov	 edx, DWORD PTR [eax]
  00075	2b 11		 sub	 edx, DWORD PTR [ecx]
  00077	c1 fa 03	 sar	 edx, 3
  0007a	52		 push	 edx
  0007b	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00080	51		 push	 ecx
  00081	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ?_Getal@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Getal
  00089	8b c8		 mov	 ecx, eax
  0008b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXQAURINGMONSTER_EVENT_TIME@@I@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::deallocate

; 1696 : 
; 1697 :             _Myfirst = pointer();

  00090	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00093	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1698 :             _Mylast  = pointer();

  00099	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1699 :             _Myend   = pointer();

  000a2	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a5	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1700 :         }
; 1701 :     }

  000ab	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ae	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b5	59		 pop	 ecx
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
  000bd	cc		 int	 3
  000be	cc		 int	 3
  000bf	cc		 int	 3
  000c0	cc		 int	 3
  000c1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXXZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Tidy
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Change_array@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXQAURINGMONSTER_EVENT_TIME@@II@Z
_TEXT	SEGMENT
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
__Myfirst$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXQAURINGMONSTER_EVENT_TIME@@II@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Change_array, COMDAT
; _this$ = ecx

; 1666 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1667 :         // orphan all iterators, discard old array, acquire new array
; 1668 :         auto& _My_data    = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1669 :         pointer& _Myfirst = _My_data._Myfirst;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1670 :         pointer& _Mylast  = _My_data._Mylast;

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001b	83 c0 04	 add	 eax, 4
  0001e	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1671 :         pointer& _Myend   = _My_data._Myend;

  00021	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00024	83 c0 08	 add	 eax, 8
  00027	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1672 : 
; 1673 :         _My_data._Orphan_all();

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1674 : 
; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00032	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00035	83 38 00	 cmp	 DWORD PTR [eax], 0
  00038	74 37		 je	 SHORT $LN2@Change_arr

; 1676 :             _Destroy(_Myfirst, _Mylast);

  0003a	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	51		 push	 ecx
  00040	8b 55 f4	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00043	8b 02		 mov	 eax, DWORD PTR [edx]
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Destroy

; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0004e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	2b 11		 sub	 edx, DWORD PTR [ecx]
  00058	c1 fa 03	 sar	 edx, 3
  0005b	52		 push	 edx
  0005c	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	51		 push	 ecx
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	e8 00 00 00 00	 call	 ?_Getal@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Getal
  0006a	8b c8		 mov	 ecx, eax
  0006c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXQAURINGMONSTER_EVENT_TIME@@I@Z ; std::allocator<RINGMONSTER_EVENT_TIME>::deallocate
$LN2@Change_arr:

; 1678 :         }
; 1679 : 
; 1680 :         _Myfirst = _Newvec;

  00071	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00077	89 08		 mov	 DWORD PTR [eax], ecx

; 1681 :         _Mylast  = _Newvec + _Newsize;

  00079	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0007c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0007f	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00082	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00085	89 10		 mov	 DWORD PTR [eax], edx

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  00087	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0008a	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0008d	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00090	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00093	89 10		 mov	 DWORD PTR [eax], edx

; 1683 :     }

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXQAURINGMONSTER_EVENT_TIME@@II@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Calculate_growth@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Geometric$ = -12					; size = 4
__Oldcapacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@ABEII@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1618 : 
; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Oldcapacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	39 45 f8	 cmp	 DWORD PTR __Oldcapacity$[ebp], eax
  00029	76 05		 jbe	 SHORT $LN2@Calculate_

; 1620 :             return _Newsize; // geometric growth would overflow

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0002e	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00030	8b 45 f8	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 f8	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00038	89 45 f4	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0003b	8b 45 f4	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0003e	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00041	73 05		 jae	 SHORT $LN3@Calculate_

; 1626 :             return _Newsize; // geometric growth would be insufficient

  00043	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00046	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1627 :         }
; 1628 : 
; 1629 :         return _Geometric; // geometric growth is sufficient

  00048	8b 45 f4	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1630 :     }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@ABEII@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Destroy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@0@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAXPAURINGMONSTER_EVENT_TIME@@QAU1@AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z ; std::_Destroy_range<std::allocator<RINGMONSTER_EVENT_TIME> >
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?_Destroy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@0@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@00@Z
_TEXT	SEGMENT
$T1 = -69						; size = 1
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@00@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1605 :     void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1606 :         // move_if_noexcept [_First, _Last) to raw _Dest, using allocator
; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  0000c	33 c0		 xor	 eax, eax
  0000e	88 45 bb	 mov	 BYTE PTR $T1[ebp], al
  00011	0f b6 4d bb	 movzx	 ecx, BYTE PTR $T1[ebp]
  00015	51		 push	 ecx
  00016	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00021	51		 push	 ecx
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Umove_if_noexcept1@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@00U?$integral_constant@_N$00@2@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove_if_noexcept1

; 1608 :             bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
; 1609 :     }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@00@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1595 :     void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1596 :         // move [_First, _Last) to raw _Dest, using allocator
; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAURINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAPAURINGMONSTER_EVENT_TIME@@QAU1@0PAU1@AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z ; std::_Uninitialized_move<RINGMONSTER_EVENT_TIME *,std::allocator<RINGMONSTER_EVENT_TIME> >
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 1598 :     }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEPAURINGMONSTER_EVENT_TIME@@PAU3@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEPAURINGMONSTER_EVENT_TIME@@PAU3@00@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove, COMDAT
; _this$ = ecx

; 1591 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAURINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@YAPAURINGMONSTER_EVENT_TIME@@QAU1@0PAU1@AAV?$allocator@URINGMONSTER_EVENT_TIME@@@0@@Z ; std::_Uninitialized_move<RINGMONSTER_EVENT_TIME *,std::allocator<RINGMONSTER_EVENT_TIME> >
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 1593 :     }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?_Umove@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEPAURINGMONSTER_EVENT_TIME@@PAU3@00@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Umove
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?capacity@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::capacity, COMDAT
; _this$ = ecx

; 1492 :     _NODISCARD size_type capacity() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001d	c1 f8 03	 sar	 eax, 3

; 1495 :     }

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?capacity@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?max_size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
_this$ = -4						; size = 4
?max_size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::max_size, COMDAT
; _this$ = ecx

; 1487 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1488 :         return (_STD min)(

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@ABEABV?$allocator@URINGMONSTER_EVENT_TIME@@@2@XZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Getal
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@SAIABV?$allocator@URINGMONSTER_EVENT_TIME@@@2@@Z ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_EVENT_TIME> >::max_size
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
  00020	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00025	89 45 b4	 mov	 DWORD PTR $T1[ebp], eax
  00028	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  0002b	50		 push	 eax
  0002c	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00035	83 c4 08	 add	 esp, 8
  00038	8b 00		 mov	 eax, DWORD PTR [eax]

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?max_size@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBEIXZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?empty@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv69 = -76						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?empty@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE_NXZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::empty, COMDAT
; _this$ = ecx

; 1477 :     _NODISCARD bool empty() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1478 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0001d	75 09		 jne	 SHORT $LN3@empty
  0001f	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN4@empty
$LN3@empty:
  00028	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@empty:
  0002f	8a 45 b4	 mov	 al, BYTE PTR tv69[ebp]

; 1480 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?empty@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QBE_NXZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?end@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::end, COMDAT
; _this$ = ecx

; 1419 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >
  0001b	83 c4 04	 add	 esp, 4
  0001e	50		 push	 eax
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00022	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00025	52		 push	 edx
  00026	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1422 :     }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?end@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?begin@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::begin, COMDAT
; _this$ = ecx

; 1409 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >
  0001b	83 c4 04	 add	 esp, 4
  0001e	50		 push	 eax
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	52		 push	 edx
  00025	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00028	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1412 :     }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?begin@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@XZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?erase@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
__Newlast$2 = -36					; size = 4
__Mylast$ = -32						; size = 4
__My_data$ = -28					; size = 4
__Lastptr$ = -24					; size = 4
__Firstptr$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::erase, COMDAT
; _this$ = ecx

; 1360 :         is_nothrow_move_assignable_v<value_type>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?erase@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1361 :         const pointer _Firstptr = _First._Ptr;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __Firstptr$[ebp], eax

; 1362 :         const pointer _Lastptr  = _Last._Ptr;

  00031	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00034	89 45 e8	 mov	 DWORD PTR __Lastptr$[ebp], eax

; 1363 :         auto& _My_data          = _Mypair._Myval2;

  00037	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1364 :         pointer& _Mylast        = _My_data._Mylast;

  0003d	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00040	83 c0 04	 add	 eax, 4
  00043	89 45 e0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1365 : 
; 1366 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1367 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) && _Last._Getcont() == _STD addressof(_My_data)
; 1368 :                         && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr,
; 1369 :             "vector erase iterator outside range");
; 1370 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1371 : 
; 1372 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

  00046	8b 45 ec	 mov	 eax, DWORD PTR __Firstptr$[ebp]
  00049	3b 45 e8	 cmp	 eax, DWORD PTR __Lastptr$[ebp]
  0004c	74 45		 je	 SHORT $LN2@erase

; 1373 :             _Orphan_range(_Firstptr, _Mylast);

  0004e	8b 45 e0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	51		 push	 ecx
  00054	8b 55 ec	 mov	 edx, DWORD PTR __Firstptr$[ebp]
  00057	52		 push	 edx
  00058	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@ABEXPAURINGMONSTER_EVENT_TIME@@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Orphan_range

; 1374 : 
; 1375 :             const pointer _Newlast = _Move_unchecked(_Lastptr, _Mylast, _Firstptr);

  00060	8b 45 ec	 mov	 eax, DWORD PTR __Firstptr$[ebp]
  00063	50		 push	 eax
  00064	8b 4d e0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00067	8b 11		 mov	 edx, DWORD PTR [ecx]
  00069	52		 push	 edx
  0006a	8b 45 e8	 mov	 eax, DWORD PTR __Lastptr$[ebp]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ??$_Move_unchecked@PAURINGMONSTER_EVENT_TIME@@PAU1@@std@@YAPAURINGMONSTER_EVENT_TIME@@PAU1@00@Z ; std::_Move_unchecked<RINGMONSTER_EVENT_TIME *,RINGMONSTER_EVENT_TIME *>
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	89 45 dc	 mov	 DWORD PTR __Newlast$2[ebp], eax

; 1376 :             _Destroy(_Newlast, _Mylast);

  00079	8b 45 e0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0007c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007e	51		 push	 ecx
  0007f	8b 55 dc	 mov	 edx, DWORD PTR __Newlast$2[ebp]
  00082	52		 push	 edx
  00083	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXPAURINGMONSTER_EVENT_TIME@@0@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Destroy

; 1377 :             _Mylast = _Newlast;

  0008b	8b 45 e0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0008e	8b 4d dc	 mov	 ecx, DWORD PTR __Newlast$2[ebp]
  00091	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@erase:

; 1378 :         }
; 1379 : 
; 1380 :         return iterator(_Firstptr, _STD addressof(_My_data));

  00093	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> > >
  0009c	83 c4 04	 add	 esp, 4
  0009f	50		 push	 eax
  000a0	8b 4d ec	 mov	 ecx, DWORD PTR __Firstptr$[ebp]
  000a3	51		 push	 ecx
  000a4	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a7	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@std@@QAE@PAURINGMONSTER_EVENT_TIME@@PBU_Container_base0@1@@Z
  000ac	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1381 :     }

  000af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b9	59		 pop	 ecx
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 0c 00	 ret	 12			; 0000000cH
  000c3	cc		 int	 3
  000c4	cc		 int	 3
  000c5	cc		 int	 3
  000c6	cc		 int	 3
  000c7	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?erase@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?erase@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@std@@@2@0@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::erase
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?push_back@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXABURINGMONSTER_EVENT_TIME@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXABURINGMONSTER_EVENT_TIME@@@Z PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::push_back, COMDAT
; _this$ = ecx

; 716  :     void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 717  :         emplace_back(_Val);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$emplace_back@ABURINGMONSTER_EVENT_TIME@@@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@ABURINGMONSTER_EVENT_TIME@@@Z ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::emplace_back<RINGMONSTER_EVENT_TIME const &>

; 718  :     }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?push_back@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAEXABURINGMONSTER_EVENT_TIME@@@Z ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::~vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Tidy@?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@AAEXXZ ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::~vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -70						; size = 1
$T2 = -69						; size = 1
_this$ = -4						; size = 4
??0?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ PROC ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >, COMDAT
; _this$ = ecx

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	0f b6 45 bb	 movzx	 eax, BYTE PTR $T2[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_EVENT_TIME@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<RINGMONSTER_EVENT_TIME>,std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >,1>::_Compressed_pair<std::allocator<RINGMONSTER_EVENT_TIME>,std::_Vector_val<std::_Simple_types<RINGMONSTER_EVENT_TIME> >,1><>

; 446  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00019	8d 45 ba	 lea	 eax, DWORD PTR $T1[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 447  :     }

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??0?$vector@URINGMONSTER_EVENT_TIME@@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@QAE@XZ ENDP ; std::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >::vector<RINGMONSTER_EVENT_TIME,std::allocator<RINGMONSTER_EVENT_TIME> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@SAIABV?$allocator@URINGMONSTER_EVENT_TIME@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@SAIABV?$allocator@URINGMONSTER_EVENT_TIME@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_EVENT_TIME> >::max_size, COMDAT

; 702  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 703  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00009	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 704  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_EVENT_TIME@@@std@@@std@@SAIABV?$allocator@URINGMONSTER_EVENT_TIME@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_EVENT_TIME> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?allocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@I@Z PROC ; std::allocator<RINGMONSTER_EVENT_TIME>::allocate, COMDAT
; _this$ = ecx

; 806  :     _NODISCARD __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$07@std@@YAII@Z ; std::_Get_size_of_n<8>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0001e	83 c4 04	 add	 esp, 4

; 808  :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEPAURINGMONSTER_EVENT_TIME@@I@Z ENDP ; std::allocator<RINGMONSTER_EVENT_TIME>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXQAURINGMONSTER_EVENT_TIME@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXQAURINGMONSTER_EVENT_TIME@@I@Z PROC ; std::allocator<RINGMONSTER_EVENT_TIME>::deallocate, COMDAT
; _this$ = ecx

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	c1 e0 03	 shl	 eax, 3
  00012	50		 push	 eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001c	83 c4 08	 add	 esp, 8

; 804  :     }

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?deallocate@?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAEXQAURINGMONSTER_EVENT_TIME@@I@Z ENDP ; std::allocator<RINGMONSTER_EVENT_TIME>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAE@XZ PROC ; std::allocator<RINGMONSTER_EVENT_TIME>::allocator<RINGMONSTER_EVENT_TIME>, COMDAT
; _this$ = ecx

; 795  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@URINGMONSTER_EVENT_TIME@@@std@@QAE@XZ ENDP ; std::allocator<RINGMONSTER_EVENT_TIME>::allocator<RINGMONSTER_EVENT_TIME>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_DATA@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@2@$00@std@@QBEABV?$allocator@URINGMONSTER_DATA@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_DATA@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@2@$00@std@@QBEABV?$allocator@URINGMONSTER_DATA@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<RINGMONSTER_DATA>,std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1348 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1349 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_DATA@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@2@$00@std@@QBEABV?$allocator@URINGMONSTER_DATA@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<RINGMONSTER_DATA>,std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_DATA@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@2@$00@std@@QAEAAV?$allocator@URINGMONSTER_DATA@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_DATA@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@2@$00@std@@QAEAAV?$allocator@URINGMONSTER_DATA@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<RINGMONSTER_DATA>,std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1344 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1345 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_DATA@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@2@$00@std@@QAEAAV?$allocator@URINGMONSTER_DATA@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<RINGMONSTER_DATA>,std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@ABEABV?$allocator@URINGMONSTER_DATA@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@ABEABV?$allocator@URINGMONSTER_DATA@@@2@XZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Getal, COMDAT
; _this$ = ecx

; 1735 :     const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1736 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_DATA@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@2@$00@std@@QBEABV?$allocator@URINGMONSTER_DATA@@@2@XZ ; std::_Compressed_pair<std::allocator<RINGMONSTER_DATA>,std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >,1>::_Get_first

; 1737 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@ABEABV?$allocator@URINGMONSTER_DATA@@@2@XZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_DATA@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_DATA@@@2@XZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Getal, COMDAT
; _this$ = ecx

; 1731 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1732 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@URINGMONSTER_DATA@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@2@$00@std@@QAEAAV?$allocator@URINGMONSTER_DATA@@@2@XZ ; std::_Compressed_pair<std::allocator<RINGMONSTER_DATA>,std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >,1>::_Get_first

; 1733 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_DATA@@@2@XZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Orphan_range@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@ABEXPAURINGMONSTER_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@ABEXPAURINGMONSTER_DATA@@0@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1711 :     void _Orphan_range(pointer _First, pointer _Last) const { // orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1712 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1713 :         _Lockit _Lock(_LOCK_DEBUG);
; 1714 : 
; 1715 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;
; 1716 :         while (*_Pnext) {
; 1717 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 1718 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator
; 1719 :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 1720 :             } else { // orphan the iterator
; 1721 :                 (*_Pnext)->_Myproxy = nullptr;
; 1722 :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 1723 :             }
; 1724 :         }
; 1725 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1726 :         (void) _First;
; 1727 :         (void) _Last;
; 1728 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1729 :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@ABEXPAURINGMONSTER_DATA@@0@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@CAXXZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Xlength, COMDAT

; 1703 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1704 :         _Xlength_error("vector too long");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  0000e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1705 :     }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Xlength@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@CAXXZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Tidy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -32						; size = 4
__Mylast$ = -28						; size = 4
__Myfirst$ = -24					; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXXZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Tidy, COMDAT
; _this$ = ecx

; 1685 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1686 :         auto& _My_data    = _Mypair._Myval2;

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 1687 :         pointer& _Myfirst = _My_data._Myfirst;

  00031	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00034	89 45 e8	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1688 :         pointer& _Mylast  = _My_data._Mylast;

  00037	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003a	83 c0 04	 add	 eax, 4
  0003d	89 45 e4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1689 :         pointer& _Myend   = _My_data._Myend;

  00040	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00043	83 c0 08	 add	 eax, 8
  00046	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1690 : 
; 1691 :         _My_data._Orphan_all();

  00049	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1692 : 
; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00054	83 38 00	 cmp	 DWORD PTR [eax], 0
  00057	74 57		 je	 SHORT $LN3@Tidy

; 1694 :             _Destroy(_Myfirst, _Mylast);

  00059	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	51		 push	 ecx
  0005f	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00062	8b 02		 mov	 eax, DWORD PTR [edx]
  00064	50		 push	 eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Destroy

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0006d	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00070	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00073	8b 00		 mov	 eax, DWORD PTR [eax]
  00075	2b 01		 sub	 eax, DWORD PTR [ecx]
  00077	99		 cdq
  00078	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0007d	f7 f9		 idiv	 ecx
  0007f	50		 push	 eax
  00080	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
  00085	50		 push	 eax
  00086	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?_Getal@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_DATA@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Getal
  0008e	8b c8		 mov	 ecx, eax
  00090	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEXQAURINGMONSTER_DATA@@I@Z ; std::allocator<RINGMONSTER_DATA>::deallocate

; 1696 : 
; 1697 :             _Myfirst = pointer();

  00095	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00098	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1698 :             _Mylast  = pointer();

  0009e	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a1	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1699 :             _Myend   = pointer();

  000a7	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000aa	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1700 :         }
; 1701 :     }

  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
  000c2	cc		 int	 3
  000c3	cc		 int	 3
  000c4	cc		 int	 3
  000c5	cc		 int	 3
  000c6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXXZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Tidy
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Change_array@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXQAURINGMONSTER_DATA@@II@Z
_TEXT	SEGMENT
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
__Myfirst$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXQAURINGMONSTER_DATA@@II@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Change_array, COMDAT
; _this$ = ecx

; 1666 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1667 :         // orphan all iterators, discard old array, acquire new array
; 1668 :         auto& _My_data    = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1669 :         pointer& _Myfirst = _My_data._Myfirst;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1670 :         pointer& _Mylast  = _My_data._Mylast;

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001b	83 c0 04	 add	 eax, 4
  0001e	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1671 :         pointer& _Myend   = _My_data._Myend;

  00021	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00024	83 c0 08	 add	 eax, 8
  00027	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1672 : 
; 1673 :         _My_data._Orphan_all();

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1674 : 
; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00032	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00035	83 38 00	 cmp	 DWORD PTR [eax], 0
  00038	74 3c		 je	 SHORT $LN2@Change_arr

; 1676 :             _Destroy(_Myfirst, _Mylast);

  0003a	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	51		 push	 ecx
  00040	8b 55 f4	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00043	8b 02		 mov	 eax, DWORD PTR [edx]
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Destroy

; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0004e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]
  00056	2b 01		 sub	 eax, DWORD PTR [ecx]
  00058	99		 cdq
  00059	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0005e	f7 f9		 idiv	 ecx
  00060	50		 push	 eax
  00061	8b 55 f4	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00064	8b 02		 mov	 eax, DWORD PTR [edx]
  00066	50		 push	 eax
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?_Getal@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_DATA@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Getal
  0006f	8b c8		 mov	 ecx, eax
  00071	e8 00 00 00 00	 call	 ?deallocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEXQAURINGMONSTER_DATA@@I@Z ; std::allocator<RINGMONSTER_DATA>::deallocate
$LN2@Change_arr:

; 1678 :         }
; 1679 : 
; 1680 :         _Myfirst = _Newvec;

  00076	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00079	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0007c	89 08		 mov	 DWORD PTR [eax], ecx

; 1681 :         _Mylast  = _Newvec + _Newsize;

  0007e	6b 45 0c 0c	 imul	 eax, DWORD PTR __Newsize$[ebp], 12
  00082	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  00085	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00088	89 01		 mov	 DWORD PTR [ecx], eax

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  0008a	6b 45 10 0c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 12
  0008e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  00091	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  00094	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :     }

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXQAURINGMONSTER_DATA@@II@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Calculate_growth@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Geometric$ = -12					; size = 4
__Oldcapacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@ABEII@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1618 : 
; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Oldcapacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	39 45 f8	 cmp	 DWORD PTR __Oldcapacity$[ebp], eax
  00029	76 05		 jbe	 SHORT $LN2@Calculate_

; 1620 :             return _Newsize; // geometric growth would overflow

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0002e	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00030	8b 45 f8	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 f8	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00038	89 45 f4	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0003b	8b 45 f4	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0003e	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00041	73 05		 jae	 SHORT $LN3@Calculate_

; 1626 :             return _Newsize; // geometric growth would be insufficient

  00043	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00046	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1627 :         }
; 1628 : 
; 1629 :         return _Geometric; // geometric growth is sufficient

  00048	8b 45 f4	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1630 :     }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@ABEII@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Destroy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@0@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_DATA@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAXPAURINGMONSTER_DATA@@QAU1@AAV?$allocator@URINGMONSTER_DATA@@@0@@Z ; std::_Destroy_range<std::allocator<RINGMONSTER_DATA> >
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?_Destroy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@0@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@00@Z
_TEXT	SEGMENT
$T1 = -69						; size = 1
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@00@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1605 :     void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1606 :         // move_if_noexcept [_First, _Last) to raw _Dest, using allocator
; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  0000c	33 c0		 xor	 eax, eax
  0000e	88 45 bb	 mov	 BYTE PTR $T1[ebp], al
  00011	0f b6 4d bb	 movzx	 ecx, BYTE PTR $T1[ebp]
  00015	51		 push	 ecx
  00016	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00021	51		 push	 ecx
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Umove_if_noexcept1@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@00U?$integral_constant@_N$00@2@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove_if_noexcept1

; 1608 :             bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
; 1609 :     }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@00@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1595 :     void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1596 :         // move [_First, _Last) to raw _Dest, using allocator
; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_DATA@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAURINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAPAURINGMONSTER_DATA@@QAU1@0PAU1@AAV?$allocator@URINGMONSTER_DATA@@@0@@Z ; std::_Uninitialized_move<RINGMONSTER_DATA *,std::allocator<RINGMONSTER_DATA> >
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 1598 :     }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEPAURINGMONSTER_DATA@@PAU3@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEPAURINGMONSTER_DATA@@PAU3@00@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove, COMDAT
; _this$ = ecx

; 1591 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEAAV?$allocator@URINGMONSTER_DATA@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAURINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@YAPAURINGMONSTER_DATA@@QAU1@0PAU1@AAV?$allocator@URINGMONSTER_DATA@@@0@@Z ; std::_Uninitialized_move<RINGMONSTER_DATA *,std::allocator<RINGMONSTER_DATA> >
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 1593 :     }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?_Umove@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEPAURINGMONSTER_DATA@@PAU3@00@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Umove
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?capacity@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::capacity, COMDAT
; _this$ = ecx

; 1492 :     _NODISCARD size_type capacity() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001d	99		 cdq
  0001e	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00023	f7 f9		 idiv	 ecx

; 1495 :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?capacity@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?max_size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
_this$ = -4						; size = 4
?max_size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::max_size, COMDAT
; _this$ = ecx

; 1487 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1488 :         return (_STD min)(

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@ABEABV?$allocator@URINGMONSTER_DATA@@@2@XZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Getal
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@SAIABV?$allocator@URINGMONSTER_DATA@@@2@@Z ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_DATA> >::max_size
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
  00020	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00025	89 45 b4	 mov	 DWORD PTR $T1[ebp], eax
  00028	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  0002b	50		 push	 eax
  0002c	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00035	83 c4 08	 add	 esp, 8
  00038	8b 00		 mov	 eax, DWORD PTR [eax]

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?max_size@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBEIXZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?empty@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv69 = -76						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?empty@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE_NXZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::empty, COMDAT
; _this$ = ecx

; 1477 :     _NODISCARD bool empty() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1478 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0001d	75 09		 jne	 SHORT $LN3@empty
  0001f	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN4@empty
$LN3@empty:
  00028	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@empty:
  0002f	8a 45 b4	 mov	 al, BYTE PTR tv69[ebp]

; 1480 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?empty@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QBE_NXZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?end@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::end, COMDAT
; _this$ = ecx

; 1419 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >
  0001b	83 c4 04	 add	 esp, 4
  0001e	50		 push	 eax
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00022	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00025	52		 push	 edx
  00026	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1422 :     }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?end@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?begin@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@XZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::begin, COMDAT
; _this$ = ecx

; 1409 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >
  0001b	83 c4 04	 add	 esp, 4
  0001e	50		 push	 eax
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	52		 push	 edx
  00025	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00028	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1412 :     }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?begin@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@XZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?erase@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
__Newlast$2 = -36					; size = 4
__Mylast$ = -32						; size = 4
__My_data$ = -28					; size = 4
__Lastptr$ = -24					; size = 4
__Firstptr$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@0@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::erase, COMDAT
; _this$ = ecx

; 1360 :         is_nothrow_move_assignable_v<value_type>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?erase@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1361 :         const pointer _Firstptr = _First._Ptr;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __Firstptr$[ebp], eax

; 1362 :         const pointer _Lastptr  = _Last._Ptr;

  00031	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00034	89 45 e8	 mov	 DWORD PTR __Lastptr$[ebp], eax

; 1363 :         auto& _My_data          = _Mypair._Myval2;

  00037	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1364 :         pointer& _Mylast        = _My_data._Mylast;

  0003d	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00040	83 c0 04	 add	 eax, 4
  00043	89 45 e0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1365 : 
; 1366 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1367 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) && _Last._Getcont() == _STD addressof(_My_data)
; 1368 :                         && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr,
; 1369 :             "vector erase iterator outside range");
; 1370 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1371 : 
; 1372 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

  00046	8b 45 ec	 mov	 eax, DWORD PTR __Firstptr$[ebp]
  00049	3b 45 e8	 cmp	 eax, DWORD PTR __Lastptr$[ebp]
  0004c	74 45		 je	 SHORT $LN2@erase

; 1373 :             _Orphan_range(_Firstptr, _Mylast);

  0004e	8b 45 e0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	51		 push	 ecx
  00054	8b 55 ec	 mov	 edx, DWORD PTR __Firstptr$[ebp]
  00057	52		 push	 edx
  00058	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@ABEXPAURINGMONSTER_DATA@@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Orphan_range

; 1374 : 
; 1375 :             const pointer _Newlast = _Move_unchecked(_Lastptr, _Mylast, _Firstptr);

  00060	8b 45 ec	 mov	 eax, DWORD PTR __Firstptr$[ebp]
  00063	50		 push	 eax
  00064	8b 4d e0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00067	8b 11		 mov	 edx, DWORD PTR [ecx]
  00069	52		 push	 edx
  0006a	8b 45 e8	 mov	 eax, DWORD PTR __Lastptr$[ebp]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ??$_Move_unchecked@PAURINGMONSTER_DATA@@PAU1@@std@@YAPAURINGMONSTER_DATA@@PAU1@00@Z ; std::_Move_unchecked<RINGMONSTER_DATA *,RINGMONSTER_DATA *>
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	89 45 dc	 mov	 DWORD PTR __Newlast$2[ebp], eax

; 1376 :             _Destroy(_Newlast, _Mylast);

  00079	8b 45 e0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0007c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007e	51		 push	 ecx
  0007f	8b 55 dc	 mov	 edx, DWORD PTR __Newlast$2[ebp]
  00082	52		 push	 edx
  00083	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Destroy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXPAURINGMONSTER_DATA@@0@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Destroy

; 1377 :             _Mylast = _Newlast;

  0008b	8b 45 e0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0008e	8b 4d dc	 mov	 ecx, DWORD PTR __Newlast$2[ebp]
  00091	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@erase:

; 1378 :         }
; 1379 : 
; 1380 :         return iterator(_Firstptr, _STD addressof(_My_data));

  00093	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00096	50		 push	 eax
  00097	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> > >
  0009c	83 c4 04	 add	 esp, 4
  0009f	50		 push	 eax
  000a0	8b 4d ec	 mov	 ecx, DWORD PTR __Firstptr$[ebp]
  000a3	51		 push	 ecx
  000a4	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000a7	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@std@@QAE@PAURINGMONSTER_DATA@@PBU_Container_base0@1@@Z
  000ac	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1381 :     }

  000af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b9	59		 pop	 ecx
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 0c 00	 ret	 12			; 0000000cH
  000c3	cc		 int	 3
  000c4	cc		 int	 3
  000c5	cc		 int	 3
  000c6	cc		 int	 3
  000c7	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?erase@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@0@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?erase@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@0@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@std@@@2@0@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::erase
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?push_back@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXABURINGMONSTER_DATA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXABURINGMONSTER_DATA@@@Z PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::push_back, COMDAT
; _this$ = ecx

; 716  :     void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 717  :         emplace_back(_Val);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$emplace_back@ABURINGMONSTER_DATA@@@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@ABURINGMONSTER_DATA@@@Z ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::emplace_back<RINGMONSTER_DATA const &>

; 718  :     }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?push_back@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAEXABURINGMONSTER_DATA@@@Z ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::~vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Tidy@?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@AAEXXZ ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::~vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -70						; size = 1
$T2 = -69						; size = 1
_this$ = -4						; size = 4
??0?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ PROC ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >, COMDAT
; _this$ = ecx

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	0f b6 45 bb	 movzx	 eax, BYTE PTR $T2[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@URINGMONSTER_DATA@@@std@@V?$_Vector_val@U?$_Simple_types@URINGMONSTER_DATA@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<RINGMONSTER_DATA>,std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >,1>::_Compressed_pair<std::allocator<RINGMONSTER_DATA>,std::_Vector_val<std::_Simple_types<RINGMONSTER_DATA> >,1><>

; 446  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00019	8d 45 ba	 lea	 eax, DWORD PTR $T1[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 447  :     }

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??0?$vector@URINGMONSTER_DATA@@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@QAE@XZ ENDP ; std::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >::vector<RINGMONSTER_DATA,std::allocator<RINGMONSTER_DATA> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@SAIABV?$allocator@URINGMONSTER_DATA@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@SAIABV?$allocator@URINGMONSTER_DATA@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_DATA> >::max_size, COMDAT

; 702  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 703  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00009	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 704  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@URINGMONSTER_DATA@@@std@@@std@@SAIABV?$allocator@URINGMONSTER_DATA@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<RINGMONSTER_DATA> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?allocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEPAURINGMONSTER_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEPAURINGMONSTER_DATA@@I@Z PROC ; std::allocator<RINGMONSTER_DATA>::allocate, COMDAT
; _this$ = ecx

; 806  :     _NODISCARD __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0M@@std@@YAII@Z ; std::_Get_size_of_n<12>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0001e	83 c4 04	 add	 esp, 4

; 808  :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEPAURINGMONSTER_DATA@@I@Z ENDP ; std::allocator<RINGMONSTER_DATA>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEXQAURINGMONSTER_DATA@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEXQAURINGMONSTER_DATA@@I@Z PROC ; std::allocator<RINGMONSTER_DATA>::deallocate, COMDAT
; _this$ = ecx

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000c	6b 45 0c 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001a	83 c4 08	 add	 esp, 8

; 804  :     }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?deallocate@?$allocator@URINGMONSTER_DATA@@@std@@QAEXQAURINGMONSTER_DATA@@I@Z ENDP ; std::allocator<RINGMONSTER_DATA>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@URINGMONSTER_DATA@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@URINGMONSTER_DATA@@@std@@QAE@XZ PROC	; std::allocator<RINGMONSTER_DATA>::allocator<RINGMONSTER_DATA>, COMDAT
; _this$ = ecx

; 795  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@URINGMONSTER_DATA@@@std@@QAE@XZ ENDP	; std::allocator<RINGMONSTER_DATA>::allocator<RINGMONSTER_DATA>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCRingMonsterHerd@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCRingMonsterHerd@@UAEPAXI@Z PROC			; CRingMonsterHerd::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CRingMonsterHerd@@UAE@XZ ; CRingMonsterHerd::~CRingMonsterHerd
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 44		 push	 68			; 00000044H
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_GCRingMonsterHerd@@UAEPAXI@Z ENDP			; CRingMonsterHerd::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.h
;	COMDAT ?GetY@CRingMonsterHerd@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetY@CRingMonsterHerd@@QAEEXZ PROC			; CRingMonsterHerd::GetY, COMDAT
; _this$ = ecx

; 114  : 	UCHAR			GetY() {				//   Y

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 115  : 		return m_iCUR_Y;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8a 40 10	 mov	 al, BYTE PTR [eax+16]

; 116  : 	}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetY@CRingMonsterHerd@@QAEEXZ ENDP			; CRingMonsterHerd::GetY
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.h
;	COMDAT ?GetX@CRingMonsterHerd@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetX@CRingMonsterHerd@@QAEEXZ PROC			; CRingMonsterHerd::GetX, COMDAT
; _this$ = ecx

; 111  : 	UCHAR			GetX() {				//   X

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		return m_iCUR_X;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8a 40 0c	 mov	 al, BYTE PTR [eax+12]

; 113  : 	}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?GetX@CRingMonsterHerd@@QAEEXZ ENDP			; CRingMonsterHerd::GetX
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?SendEventGiftWinner@CRingMonsterHerd@@QAEXHH@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 20
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_iGiftKind$ = 12					; size = 4
?SendEventGiftWinner@CRingMonsterHerd@@QAEXHH@Z PROC	; CRingMonsterHerd::SendEventGiftWinner, COMDAT
; _this$ = ecx

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 141  : 	if (gObjIsConnected(iIndex) == FALSE)

  00016	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0001f	83 c4 04	 add	 esp, 4
  00022	85 c0		 test	 eax, eax
  00024	75 05		 jne	 SHORT $LN2@SendEventG

; 142  : 		return;

  00026	e9 c1 00 00 00	 jmp	 $LN1@SendEventG
$LN2@SendEventG:

; 143  : 
; 144  : 	if( gObj[iIndex].UseEventServer )

  0002b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00038	83 bc 01 84 0e
	00 00 00	 cmp	 DWORD PTR [ecx+eax+3716], 0
  00040	74 05		 je	 SHORT $LN3@SendEventG

; 145  : 	return;

  00042	e9 a5 00 00 00	 jmp	 $LN1@SendEventG
$LN3@SendEventG:

; 146  : 
; 147  : 	gObj[iIndex].UseEventServer = TRUE;

  00047	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00054	c7 84 01 84 0e
	00 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+3716], 1

; 148  : 
; 149  : 	PMSG_REQ_REG_RINGGIFT pMsg;
; 150  : 
; 151  : 	PHeadSetB((LPBYTE)&pMsg, 0x10, sizeof(pMsg));

  0005f	6a 14		 push	 20			; 00000014H
  00061	6a 10		 push	 16			; 00000010H
  00063	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 152  : 
; 153  : 	pMsg.iINDEX = iIndex;

  0006f	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00072	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+4], eax

; 154  : 	memcpy (pMsg.szUID, gObj[iIndex].AccountID, MAX_IDSTRING);

  00075	6a 0a		 push	 10			; 0000000aH
  00077	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00084	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00088	52		 push	 edx
  00089	8d 45 ec	 lea	 eax, DWORD PTR _pMsg$[ebp+8]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _memcpy
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH

; 155  : 	pMsg.szUID[sizeof(pMsg.szUID)-1] = 0;

  00095	b8 01 00 00 00	 mov	 eax, 1
  0009a	6b c8 0a	 imul	 ecx, eax, 10
  0009d	c6 44 0d ec 00	 mov	 BYTE PTR _pMsg$[ebp+ecx+8], 0

; 156  : 	pMsg.btGiftKind = iGiftKind;

  000a2	8a 45 0c	 mov	 al, BYTE PTR _iGiftKind$[ebp]
  000a5	88 45 f7	 mov	 BYTE PTR _pMsg$[ebp+19], al

; 157  : 
; 158  : 	DataSendEventChip((char*)&pMsg, sizeof(pMsg));

  000a8	6a 14		 push	 20			; 00000014H
  000aa	8d 45 e4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 ?DataSendEventChip@@YAXPADH@Z ; DataSendEventChip
  000b3	83 c4 08	 add	 esp, 8

; 159  : 
; 160  : 	LogAddTD("[Ring Event] [%s][%s] Request to Register Gift - Gift Kind (%d)", gObj[iIndex].AccountID, gObj[iIndex].Name, iGiftKind);

  000b6	8b 45 0c	 mov	 eax, DWORD PTR _iGiftKind$[ebp]
  000b9	50		 push	 eax
  000ba	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  000c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c7	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  000cb	50		 push	 eax
  000cc	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  000d3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000d9	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  000dd	50		 push	 eax
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@DGMJBKOB@?$FLRing?5Event?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Request?5t@
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e9	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@SendEventG:

; 161  : }

  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx
  000ef	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f2	33 cd		 xor	 ecx, ebp
  000f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 08 00	 ret	 8
?SendEventGiftWinner@CRingMonsterHerd@@QAEXHH@Z ENDP	; CRingMonsterHerd::SendEventGiftWinner
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?MonsterAttackAction@CRingMonsterHerd@@UAEXPAVOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?MonsterAttackAction@CRingMonsterHerd@@UAEXPAVOBJECTSTRUCT@@0@Z PROC ; CRingMonsterHerd::MonsterAttackAction, COMDAT
; _this$ = ecx

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   : #ifdef NEW_FORSKYLAND2
; 97   : 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 98   : 	if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_STONE ) == true )
; 99   : 	#else
; 100  : 	if( lpObj->m_SkillHarden != 0 )

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000f	83 b8 fc 19 00
	00 00		 cmp	 DWORD PTR [eax+6652], 0
  00016	74 02		 je	 SHORT $LN2@MonsterAtt

; 101  : 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 102  : 		return;

  00018	eb 5b		 jmp	 SHORT $LN1@MonsterAtt
$LN2@MonsterAtt:

; 103  : #endif
; 104  : 	
; 105  : #ifdef ADD_NEW_SKILL_FOR_CASTLE_02_20050531
; 106  : 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 107  : 	if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_STUN ) == true )
; 108  : 	#else
; 109  : 	if( lpObj->m_iSkillStunTime > 0 )
; 110  : 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 111  : 		return;
; 112  : #endif
; 113  : 
; 114  : #ifdef ADD_SEASON_3_NEW_CHARACTER_SUMMONER_20070912	//     
; 115  : 	if( gObjCheckUsedBuffEffect( lpObj, BUFFTYPE_SLEEP ) == true )
; 116  : 	{
; 117  : 		return;
; 118  : 	}
; 119  : #endif
; 120  : 	
; 121  : 	if (lpObj == NULL)

  0001a	83 7d 08 00	 cmp	 DWORD PTR _lpObj$[ebp], 0
  0001e	75 02		 jne	 SHORT $LN3@MonsterAtt

; 122  : 		return;

  00020	eb 53		 jmp	 SHORT $LN1@MonsterAtt
$LN3@MonsterAtt:

; 123  : 
; 124  : 	if (lpTargetObj == NULL)

  00022	83 7d 0c 00	 cmp	 DWORD PTR _lpTargetObj$[ebp], 0
  00026	75 02		 jne	 SHORT $LN4@MonsterAtt

; 125  : 		return;

  00028	eb 4b		 jmp	 SHORT $LN1@MonsterAtt
$LN4@MonsterAtt:

; 126  : 
; 127  : 	if (lpObj->Connected < 3 || lpObj->Type != OBJTYPE_MONSTER)

  0002a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002d	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00031	7c 0c		 jl	 SHORT $LN6@MonsterAtt
  00033	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00036	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0003a	83 f9 02	 cmp	 ecx, 2
  0003d	74 02		 je	 SHORT $LN5@MonsterAtt
$LN6@MonsterAtt:

; 128  : 		return;

  0003f	eb 34		 jmp	 SHORT $LN1@MonsterAtt
$LN5@MonsterAtt:

; 129  : 
; 130  : 	if (lpTargetObj->Connected < 3)

  00041	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00044	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00048	7d 02		 jge	 SHORT $LN7@MonsterAtt

; 131  : 		return;

  0004a	eb 29		 jmp	 SHORT $LN1@MonsterAtt
$LN7@MonsterAtt:

; 132  : 
; 133  : 	if (lpObj->Class == 135) {			

  0004c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004f	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00056	81 f9 87 00 00
	00		 cmp	 ecx, 135		; 00000087H
  0005c	75 17		 jne	 SHORT $LN1@MonsterAtt

; 134  : 		OrderAttack(lpObj, lpTargetObj, 90);	//      

  0005e	6a 5a		 push	 90			; 0000005aH
  00060	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00063	50		 push	 eax
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00067	51		 push	 ecx
  00068	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	8b 02		 mov	 eax, DWORD PTR [edx]
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	8b 50 3c	 mov	 edx, DWORD PTR [eax+60]
  00073	ff d2		 call	 edx
$LN1@MonsterAtt:

; 135  : 	}
; 136  : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 08 00	 ret	 8
?MonsterAttackAction@CRingMonsterHerd@@UAEXPAVOBJECTSTRUCT@@0@Z ENDP ; CRingMonsterHerd::MonsterAttackAction
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?MonsterHerdItemDrop@CRingMonsterHerd@@UAEHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iMaxHitUser$1 = -284					; size = 4
_iType$2 = -280						; size = 4
_iMaxHitUser$3 = -276					; size = 4
_szTemp$4 = -272					; size = 256
_iType$5 = -16						; size = 4
_iMaxHitUser$6 = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?MonsterHerdItemDrop@CRingMonsterHerd@@UAEHPAVOBJECTSTRUCT@@@Z PROC ; CRingMonsterHerd::MonsterHerdItemDrop, COMDAT
; _this$ = ecx

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 50   : 	if (lpObj->Class == 135) {		//    

  00019	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00023	81 f9 87 00 00
	00		 cmp	 ecx, 135		; 00000087H
  00029	0f 85 13 01 00
	00		 jne	 $LN2@MonsterHer

; 51   : 		int iMaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  0002f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00038	83 c4 04	 add	 esp, 4
  0003b	89 45 f4	 mov	 DWORD PTR _iMaxHitUser$6[ebp], eax

; 52   : 		int iType = ItemGetNumberMake(14, 13);

  0003e	6a 0d		 push	 13			; 0000000dH
  00040	6a 0e		 push	 14			; 0000000eH
  00042	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00047	83 c4 08	 add	 esp, 8
  0004a	89 45 f0	 mov	 DWORD PTR _iType$5[ebp], eax

; 53   : 		ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE) lpObj->X, (BYTE) lpObj->Y, iType, 0, (BYTE)0, 0, 0, 0, iMaxHitUser);

  0004d	6a 00		 push	 0
  0004f	6a 00		 push	 0
  00051	6a 00		 push	 0
  00053	8b 45 f4	 mov	 eax, DWORD PTR _iMaxHitUser$6[ebp]
  00056	50		 push	 eax
  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	6a 00		 push	 0
  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	8b 4d f0	 mov	 ecx, DWORD PTR _iType$5[ebp]
  00064	51		 push	 ecx
  00065	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00068	0f b6 82 06 01
	00 00		 movzx	 eax, BYTE PTR [edx+262]
  0006f	50		 push	 eax
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00073	0f b6 91 04 01
	00 00		 movzx	 edx, BYTE PTR [ecx+260]
  0007a	52		 push	 edx
  0007b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007e	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00085	51		 push	 ecx
  00086	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00089	8b 02		 mov	 eax, DWORD PTR [edx]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  00091	83 c4 38	 add	 esp, 56			; 00000038H

; 54   : 
; 55   : 		//    .
; 56   : 		CHAR szTemp[256];
; 57   : 		wsprintf(szTemp, lMsg.Get(1205), gObj[iMaxHitUser].Name, g_TerrainManager.GetMapName(lpObj->MapNumber));	// "%s %s     ."

  00094	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00097	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0009e	51		 push	 ecx
  0009f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TerrainManager@@3VCTerrainManager@@A ; g_TerrainManager
  000a4	e8 00 00 00 00	 call	 ?GetMapName@CTerrainManager@@QAEPADH@Z ; CTerrainManager::GetMapName
  000a9	50		 push	 eax
  000aa	69 55 f4 a0 1b
	00 00		 imul	 edx, DWORD PTR _iMaxHitUser$6[ebp], 7072
  000b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b6	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  000ba	51		 push	 ecx
  000bb	68 b5 04 00 00	 push	 1205			; 000004b5H
  000c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000cb	50		 push	 eax
  000cc	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$4[ebp]
  000d2	52		 push	 edx
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  000d9	83 c4 10	 add	 esp, 16			; 00000010H

; 58   : 		AllSendServerMsg (szTemp);

  000dc	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$4[ebp]
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  000e8	83 c4 04	 add	 esp, 4

; 59   : 
; 60   : 		LogAddTD("[Ring Event] White Wizard Killed by [%s][%s], MapNumber:%d", gObj[iMaxHitUser].AccountID, gObj[iMaxHitUser].Name, gObj[iMaxHitUser].MapNumber);

  000eb	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMaxHitUser$6[ebp], 7072
  000f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f8	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00100	52		 push	 edx
  00101	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMaxHitUser$6[ebp], 7072
  00108	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010e	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00112	52		 push	 edx
  00113	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMaxHitUser$6[ebp], 7072
  0011a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00120	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00124	52		 push	 edx
  00125	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@ELDBHEBB@?$FLRing?5Event?$FN?5White?5Wizard?5Kille@
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00130	83 c4 10	 add	 esp, 16			; 00000010H

; 61   : 		return TRUE;

  00133	b8 01 00 00 00	 mov	 eax, 1
  00138	e9 34 01 00 00	 jmp	 $LN1@MonsterHer

; 62   : 	}

  0013d	e9 2d 01 00 00	 jmp	 $LN3@MonsterHer
$LN2@MonsterHer:

; 63   : 	else if (
; 64   : 		lpObj->Class == 136 ||

  00142	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00145	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0014c	81 f9 88 00 00
	00		 cmp	 ecx, 136		; 00000088H
  00152	74 16		 je	 SHORT $LN5@MonsterHer
  00154	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00157	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0015e	81 f9 89 00 00
	00		 cmp	 ecx, 137		; 00000089H
  00164	0f 85 05 01 00
	00		 jne	 $LN3@MonsterHer
$LN5@MonsterHer:

; 65   : 		lpObj->Class == 137			//  30%   
; 66   : 		) 
; 67   : 	{
; 68   : 		if (rand()%100 < 30) {

  0016a	e8 00 00 00 00	 call	 _rand
  0016f	99		 cdq
  00170	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00175	f7 f9		 idiv	 ecx
  00177	83 fa 1e	 cmp	 edx, 30			; 0000001eH
  0017a	7d 7a		 jge	 SHORT $LN6@MonsterHer

; 69   : 			int iMaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  0017c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017f	50		 push	 eax
  00180	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  00185	83 c4 04	 add	 esp, 4
  00188	89 85 ec fe ff
	ff		 mov	 DWORD PTR _iMaxHitUser$3[ebp], eax

; 70   : 			int iType = ItemGetNumberMake(13, 20);

  0018e	6a 14		 push	 20			; 00000014H
  00190	6a 0d		 push	 13			; 0000000dH
  00192	e8 00 00 00 00	 call	 ?ItemGetNumberMake@@YAHHH@Z ; ItemGetNumberMake
  00197	83 c4 08	 add	 esp, 8
  0019a	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _iType$2[ebp], eax

; 71   : 			ItemSerialCreateSend(lpObj->m_Index, lpObj->MapNumber, (BYTE) lpObj->X, (BYTE) lpObj->Y, iType, 0, (BYTE)30, 0, 0, 0, iMaxHitUser);

  001a0	6a 00		 push	 0
  001a2	6a 00		 push	 0
  001a4	6a 00		 push	 0
  001a6	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _iMaxHitUser$3[ebp]
  001ac	50		 push	 eax
  001ad	6a 00		 push	 0
  001af	6a 00		 push	 0
  001b1	6a 00		 push	 0
  001b3	6a 1e		 push	 30			; 0000001eH
  001b5	6a 00		 push	 0
  001b7	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _iType$2[ebp]
  001bd	51		 push	 ecx
  001be	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001c1	0f b6 82 06 01
	00 00		 movzx	 eax, BYTE PTR [edx+262]
  001c8	50		 push	 eax
  001c9	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001cc	0f b6 91 04 01
	00 00		 movzx	 edx, BYTE PTR [ecx+260]
  001d3	52		 push	 edx
  001d4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001d7	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  001de	51		 push	 ecx
  001df	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001e2	8b 02		 mov	 eax, DWORD PTR [edx]
  001e4	50		 push	 eax
  001e5	e8 00 00 00 00	 call	 ?ItemSerialCreateSend@@YAXHEEEHEEEEEHEEH@Z ; ItemSerialCreateSend
  001ea	83 c4 38	 add	 esp, 56			; 00000038H

; 72   : 			return TRUE;

  001ed	b8 01 00 00 00	 mov	 eax, 1
  001f2	eb 7d		 jmp	 SHORT $LN1@MonsterHer

; 73   : 		}

  001f4	eb 79		 jmp	 SHORT $LN3@MonsterHer
$LN6@MonsterHer:

; 74   : 		else if (rand()%g_iRingOrcKillGiftRate == 0) {			//  1/n   

  001f6	e8 00 00 00 00	 call	 _rand
  001fb	99		 cdq
  001fc	f7 3d 00 00 00
	00		 idiv	 DWORD PTR ?g_iRingOrcKillGiftRate@@3HA ; g_iRingOrcKillGiftRate
  00202	85 d2		 test	 edx, edx
  00204	75 2c		 jne	 SHORT $LN8@MonsterHer

; 75   : 			int iMaxHitUser = gObjMonsterTopHitDamageUser(lpObj);

  00206	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00209	50		 push	 eax
  0020a	e8 00 00 00 00	 call	 ?gObjMonsterTopHitDamageUser@@YAHPAVOBJECTSTRUCT@@@Z ; gObjMonsterTopHitDamageUser
  0020f	83 c4 04	 add	 esp, 4
  00212	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _iMaxHitUser$1[ebp], eax

; 76   : 
; 77   : 			SendEventGiftWinner (iMaxHitUser, 1);				//    .

  00218	6a 01		 push	 1
  0021a	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _iMaxHitUser$1[ebp]
  00220	50		 push	 eax
  00221	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00224	e8 00 00 00 00	 call	 ?SendEventGiftWinner@CRingMonsterHerd@@QAEXHH@Z ; CRingMonsterHerd::SendEventGiftWinner

; 78   : 			return TRUE;

  00229	b8 01 00 00 00	 mov	 eax, 1
  0022e	eb 41		 jmp	 SHORT $LN1@MonsterHer

; 79   : 		}

  00230	eb 3d		 jmp	 SHORT $LN3@MonsterHer
$LN8@MonsterHer:

; 80   : 		else {
; 81   : 			//   10000 .
; 82   : 			MapC[lpObj->MapNumber].MoneyItemDrop((int)10000, (BYTE) lpObj->X ,(BYTE) lpObj->Y);

  00232	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00235	0f b6 88 06 01
	00 00		 movzx	 ecx, BYTE PTR [eax+262]
  0023c	51		 push	 ecx
  0023d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00240	0f b6 82 04 01
	00 00		 movzx	 eax, BYTE PTR [edx+260]
  00247	50		 push	 eax
  00248	68 10 27 00 00	 push	 10000			; 00002710H
  0024d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00250	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00257	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  0025d	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00263	e8 00 00 00 00	 call	 ?MoneyItemDrop@MapClass@@QAEHHHH@Z ; MapClass::MoneyItemDrop

; 83   : 			return TRUE;

  00268	b8 01 00 00 00	 mov	 eax, 1
  0026d	eb 02		 jmp	 SHORT $LN1@MonsterHer
$LN3@MonsterHer:

; 84   : 		}
; 85   : 	}
; 86   : 
; 87   : 	return FALSE;

  0026f	33 c0		 xor	 eax, eax
$LN1@MonsterHer:

; 88   : }

  00271	5f		 pop	 edi
  00272	5e		 pop	 esi
  00273	5b		 pop	 ebx
  00274	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00277	33 cd		 xor	 ecx, ebp
  00279	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0027e	8b e5		 mov	 esp, ebp
  00280	5d		 pop	 ebp
  00281	c2 04 00	 ret	 4
?MonsterHerdItemDrop@CRingMonsterHerd@@UAEHPAVOBJECTSTRUCT@@@Z ENDP ; CRingMonsterHerd::MonsterHerdItemDrop
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?Start@CRingMonsterHerd@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Start@CRingMonsterHerd@@UAEHXZ PROC			; CRingMonsterHerd::Start, COMDAT
; _this$ = ecx

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   : 	m_bEventSuccess = FALSE;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0

; 42   : 
; 43   : 	return MonsterHerd::Start();

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?Start@MonsterHerd@@UAEHXZ ; MonsterHerd::Start

; 44   : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?Start@CRingMonsterHerd@@UAEHXZ ENDP			; CRingMonsterHerd::Start
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ??1CRingMonsterHerd@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CRingMonsterHerd@@UAE@XZ PROC			; CRingMonsterHerd::~CRingMonsterHerd, COMDAT
; _this$ = ecx

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CRingMonsterHerd@@6B@

; 36   : 	
; 37   : }

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1MonsterHerd@@UAE@XZ	; MonsterHerd::~MonsterHerd
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1CRingMonsterHerd@@UAE@XZ ENDP			; CRingMonsterHerd::~CRingMonsterHerd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ??0CRingMonsterHerd@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRingMonsterHerd@@QAE@XZ PROC			; CRingMonsterHerd::CRingMonsterHerd, COMDAT
; _this$ = ecx

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0MonsterHerd@@QAE@XZ	; MonsterHerd::MonsterHerd
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CRingMonsterHerd@@6B@

; 31   : 	
; 32   : }

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??0CRingMonsterHerd@@QAE@XZ ENDP			; CRingMonsterHerd::CRingMonsterHerd
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\map
;	COMDAT ??$_Kfn@$$CBHU_TERRAIN_INFO@@@?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_TERRAIN_INFO@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHU_TERRAIN_INFO@@@?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_TERRAIN_INFO@@@1@@Z PROC ; std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0>::_Kfn<int const ,_TERRAIN_INFO>, COMDAT

; 68   :     static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val) { // extract key from element value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 69   :         return _Val.first;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 70   :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Kfn@$$CBHU_TERRAIN_INFO@@@?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_TERRAIN_INFO@@@1@@Z ENDP ; std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0>::_Kfn<int const ,_TERRAIN_INFO>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > const >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > const >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Ptr_container$ = -8					; size = 4
__Block_size$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000c	83 c0 23	 add	 eax, 35			; 00000023H
  0000f	89 45 fc	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  00012	8b 45 fc	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00015	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00018	77 05		 ja	 SHORT $LN8@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  0001a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0001f	8b 45 fc	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002e	83 7d f8 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  00032	74 02		 je	 SHORT $LN7@Allocate_m
  00034	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00036	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0003b	33 c0		 xor	 eax, eax
  0003d	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  0003f	33 c0		 xor	 eax, eax
  00041	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00043	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00046	83 c0 23	 add	 eax, 35			; 00000023H
  00049	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0004c	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0004f	b8 04 00 00 00	 mov	 eax, 4
  00054	6b c8 ff	 imul	 ecx, eax, -1
  00057	8b 55 f4	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  0005d	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00060	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z
_TEXT	SEGMENT
tv78 = -72						; size = 4
_this$ = -4						; size = 4
__Bound$ = 8						; size = 4
__Keyval$ = 12						; size = 4
??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Lower_bound_duplicate<int>, COMDAT
; _this$ = ecx

; 1694 :     bool _Lower_bound_duplicate(const _Nodeptr _Bound, const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Bound$[ebp]
  0000f	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  00013	85 c9		 test	 ecx, ecx
  00015	75 33		 jne	 SHORT $LN3@Lower_boun
  00017	8b 55 08	 mov	 edx, DWORD PTR __Bound$[ebp]
  0001a	83 c2 10	 add	 edx, 16			; 00000010H
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHU_TERRAIN_INFO@@@?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_TERRAIN_INFO@@@1@@Z ; std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0>::_Kfn<int const ,_TERRAIN_INFO>
  00023	83 c4 04	 add	 esp, 4
  00026	50		 push	 eax
  00027	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Getcomp@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Getcomp
  00033	8b c8		 mov	 ecx, eax
  00035	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0003a	0f b6 c8	 movzx	 ecx, al
  0003d	85 c9		 test	 ecx, ecx
  0003f	75 09		 jne	 SHORT $LN3@Lower_boun
  00041	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  00048	eb 07		 jmp	 SHORT $LN4@Lower_boun
$LN3@Lower_boun:
  0004a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN4@Lower_boun:
  00051	8a 45 b8	 mov	 al, BYTE PTR tv78[ebp]

; 1696 :     }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Lower_bound_duplicate<int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@1@ABH@Z
_TEXT	SEGMENT
__Trynode$ = -24					; size = 4
__Result$ = -20						; size = 12
__Scary$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@1@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Find_lower_bound<int>, COMDAT
; _this$ = ecx

; 1699 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1700 :         const auto _Scary = _Get_scary();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1701 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001f	89 55 ec	 mov	 DWORD PTR __Result$[ebp], edx
  00022	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 0
  00029	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	89 4d f4	 mov	 DWORD PTR __Result$[ebp+8], ecx

; 1702 :         _Nodeptr _Trynode = _Result._Location._Parent;

  00031	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]
  00034	89 45 e8	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN2@Find_lower:

; 1703 :         while (!_Trynode->_Isnil) {

  00037	8b 45 e8	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0003a	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  0003e	85 c9		 test	 ecx, ecx
  00040	75 59		 jne	 SHORT $LN3@Find_lower

; 1704 :             _Result._Location._Parent = _Trynode;

  00042	8b 45 e8	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00045	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 1705 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  00048	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d e8	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  0004f	83 c1 10	 add	 ecx, 16			; 00000010H
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHU_TERRAIN_INFO@@@?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_TERRAIN_INFO@@@1@@Z ; std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0>::_Kfn<int const ,_TERRAIN_INFO>
  00058	83 c4 04	 add	 esp, 4
  0005b	50		 push	 eax
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Getcomp@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Getcomp
  00064	8b c8		 mov	 ecx, eax
  00066	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0006b	0f b6 d0	 movzx	 edx, al
  0006e	85 d2		 test	 edx, edx
  00070	74 12		 je	 SHORT $LN4@Find_lower

; 1706 :                 _Result._Location._Child = _Tree_child::_Right;

  00072	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 0

; 1707 :                 _Trynode                 = _Trynode->_Right;

  00079	8b 45 e8	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0007c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0007f	89 4d e8	 mov	 DWORD PTR __Trynode$[ebp], ecx

; 1708 :             } else {

  00082	eb 15		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1709 :                 _Result._Location._Child = _Tree_child::_Left;

  00084	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 1

; 1710 :                 _Result._Bound           = _Trynode;

  0008b	8b 45 e8	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008e	89 45 f4	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1711 :                 _Trynode                 = _Trynode->_Left;

  00091	8b 45 e8	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00094	8b 08		 mov	 ecx, DWORD PTR [eax]
  00096	89 4d e8	 mov	 DWORD PTR __Trynode$[ebp], ecx
$LN5@Find_lower:

; 1712 :             }
; 1713 :         }

  00099	eb 9c		 jmp	 SHORT $LN2@Find_lower
$LN3@Find_lower:

; 1714 : 
; 1715 :         return _Result;

  0009b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0009e	8b 4d ec	 mov	 ecx, DWORD PTR __Result$[ebp]
  000a1	89 08		 mov	 DWORD PTR [eax], ecx
  000a3	8b 55 f0	 mov	 edx, DWORD PTR __Result$[ebp+4]
  000a6	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000a9	8b 4d f4	 mov	 ecx, DWORD PTR __Result$[ebp+8]
  000ac	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000af	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1716 :     }

  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 08 00	 ret	 8
??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@1@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Find_lower_bound<int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00009	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00010	72 0e		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00012	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0001b	83 c4 04	 add	 esp, 4
  0001e	eb 16		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00020	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00024	74 0e		 je	 SHORT $LN3@Allocate

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0002f	83 c4 04	 add	 esp, 4
  00032	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00034	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00028	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0002f	72 10		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  00031	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  00034	50		 push	 eax
  00035	8d 4d 08	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0003e	83 c4 08	 add	 esp, 8
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00041	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00044	50		 push	 eax
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004e	83 c4 08	 add	 esp, 8

; 222  : }

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
  00063	cc		 int	 3
  00064	cc		 int	 3
  00065	cc		 int	 3
  00066	cc		 int	 3
  00067	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -72						; size = 4
$T1 = -68						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 67   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 68   :     // return smaller of _Left and _Right
; 69   :     return _Right < _Left ? _Right : _Left;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00013	73 08		 jae	 SHORT $LN3@min
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00018	89 45 b8	 mov	 DWORD PTR tv65[ebp], eax
  0001b	eb 06		 jmp	 SHORT $LN4@min
$LN3@min:
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00020	89 4d b8	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@min:
  00023	8b 55 b8	 mov	 edx, DWORD PTR tv65[ebp]
  00026	89 55 bc	 mov	 DWORD PTR $T1[ebp], edx
  00029	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]

; 70   : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@YAPAU?$pair@$$CBHU_TERRAIN_INFO@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@YAPAU?$pair@$$CBHU_TERRAIN_INFO@@@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,_TERRAIN_INFO> >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@YAPAU?$pair@$$CBHU_TERRAIN_INFO@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,_TERRAIN_INFO> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$_Find@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z
_TEXT	SEGMENT
__Loc$ = -16						; size = 12
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??$_Find@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Find<int>, COMDAT
; _this$ = ecx

; 1457 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1458 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f0	 lea	 ecx, DWORD PTR __Loc$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Find_lower_bound<int>

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  0001c	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f8	 mov	 ecx, DWORD PTR __Loc$[ebp+8]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Lower_bound_duplicate<int>
  0002c	0f b6 d0	 movzx	 edx, al
  0002f	85 d2		 test	 edx, edx
  00031	74 05		 je	 SHORT $LN2@Find

; 1460 :             return _Loc._Bound;

  00033	8b 45 f8	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  00036	eb 0a		 jmp	 SHORT $LN1@Find
$LN2@Find:

; 1461 :         }
; 1462 : 
; 1463 :         return _Get_scary()->_Myhead;

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary
  00040	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Find:

; 1464 :     }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
??$_Find@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Find<int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@SAPAU?$pair@$$CBHU_TERRAIN_INFO@@@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAU?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@SAPAU?$pair@$$CBHU_TERRAIN_INFO@@@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<int const ,_TERRAIN_INFO> *>::pointer_to, COMDAT

; 146  :     _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 147  :         return _STD addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@YAPAU?$pair@$$CBHU_TERRAIN_INFO@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_TERRAIN_INFO> >
  00012	83 c4 04	 add	 esp, 4

; 148  :     }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@SAPAU?$pair@$$CBHU_TERRAIN_INFO@@@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<int const ,_TERRAIN_INFO> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator->, COMDAT
; _this$ = ecx

; 276  :     _NODISCARD pointer operator->() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator*
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?pointer_to@?$pointer_traits@PAU?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@SAPAU?$pair@$$CBHU_TERRAIN_INFO@@@2@AAU32@@Z ; std::pointer_traits<std::pair<int const ,_TERRAIN_INFO> *>::pointer_to
  0001a	83 c4 04	 add	 esp, 4

; 278  :     }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator*, COMDAT
; _this$ = ecx

; 272  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 273  :         return const_cast<reference>(_Mybase::operator*());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator*

; 274  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,std::_Iterator_base0>
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv75 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator==, COMDAT
; _this$ = ecx

; 227  :     _NODISCARD bool operator==(const _Tree_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 228  : #if _ITERATOR_DEBUG_LEVEL == 2
; 229  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 230  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 231  : 
; 232  :         return this->_Ptr == _Right._Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00016	75 09		 jne	 SHORT $LN3@operator
  00018	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  0001f	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00021	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN4@operator:
  00028	8a 45 b8	 mov	 al, BYTE PTR tv75[ebp]

; 233  :     }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator*, COMDAT
; _this$ = ecx

; 178  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 179  : #if _ITERATOR_DEBUG_LEVEL == 2
; 180  :         const auto _Mycont = static_cast<const _Mytree*>(this->_Getcont());
; 181  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized map/set iterator");
; 182  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end map/set iterator");
; 183  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 184  : 
; 185  :         return this->_Ptr->_Myval;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	83 c0 10	 add	 eax, 16			; 00000010H

; 186  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 40   :         this->_Adopt(_Plist);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 41   :     }

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,_TERRAIN_INFO>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1348 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1349 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,_TERRAIN_INFO>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 2050 :     const _Scary_val* _Get_scary() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@ABV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > const >
  00015	83 c4 04	 add	 esp, 4

; 2052 :     }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 2046 :     _Scary_val* _Get_scary() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >
  00015	83 c4 04	 add	 esp, 4

; 2048 :     }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcomp@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 2034 :     const key_compare& _Getcomp() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2035 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,_TERRAIN_INFO>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > >,1>,1>::_Get_first

; 2036 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getcomp@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::find, COMDAT
; _this$ = ecx

; 1467 :     _NODISCARD iterator find(const key_type& _Keyval) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary
  00014	50		 push	 eax
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??$_Find@H@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Find<int>
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00025	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z
  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1469 :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__Scary$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::end, COMDAT
; _this$ = ecx

; 1248 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1249 :         const auto _Scary = _Get_scary();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::_Get_scary
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	52		 push	 edx
  00021	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@1@@Z
  00029	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1251 :     }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\TerrainManager.h
;	COMDAT ?GetMapName@CTerrainManager@@QAEPADH@Z
_TEXT	SEGMENT
$T1 = -76						; size = 4
_it$ = -8						; size = 4
_this$ = -4						; size = 4
_MapNumber$ = 8						; size = 4
?GetMapName@CTerrainManager@@QAEPADH@Z PROC		; CTerrainManager::GetMapName, COMDAT
; _this$ = ecx

; 47   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 48   : 		std::map<int, _TERRAIN_INFO>::iterator it = this->m_mTerrainMap.find(MapNumber);

  0000c	8d 45 08	 lea	 eax, DWORD PTR _MapNumber$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::find

; 49   : 
; 50   : 		if(it == this->m_mTerrainMap.end())

  0001c	8d 45 b4	 lea	 eax, DWORD PTR $T1[ebp]
  0001f	50		 push	 eax
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HU_TERRAIN_INFO@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_TERRAIN_INFO,std::less<int>,std::allocator<std::pair<int const ,_TERRAIN_INFO> >,0> >::end
  00028	50		 push	 eax
  00029	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  0002c	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator==
  00031	0f b6 c8	 movzx	 ecx, al
  00034	85 c9		 test	 ecx, ecx
  00036	74 07		 je	 SHORT $LN2@GetMapName

; 51   : 			return "Unknown";

  00038	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07NBCGADJA@Unknown@
  0003d	eb 0b		 jmp	 SHORT $LN1@GetMapName
$LN2@GetMapName:

; 52   : 
; 53   : 		return it->second.szMapName;

  0003f	8d 4d f8	 lea	 ecx, DWORD PTR _it$[ebp]
  00042	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHU_TERRAIN_INFO@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_TERRAIN_INFO@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,_TERRAIN_INFO> > > >::operator->
  00047	83 c0 24	 add	 eax, 36			; 00000024H
$LN1@GetMapName:

; 54   : 	}

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?GetMapName@CTerrainManager@@QAEPADH@Z ENDP		; CTerrainManager::GetMapName
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
tv65 = -72						; size = 4
_this$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 126  :     constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  :         return _Left < _Right;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00016	7d 09		 jge	 SHORT $LN3@operator
  00018	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  0001f	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00021	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
$LN4@operator:
  00028	8a 45 b8	 mov	 al, BYTE PTR tv65[ebp]

; 128  :     }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 1072 :     void _Adopt(const void*) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT
; _this$ = ecx

; 1067 :     void _Alloc_proxy(const _Fake_allocator&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 1065 :     void _Orphan_all() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -16					; size = 4
__Min_back_shift$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Ptr_user$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	83 c1 23	 add	 ecx, 35			; 00000023H
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00014	89 0a		 mov	 DWORD PTR [edx], ecx

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00016	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	89 4d fc	 mov	 DWORD PTR __Ptr_user$[ebp], ecx

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001e	b8 04 00 00 00	 mov	 eax, 4
  00023	6b c8 ff	 imul	 ecx, eax, -1
  00026	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  00029	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002c	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002f	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00036	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	2b 4d f8	 sub	 ecx, DWORD PTR __Ptr_container$[ebp]
  0003e	89 4d f0	 mov	 DWORD PTR __Back_shift$[ebp], ecx
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00041	83 7d f0 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00045	72 08		 jb	 SHORT $LN7@Adjust_man
  00047	83 7d f0 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  0004b	77 02		 ja	 SHORT $LN7@Adjust_man
  0004d	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00054	33 c0		 xor	 eax, eax
  00056	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00058	33 c0		 xor	 eax, eax
  0005a	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  00062	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 76   :     __declspec(allocator) static void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 77   :         return ::operator new(_Bytes);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00012	83 c4 04	 add	 esp, 4

; 78   :     }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 554  :     _NODISCARD static constexpr int(max)() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 555  :         return INT_MAX;

  00009	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 556  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -76						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 321  :     _THROW(bad_array_new_length{});

  00009	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  0000c	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  00011	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00016	8d 45 b4	 lea	 eax, DWORD PTR $T1[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UAE@XZ
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@ABV01@@Z
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 140  :         : bad_alloc("bad array new length")

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AAE@QBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 130  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 129  :         : exception(_Message, 1)

  0000c	6a 01		 push	 1
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception

; 130  :     {

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 131  :     }

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00013	74 0b		 je	 SHORT $LN3@what
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001b	89 55 b8	 mov	 DWORD PTR tv69[ebp], edx
  0001e	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  00020	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00027	8b 45 b8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 89   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ___std_exception_destroy
  00021	83 c4 04	 add	 esp, 4

; 91   :     }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00015	33 c0		 xor	 eax, eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	83 c1 04	 add	 ecx, 4
  0001d	89 01		 mov	 DWORD PTR [ecx], eax
  0001f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 c0 04	 add	 eax, 4
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  0002c	83 c1 04	 add	 ecx, 4
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ___std_exception_copy
  00035	83 c4 08	 add	 esp, 8

; 74   :     }

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00015	33 c0		 xor	 eax, eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	83 c1 04	 add	 ecx, 4
  0001d	89 01		 mov	 DWORD PTR [ecx], eax
  0001f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00028	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 68   :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 167  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 168  :         (void)_Size;
; 169  :         return _Where;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 170  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\RingAttackEvent.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
