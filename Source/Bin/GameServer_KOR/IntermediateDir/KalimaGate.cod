; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\KalimaGate.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0CKalimaGate@@QAE@XZ				; CKalimaGate::CKalimaGate
PUBLIC	??1CKalimaGate@@UAE@XZ				; CKalimaGate::~CKalimaGate
PUBLIC	?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z	; CKalimaGate::CreateKalimaGate
PUBLIC	?KalimaGateAct@CKalimaGate@@QAEXH@Z		; CKalimaGate::KalimaGateAct
PUBLIC	?CheckOverlapKundunMark@CKalimaGate@@QAEHHE@Z	; CKalimaGate::CheckOverlapKundunMark
PUBLIC	?DeleteKalimaGate@CKalimaGate@@QAEHHH@Z		; CKalimaGate::DeleteKalimaGate
PUBLIC	?DeleteKalimaGate@CKalimaGate@@QAEHH@Z		; CKalimaGate::DeleteKalimaGate
PUBLIC	?GetRandomLocation@CKalimaGate@@AAEHHAAE0@Z	; CKalimaGate::GetRandomLocation
PUBLIC	?GetKalimaGateLevel@CKalimaGate@@AAEHH@Z	; CKalimaGate::GetKalimaGateLevel
PUBLIC	??_GCKalimaGate@@UAEPAXI@Z			; CKalimaGate::`scalar deleting destructor'
PUBLIC	??_7CKalimaGate@@6B@				; CKalimaGate::`vftable'
PUBLIC	?g_KalimaGate@@3VCKalimaGate@@A			; g_KalimaGate
PUBLIC	??_C@_0CM@PDFGAPNC@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to?5Create@ ; `string'
PUBLIC	??_C@_0EN@GPHOBJAE@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@ ; `string'
PUBLIC	??_C@_0FM@IGFLMFGN@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@ ; `string'
PUBLIC	??_C@_0FE@NNCGKIKM@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@ ; `string'
PUBLIC	??_C@_0GD@BNDCCFJF@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@ ; `string'
PUBLIC	??_C@_0FM@OJLJJEMN@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@ ; `string'
PUBLIC	??_C@_0EK@OMOPGPDM@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@ ; `string'
PUBLIC	??_C@_0JE@GBKKIBCM@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Create?5Kalima@ ; `string'
PUBLIC	??_C@_0FC@ILNKILMI@?$FLKalima?$FN?5Kalima?5Gate?5Vanished?5?9@ ; `string'
PUBLIC	??_C@_0FH@INKPFMP@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@ ; `string'
PUBLIC	??_C@_0FK@FFJOIHJB@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@ ; `string'
PUBLIC	??_C@_0FC@CCIHPNEM@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@ ; `string'
PUBLIC	??_C@_0DG@DFEBENJO@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5mo@ ; `string'
PUBLIC	??_C@_0GD@MOAKLAME@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Tr@ ; `string'
PUBLIC	??_C@_0FF@FPKJHAJK@?$FLKalima?$FN?5DeleteKalimaGate?$CI?$CJ?5?9?5o@ ; `string'
PUBLIC	??_C@_0EA@CCDLFCDJ@?$FLKalima?$FN?5DeleteKalimaGate?$CI?$CJ?5?9?5o@ ; `string'
PUBLIC	??_R4CKalimaGate@@6B@				; CKalimaGate::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCKalimaGate@@@8				; CKalimaGate `RTTI Type Descriptor'
PUBLIC	??_R3CKalimaGate@@8				; CKalimaGate::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CKalimaGate@@8				; CKalimaGate::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CKalimaGate@@8			; CKalimaGate::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@447a0000
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	_abs:PROC
EXTRN	_rand:PROC
EXTRN	__imp_?Get@CMsg@@QAEPADH@Z:PROC
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?GCDiePlayerSend@@YAXPAVOBJECTSTRUCT@@HEH@Z:PROC ; GCDiePlayerSend
EXTRN	??_ECKalimaGate@@UAEPAXI@Z:PROC			; CKalimaGate::`vector deleting destructor'
EXTRN	?MakeItemNumber@@YAHHH@Z:PROC			; MakeItemNumber
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z:PROC ; CMonsterAttr::GetAttr
EXTRN	?gObjCharZeroSet@@YAXH@Z:PROC			; gObjCharZeroSet
EXTRN	__except_handler4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?MapC@@3PAVMapClass@@A:DWORD			; MapC
EXTRN	?gMAttr@@3VCMonsterAttr@@A:BYTE			; gMAttr
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?g_KalimaGate@@3VCKalimaGate@@A DB 01cH DUP (?)		; g_KalimaGate
?g_iChaosCastle_MonsterItems@@3PAY111HA DD 018H DUP (?)	; g_iChaosCastle_MonsterItems
_BSS	ENDS
CRT$XCU	SEGMENT
?g_KalimaGate$initializer$@@3P6AXXZA DD FLAT:??__Eg_KalimaGate@@YAXXZ ; g_KalimaGate$initializer$
CRT$XCU	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CKalimaGate@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CKalimaGate@@8 DD FLAT:??_R0?AVCKalimaGate@@@8 ; CKalimaGate::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CKalimaGate@@8
rdata$r	ENDS
;	COMDAT ??_R2CKalimaGate@@8
rdata$r	SEGMENT
??_R2CKalimaGate@@8 DD FLAT:??_R1A@?0A@EA@CKalimaGate@@8 ; CKalimaGate::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CKalimaGate@@8
rdata$r	SEGMENT
??_R3CKalimaGate@@8 DD 00H				; CKalimaGate::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CKalimaGate@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCKalimaGate@@@8
data$r	SEGMENT
??_R0?AVCKalimaGate@@@8 DD FLAT:??_7type_info@@6B@	; CKalimaGate `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCKalimaGate@@', 00H
data$r	ENDS
;	COMDAT ??_R4CKalimaGate@@6B@
rdata$r	SEGMENT
??_R4CKalimaGate@@6B@ DD 00H				; CKalimaGate::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCKalimaGate@@@8
	DD	FLAT:??_R3CKalimaGate@@8
rdata$r	ENDS
;	COMDAT ??_C@_0EA@CCDLFCDJ@?$FLKalima?$FN?5DeleteKalimaGate?$CI?$CJ?5?9?5o@
CONST	SEGMENT
??_C@_0EA@CCDLFCDJ@?$FLKalima?$FN?5DeleteKalimaGate?$CI?$CJ?5?9?5o@ DB '['
	DB	'Kalima] DeleteKalimaGate() - out of Index (iCallOwnerIndex:%d'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@FPKJHAJK@?$FLKalima?$FN?5DeleteKalimaGate?$CI?$CJ?5?9?5o@
CONST	SEGMENT
??_C@_0FF@FPKJHAJK@?$FLKalima?$FN?5DeleteKalimaGate?$CI?$CJ?5?9?5o@ DB '['
	DB	'Kalima] DeleteKalimaGate() - out of Index (iKalimaGateIndex:%'
	DB	'd, iCallOwnerIndex:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@MOAKLAME@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Tr@
CONST	SEGMENT
??_C@_0GD@MOAKLAME@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Tr@ DB '['
	DB	'Kalima] [%s][%s] - [%s][%s] Transported by Kalima Gate (Summo'
	DB	'nIndex:%d, GateNo.:%d, MapNumber:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@DFEBENJO@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5mo@
CONST	SEGMENT
??_C@_0DG@DFEBENJO@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5mo@ DB '['
	DB	'Kalima] [%s][%s] - [%s][%s] move fail (MapNumber:%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@CCIHPNEM@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@
CONST	SEGMENT
??_C@_0FC@CCIHPNEM@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@ DB '['
	DB	'Kalima] [%s][%s] Kalima Gate Vanished - Time Out (SummonIndex'
	DB	':%d, EnterCount:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@FFJOIHJB@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@
CONST	SEGMENT
??_C@_0FK@FFJOIHJB@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@ DB '['
	DB	'Kalima] [%s][%s] Kalima Gate Vanished - Enter Count Over (Sum'
	DB	'monIndex:%d, EnterCount:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@INKPFMP@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@
CONST	SEGMENT
??_C@_0FH@INKPFMP@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@ DB '['
	DB	'Kalima] [%s][%s] Kalima Gate Vanished - Summoner Died (Summon'
	DB	'Index:%d, EnterCount:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@ILNKILMI@?$FLKalima?$FN?5Kalima?5Gate?5Vanished?5?9@
CONST	SEGMENT
??_C@_0FC@ILNKILMI@?$FLKalima?$FN?5Kalima?5Gate?5Vanished?5?9@ DB '[Kalim'
	DB	'a] Kalima Gate Vanished - Summoner Vanished (SummonIndex:%d, '
	DB	'EnterCount:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0JE@GBKKIBCM@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Create?5Kalima@
CONST	SEGMENT
??_C@_0JE@GBKKIBCM@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Create?5Kalima@ DB '['
	DB	'Kalima] [%s][%s] Create Kalima Gate Successfuly (Live:%d, Gat'
	DB	'eTick:%u, DieRegen:%d, Map:%d, X:%d, Y:%d, SummonIndex:%d, Ow'
	DB	'nerIndex:%d, GateNo.:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@OMOPGPDM@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@
CONST	SEGMENT
??_C@_0EK@OMOPGPDM@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@ DB '['
	DB	'Kalima] [%s][%s] Kalima Gate Vanished - lpMATTR == NULL (Summ'
	DB	'onIndex:%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@OJLJJEMN@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@
CONST	SEGMENT
??_C@_0FM@OJLJJEMN@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@ DB '['
	DB	'Kalima] [%s][%s] Failed to Summon Kalima Gate - Uable to Summ'
	DB	'on in this Map (MapNumber:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@BNDCCFJF@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@
CONST	SEGMENT
??_C@_0GD@BNDCCFJF@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@ DB '['
	DB	'Kalima] [%s][%s] Failed to Summon Kalima Gate - Failed to get'
	DB	' Location (MapNumber:%d, X:%d, Y:%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@NNCGKIKM@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@
CONST	SEGMENT
??_C@_0FE@NNCGKIKM@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@ DB '['
	DB	'Kalima] [%s][%s] Failed to Summon Kalima Gate - Already Have '
	DB	'Gate (SummonIndex:%d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@IGFLMFGN@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@
CONST	SEGMENT
??_C@_0FM@IGFLMFGN@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@ DB '['
	DB	'Kalima] [%s][%s] Failed to Summon Kalima Gate - Called in Saf'
	DB	'tey Area (Map:%d, X:%d, Y:%d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@GPHOBJAE@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@
CONST	SEGMENT
??_C@_0EN@GPHOBJAE@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@ DB '['
	DB	'Kalima] [%s][%s] Failed to Summon Kalima Gate - Gate Level Ch'
	DB	'eck Error : %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PDFGAPNC@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to?5Create@
CONST	SEGMENT
??_C@_0CM@PDFGAPNC@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to?5Create@ DB '['
	DB	'Kalima] [%s][%s] Try to Create Kalima Gate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CKalimaGate@@6B@
CONST	SEGMENT
??_7CKalimaGate@@6B@ DD FLAT:??_R4CKalimaGate@@6B@	; CKalimaGate::`vftable'
	DD	FLAT:??_ECKalimaGate@@UAEPAXI@Z
CONST	ENDS
_DATA	SEGMENT
?g_sttKALIMAGATE_LEVEL@@3PAU_KALIMAGATE_LEVEL@@A DD 0fH	; g_sttKALIMAGATE_LEVEL
	DD	031H
	DD	0fH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	0190H
	DD	0118H
	DD	0190H
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?DeleteKalimaGate@CKalimaGate@@QAEHHH@Z DD 0fffffffeH
	DD	00H
	DD	0ffffff88H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN20@DeleteKali
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z DD 0fffffffeH
	DD	00H
	DD	0ffffff6cH
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN37@CreateKali
xdata$x	ENDS
CRT$XCU	SEGMENT
?g_iChaosCastle_MonsterItems$initializer$@@3P6AXXZA DD FLAT:??__Eg_iChaosCastle_MonsterItems@@YAXXZ ; g_iChaosCastle_MonsterItems$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ChaosCastle.h
;	COMDAT ??__Eg_iChaosCastle_MonsterItems@@YAXXZ
text$di	SEGMENT
??__Eg_iChaosCastle_MonsterItems@@YAXXZ PROC		; `dynamic initializer for 'g_iChaosCastle_MonsterItems'', COMDAT

; 359  : };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 337  : 	MAKE_ITEMNUM(14, 13),		1,								// 1번 캐슬 - 축석

  00009	6a 0d		 push	 13			; 0000000dH
  0000b	6a 0e		 push	 14			; 0000000eH
  0000d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00012	83 c4 08	 add	 esp, 8
  00015	a3 00 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA, eax
  0001a	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+4, 1

; 338  : 	MAKE_ITEMNUM(14, 14),		2,								// 1번 캐슬 - 영석

  00024	6a 0e		 push	 14			; 0000000eH
  00026	6a 0e		 push	 14			; 0000000eH
  00028	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0002d	83 c4 08	 add	 esp, 8
  00030	a3 08 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+8, eax
  00035	c7 05 0c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+12, 2

; 339  : 	
; 340  : 	MAKE_ITEMNUM(14, 13),		1,								// 2번 캐슬 - 축석

  0003f	6a 0d		 push	 13			; 0000000dH
  00041	6a 0e		 push	 14			; 0000000eH
  00043	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00048	83 c4 08	 add	 esp, 8
  0004b	a3 10 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+16, eax
  00050	c7 05 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+20, 1

; 341  : 	MAKE_ITEMNUM(14, 14),		3,								// 2번 캐슬 - 영석

  0005a	6a 0e		 push	 14			; 0000000eH
  0005c	6a 0e		 push	 14			; 0000000eH
  0005e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00063	83 c4 08	 add	 esp, 8
  00066	a3 18 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+24, eax
  0006b	c7 05 1c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+28, 3

; 342  : 	
; 343  : 	MAKE_ITEMNUM(14, 13),		1,								// 3번 캐슬 - 축석

  00075	6a 0d		 push	 13			; 0000000dH
  00077	6a 0e		 push	 14			; 0000000eH
  00079	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0007e	83 c4 08	 add	 esp, 8
  00081	a3 20 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+32, eax
  00086	c7 05 24 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+36, 1

; 344  : 	MAKE_ITEMNUM(14, 14),		3,								// 3번 캐슬 - 영석

  00090	6a 0e		 push	 14			; 0000000eH
  00092	6a 0e		 push	 14			; 0000000eH
  00094	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00099	83 c4 08	 add	 esp, 8
  0009c	a3 28 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+40, eax
  000a1	c7 05 2c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+44, 3

; 345  : 	
; 346  : 	MAKE_ITEMNUM(14, 13),		2,								// 4번 캐슬 - 축석

  000ab	6a 0d		 push	 13			; 0000000dH
  000ad	6a 0e		 push	 14			; 0000000eH
  000af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b4	83 c4 08	 add	 esp, 8
  000b7	a3 30 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+48, eax
  000bc	c7 05 34 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+52, 2

; 347  : 	MAKE_ITEMNUM(14, 14),		2,								// 4번 캐슬 - 영석

  000c6	6a 0e		 push	 14			; 0000000eH
  000c8	6a 0e		 push	 14			; 0000000eH
  000ca	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000cf	83 c4 08	 add	 esp, 8
  000d2	a3 38 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+56, eax
  000d7	c7 05 3c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+60, 2

; 348  : 	
; 349  : 	MAKE_ITEMNUM(14, 13),		2,								// 5번 캐슬 - 축석

  000e1	6a 0d		 push	 13			; 0000000dH
  000e3	6a 0e		 push	 14			; 0000000eH
  000e5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ea	83 c4 08	 add	 esp, 8
  000ed	a3 40 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+64, eax
  000f2	c7 05 44 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+68, 2

; 350  : 	MAKE_ITEMNUM(14, 14),		3,								// 5번 캐슬 - 영석

  000fc	6a 0e		 push	 14			; 0000000eH
  000fe	6a 0e		 push	 14			; 0000000eH
  00100	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00105	83 c4 08	 add	 esp, 8
  00108	a3 48 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+72, eax
  0010d	c7 05 4c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+76, 3

; 351  : 	
; 352  : 	MAKE_ITEMNUM(14, 13),		2,								// 6번 캐슬 - 축석

  00117	6a 0d		 push	 13			; 0000000dH
  00119	6a 0e		 push	 14			; 0000000eH
  0011b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00120	83 c4 08	 add	 esp, 8
  00123	a3 50 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+80, eax
  00128	c7 05 54 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+84, 2

; 353  : 	MAKE_ITEMNUM(14, 14),		3,								// 6번 캐슬 - 영석

  00132	6a 0e		 push	 14			; 0000000eH
  00134	6a 0e		 push	 14			; 0000000eH
  00136	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0013b	83 c4 08	 add	 esp, 8
  0013e	a3 58 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+88, eax
  00143	c7 05 5c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+92, 3
  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
??__Eg_iChaosCastle_MonsterItems@@YAXXZ ENDP		; `dynamic initializer for 'g_iChaosCastle_MonsterItems''
text$di	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Fg_KalimaGate@@YAXXZ
text$yd	SEGMENT
??__Fg_KalimaGate@@YAXXZ PROC				; `dynamic atexit destructor for 'g_KalimaGate'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  0000e	e8 00 00 00 00	 call	 ??1CKalimaGate@@UAE@XZ	; CKalimaGate::~CKalimaGate
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_KalimaGate@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_KalimaGate''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\KalimaGate.cpp
;	COMDAT ??__Eg_KalimaGate@@YAXXZ
text$di	SEGMENT
??__Eg_KalimaGate@@YAXXZ PROC				; `dynamic initializer for 'g_KalimaGate'', COMDAT

; 46   : CKalimaGate	g_KalimaGate;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_KalimaGate@@3VCKalimaGate@@A ; g_KalimaGate
  0000e	e8 00 00 00 00	 call	 ??0CKalimaGate@@QAE@XZ	; CKalimaGate::CKalimaGate
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_KalimaGate@@YAXXZ ; `dynamic atexit destructor for 'g_KalimaGate''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_KalimaGate@@YAXXZ ENDP				; `dynamic initializer for 'g_KalimaGate''
text$di	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCKalimaGate@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCKalimaGate@@UAEPAXI@Z PROC				; CKalimaGate::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CKalimaGate@@UAE@XZ	; CKalimaGate::~CKalimaGate
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 1c		 push	 28			; 0000001cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_GCKalimaGate@@UAEPAXI@Z ENDP				; CKalimaGate::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\KalimaGate.cpp
;	COMDAT ?GetKalimaGateLevel@CKalimaGate@@AAEHH@Z
_TEXT	SEGMENT
_iLevel$1 = -12						; size = 4
_iLevel$2 = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?GetKalimaGateLevel@CKalimaGate@@AAEHH@Z PROC		; CKalimaGate::GetKalimaGateLevel, COMDAT
; _this$ = ecx

; 506  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 507  : 	if (gObj[iIndex].Class == CLASS_MAGUMSA || gObj[iIndex].Class == CLASS_DARKLORD) {

  0000c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00013	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00019	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  00021	83 fa 03	 cmp	 edx, 3
  00024	74 1a		 je	 SHORT $LN10@GetKalimaG
  00026	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00033	0f b7 94 01 9c
	00 00 00	 movzx	 edx, WORD PTR [ecx+eax+156]
  0003b	83 fa 04	 cmp	 edx, 4
  0003e	75 67		 jne	 SHORT $LN8@GetKalimaG
$LN10@GetKalimaG:

; 508  : 		for (INT iLevel = 0 ; iLevel < MAX_KALIMAGATE_COUNT ; iLevel++) {

  00040	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _iLevel$2[ebp], 0
  00047	eb 09		 jmp	 SHORT $LN4@GetKalimaG
$LN2@GetKalimaG:
  00049	8b 45 f8	 mov	 eax, DWORD PTR _iLevel$2[ebp]
  0004c	83 c0 01	 add	 eax, 1
  0004f	89 45 f8	 mov	 DWORD PTR _iLevel$2[ebp], eax
$LN4@GetKalimaG:
  00052	83 7d f8 06	 cmp	 DWORD PTR _iLevel$2[ebp], 6
  00056	7d 4d		 jge	 SHORT $LN3@GetKalimaG

; 509  : 			if ( (gObj[iIndex].Level >= g_sttKALIMAGATE_LEVEL[iLevel].iLOWER_BOUND_MAGUMSA) && (gObj[iIndex].Level <= g_sttKALIMAGATE_LEVEL[iLevel].iUPPER_BOUND_MAGUMSA))

  00058	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00065	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _iLevel$2[ebp]
  00070	c1 e0 04	 shl	 eax, 4
  00073	3b 90 08 00 00
	00		 cmp	 edx, DWORD PTR ?g_sttKALIMAGATE_LEVEL@@3PAU_KALIMAGATE_LEVEL@@A[eax+8]
  00079	7c 28		 jl	 SHORT $LN11@GetKalimaG
  0007b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00082	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00088	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  00090	8b 45 f8	 mov	 eax, DWORD PTR _iLevel$2[ebp]
  00093	c1 e0 04	 shl	 eax, 4
  00096	3b 90 0c 00 00
	00		 cmp	 edx, DWORD PTR ?g_sttKALIMAGATE_LEVEL@@3PAU_KALIMAGATE_LEVEL@@A[eax+12]
  0009c	7f 05		 jg	 SHORT $LN11@GetKalimaG

; 510  : 				return iLevel;

  0009e	8b 45 f8	 mov	 eax, DWORD PTR _iLevel$2[ebp]
  000a1	eb 6c		 jmp	 SHORT $LN1@GetKalimaG
$LN11@GetKalimaG:

; 511  : 		}

  000a3	eb a4		 jmp	 SHORT $LN2@GetKalimaG
$LN3@GetKalimaG:

; 512  : 	}

  000a5	eb 65		 jmp	 SHORT $LN9@GetKalimaG
$LN8@GetKalimaG:

; 513  : 	else {
; 514  : 		for (INT iLevel = 0 ; iLevel < MAX_KALIMAGATE_COUNT ; iLevel++) {

  000a7	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _iLevel$1[ebp], 0
  000ae	eb 09		 jmp	 SHORT $LN7@GetKalimaG
$LN5@GetKalimaG:
  000b0	8b 45 f4	 mov	 eax, DWORD PTR _iLevel$1[ebp]
  000b3	83 c0 01	 add	 eax, 1
  000b6	89 45 f4	 mov	 DWORD PTR _iLevel$1[ebp], eax
$LN7@GetKalimaG:
  000b9	83 7d f4 06	 cmp	 DWORD PTR _iLevel$1[ebp], 6
  000bd	7d 4d		 jge	 SHORT $LN9@GetKalimaG

; 515  : 			if ( (gObj[iIndex].Level >= g_sttKALIMAGATE_LEVEL[iLevel].iLOWER_BOUND) && (gObj[iIndex].Level <= g_sttKALIMAGATE_LEVEL[iLevel].iUPPER_BOUND))

  000bf	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cc	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  000d4	8b 45 f4	 mov	 eax, DWORD PTR _iLevel$1[ebp]
  000d7	c1 e0 04	 shl	 eax, 4
  000da	3b 90 00 00 00
	00		 cmp	 edx, DWORD PTR ?g_sttKALIMAGATE_LEVEL@@3PAU_KALIMAGATE_LEVEL@@A[eax]
  000e0	7c 28		 jl	 SHORT $LN12@GetKalimaG
  000e2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ef	0f bf 94 01 a0
	00 00 00	 movsx	 edx, WORD PTR [ecx+eax+160]
  000f7	8b 45 f4	 mov	 eax, DWORD PTR _iLevel$1[ebp]
  000fa	c1 e0 04	 shl	 eax, 4
  000fd	3b 90 04 00 00
	00		 cmp	 edx, DWORD PTR ?g_sttKALIMAGATE_LEVEL@@3PAU_KALIMAGATE_LEVEL@@A[eax+4]
  00103	7f 05		 jg	 SHORT $LN12@GetKalimaG

; 516  : 				return iLevel;

  00105	8b 45 f4	 mov	 eax, DWORD PTR _iLevel$1[ebp]
  00108	eb 05		 jmp	 SHORT $LN1@GetKalimaG
$LN12@GetKalimaG:

; 517  : 		}

  0010a	eb a4		 jmp	 SHORT $LN5@GetKalimaG
$LN9@GetKalimaG:

; 518  : 	}
; 519  : 	
; 520  : 	return -1;

  0010c	83 c8 ff	 or	 eax, -1
$LN1@GetKalimaG:

; 521  : }

  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	5b		 pop	 ebx
  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c2 04 00	 ret	 4
?GetKalimaGateLevel@CKalimaGate@@AAEHH@Z ENDP		; CKalimaGate::GetKalimaGateLevel
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\KalimaGate.cpp
;	COMDAT ?GetRandomLocation@CKalimaGate@@AAEHHAAE0@Z
_TEXT	SEGMENT
tv83 = -88						; size = 4
tv74 = -88						; size = 4
tv68 = -88						; size = 4
_btMapAttr$1 = -17					; size = 1
_iUY$ = -16						; size = 4
_iUX$ = -12						; size = 4
_iCount$ = -8						; size = 4
_this$ = -4						; size = 4
_iMapNumber$ = 8					; size = 4
_cX$ = 12						; size = 4
_cY$ = 16						; size = 4
?GetRandomLocation@CKalimaGate@@AAEHHAAE0@Z PROC	; CKalimaGate::GetRandomLocation, COMDAT
; _this$ = ecx

; 485  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 486  : 	INT iCount = 100;

  0000c	c7 45 f8 64 00
	00 00		 mov	 DWORD PTR _iCount$[ebp], 100 ; 00000064H

; 487  : 	INT iUX = cX;

  00013	8b 45 0c	 mov	 eax, DWORD PTR _cX$[ebp]
  00016	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00019	89 4d f4	 mov	 DWORD PTR _iUX$[ebp], ecx

; 488  : 	INT iUY = cY;

  0001c	8b 45 10	 mov	 eax, DWORD PTR _cY$[ebp]
  0001f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00022	89 4d f0	 mov	 DWORD PTR _iUY$[ebp], ecx
$LN2@GetRandomL:

; 489  : 
; 490  : 	while (iCount-- > 0) {

  00025	8b 45 f8	 mov	 eax, DWORD PTR _iCount$[ebp]
  00028	89 45 a8	 mov	 DWORD PTR tv68[ebp], eax
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _iCount$[ebp]
  0002e	83 e9 01	 sub	 ecx, 1
  00031	89 4d f8	 mov	 DWORD PTR _iCount$[ebp], ecx
  00034	83 7d a8 00	 cmp	 DWORD PTR tv68[ebp], 0
  00038	0f 8e b3 00 00
	00		 jle	 $LN3@GetRandomL

; 491  : 		cX = (rand() % (KALIMAGATE_SUMMON_FIELDSIZE + 1)) * ((rand() % 2) ? 1 : -1) + iUX;

  0003e	e8 00 00 00 00	 call	 _rand
  00043	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00048	79 05		 jns	 SHORT $LN10@GetRandomL
  0004a	48		 dec	 eax
  0004b	83 c8 fe	 or	 eax, -2			; fffffffeH
  0004e	40		 inc	 eax
$LN10@GetRandomL:
  0004f	85 c0		 test	 eax, eax
  00051	74 09		 je	 SHORT $LN6@GetRandomL
  00053	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  0005a	eb 07		 jmp	 SHORT $LN7@GetRandomL
$LN6@GetRandomL:
  0005c	c7 45 a8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
$LN7@GetRandomL:
  00063	e8 00 00 00 00	 call	 _rand
  00068	99		 cdq
  00069	b9 06 00 00 00	 mov	 ecx, 6
  0006e	f7 f9		 idiv	 ecx
  00070	0f af 55 a8	 imul	 edx, DWORD PTR tv74[ebp]
  00074	03 55 f4	 add	 edx, DWORD PTR _iUX$[ebp]
  00077	8b 45 0c	 mov	 eax, DWORD PTR _cX$[ebp]
  0007a	88 10		 mov	 BYTE PTR [eax], dl

; 492  : 		cY = (rand() % (KALIMAGATE_SUMMON_FIELDSIZE + 1)) * ((rand() % 2) ? 1 : -1) + iUY;

  0007c	e8 00 00 00 00	 call	 _rand
  00081	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00086	79 05		 jns	 SHORT $LN11@GetRandomL
  00088	48		 dec	 eax
  00089	83 c8 fe	 or	 eax, -2			; fffffffeH
  0008c	40		 inc	 eax
$LN11@GetRandomL:
  0008d	85 c0		 test	 eax, eax
  0008f	74 09		 je	 SHORT $LN8@GetRandomL
  00091	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv83[ebp], 1
  00098	eb 07		 jmp	 SHORT $LN9@GetRandomL
$LN8@GetRandomL:
  0009a	c7 45 a8 ff ff
	ff ff		 mov	 DWORD PTR tv83[ebp], -1
$LN9@GetRandomL:
  000a1	e8 00 00 00 00	 call	 _rand
  000a6	99		 cdq
  000a7	b9 06 00 00 00	 mov	 ecx, 6
  000ac	f7 f9		 idiv	 ecx
  000ae	0f af 55 a8	 imul	 edx, DWORD PTR tv83[ebp]
  000b2	03 55 f0	 add	 edx, DWORD PTR _iUY$[ebp]
  000b5	8b 45 10	 mov	 eax, DWORD PTR _cY$[ebp]
  000b8	88 10		 mov	 BYTE PTR [eax], dl

; 493  : 
; 494  : 		BYTE btMapAttr = MapC[iMapNumber].GetAttr(cX, cY);

  000ba	8b 45 10	 mov	 eax, DWORD PTR _cY$[ebp]
  000bd	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000c0	51		 push	 ecx
  000c1	8b 55 0c	 mov	 edx, DWORD PTR _cX$[ebp]
  000c4	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000c7	50		 push	 eax
  000c8	69 4d 08 8c 04
	05 00		 imul	 ecx, DWORD PTR _iMapNumber$[ebp], 328844
  000cf	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000d5	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000da	88 45 ef	 mov	 BYTE PTR _btMapAttr$1[ebp], al

; 495  : 		if( btMapAttr == MAP_ATTR_NONE )	// 이동가능한 지역이라면 성공

  000dd	0f b6 45 ef	 movzx	 eax, BYTE PTR _btMapAttr$1[ebp]
  000e1	85 c0		 test	 eax, eax
  000e3	75 07		 jne	 SHORT $LN4@GetRandomL

; 496  : 			return TRUE;

  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	eb 07		 jmp	 SHORT $LN1@GetRandomL
$LN4@GetRandomL:

; 497  : 	}

  000ec	e9 34 ff ff ff	 jmp	 $LN2@GetRandomL
$LN3@GetRandomL:

; 498  : 
; 499  : 	return FALSE;

  000f1	33 c0		 xor	 eax, eax
$LN1@GetRandomL:

; 500  : }

  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	5b		 pop	 ebx
  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c2 0c 00	 ret	 12			; 0000000cH
?GetRandomLocation@CKalimaGate@@AAEHHAAE0@Z ENDP	; CKalimaGate::GetRandomLocation
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\KalimaGate.cpp
;	COMDAT ?DeleteKalimaGate@CKalimaGate@@QAEHH@Z
_TEXT	SEGMENT
tv94 = -80						; size = 4
tv76 = -80						; size = 4
tv66 = -80						; size = 4
tv95 = -76						; size = 4
tv77 = -76						; size = 4
tv67 = -76						; size = 4
_iKalimaGateIndex$ = -8					; size = 4
_this$ = -4						; size = 4
_iCallOwnerIndex$ = 8					; size = 4
?DeleteKalimaGate@CKalimaGate@@QAEHH@Z PROC		; CKalimaGate::DeleteKalimaGate, COMDAT
; _this$ = ecx

; 575  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 576  : 	if(!CHECK_LIMIT(iCallOwnerIndex, MAX_OBJECT)) 

  0000c	83 7d 08 00	 cmp	 DWORD PTR _iCallOwnerIndex$[ebp], 0
  00010	7d 09		 jge	 SHORT $LN9@DeleteKali
  00012	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00019	eb 1f		 jmp	 SHORT $LN10@DeleteKali
$LN9@DeleteKali:
  0001b	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iCallOwnerIndex$[ebp], 7399 ; 00001ce7H
  00022	7e 09		 jle	 SHORT $LN7@DeleteKali
  00024	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  0002b	eb 07		 jmp	 SHORT $LN8@DeleteKali
$LN7@DeleteKali:
  0002d	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN8@DeleteKali:
  00034	8b 45 b0	 mov	 eax, DWORD PTR tv66[ebp]
  00037	89 45 b4	 mov	 DWORD PTR tv67[ebp], eax
$LN10@DeleteKali:
  0003a	83 7d b4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003e	75 19		 jne	 SHORT $LN2@DeleteKali

; 577  : 	{
; 578  : 		LogAddTD("[Kalima] DeleteKalimaGate() - out of Index (iCallOwnerIndex:%d)",

  00040	8b 45 08	 mov	 eax, DWORD PTR _iCallOwnerIndex$[ebp]
  00043	50		 push	 eax
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@CCDLFCDJ@?$FLKalima?$FN?5DeleteKalimaGate?$CI?$CJ?5?9?5o@
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0004f	83 c4 08	 add	 esp, 8

; 579  : 			iCallOwnerIndex
; 580  : 			);
; 581  : 		return FALSE;

  00052	33 c0		 xor	 eax, eax
  00054	e9 d5 00 00 00	 jmp	 $LN1@DeleteKali
$LN2@DeleteKali:

; 582  : 	}
; 583  : 
; 584  : 	INT iKalimaGateIndex = gObj[iCallOwnerIndex].m_iKalimaGateIndex;

  00059	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iCallOwnerIndex$[ebp], 7072
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00066	8b 94 01 28 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+552]
  0006d	89 55 f8	 mov	 DWORD PTR _iKalimaGateIndex$[ebp], edx

; 585  : 	if(!CHECK_LIMIT(iKalimaGateIndex, MAX_OBJECT)) 

  00070	83 7d f8 00	 cmp	 DWORD PTR _iKalimaGateIndex$[ebp], 0
  00074	7d 09		 jge	 SHORT $LN13@DeleteKali
  00076	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
  0007d	eb 1f		 jmp	 SHORT $LN14@DeleteKali
$LN13@DeleteKali:
  0007f	81 7d f8 e7 1c
	00 00		 cmp	 DWORD PTR _iKalimaGateIndex$[ebp], 7399 ; 00001ce7H
  00086	7e 09		 jle	 SHORT $LN11@DeleteKali
  00088	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
  0008f	eb 07		 jmp	 SHORT $LN12@DeleteKali
$LN11@DeleteKali:
  00091	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
$LN12@DeleteKali:
  00098	8b 45 b0	 mov	 eax, DWORD PTR tv76[ebp]
  0009b	89 45 b4	 mov	 DWORD PTR tv77[ebp], eax
$LN14@DeleteKali:
  0009e	83 7d b4 00	 cmp	 DWORD PTR tv77[ebp], 0
  000a2	75 07		 jne	 SHORT $LN3@DeleteKali

; 586  : 	{
; 587  : 		return FALSE;

  000a4	33 c0		 xor	 eax, eax
  000a6	e9 83 00 00 00	 jmp	 $LN1@DeleteKali
$LN3@DeleteKali:

; 588  : 	}
; 589  : 
; 590  : 	if (
; 591  : 		gObj[iKalimaGateIndex].Live == 0 ||

  000ab	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iKalimaGateIndex$[ebp], 7072
  000b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b8	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  000bd	85 d2		 test	 edx, edx
  000bf	74 59		 je	 SHORT $LN5@DeleteKali
  000c1	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iKalimaGateIndex$[ebp], 7072
  000c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ce	0f bf 94 01 fe
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+766]
  000d6	83 fa 33	 cmp	 edx, 51			; 00000033H
  000d9	7d 09		 jge	 SHORT $LN17@DeleteKali
  000db	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], 0
  000e2	eb 30		 jmp	 SHORT $LN18@DeleteKali
$LN17@DeleteKali:
  000e4	69 45 f8 a0 1b
	00 00		 imul	 eax, DWORD PTR _iKalimaGateIndex$[ebp], 7072
  000eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f1	0f bf 94 01 fe
	02 00 00	 movsx	 edx, WORD PTR [ecx+eax+766]
  000f9	83 fa 38	 cmp	 edx, 56			; 00000038H
  000fc	7e 09		 jle	 SHORT $LN15@DeleteKali
  000fe	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
  00105	eb 07		 jmp	 SHORT $LN16@DeleteKali
$LN15@DeleteKali:
  00107	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv94[ebp], 1
$LN16@DeleteKali:
  0010e	8b 45 b0	 mov	 eax, DWORD PTR tv94[ebp]
  00111	89 45 b4	 mov	 DWORD PTR tv95[ebp], eax
$LN18@DeleteKali:
  00114	83 7d b4 00	 cmp	 DWORD PTR tv95[ebp], 0
  00118	75 04		 jne	 SHORT $LN4@DeleteKali
$LN5@DeleteKali:

; 592  : 		!CHECK_KALIMAGATE(gObj[iKalimaGateIndex].m_Attribute)
; 593  : 		) 
; 594  : 	{
; 595  : 		return FALSE;

  0011a	33 c0		 xor	 eax, eax
  0011c	eb 10		 jmp	 SHORT $LN1@DeleteKali
$LN4@DeleteKali:

; 596  : 	}
; 597  : 
; 598  : 	return DeleteKalimaGate (iKalimaGateIndex, iCallOwnerIndex);

  0011e	8b 45 08	 mov	 eax, DWORD PTR _iCallOwnerIndex$[ebp]
  00121	50		 push	 eax
  00122	8b 4d f8	 mov	 ecx, DWORD PTR _iKalimaGateIndex$[ebp]
  00125	51		 push	 ecx
  00126	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ?DeleteKalimaGate@CKalimaGate@@QAEHHH@Z ; CKalimaGate::DeleteKalimaGate
$LN1@DeleteKali:

; 599  : }

  0012e	5f		 pop	 edi
  0012f	5e		 pop	 esi
  00130	5b		 pop	 ebx
  00131	8b e5		 mov	 esp, ebp
  00133	5d		 pop	 ebp
  00134	c2 04 00	 ret	 4
?DeleteKalimaGate@CKalimaGate@@QAEHH@Z ENDP		; CKalimaGate::DeleteKalimaGate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\KalimaGate.cpp
;	COMDAT ?DeleteKalimaGate@CKalimaGate@@QAEHHH@Z
_TEXT	SEGMENT
tv73 = -104						; size = 4
tv68 = -104						; size = 4
tv74 = -100						; size = 4
tv69 = -100						; size = 4
_ret$ = -32						; size = 4
_this$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_iKalimaGateIndex$ = 8					; size = 4
_iCallOwnerIndex$ = 12					; size = 4
?DeleteKalimaGate@CKalimaGate@@QAEHHH@Z PROC		; CKalimaGate::DeleteKalimaGate, COMDAT
; _this$ = ecx

; 528  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?DeleteKalimaGate@CKalimaGate@@QAEHHH@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 c4 a8	 add	 esp, -88		; ffffffa8H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 529  : 	// 이 함수가 실제로 마석을 제거하는 함수
; 530  : 
; 531  : 	EnterCriticalSection(&m_critKalimaGate);

  00033	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00036	83 c0 04	 add	 eax, 4
  00039	50		 push	 eax
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 532  : 
; 533  : 	BOOL ret = FALSE;

  00040	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 534  : 
; 535  : 	__try {

  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 536  : 		if(
; 537  : 			!CHECK_LIMIT(iKalimaGateIndex, MAX_OBJECT) ||

  0004e	83 7d 08 00	 cmp	 DWORD PTR _iKalimaGateIndex$[ebp], 0
  00052	7d 09		 jge	 SHORT $LN8@DeleteKali
  00054	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
  0005b	eb 1f		 jmp	 SHORT $LN9@DeleteKali
$LN8@DeleteKali:
  0005d	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iKalimaGateIndex$[ebp], 7399 ; 00001ce7H
  00064	7e 09		 jle	 SHORT $LN6@DeleteKali
  00066	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  0006d	eb 07		 jmp	 SHORT $LN7@DeleteKali
$LN6@DeleteKali:
  0006f	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
$LN7@DeleteKali:
  00076	8b 45 98	 mov	 eax, DWORD PTR tv68[ebp]
  00079	89 45 9c	 mov	 DWORD PTR tv69[ebp], eax
$LN9@DeleteKali:
  0007c	83 7d 9c 00	 cmp	 DWORD PTR tv69[ebp], 0
  00080	74 34		 je	 SHORT $LN4@DeleteKali
  00082	83 7d 0c 00	 cmp	 DWORD PTR _iCallOwnerIndex$[ebp], 0
  00086	7d 09		 jge	 SHORT $LN12@DeleteKali
  00088	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
  0008f	eb 1f		 jmp	 SHORT $LN13@DeleteKali
$LN12@DeleteKali:
  00091	81 7d 0c e7 1c
	00 00		 cmp	 DWORD PTR _iCallOwnerIndex$[ebp], 7399 ; 00001ce7H
  00098	7e 09		 jle	 SHORT $LN10@DeleteKali
  0009a	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  000a1	eb 07		 jmp	 SHORT $LN11@DeleteKali
$LN10@DeleteKali:
  000a3	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
$LN11@DeleteKali:
  000aa	8b 45 98	 mov	 eax, DWORD PTR tv73[ebp]
  000ad	89 45 9c	 mov	 DWORD PTR tv74[ebp], eax
$LN13@DeleteKali:
  000b0	83 7d 9c 00	 cmp	 DWORD PTR tv74[ebp], 0
  000b4	75 18		 jne	 SHORT $LN3@DeleteKali
$LN4@DeleteKali:

; 538  : 			!CHECK_LIMIT(iCallOwnerIndex, MAX_OBJECT)
; 539  : 			) 
; 540  : 		{
; 541  : 			LogAddTD("[Kalima] DeleteKalimaGate() - out of Index (iKalimaGateIndex:%d, iCallOwnerIndex:%d)",

  000b6	8b 45 0c	 mov	 eax, DWORD PTR _iCallOwnerIndex$[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _iKalimaGateIndex$[ebp]
  000bd	51		 push	 ecx
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_0FF@FPKJHAJK@?$FLKalima?$FN?5DeleteKalimaGate?$CI?$CJ?5?9?5o@
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 542  : 				iKalimaGateIndex,
; 543  : 				iCallOwnerIndex
; 544  : 				);
; 545  : 			__leave;

  000cc	eb 6a		 jmp	 SHORT $LN2@DeleteKali
$LN3@DeleteKali:

; 546  : 		}
; 547  : 			
; 548  : 		GCDiePlayerSend (&gObj[iKalimaGateIndex], iKalimaGateIndex, 0, 0);

  000ce	6a 00		 push	 0
  000d0	6a 00		 push	 0
  000d2	8b 45 08	 mov	 eax, DWORD PTR _iKalimaGateIndex$[ebp]
  000d5	50		 push	 eax
  000d6	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iKalimaGateIndex$[ebp], 7072
  000dd	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e3	51		 push	 ecx
  000e4	e8 00 00 00 00	 call	 ?GCDiePlayerSend@@YAXPAVOBJECTSTRUCT@@HEH@Z ; GCDiePlayerSend
  000e9	83 c4 10	 add	 esp, 16			; 00000010H

; 549  : 
; 550  : //		lpObj->Live							= 0;
; 551  : //		lpObj->Life							= -1;
; 552  : //		lpObj->m_RecallMon					= -1;
; 553  : //		lpObjCallOwner->m_RecallMon			= -1;
; 554  : 
; 555  : 		gObj[iCallOwnerIndex].m_cKalimaGateExist	= false;		// 마석이 주인에게 제거되는 유일한 조건이다.

  000ec	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iCallOwnerIndex$[ebp], 7072
  000f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000f9	c6 84 01 26 02
	00 00 00	 mov	 BYTE PTR [ecx+eax+550], 0

; 556  : 		gObj[iCallOwnerIndex].m_iKalimaGateIndex	= -1;			// 마석이 주인에게 제거되는 유일한 조건이다.

  00101	69 45 0c a0 1b
	00 00		 imul	 eax, DWORD PTR _iCallOwnerIndex$[ebp], 7072
  00108	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0010e	c7 84 01 28 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax+552], -1

; 557  : 
; 558  : 		gObjDel(iKalimaGateIndex);

  00119	8b 45 08	 mov	 eax, DWORD PTR _iKalimaGateIndex$[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00122	83 c4 04	 add	 esp, 4

; 559  : 		gObjCharZeroSet(iKalimaGateIndex);

  00125	8b 45 08	 mov	 eax, DWORD PTR _iKalimaGateIndex$[ebp]
  00128	50		 push	 eax
  00129	e8 00 00 00 00	 call	 ?gObjCharZeroSet@@YAXH@Z ; gObjCharZeroSet
  0012e	83 c4 04	 add	 esp, 4

; 560  : 
; 561  : 		ret = TRUE;

  00131	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1
$LN2@DeleteKali:

; 562  : //		gObjMonsterCallKill(lpObjCallOwner->m_Index);
; 563  : 	}

  00138	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  0013f	e8 02 00 00 00	 call	 $LN17@DeleteKali
  00144	eb 0e		 jmp	 SHORT $LN18@DeleteKali
$LN15@DeleteKali:
$LN20@DeleteKali:
$LN17@DeleteKali:

; 564  : 	__finally {
; 565  : 		LeaveCriticalSection(&m_critKalimaGate);

  00146	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00149	83 c0 04	 add	 eax, 4
  0014c	50		 push	 eax
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN16@DeleteKali:
$LN19@DeleteKali:
  00153	c3		 ret	 0
$LN18@DeleteKali:

; 566  : 	}
; 567  : 
; 568  : 	return ret;

  00154	8b 45 e0	 mov	 eax, DWORD PTR _ret$[ebp]

; 569  : }

  00157	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  0015a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00161	59		 pop	 ecx
  00162	5f		 pop	 edi
  00163	5e		 pop	 esi
  00164	5b		 pop	 ebx
  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c2 08 00	 ret	 8
?DeleteKalimaGate@CKalimaGate@@QAEHHH@Z ENDP		; CKalimaGate::DeleteKalimaGate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\KalimaGate.cpp
;	COMDAT ?CheckOverlapKundunMark@CKalimaGate@@QAEHHE@Z
_TEXT	SEGMENT
tv135 = -84						; size = 4
tv136 = -80						; size = 4
_iITEM_DUR$1 = -12					; size = 4
_x$2 = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_btLevel$ = 12						; size = 1
?CheckOverlapKundunMark@CKalimaGate@@QAEHHE@Z PROC	; CKalimaGate::CheckOverlapKundunMark, COMDAT
; _this$ = ecx

; 454  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 455  : 	for(int x=0; x<MAX_INVENTORY; x++)

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _x$2[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@CheckOverl
$LN2@CheckOverl:
  00015	8b 45 f8	 mov	 eax, DWORD PTR _x$2[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 f8	 mov	 DWORD PTR _x$2[ebp], eax
$LN4@CheckOverl:
  0001e	83 7d f8 4c	 cmp	 DWORD PTR _x$2[ebp], 76	; 0000004cH
  00022	0f 8d e4 00 00
	00		 jge	 $LN3@CheckOverl

; 456  : 	{
; 457  : 		if( gObj[iIndex].pInventory[x].IsItem() == TRUE )

  00028	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0002f	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$2[ebp], 168
  00036	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0003c	03 8c 02 5c 0c
	00 00		 add	 ecx, DWORD PTR [edx+eax+3164]
  00043	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00048	83 f8 01	 cmp	 eax, 1
  0004b	0f 85 b6 00 00
	00		 jne	 $LN7@CheckOverl

; 458  : 		{
; 459  : #ifdef MODIFY_KALIMA_KUNDUNMARK_DROP_01_20040906
; 460  : 			if( gObj[iIndex].pInventory[x].m_Type == MAKE_ITEMNUM(14, 29) 
; 461  : 				&& gObj[iIndex].pInventory[x].m_Level == btLevel )				// 쿤둔의 표식이 존재하고 레벨이 같으면

  00051	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00058	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$2[ebp], 168
  0005f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00065	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  0006c	0f bf 74 08 06	 movsx	 esi, WORD PTR [eax+ecx+6]
  00071	6a 1d		 push	 29			; 0000001dH
  00073	6a 0e		 push	 14			; 0000000eH
  00075	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0007a	83 c4 08	 add	 esp, 8
  0007d	3b f0		 cmp	 esi, eax
  0007f	0f 85 82 00 00
	00		 jne	 $LN7@CheckOverl
  00085	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0008c	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$2[ebp], 168
  00093	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00099	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  000a0	0f bf 4c 08 08	 movsx	 ecx, WORD PTR [eax+ecx+8]
  000a5	0f b6 55 0c	 movzx	 edx, BYTE PTR _btLevel$[ebp]
  000a9	3b ca		 cmp	 ecx, edx
  000ab	75 5a		 jne	 SHORT $LN7@CheckOverl

; 462  : #else
; 463  : 			if( gObj[iIndex].pInventory[x].m_Type == MAKE_ITEMNUM(14, 29) )		// 쿤둔의 표식이 존재한다면
; 464  : #endif
; 465  : 			{
; 466  : 				INT iITEM_DUR = (INT) gObj[iIndex].pInventory[x].m_Durability;	// 아이템 개수 (내구도) 를 얻는다.

  000ad	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000b4	69 4d f8 a8 00
	00 00		 imul	 ecx, DWORD PTR _x$2[ebp], 168
  000bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000c1	8b 84 02 5c 0c
	00 00		 mov	 eax, DWORD PTR [edx+eax+3164]
  000c8	f3 0f 2c 4c 08
	24		 cvttss2si ecx, DWORD PTR [eax+ecx+36]
  000ce	89 4d f4	 mov	 DWORD PTR _iITEM_DUR$1[ebp], ecx

; 467  : 
; 468  : 				if (CHECK_LIMIT(iITEM_DUR, MAX_KALIMAGATE_STONE_OVERLAP)) {

  000d1	83 7d f4 00	 cmp	 DWORD PTR _iITEM_DUR$1[ebp], 0
  000d5	7d 09		 jge	 SHORT $LN11@CheckOverl
  000d7	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv136[ebp], 0
  000de	eb 1c		 jmp	 SHORT $LN12@CheckOverl
$LN11@CheckOverl:
  000e0	83 7d f4 04	 cmp	 DWORD PTR _iITEM_DUR$1[ebp], 4
  000e4	7e 09		 jle	 SHORT $LN9@CheckOverl
  000e6	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv135[ebp], 0
  000ed	eb 07		 jmp	 SHORT $LN10@CheckOverl
$LN9@CheckOverl:
  000ef	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR tv135[ebp], 1
$LN10@CheckOverl:
  000f6	8b 45 ac	 mov	 eax, DWORD PTR tv135[ebp]
  000f9	89 45 b0	 mov	 DWORD PTR tv136[ebp], eax
$LN12@CheckOverl:
  000fc	83 7d b0 00	 cmp	 DWORD PTR tv136[ebp], 0
  00100	74 05		 je	 SHORT $LN7@CheckOverl

; 469  : 					// 만약 10개 미만이라면 여기에 더 넣을 수 있다.
; 470  : 					return x;

  00102	8b 45 f8	 mov	 eax, DWORD PTR _x$2[ebp]
  00105	eb 08		 jmp	 SHORT $LN1@CheckOverl
$LN7@CheckOverl:

; 471  : 				}
; 472  : 			}
; 473  : 		}
; 474  : 	}

  00107	e9 09 ff ff ff	 jmp	 $LN2@CheckOverl
$LN3@CheckOverl:

; 475  : 
; 476  : 	return -1;

  0010c	83 c8 ff	 or	 eax, -1
$LN1@CheckOverl:

; 477  : }

  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	5b		 pop	 ebx
  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c2 08 00	 ret	 8
?CheckOverlapKundunMark@CKalimaGate@@QAEHHE@Z ENDP	; CKalimaGate::CheckOverlapKundunMark
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\KalimaGate.cpp
;	COMDAT ?KalimaGateAct@CKalimaGate@@QAEXH@Z
_TEXT	SEGMENT
tv66 = -112						; size = 4
tv67 = -108						; size = 4
_iOverLevel$1 = -40					; size = 4
_iGateNumber$2 = -36					; size = 4
_iMapNumber$3 = -32					; size = 4
_iMoveMapLevel$4 = -28					; size = 4
_i$5 = -24						; size = 4
_tObjNum$ = -20						; size = 4
_dwTickCount$ = -16					; size = 4
_lpObjCallOwner$ = -12					; size = 4
_lpObj$ = -8						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?KalimaGateAct@CKalimaGate@@QAEXH@Z PROC		; CKalimaGate::KalimaGateAct, COMDAT
; _this$ = ecx

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 295  : 	LPOBJECTSTRUCT lpObj = NULL;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _lpObj$[ebp], 0

; 296  : 	LPOBJECTSTRUCT lpObjCallOwner = NULL;

  00013	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _lpObjCallOwner$[ebp], 0

; 297  : 
; 298  : 	if (!CHECK_LIMIT(iIndex, MAX_OBJECT))

  0001a	83 7d 08 00	 cmp	 DWORD PTR _iIndex$[ebp], 0
  0001e	7d 09		 jge	 SHORT $LN25@KalimaGate
  00020	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00027	eb 1f		 jmp	 SHORT $LN26@KalimaGate
$LN25@KalimaGate:
  00029	81 7d 08 e7 1c
	00 00		 cmp	 DWORD PTR _iIndex$[ebp], 7399 ; 00001ce7H
  00030	7e 09		 jle	 SHORT $LN23@KalimaGate
  00032	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  00039	eb 07		 jmp	 SHORT $LN24@KalimaGate
$LN23@KalimaGate:
  0003b	c7 45 90 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN24@KalimaGate:
  00042	8b 45 90	 mov	 eax, DWORD PTR tv66[ebp]
  00045	89 45 94	 mov	 DWORD PTR tv67[ebp], eax
$LN26@KalimaGate:
  00048	83 7d 94 00	 cmp	 DWORD PTR tv67[ebp], 0
  0004c	75 05		 jne	 SHORT $LN5@KalimaGate

; 299  : 		return;

  0004e	e9 f8 04 00 00	 jmp	 $LN1@KalimaGate
$LN5@KalimaGate:

; 300  : 
; 301  : 	if (gObj[iIndex].Live == 0)

  00053	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0005a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00060	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  00065	85 d2		 test	 edx, edx
  00067	75 05		 jne	 SHORT $LN6@KalimaGate

; 302  : 		return;

  00069	e9 dd 04 00 00	 jmp	 $LN1@KalimaGate
$LN6@KalimaGate:

; 303  : 
; 304  : 	// 소유주가 접속 상태가 아니라면 마석을 제거한다.
; 305  : 	if (!gObjIsConnected(gObj[iIndex].m_RecallMon)) {

  0006e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007b	8b 94 01 a4 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+676]
  00082	52		 push	 edx
  00083	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00088	83 c4 04	 add	 esp, 4
  0008b	85 c0		 test	 eax, eax
  0008d	75 65		 jne	 SHORT $LN7@KalimaGate

; 306  : 		LogAddTD("[Kalima] Kalima Gate Vanished - Summoner Vanished (SummonIndex:%d, EnterCount:%d)", 

  0008f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0009c	0f be 94 01 2c
	02 00 00	 movsx	 edx, BYTE PTR [ecx+eax+556]
  000a4	52		 push	 edx
  000a5	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  000a8	50		 push	 eax
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@ILNKILMI@?$FLKalima?$FN?5Kalima?5Gate?5Vanished?5?9@
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 307  : 			iIndex,
; 308  : 			gObj[iIndex].m_cKalimaGateEnterCount
; 309  : 			);
; 310  : 
; 311  : 		// 마석을 없앤다.
; 312  : 		GCDiePlayerSend (&gObj[iIndex], iIndex, 0, 0);

  000b7	6a 00		 push	 0
  000b9	6a 00		 push	 0
  000bb	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  000be	50		 push	 eax
  000bf	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  000c6	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cc	51		 push	 ecx
  000cd	e8 00 00 00 00	 call	 ?GCDiePlayerSend@@YAXPAVOBJECTSTRUCT@@HEH@Z ; GCDiePlayerSend
  000d2	83 c4 10	 add	 esp, 16			; 00000010H

; 313  : 		gObjDel(iIndex);

  000d5	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  000de	83 c4 04	 add	 esp, 4

; 314  : 		gObjCharZeroSet(iIndex);

  000e1	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ?gObjCharZeroSet@@YAXH@Z ; gObjCharZeroSet
  000ea	83 c4 04	 add	 esp, 4

; 315  : //		gObj[iIndex].m_RecallMon = -1;
; 316  : //		gObjDel(gObj[iIndex].m_Index);
; 317  : 		return;

  000ed	e9 59 04 00 00	 jmp	 $LN1@KalimaGate

; 318  : 	}

  000f2	eb 26		 jmp	 SHORT $LN8@KalimaGate
$LN7@KalimaGate:

; 319  : 	else {
; 320  : 		lpObj = &gObj[iIndex];

  000f4	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000fb	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00101	89 45 f8	 mov	 DWORD PTR _lpObj$[ebp], eax

; 321  : 		lpObjCallOwner = &gObj[lpObj->m_RecallMon];

  00104	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00107	69 88 a4 02 00
	00 a0 1b 00 00	 imul	 ecx, DWORD PTR [eax+676], 7072
  00111	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00117	89 4d f4	 mov	 DWORD PTR _lpObjCallOwner$[ebp], ecx
$LN8@KalimaGate:

; 322  : 	}
; 323  : 
; 324  : 	// 마석을 소환한 사람이 죽었다면 마석을 제거한다.
; 325  : 	if (gObj[gObj[iIndex].m_RecallMon].DieRegen > 0) {			// 자신을 소환한 사람이 죽었다면

  0011a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00121	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00127	69 94 01 a4 02
	00 00 a0 1b 00
	00		 imul	 edx, DWORD PTR [ecx+eax+676], 7072
  00132	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00137	0f be 8c 10 fe
	01 00 00	 movsx	 ecx, BYTE PTR [eax+edx+510]
  0013f	85 c9		 test	 ecx, ecx
  00141	7e 7c		 jle	 SHORT $LN9@KalimaGate

; 326  : 		lpObjCallOwner->AccountID[MAX_IDSTRING]		= '\0';

  00143	b8 01 00 00 00	 mov	 eax, 1
  00148	6b c8 0a	 imul	 ecx, eax, 10
  0014b	8b 55 f4	 mov	 edx, DWORD PTR _lpObjCallOwner$[ebp]
  0014e	c6 44 0a 68 00	 mov	 BYTE PTR [edx+ecx+104], 0

; 327  : 		lpObjCallOwner->Name[MAX_IDSTRING]			= '\0';

  00153	b8 01 00 00 00	 mov	 eax, 1
  00158	6b c8 0a	 imul	 ecx, eax, 10
  0015b	8b 55 f4	 mov	 edx, DWORD PTR _lpObjCallOwner$[ebp]
  0015e	c6 44 0a 73 00	 mov	 BYTE PTR [edx+ecx+115], 0

; 328  : 
; 329  : 		LogAddTD("[Kalima] [%s][%s] Kalima Gate Vanished - Summoner Died (SummonIndex:%d, EnterCount:%d)", 

  00163	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0016a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00170	0f be 94 01 2c
	02 00 00	 movsx	 edx, BYTE PTR [ecx+eax+556]
  00178	52		 push	 edx
  00179	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0017c	50		 push	 eax
  0017d	8b 4d f4	 mov	 ecx, DWORD PTR _lpObjCallOwner$[ebp]
  00180	83 c1 73	 add	 ecx, 115		; 00000073H
  00183	51		 push	 ecx
  00184	8b 55 f4	 mov	 edx, DWORD PTR _lpObjCallOwner$[ebp]
  00187	83 c2 68	 add	 edx, 104		; 00000068H
  0018a	52		 push	 edx
  0018b	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@INKPFMP@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@
  00190	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00196	83 c4 14	 add	 esp, 20			; 00000014H

; 330  : 			lpObjCallOwner->AccountID,
; 331  : 			lpObjCallOwner->Name,
; 332  : 			iIndex,
; 333  : 			gObj[iIndex].m_cKalimaGateEnterCount
; 334  : 			);
; 335  : 
; 336  : 		// 마석을 없앤다.
; 337  : 		DeleteKalimaGate (iIndex, gObj[iIndex].m_RecallMon);

  00199	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001a6	8b 94 01 a4 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+676]
  001ad	52		 push	 edx
  001ae	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  001b1	50		 push	 eax
  001b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b5	e8 00 00 00 00	 call	 ?DeleteKalimaGate@CKalimaGate@@QAEHHH@Z ; CKalimaGate::DeleteKalimaGate

; 338  : 		return;

  001ba	e9 8c 03 00 00	 jmp	 $LN1@KalimaGate
$LN9@KalimaGate:

; 339  : 	}
; 340  : 
; 341  : 
; 342  : 	// 마석의 입장 횟수가 N회를 넘었다면 제거한다.
; 343  : 	if (gObj[iIndex].m_cKalimaGateEnterCount >= MAX_KALIMAGATE_ENTER_COUNT) {

  001bf	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  001c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001cc	0f be 94 01 2c
	02 00 00	 movsx	 edx, BYTE PTR [ecx+eax+556]
  001d4	83 fa 05	 cmp	 edx, 5
  001d7	7c 7c		 jl	 SHORT $LN10@KalimaGate

; 344  : 		lpObjCallOwner->AccountID[MAX_IDSTRING]		= '\0';

  001d9	b8 01 00 00 00	 mov	 eax, 1
  001de	6b c8 0a	 imul	 ecx, eax, 10
  001e1	8b 55 f4	 mov	 edx, DWORD PTR _lpObjCallOwner$[ebp]
  001e4	c6 44 0a 68 00	 mov	 BYTE PTR [edx+ecx+104], 0

; 345  : 		lpObjCallOwner->Name[MAX_IDSTRING]			= '\0';

  001e9	b8 01 00 00 00	 mov	 eax, 1
  001ee	6b c8 0a	 imul	 ecx, eax, 10
  001f1	8b 55 f4	 mov	 edx, DWORD PTR _lpObjCallOwner$[ebp]
  001f4	c6 44 0a 73 00	 mov	 BYTE PTR [edx+ecx+115], 0

; 346  : 
; 347  : 		LogAddTD("[Kalima] [%s][%s] Kalima Gate Vanished - Enter Count Over (SummonIndex:%d, EnterCount:%d)", 

  001f9	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00200	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00206	0f be 94 01 2c
	02 00 00	 movsx	 edx, BYTE PTR [ecx+eax+556]
  0020e	52		 push	 edx
  0020f	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00212	50		 push	 eax
  00213	8b 4d f4	 mov	 ecx, DWORD PTR _lpObjCallOwner$[ebp]
  00216	83 c1 73	 add	 ecx, 115		; 00000073H
  00219	51		 push	 ecx
  0021a	8b 55 f4	 mov	 edx, DWORD PTR _lpObjCallOwner$[ebp]
  0021d	83 c2 68	 add	 edx, 104		; 00000068H
  00220	52		 push	 edx
  00221	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@FFJOIHJB@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@
  00226	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0022c	83 c4 14	 add	 esp, 20			; 00000014H

; 348  : 			lpObjCallOwner->AccountID,
; 349  : 			lpObjCallOwner->Name,
; 350  : 			iIndex,
; 351  : 			gObj[iIndex].m_cKalimaGateEnterCount
; 352  : 			);
; 353  : 
; 354  : 		// 마석을 없앤다.
; 355  : 		DeleteKalimaGate (iIndex, gObj[iIndex].m_RecallMon);

  0022f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00236	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0023c	8b 94 01 a4 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+676]
  00243	52		 push	 edx
  00244	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00247	50		 push	 eax
  00248	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0024b	e8 00 00 00 00	 call	 ?DeleteKalimaGate@CKalimaGate@@QAEHHH@Z ; CKalimaGate::DeleteKalimaGate

; 356  : 		return;

  00250	e9 f6 02 00 00	 jmp	 $LN1@KalimaGate
$LN10@KalimaGate:

; 357  : 	}
; 358  : 
; 359  : 
; 360  : 	// 생성 시간으로 부터 N분이 지났다면 없어진다.
; 361  : 	DWORD dwTickCount = GetTickCount();

  00255	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0025b	89 45 f0	 mov	 DWORD PTR _dwTickCount$[ebp], eax

; 362  : 	if (dwTickCount > lpObj->RegenTime + MAX_KALIMAGATE_LIFE_TICKTERM) {

  0025e	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00261	8b 88 04 02 00
	00		 mov	 ecx, DWORD PTR [eax+516]
  00267	81 c1 20 bf 02
	00		 add	 ecx, 180000		; 0002bf20H
  0026d	39 4d f0	 cmp	 DWORD PTR _dwTickCount$[ebp], ecx
  00270	76 6f		 jbe	 SHORT $LN11@KalimaGate

; 363  : 		lpObjCallOwner->AccountID[MAX_IDSTRING]		= '\0';

  00272	b8 01 00 00 00	 mov	 eax, 1
  00277	6b c8 0a	 imul	 ecx, eax, 10
  0027a	8b 55 f4	 mov	 edx, DWORD PTR _lpObjCallOwner$[ebp]
  0027d	c6 44 0a 68 00	 mov	 BYTE PTR [edx+ecx+104], 0

; 364  : 		lpObjCallOwner->Name[MAX_IDSTRING]			= '\0';

  00282	b8 01 00 00 00	 mov	 eax, 1
  00287	6b c8 0a	 imul	 ecx, eax, 10
  0028a	8b 55 f4	 mov	 edx, DWORD PTR _lpObjCallOwner$[ebp]
  0028d	c6 44 0a 73 00	 mov	 BYTE PTR [edx+ecx+115], 0

; 365  : 
; 366  : 		LogAddTD("[Kalima] [%s][%s] Kalima Gate Vanished - Time Out (SummonIndex:%d, EnterCount:%d)", 

  00292	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00299	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0029f	0f be 94 01 2c
	02 00 00	 movsx	 edx, BYTE PTR [ecx+eax+556]
  002a7	52		 push	 edx
  002a8	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  002ab	50		 push	 eax
  002ac	8b 4d f4	 mov	 ecx, DWORD PTR _lpObjCallOwner$[ebp]
  002af	83 c1 73	 add	 ecx, 115		; 00000073H
  002b2	51		 push	 ecx
  002b3	8b 55 f4	 mov	 edx, DWORD PTR _lpObjCallOwner$[ebp]
  002b6	83 c2 68	 add	 edx, 104		; 00000068H
  002b9	52		 push	 edx
  002ba	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@CCIHPNEM@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@
  002bf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002c5	83 c4 14	 add	 esp, 20			; 00000014H

; 367  : 			lpObjCallOwner->AccountID, 
; 368  : 			lpObjCallOwner->Name,
; 369  : 			iIndex,
; 370  : 			gObj[iIndex].m_cKalimaGateEnterCount
; 371  : 			);
; 372  : 
; 373  : 		// 마석을 없앤다.
; 374  : 		DeleteKalimaGate (lpObj->m_Index, lpObjCallOwner->m_Index);

  002c8	8b 45 f4	 mov	 eax, DWORD PTR _lpObjCallOwner$[ebp]
  002cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  002cd	51		 push	 ecx
  002ce	8b 55 f8	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002d1	8b 02		 mov	 eax, DWORD PTR [edx]
  002d3	50		 push	 eax
  002d4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d7	e8 00 00 00 00	 call	 ?DeleteKalimaGate@CKalimaGate@@QAEHHH@Z ; CKalimaGate::DeleteKalimaGate

; 375  : 		return;

  002dc	e9 6a 02 00 00	 jmp	 $LN1@KalimaGate
$LN11@KalimaGate:

; 376  : 	}
; 377  : 
; 378  : 	// 몬스터의 뷰포트 상에 아무도 없다면 끝난다.
; 379  : 	if( lpObj->VPCount < 1 ) return;

  002e1	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002e4	83 b8 6c 0a 00
	00 01		 cmp	 DWORD PTR [eax+2668], 1
  002eb	7d 05		 jge	 SHORT $LN12@KalimaGate
  002ed	e9 59 02 00 00	 jmp	 $LN1@KalimaGate
$LN12@KalimaGate:

; 380  : 
; 381  : 
; 382  : 	INT	tObjNum	= -1;

  002f2	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _tObjNum$[ebp], -1

; 383  : 	for( int i=0; i<MAX_MONVIEWPORTOBJECT; i++)

  002f9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  00300	eb 09		 jmp	 SHORT $LN4@KalimaGate
$LN2@KalimaGate:
  00302	8b 45 e8	 mov	 eax, DWORD PTR _i$5[ebp]
  00305	83 c0 01	 add	 eax, 1
  00308	89 45 e8	 mov	 DWORD PTR _i$5[ebp], eax
$LN4@KalimaGate:
  0030b	83 7d e8 14	 cmp	 DWORD PTR _i$5[ebp], 20	; 00000014H
  0030f	0f 8d 36 02 00
	00		 jge	 $LN1@KalimaGate

; 384  : 	{
; 385  : 		tObjNum = lpObj->VpPlayer[i].number;

  00315	6b 45 e8 0c	 imul	 eax, DWORD PTR _i$5[ebp], 12
  00319	8b 4d f8	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0031c	0f bf 94 01 66
	03 00 00	 movsx	 edx, WORD PTR [ecx+eax+870]
  00324	89 55 ec	 mov	 DWORD PTR _tObjNum$[ebp], edx

; 386  : 		if( tObjNum >= 0 )

  00327	83 7d ec 00	 cmp	 DWORD PTR _tObjNum$[ebp], 0
  0032b	0f 8c 15 02 00
	00		 jl	 $LN13@KalimaGate

; 387  : 		{
; 388  : 			if( gObj[tObjNum].Type == OBJTYPE_CHARACTER && gObj[tObjNum].Live )

  00331	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00338	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0033e	0f b7 54 01 64	 movzx	 edx, WORD PTR [ecx+eax+100]
  00343	83 fa 01	 cmp	 edx, 1
  00346	0f 85 fa 01 00
	00		 jne	 $LN13@KalimaGate
  0034c	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  00353	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00359	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  0035e	85 d2		 test	 edx, edx
  00360	0f 84 e0 01 00
	00		 je	 $LN13@KalimaGate

; 389  : 			{
; 390  : //				if( (lpObj->Y == gObj[tObjNum].Y) && (lpObj->X == gObj[tObjNum].X) )
; 391  : 				if (abs(lpObj->Y - gObj[tObjNum].Y) < 2 && abs(lpObj->X - gObj[tObjNum].X) < 2 )

  00366	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00369	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00370	69 55 ec a0 1b
	00 00		 imul	 edx, DWORD PTR _tObjNum$[ebp], 7072
  00377	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0037c	0f bf 94 10 06
	01 00 00	 movsx	 edx, WORD PTR [eax+edx+262]
  00384	2b ca		 sub	 ecx, edx
  00386	51		 push	 ecx
  00387	e8 00 00 00 00	 call	 _abs
  0038c	83 c4 04	 add	 esp, 4
  0038f	83 f8 02	 cmp	 eax, 2
  00392	0f 8d ae 01 00
	00		 jge	 $LN13@KalimaGate
  00398	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0039b	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  003a2	69 55 ec a0 1b
	00 00		 imul	 edx, DWORD PTR _tObjNum$[ebp], 7072
  003a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003ae	0f bf 94 10 04
	01 00 00	 movsx	 edx, WORD PTR [eax+edx+260]
  003b6	2b ca		 sub	 ecx, edx
  003b8	51		 push	 ecx
  003b9	e8 00 00 00 00	 call	 _abs
  003be	83 c4 04	 add	 esp, 4
  003c1	83 f8 02	 cmp	 eax, 2
  003c4	0f 8d 7c 01 00
	00		 jge	 $LN13@KalimaGate

; 392  : 				{
; 393  : 					// 마석을 소환한 사람이거나 같은 파티원이라면 이동
; 394  : 					if ((lpObj->m_RecallMon == tObjNum) || ((gObj[tObjNum].PartyNumber != -1) && (lpObjCallOwner->PartyNumber == gObj[tObjNum].PartyNumber))) {

  003ca	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003cd	8b 88 a4 02 00
	00		 mov	 ecx, DWORD PTR [eax+676]
  003d3	3b 4d ec	 cmp	 ecx, DWORD PTR _tObjNum$[ebp]
  003d6	74 3e		 je	 SHORT $LN17@KalimaGate
  003d8	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  003df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  003e5	83 bc 01 88 02
	00 00 ff	 cmp	 DWORD PTR [ecx+eax+648], -1
  003ed	0f 84 53 01 00
	00		 je	 $LN13@KalimaGate
  003f3	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  003fa	8b 4d f4	 mov	 ecx, DWORD PTR _lpObjCallOwner$[ebp]
  003fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00403	8b 89 88 02 00
	00		 mov	 ecx, DWORD PTR [ecx+648]
  00409	3b 8c 02 88 02
	00 00		 cmp	 ecx, DWORD PTR [edx+eax+648]
  00410	0f 85 30 01 00
	00		 jne	 $LN13@KalimaGate
$LN17@KalimaGate:

; 395  : 						INT iMoveMapLevel	= lpObj->m_Attribute - MON_ATTR_KALIMAGATE_1;

  00416	8b 45 f8	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00419	0f bf 88 fe 02
	00 00		 movsx	 ecx, WORD PTR [eax+766]
  00420	83 e9 33	 sub	 ecx, 51			; 00000033H
  00423	89 4d e4	 mov	 DWORD PTR _iMoveMapLevel$4[ebp], ecx

; 396  : 						INT iMapNumber		= MAP_INDEX_KALIMA1 + iMoveMapLevel;

  00426	8b 45 e4	 mov	 eax, DWORD PTR _iMoveMapLevel$4[ebp]
  00429	83 c0 18	 add	 eax, 24			; 00000018H
  0042c	89 45 e0	 mov	 DWORD PTR _iMapNumber$3[ebp], eax

; 397  : #ifdef HIDDEN_KALIMA_20050706
; 398  : 						INT iGateNumber		= g_iKalimaGateGateIndex[iMoveMapLevel];
; 399  : #else
; 400  : 						INT iGateNumber		= GATE_INDEX_KALIMA_1 + iMoveMapLevel;

  0042f	8b 45 e4	 mov	 eax, DWORD PTR _iMoveMapLevel$4[ebp]
  00432	83 c0 58	 add	 eax, 88			; 00000058H
  00435	89 45 dc	 mov	 DWORD PTR _iGateNumber$2[ebp], eax

; 401  : #endif
; 402  : 						INT iOverLevel		= GetKalimaGateLevel(tObjNum);

  00438	8b 45 ec	 mov	 eax, DWORD PTR _tObjNum$[ebp]
  0043b	50		 push	 eax
  0043c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0043f	e8 00 00 00 00	 call	 ?GetKalimaGateLevel@CKalimaGate@@AAEHH@Z ; CKalimaGate::GetKalimaGateLevel
  00444	89 45 d8	 mov	 DWORD PTR _iOverLevel$1[ebp], eax

; 403  : 
; 404  : #ifdef HIDDEN_KALIMA_20050706
; 405  : 						if( iOverLevel >= iMoveMapLevel )		// 자신에게 맞거나 낮은 레벨이라면 입장 가능하다.
; 406  : #else
; 407  : 						if( iOverLevel == iMoveMapLevel )		// 자신에게 맞는 마석에만 입장할 수 있다.

  00447	8b 45 d8	 mov	 eax, DWORD PTR _iOverLevel$1[ebp]
  0044a	3b 45 e4	 cmp	 eax, DWORD PTR _iMoveMapLevel$4[ebp]
  0044d	0f 85 f3 00 00
	00		 jne	 $LN13@KalimaGate

; 408  : #endif
; 409  : 						{							
; 410  : 							if( !gObjMoveGate(tObjNum, iGateNumber) ) {

  00453	8b 45 dc	 mov	 eax, DWORD PTR _iGateNumber$2[ebp]
  00456	50		 push	 eax
  00457	8b 4d ec	 mov	 ecx, DWORD PTR _tObjNum$[ebp]
  0045a	51		 push	 ecx
  0045b	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00460	83 c4 08	 add	 esp, 8
  00463	85 c0		 test	 eax, eax
  00465	75 49		 jne	 SHORT $LN19@KalimaGate

; 411  : 								LogAddTD("[Kalima] [%s][%s] - [%s][%s] move fail (MapNumber:%d)", 

  00467	8b 45 e0	 mov	 eax, DWORD PTR _iMapNumber$3[ebp]
  0046a	50		 push	 eax
  0046b	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _tObjNum$[ebp], 7072
  00472	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00478	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  0047c	50		 push	 eax
  0047d	69 4d ec a0 1b
	00 00		 imul	 ecx, DWORD PTR _tObjNum$[ebp], 7072
  00484	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0048a	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  0048e	50		 push	 eax
  0048f	8b 4d f4	 mov	 ecx, DWORD PTR _lpObjCallOwner$[ebp]
  00492	83 c1 73	 add	 ecx, 115		; 00000073H
  00495	51		 push	 ecx
  00496	8b 55 f4	 mov	 edx, DWORD PTR _lpObjCallOwner$[ebp]
  00499	83 c2 68	 add	 edx, 104		; 00000068H
  0049c	52		 push	 edx
  0049d	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@DFEBENJO@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5mo@
  004a2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004a8	83 c4 18	 add	 esp, 24			; 00000018H

; 412  : 									lpObjCallOwner->AccountID, 
; 413  : 									lpObjCallOwner->Name,
; 414  : 									gObj[tObjNum].AccountID, 
; 415  : 									gObj[tObjNum].Name,
; 416  : 									iMapNumber)
; 417  : 									;
; 418  : 							}

  004ab	e9 96 00 00 00	 jmp	 $LN13@KalimaGate
$LN19@KalimaGate:

; 419  : 							else {
; 420  : 								LogAddTD("[Kalima] [%s][%s] - [%s][%s] Transported by Kalima Gate (SummonIndex:%d, GateNo.:%d, MapNumber:%d)", 

  004b0	8b 45 e0	 mov	 eax, DWORD PTR _iMapNumber$3[ebp]
  004b3	50		 push	 eax
  004b4	8b 4d e4	 mov	 ecx, DWORD PTR _iMoveMapLevel$4[ebp]
  004b7	83 c1 01	 add	 ecx, 1
  004ba	51		 push	 ecx
  004bb	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  004be	52		 push	 edx
  004bf	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  004c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004cc	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  004d0	52		 push	 edx
  004d1	69 45 ec a0 1b
	00 00		 imul	 eax, DWORD PTR _tObjNum$[ebp], 7072
  004d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004de	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  004e2	52		 push	 edx
  004e3	8b 45 f4	 mov	 eax, DWORD PTR _lpObjCallOwner$[ebp]
  004e6	83 c0 73	 add	 eax, 115		; 00000073H
  004e9	50		 push	 eax
  004ea	8b 4d f4	 mov	 ecx, DWORD PTR _lpObjCallOwner$[ebp]
  004ed	83 c1 68	 add	 ecx, 104		; 00000068H
  004f0	51		 push	 ecx
  004f1	68 00 00 00 00	 push	 OFFSET ??_C@_0GD@MOAKLAME@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5?9?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Tr@
  004f6	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004fc	83 c4 20	 add	 esp, 32			; 00000020H

; 421  : 									lpObjCallOwner->AccountID, 
; 422  : 									lpObjCallOwner->Name,
; 423  : 									gObj[tObjNum].AccountID, 
; 424  : 									gObj[tObjNum].Name,
; 425  : 									iIndex,
; 426  : 									iMoveMapLevel+1,
; 427  : 									iMapNumber
; 428  : 									);
; 429  : 								
; 430  : 								gObj[iIndex].m_cKalimaGateEnterCount++;

  004ff	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00506	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0050c	8a 94 01 2c 02
	00 00		 mov	 dl, BYTE PTR [ecx+eax+556]
  00513	80 c2 01	 add	 dl, 1
  00516	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0051d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00523	88 94 01 2c 02
	00 00		 mov	 BYTE PTR [ecx+eax+556], dl

; 431  : 								if (gObj[iIndex].m_cKalimaGateEnterCount >= MAX_KALIMAGATE_ENTER_COUNT)

  0052a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00531	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00537	0f be 94 01 2c
	02 00 00	 movsx	 edx, BYTE PTR [ecx+eax+556]
  0053f	83 fa 05	 cmp	 edx, 5
  00542	7c 02		 jl	 SHORT $LN13@KalimaGate

; 432  : 									return;

  00544	eb 05		 jmp	 SHORT $LN1@KalimaGate
$LN13@KalimaGate:

; 433  : 							}
; 434  : 						}
; 435  : 					}
; 436  : 				}
; 437  : 			}
; 438  : 		}
; 439  : 	}

  00546	e9 b7 fd ff ff	 jmp	 $LN2@KalimaGate
$LN1@KalimaGate:

; 440  : }

  0054b	5f		 pop	 edi
  0054c	5e		 pop	 esi
  0054d	5b		 pop	 ebx
  0054e	8b e5		 mov	 esp, ebp
  00550	5d		 pop	 ebp
  00551	c2 04 00	 ret	 4
?KalimaGateAct@CKalimaGate@@QAEXH@Z ENDP		; CKalimaGate::KalimaGateAct
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\KalimaGate.cpp
;	COMDAT ?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z
_TEXT	SEGMENT
tv153 = -132						; size = 4
tv148 = -132						; size = 4
tv135 = -132						; size = 4
tv154 = -128						; size = 4
tv149 = -128						; size = 4
tv136 = -128						; size = 4
_lpMATTR$2 = -60					; size = 4
_cY$3 = -54						; size = 1
_cX$4 = -53						; size = 1
_iMonsterType$5 = -52					; size = 4
_btMapAttr$6 = -45					; size = 1
_iMapNumber$7 = -44					; size = 4
_iKalimaGateLevel$8 = -40				; size = 4
_iMonsterIndex$ = -36					; size = 4
_bKalimaGateCreateSucceed$ = -32			; size = 4
_this$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_iIndex$ = 8						; size = 4
_btLevel$ = 12						; size = 1
_cTX$ = 16						; size = 1
_cTY$ = 20						; size = 1
?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z PROC		; CKalimaGate::CreateKalimaGate, COMDAT
; _this$ = ecx

; 78   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 c4 8c	 add	 esp, -116		; ffffff8cH
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 79   : 	// 소환자의 주변 5x5 공간에 마석을 생성한다.
; 80   : 	BOOL bKalimaGateCreateSucceed	= FALSE;

  00033	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _bKalimaGateCreateSucceed$[ebp], 0

; 81   : 	INT iMonsterIndex				= -1;

  0003a	c7 45 dc ff ff
	ff ff		 mov	 DWORD PTR _iMonsterIndex$[ebp], -1

; 82   : 
; 83   : 	EnterCriticalSection(&m_critKalimaGate);

  00041	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 c0 04	 add	 eax, 4
  00047	50		 push	 eax
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 84   : 
; 85   : 	__try {

  0004e	9b		 fwait
  0004f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 86   : 		if (!gObjIsConnected(iIndex)) {		// 사용자가 접속 중인지 확인한다.

  00056	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0005f	83 c4 04	 add	 esp, 4
  00062	85 c0		 test	 eax, eax
  00064	75 05		 jne	 SHORT $LN3@CreateKali

; 87   : 			__leave; //return FALSE;

  00066	e9 2a 08 00 00	 jmp	 $LN15@CreateKali
$LN3@CreateKali:

; 88   : 		}
; 89   : 
; 90   : 		LogAddTD("[Kalima] [%s][%s] Try to Create Kalima Gate", 

  0006b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00078	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0007c	52		 push	 edx
  0007d	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00084	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0008a	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0008e	52		 push	 edx
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@PDFGAPNC@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5to?5Create@
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 91   : 			gObj[iIndex].AccountID, 
; 92   : 			gObj[iIndex].Name
; 93   : 			);
; 94   : 
; 95   : 		// 1 . 소환자가 마석을 소환할 수 있는 레벨인지 확인한다.
; 96   : 		INT iKalimaGateLevel = GetKalimaGateLevel(iIndex);

  0009d	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  000a0	50		 push	 eax
  000a1	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	e8 00 00 00 00	 call	 ?GetKalimaGateLevel@CKalimaGate@@AAEHH@Z ; CKalimaGate::GetKalimaGateLevel
  000a9	89 45 d8	 mov	 DWORD PTR _iKalimaGateLevel$8[ebp], eax

; 97   : 
; 98   : #ifdef HIDDEN_KALIMA_20050706
; 99   : 		if( iKalimaGateLevel < (btLevel - 1) )		// 사용자 자신의 게이트 레벨이 마석의 레벨과 같거나 높으면 통과
; 100  : 			__leave;
; 101  : 		iKalimaGateLevel = btLevel - 1;
; 102  : #else
; 103  : #ifdef MODIFY_KALIMA_KUNDUNMARK_DROP_01_20040906
; 104  : 		// 1-1.  EX ) 마석의 레벨과 소환자의 레벨을 확인한다.
; 105  : 		if( iKalimaGateLevel != (btLevel - 1) )

  000ac	0f b6 45 0c	 movzx	 eax, BYTE PTR _btLevel$[ebp]
  000b0	83 e8 01	 sub	 eax, 1
  000b3	39 45 d8	 cmp	 DWORD PTR _iKalimaGateLevel$8[ebp], eax
  000b6	74 05		 je	 SHORT $LN4@CreateKali

; 106  : 			__leave;

  000b8	e9 d8 07 00 00	 jmp	 $LN15@CreateKali
$LN4@CreateKali:

; 107  : #endif
; 108  : #endif
; 109  : 
; 110  : #ifdef ADD_MAPCHECK_OPEN_KALIMAGATE_20041129
; 111  : 		// 칼리마 게이트가 열릴수 있는 곳인지 검사한다.
; 112  : 
; 113  : 		if( gObj[iIndex].m_stateEngagePVP == PVP_USER_PLAYING )

  000bd	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000ca	83 bc 01 80 1a
	00 00 02	 cmp	 DWORD PTR [ecx+eax+6784], 2
  000d2	75 05		 jne	 SHORT $LN5@CreateKali

; 114  : 			__leave;

  000d4	e9 bc 07 00 00	 jmp	 $LN15@CreateKali
$LN5@CreateKali:

; 115  : 
; 116  : 		// 악마의광장 이면
; 117  : #ifdef DEVILSQUARE_EXTEND_20050221		// 데빌스퀘어 맵번호 체크 수정
; 118  : 		if( CHECK_DEVILSQUARE(gObj[iIndex].MapNumber) ) 
; 119  : #else
; 120  : 		if( gObj[iIndex].MapNumber == 9 ) 

  000d9	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e6	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  000ee	83 fa 09	 cmp	 edx, 9
  000f1	75 05		 jne	 SHORT $LN6@CreateKali

; 121  : #endif
; 122  : 			__leave;

  000f3	e9 9d 07 00 00	 jmp	 $LN15@CreateKali
$LN6@CreateKali:

; 123  : 
; 124  : 		// 블러드캐슬 이면
; 125  : 		if( CHECK_BLOODCASTLE( gObj[iIndex].MapNumber ) ) 

  000f8	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  000ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00105	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0010d	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  00110	7d 09		 jge	 SHORT $LN21@CreateKali
  00112	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv136[ebp], 0
  00119	eb 39		 jmp	 SHORT $LN22@CreateKali
$LN21@CreateKali:
  0011b	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00122	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00128	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00130	83 fa 11	 cmp	 edx, 17			; 00000011H
  00133	7e 0c		 jle	 SHORT $LN19@CreateKali
  00135	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv135[ebp], 0
  0013f	eb 0a		 jmp	 SHORT $LN20@CreateKali
$LN19@CreateKali:
  00141	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv135[ebp], 1
$LN20@CreateKali:
  0014b	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv135[ebp]
  00151	89 45 80	 mov	 DWORD PTR tv136[ebp], eax
$LN22@CreateKali:
  00154	83 7d 80 00	 cmp	 DWORD PTR tv136[ebp], 0
  00158	74 05		 je	 SHORT $LN7@CreateKali

; 126  : 			__leave;

  0015a	e9 36 07 00 00	 jmp	 $LN15@CreateKali
$LN7@CreateKali:

; 127  : 
; 128  : 		// 카오스캐슬 이면
; 129  : 		if( CHECK_CHAOSCASTLE( gObj[iIndex].MapNumber ) ) 

  0015f	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00166	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0016c	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00174	83 fa 12	 cmp	 edx, 18			; 00000012H
  00177	7d 09		 jge	 SHORT $LN25@CreateKali
  00179	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv149[ebp], 0
  00180	eb 39		 jmp	 SHORT $LN26@CreateKali
$LN25@CreateKali:
  00182	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00189	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018f	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00197	83 fa 17	 cmp	 edx, 23			; 00000017H
  0019a	7e 0c		 jle	 SHORT $LN23@CreateKali
  0019c	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv148[ebp], 0
  001a6	eb 0a		 jmp	 SHORT $LN24@CreateKali
$LN23@CreateKali:
  001a8	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv148[ebp], 1
$LN24@CreateKali:
  001b2	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv148[ebp]
  001b8	89 45 80	 mov	 DWORD PTR tv149[ebp], eax
$LN26@CreateKali:
  001bb	83 7d 80 00	 cmp	 DWORD PTR tv149[ebp], 0
  001bf	74 05		 je	 SHORT $LN8@CreateKali

; 130  : 			__leave;

  001c1	e9 cf 06 00 00	 jmp	 $LN15@CreateKali
$LN8@CreateKali:

; 131  : #endif
; 132  : 
; 133  : #ifdef MODIFY_ILLUSION_TEMPLE_USE_KALIMA_GATE_BUGFIX_20080821
; 134  : 		// 환영사원 이면
; 135  : 		if( CHECK_ILLUSION_TEMPLE( gObj[iIndex].MapNumber ) )
; 136  : 			__leave;
; 137  : #endif // MODIFY_ILLUSION_TEMPLE_USE_KALIMA_GATE_BUGFIX_20080821
; 138  : 
; 139  : 		if (!CHECK_LIMIT(iKalimaGateLevel, MAX_KALIMAGATE_COUNT)) {

  001c6	83 7d d8 00	 cmp	 DWORD PTR _iKalimaGateLevel$8[ebp], 0
  001ca	7d 09		 jge	 SHORT $LN29@CreateKali
  001cc	c7 45 80 00 00
	00 00		 mov	 DWORD PTR tv154[ebp], 0
  001d3	eb 25		 jmp	 SHORT $LN30@CreateKali
$LN29@CreateKali:
  001d5	83 7d d8 05	 cmp	 DWORD PTR _iKalimaGateLevel$8[ebp], 5
  001d9	7e 0c		 jle	 SHORT $LN27@CreateKali
  001db	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
  001e5	eb 0a		 jmp	 SHORT $LN28@CreateKali
$LN27@CreateKali:
  001e7	c7 85 7c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv153[ebp], 1
$LN28@CreateKali:
  001f1	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv153[ebp]
  001f7	89 45 80	 mov	 DWORD PTR tv154[ebp], eax
$LN30@CreateKali:
  001fa	83 7d 80 00	 cmp	 DWORD PTR tv154[ebp], 0
  001fe	75 3e		 jne	 SHORT $LN9@CreateKali

; 140  : 
; 141  : 			LogAddTD("[Kalima] [%s][%s] Failed to Summon Kalima Gate - Gate Level Check Error : %d", 

  00200	8b 45 d8	 mov	 eax, DWORD PTR _iKalimaGateLevel$8[ebp]
  00203	83 c0 01	 add	 eax, 1
  00206	50		 push	 eax
  00207	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  0020e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00214	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00218	50		 push	 eax
  00219	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  00220	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00226	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  0022a	50		 push	 eax
  0022b	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GPHOBJAE@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@
  00230	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00236	83 c4 10	 add	 esp, 16			; 00000010H

; 142  : 				gObj[iIndex].AccountID, 
; 143  : 				gObj[iIndex].Name,
; 144  : 				iKalimaGateLevel+1
; 145  : 				);
; 146  : 			__leave;

  00239	e9 57 06 00 00	 jmp	 $LN15@CreateKali
$LN9@CreateKali:

; 147  : 		}
; 148  : 
; 149  : 		// 2 . 소환자가 안전지대에 있지 않은지 확인한다.
; 150  : 		INT iMapNumber		= gObj[iIndex].MapNumber;

  0023e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00245	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0024b	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00253	89 55 d4	 mov	 DWORD PTR _iMapNumber$7[ebp], edx

; 151  : 		BYTE btMapAttr		= MapC[iMapNumber].GetAttr(gObj[iIndex].X, gObj[iIndex].Y);

  00256	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0025d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00263	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  0026b	52		 push	 edx
  0026c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00273	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00279	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  00281	52		 push	 edx
  00282	69 4d d4 8c 04
	05 00		 imul	 ecx, DWORD PTR _iMapNumber$7[ebp], 328844
  00289	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0028f	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00294	88 45 d3	 mov	 BYTE PTR _btMapAttr$6[ebp], al

; 152  : 		if( btMapAttr & MAP_ATTR_SAFTYZONE )

  00297	0f b6 45 d3	 movzx	 eax, BYTE PTR _btMapAttr$6[ebp]
  0029b	83 e0 01	 and	 eax, 1
  0029e	74 79		 je	 SHORT $LN10@CreateKali

; 153  : 		{	// 안전지대에서는 마석을 소환할 수 없다.
; 154  : 			LogAddTD("[Kalima] [%s][%s] Failed to Summon Kalima Gate - Called in Saftey Area (Map:%d, X:%d, Y:%d)", 

  002a0	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  002a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ad	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  002b5	52		 push	 edx
  002b6	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  002bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002c3	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  002cb	52		 push	 edx
  002cc	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  002d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002d9	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  002e1	52		 push	 edx
  002e2	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  002e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002ef	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  002f3	52		 push	 edx
  002f4	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  002fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00301	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  00305	52		 push	 edx
  00306	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@IGFLMFGN@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@
  0030b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00311	83 c4 18	 add	 esp, 24			; 00000018H

; 155  : 				gObj[iIndex].AccountID, 
; 156  : 				gObj[iIndex].Name,
; 157  : 				gObj[iIndex].MapNumber,
; 158  : 				gObj[iIndex].X,
; 159  : 				gObj[iIndex].Y
; 160  : 				);
; 161  : 			__leave;

  00314	e9 7c 05 00 00	 jmp	 $LN15@CreateKali
$LN10@CreateKali:

; 162  : 		}
; 163  : 
; 164  : 		// 3 . 소환자가 이미 생성한 마석이 있는지 확인한다.
; 165  : 		if (gObj[iIndex].m_cKalimaGateExist == (char)true) {			

  00319	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00320	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00326	0f be 94 01 26
	02 00 00	 movsx	 edx, BYTE PTR [ecx+eax+550]
  0032e	83 fa 01	 cmp	 edx, 1
  00331	75 6b		 jne	 SHORT $LN11@CreateKali

; 166  : 				GCServerMsgStringSend(lMsg.Get(1248), iIndex, 1);		// "이미 소환된 마석이 있습니다."

  00333	6a 01		 push	 1
  00335	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  00338	50		 push	 eax
  00339	68 e0 04 00 00	 push	 1248			; 000004e0H
  0033e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  00343	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  00349	50		 push	 eax
  0034a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  0034f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 167  : 				LogAddTD("[Kalima] [%s][%s] Failed to Summon Kalima Gate - Already Have Gate (SummonIndex:%d)", 

  00352	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00359	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0035f	8b 94 01 28 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+552]
  00366	52		 push	 edx
  00367	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0036e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00374	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00378	52		 push	 edx
  00379	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00380	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00386	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0038a	52		 push	 edx
  0038b	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@NNCGKIKM@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@
  00390	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00396	83 c4 10	 add	 esp, 16			; 00000010H

; 168  : 					gObj[iIndex].AccountID, 
; 169  : 					gObj[iIndex].Name,
; 170  : 					gObj[iIndex].m_iKalimaGateIndex
; 171  : 					);
; 172  : 				__leave;

  00399	e9 f7 04 00 00	 jmp	 $LN15@CreateKali
$LN11@CreateKali:

; 173  : 		}
; 174  : 
; 175  : 		// 4 . 마석을 생성한다.
; 176  : 		INT iMonsterType = MONSTER_INDEX_KALIMA_1+iKalimaGateLevel;		// 실제 몬스터

  0039e	8b 45 d8	 mov	 eax, DWORD PTR _iKalimaGateLevel$8[ebp]
  003a1	05 98 00 00 00	 add	 eax, 152		; 00000098H
  003a6	89 45 cc	 mov	 DWORD PTR _iMonsterType$5[ebp], eax

; 177  : 				
; 178  : 		UCHAR cX = cTX;

  003a9	8a 45 10	 mov	 al, BYTE PTR _cTX$[ebp]
  003ac	88 45 cb	 mov	 BYTE PTR _cX$4[ebp], al

; 179  : 		UCHAR cY = cTY;

  003af	8a 45 14	 mov	 al, BYTE PTR _cTY$[ebp]
  003b2	88 45 ca	 mov	 BYTE PTR _cY$3[ebp], al

; 180  : 
; 181  : 		btMapAttr = MapC[iMapNumber].GetAttr(cX, cY);

  003b5	0f b6 45 ca	 movzx	 eax, BYTE PTR _cY$3[ebp]
  003b9	50		 push	 eax
  003ba	0f b6 4d cb	 movzx	 ecx, BYTE PTR _cX$4[ebp]
  003be	51		 push	 ecx
  003bf	69 4d d4 8c 04
	05 00		 imul	 ecx, DWORD PTR _iMapNumber$7[ebp], 328844
  003c6	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  003cc	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  003d1	88 45 d3	 mov	 BYTE PTR _btMapAttr$6[ebp], al

; 182  : 		if( btMapAttr != MAP_ATTR_NONE ) {

  003d4	0f b6 45 d3	 movzx	 eax, BYTE PTR _btMapAttr$6[ebp]
  003d8	85 c0		 test	 eax, eax
  003da	74 6c		 je	 SHORT $LN13@CreateKali

; 183  : 			if (!GetRandomLocation(iMapNumber, cX, cY)) {

  003dc	8d 45 ca	 lea	 eax, DWORD PTR _cY$3[ebp]
  003df	50		 push	 eax
  003e0	8d 4d cb	 lea	 ecx, DWORD PTR _cX$4[ebp]
  003e3	51		 push	 ecx
  003e4	8b 55 d4	 mov	 edx, DWORD PTR _iMapNumber$7[ebp]
  003e7	52		 push	 edx
  003e8	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  003eb	e8 00 00 00 00	 call	 ?GetRandomLocation@CKalimaGate@@AAEHHAAE0@Z ; CKalimaGate::GetRandomLocation
  003f0	85 c0		 test	 eax, eax
  003f2	75 54		 jne	 SHORT $LN13@CreateKali

; 184  : 				LogAddTD("[Kalima] [%s][%s] Failed to Summon Kalima Gate - Failed to get Location (MapNumber:%d, X:%d, Y:%d)", 

  003f4	0f b6 45 ca	 movzx	 eax, BYTE PTR _cY$3[ebp]
  003f8	50		 push	 eax
  003f9	0f b6 4d cb	 movzx	 ecx, BYTE PTR _cX$4[ebp]
  003fd	51		 push	 ecx
  003fe	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  00405	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0040a	0f b6 8c 10 09
	01 00 00	 movzx	 ecx, BYTE PTR [eax+edx+265]
  00412	51		 push	 ecx
  00413	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  0041a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0041f	8d 4c 10 73	 lea	 ecx, DWORD PTR [eax+edx+115]
  00423	51		 push	 ecx
  00424	69 55 08 a0 1b
	00 00		 imul	 edx, DWORD PTR _iIndex$[ebp], 7072
  0042b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00430	8d 4c 10 68	 lea	 ecx, DWORD PTR [eax+edx+104]
  00434	51		 push	 ecx
  00435	68 00 00 00 00	 push	 OFFSET ??_C@_0GD@BNDCCFJF@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@
  0043a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00440	83 c4 18	 add	 esp, 24			; 00000018H

; 185  : 					gObj[iIndex].AccountID, 
; 186  : 					gObj[iIndex].Name,
; 187  : 					gObj[iIndex].MapNumber,
; 188  : 					cX, cY
; 189  : 					);
; 190  : 				__leave;

  00443	e9 4d 04 00 00	 jmp	 $LN15@CreateKali
$LN13@CreateKali:

; 191  : 			}
; 192  : 		}
; 193  : 
; 194  : 		// *> 수정부분 (2004.09.13 - b4nfter)
; 195  : 		if( gObj[iIndex].MapNumber == 10	// 천공

  00448	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0044f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00455	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0045d	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00460	75 4d		 jne	 SHORT $LN14@CreateKali

; 196  : 			)
; 197  : 		{	
; 198  : 			// 소환할 수 없는 지역 체크
; 199  : 			LogAddTD("[Kalima] [%s][%s] Failed to Summon Kalima Gate - Uable to Summon in this Map (MapNumber:%d)", 

  00462	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00469	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0046f	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  00477	52		 push	 edx
  00478	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  0047f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00485	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  00489	52		 push	 edx
  0048a	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00491	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00497	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0049b	52		 push	 edx
  0049c	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@OJLJJEMN@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Failed?5to?5Sum@
  004a1	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  004a7	83 c4 10	 add	 esp, 16			; 00000010H

; 200  : 				gObj[iIndex].AccountID, 
; 201  : 				gObj[iIndex].Name,
; 202  : 				gObj[iIndex].MapNumber
; 203  : 				);
; 204  : 			__leave;

  004aa	e9 e6 03 00 00	 jmp	 $LN15@CreateKali
$LN14@CreateKali:

; 205  : 		}
; 206  : 
; 207  : #ifdef MAP_SERVER_ADD_MONSTER_20041216		// 맵서버 관련 몬스터, NPC 추가 (서버가 가지고 있는 맵만 추가가 가능하다.)
; 208  : 		iMonsterIndex = gObjAddMonster(iMapNumber);

  004af	8b 45 d4	 mov	 eax, DWORD PTR _iMapNumber$7[ebp]
  004b2	50		 push	 eax
  004b3	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  004b8	83 c4 04	 add	 esp, 4
  004bb	0f bf c8	 movsx	 ecx, ax
  004be	89 4d dc	 mov	 DWORD PTR _iMonsterIndex$[ebp], ecx

; 209  : #else
; 210  : 		iMonsterIndex = gObjAdd();
; 211  : #endif
; 212  : 		if( iMonsterIndex >= 0 )

  004c1	83 7d dc 00	 cmp	 DWORD PTR _iMonsterIndex$[ebp], 0
  004c5	0f 8c ca 03 00
	00		 jl	 $LN15@CreateKali

; 213  : 		{
; 214  : 			LPMONSTER_ATTRIBUTE		lpMATTR;
; 215  : 			lpMATTR = gMAttr.GetAttr(iMonsterType);

  004cb	8b 45 cc	 mov	 eax, DWORD PTR _iMonsterType$5[ebp]
  004ce	50		 push	 eax
  004cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  004d4	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  004d9	89 45 c4	 mov	 DWORD PTR _lpMATTR$2[ebp], eax

; 216  : 
; 217  : 			if (lpMATTR == NULL) {

  004dc	83 7d c4 00	 cmp	 DWORD PTR _lpMATTR$2[ebp], 0
  004e0	75 47		 jne	 SHORT $LN16@CreateKali

; 218  : 				gObjDel (iMonsterIndex);

  004e2	8b 45 dc	 mov	 eax, DWORD PTR _iMonsterIndex$[ebp]
  004e5	50		 push	 eax
  004e6	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  004eb	83 c4 04	 add	 esp, 4

; 219  : 				LogAddTD("[Kalima] [%s][%s] Kalima Gate Vanished - lpMATTR == NULL (SummonIndex:%d)", 

  004ee	8b 45 dc	 mov	 eax, DWORD PTR _iMonsterIndex$[ebp]
  004f1	50		 push	 eax
  004f2	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  004f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  004ff	8d 44 0a 73	 lea	 eax, DWORD PTR [edx+ecx+115]
  00503	50		 push	 eax
  00504	69 4d 08 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iIndex$[ebp], 7072
  0050b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00511	8d 44 0a 68	 lea	 eax, DWORD PTR [edx+ecx+104]
  00515	50		 push	 eax
  00516	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@OMOPGPDM@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Kalima?5Gate?5V@
  0051b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00521	83 c4 10	 add	 esp, 16			; 00000010H

; 220  : 					gObj[iIndex].AccountID, 
; 221  : 					gObj[iIndex].Name,
; 222  : 					iMonsterIndex
; 223  : 					);
; 224  : 				__leave;

  00524	e9 6c 03 00 00	 jmp	 $LN15@CreateKali
$LN16@CreateKali:

; 225  : 			}
; 226  : 
; 227  : 			gObjSetMonster(iMonsterIndex, iMonsterType);

  00529	8b 45 cc	 mov	 eax, DWORD PTR _iMonsterType$5[ebp]
  0052c	50		 push	 eax
  0052d	8b 4d dc	 mov	 ecx, DWORD PTR _iMonsterIndex$[ebp]
  00530	51		 push	 ecx
  00531	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  00536	83 c4 08	 add	 esp, 8

; 228  : 
; 229  : 			gObj[iMonsterIndex].Live						= 1;

  00539	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  00540	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00546	c6 44 01 66 01	 mov	 BYTE PTR [ecx+eax+102], 1

; 230  : 			gObj[iMonsterIndex].Life						= 1000.0;

  0054b	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  00552	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00558	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@447a0000
  00560	f3 0f 11 84 01
	bc 00 00 00	 movss	 DWORD PTR [ecx+eax+188], xmm0

; 231  : 			gObj[iMonsterIndex].MaxLife						= 1000.0;

  00569	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  00570	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00576	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@447a0000
  0057e	f3 0f 11 84 01
	c0 00 00 00	 movss	 DWORD PTR [ecx+eax+192], xmm0

; 232  : 
; 233  : 			gObj[iMonsterIndex].m_PosNum					= -1;

  00587	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  0058e	83 c9 ff	 or	 ecx, -1
  00591	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00597	66 89 8c 02 0c
	02 00 00	 mov	 WORD PTR [edx+eax+524], cx

; 234  : 			gObj[iMonsterIndex].X							= cX;

  0059f	66 0f b6 45 cb	 movzx	 ax, BYTE PTR _cX$4[ebp]
  005a4	69 4d dc a0 1b
	00 00		 imul	 ecx, DWORD PTR _iMonsterIndex$[ebp], 7072
  005ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005b1	66 89 84 0a 04
	01 00 00	 mov	 WORD PTR [edx+ecx+260], ax

; 235  : 			gObj[iMonsterIndex].Y							= cY;

  005b9	66 0f b6 45 ca	 movzx	 ax, BYTE PTR _cY$3[ebp]
  005be	69 4d dc a0 1b
	00 00		 imul	 ecx, DWORD PTR _iMonsterIndex$[ebp], 7072
  005c5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005cb	66 89 84 0a 06
	01 00 00	 mov	 WORD PTR [edx+ecx+262], ax

; 236  : 			gObj[iMonsterIndex].MTX							= cX;

  005d3	66 0f b6 45 cb	 movzx	 ax, BYTE PTR _cX$4[ebp]
  005d8	69 4d dc a0 1b
	00 00		 imul	 ecx, DWORD PTR _iMonsterIndex$[ebp], 7072
  005df	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005e5	66 89 84 0a 24
	01 00 00	 mov	 WORD PTR [edx+ecx+292], ax

; 237  : 			gObj[iMonsterIndex].MTY							= cY;

  005ed	66 0f b6 45 ca	 movzx	 ax, BYTE PTR _cY$3[ebp]
  005f2	69 4d dc a0 1b
	00 00		 imul	 ecx, DWORD PTR _iMonsterIndex$[ebp], 7072
  005f9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  005ff	66 89 84 0a 26
	01 00 00	 mov	 WORD PTR [edx+ecx+294], ax

; 238  : 			gObj[iMonsterIndex].TX							= cX;

  00607	66 0f b6 45 cb	 movzx	 ax, BYTE PTR _cX$4[ebp]
  0060c	69 4d dc a0 1b
	00 00		 imul	 ecx, DWORD PTR _iMonsterIndex$[ebp], 7072
  00613	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00619	66 89 84 0a 20
	01 00 00	 mov	 WORD PTR [edx+ecx+288], ax

; 239  : 			gObj[iMonsterIndex].TY							= cY;

  00621	66 0f b6 45 ca	 movzx	 ax, BYTE PTR _cY$3[ebp]
  00626	69 4d dc a0 1b
	00 00		 imul	 ecx, DWORD PTR _iMonsterIndex$[ebp], 7072
  0062d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00633	66 89 84 0a 22
	01 00 00	 mov	 WORD PTR [edx+ecx+290], ax

; 240  : 			gObj[iMonsterIndex].m_OldX						= cX;

  0063b	66 0f b6 45 cb	 movzx	 ax, BYTE PTR _cX$4[ebp]
  00640	69 4d dc a0 1b
	00 00		 imul	 ecx, DWORD PTR _iMonsterIndex$[ebp], 7072
  00647	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0064d	66 89 84 0a 1c
	01 00 00	 mov	 WORD PTR [edx+ecx+284], ax

; 241  : 			gObj[iMonsterIndex].m_OldY						= cY;

  00655	66 0f b6 45 ca	 movzx	 ax, BYTE PTR _cY$3[ebp]
  0065a	69 4d dc a0 1b
	00 00		 imul	 ecx, DWORD PTR _iMonsterIndex$[ebp], 7072
  00661	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00667	66 89 84 0a 1e
	01 00 00	 mov	 WORD PTR [edx+ecx+286], ax

; 242  : 			gObj[iMonsterIndex].StartX						= cX;

  0066f	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  00676	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0067c	8a 55 cb	 mov	 dl, BYTE PTR _cX$4[ebp]
  0067f	88 94 01 1a 01
	00 00		 mov	 BYTE PTR [ecx+eax+282], dl

; 243  : 			gObj[iMonsterIndex].StartY						= cY;

  00686	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  0068d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00693	8a 55 ca	 mov	 dl, BYTE PTR _cY$3[ebp]
  00696	88 94 01 1b 01
	00 00		 mov	 BYTE PTR [ecx+eax+283], dl

; 244  : 			gObj[iMonsterIndex].MapNumber					= iMapNumber;

  0069d	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  006a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006aa	8a 55 d4	 mov	 dl, BYTE PTR _iMapNumber$7[ebp]
  006ad	88 94 01 09 01
	00 00		 mov	 BYTE PTR [ecx+eax+265], dl

; 245  : 			gObj[iMonsterIndex].m_MoveRange					= 0;

  006b4	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  006bb	33 c9		 xor	 ecx, ecx
  006bd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006c3	66 89 8c 02 f6
	02 00 00	 mov	 WORD PTR [edx+eax+758], cx

; 246  : 			gObj[iMonsterIndex].m_cKalimaGateEnterCount		= 0;								// 마석의 입장 가능횟수

  006cb	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  006d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006d8	c6 84 01 2c 02
	00 00 00	 mov	 BYTE PTR [ecx+eax+556], 0

; 247  : 
; 248  : 			gObj[iIndex].m_cKalimaGateExist					= true;								// 다만 마석이 존재하는 것으로 체크한다.

  006e0	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  006e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  006ed	c6 84 01 26 02
	00 00 01	 mov	 BYTE PTR [ecx+eax+550], 1

; 249  : 			gObj[iIndex].m_iKalimaGateIndex					= iMonsterIndex;					// 마석의 인덱스를 별도록 기록

  006f5	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  006fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00702	8b 55 dc	 mov	 edx, DWORD PTR _iMonsterIndex$[ebp]
  00705	89 94 01 28 02
	00 00		 mov	 DWORD PTR [ecx+eax+552], edx

; 250  : 
; 251  : 			gObj[iMonsterIndex].Level						= lpMATTR->m_Level;

  0070c	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  00713	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00719	8b 55 c4	 mov	 edx, DWORD PTR _lpMATTR$2[ebp]
  0071c	66 8b 52 1c	 mov	 dx, WORD PTR [edx+28]
  00720	66 89 94 01 a0
	00 00 00	 mov	 WORD PTR [ecx+eax+160], dx

; 252  : 
; 253  : 			gObj[iMonsterIndex].Type						= OBJTYPE_MONSTER;	// 몬스터

  00728	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  0072f	b9 02 00 00 00	 mov	 ecx, 2
  00734	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0073a	66 89 4c 02 64	 mov	 WORD PTR [edx+eax+100], cx

; 254  : 			gObj[iMonsterIndex].MaxRegenTime				= 1000;

  0073f	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  00746	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0074c	c7 84 01 08 02
	00 00 e8 03 00
	00		 mov	 DWORD PTR [ecx+eax+520], 1000 ; 000003e8H

; 255  : 			gObj[iMonsterIndex].Dir							= 1;				// 방향은 화면을 기준으로 입구가 항상 아래로 향한다.

  00757	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  0075e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00764	c6 84 01 08 01
	00 00 01	 mov	 BYTE PTR [ecx+eax+264], 1

; 256  : 			
; 257  : 			gObj[iMonsterIndex].m_RecallMon					= iIndex;

  0076c	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  00773	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00779	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  0077c	89 94 01 a4 02
	00 00		 mov	 DWORD PTR [ecx+eax+676], edx

; 258  : 
; 259  : 			gObj[iMonsterIndex].RegenTime					= GetTickCount();	// 마석의 리젠시간은 마석이 처음 생긴 시간이고 나중에 + 생명주기와 함께 체크한다.

  00783	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00789	69 4d dc a0 1b
	00 00		 imul	 ecx, DWORD PTR _iMonsterIndex$[ebp], 7072
  00790	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00796	89 84 0a 04 02
	00 00		 mov	 DWORD PTR [edx+ecx+516], eax

; 260  : 
; 261  : 			gObj[iMonsterIndex].m_Attribute					= MON_ATTR_KALIMAGATE_1 + iKalimaGateLevel;

  0079d	8b 45 d8	 mov	 eax, DWORD PTR _iKalimaGateLevel$8[ebp]
  007a0	83 c0 33	 add	 eax, 51			; 00000033H
  007a3	69 4d dc a0 1b
	00 00		 imul	 ecx, DWORD PTR _iMonsterIndex$[ebp], 7072
  007aa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007b0	66 89 84 0a fe
	02 00 00	 mov	 WORD PTR [edx+ecx+766], ax

; 262  : 
; 263  : 			gObj[iMonsterIndex].DieRegen					= 0;				// 이 수치가 초기화 되지 않아서 마석이 사라지는 버그발생 (BUGFIX_KALIMAGATE_VANISHING_20041006)

  007b8	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  007bf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007c5	c6 84 01 fe 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+510], 0

; 264  : 
; 265  : 			LogAddTD("[Kalima] [%s][%s] Create Kalima Gate Successfuly (Live:%d, GateTick:%u, DieRegen:%d, Map:%d, X:%d, Y:%d, SummonIndex:%d, OwnerIndex:%d, GateNo.:%d)", 

  007cd	8b 45 d8	 mov	 eax, DWORD PTR _iKalimaGateLevel$8[ebp]
  007d0	83 c0 01	 add	 eax, 1
  007d3	50		 push	 eax
  007d4	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  007d7	51		 push	 ecx
  007d8	8b 55 dc	 mov	 edx, DWORD PTR _iMonsterIndex$[ebp]
  007db	52		 push	 edx
  007dc	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  007e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007e9	0f bf 94 01 06
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+262]
  007f1	52		 push	 edx
  007f2	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  007f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  007ff	0f bf 94 01 04
	01 00 00	 movsx	 edx, WORD PTR [ecx+eax+260]
  00807	52		 push	 edx
  00808	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  0080f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00815	0f b6 94 01 09
	01 00 00	 movzx	 edx, BYTE PTR [ecx+eax+265]
  0081d	52		 push	 edx
  0081e	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  00825	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0082b	0f be 94 01 fe
	01 00 00	 movsx	 edx, BYTE PTR [ecx+eax+510]
  00833	52		 push	 edx
  00834	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  0083b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00841	8b 94 01 04 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+516]
  00848	52		 push	 edx
  00849	69 45 dc a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  00850	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00856	0f b6 54 01 66	 movzx	 edx, BYTE PTR [ecx+eax+102]
  0085b	52		 push	 edx
  0085c	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00863	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00869	8d 54 01 73	 lea	 edx, DWORD PTR [ecx+eax+115]
  0086d	52		 push	 edx
  0086e	69 45 08 a0 1b
	00 00		 imul	 eax, DWORD PTR _iIndex$[ebp], 7072
  00875	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0087b	8d 54 01 68	 lea	 edx, DWORD PTR [ecx+eax+104]
  0087f	52		 push	 edx
  00880	68 00 00 00 00	 push	 OFFSET ??_C@_0JE@GBKKIBCM@?$FLKalima?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Create?5Kalima@
  00885	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0088b	83 c4 30	 add	 esp, 48			; 00000030H

; 266  : 				gObj[iIndex].AccountID, 
; 267  : 				gObj[iIndex].Name,
; 268  : 				gObj[iMonsterIndex].Live,
; 269  : 				gObj[iMonsterIndex].RegenTime,
; 270  : 				gObj[iMonsterIndex].DieRegen,
; 271  : 				gObj[iMonsterIndex].MapNumber,
; 272  : 				gObj[iMonsterIndex].X,
; 273  : 				gObj[iMonsterIndex].Y,
; 274  : 				iMonsterIndex,
; 275  : 				iIndex,
; 276  : 				iKalimaGateLevel+1
; 277  : 				);
; 278  : 			bKalimaGateCreateSucceed	= TRUE;

  0088e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _bKalimaGateCreateSucceed$[ebp], 1
$LN15@CreateKali:

; 279  : 		}
; 280  : 	}

  00895	9b		 fwait
  00896	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  0089d	e8 02 00 00 00	 call	 $LN34@CreateKali
  008a2	eb 0e		 jmp	 SHORT $LN35@CreateKali
$LN32@CreateKali:
$LN37@CreateKali:
$LN34@CreateKali:

; 281  : 	__finally {
; 282  : 		LeaveCriticalSection(&m_critKalimaGate);

  008a4	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  008a7	83 c0 04	 add	 eax, 4
  008aa	50		 push	 eax
  008ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN33@CreateKali:
$LN36@CreateKali:
  008b1	c3		 ret	 0
$LN35@CreateKali:

; 283  : 
; 284  : 		if (bKalimaGateCreateSucceed){
; 285  : 			// 마석이 성공적으로 생성됨
; 286  : 		}
; 287  : 	}
; 288  : 
; 289  : 	return bKalimaGateCreateSucceed;

  008b2	8b 45 e0	 mov	 eax, DWORD PTR _bKalimaGateCreateSucceed$[ebp]

; 290  : }

  008b5	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  008b8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  008bf	59		 pop	 ecx
  008c0	5f		 pop	 edi
  008c1	5e		 pop	 esi
  008c2	5b		 pop	 ebx
  008c3	8b e5		 mov	 esp, ebp
  008c5	5d		 pop	 ebp
  008c6	c2 10 00	 ret	 16			; 00000010H
?CreateKalimaGate@CKalimaGate@@QAEHHEEE@Z ENDP		; CKalimaGate::CreateKalimaGate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\KalimaGate.cpp
;	COMDAT ??1CKalimaGate@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CKalimaGate@@UAE@XZ PROC				; CKalimaGate::~CKalimaGate, COMDAT
; _this$ = ecx

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CKalimaGate@@6B@

; 70   : 	DeleteCriticalSection(&m_critKalimaGate);

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 71   : }

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??1CKalimaGate@@UAE@XZ ENDP				; CKalimaGate::~CKalimaGate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\KalimaGate.cpp
;	COMDAT ??0CKalimaGate@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CKalimaGate@@QAE@XZ PROC				; CKalimaGate::CKalimaGate, COMDAT
; _this$ = ecx

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CKalimaGate@@6B@

; 64   : 	InitializeCriticalSection(&m_critKalimaGate);

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 65   : }

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??0CKalimaGate@@QAE@XZ ENDP				; CKalimaGate::CKalimaGate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\KalimaGate.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\KalimaGate.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
