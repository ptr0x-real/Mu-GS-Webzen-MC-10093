; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ; std::_Iterator_base0::_Getcont
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	?_Throw_tree_length_error@std@@YAXXZ		; std::_Throw_tree_length_error
PUBLIC	?set@PBMSG_HEAD@@QAEXPAEEE@Z			; PBMSG_HEAD::set
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
PUBLIC	??0CResetSystem@@QAE@XZ				; CResetSystem::CResetSystem
PUBLIC	??1CResetSystem@@UAE@XZ				; CResetSystem::~CResetSystem
PUBLIC	?Clear@CResetSystem@@QAEXXZ			; CResetSystem::Clear
PUBLIC	?Init@CResetSystem@@QAEXXZ			; CResetSystem::Init
PUBLIC	?Load@CResetSystem@@QAEHPAD@Z			; CResetSystem::Load
PUBLIC	?DBGetResetInfo@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CResetSystem::DBGetResetInfo
PUBLIC	?DBLoadReset@CResetSystem@@QAEXPAE@Z		; CResetSystem::DBLoadReset
PUBLIC	?DBReqUpdateReset@CResetSystem@@QAEXPAVOBJECTSTRUCT@@HHHHHHHHH@Z ; CResetSystem::DBReqUpdateReset
PUBLIC	?DBAnsUpdateReset@CResetSystem@@QAEXPAE@Z	; CResetSystem::DBAnsUpdateReset
PUBLIC	?ClearAllBuffStates@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CResetSystem::ClearAllBuffStates
PUBLIC	?CalculateEquipment@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CResetSystem::CalculateEquipment
PUBLIC	?FixUserExpInterface@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CResetSystem::FixUserExpInterface
PUBLIC	?SetUserDefaultLifePlusMana@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CResetSystem::SetUserDefaultLifePlusMana
PUBLIC	?SetUserBornPlace@CResetSystem@@QAEXPAVOBJECTSTRUCT@@HH@Z ; CResetSystem::SetUserBornPlace
PUBLIC	?UpdateUserStatusPoint@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CResetSystem::UpdateUserStatusPoint
PUBLIC	?SearchResetRequiredItem@CResetSystem@@QAE_NPAVOBJECTSTRUCT@@H@Z ; CResetSystem::SearchResetRequiredItem
PUBLIC	?DeleteResetRequiredItem@CResetSystem@@QAEXPAVOBJECTSTRUCT@@H@Z ; CResetSystem::DeleteResetRequiredItem
PUBLIC	?CheckUserCondition@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CResetSystem::CheckUserCondition
PUBLIC	?ExecResetApply@CResetSystem@@QAEXPAVOBJECTSTRUCT@@HHHHHHHHH@Z ; CResetSystem::ExecResetApply
PUBLIC	?SetResetNPCData@CResetSystem@@QAEXAAUNPC_DATA@@@Z ; CResetSystem::SetResetNPCData
PUBLIC	?ClearResetNPCData@CResetSystem@@QAEXXZ		; CResetSystem::ClearResetNPCData
PUBLIC	?GetNPCResetData@CResetSystem@@QAEHH@Z		; CResetSystem::GetNPCResetData
PUBLIC	?CheckUserEquipment@CResetSystem@@QAEHPAVOBJECTSTRUCT@@@Z ; CResetSystem::CheckUserEquipment
PUBLIC	?ClearMagicList@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CResetSystem::ClearMagicList
PUBLIC	??0?$allocator@UNON_TABLE_RESET@@@std@@QAE@XZ	; std::allocator<NON_TABLE_RESET>::allocator<NON_TABLE_RESET>
PUBLIC	?deallocate@?$allocator@UNON_TABLE_RESET@@@std@@QAEXQAUNON_TABLE_RESET@@I@Z ; std::allocator<NON_TABLE_RESET>::deallocate
PUBLIC	?allocate@?$allocator@UNON_TABLE_RESET@@@std@@QAEPAUNON_TABLE_RESET@@I@Z ; std::allocator<NON_TABLE_RESET>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@SAIABV?$allocator@UNON_TABLE_RESET@@@2@@Z ; std::_Default_allocator_traits<std::allocator<NON_TABLE_RESET> >::max_size
PUBLIC	??0?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >
PUBLIC	??1?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::~vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >
PUBLIC	?push_back@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEXABUNON_TABLE_RESET@@@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::push_back
PUBLIC	?clear@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEXXZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::clear
PUBLIC	?begin@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@2@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::begin
PUBLIC	?end@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@2@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::end
PUBLIC	?empty@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QBE_NXZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::empty
PUBLIC	?max_size@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QBEIXZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::max_size
PUBLIC	?capacity@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QBEIXZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::capacity
PUBLIC	?_Umove@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEPAUNON_TABLE_RESET@@PAU3@00@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Umove
PUBLIC	?_Umove_if_noexcept1@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@00U?$integral_constant@_N$00@2@@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@00@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@0@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@ABEII@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXQAUNON_TABLE_RESET@@II@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Change_array
PUBLIC	?_Tidy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXXZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Tidy
PUBLIC	?_Xlength@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@CAXXZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@ABEXPAUNON_TABLE_RESET@@0@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Orphan_range
PUBLIC	?_Getal@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UNON_TABLE_RESET@@@2@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Getal
PUBLIC	?_Getal@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@ABEABV?$allocator@UNON_TABLE_RESET@@@2@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UNON_TABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@2@$00@std@@QAEAAV?$allocator@UNON_TABLE_RESET@@@2@XZ ; std::_Compressed_pair<std::allocator<NON_TABLE_RESET>,std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UNON_TABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@2@$00@std@@QBEABV?$allocator@UNON_TABLE_RESET@@@2@XZ ; std::_Compressed_pair<std::allocator<NON_TABLE_RESET>,std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >,1>::_Get_first
PUBLIC	??0?$allocator@UTABLE_RESET@@@std@@QAE@XZ	; std::allocator<TABLE_RESET>::allocator<TABLE_RESET>
PUBLIC	?deallocate@?$allocator@UTABLE_RESET@@@std@@QAEXQAUTABLE_RESET@@I@Z ; std::allocator<TABLE_RESET>::deallocate
PUBLIC	?allocate@?$allocator@UTABLE_RESET@@@std@@QAEPAUTABLE_RESET@@I@Z ; std::allocator<TABLE_RESET>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UTABLE_RESET@@@std@@@std@@SAIABV?$allocator@UTABLE_RESET@@@2@@Z ; std::_Default_allocator_traits<std::allocator<TABLE_RESET> >::max_size
PUBLIC	??0?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::vector<TABLE_RESET,std::allocator<TABLE_RESET> >
PUBLIC	??1?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::~vector<TABLE_RESET,std::allocator<TABLE_RESET> >
PUBLIC	?push_back@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEXABUTABLE_RESET@@@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::push_back
PUBLIC	?clear@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEXXZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::clear
PUBLIC	?begin@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@2@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::begin
PUBLIC	?end@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@2@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::end
PUBLIC	?empty@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QBE_NXZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::empty
PUBLIC	?max_size@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QBEIXZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::max_size
PUBLIC	?capacity@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QBEIXZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::capacity
PUBLIC	?_Umove@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEPAUTABLE_RESET@@PAU3@00@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Umove
PUBLIC	?_Umove_if_noexcept1@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@00U?$integral_constant@_N$00@2@@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@00@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@0@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@ABEII@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXQAUTABLE_RESET@@II@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Change_array
PUBLIC	?_Tidy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXXZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Tidy
PUBLIC	?_Xlength@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@CAXXZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@ABEXPAUTABLE_RESET@@0@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Orphan_range
PUBLIC	?_Getal@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UTABLE_RESET@@@2@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Getal
PUBLIC	?_Getal@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@ABEABV?$allocator@UTABLE_RESET@@@2@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<TABLE_RESET> >::_Vector_val<std::_Simple_types<TABLE_RESET> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UTABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@2@$00@std@@QAEAAV?$allocator@UTABLE_RESET@@@2@XZ ; std::_Compressed_pair<std::allocator<TABLE_RESET>,std::_Vector_val<std::_Simple_types<TABLE_RESET> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UTABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@2@$00@std@@QBEABV?$allocator@UTABLE_RESET@@@2@XZ ; std::_Compressed_pair<std::allocator<TABLE_RESET>,std::_Vector_val<std::_Simple_types<TABLE_RESET> >,1>::_Get_first
PUBLIC	??0?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAE@XZ ; std::allocator<REQUIRE_SPECIAL_ITEM>::allocator<REQUIRE_SPECIAL_ITEM>
PUBLIC	?deallocate@?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAEXQAUREQUIRE_SPECIAL_ITEM@@I@Z ; std::allocator<REQUIRE_SPECIAL_ITEM>::deallocate
PUBLIC	?allocate@?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@I@Z ; std::allocator<REQUIRE_SPECIAL_ITEM>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@SAIABV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@@Z ; std::_Default_allocator_traits<std::allocator<REQUIRE_SPECIAL_ITEM> >::max_size
PUBLIC	??0?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >
PUBLIC	??1?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::~vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >
PUBLIC	?push_back@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEXABUREQUIRE_SPECIAL_ITEM@@@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::push_back
PUBLIC	?clear@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEXXZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::clear
PUBLIC	?begin@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@2@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::begin
PUBLIC	?end@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@2@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::end
PUBLIC	?size@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::size
PUBLIC	?max_size@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::max_size
PUBLIC	?capacity@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::capacity
PUBLIC	?_Umove@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEPAUREQUIRE_SPECIAL_ITEM@@PAU3@00@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Umove
PUBLIC	?_Umove_if_noexcept1@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@00U?$integral_constant@_N$00@2@@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@00@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@0@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@ABEII@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXQAUREQUIRE_SPECIAL_ITEM@@II@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Change_array
PUBLIC	?_Tidy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXXZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Tidy
PUBLIC	?_Xlength@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@CAXXZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@ABEXPAUREQUIRE_SPECIAL_ITEM@@0@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Orphan_range
PUBLIC	?_Getal@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Getal
PUBLIC	?_Getal@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@ABEABV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@2@$00@std@@QAEAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ; std::_Compressed_pair<std::allocator<REQUIRE_SPECIAL_ITEM>,std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@2@$00@std@@QBEABV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ; std::_Compressed_pair<std::allocator<REQUIRE_SPECIAL_ITEM>,std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >,1>::_Get_first
PUBLIC	??0?$allocator@UBORN_PLACE@@@std@@QAE@XZ	; std::allocator<BORN_PLACE>::allocator<BORN_PLACE>
PUBLIC	?deallocate@?$allocator@UBORN_PLACE@@@std@@QAEXQAUBORN_PLACE@@I@Z ; std::allocator<BORN_PLACE>::deallocate
PUBLIC	?allocate@?$allocator@UBORN_PLACE@@@std@@QAEPAUBORN_PLACE@@I@Z ; std::allocator<BORN_PLACE>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@UBORN_PLACE@@@std@@@std@@SAIABV?$allocator@UBORN_PLACE@@@2@@Z ; std::_Default_allocator_traits<std::allocator<BORN_PLACE> >::max_size
PUBLIC	??0?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::vector<BORN_PLACE,std::allocator<BORN_PLACE> >
PUBLIC	??1?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::~vector<BORN_PLACE,std::allocator<BORN_PLACE> >
PUBLIC	?push_back@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEXABUBORN_PLACE@@@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::push_back
PUBLIC	?clear@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEXXZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::clear
PUBLIC	?begin@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@2@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::begin
PUBLIC	?end@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@2@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::end
PUBLIC	?size@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::size
PUBLIC	?max_size@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::max_size
PUBLIC	?capacity@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::capacity
PUBLIC	?_Umove@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEPAUBORN_PLACE@@PAU3@00@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Umove
PUBLIC	?_Umove_if_noexcept1@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@00U?$integral_constant@_N$00@2@@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@00@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@0@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@ABEII@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXQAUBORN_PLACE@@II@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Change_array
PUBLIC	?_Tidy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXXZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Tidy
PUBLIC	?_Xlength@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@CAXXZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@ABEXPAUBORN_PLACE@@0@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Orphan_range
PUBLIC	?_Getal@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEAAV?$allocator@UBORN_PLACE@@@2@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Getal
PUBLIC	?_Getal@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@ABEABV?$allocator@UBORN_PLACE@@@2@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<BORN_PLACE> >::_Vector_val<std::_Simple_types<BORN_PLACE> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UBORN_PLACE@@@std@@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@2@$00@std@@QAEAAV?$allocator@UBORN_PLACE@@@2@XZ ; std::_Compressed_pair<std::allocator<BORN_PLACE>,std::_Vector_val<std::_Simple_types<BORN_PLACE> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@UBORN_PLACE@@@std@@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@2@$00@std@@QBEABV?$allocator@UBORN_PLACE@@@2@XZ ; std::_Compressed_pair<std::allocator<BORN_PLACE>,std::_Vector_val<std::_Simple_types<BORN_PLACE> >,1>::_Get_first
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >::allocate
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::deallocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::max_size
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::~_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::end
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::size
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::max_size
PUBLIC	?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Erase_unchecked
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::find
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Check_grow_by_1
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Getcomp@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Getcomp
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Getal
PUBLIC	?_Getal@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Getal
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
PUBLIC	?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Max
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Min
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Rrotate
PUBLIC	?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Extract
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Insert_node
PUBLIC	?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Orphan_ptr
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>,1>::_Get_first
PUBLIC	??0?$map@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@@std@@QAE@XZ ; std::map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >::map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >
PUBLIC	??1?$map@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@@std@@QAE@XZ ; std::map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >::~map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >
PUBLIC	??_GCResetSystem@@UAEPAXI@Z			; CResetSystem::`scalar deleting destructor'
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE@PAUTABLE_RESET@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEABUTABLE_RESET@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::_Compat
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator++
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE@PAUTABLE_RESET@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE@PAUNON_TABLE_RESET@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEABUNON_TABLE_RESET@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::_Compat
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator++
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE@PAUNON_TABLE_RESET@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAE@PAUBORN_PLACE@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEABUBORN_PLACE@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::_Compat
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEAAUBORN_PLACE@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator++
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAE@PAUBORN_PLACE@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE@PAUREQUIRE_SPECIAL_ITEM@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEABUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::_Compat
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator++
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE@PAUREQUIRE_SPECIAL_ITEM@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >
PUBLIC	??$make_pair@AAHAAUNPC_DATA@@@std@@YA?AU?$pair@HUNPC_DATA@@@0@AAHAAUNPC_DATA@@@Z ; std::make_pair<int &,NPC_DATA &>
PUBLIC	??$?0HUNPC_DATA@@$0A@@?$pair@$$CBHUNPC_DATA@@@std@@QAE@$$QAU?$pair@HUNPC_DATA@@@1@@Z ; std::pair<int const ,NPC_DATA>::pair<int const ,NPC_DATA><int,NPC_DATA,0>
PUBLIC	??$insert@U?$pair@HUNPC_DATA@@@std@@$0A@@?$map@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z ; std::map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >::insert<std::pair<int,NPC_DATA>,0>
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,std::_Iterator_base0>
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,std::_Iterator_base0>::operator++
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHUNPC_DATA@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator*
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator==
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator!=
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHUNPC_DATA@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator*
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHUNPC_DATA@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator->
PUBLIC	?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::_Unwrapped
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >
PUBLIC	??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@1@V21@@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::erase<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >,0>
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@$$CBHUNPC_DATA@@@std@@@std@@SAPAU?$pair@$$CBHUNPC_DATA@@@2@AAU32@@Z ; std::pointer_traits<std::pair<int const ,NPC_DATA> *>::pointer_to
PUBLIC	??$_Find@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Find<int>
PUBLIC	??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >
PUBLIC	??$emplace_back@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE@ABUBORN_PLACE@@@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::emplace_back<BORN_PLACE const &>
PUBLIC	??$forward@ABUBORN_PLACE@@@std@@YAABUBORN_PLACE@@ABU1@@Z ; std::forward<BORN_PLACE const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAE@ABUBORN_PLACE@@@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Emplace_back_with_unused_capacity<BORN_PLACE const &>
PUBLIC	??$_Unfancy@UBORN_PLACE@@@std@@YAPAUBORN_PLACE@@PAU1@@Z ; std::_Unfancy<BORN_PLACE>
PUBLIC	??$construct@UBORN_PLACE@@ABU1@@?$_Default_allocator_traits@V?$allocator@UBORN_PLACE@@@std@@@std@@SAXAAV?$allocator@UBORN_PLACE@@@1@QAUBORN_PLACE@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<BORN_PLACE> >::construct<BORN_PLACE,BORN_PLACE const &>
PUBLIC	??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Emplace_reallocate<BORN_PLACE const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UBORN_PLACE@@@std@@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<BORN_PLACE>,std::_Vector_val<std::_Simple_types<BORN_PLACE> >,1>::_Compressed_pair<std::allocator<BORN_PLACE>,std::_Vector_val<std::_Simple_types<BORN_PLACE> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >
PUBLIC	??$emplace_back@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@ABUREQUIRE_SPECIAL_ITEM@@@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::emplace_back<REQUIRE_SPECIAL_ITEM const &>
PUBLIC	??$forward@ABUREQUIRE_SPECIAL_ITEM@@@std@@YAABUREQUIRE_SPECIAL_ITEM@@ABU1@@Z ; std::forward<REQUIRE_SPECIAL_ITEM const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAE@ABUREQUIRE_SPECIAL_ITEM@@@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Emplace_back_with_unused_capacity<REQUIRE_SPECIAL_ITEM const &>
PUBLIC	??$_Unfancy@UREQUIRE_SPECIAL_ITEM@@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@PAU1@@Z ; std::_Unfancy<REQUIRE_SPECIAL_ITEM>
PUBLIC	??$construct@UREQUIRE_SPECIAL_ITEM@@ABU1@@?$_Default_allocator_traits@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@SAXAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@1@QAUREQUIRE_SPECIAL_ITEM@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<REQUIRE_SPECIAL_ITEM> >::construct<REQUIRE_SPECIAL_ITEM,REQUIRE_SPECIAL_ITEM const &>
PUBLIC	??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Emplace_reallocate<REQUIRE_SPECIAL_ITEM const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<REQUIRE_SPECIAL_ITEM>,std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >,1>::_Compressed_pair<std::allocator<REQUIRE_SPECIAL_ITEM>,std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >
PUBLIC	??$emplace_back@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE@ABUTABLE_RESET@@@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::emplace_back<TABLE_RESET const &>
PUBLIC	??$forward@ABUTABLE_RESET@@@std@@YAABUTABLE_RESET@@ABU1@@Z ; std::forward<TABLE_RESET const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAE@ABUTABLE_RESET@@@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Emplace_back_with_unused_capacity<TABLE_RESET const &>
PUBLIC	??$_Unfancy@UTABLE_RESET@@@std@@YAPAUTABLE_RESET@@PAU1@@Z ; std::_Unfancy<TABLE_RESET>
PUBLIC	??$construct@UTABLE_RESET@@ABU1@@?$_Default_allocator_traits@V?$allocator@UTABLE_RESET@@@std@@@std@@SAXAAV?$allocator@UTABLE_RESET@@@1@QAUTABLE_RESET@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<TABLE_RESET> >::construct<TABLE_RESET,TABLE_RESET const &>
PUBLIC	??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Emplace_reallocate<TABLE_RESET const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UTABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<TABLE_RESET>,std::_Vector_val<std::_Simple_types<TABLE_RESET> >,1>::_Compressed_pair<std::allocator<TABLE_RESET>,std::_Vector_val<std::_Simple_types<TABLE_RESET> >,1><>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >
PUBLIC	??$emplace_back@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE@ABUNON_TABLE_RESET@@@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::emplace_back<NON_TABLE_RESET const &>
PUBLIC	??$forward@ABUNON_TABLE_RESET@@@std@@YAABUNON_TABLE_RESET@@ABU1@@Z ; std::forward<NON_TABLE_RESET const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAE@ABUNON_TABLE_RESET@@@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Emplace_back_with_unused_capacity<NON_TABLE_RESET const &>
PUBLIC	??$_Unfancy@UNON_TABLE_RESET@@@std@@YAPAUNON_TABLE_RESET@@PAU1@@Z ; std::_Unfancy<NON_TABLE_RESET>
PUBLIC	??$construct@UNON_TABLE_RESET@@ABU1@@?$_Default_allocator_traits@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@SAXAAV?$allocator@UNON_TABLE_RESET@@@1@QAUNON_TABLE_RESET@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<NON_TABLE_RESET> >::construct<NON_TABLE_RESET,NON_TABLE_RESET const &>
PUBLIC	??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Emplace_reallocate<NON_TABLE_RESET const &>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@UNON_TABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<NON_TABLE_RESET>,std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >,1>::_Compressed_pair<std::allocator<NON_TABLE_RESET>,std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >,1><>
PUBLIC	??$addressof@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@YAPAU?$pair@$$CBHUNPC_DATA@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,NPC_DATA> >
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@0@ABV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > const >
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >
PUBLIC	??$?0ABU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@UBORN_PLACE@@@std@@@std@@YAXPAUBORN_PLACE@@QAU1@AAV?$allocator@UBORN_PLACE@@@0@@Z ; std::_Destroy_range<std::allocator<BORN_PLACE> >
PUBLIC	??$_Destroy_range@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@YAXPAUREQUIRE_SPECIAL_ITEM@@QAU1@AAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@0@@Z ; std::_Destroy_range<std::allocator<REQUIRE_SPECIAL_ITEM> >
PUBLIC	??$_Destroy_range@V?$allocator@UTABLE_RESET@@@std@@@std@@YAXPAUTABLE_RESET@@QAU1@AAV?$allocator@UTABLE_RESET@@@0@@Z ; std::_Destroy_range<std::allocator<TABLE_RESET> >
PUBLIC	??$_Destroy_range@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@YAXPAUNON_TABLE_RESET@@QAU1@AAV?$allocator@UNON_TABLE_RESET@@@0@@Z ; std::_Destroy_range<std::allocator<NON_TABLE_RESET> >
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<int const ,NPC_DATA>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
PUBLIC	??$forward@AAUNPC_DATA@@@std@@YAAAUNPC_DATA@@AAU1@@Z ; std::forward<NPC_DATA &>
PUBLIC	??$?0AAHAAUNPC_DATA@@$0A@@?$pair@HUNPC_DATA@@@std@@QAE@AAHAAUNPC_DATA@@@Z ; std::pair<int,NPC_DATA>::pair<int,NPC_DATA><int &,NPC_DATA &,0>
PUBLIC	??$forward@U?$pair@HUNPC_DATA@@@std@@@std@@YA$$QAU?$pair@HUNPC_DATA@@@0@AAU10@@Z ; std::forward<std::pair<int,NPC_DATA> >
PUBLIC	??$emplace@U?$pair@HUNPC_DATA@@@std@@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::emplace<std::pair<int,NPC_DATA> >
PUBLIC	??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >
PUBLIC	??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Find_lower_bound<int>
PUBLIC	??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Lower_bound_duplicate<int>
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<int const ,NPC_DATA>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
PUBLIC	??$forward@ABU?$less@H@std@@@std@@YAABU?$less@H@0@ABU10@@Z ; std::forward<std::less<int> const &>
PUBLIC	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * const &>
PUBLIC	??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<int const ,NPC_DATA>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
PUBLIC	??$_Get_size_of_n@$0CI@@std@@YAII@Z		; std::_Get_size_of_n<40>
PUBLIC	??$_Uninitialized_move@PAUBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@YAPAUBORN_PLACE@@QAU1@0PAU1@AAV?$allocator@UBORN_PLACE@@@0@@Z ; std::_Uninitialized_move<BORN_PLACE *,std::allocator<BORN_PLACE> >
PUBLIC	??$_Get_size_of_n@$0M@@std@@YAII@Z		; std::_Get_size_of_n<12>
PUBLIC	??$_Uninitialized_move@PAUREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@QAU1@0PAU1@AAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@0@@Z ; std::_Uninitialized_move<REQUIRE_SPECIAL_ITEM *,std::allocator<REQUIRE_SPECIAL_ITEM> >
PUBLIC	??$_Get_size_of_n@$0BM@@std@@YAII@Z		; std::_Get_size_of_n<28>
PUBLIC	??$_Uninitialized_move@PAUTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@YAPAUTABLE_RESET@@QAU1@0PAU1@AAV?$allocator@UTABLE_RESET@@@0@@Z ; std::_Uninitialized_move<TABLE_RESET *,std::allocator<TABLE_RESET> >
PUBLIC	??$_Get_size_of_n@$0DM@@std@@YAII@Z		; std::_Get_size_of_n<60>
PUBLIC	??$_Uninitialized_move@PAUNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@YAPAUNON_TABLE_RESET@@QAU1@0PAU1@AAV?$allocator@UNON_TABLE_RESET@@@0@@Z ; std::_Uninitialized_move<NON_TABLE_RESET *,std::allocator<NON_TABLE_RESET> >
PUBLIC	??$_Get_size_of_n@$0DE@@std@@YAII@Z		; std::_Get_size_of_n<52>
PUBLIC	??$swap@D$0A@@std@@YAXAAD0@Z			; std::swap<char,0>
PUBLIC	??$_Emplace@U?$pair@HUNPC_DATA@@@std@@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Emplace<std::pair<int,NPC_DATA> >
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@1@AB_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >,bool const &,0>
PUBLIC	??$_Kfn@$$CBHUNPC_DATA@@@?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUNPC_DATA@@@1@@Z ; std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0>::_Kfn<int const ,NPC_DATA>
PUBLIC	??$exchange@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@0@Z ; std::exchange<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>
PUBLIC	??$addressof@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>
PUBLIC	??$forward@ABQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@ABQAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * const &>
PUBLIC	??$destroy@U?$pair@$$CBHUNPC_DATA@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@QAU?$pair@$$CBHUNPC_DATA@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::destroy<std::pair<int const ,NPC_DATA> >
PUBLIC	??$_Get_unwrapped@ABQAUBORN_PLACE@@@std@@YA@ABQAUBORN_PLACE@@@Z ; std::_Get_unwrapped<BORN_PLACE * const &>
PUBLIC	??$_Copy_memmove@PAUBORN_PLACE@@PAU1@@std@@YAPAUBORN_PLACE@@PAU1@00@Z ; std::_Copy_memmove<BORN_PLACE *,BORN_PLACE *>
PUBLIC	??$_Get_unwrapped@ABQAUREQUIRE_SPECIAL_ITEM@@@std@@YA@ABQAUREQUIRE_SPECIAL_ITEM@@@Z ; std::_Get_unwrapped<REQUIRE_SPECIAL_ITEM * const &>
PUBLIC	??$_Copy_memmove@PAUREQUIRE_SPECIAL_ITEM@@PAU1@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@PAU1@00@Z ; std::_Copy_memmove<REQUIRE_SPECIAL_ITEM *,REQUIRE_SPECIAL_ITEM *>
PUBLIC	??$_Get_unwrapped@ABQAUTABLE_RESET@@@std@@YA@ABQAUTABLE_RESET@@@Z ; std::_Get_unwrapped<TABLE_RESET * const &>
PUBLIC	??$_Copy_memmove@PAUTABLE_RESET@@PAU1@@std@@YAPAUTABLE_RESET@@PAU1@00@Z ; std::_Copy_memmove<TABLE_RESET *,TABLE_RESET *>
PUBLIC	??$_Get_unwrapped@ABQAUNON_TABLE_RESET@@@std@@YA@ABQAUNON_TABLE_RESET@@@Z ; std::_Get_unwrapped<NON_TABLE_RESET * const &>
PUBLIC	??$_Copy_memmove@PAUNON_TABLE_RESET@@PAU1@@std@@YAPAUNON_TABLE_RESET@@PAU1@00@Z ; std::_Copy_memmove<NON_TABLE_RESET *,NON_TABLE_RESET *>
PUBLIC	??$move@AAD@std@@YA$$QADAAD@Z			; std::move<char &>
PUBLIC	?_Extract@?$_In_place_key_extract_map@HU?$pair@HUNPC_DATA@@@std@@@std@@SAABHABU?$pair@HUNPC_DATA@@@2@@Z ; std::_In_place_key_extract_map<int,std::pair<int,NPC_DATA> >::_Extract
PUBLIC	??$?0AAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QA_N@Z ; std::pair<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool>::pair<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool><std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &,bool,0>
PUBLIC	??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
PUBLIC	?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Release
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
PUBLIC	??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
PUBLIC	??$?0U?$pair@HUNPC_DATA@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > ><std::pair<int,NPC_DATA> >
PUBLIC	??$?0PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QA_N@Z ; std::pair<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool>::pair<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool><std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool,0>
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > > >
PUBLIC	??$forward@AB_N@std@@YAAB_NAB_N@Z		; std::forward<bool const &>
PUBLIC	??$exchange@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::nullptr_t>
PUBLIC	??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &>
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
PUBLIC	??$construct@U?$pair@$$CBHUNPC_DATA@@@std@@U?$pair@HUNPC_DATA@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@QAU?$pair@$$CBHUNPC_DATA@@@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::construct<std::pair<int const ,NPC_DATA>,std::pair<int,NPC_DATA> >
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &>
PUBLIC	??$forward@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
PUBLIC	??$forward@UNPC_DATA@@@std@@YA$$QAUNPC_DATA@@AAU1@@Z ; std::forward<NPC_DATA>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BB@GCADKGJO@map?1set?5too?5long@		; `string'
PUBLIC	??_7CResetSystem@@6B@				; CResetSystem::`vftable'
PUBLIC	?g_ResetSystem@@3VCResetSystem@@A		; g_ResetSystem
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?RESET_SYSTEM_LOG@@3VCLogToFile@@A		; RESET_SYSTEM_LOG
PUBLIC	??_C@_0BG@PCEAKJNF@?4?2RESET_BUGTRACER_LOG@	; `string'
PUBLIC	??_C@_0BB@BFFKLPEJ@RESET_SYSTEM_LOG@		; `string'
PUBLIC	??_C@_0GK@PNLFBAGA@?$FLReset?5System?$FN?5Selected?5Setting@ ; `string'
PUBLIC	??_C@_0FM@JPHLMJOB@?$FLReset?5System?$FN?5CResetSystem?3?3In@ ; `string'
PUBLIC	??_C@_0GB@ODDJKOIG@?$FLReset?5System?$FN?5CResetSystem?3?3In@ ; `string'
PUBLIC	??_C@_0FC@DFADEEFM@?$FLReset?5System?$FN?5CResetSystem?3?3In@ ; `string'
PUBLIC	??_C@_0MI@IGIKPDAC@?$FLReset?5System?$FN?5R_IDX?3?5?$CFd?0?5C_TYP@ ; `string'
PUBLIC	??_C@_0GD@CDCOMDIE@?$FLReset?5System?$FN?5CResetSystem?3?3In@ ; `string'
PUBLIC	??_C@_0LM@LANKAEMK@?$FLReset?5System?$FN?5R_IDX?3?5?$CFd?0?5C_TYP@ ; `string'
PUBLIC	??_C@_0GN@HPBNHHNI@?$FLReset?5System?$FN?5CResetSystem?3?3In@ ; `string'
PUBLIC	??_C@_0DD@GLFDECHM@?$FLReset?5System?$FN?5?9?5File?5load?5erro@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_0CI@LILKLNJA@?$FLReset?5System?$FN?5Info?5file?5Load?5F@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end@				; `string'
PUBLIC	??_C@_0BN@PJBHKEBH@?$FLReset?5System?$FN?5?$CFs?5file?5load?$CB@ ; `string'
PUBLIC	??_R0K@8					; unsigned long `RTTI Type Descriptor'
PUBLIC	??_C@_0DF@GGODGFJG@?$FLReset?5System?$FN?5?9?5Loading?5Except@ ; `string'
PUBLIC	??_C@_0CE@JDMKFIAN@?$FLRESET?5SYSTEM?$FN?3?5Tienes?5?$CFd?5Reset@ ; `string'
PUBLIC	??_C@_0CP@OPBOKLMI@?$FLReset?5System?$FN?5Set?5User?5ResetIn@ ; `string'
PUBLIC	??_C@_0DG@NMEDGBB@?$FLReset?5System?$FN?5Req?5Update?5User?5@ ; `string'
PUBLIC	??_C@_0CL@JBOFKBMJ@?$FLReset?5System?$FN?5DBAnsUpdateReset@ ; `string'
PUBLIC	??_C@_0EA@IOHPDFLJ@?$FLReset?5System?$FN?5Ans?5Update?5User?5@ ; `string'
PUBLIC	??_C@_0DN@KAKCNPHO@?$FLReset?5System?$FN?5Ans?5Update?5User?5@ ; `string'
PUBLIC	??_C@_0FE@BLGOPBEG@Fallo?5al?5resetear?4?5Tienes?5?$CI?$CFd?5o@ ; `string'
PUBLIC	??_C@_0EJ@KAAHMMNN@Se?5encontraron?5?$CI?$CFd?5de?5?$CFd?5?9?$DO?5?$CFs?$CJ@ ; `string'
PUBLIC	??_C@_0FL@KIAHIDBE@?$FLReset?5System?$FN?5Force?5?$CIAccount?3?$CF@ ; `string'
PUBLIC	??_C@_0CA@DIPDIDAL@No?5tienen?5suficiente?5zen?$CI?$CFd?$CJ?4?4?4@ ; `string'
PUBLIC	??_C@_0CM@OEAKHNJB@No?5tienes?5el?5nivel?5necesario?5pa@ ; `string'
PUBLIC	??_C@_0EO@GAODGINP@?$FLReset?5System?$FN?5Npc?5Addition?5?3?5I@ ; `string'
PUBLIC	??_C@_0CJ@FMODDEJG@?$FLReset?5System?$FN?5To?5Delete?5Npc?5?3?5@ ; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CResetSystem@@6B@				; CResetSystem::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCResetSystem@@@8			; CResetSystem `RTTI Type Descriptor'
PUBLIC	??_R3CResetSystem@@8				; CResetSystem::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CResetSystem@@8				; CResetSystem::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CResetSystem@@8			; CResetSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_atof:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?IsMagic@CMagicInf@@QAEHXZ:PROC			; CMagicInf::IsMagic
EXTRN	?Clear@CMagicInf@@QAEXXZ:PROC			; CMagicInf::Clear
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?gObjMagicAddEnergyCheckOnOff@@YAXH@Z:PROC	; gObjMagicAddEnergyCheckOnOff
EXTRN	?gObjWeaponMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z:PROC ; gObjWeaponMagicAdd
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
EXTRN	?gObjIsConnectedGP@@YAHH@Z:PROC			; gObjIsConnectedGP
EXTRN	?gObjTimeCheckSelfDefense@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; gObjTimeCheckSelfDefense
EXTRN	?gObjSetMonster@@YAHHH@Z:PROC			; gObjSetMonster
EXTRN	?gObjInventoryDeleteItem@@YAEHH@Z:PROC		; gObjInventoryDeleteItem
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z:PROC	; gObjMagicAdd
EXTRN	?gObjSetBP@@YAXH@Z:PROC				; gObjSetBP
EXTRN	?gObjCalcMaxLifePower@@YAXH@Z:PROC		; gObjCalcMaxLifePower
EXTRN	?gObjGetStatPointState@@YAXHAAF0@Z:PROC		; gObjGetStatPointState
EXTRN	?gObjNextExpCal@@YAXPAVOBJECTSTRUCT@@@Z:PROC	; gObjNextExpCal
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
EXTRN	?GCReFillSend@@YAXHGEE@Z:PROC			; GCReFillSend
EXTRN	?GCLevelUpMsgSend@@YAXHGGGGGFF@Z:PROC		; GCLevelUpMsgSend
EXTRN	?GCManaSend@@YAXHFEEG@Z:PROC			; GCManaSend
EXTRN	?GCMagicListOneSend@@YAXHDEEE@Z:PROC		; GCMagicListOneSend
EXTRN	?GCMagicListOneDelSend@@YAXHDEEE@Z:PROC		; GCMagicListOneDelSend
EXTRN	?GCMagicListMultiSend@@YAXPAVOBJECTSTRUCT@@@Z:PROC ; GCMagicListMultiSend
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?CGWarehouseUseEnd@@YAXH@Z:PROC			; CGWarehouseUseEnd
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	??_ECResetSystem@@UAEPAXI@Z:PROC		; CResetSystem::`vector deleting destructor'
EXTRN	?Output@CLogToFile@@QAAXPADZZ:PROC		; CLogToFile::Output
EXTRN	??0CLogToFile@@QAE@QAD0H@Z:PROC			; CLogToFile::CLogToFile
EXTRN	??1CLogToFile@@QAE@XZ:PROC			; CLogToFile::~CLogToFile
EXTRN	?GJSetCharacterInfo@@YAXPAVOBJECTSTRUCT@@HH@Z:PROC ; GJSetCharacterInfo
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
EXTRN	?MakeItemNumber@@YAHHH@Z:PROC			; MakeItemNumber
EXTRN	?Send@DBSockMng@@QAEHPADH@Z:PROC		; DBSockMng::Send
EXTRN	?ResetViewport@CGMMng@@QAEXPAVOBJECTSTRUCT@@@Z:PROC ; CGMMng::ResetViewport
EXTRN	?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z:PROC ; CMonsterAttr::GetAttr
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	?cManager@@3VCGMMng@@A:BYTE			; cManager
EXTRN	?DCInfo@@3Vclassdef@@A:BYTE			; DCInfo
EXTRN	?gMAttr@@3VCMonsterAttr@@A:BYTE			; gMAttr
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?g_ResetSystem@@3VCResetSystem@@A DB 084H DUP (?)	; g_ResetSystem
?SMDFile@@3PAU_iobuf@@A DD 01H DUP (?)			; SMDFile
?TokenNumber@@3MA DD 01H DUP (?)			; TokenNumber
?TokenString@@3PADA DB 064H DUP (?)			; TokenString
?CurrentToken@@3W4SMDToken@@A DD 01H DUP (?)		; CurrentToken
?g_iChaosCastle_MonsterItems@@3PAY111HA DD 018H DUP (?)	; g_iChaosCastle_MonsterItems
?RESET_SYSTEM_LOG@@3VCLogToFile@@A DB 010228H DUP (?)	; RESET_SYSTEM_LOG
_BSS	ENDS
CRT$XCU	SEGMENT
?g_iChaosCastle_MonsterItems$initializer$@@3P6AXXZA DD FLAT:??__Eg_iChaosCastle_MonsterItems@@YAXXZ ; g_iChaosCastle_MonsterItems$initializer$
CRT$XCU	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CResetSystem@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CResetSystem@@8 DD FLAT:??_R0?AVCResetSystem@@@8 ; CResetSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CResetSystem@@8
rdata$r	ENDS
;	COMDAT ??_R2CResetSystem@@8
rdata$r	SEGMENT
??_R2CResetSystem@@8 DD FLAT:??_R1A@?0A@EA@CResetSystem@@8 ; CResetSystem::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CResetSystem@@8
rdata$r	SEGMENT
??_R3CResetSystem@@8 DD 00H				; CResetSystem::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CResetSystem@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCResetSystem@@@8
data$r	SEGMENT
??_R0?AVCResetSystem@@@8 DD FLAT:??_7type_info@@6B@	; CResetSystem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCResetSystem@@', 00H
data$r	ENDS
;	COMDAT ??_R4CResetSystem@@6B@
rdata$r	SEGMENT
??_R4CResetSystem@@6B@ DD 00H				; CResetSystem::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCResetSystem@@@8
	DD	FLAT:??_R3CResetSystem@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FMODDEJG@?$FLReset?5System?$FN?5To?5Delete?5Npc?5?3?5@
CONST	SEGMENT
??_C@_0CJ@FMODDEJG@?$FLReset?5System?$FN?5To?5Delete?5Npc?5?3?5@ DB '[Res'
	DB	'et System] To Delete Npc : Index(%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@GAODGINP@?$FLReset?5System?$FN?5Npc?5Addition?5?3?5I@
CONST	SEGMENT
??_C@_0EO@GAODGINP@?$FLReset?5System?$FN?5Npc?5Addition?5?3?5I@ DB '[Rese'
	DB	't System] Npc Addition : Index(%d) NpcID(%d) MapID(%d) PosX(%'
	DB	'd) PosY(%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OEAKHNJB@No?5tienes?5el?5nivel?5necesario?5pa@
CONST	SEGMENT
??_C@_0CM@OEAKHNJB@No?5tienes?5el?5nivel?5necesario?5pa@ DB 'No tienes el'
	DB	' nivel necesario para resetear!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DIPDIDAL@No?5tienen?5suficiente?5zen?$CI?$CFd?$CJ?4?4?4@
CONST	SEGMENT
??_C@_0CA@DIPDIDAL@No?5tienen?5suficiente?5zen?$CI?$CFd?$CJ?4?4?4@ DB 'No'
	DB	' tienen suficiente zen(%d)...', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@KIAHIDBE@?$FLReset?5System?$FN?5Force?5?$CIAccount?3?$CF@
CONST	SEGMENT
??_C@_0FL@KIAHIDBE@?$FLReset?5System?$FN?5Force?5?$CIAccount?3?$CF@ DB '['
	DB	'Reset System] Force (Account:%s, Name:%s) to Delete Required '
	DB	'Item in Pos:(%d) [Serial:%d]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@KAAHMMNN@Se?5encontraron?5?$CI?$CFd?5de?5?$CFd?5?9?$DO?5?$CFs?$CJ@
CONST	SEGMENT
??_C@_0EJ@KAAHMMNN@Se?5encontraron?5?$CI?$CFd?5de?5?$CFd?5?9?$DO?5?$CFs?$CJ@ DB 'S'
	DB	'e encontraron (%d de %d -> %s) de los objetos necesarios para'
	DB	' resetear.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@BLGOPBEG@Fallo?5al?5resetear?4?5Tienes?5?$CI?$CFd?5o@
CONST	SEGMENT
??_C@_0FE@BLGOPBEG@Fallo?5al?5resetear?4?5Tienes?5?$CI?$CFd?5o@ DB 'Fallo'
	DB	' al resetear. Tienes (%d of %d -> %s) de los objetos necesari'
	DB	'os para resetear.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@KAKCNPHO@?$FLReset?5System?$FN?5Ans?5Update?5User?5@
CONST	SEGMENT
??_C@_0DN@KAKCNPHO@?$FLReset?5System?$FN?5Ans?5Update?5User?5@ DB '[Reset'
	DB	' System] Ans Update User ResetInfo - FAIL [%s][%s](%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@IOHPDFLJ@?$FLReset?5System?$FN?5Ans?5Update?5User?5@
CONST	SEGMENT
??_C@_0EA@IOHPDFLJ@?$FLReset?5System?$FN?5Ans?5Update?5User?5@ DB '[Reset'
	DB	' System] Ans Update User ResetInfo - SUCCESS [%s][%s](%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JBOFKBMJ@?$FLReset?5System?$FN?5DBAnsUpdateReset@
CONST	SEGMENT
??_C@_0CL@JBOFKBMJ@?$FLReset?5System?$FN?5DBAnsUpdateReset@ DB '[Reset Sy'
	DB	'stem] DBAnsUpdateReset ERROR (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@NMEDGBB@?$FLReset?5System?$FN?5Req?5Update?5User?5@
CONST	SEGMENT
??_C@_0DG@NMEDGBB@?$FLReset?5System?$FN?5Req?5Update?5User?5@ DB '[Reset '
	DB	'System] Req Update User ResetInfo [%s][%s](%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OPBOKLMI@?$FLReset?5System?$FN?5Set?5User?5ResetIn@
CONST	SEGMENT
??_C@_0CP@OPBOKLMI@?$FLReset?5System?$FN?5Set?5User?5ResetIn@ DB '[Reset '
	DB	'System] Set User ResetInfo [%s][%s](%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JDMKFIAN@?$FLRESET?5SYSTEM?$FN?3?5Tienes?5?$CFd?5Reset@
CONST	SEGMENT
??_C@_0CE@JDMKFIAN@?$FLRESET?5SYSTEM?$FN?3?5Tienes?5?$CFd?5Reset@ DB '[RE'
	DB	'SET SYSTEM]: Tienes %d Reset(s).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GGODGFJG@?$FLReset?5System?$FN?5?9?5Loading?5Except@
CONST	SEGMENT
??_C@_0DF@GGODGFJG@?$FLReset?5System?$FN?5?9?5Loading?5Except@ DB '[Reset'
	DB	' System] - Loading Exception Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R0K@8
data$r	SEGMENT
??_R0K@8 DD	FLAT:??_7type_info@@6B@			; unsigned long `RTTI Type Descriptor'
	DD	00H
	DB	'.K', 00H
data$r	ENDS
;	COMDAT ??_C@_0BN@PJBHKEBH@?$FLReset?5System?$FN?5?$CFs?5file?5load?$CB@
CONST	SEGMENT
??_C@_0BN@PJBHKEBH@?$FLReset?5System?$FN?5?$CFs?5file?5load?$CB@ DB '[Res'
	DB	'et System] %s file load!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end@
CONST	SEGMENT
??_C@_03JBJLGPFL@end@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LILKLNJA@?$FLReset?5System?$FN?5Info?5file?5Load?5F@
CONST	SEGMENT
??_C@_0CI@LILKLNJA@?$FLReset?5System?$FN?5Info?5file?5Load?5F@ DB '[Reset'
	DB	' System] Info file Load Fail [%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@GLFDECHM@?$FLReset?5System?$FN?5?9?5File?5load?5erro@
CONST	SEGMENT
??_C@_0DD@GLFDECHM@?$FLReset?5System?$FN?5?9?5File?5load?5erro@ DB '[Rese'
	DB	't System] - File load error : File Name Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GN@HPBNHHNI@?$FLReset?5System?$FN?5CResetSystem?3?3In@
CONST	SEGMENT
??_C@_0GN@HPBNHHNI@?$FLReset?5System?$FN?5CResetSystem?3?3In@ DB '[Reset '
	DB	'System] CResetSystem::Init() - Reset Command is Disable and N'
	DB	'PC Setting is empty (m_mNpcData is Zero)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0LM@LANKAEMK@?$FLReset?5System?$FN?5R_IDX?3?5?$CFd?0?5C_TYP@
CONST	SEGMENT
??_C@_0LM@LANKAEMK@?$FLReset?5System?$FN?5R_IDX?3?5?$CFd?0?5C_TYP@ DB '[R'
	DB	'eset System] R_IDX: %d, C_TYPE: %d, MIN_LVL: %d, MAX_LVL: %d,'
	DB	' CLR_STAT: %d, LVL_AFTER: %d, POINT: %d, RQ_ITEM: %d, B_PLACE'
	DB	': %d, CLR_BUFF: %d, VIP: %d, CHK_INVENT: %d, CLR_MAGIC_LIST: '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0GD@CDCOMDIE@?$FLReset?5System?$FN?5CResetSystem?3?3In@
CONST	SEGMENT
??_C@_0GD@CDCOMDIE@?$FLReset?5System?$FN?5CResetSystem?3?3In@ DB '[Reset '
	DB	'System] CResetSystem::Init() - Non Table Reset Setting Is Emp'
	DB	'ty (m_vtNonTableReset is Zero)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0MI@IGIKPDAC@?$FLReset?5System?$FN?5R_IDX?3?5?$CFd?0?5C_TYP@
CONST	SEGMENT
??_C@_0MI@IGIKPDAC@?$FLReset?5System?$FN?5R_IDX?3?5?$CFd?0?5C_TYP@ DB '[R'
	DB	'eset System] R_IDX: %d, C_TYPE: %d, MIN_LVL: %d, MAX_LVL: %d,'
	DB	' CLR_STAT: %d, LVL_AFTER: %d, POINT: %d, RQ_ITEM: %d, B_PLACE'
	DB	': %d, RST_NUM: %d,CLR_BUFF: %d, VIP: %d, CHK_INVENT: %d, CLR_'
	DB	'MAGIC_LIST: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@DFADEEFM@?$FLReset?5System?$FN?5CResetSystem?3?3In@
CONST	SEGMENT
??_C@_0FC@DFADEEFM@?$FLReset?5System?$FN?5CResetSystem?3?3In@ DB '[Reset '
	DB	'System] CResetSystem::Init() - Born Place Is Empty (m_vtBornP'
	DB	'lace is Zero)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GB@ODDJKOIG@?$FLReset?5System?$FN?5CResetSystem?3?3In@
CONST	SEGMENT
??_C@_0GB@ODDJKOIG@?$FLReset?5System?$FN?5CResetSystem?3?3In@ DB '[Reset '
	DB	'System] CResetSystem::Init() - Require Special Item Is Empty '
	DB	'(m_vtReqSpecialItem is Zero)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@JPHLMJOB@?$FLReset?5System?$FN?5CResetSystem?3?3In@
CONST	SEGMENT
??_C@_0FM@JPHLMJOB@?$FLReset?5System?$FN?5CResetSystem?3?3In@ DB '[Reset '
	DB	'System] CResetSystem::Init() - Table Reset Setting Is Empty ('
	DB	'm_vtTableReset is Zero)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@PNLFBAGA@?$FLReset?5System?$FN?5Selected?5Setting@
CONST	SEGMENT
??_C@_0GK@PNLFBAGA@?$FLReset?5System?$FN?5Selected?5Setting@ DB '[Reset S'
	DB	'ystem] Selected Setting: USE_RESET_SYSTEM -> %d || RESET_SYST'
	DB	'EM_TYPE -> %d || USE_RESET_CMD -> %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BFFKLPEJ@RESET_SYSTEM_LOG@
CONST	SEGMENT
??_C@_0BB@BFFKLPEJ@RESET_SYSTEM_LOG@ DB 'RESET_SYSTEM_LOG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PCEAKJNF@?4?2RESET_BUGTRACER_LOG@
CONST	SEGMENT
??_C@_0BG@PCEAKJNF@?4?2RESET_BUGTRACER_LOG@ DB '.\RESET_BUGTRACER_LOG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7CResetSystem@@6B@
CONST	SEGMENT
??_7CResetSystem@@6B@ DD FLAT:??_R4CResetSystem@@6B@	; CResetSystem::`vftable'
	DD	FLAT:??_ECResetSystem@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BB@GCADKGJO@map?1set?5too?5long@ DB 'map/set too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0U?$pair@HUNPC_DATA@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@HUNPC_DATA@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z$0
__ehfuncinfo$??$?0U?$pair@HUNPC_DATA@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0U?$pair@HUNPC_DATA@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z$2
__ehfuncinfo$??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z$2
__ehfuncinfo$??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z$2
__ehfuncinfo$??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z$2
__ehfuncinfo$??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@1@V21@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?Load@CResetSystem@@QAEHPAD@Z$2 DD 00H
	DD	FLAT:??_R0K@8
	DD	00H
	DD	FLAT:__catch$?Load@CResetSystem@@QAEHPAD@Z$0
__unwindtable$?Load@CResetSystem@@QAEHPAD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?Load@CResetSystem@@QAEHPAD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?Load@CResetSystem@@QAEHPAD@Z$2
__ehfuncinfo$?Load@CResetSystem@@QAEHPAD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Load@CResetSystem@@QAEHPAD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?Load@CResetSystem@@QAEHPAD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CResetSystem@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0CResetSystem@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CResetSystem@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CResetSystem@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CResetSystem@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CResetSystem@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CResetSystem@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CResetSystem@@QAE@XZ$4
xdata$x	ENDS
CRT$XCU	SEGMENT
?RESET_SYSTEM_LOG$initializer$@@3P6AXXZA DD FLAT:??__ERESET_SYSTEM_LOG@@YAXXZ ; RESET_SYSTEM_LOG$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?g_ResetSystem$initializer$@@3P6AXXZA DD FLAT:??__Eg_ResetSystem@@YAXXZ ; g_ResetSystem$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@UNPC_DATA@@@std@@YA$$QAUNPC_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UNPC_DATA@@@std@@YA$$QAUNPC_DATA@@AAU1@@Z PROC ; std::forward<NPC_DATA>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@UNPC_DATA@@@std@@YA$$QAUNPC_DATA@@AAU1@@Z ENDP ; std::forward<NPC_DATA>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	6a 04		 push	 4
  00018	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0001d	83 c4 08	 add	 esp, 8
  00020	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBHUNPC_DATA@@@std@@U?$pair@HUNPC_DATA@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@QAU?$pair@$$CBHUNPC_DATA@@@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U?$pair@$$CBHUNPC_DATA@@@std@@U?$pair@HUNPC_DATA@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@QAU?$pair@$$CBHUNPC_DATA@@@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::construct<std::pair<int const ,NPC_DATA>,std::pair<int,NPC_DATA> >, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	50		 push	 eax
  0000d	6a 18		 push	 24			; 00000018H
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00014	83 c4 08	 add	 esp, 8
  00017	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ??$forward@U?$pair@HUNPC_DATA@@@std@@@std@@YA$$QAU?$pair@HUNPC_DATA@@@0@AAU10@@Z ; std::forward<std::pair<int,NPC_DATA> >
  00023	83 c4 04	 add	 esp, 4
  00026	50		 push	 eax
  00027	8b 4d bc	 mov	 ecx, DWORD PTR $T1[ebp]
  0002a	e8 00 00 00 00	 call	 ??$?0HUNPC_DATA@@$0A@@?$pair@$$CBHUNPC_DATA@@@std@@QAE@$$QAU?$pair@HUNPC_DATA@@@1@@Z ; std::pair<int const ,NPC_DATA>::pair<int const ,NPC_DATA><int,NPC_DATA,0>

; 695  :     }

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$construct@U?$pair@$$CBHUNPC_DATA@@@std@@U?$pair@HUNPC_DATA@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@QAU?$pair@$$CBHUNPC_DATA@@@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::construct<std::pair<int const ,NPC_DATA>,std::pair<int,NPC_DATA> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::nullptr_t>, COMDAT

; 597  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 598  :     // assign _New_val to _Val, return previous _Val
; 599  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 600  :     _Val         = static_cast<_Other&&>(_New_val);

  00011	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR __New_val$[ebp]
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	89 10		 mov	 DWORD PTR [eax], edx

; 601  :     return _Old_val;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 602  : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$exchange@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@AB_N@std@@YAAB_NAB_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AB_N@std@@YAAB_NAB_N@Z PROC			; std::forward<bool const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AB_N@std@@YAAB_NAB_N@Z ENDP			; std::forward<bool const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > > >, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$?0PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QA_N@Z PROC ; std::pair<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool>::pair<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool><std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool,0>, COMDAT
; _this$ = ecx

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YA$$QAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool>::pair<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool><std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$?0U?$pair@HUNPC_DATA@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
__Myhead$ = 12						; size = 4
_<_Vals_0>$ = 16					; size = 4
??$?0U?$pair@HUNPC_DATA@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > ><std::pair<int,NPC_DATA> >, COMDAT
; _this$ = ecx

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0U?$pair@HUNPC_DATA@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0003e	8b 45 10	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??$forward@U?$pair@HUNPC_DATA@@@std@@@std@@YA$$QAU?$pair@HUNPC_DATA@@@0@AAU10@@Z ; std::forward<std::pair<int,NPC_DATA> >
  00047	83 c4 04	 add	 esp, 4
  0004a	50		 push	 eax
  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00051	83 c2 10	 add	 edx, 16			; 00000010H
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@YAPAU?$pair@$$CBHUNPC_DATA@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,NPC_DATA> >
  0005a	83 c4 04	 add	 esp, 4
  0005d	50		 push	 eax
  0005e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ??$construct@U?$pair@$$CBHUNPC_DATA@@@std@@U?$pair@HUNPC_DATA@@@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@QAU?$pair@$$CBHUNPC_DATA@@@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::construct<std::pair<int const ,NPC_DATA>,std::pair<int,NPC_DATA> >
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 807  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  0006c	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &>
  0007c	83 c4 08	 add	 esp, 8

; 808  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  0007f	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  00082	50		 push	 eax
  00083	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00089	83 c2 04	 add	 edx, 4
  0008c	52		 push	 edx
  0008d	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &>
  00092	83 c4 08	 add	 esp, 8

; 809  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  00095	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  00098	50		 push	 eax
  00099	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0009f	83 c2 08	 add	 edx, 8
  000a2	52		 push	 edx
  000a3	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &>
  000a8	83 c4 08	 add	 esp, 8

; 810  :         this->_Ptr->_Color = _Red;

  000ab	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b1	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 811  :         this->_Ptr->_Isnil = false;

  000b5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000bb	c6 41 0d 00	 mov	 BYTE PTR [ecx+13], 0

; 812  :     }

  000bf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000c6	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d3	59		 pop	 ecx
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi
  000d6	5b		 pop	 ebx
  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0U?$pair@HUNPC_DATA@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0U?$pair@HUNPC_DATA@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0U?$pair@HUNPC_DATA@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0U?$pair@HUNPC_DATA@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > ><std::pair<int,NPC_DATA> >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >, COMDAT
; _this$ = ecx

; 817  :     ~_Tree_temp_node() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 818  :         if (this->_Ptr) {

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	74 54		 je	 SHORT $LN1@Tree_temp_

; 819  :             _Destroy_in_place(this->_Ptr->_Left);

  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>
  00040	83 c4 04	 add	 esp, 4

; 820  :             _Destroy_in_place(this->_Ptr->_Parent);

  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00049	83 c1 04	 add	 ecx, 4
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>
  00052	83 c4 04	 add	 esp, 4

; 821  :             _Destroy_in_place(this->_Ptr->_Right);

  00055	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005b	83 c1 08	 add	 ecx, 8
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>
  00064	83 c4 04	 add	 esp, 4

; 822  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00067	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006d	83 c1 10	 add	 ecx, 16			; 00000010H
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@YAPAU?$pair@$$CBHUNPC_DATA@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,NPC_DATA> >
  00076	83 c4 04	 add	 esp, 4
  00079	50		 push	 eax
  0007a	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0007d	8b 02		 mov	 eax, DWORD PTR [edx]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ??$destroy@U?$pair@$$CBHUNPC_DATA@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@QAU?$pair@$$CBHUNPC_DATA@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::destroy<std::pair<int const ,NPC_DATA> >
  00085	83 c4 08	 add	 esp, 8
$LN1@Tree_temp_:

; 823  :         }
; 824  :     }

  00088	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	e8 00 00 00 00	 call	 ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ
  00090	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00093	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009a	59		 pop	 ecx
  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	5b		 pop	 ebx
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
  000a2	cc		 int	 3
  000a3	cc		 int	 3
  000a4	cc		 int	 3
  000a5	cc		 int	 3
  000a6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >, COMDAT
; _this$ = ecx

; 784  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 08	 mov	 eax, DWORD PTR __Al_$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 785  :         _Alloc_construct_ptr<_Alnode>::_Allocate();

  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Allocate

; 786  :     }

  00046	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >, COMDAT
; _this$ = ecx

; 1051 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         if (_Ptr) {

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	74 13		 je	 SHORT $LN3@Alloc_cons

; 1053 :             _Al.deallocate(_Ptr, 1);

  00034	6a 01		 push	 1
  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	51		 push	 ecx
  0003d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00042	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >::deallocate
$LN3@Alloc_cons:

; 1054 :         }
; 1055 :     }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
  00059	cc		 int	 3
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1046 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1047 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1048 :         _Ptr = _Al.allocate(1);

  00016	6a 01		 push	 1
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >::allocate
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1049 :     }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@XZ
_TEXT	SEGMENT
$T1 = -72						; size = 4
_this$ = -4						; size = 4
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Release, COMDAT
; _this$ = ecx

; 1042 :     _NODISCARD pointer _Release() noexcept { // disengage *this and return contained pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1043 :         return _STD exchange(_Ptr, nullptr);

  0000c	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00013	8d 45 b8	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	83 c1 04	 add	 ecx, 4
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ??$exchange@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@$$T@std@@YAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::nullptr_t>
  00023	83 c4 08	 add	 esp, 8

; 1044 :     }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al_$ = 8						; size = 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >, COMDAT
; _this$ = ecx

; 1040 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$?0AAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QA_N@Z PROC ; std::pair<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool>::pair<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool><std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &,bool,0>, COMDAT
; _this$ = ecx

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@_N@std@@YA$$QA_NAA_N@Z ; std::forward<bool>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0AAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool>::pair<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool><std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Extract@?$_In_place_key_extract_map@HU?$pair@HUNPC_DATA@@@std@@@std@@SAABHABU?$pair@HUNPC_DATA@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Extract@?$_In_place_key_extract_map@HU?$pair@HUNPC_DATA@@@std@@@std@@SAABHABU?$pair@HUNPC_DATA@@@2@@Z PROC ; std::_In_place_key_extract_map<int,std::pair<int,NPC_DATA> >::_Extract, COMDAT

; 1961 :     static const _Key& _Extract(const pair<_First, _Second>& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1962 :         return _Val.first;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1963 :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Extract@?$_In_place_key_extract_map@HU?$pair@HUNPC_DATA@@@std@@@std@@SAABHABU?$pair@HUNPC_DATA@@@2@@Z ENDP ; std::_In_place_key_extract_map<int,std::pair<int,NPC_DATA> >::_Extract
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAD@std@@YA$$QADAAD@Z PROC			; std::move<char &>, COMDAT

; 1466 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1467 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1468 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$move@AAD@std@@YA$$QADAAD@Z ENDP			; std::move<char &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAUNON_TABLE_RESET@@PAU1@@std@@YAPAUNON_TABLE_RESET@@PAU1@00@Z
_TEXT	SEGMENT
__Count$ = -16						; size = 4
__Dest_ch$ = -12					; size = 4
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUNON_TABLE_RESET@@PAU1@@std@@YAPAUNON_TABLE_RESET@@PAU1@00@Z PROC ; std::_Copy_memmove<NON_TABLE_RESET *,NON_TABLE_RESET *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	89 45 f4	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001e	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00021	89 45 f0	 mov	 DWORD PTR __Count$[ebp], eax

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00024	8b 45 f0	 mov	 eax, DWORD PTR __Count$[ebp]
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR __First_ch$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 f4	 mov	 edx, DWORD PTR __Dest_ch$[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 _memmove
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00038	8b 45 f4	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0003b	03 45 f0	 add	 eax, DWORD PTR __Count$[ebp]

; 4120 : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$_Copy_memmove@PAUNON_TABLE_RESET@@PAU1@@std@@YAPAUNON_TABLE_RESET@@PAU1@00@Z ENDP ; std::_Copy_memmove<NON_TABLE_RESET *,NON_TABLE_RESET *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUNON_TABLE_RESET@@@std@@YA@ABQAUNON_TABLE_RESET@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAUNON_TABLE_RESET@@@std@@YA@ABQAUNON_TABLE_RESET@@@Z PROC ; std::_Get_unwrapped<NON_TABLE_RESET * const &>, COMDAT

; 1229 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1230 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1231 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1232 :         return _It + 0;

  00009	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]

; 1233 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1234 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1235 :     } else {
; 1236 :         return static_cast<_Iter&&>(_It);
; 1237 :     }
; 1238 : }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Get_unwrapped@ABQAUNON_TABLE_RESET@@@std@@YA@ABQAUNON_TABLE_RESET@@@Z ENDP ; std::_Get_unwrapped<NON_TABLE_RESET * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAUTABLE_RESET@@PAU1@@std@@YAPAUTABLE_RESET@@PAU1@00@Z
_TEXT	SEGMENT
__Count$ = -16						; size = 4
__Dest_ch$ = -12					; size = 4
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUTABLE_RESET@@PAU1@@std@@YAPAUTABLE_RESET@@PAU1@00@Z PROC ; std::_Copy_memmove<TABLE_RESET *,TABLE_RESET *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	89 45 f4	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001e	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00021	89 45 f0	 mov	 DWORD PTR __Count$[ebp], eax

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00024	8b 45 f0	 mov	 eax, DWORD PTR __Count$[ebp]
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR __First_ch$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 f4	 mov	 edx, DWORD PTR __Dest_ch$[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 _memmove
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00038	8b 45 f4	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0003b	03 45 f0	 add	 eax, DWORD PTR __Count$[ebp]

; 4120 : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$_Copy_memmove@PAUTABLE_RESET@@PAU1@@std@@YAPAUTABLE_RESET@@PAU1@00@Z ENDP ; std::_Copy_memmove<TABLE_RESET *,TABLE_RESET *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUTABLE_RESET@@@std@@YA@ABQAUTABLE_RESET@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAUTABLE_RESET@@@std@@YA@ABQAUTABLE_RESET@@@Z PROC ; std::_Get_unwrapped<TABLE_RESET * const &>, COMDAT

; 1229 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1230 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1231 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1232 :         return _It + 0;

  00009	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]

; 1233 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1234 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1235 :     } else {
; 1236 :         return static_cast<_Iter&&>(_It);
; 1237 :     }
; 1238 : }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Get_unwrapped@ABQAUTABLE_RESET@@@std@@YA@ABQAUTABLE_RESET@@@Z ENDP ; std::_Get_unwrapped<TABLE_RESET * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAUREQUIRE_SPECIAL_ITEM@@PAU1@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@PAU1@00@Z
_TEXT	SEGMENT
__Count$ = -16						; size = 4
__Dest_ch$ = -12					; size = 4
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUREQUIRE_SPECIAL_ITEM@@PAU1@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@PAU1@00@Z PROC ; std::_Copy_memmove<REQUIRE_SPECIAL_ITEM *,REQUIRE_SPECIAL_ITEM *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	89 45 f4	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001e	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00021	89 45 f0	 mov	 DWORD PTR __Count$[ebp], eax

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00024	8b 45 f0	 mov	 eax, DWORD PTR __Count$[ebp]
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR __First_ch$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 f4	 mov	 edx, DWORD PTR __Dest_ch$[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 _memmove
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00038	8b 45 f4	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0003b	03 45 f0	 add	 eax, DWORD PTR __Count$[ebp]

; 4120 : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$_Copy_memmove@PAUREQUIRE_SPECIAL_ITEM@@PAU1@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@PAU1@00@Z ENDP ; std::_Copy_memmove<REQUIRE_SPECIAL_ITEM *,REQUIRE_SPECIAL_ITEM *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUREQUIRE_SPECIAL_ITEM@@@std@@YA@ABQAUREQUIRE_SPECIAL_ITEM@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAUREQUIRE_SPECIAL_ITEM@@@std@@YA@ABQAUREQUIRE_SPECIAL_ITEM@@@Z PROC ; std::_Get_unwrapped<REQUIRE_SPECIAL_ITEM * const &>, COMDAT

; 1229 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1230 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1231 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1232 :         return _It + 0;

  00009	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]

; 1233 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1234 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1235 :     } else {
; 1236 :         return static_cast<_Iter&&>(_It);
; 1237 :     }
; 1238 : }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Get_unwrapped@ABQAUREQUIRE_SPECIAL_ITEM@@@std@@YA@ABQAUREQUIRE_SPECIAL_ITEM@@@Z ENDP ; std::_Get_unwrapped<REQUIRE_SPECIAL_ITEM * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Copy_memmove@PAUBORN_PLACE@@PAU1@@std@@YAPAUBORN_PLACE@@PAU1@00@Z
_TEXT	SEGMENT
__Count$ = -16						; size = 4
__Dest_ch$ = -12					; size = 4
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUBORN_PLACE@@PAU1@@std@@YAPAUBORN_PLACE@@PAU1@00@Z PROC ; std::_Copy_memmove<BORN_PLACE *,BORN_PLACE *>, COMDAT

; 4113 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 4114 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4115 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4116 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	89 45 f4	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4117 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001e	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00021	89 45 f0	 mov	 DWORD PTR __Count$[ebp], eax

; 4118 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00024	8b 45 f0	 mov	 eax, DWORD PTR __Count$[ebp]
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR __First_ch$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 f4	 mov	 edx, DWORD PTR __Dest_ch$[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 _memmove
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4119 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00038	8b 45 f4	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0003b	03 45 f0	 add	 eax, DWORD PTR __Count$[ebp]

; 4120 : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$_Copy_memmove@PAUBORN_PLACE@@PAU1@@std@@YAPAUBORN_PLACE@@PAU1@00@Z ENDP ; std::_Copy_memmove<BORN_PLACE *,BORN_PLACE *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAUBORN_PLACE@@@std@@YA@ABQAUBORN_PLACE@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAUBORN_PLACE@@@std@@YA@ABQAUBORN_PLACE@@@Z PROC ; std::_Get_unwrapped<BORN_PLACE * const &>, COMDAT

; 1229 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1230 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1231 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1232 :         return _It + 0;

  00009	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]

; 1233 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1234 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1235 :     } else {
; 1236 :         return static_cast<_Iter&&>(_It);
; 1237 :     }
; 1238 : }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Get_unwrapped@ABQAUBORN_PLACE@@@std@@YA@ABQAUBORN_PLACE@@@Z ENDP ; std::_Get_unwrapped<BORN_PLACE * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBHUNPC_DATA@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@QAU?$pair@$$CBHUNPC_DATA@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@$$CBHUNPC_DATA@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@QAU?$pair@$$CBHUNPC_DATA@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::destroy<std::pair<int const ,NPC_DATA> >, COMDAT

; 698  :     static void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 699  :         _Ptr->~_Uty();
; 700  :     }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$destroy@U?$pair@$$CBHUNPC_DATA@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@QAU?$pair@$$CBHUNPC_DATA@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::destroy<std::pair<int const ,NPC_DATA> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@ABQAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@ABQAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>, COMDAT

; 267  : void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 268  :     _Obj.~_Ty();
; 269  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$exchange@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@0@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@0@Z PROC ; std::exchange<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &>, COMDAT

; 597  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 598  :     // assign _New_val to _Val, return previous _Val
; 599  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 600  :     _Val         = static_cast<_Other&&>(_New_val);

  00011	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR __New_val$[ebp]
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	89 10		 mov	 DWORD PTR [eax], edx

; 601  :     return _Old_val;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 602  : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$exchange@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@0@Z ENDP ; std::exchange<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\map
;	COMDAT ??$_Kfn@$$CBHUNPC_DATA@@@?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUNPC_DATA@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHUNPC_DATA@@@?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUNPC_DATA@@@1@@Z PROC ; std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0>::_Kfn<int const ,NPC_DATA>, COMDAT

; 68   :     static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val) { // extract key from element value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 69   :         return _Val.first;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 70   :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Kfn@$$CBHUNPC_DATA@@@?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUNPC_DATA@@@1@@Z ENDP ; std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0>::_Kfn<int const ,NPC_DATA>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@1@AB_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >,bool const &,0>, COMDAT
; _this$ = ecx

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > > >
  00015	83 c4 04	 add	 esp, 4
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	89 0a		 mov	 DWORD PTR [edx], ecx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@AB_N@std@@YAAB_NAB_N@Z ; std::forward<bool const &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8a 10		 mov	 dl, BYTE PTR [eax]
  00030	88 51 04	 mov	 BYTE PTR [ecx+4], dl
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >,bool const &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$_Emplace@U?$pair@HUNPC_DATA@@@std@@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z
_TEXT	SEGMENT
tv141 = -128						; size = 4
$T1 = -124						; size = 4
$T2 = -117						; size = 1
$T3 = -116						; size = 8
$T4 = -105						; size = 1
$T5 = -104						; size = 12
__Keyval$6 = -28					; size = 4
__Inserted$ = -24					; size = 4
__Loc$ = -20						; size = 12
__Scary$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_<_Vals_0>$ = 12					; size = 4
??$_Emplace@U?$pair@HUNPC_DATA@@@std@@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Emplace<std::pair<int,NPC_DATA> >, COMDAT
; _this$ = ecx

; 1002 :     pair<_Nodeptr, bool> _Emplace(_Valtys&&... _Vals) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1003 :         using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
; 1004 :         const auto _Scary             = _Get_scary();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
  00017	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1005 :         _Tree_find_result<_Nodeptr> _Loc;
; 1006 :         _Nodeptr _Inserted;
; 1007 :         if constexpr (!_Multi && _In_place_key_extractor::_Extractable) {
; 1008 :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ?_Extract@?$_In_place_key_extract_map@HU?$pair@HUNPC_DATA@@@std@@@std@@SAABHABU?$pair@HUNPC_DATA@@@2@@Z ; std::_In_place_key_extract_map<int,std::pair<int,NPC_DATA> >::_Extract
  00023	83 c4 04	 add	 esp, 4
  00026	89 45 e4	 mov	 DWORD PTR __Keyval$6[ebp], eax

; 1009 :             _Loc                = _Find_lower_bound(_Keyval);

  00029	8b 45 e4	 mov	 eax, DWORD PTR __Keyval$6[ebp]
  0002c	50		 push	 eax
  0002d	8d 4d 98	 lea	 ecx, DWORD PTR $T5[ebp]
  00030	51		 push	 ecx
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Find_lower_bound<int>
  00039	8b 10		 mov	 edx, DWORD PTR [eax]
  0003b	89 55 ec	 mov	 DWORD PTR __Loc$[ebp], edx
  0003e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00041	89 4d f0	 mov	 DWORD PTR __Loc$[ebp+4], ecx
  00044	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00047	89 55 f4	 mov	 DWORD PTR __Loc$[ebp+8], edx

; 1010 :             if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __Keyval$6[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __Loc$[ebp+8]
  00051	51		 push	 ecx
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Lower_bound_duplicate<int>
  0005a	0f b6 d0	 movzx	 edx, al
  0005d	85 d2		 test	 edx, edx
  0005f	74 19		 je	 SHORT $LN2@Emplace

; 1011 :                 return {_Loc._Bound, false};

  00061	c6 45 97 00	 mov	 BYTE PTR $T4[ebp], 0
  00065	8d 45 97	 lea	 eax, DWORD PTR $T4[ebp]
  00068	50		 push	 eax
  00069	8d 4d f4	 lea	 ecx, DWORD PTR __Loc$[ebp+8]
  0006c	51		 push	 ecx
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00070	e8 00 00 00 00	 call	 ??$?0AAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N@std@@QAE@AAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QA_N@Z ; std::pair<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool>::pair<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool><std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &,bool,0>
  00075	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00078	eb 70		 jmp	 SHORT $LN1@Emplace
$LN2@Emplace:

; 1012 :             }
; 1013 : 
; 1014 :             _Check_grow_by_1();

  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Check_grow_by_1

; 1015 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  00082	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ??$forward@U?$pair@HUNPC_DATA@@@std@@@std@@YA$$QAU?$pair@HUNPC_DATA@@@0@AAU10@@Z ; std::forward<std::pair<int,NPC_DATA> >
  0008b	83 c4 04	 add	 esp, 4
  0008e	50		 push	 eax
  0008f	8b 4d f8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00092	8b 11		 mov	 edx, DWORD PTR [ecx]
  00094	52		 push	 edx
  00095	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	e8 00 00 00 00	 call	 ?_Getal@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Getal
  0009d	50		 push	 eax
  0009e	8d 4d 8c	 lea	 ecx, DWORD PTR $T3[ebp]
  000a1	e8 00 00 00 00	 call	 ??$?0U?$pair@HUNPC_DATA@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > ><std::pair<int,NPC_DATA> >
  000a6	89 45 80	 mov	 DWORD PTR tv141[ebp], eax
  000a9	8b 4d 80	 mov	 ecx, DWORD PTR tv141[ebp]
  000ac	e8 00 00 00 00	 call	 ?_Release@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::_Release
  000b1	89 45 e8	 mov	 DWORD PTR __Inserted$[ebp], eax
  000b4	8d 4d 8c	 lea	 ecx, DWORD PTR $T3[ebp]
  000b7	e8 00 00 00 00	 call	 ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >

; 1016 :             // nothrow hereafter
; 1017 :         } else {
; 1018 :             _Tree_temp_node<_Alnode> _Newnode(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...);
; 1019 :             const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
; 1020 :             if constexpr (_Multi) { // duplicate check if unique
; 1021 :                 _Loc = _Find_upper_bound(_Keyval);
; 1022 :             } else {
; 1023 :                 _Loc = _Find_lower_bound(_Keyval);
; 1024 :                 if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
; 1025 :                     return {_Loc._Bound, false};
; 1026 :                 }
; 1027 :             }
; 1028 : 
; 1029 :             _Check_grow_by_1();
; 1030 :             // nothrow hereafter
; 1031 :             _Inserted = _Newnode._Release();
; 1032 :         }
; 1033 : 
; 1034 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000bc	8b 45 e8	 mov	 eax, DWORD PTR __Inserted$[ebp]
  000bf	50		 push	 eax
  000c0	8b 4d f0	 mov	 ecx, DWORD PTR __Loc$[ebp+4]
  000c3	51		 push	 ecx
  000c4	8b 55 ec	 mov	 edx, DWORD PTR __Loc$[ebp]
  000c7	52		 push	 edx
  000c8	8b 4d f8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  000cb	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Insert_node
  000d0	89 45 84	 mov	 DWORD PTR $T1[ebp], eax
  000d3	c6 45 8b 01	 mov	 BYTE PTR $T2[ebp], 1
  000d7	8d 45 8b	 lea	 eax, DWORD PTR $T2[ebp]
  000da	50		 push	 eax
  000db	8d 4d 84	 lea	 ecx, DWORD PTR $T1[ebp]
  000de	51		 push	 ecx
  000df	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000e2	e8 00 00 00 00	 call	 ??$?0PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N$0A@@?$pair@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N@std@@QAE@$$QAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@$$QA_N@Z ; std::pair<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool>::pair<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool><std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,bool,0>
  000e7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Emplace:

; 1035 :     }

  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	5b		 pop	 ebx
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c2 08 00	 ret	 8
??$_Emplace@U?$pair@HUNPC_DATA@@@std@@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Emplace<std::pair<int,NPC_DATA> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$swap@D$0A@@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$ = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D$0A@@std@@YAXAAD0@Z PROC			; std::swap<char,0>, COMDAT

; 105  :     is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 106  :     _Ty _Tmp = _STD move(_Left);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$move@AAD@std@@YA$$QADAAD@Z ; std::move<char &>
  00012	83 c4 04	 add	 esp, 4
  00015	8a 08		 mov	 cl, BYTE PTR [eax]
  00017	88 4d ff	 mov	 BYTE PTR __Tmp$[ebp], cl

; 107  :     _Left    = _STD move(_Right);

  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$move@AAD@std@@YA$$QADAAD@Z ; std::move<char &>
  00023	83 c4 04	 add	 esp, 4
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00029	8a 10		 mov	 dl, BYTE PTR [eax]
  0002b	88 11		 mov	 BYTE PTR [ecx], dl

; 108  :     _Right   = _STD move(_Tmp);

  0002d	8d 45 ff	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$move@AAD@std@@YA$$QADAAD@Z ; std::move<char &>
  00036	83 c4 04	 add	 esp, 4
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003c	8a 10		 mov	 dl, BYTE PTR [eax]
  0003e	88 11		 mov	 BYTE PTR [ecx], dl

; 109  : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
??$swap@D$0A@@std@@YAXAAD0@Z ENDP			; std::swap<char,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0DE@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0DE@@std@@YAII@Z PROC		; std::_Get_size_of_n<52>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000d	c7 45 f8 c4 4e
	ec 04		 mov	 DWORD PTR __Max_possible$1[ebp], 82595524 ; 04ec4ec4H

; 60   :         if (_Count > _Max_possible) {

  00014	81 7d 08 c4 4e
	ec 04		 cmp	 DWORD PTR __Count$[ebp], 82595524 ; 04ec4ec4H
  0001b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00022	6b 45 08 34	 imul	 eax, DWORD PTR __Count$[ebp], 52
$LN3@Get_size_o:

; 66   : }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Get_size_of_n@$0DE@@std@@YAII@Z ENDP		; std::_Get_size_of_n<52>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@YAPAUNON_TABLE_RESET@@QAU1@0PAU1@AAV?$allocator@UNON_TABLE_RESET@@@0@@Z
_TEXT	SEGMENT
__ULast$ = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@YAPAUNON_TABLE_RESET@@QAU1@0PAU1@AAV?$allocator@UNON_TABLE_RESET@@@0@@Z PROC ; std::_Uninitialized_move<NON_TABLE_RESET *,std::allocator<NON_TABLE_RESET> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);

  00009	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAUNON_TABLE_RESET@@@std@@YA@ABQAUNON_TABLE_RESET@@@Z ; std::_Get_unwrapped<NON_TABLE_RESET * const &>
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1652 :     const auto _ULast = _Get_unwrapped(_Last);

  00018	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAUNON_TABLE_RESET@@@std@@YA@ABQAUNON_TABLE_RESET@@@Z ; std::_Get_unwrapped<NON_TABLE_RESET * const &>
  00021	83 c4 04	 add	 esp, 4
  00024	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00027	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Unfancy@UNON_TABLE_RESET@@@std@@YAPAUNON_TABLE_RESET@@PAU1@@Z ; std::_Unfancy<NON_TABLE_RESET>
  00030	83 c4 04	 add	 esp, 4
  00033	50		 push	 eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR __ULast$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 fc	 mov	 edx, DWORD PTR __UFirst$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUNON_TABLE_RESET@@PAU1@@std@@YAPAUNON_TABLE_RESET@@PAU1@00@Z ; std::_Copy_memmove<NON_TABLE_RESET *,NON_TABLE_RESET *>
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1656 :         return _Dest + (_ULast - _UFirst);

  00044	8b 45 f8	 mov	 eax, DWORD PTR __ULast$[ebp]
  00047	2b 45 fc	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0004a	99		 cdq
  0004b	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00050	f7 f9		 idiv	 ecx
  00052	6b c0 34	 imul	 eax, eax, 52
  00055	03 45 10	 add	 eax, DWORD PTR __Dest$[ebp]

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
??$_Uninitialized_move@PAUNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@YAPAUNON_TABLE_RESET@@QAU1@0PAU1@AAV?$allocator@UNON_TABLE_RESET@@@0@@Z ENDP ; std::_Uninitialized_move<NON_TABLE_RESET *,std::allocator<NON_TABLE_RESET> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0DM@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0DM@@std@@YAII@Z PROC		; std::_Get_size_of_n<60>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000d	c7 45 f8 44 44
	44 04		 mov	 DWORD PTR __Max_possible$1[ebp], 71582788 ; 04444444H

; 60   :         if (_Count > _Max_possible) {

  00014	81 7d 08 44 44
	44 04		 cmp	 DWORD PTR __Count$[ebp], 71582788 ; 04444444H
  0001b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00022	6b 45 08 3c	 imul	 eax, DWORD PTR __Count$[ebp], 60
$LN3@Get_size_o:

; 66   : }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Get_size_of_n@$0DM@@std@@YAII@Z ENDP		; std::_Get_size_of_n<60>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@YAPAUTABLE_RESET@@QAU1@0PAU1@AAV?$allocator@UTABLE_RESET@@@0@@Z
_TEXT	SEGMENT
__ULast$ = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@YAPAUTABLE_RESET@@QAU1@0PAU1@AAV?$allocator@UTABLE_RESET@@@0@@Z PROC ; std::_Uninitialized_move<TABLE_RESET *,std::allocator<TABLE_RESET> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);

  00009	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAUTABLE_RESET@@@std@@YA@ABQAUTABLE_RESET@@@Z ; std::_Get_unwrapped<TABLE_RESET * const &>
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1652 :     const auto _ULast = _Get_unwrapped(_Last);

  00018	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAUTABLE_RESET@@@std@@YA@ABQAUTABLE_RESET@@@Z ; std::_Get_unwrapped<TABLE_RESET * const &>
  00021	83 c4 04	 add	 esp, 4
  00024	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00027	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Unfancy@UTABLE_RESET@@@std@@YAPAUTABLE_RESET@@PAU1@@Z ; std::_Unfancy<TABLE_RESET>
  00030	83 c4 04	 add	 esp, 4
  00033	50		 push	 eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR __ULast$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 fc	 mov	 edx, DWORD PTR __UFirst$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUTABLE_RESET@@PAU1@@std@@YAPAUTABLE_RESET@@PAU1@00@Z ; std::_Copy_memmove<TABLE_RESET *,TABLE_RESET *>
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1656 :         return _Dest + (_ULast - _UFirst);

  00044	8b 45 f8	 mov	 eax, DWORD PTR __ULast$[ebp]
  00047	2b 45 fc	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0004a	99		 cdq
  0004b	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00050	f7 f9		 idiv	 ecx
  00052	6b c0 3c	 imul	 eax, eax, 60
  00055	03 45 10	 add	 eax, DWORD PTR __Dest$[ebp]

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
??$_Uninitialized_move@PAUTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@YAPAUTABLE_RESET@@QAU1@0PAU1@AAV?$allocator@UTABLE_RESET@@@0@@Z ENDP ; std::_Uninitialized_move<TABLE_RESET *,std::allocator<TABLE_RESET> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BM@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0BM@@std@@YAII@Z PROC		; std::_Get_size_of_n<28>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000d	c7 45 f8 49 92
	24 09		 mov	 DWORD PTR __Max_possible$1[ebp], 153391689 ; 09249249H

; 60   :         if (_Count > _Max_possible) {

  00014	81 7d 08 49 92
	24 09		 cmp	 DWORD PTR __Count$[ebp], 153391689 ; 09249249H
  0001b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00022	6b 45 08 1c	 imul	 eax, DWORD PTR __Count$[ebp], 28
$LN3@Get_size_o:

; 66   : }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Get_size_of_n@$0BM@@std@@YAII@Z ENDP		; std::_Get_size_of_n<28>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@QAU1@0PAU1@AAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@0@@Z
_TEXT	SEGMENT
__ULast$ = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@QAU1@0PAU1@AAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@0@@Z PROC ; std::_Uninitialized_move<REQUIRE_SPECIAL_ITEM *,std::allocator<REQUIRE_SPECIAL_ITEM> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);

  00009	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAUREQUIRE_SPECIAL_ITEM@@@std@@YA@ABQAUREQUIRE_SPECIAL_ITEM@@@Z ; std::_Get_unwrapped<REQUIRE_SPECIAL_ITEM * const &>
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1652 :     const auto _ULast = _Get_unwrapped(_Last);

  00018	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAUREQUIRE_SPECIAL_ITEM@@@std@@YA@ABQAUREQUIRE_SPECIAL_ITEM@@@Z ; std::_Get_unwrapped<REQUIRE_SPECIAL_ITEM * const &>
  00021	83 c4 04	 add	 esp, 4
  00024	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00027	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Unfancy@UREQUIRE_SPECIAL_ITEM@@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@PAU1@@Z ; std::_Unfancy<REQUIRE_SPECIAL_ITEM>
  00030	83 c4 04	 add	 esp, 4
  00033	50		 push	 eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR __ULast$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 fc	 mov	 edx, DWORD PTR __UFirst$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUREQUIRE_SPECIAL_ITEM@@PAU1@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@PAU1@00@Z ; std::_Copy_memmove<REQUIRE_SPECIAL_ITEM *,REQUIRE_SPECIAL_ITEM *>
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1656 :         return _Dest + (_ULast - _UFirst);

  00044	8b 45 f8	 mov	 eax, DWORD PTR __ULast$[ebp]
  00047	2b 45 fc	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0004a	99		 cdq
  0004b	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00050	f7 f9		 idiv	 ecx
  00052	6b c0 1c	 imul	 eax, eax, 28
  00055	03 45 10	 add	 eax, DWORD PTR __Dest$[ebp]

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
??$_Uninitialized_move@PAUREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@QAU1@0PAU1@AAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@0@@Z ENDP ; std::_Uninitialized_move<REQUIRE_SPECIAL_ITEM *,std::allocator<REQUIRE_SPECIAL_ITEM> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0M@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0M@@std@@YAII@Z PROC			; std::_Get_size_of_n<12>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000d	c7 45 f8 55 55
	55 15		 mov	 DWORD PTR __Max_possible$1[ebp], 357913941 ; 15555555H

; 60   :         if (_Count > _Max_possible) {

  00014	81 7d 08 55 55
	55 15		 cmp	 DWORD PTR __Count$[ebp], 357913941 ; 15555555H
  0001b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00022	6b 45 08 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
$LN3@Get_size_o:

; 66   : }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Get_size_of_n@$0M@@std@@YAII@Z ENDP			; std::_Get_size_of_n<12>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@YAPAUBORN_PLACE@@QAU1@0PAU1@AAV?$allocator@UBORN_PLACE@@@0@@Z
_TEXT	SEGMENT
__ULast$ = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@YAPAUBORN_PLACE@@QAU1@0PAU1@AAV?$allocator@UBORN_PLACE@@@0@@Z PROC ; std::_Uninitialized_move<BORN_PLACE *,std::allocator<BORN_PLACE> >, COMDAT

; 1647 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1648 :     // move [_First, _Last) to raw _Dest, using _Al
; 1649 :     // note: only called internally from elsewhere in the STL
; 1650 :     using _Ptrval     = typename _Alloc::value_type*;
; 1651 :     auto _UFirst      = _Get_unwrapped(_First);

  00009	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAUBORN_PLACE@@@std@@YA@ABQAUBORN_PLACE@@@Z ; std::_Get_unwrapped<BORN_PLACE * const &>
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1652 :     const auto _ULast = _Get_unwrapped(_Last);

  00018	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAUBORN_PLACE@@@std@@YA@ABQAUBORN_PLACE@@@Z ; std::_Get_unwrapped<BORN_PLACE * const &>
  00021	83 c4 04	 add	 esp, 4
  00024	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1653 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1654 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1655 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00027	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Unfancy@UBORN_PLACE@@@std@@YAPAUBORN_PLACE@@PAU1@@Z ; std::_Unfancy<BORN_PLACE>
  00030	83 c4 04	 add	 esp, 4
  00033	50		 push	 eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR __ULast$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 fc	 mov	 edx, DWORD PTR __UFirst$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUBORN_PLACE@@PAU1@@std@@YAPAUBORN_PLACE@@PAU1@00@Z ; std::_Copy_memmove<BORN_PLACE *,BORN_PLACE *>
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1656 :         return _Dest + (_ULast - _UFirst);

  00044	8b 45 f8	 mov	 eax, DWORD PTR __ULast$[ebp]
  00047	2b 45 fc	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0004a	99		 cdq
  0004b	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00050	f7 f9		 idiv	 ecx
  00052	6b c0 0c	 imul	 eax, eax, 12
  00055	03 45 10	 add	 eax, DWORD PTR __Dest$[ebp]

; 1657 :     } else {
; 1658 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1659 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1660 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1661 :         }
; 1662 : 
; 1663 :         return _Backout._Release();
; 1664 :     }
; 1665 : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
??$_Uninitialized_move@PAUBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@YAPAUBORN_PLACE@@QAU1@0PAU1@AAV?$allocator@UBORN_PLACE@@@0@@Z ENDP ; std::_Uninitialized_move<BORN_PLACE *,std::allocator<BORN_PLACE> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0CI@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0CI@@std@@YAII@Z PROC		; std::_Get_size_of_n<40>, COMDAT

; 55   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000d	c7 45 f8 66 66
	66 06		 mov	 DWORD PTR __Max_possible$1[ebp], 107374182 ; 06666666H

; 60   :         if (_Count > _Max_possible) {

  00014	81 7d 08 66 66
	66 06		 cmp	 DWORD PTR __Count$[ebp], 107374182 ; 06666666H
  0001b	76 05		 jbe	 SHORT $LN2@Get_size_o

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00022	6b 45 08 28	 imul	 eax, DWORD PTR __Count$[ebp], 40
$LN3@Get_size_o:

; 66   : }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Get_size_of_n@$0CI@@std@@YAII@Z ENDP		; std::_Get_size_of_n<40>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<int const ,NPC_DATA>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >, COMDAT

; 377  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 378  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode call");
; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	83 c0 10	 add	 eax, 16			; 00000010H
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@YAPAU?$pair@$$CBHUNPC_DATA@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,NPC_DATA> >
  00034	83 c4 04	 add	 esp, 4
  00037	50		 push	 eax
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??$destroy@U?$pair@$$CBHUNPC_DATA@@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@QAU?$pair@$$CBHUNPC_DATA@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::destroy<std::pair<int const ,NPC_DATA> >
  00041	83 c4 08	 add	 esp, 8

; 380  :         _Freenode0(_Al, _Ptr);

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00047	50		 push	 eax
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<int const ,NPC_DATA>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
  00051	83 c4 08	 add	 esp, 8

; 381  :     }

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<int const ,NPC_DATA>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00009	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	6a 04		 push	 4
  00018	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0001d	83 c4 08	 add	 esp, 8
  00020	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ??$forward@ABQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAABQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@ABQAU10@@Z ; std::forward<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * const &>
  0002c	83 c4 04	 add	 esp, 4
  0002f	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 02		 mov	 DWORD PTR [edx], eax

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z PROC ; std::forward<std::_Zero_then_variadic_args_t>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z ENDP ; std::forward<std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABU?$less@H@std@@@std@@YAABU?$less@H@0@ABU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABU?$less@H@std@@@std@@YAABU?$less@H@0@ABU10@@Z PROC ; std::forward<std::less<int> const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABU?$less@H@std@@@std@@YAABU?$less@H@0@ABU10@@Z ENDP ; std::forward<std::less<int> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<int const ,NPC_DATA>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >, COMDAT

; 368  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 369  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 370  :         _Destroy_in_place(_Ptr->_Left);

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>
  00031	83 c4 04	 add	 esp, 4

; 371  :         _Destroy_in_place(_Ptr->_Parent);

  00034	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00037	83 c0 04	 add	 eax, 4
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>
  00040	83 c4 04	 add	 esp, 4

; 372  :         _Destroy_in_place(_Ptr->_Right);

  00043	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00046	83 c0 08	 add	 eax, 8
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *>
  0004f	83 c4 04	 add	 esp, 4

; 373  :         allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);

  00052	6a 01		 push	 1
  00054	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00057	50		 push	 eax
  00058	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::deallocate
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH

; 374  :     }

  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
  00076	cc		 int	 3
  00077	cc		 int	 3
  00078	cc		 int	 3
  00079	cc		 int	 3
  0007a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<int const ,NPC_DATA>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Erase_tree:

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000f	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  00013	85 c9		 test	 ecx, ecx
  00015	75 32		 jne	 SHORT $LN4@Erase_tree

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00017	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0001a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001d	51		 push	 ecx
  0001e	8b 55 08	 mov	 edx, DWORD PTR __Al$[ebp]
  00021	52		 push	 edx
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

  0002a	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0002d	50		 push	 eax
  0002e	8d 4d 0c	 lea	 ecx, DWORD PTR __Rootnode$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 ??$exchange@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@AAPAU12@@std@@YAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@AAPAU10@0@Z ; std::exchange<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * &>
  00037	83 c4 08	 add	 esp, 8
  0003a	50		 push	 eax
  0003b	8b 55 08	 mov	 edx, DWORD PTR __Al$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<int const ,NPC_DATA>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
  00044	83 c4 08	 add	 esp, 8

; 746  :         }

  00047	eb c3		 jmp	 SHORT $LN2@Erase_tree
$LN4@Erase_tree:

; 747  :     }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@ABH@Z
_TEXT	SEGMENT
tv78 = -72						; size = 4
_this$ = -4						; size = 4
__Bound$ = 8						; size = 4
__Keyval$ = 12						; size = 4
??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Lower_bound_duplicate<int>, COMDAT
; _this$ = ecx

; 1694 :     bool _Lower_bound_duplicate(const _Nodeptr _Bound, const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Bound$[ebp]
  0000f	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  00013	85 c9		 test	 ecx, ecx
  00015	75 33		 jne	 SHORT $LN3@Lower_boun
  00017	8b 55 08	 mov	 edx, DWORD PTR __Bound$[ebp]
  0001a	83 c2 10	 add	 edx, 16			; 00000010H
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHUNPC_DATA@@@?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUNPC_DATA@@@1@@Z ; std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0>::_Kfn<int const ,NPC_DATA>
  00023	83 c4 04	 add	 esp, 4
  00026	50		 push	 eax
  00027	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Getcomp@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Getcomp
  00033	8b c8		 mov	 ecx, eax
  00035	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0003a	0f b6 c8	 movzx	 ecx, al
  0003d	85 c9		 test	 ecx, ecx
  0003f	75 09		 jne	 SHORT $LN3@Lower_boun
  00041	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  00048	eb 07		 jmp	 SHORT $LN4@Lower_boun
$LN3@Lower_boun:
  0004a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN4@Lower_boun:
  00051	8a 45 b8	 mov	 al, BYTE PTR tv78[ebp]

; 1696 :     }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Lower_bound_duplicate<int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@ABH@Z
_TEXT	SEGMENT
__Trynode$ = -24					; size = 4
__Result$ = -20						; size = 12
__Scary$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Find_lower_bound<int>, COMDAT
; _this$ = ecx

; 1699 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1700 :         const auto _Scary = _Get_scary();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1701 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001f	89 55 ec	 mov	 DWORD PTR __Result$[ebp], edx
  00022	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 0
  00029	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	89 4d f4	 mov	 DWORD PTR __Result$[ebp+8], ecx

; 1702 :         _Nodeptr _Trynode = _Result._Location._Parent;

  00031	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]
  00034	89 45 e8	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN2@Find_lower:

; 1703 :         while (!_Trynode->_Isnil) {

  00037	8b 45 e8	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0003a	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  0003e	85 c9		 test	 ecx, ecx
  00040	75 59		 jne	 SHORT $LN3@Find_lower

; 1704 :             _Result._Location._Parent = _Trynode;

  00042	8b 45 e8	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00045	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 1705 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  00048	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d e8	 mov	 ecx, DWORD PTR __Trynode$[ebp]
  0004f	83 c1 10	 add	 ecx, 16			; 00000010H
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ??$_Kfn@$$CBHUNPC_DATA@@@?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHUNPC_DATA@@@1@@Z ; std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0>::_Kfn<int const ,NPC_DATA>
  00058	83 c4 04	 add	 esp, 4
  0005b	50		 push	 eax
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Getcomp@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Getcomp
  00064	8b c8		 mov	 ecx, eax
  00066	e8 00 00 00 00	 call	 ??R?$less@H@std@@QBE_NABH0@Z ; std::less<int>::operator()
  0006b	0f b6 d0	 movzx	 edx, al
  0006e	85 d2		 test	 edx, edx
  00070	74 12		 je	 SHORT $LN4@Find_lower

; 1706 :                 _Result._Location._Child = _Tree_child::_Right;

  00072	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 0

; 1707 :                 _Trynode                 = _Trynode->_Right;

  00079	8b 45 e8	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0007c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0007f	89 4d e8	 mov	 DWORD PTR __Trynode$[ebp], ecx

; 1708 :             } else {

  00082	eb 15		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1709 :                 _Result._Location._Child = _Tree_child::_Left;

  00084	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 1

; 1710 :                 _Result._Bound           = _Trynode;

  0008b	8b 45 e8	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008e	89 45 f4	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1711 :                 _Trynode                 = _Trynode->_Left;

  00091	8b 45 e8	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00094	8b 08		 mov	 ecx, DWORD PTR [eax]
  00096	89 4d e8	 mov	 DWORD PTR __Trynode$[ebp], ecx
$LN5@Find_lower:

; 1712 :             }
; 1713 :         }

  00099	eb 9c		 jmp	 SHORT $LN2@Find_lower
$LN3@Find_lower:

; 1714 : 
; 1715 :         return _Result;

  0009b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0009e	8b 4d ec	 mov	 ecx, DWORD PTR __Result$[ebp]
  000a1	89 08		 mov	 DWORD PTR [eax], ecx
  000a3	8b 55 f0	 mov	 edx, DWORD PTR __Result$[ebp+4]
  000a6	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000a9	8b 4d f4	 mov	 ecx, DWORD PTR __Result$[ebp+8]
  000ac	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000af	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1716 :     }

  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 08 00	 ret	 8
??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Find_lower_bound<int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,std::_Iterator_base0>
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::_Tree_unchecked_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$emplace@U?$pair@HUNPC_DATA@@@std@@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z
_TEXT	SEGMENT
$T1 = -80						; size = 4
__Result$ = -12						; size = 8
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_<_Vals_0>$ = 12					; size = 4
??$emplace@U?$pair@HUNPC_DATA@@@std@@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::emplace<std::pair<int,NPC_DATA> >, COMDAT
; _this$ = ecx

; 1094 :     pair<iterator, bool> emplace(_Valtys&&... _Vals) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1095 :         const auto _Result = _Emplace(_STD forward<_Valtys>(_Vals)...);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@U?$pair@HUNPC_DATA@@@std@@@std@@YA$$QAU?$pair@HUNPC_DATA@@@0@AAU10@@Z ; std::forward<std::pair<int,NPC_DATA> >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8d 4d f4	 lea	 ecx, DWORD PTR __Result$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Emplace@U?$pair@HUNPC_DATA@@@std@@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@_N@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Emplace<std::pair<int,NPC_DATA> >

; 1096 :         return {iterator(_Result.first, _Get_scary()), _Result.second};

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
  0002d	50		 push	 eax
  0002e	8b 45 f4	 mov	 eax, DWORD PTR __Result$[ebp]
  00031	50		 push	 eax
  00032	8d 4d b0	 lea	 ecx, DWORD PTR $T1[ebp]
  00035	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z
  0003a	8d 4d f8	 lea	 ecx, DWORD PTR __Result$[ebp+4]
  0003d	51		 push	 ecx
  0003e	50		 push	 eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00042	e8 00 00 00 00	 call	 ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@AB_N$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@1@AB_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >,bool const &,0>
  00047	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1097 :     }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
??$emplace@U?$pair@HUNPC_DATA@@@std@@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::emplace<std::pair<int,NPC_DATA> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@U?$pair@HUNPC_DATA@@@std@@@std@@YA$$QAU?$pair@HUNPC_DATA@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@HUNPC_DATA@@@std@@@std@@YA$$QAU?$pair@HUNPC_DATA@@@0@AAU10@@Z PROC ; std::forward<std::pair<int,NPC_DATA> >, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@U?$pair@HUNPC_DATA@@@std@@@std@@YA$$QAU?$pair@HUNPC_DATA@@@0@AAU10@@Z ENDP ; std::forward<std::pair<int,NPC_DATA> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$?0AAHAAUNPC_DATA@@$0A@@?$pair@HUNPC_DATA@@@std@@QAE@AAHAAUNPC_DATA@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAUNPC_DATA@@$0A@@?$pair@HUNPC_DATA@@@std@@QAE@AAHAAUNPC_DATA@@@Z PROC ; std::pair<int,NPC_DATA>::pair<int,NPC_DATA><int &,NPC_DATA &,0>, COMDAT
; _this$ = ecx

; 192  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Val2$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??$forward@AAUNPC_DATA@@@std@@YAAAUNPC_DATA@@AAU1@@Z ; std::forward<NPC_DATA &>
  00028	83 c4 04	 add	 esp, 4
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	83 c1 04	 add	 ecx, 4
  00031	8b 10		 mov	 edx, DWORD PTR [eax]
  00033	89 11		 mov	 DWORD PTR [ecx], edx
  00035	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00038	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0003b	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00041	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00044	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00047	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0004a	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 08 00	 ret	 8
??$?0AAHAAUNPC_DATA@@$0A@@?$pair@HUNPC_DATA@@@std@@QAE@AAHAAUNPC_DATA@@@Z ENDP ; std::pair<int,NPC_DATA>::pair<int,NPC_DATA><int &,NPC_DATA &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@AAUNPC_DATA@@@std@@YAAAUNPC_DATA@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUNPC_DATA@@@std@@YAAAUNPC_DATA@@AAU1@@Z PROC ; std::forward<NPC_DATA &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAUNPC_DATA@@@std@@YAAAUNPC_DATA@@AAU1@@Z ENDP ; std::forward<NPC_DATA &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = -4						; size = 4
__Al$ = 8						; size = 4
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<int const ,NPC_DATA>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >, COMDAT

; 341  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 342  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buyheadnode call");
; 343  :         const auto _Pnode = _Al.allocate(1);

  00009	6a 01		 push	 1
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000e	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >::allocate
  00013	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00016	8d 45 fc	 lea	 eax, DWORD PTR __Pnode$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * const &>
  00023	83 c4 08	 add	 esp, 8

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00026	8d 45 fc	 lea	 eax, DWORD PTR __Pnode$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0002d	83 c1 04	 add	 ecx, 4
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * const &>
  00036	83 c4 08	 add	 esp, 8

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00039	8d 45 fc	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00040	83 c1 08	 add	 ecx, 8
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> *,std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> * const &>
  00049	83 c4 08	 add	 esp, 8

; 347  :         _Pnode->_Color = _Black;

  0004c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0004f	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 348  :         _Pnode->_Isnil = true;

  00053	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00056	c6 40 0d 01	 mov	 BYTE PTR [eax+13], 1

; 349  :         return _Pnode;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 350  :     }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<int const ,NPC_DATA>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@YAXPAUNON_TABLE_RESET@@QAU1@AAV?$allocator@UNON_TABLE_RESET@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@YAXPAUNON_TABLE_RESET@@QAU1@AAV?$allocator@UNON_TABLE_RESET@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NON_TABLE_RESET> >, COMDAT

; 955  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_range@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@YAXPAUNON_TABLE_RESET@@QAU1@AAV?$allocator@UNON_TABLE_RESET@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NON_TABLE_RESET> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UTABLE_RESET@@@std@@@std@@YAXPAUTABLE_RESET@@QAU1@AAV?$allocator@UTABLE_RESET@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UTABLE_RESET@@@std@@@std@@YAXPAUTABLE_RESET@@QAU1@AAV?$allocator@UTABLE_RESET@@@0@@Z PROC ; std::_Destroy_range<std::allocator<TABLE_RESET> >, COMDAT

; 955  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_range@V?$allocator@UTABLE_RESET@@@std@@@std@@YAXPAUTABLE_RESET@@QAU1@AAV?$allocator@UTABLE_RESET@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<TABLE_RESET> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@YAXPAUREQUIRE_SPECIAL_ITEM@@QAU1@AAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@YAXPAUREQUIRE_SPECIAL_ITEM@@QAU1@AAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@0@@Z PROC ; std::_Destroy_range<std::allocator<REQUIRE_SPECIAL_ITEM> >, COMDAT

; 955  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_range@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@YAXPAUREQUIRE_SPECIAL_ITEM@@QAU1@AAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<REQUIRE_SPECIAL_ITEM> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UBORN_PLACE@@@std@@@std@@YAXPAUBORN_PLACE@@QAU1@AAV?$allocator@UBORN_PLACE@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UBORN_PLACE@@@std@@@std@@YAXPAUBORN_PLACE@@QAU1@AAV?$allocator@UBORN_PLACE@@@0@@Z PROC ; std::_Destroy_range<std::allocator<BORN_PLACE> >, COMDAT

; 955  : void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 956  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 957  :     using _Ty = typename _Alloc::value_type;
; 958  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 959  :         for (; _First != _Last; ++_First) {
; 960  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 961  :         }
; 962  :     }
; 963  : }

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_range@V?$allocator@UBORN_PLACE@@@std@@@std@@YAXPAUBORN_PLACE@@QAU1@AAV?$allocator@UBORN_PLACE@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<BORN_PLACE> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1><>, COMDAT
; _this$ = ecx

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0ABU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
??$?0ABU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx

; 1341 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@ABU?$less@H@std@@@std@@YAABU?$less@H@0@ABU10@@Z ; std::forward<std::less<int> const &>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 45 10	 mov	 eax, DWORD PTR _<_Val2_0>$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
  00021	83 c4 04	 add	 esp, 4
  00024	8a 08		 mov	 cl, BYTE PTR [eax]
  00026	0f b6 d1	 movzx	 edx, cl
  00029	52		 push	 edx
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1><>
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
??$?0ABU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > const >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > const >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@YAPAU?$pair@$$CBHUNPC_DATA@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@YAPAU?$pair@$$CBHUNPC_DATA@@@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,NPC_DATA> >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@YAPAU?$pair@$$CBHUNPC_DATA@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,NPC_DATA> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UNON_TABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@UNON_TABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<NON_TABLE_RESET>,std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >,1>::_Compressed_pair<std::allocator<NON_TABLE_RESET>,std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >,1><>, COMDAT
; _this$ = ecx

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@UNON_TABLE_RESET@@@std@@QAE@XZ ; std::allocator<NON_TABLE_RESET>::allocator<NON_TABLE_RESET>
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@UNON_TABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<NON_TABLE_RESET>,std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >,1>::_Compressed_pair<std::allocator<NON_TABLE_RESET>,std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z
_TEXT	SEGMENT
__Constructed_first$ = -64				; size = 4
__Constructed_last$ = -60				; size = 4
__Newvec$ = -56						; size = 4
__Newcapacity$ = -52					; size = 4
__Newsize$ = -48					; size = 4
__Oldsize$ = -44					; size = 4
__Whereoff$ = -40					; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
__My_data$ = -28					; size = 4
__Al$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Emplace_reallocate<NON_TABLE_RESET const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 70	 sub	 esp, 112		; 00000070H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Getal@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UNON_TABLE_RESET@@@2@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Getal
  00037	89 45 e8	 mov	 DWORD PTR __Al$[ebp], eax

; 728  :         auto& _My_data    = _Mypair._Myval2;

  0003a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00040	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00043	89 45 e0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  00046	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	83 c0 04	 add	 eax, 4
  0004c	89 45 dc	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0004f	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00055	2b 08		 sub	 ecx, DWORD PTR [eax]
  00057	8b c1		 mov	 eax, ecx
  00059	99		 cdq
  0005a	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  0005f	f7 f9		 idiv	 ecx
  00061	89 45 d8	 mov	 DWORD PTR __Whereoff$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00064	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00067	8b 4d e0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006a	8b 00		 mov	 eax, DWORD PTR [eax]
  0006c	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006e	99		 cdq
  0006f	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00074	f7 f9		 idiv	 ecx
  00076	89 45 d4	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  00079	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ?max_size@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QBEIXZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::max_size
  00081	39 45 d4	 cmp	 DWORD PTR __Oldsize$[ebp], eax
  00084	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  00086	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@CAXXZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0008b	8b 45 d4	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  0008e	83 c0 01	 add	 eax, 1
  00091	89 45 d0	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  00094	8b 45 d0	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	50		 push	 eax
  00098	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@ABEII@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Calculate_growth
  000a0	89 45 cc	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 743  : 
; 744  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

  000a3	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000a6	50		 push	 eax
  000a7	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  000aa	e8 00 00 00 00	 call	 ?allocate@?$allocator@UNON_TABLE_RESET@@@std@@QAEPAUNON_TABLE_RESET@@I@Z ; std::allocator<NON_TABLE_RESET>::allocate
  000af	89 45 c8	 mov	 DWORD PTR __Newvec$[ebp], eax

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000b2	6b 45 d8 34	 imul	 eax, DWORD PTR __Whereoff$[ebp], 52
  000b6	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000b9	8d 54 01 34	 lea	 edx, DWORD PTR [ecx+eax+52]
  000bd	89 55 c4	 mov	 DWORD PTR __Constructed_last$[ebp], edx

; 746  :         pointer _Constructed_first      = _Constructed_last;

  000c0	8b 45 c4	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  000c3	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  000c6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000cd	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ??$forward@ABUNON_TABLE_RESET@@@std@@YAABUNON_TABLE_RESET@@ABU1@@Z ; std::forward<NON_TABLE_RESET const &>
  000d6	83 c4 04	 add	 esp, 4
  000d9	50		 push	 eax
  000da	6b 4d d8 34	 imul	 ecx, DWORD PTR __Whereoff$[ebp], 52
  000de	03 4d c8	 add	 ecx, DWORD PTR __Newvec$[ebp]
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 ??$_Unfancy@UNON_TABLE_RESET@@@std@@YAPAUNON_TABLE_RESET@@PAU1@@Z ; std::_Unfancy<NON_TABLE_RESET>
  000e7	83 c4 04	 add	 esp, 4
  000ea	50		 push	 eax
  000eb	8b 55 e8	 mov	 edx, DWORD PTR __Al$[ebp]
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 ??$construct@UNON_TABLE_RESET@@ABU1@@?$_Default_allocator_traits@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@SAXAAV?$allocator@UNON_TABLE_RESET@@@1@QAUNON_TABLE_RESET@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<NON_TABLE_RESET> >::construct<NON_TABLE_RESET,NON_TABLE_RESET const &>
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  000f7	6b 45 d8 34	 imul	 eax, DWORD PTR __Whereoff$[ebp], 52
  000fb	03 45 c8	 add	 eax, DWORD PTR __Newvec$[ebp]
  000fe	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00101	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00104	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00107	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00109	75 1a		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  0010b	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0010e	50		 push	 eax
  0010f	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00112	8b 11		 mov	 edx, DWORD PTR [ecx]
  00114	52		 push	 edx
  00115	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00118	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011a	51		 push	 ecx
  0011b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011e	e8 00 00 00 00	 call	 ?_Umove_if_noexcept@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@00@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Umove_if_noexcept

; 754  :         } else { // provide basic guarantee

  00123	eb 3a		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  00125	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00128	50		 push	 eax
  00129	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0012c	51		 push	 ecx
  0012d	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00130	8b 02		 mov	 eax, DWORD PTR [edx]
  00132	50		 push	 eax
  00133	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	e8 00 00 00 00	 call	 ?_Umove@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEPAUNON_TABLE_RESET@@PAU3@00@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Umove

; 756  :             _Constructed_first = _Newvec;

  0013b	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0013e	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00141	6b 45 d8 34	 imul	 eax, DWORD PTR __Whereoff$[ebp], 52
  00145	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00148	8d 54 01 34	 lea	 edx, DWORD PTR [ecx+eax+52]
  0014c	52		 push	 edx
  0014d	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	51		 push	 ecx
  00153	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  00156	52		 push	 edx
  00157	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	e8 00 00 00 00	 call	 ?_Umove@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEPAUNON_TABLE_RESET@@PAU3@00@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Umove
$LN5@Emplace_re:
  0015f	eb 2f		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00161	8b 45 c4	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00164	50		 push	 eax
  00165	8b 4d c0	 mov	 ecx, DWORD PTR __Constructed_first$[ebp]
  00168	51		 push	 ecx
  00169	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0016c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@0@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00171	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00174	50		 push	 eax
  00175	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00178	51		 push	 ecx
  00179	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  0017c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UNON_TABLE_RESET@@@std@@QAEXQAUNON_TABLE_RESET@@I@Z ; std::allocator<NON_TABLE_RESET>::deallocate

; 762  :         _RERAISE;

  00181	6a 00		 push	 0
  00183	6a 00		 push	 0
  00185	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  0018a	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0018f	c3		 ret	 0
$LN7@Emplace_re:
  00190	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00197	eb 07		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z$1
$LN10@Emplace_re:
  00199	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z$1:

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001a0	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  001a3	50		 push	 eax
  001a4	8b 4d d0	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  001a7	51		 push	 ecx
  001a8	8b 55 c8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  001ab	52		 push	 edx
  001ac	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001af	e8 00 00 00 00	 call	 ?_Change_array@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXQAUNON_TABLE_RESET@@II@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  001b4	6b 45 d8 34	 imul	 eax, DWORD PTR __Whereoff$[ebp], 52
  001b8	03 45 c8	 add	 eax, DWORD PTR __Newvec$[ebp]
$LN6@Emplace_re:

; 767  :     }

  001bb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001be	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001c5	59		 pop	 ecx
  001c6	5f		 pop	 edi
  001c7	5e		 pop	 esi
  001c8	5b		 pop	 ebx
  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c2 08 00	 ret	 8
  001cf	cc		 int	 3
  001d0	cc		 int	 3
  001d1	cc		 int	 3
  001d2	cc		 int	 3
  001d3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 7c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-132]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Emplace_reallocate<NON_TABLE_RESET const &>
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@UNON_TABLE_RESET@@ABU1@@?$_Default_allocator_traits@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@SAXAAV?$allocator@UNON_TABLE_RESET@@@1@QAUNON_TABLE_RESET@@ABU3@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UNON_TABLE_RESET@@ABU1@@?$_Default_allocator_traits@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@SAXAAV?$allocator@UNON_TABLE_RESET@@@1@QAUNON_TABLE_RESET@@ABU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<NON_TABLE_RESET> >::construct<NON_TABLE_RESET,NON_TABLE_RESET const &>, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	50		 push	 eax
  0000d	6a 34		 push	 52			; 00000034H
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00014	83 c4 08	 add	 esp, 8
  00017	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ??$forward@ABUNON_TABLE_RESET@@@std@@YAABUNON_TABLE_RESET@@ABU1@@Z ; std::forward<NON_TABLE_RESET const &>
  00023	83 c4 04	 add	 esp, 4
  00026	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  0002b	8b f0		 mov	 esi, eax
  0002d	8b 7d bc	 mov	 edi, DWORD PTR $T1[ebp]
  00030	f3 a5		 rep movsd

; 695  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$construct@UNON_TABLE_RESET@@ABU1@@?$_Default_allocator_traits@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@SAXAAV?$allocator@UNON_TABLE_RESET@@@1@QAUNON_TABLE_RESET@@ABU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<NON_TABLE_RESET> >::construct<NON_TABLE_RESET,NON_TABLE_RESET const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$_Unfancy@UNON_TABLE_RESET@@@std@@YAPAUNON_TABLE_RESET@@PAU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@UNON_TABLE_RESET@@@std@@YAPAUNON_TABLE_RESET@@PAU1@@Z PROC ; std::_Unfancy<NON_TABLE_RESET>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 289  :     return _Ptr;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Unfancy@UNON_TABLE_RESET@@@std@@YAPAUNON_TABLE_RESET@@PAU1@@Z ENDP ; std::_Unfancy<NON_TABLE_RESET>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAE@ABUNON_TABLE_RESET@@@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAE@ABUNON_TABLE_RESET@@@Z PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Emplace_back_with_unused_capacity<NON_TABLE_RESET const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 686  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$forward@ABUNON_TABLE_RESET@@@std@@YAABUNON_TABLE_RESET@@ABU1@@Z ; std::forward<NON_TABLE_RESET const &>
  00024	83 c4 04	 add	 esp, 4
  00027	50		 push	 eax
  00028	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ??$_Unfancy@UNON_TABLE_RESET@@@std@@YAPAUNON_TABLE_RESET@@PAU1@@Z ; std::_Unfancy<NON_TABLE_RESET>
  00033	83 c4 04	 add	 esp, 4
  00036	50		 push	 eax
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Getal@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UNON_TABLE_RESET@@@2@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Getal
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$construct@UNON_TABLE_RESET@@ABU1@@?$_Default_allocator_traits@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@SAXAAV?$allocator@UNON_TABLE_RESET@@@1@QAUNON_TABLE_RESET@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<NON_TABLE_RESET> >::construct<NON_TABLE_RESET,NON_TABLE_RESET const &>
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 688  :         _Orphan_range(_Mylast, _Mylast);

  00048	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	51		 push	 ecx
  0004e	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	50		 push	 eax
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@ABEXPAUNON_TABLE_RESET@@0@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Orphan_range

; 689  :         _Ty& _Result = *_Mylast;

  0005c	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	89 4d f0	 mov	 DWORD PTR __Result$[ebp], ecx

; 690  :         ++_Mylast;

  00064	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	83 c1 34	 add	 ecx, 52			; 00000034H
  0006c	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0006f	89 0a		 mov	 DWORD PTR [edx], ecx

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAE@ABUNON_TABLE_RESET@@@Z ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Emplace_back_with_unused_capacity<NON_TABLE_RESET const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABUNON_TABLE_RESET@@@std@@YAABUNON_TABLE_RESET@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUNON_TABLE_RESET@@@std@@YAABUNON_TABLE_RESET@@ABU1@@Z PROC ; std::forward<NON_TABLE_RESET const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUNON_TABLE_RESET@@@std@@YAABUNON_TABLE_RESET@@ABU1@@Z ENDP ; std::forward<NON_TABLE_RESET const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$emplace_back@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE@ABUNON_TABLE_RESET@@@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE@ABUNON_TABLE_RESET@@@Z PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::emplace_back<NON_TABLE_RESET const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001e	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00021	8b 10		 mov	 edx, DWORD PTR [eax]
  00023	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00026	74 17		 je	 SHORT $LN2@emplace_ba

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00028	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$forward@ABUNON_TABLE_RESET@@@std@@YAABUNON_TABLE_RESET@@ABU1@@Z ; std::forward<NON_TABLE_RESET const &>
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAE@ABUNON_TABLE_RESET@@@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Emplace_back_with_unused_capacity<NON_TABLE_RESET const &>
  0003d	eb 1e		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$forward@ABUNON_TABLE_RESET@@@std@@YAABUNON_TABLE_RESET@@ABU1@@Z ; std::forward<NON_TABLE_RESET const &>
  00048	83 c4 04	 add	 esp, 4
  0004b	50		 push	 eax
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	52		 push	 edx
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEPAUNON_TABLE_RESET@@QAU2@ABU2@@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Emplace_reallocate<NON_TABLE_RESET const &>
  0005a	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
??$emplace_back@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE@ABUNON_TABLE_RESET@@@Z ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::emplace_back<NON_TABLE_RESET const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UTABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@UTABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<TABLE_RESET>,std::_Vector_val<std::_Simple_types<TABLE_RESET> >,1>::_Compressed_pair<std::allocator<TABLE_RESET>,std::_Vector_val<std::_Simple_types<TABLE_RESET> >,1><>, COMDAT
; _this$ = ecx

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@UTABLE_RESET@@@std@@QAE@XZ ; std::allocator<TABLE_RESET>::allocator<TABLE_RESET>
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<TABLE_RESET> >::_Vector_val<std::_Simple_types<TABLE_RESET> >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@UTABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<TABLE_RESET>,std::_Vector_val<std::_Simple_types<TABLE_RESET> >,1>::_Compressed_pair<std::allocator<TABLE_RESET>,std::_Vector_val<std::_Simple_types<TABLE_RESET> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z
_TEXT	SEGMENT
__Constructed_first$ = -64				; size = 4
__Constructed_last$ = -60				; size = 4
__Newvec$ = -56						; size = 4
__Newcapacity$ = -52					; size = 4
__Newsize$ = -48					; size = 4
__Oldsize$ = -44					; size = 4
__Whereoff$ = -40					; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
__My_data$ = -28					; size = 4
__Al$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Emplace_reallocate<TABLE_RESET const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 70	 sub	 esp, 112		; 00000070H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Getal@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UTABLE_RESET@@@2@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Getal
  00037	89 45 e8	 mov	 DWORD PTR __Al$[ebp], eax

; 728  :         auto& _My_data    = _Mypair._Myval2;

  0003a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00040	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00043	89 45 e0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  00046	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	83 c0 04	 add	 eax, 4
  0004c	89 45 dc	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0004f	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00055	2b 08		 sub	 ecx, DWORD PTR [eax]
  00057	8b c1		 mov	 eax, ecx
  00059	99		 cdq
  0005a	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0005f	f7 f9		 idiv	 ecx
  00061	89 45 d8	 mov	 DWORD PTR __Whereoff$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00064	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00067	8b 4d e0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006a	8b 00		 mov	 eax, DWORD PTR [eax]
  0006c	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006e	99		 cdq
  0006f	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00074	f7 f9		 idiv	 ecx
  00076	89 45 d4	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  00079	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ?max_size@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QBEIXZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::max_size
  00081	39 45 d4	 cmp	 DWORD PTR __Oldsize$[ebp], eax
  00084	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  00086	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@CAXXZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0008b	8b 45 d4	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  0008e	83 c0 01	 add	 eax, 1
  00091	89 45 d0	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  00094	8b 45 d0	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	50		 push	 eax
  00098	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@ABEII@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Calculate_growth
  000a0	89 45 cc	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 743  : 
; 744  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

  000a3	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000a6	50		 push	 eax
  000a7	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  000aa	e8 00 00 00 00	 call	 ?allocate@?$allocator@UTABLE_RESET@@@std@@QAEPAUTABLE_RESET@@I@Z ; std::allocator<TABLE_RESET>::allocate
  000af	89 45 c8	 mov	 DWORD PTR __Newvec$[ebp], eax

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000b2	6b 45 d8 3c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 60
  000b6	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000b9	8d 54 01 3c	 lea	 edx, DWORD PTR [ecx+eax+60]
  000bd	89 55 c4	 mov	 DWORD PTR __Constructed_last$[ebp], edx

; 746  :         pointer _Constructed_first      = _Constructed_last;

  000c0	8b 45 c4	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  000c3	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  000c6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000cd	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ??$forward@ABUTABLE_RESET@@@std@@YAABUTABLE_RESET@@ABU1@@Z ; std::forward<TABLE_RESET const &>
  000d6	83 c4 04	 add	 esp, 4
  000d9	50		 push	 eax
  000da	6b 4d d8 3c	 imul	 ecx, DWORD PTR __Whereoff$[ebp], 60
  000de	03 4d c8	 add	 ecx, DWORD PTR __Newvec$[ebp]
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 ??$_Unfancy@UTABLE_RESET@@@std@@YAPAUTABLE_RESET@@PAU1@@Z ; std::_Unfancy<TABLE_RESET>
  000e7	83 c4 04	 add	 esp, 4
  000ea	50		 push	 eax
  000eb	8b 55 e8	 mov	 edx, DWORD PTR __Al$[ebp]
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 ??$construct@UTABLE_RESET@@ABU1@@?$_Default_allocator_traits@V?$allocator@UTABLE_RESET@@@std@@@std@@SAXAAV?$allocator@UTABLE_RESET@@@1@QAUTABLE_RESET@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<TABLE_RESET> >::construct<TABLE_RESET,TABLE_RESET const &>
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  000f7	6b 45 d8 3c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 60
  000fb	03 45 c8	 add	 eax, DWORD PTR __Newvec$[ebp]
  000fe	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00101	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00104	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00107	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00109	75 1a		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  0010b	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0010e	50		 push	 eax
  0010f	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00112	8b 11		 mov	 edx, DWORD PTR [ecx]
  00114	52		 push	 edx
  00115	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00118	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011a	51		 push	 ecx
  0011b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011e	e8 00 00 00 00	 call	 ?_Umove_if_noexcept@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@00@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Umove_if_noexcept

; 754  :         } else { // provide basic guarantee

  00123	eb 3a		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  00125	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00128	50		 push	 eax
  00129	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0012c	51		 push	 ecx
  0012d	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00130	8b 02		 mov	 eax, DWORD PTR [edx]
  00132	50		 push	 eax
  00133	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	e8 00 00 00 00	 call	 ?_Umove@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEPAUTABLE_RESET@@PAU3@00@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Umove

; 756  :             _Constructed_first = _Newvec;

  0013b	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0013e	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00141	6b 45 d8 3c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 60
  00145	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00148	8d 54 01 3c	 lea	 edx, DWORD PTR [ecx+eax+60]
  0014c	52		 push	 edx
  0014d	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	51		 push	 ecx
  00153	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  00156	52		 push	 edx
  00157	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	e8 00 00 00 00	 call	 ?_Umove@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEPAUTABLE_RESET@@PAU3@00@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Umove
$LN5@Emplace_re:
  0015f	eb 2f		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00161	8b 45 c4	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00164	50		 push	 eax
  00165	8b 4d c0	 mov	 ecx, DWORD PTR __Constructed_first$[ebp]
  00168	51		 push	 ecx
  00169	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0016c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@0@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00171	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00174	50		 push	 eax
  00175	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00178	51		 push	 ecx
  00179	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  0017c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTABLE_RESET@@@std@@QAEXQAUTABLE_RESET@@I@Z ; std::allocator<TABLE_RESET>::deallocate

; 762  :         _RERAISE;

  00181	6a 00		 push	 0
  00183	6a 00		 push	 0
  00185	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  0018a	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0018f	c3		 ret	 0
$LN7@Emplace_re:
  00190	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00197	eb 07		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z$1
$LN10@Emplace_re:
  00199	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z$1:

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001a0	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  001a3	50		 push	 eax
  001a4	8b 4d d0	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  001a7	51		 push	 ecx
  001a8	8b 55 c8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  001ab	52		 push	 edx
  001ac	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001af	e8 00 00 00 00	 call	 ?_Change_array@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXQAUTABLE_RESET@@II@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  001b4	6b 45 d8 3c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 60
  001b8	03 45 c8	 add	 eax, DWORD PTR __Newvec$[ebp]
$LN6@Emplace_re:

; 767  :     }

  001bb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001be	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001c5	59		 pop	 ecx
  001c6	5f		 pop	 edi
  001c7	5e		 pop	 esi
  001c8	5b		 pop	 ebx
  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c2 08 00	 ret	 8
  001cf	cc		 int	 3
  001d0	cc		 int	 3
  001d1	cc		 int	 3
  001d2	cc		 int	 3
  001d3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 7c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-132]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Emplace_reallocate<TABLE_RESET const &>
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@UTABLE_RESET@@ABU1@@?$_Default_allocator_traits@V?$allocator@UTABLE_RESET@@@std@@@std@@SAXAAV?$allocator@UTABLE_RESET@@@1@QAUTABLE_RESET@@ABU3@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UTABLE_RESET@@ABU1@@?$_Default_allocator_traits@V?$allocator@UTABLE_RESET@@@std@@@std@@SAXAAV?$allocator@UTABLE_RESET@@@1@QAUTABLE_RESET@@ABU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<TABLE_RESET> >::construct<TABLE_RESET,TABLE_RESET const &>, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	50		 push	 eax
  0000d	6a 3c		 push	 60			; 0000003cH
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00014	83 c4 08	 add	 esp, 8
  00017	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ??$forward@ABUTABLE_RESET@@@std@@YAABUTABLE_RESET@@ABU1@@Z ; std::forward<TABLE_RESET const &>
  00023	83 c4 04	 add	 esp, 4
  00026	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  0002b	8b f0		 mov	 esi, eax
  0002d	8b 7d bc	 mov	 edi, DWORD PTR $T1[ebp]
  00030	f3 a5		 rep movsd

; 695  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$construct@UTABLE_RESET@@ABU1@@?$_Default_allocator_traits@V?$allocator@UTABLE_RESET@@@std@@@std@@SAXAAV?$allocator@UTABLE_RESET@@@1@QAUTABLE_RESET@@ABU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<TABLE_RESET> >::construct<TABLE_RESET,TABLE_RESET const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$_Unfancy@UTABLE_RESET@@@std@@YAPAUTABLE_RESET@@PAU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@UTABLE_RESET@@@std@@YAPAUTABLE_RESET@@PAU1@@Z PROC ; std::_Unfancy<TABLE_RESET>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 289  :     return _Ptr;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Unfancy@UTABLE_RESET@@@std@@YAPAUTABLE_RESET@@PAU1@@Z ENDP ; std::_Unfancy<TABLE_RESET>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAE@ABUTABLE_RESET@@@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAE@ABUTABLE_RESET@@@Z PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Emplace_back_with_unused_capacity<TABLE_RESET const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 686  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$forward@ABUTABLE_RESET@@@std@@YAABUTABLE_RESET@@ABU1@@Z ; std::forward<TABLE_RESET const &>
  00024	83 c4 04	 add	 esp, 4
  00027	50		 push	 eax
  00028	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ??$_Unfancy@UTABLE_RESET@@@std@@YAPAUTABLE_RESET@@PAU1@@Z ; std::_Unfancy<TABLE_RESET>
  00033	83 c4 04	 add	 esp, 4
  00036	50		 push	 eax
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Getal@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UTABLE_RESET@@@2@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Getal
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$construct@UTABLE_RESET@@ABU1@@?$_Default_allocator_traits@V?$allocator@UTABLE_RESET@@@std@@@std@@SAXAAV?$allocator@UTABLE_RESET@@@1@QAUTABLE_RESET@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<TABLE_RESET> >::construct<TABLE_RESET,TABLE_RESET const &>
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 688  :         _Orphan_range(_Mylast, _Mylast);

  00048	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	51		 push	 ecx
  0004e	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	50		 push	 eax
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@ABEXPAUTABLE_RESET@@0@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Orphan_range

; 689  :         _Ty& _Result = *_Mylast;

  0005c	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	89 4d f0	 mov	 DWORD PTR __Result$[ebp], ecx

; 690  :         ++_Mylast;

  00064	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	83 c1 3c	 add	 ecx, 60			; 0000003cH
  0006c	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0006f	89 0a		 mov	 DWORD PTR [edx], ecx

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAE@ABUTABLE_RESET@@@Z ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Emplace_back_with_unused_capacity<TABLE_RESET const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABUTABLE_RESET@@@std@@YAABUTABLE_RESET@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUTABLE_RESET@@@std@@YAABUTABLE_RESET@@ABU1@@Z PROC ; std::forward<TABLE_RESET const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUTABLE_RESET@@@std@@YAABUTABLE_RESET@@ABU1@@Z ENDP ; std::forward<TABLE_RESET const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$emplace_back@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE@ABUTABLE_RESET@@@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE@ABUTABLE_RESET@@@Z PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::emplace_back<TABLE_RESET const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001e	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00021	8b 10		 mov	 edx, DWORD PTR [eax]
  00023	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00026	74 17		 je	 SHORT $LN2@emplace_ba

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00028	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$forward@ABUTABLE_RESET@@@std@@YAABUTABLE_RESET@@ABU1@@Z ; std::forward<TABLE_RESET const &>
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAE@ABUTABLE_RESET@@@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Emplace_back_with_unused_capacity<TABLE_RESET const &>
  0003d	eb 1e		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$forward@ABUTABLE_RESET@@@std@@YAABUTABLE_RESET@@ABU1@@Z ; std::forward<TABLE_RESET const &>
  00048	83 c4 04	 add	 esp, 4
  0004b	50		 push	 eax
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	52		 push	 edx
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEPAUTABLE_RESET@@QAU2@ABU2@@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Emplace_reallocate<TABLE_RESET const &>
  0005a	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
??$emplace_back@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE@ABUTABLE_RESET@@@Z ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::emplace_back<TABLE_RESET const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<REQUIRE_SPECIAL_ITEM>,std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >,1>::_Compressed_pair<std::allocator<REQUIRE_SPECIAL_ITEM>,std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >,1><>, COMDAT
; _this$ = ecx

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAE@XZ ; std::allocator<REQUIRE_SPECIAL_ITEM>::allocator<REQUIRE_SPECIAL_ITEM>
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<REQUIRE_SPECIAL_ITEM>,std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >,1>::_Compressed_pair<std::allocator<REQUIRE_SPECIAL_ITEM>,std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z
_TEXT	SEGMENT
__Constructed_first$ = -64				; size = 4
__Constructed_last$ = -60				; size = 4
__Newvec$ = -56						; size = 4
__Newcapacity$ = -52					; size = 4
__Newsize$ = -48					; size = 4
__Oldsize$ = -44					; size = 4
__Whereoff$ = -40					; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
__My_data$ = -28					; size = 4
__Al$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Emplace_reallocate<REQUIRE_SPECIAL_ITEM const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 70	 sub	 esp, 112		; 00000070H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Getal@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Getal
  00037	89 45 e8	 mov	 DWORD PTR __Al$[ebp], eax

; 728  :         auto& _My_data    = _Mypair._Myval2;

  0003a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00040	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00043	89 45 e0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  00046	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	83 c0 04	 add	 eax, 4
  0004c	89 45 dc	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0004f	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00055	2b 08		 sub	 ecx, DWORD PTR [eax]
  00057	8b c1		 mov	 eax, ecx
  00059	99		 cdq
  0005a	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0005f	f7 f9		 idiv	 ecx
  00061	89 45 d8	 mov	 DWORD PTR __Whereoff$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00064	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00067	8b 4d e0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006a	8b 00		 mov	 eax, DWORD PTR [eax]
  0006c	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006e	99		 cdq
  0006f	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00074	f7 f9		 idiv	 ecx
  00076	89 45 d4	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  00079	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ?max_size@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::max_size
  00081	39 45 d4	 cmp	 DWORD PTR __Oldsize$[ebp], eax
  00084	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  00086	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@CAXXZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0008b	8b 45 d4	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  0008e	83 c0 01	 add	 eax, 1
  00091	89 45 d0	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  00094	8b 45 d0	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	50		 push	 eax
  00098	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@ABEII@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Calculate_growth
  000a0	89 45 cc	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 743  : 
; 744  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

  000a3	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000a6	50		 push	 eax
  000a7	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  000aa	e8 00 00 00 00	 call	 ?allocate@?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@I@Z ; std::allocator<REQUIRE_SPECIAL_ITEM>::allocate
  000af	89 45 c8	 mov	 DWORD PTR __Newvec$[ebp], eax

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000b2	6b 45 d8 1c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 28
  000b6	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000b9	8d 54 01 1c	 lea	 edx, DWORD PTR [ecx+eax+28]
  000bd	89 55 c4	 mov	 DWORD PTR __Constructed_last$[ebp], edx

; 746  :         pointer _Constructed_first      = _Constructed_last;

  000c0	8b 45 c4	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  000c3	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  000c6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000cd	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ??$forward@ABUREQUIRE_SPECIAL_ITEM@@@std@@YAABUREQUIRE_SPECIAL_ITEM@@ABU1@@Z ; std::forward<REQUIRE_SPECIAL_ITEM const &>
  000d6	83 c4 04	 add	 esp, 4
  000d9	50		 push	 eax
  000da	6b 4d d8 1c	 imul	 ecx, DWORD PTR __Whereoff$[ebp], 28
  000de	03 4d c8	 add	 ecx, DWORD PTR __Newvec$[ebp]
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 ??$_Unfancy@UREQUIRE_SPECIAL_ITEM@@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@PAU1@@Z ; std::_Unfancy<REQUIRE_SPECIAL_ITEM>
  000e7	83 c4 04	 add	 esp, 4
  000ea	50		 push	 eax
  000eb	8b 55 e8	 mov	 edx, DWORD PTR __Al$[ebp]
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 ??$construct@UREQUIRE_SPECIAL_ITEM@@ABU1@@?$_Default_allocator_traits@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@SAXAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@1@QAUREQUIRE_SPECIAL_ITEM@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<REQUIRE_SPECIAL_ITEM> >::construct<REQUIRE_SPECIAL_ITEM,REQUIRE_SPECIAL_ITEM const &>
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  000f7	6b 45 d8 1c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 28
  000fb	03 45 c8	 add	 eax, DWORD PTR __Newvec$[ebp]
  000fe	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00101	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00104	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00107	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00109	75 1a		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  0010b	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0010e	50		 push	 eax
  0010f	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00112	8b 11		 mov	 edx, DWORD PTR [ecx]
  00114	52		 push	 edx
  00115	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00118	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011a	51		 push	 ecx
  0011b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011e	e8 00 00 00 00	 call	 ?_Umove_if_noexcept@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@00@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Umove_if_noexcept

; 754  :         } else { // provide basic guarantee

  00123	eb 3a		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  00125	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00128	50		 push	 eax
  00129	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0012c	51		 push	 ecx
  0012d	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00130	8b 02		 mov	 eax, DWORD PTR [edx]
  00132	50		 push	 eax
  00133	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	e8 00 00 00 00	 call	 ?_Umove@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEPAUREQUIRE_SPECIAL_ITEM@@PAU3@00@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Umove

; 756  :             _Constructed_first = _Newvec;

  0013b	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0013e	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00141	6b 45 d8 1c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 28
  00145	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00148	8d 54 01 1c	 lea	 edx, DWORD PTR [ecx+eax+28]
  0014c	52		 push	 edx
  0014d	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	51		 push	 ecx
  00153	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  00156	52		 push	 edx
  00157	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	e8 00 00 00 00	 call	 ?_Umove@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEPAUREQUIRE_SPECIAL_ITEM@@PAU3@00@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Umove
$LN5@Emplace_re:
  0015f	eb 2f		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00161	8b 45 c4	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00164	50		 push	 eax
  00165	8b 4d c0	 mov	 ecx, DWORD PTR __Constructed_first$[ebp]
  00168	51		 push	 ecx
  00169	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0016c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@0@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00171	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00174	50		 push	 eax
  00175	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00178	51		 push	 ecx
  00179	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  0017c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAEXQAUREQUIRE_SPECIAL_ITEM@@I@Z ; std::allocator<REQUIRE_SPECIAL_ITEM>::deallocate

; 762  :         _RERAISE;

  00181	6a 00		 push	 0
  00183	6a 00		 push	 0
  00185	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  0018a	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0018f	c3		 ret	 0
$LN7@Emplace_re:
  00190	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00197	eb 07		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z$1
$LN10@Emplace_re:
  00199	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z$1:

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001a0	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  001a3	50		 push	 eax
  001a4	8b 4d d0	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  001a7	51		 push	 ecx
  001a8	8b 55 c8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  001ab	52		 push	 edx
  001ac	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001af	e8 00 00 00 00	 call	 ?_Change_array@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXQAUREQUIRE_SPECIAL_ITEM@@II@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  001b4	6b 45 d8 1c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 28
  001b8	03 45 c8	 add	 eax, DWORD PTR __Newvec$[ebp]
$LN6@Emplace_re:

; 767  :     }

  001bb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001be	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001c5	59		 pop	 ecx
  001c6	5f		 pop	 edi
  001c7	5e		 pop	 esi
  001c8	5b		 pop	 ebx
  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c2 08 00	 ret	 8
  001cf	cc		 int	 3
  001d0	cc		 int	 3
  001d1	cc		 int	 3
  001d2	cc		 int	 3
  001d3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 7c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-132]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Emplace_reallocate<REQUIRE_SPECIAL_ITEM const &>
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@UREQUIRE_SPECIAL_ITEM@@ABU1@@?$_Default_allocator_traits@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@SAXAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@1@QAUREQUIRE_SPECIAL_ITEM@@ABU3@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UREQUIRE_SPECIAL_ITEM@@ABU1@@?$_Default_allocator_traits@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@SAXAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@1@QAUREQUIRE_SPECIAL_ITEM@@ABU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<REQUIRE_SPECIAL_ITEM> >::construct<REQUIRE_SPECIAL_ITEM,REQUIRE_SPECIAL_ITEM const &>, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	50		 push	 eax
  0000d	6a 1c		 push	 28			; 0000001cH
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00014	83 c4 08	 add	 esp, 8
  00017	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ??$forward@ABUREQUIRE_SPECIAL_ITEM@@@std@@YAABUREQUIRE_SPECIAL_ITEM@@ABU1@@Z ; std::forward<REQUIRE_SPECIAL_ITEM const &>
  00023	83 c4 04	 add	 esp, 4
  00026	b9 07 00 00 00	 mov	 ecx, 7
  0002b	8b f0		 mov	 esi, eax
  0002d	8b 7d bc	 mov	 edi, DWORD PTR $T1[ebp]
  00030	f3 a5		 rep movsd

; 695  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$construct@UREQUIRE_SPECIAL_ITEM@@ABU1@@?$_Default_allocator_traits@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@SAXAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@1@QAUREQUIRE_SPECIAL_ITEM@@ABU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<REQUIRE_SPECIAL_ITEM> >::construct<REQUIRE_SPECIAL_ITEM,REQUIRE_SPECIAL_ITEM const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$_Unfancy@UREQUIRE_SPECIAL_ITEM@@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@PAU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@UREQUIRE_SPECIAL_ITEM@@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@PAU1@@Z PROC ; std::_Unfancy<REQUIRE_SPECIAL_ITEM>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 289  :     return _Ptr;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Unfancy@UREQUIRE_SPECIAL_ITEM@@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@PAU1@@Z ENDP ; std::_Unfancy<REQUIRE_SPECIAL_ITEM>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAE@ABUREQUIRE_SPECIAL_ITEM@@@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAE@ABUREQUIRE_SPECIAL_ITEM@@@Z PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Emplace_back_with_unused_capacity<REQUIRE_SPECIAL_ITEM const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 686  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$forward@ABUREQUIRE_SPECIAL_ITEM@@@std@@YAABUREQUIRE_SPECIAL_ITEM@@ABU1@@Z ; std::forward<REQUIRE_SPECIAL_ITEM const &>
  00024	83 c4 04	 add	 esp, 4
  00027	50		 push	 eax
  00028	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ??$_Unfancy@UREQUIRE_SPECIAL_ITEM@@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@PAU1@@Z ; std::_Unfancy<REQUIRE_SPECIAL_ITEM>
  00033	83 c4 04	 add	 esp, 4
  00036	50		 push	 eax
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Getal@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Getal
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$construct@UREQUIRE_SPECIAL_ITEM@@ABU1@@?$_Default_allocator_traits@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@SAXAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@1@QAUREQUIRE_SPECIAL_ITEM@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<REQUIRE_SPECIAL_ITEM> >::construct<REQUIRE_SPECIAL_ITEM,REQUIRE_SPECIAL_ITEM const &>
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 688  :         _Orphan_range(_Mylast, _Mylast);

  00048	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	51		 push	 ecx
  0004e	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	50		 push	 eax
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@ABEXPAUREQUIRE_SPECIAL_ITEM@@0@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Orphan_range

; 689  :         _Ty& _Result = *_Mylast;

  0005c	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	89 4d f0	 mov	 DWORD PTR __Result$[ebp], ecx

; 690  :         ++_Mylast;

  00064	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0006c	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0006f	89 0a		 mov	 DWORD PTR [edx], ecx

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAE@ABUREQUIRE_SPECIAL_ITEM@@@Z ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Emplace_back_with_unused_capacity<REQUIRE_SPECIAL_ITEM const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABUREQUIRE_SPECIAL_ITEM@@@std@@YAABUREQUIRE_SPECIAL_ITEM@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUREQUIRE_SPECIAL_ITEM@@@std@@YAABUREQUIRE_SPECIAL_ITEM@@ABU1@@Z PROC ; std::forward<REQUIRE_SPECIAL_ITEM const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUREQUIRE_SPECIAL_ITEM@@@std@@YAABUREQUIRE_SPECIAL_ITEM@@ABU1@@Z ENDP ; std::forward<REQUIRE_SPECIAL_ITEM const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$emplace_back@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@ABUREQUIRE_SPECIAL_ITEM@@@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@ABUREQUIRE_SPECIAL_ITEM@@@Z PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::emplace_back<REQUIRE_SPECIAL_ITEM const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001e	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00021	8b 10		 mov	 edx, DWORD PTR [eax]
  00023	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00026	74 17		 je	 SHORT $LN2@emplace_ba

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00028	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$forward@ABUREQUIRE_SPECIAL_ITEM@@@std@@YAABUREQUIRE_SPECIAL_ITEM@@ABU1@@Z ; std::forward<REQUIRE_SPECIAL_ITEM const &>
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAE@ABUREQUIRE_SPECIAL_ITEM@@@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Emplace_back_with_unused_capacity<REQUIRE_SPECIAL_ITEM const &>
  0003d	eb 1e		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$forward@ABUREQUIRE_SPECIAL_ITEM@@@std@@YAABUREQUIRE_SPECIAL_ITEM@@ABU1@@Z ; std::forward<REQUIRE_SPECIAL_ITEM const &>
  00048	83 c4 04	 add	 esp, 4
  0004b	50		 push	 eax
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	52		 push	 edx
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@QAU2@ABU2@@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Emplace_reallocate<REQUIRE_SPECIAL_ITEM const &>
  0005a	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
??$emplace_back@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@ABUREQUIRE_SPECIAL_ITEM@@@Z ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::emplace_back<REQUIRE_SPECIAL_ITEM const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@UBORN_PLACE@@@std@@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@UBORN_PLACE@@@std@@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<BORN_PLACE>,std::_Vector_val<std::_Simple_types<BORN_PLACE> >,1>::_Compressed_pair<std::allocator<BORN_PLACE>,std::_Vector_val<std::_Simple_types<BORN_PLACE> >,1><>, COMDAT
; _this$ = ecx

; 1336 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@UBORN_PLACE@@@std@@QAE@XZ ; std::allocator<BORN_PLACE>::allocator<BORN_PLACE>
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<BORN_PLACE> >::_Vector_val<std::_Simple_types<BORN_PLACE> >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@UBORN_PLACE@@@std@@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<BORN_PLACE>,std::_Vector_val<std::_Simple_types<BORN_PLACE> >,1>::_Compressed_pair<std::allocator<BORN_PLACE>,std::_Vector_val<std::_Simple_types<BORN_PLACE> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z
_TEXT	SEGMENT
__Constructed_first$ = -64				; size = 4
__Constructed_last$ = -60				; size = 4
__Newvec$ = -56						; size = 4
__Newcapacity$ = -52					; size = 4
__Newsize$ = -48					; size = 4
__Oldsize$ = -44					; size = 4
__Whereoff$ = -40					; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
__My_data$ = -28					; size = 4
__Al$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Emplace_reallocate<BORN_PLACE const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 70	 sub	 esp, 112		; 00000070H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();

  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Getal@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEAAV?$allocator@UBORN_PLACE@@@2@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Getal
  00037	89 45 e8	 mov	 DWORD PTR __Al$[ebp], eax

; 728  :         auto& _My_data    = _Mypair._Myval2;

  0003a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00040	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00043	89 45 e0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  00046	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	83 c0 04	 add	 eax, 4
  0004c	89 45 dc	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0004f	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00055	2b 08		 sub	 ecx, DWORD PTR [eax]
  00057	8b c1		 mov	 eax, ecx
  00059	99		 cdq
  0005a	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0005f	f7 f9		 idiv	 ecx
  00061	89 45 d8	 mov	 DWORD PTR __Whereoff$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00064	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00067	8b 4d e0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006a	8b 00		 mov	 eax, DWORD PTR [eax]
  0006c	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006e	99		 cdq
  0006f	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00074	f7 f9		 idiv	 ecx
  00076	89 45 d4	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  00079	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ?max_size@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::max_size
  00081	39 45 d4	 cmp	 DWORD PTR __Oldsize$[ebp], eax
  00084	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  00086	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@CAXXZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0008b	8b 45 d4	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  0008e	83 c0 01	 add	 eax, 1
  00091	89 45 d0	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  00094	8b 45 d0	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	50		 push	 eax
  00098	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@ABEII@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Calculate_growth
  000a0	89 45 cc	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 743  : 
; 744  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

  000a3	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000a6	50		 push	 eax
  000a7	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  000aa	e8 00 00 00 00	 call	 ?allocate@?$allocator@UBORN_PLACE@@@std@@QAEPAUBORN_PLACE@@I@Z ; std::allocator<BORN_PLACE>::allocate
  000af	89 45 c8	 mov	 DWORD PTR __Newvec$[ebp], eax

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000b2	6b 45 d8 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  000b6	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000b9	8d 54 01 0c	 lea	 edx, DWORD PTR [ecx+eax+12]
  000bd	89 55 c4	 mov	 DWORD PTR __Constructed_last$[ebp], edx

; 746  :         pointer _Constructed_first      = _Constructed_last;

  000c0	8b 45 c4	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  000c3	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  000c6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000cd	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ??$forward@ABUBORN_PLACE@@@std@@YAABUBORN_PLACE@@ABU1@@Z ; std::forward<BORN_PLACE const &>
  000d6	83 c4 04	 add	 esp, 4
  000d9	50		 push	 eax
  000da	6b 4d d8 0c	 imul	 ecx, DWORD PTR __Whereoff$[ebp], 12
  000de	03 4d c8	 add	 ecx, DWORD PTR __Newvec$[ebp]
  000e1	51		 push	 ecx
  000e2	e8 00 00 00 00	 call	 ??$_Unfancy@UBORN_PLACE@@@std@@YAPAUBORN_PLACE@@PAU1@@Z ; std::_Unfancy<BORN_PLACE>
  000e7	83 c4 04	 add	 esp, 4
  000ea	50		 push	 eax
  000eb	8b 55 e8	 mov	 edx, DWORD PTR __Al$[ebp]
  000ee	52		 push	 edx
  000ef	e8 00 00 00 00	 call	 ??$construct@UBORN_PLACE@@ABU1@@?$_Default_allocator_traits@V?$allocator@UBORN_PLACE@@@std@@@std@@SAXAAV?$allocator@UBORN_PLACE@@@1@QAUBORN_PLACE@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<BORN_PLACE> >::construct<BORN_PLACE,BORN_PLACE const &>
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  000f7	6b 45 d8 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  000fb	03 45 c8	 add	 eax, DWORD PTR __Newvec$[ebp]
  000fe	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00101	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00104	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00107	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00109	75 1a		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  0010b	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0010e	50		 push	 eax
  0010f	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00112	8b 11		 mov	 edx, DWORD PTR [ecx]
  00114	52		 push	 edx
  00115	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00118	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011a	51		 push	 ecx
  0011b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011e	e8 00 00 00 00	 call	 ?_Umove_if_noexcept@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@00@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Umove_if_noexcept

; 754  :         } else { // provide basic guarantee

  00123	eb 3a		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  00125	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00128	50		 push	 eax
  00129	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0012c	51		 push	 ecx
  0012d	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00130	8b 02		 mov	 eax, DWORD PTR [edx]
  00132	50		 push	 eax
  00133	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	e8 00 00 00 00	 call	 ?_Umove@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEPAUBORN_PLACE@@PAU3@00@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Umove

; 756  :             _Constructed_first = _Newvec;

  0013b	8b 45 c8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0013e	89 45 c0	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00141	6b 45 d8 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  00145	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00148	8d 54 01 0c	 lea	 edx, DWORD PTR [ecx+eax+12]
  0014c	52		 push	 edx
  0014d	8b 45 dc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	51		 push	 ecx
  00153	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  00156	52		 push	 edx
  00157	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	e8 00 00 00 00	 call	 ?_Umove@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEPAUBORN_PLACE@@PAU3@00@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Umove
$LN5@Emplace_re:
  0015f	eb 2f		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00161	8b 45 c4	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00164	50		 push	 eax
  00165	8b 4d c0	 mov	 ecx, DWORD PTR __Constructed_first$[ebp]
  00168	51		 push	 ecx
  00169	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0016c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@0@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00171	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00174	50		 push	 eax
  00175	8b 4d c8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00178	51		 push	 ecx
  00179	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  0017c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UBORN_PLACE@@@std@@QAEXQAUBORN_PLACE@@I@Z ; std::allocator<BORN_PLACE>::deallocate

; 762  :         _RERAISE;

  00181	6a 00		 push	 0
  00183	6a 00		 push	 0
  00185	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  0018a	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0018f	c3		 ret	 0
$LN7@Emplace_re:
  00190	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00197	eb 07		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z$1
$LN10@Emplace_re:
  00199	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z$1:

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001a0	8b 45 cc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  001a3	50		 push	 eax
  001a4	8b 4d d0	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  001a7	51		 push	 ecx
  001a8	8b 55 c8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  001ab	52		 push	 edx
  001ac	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001af	e8 00 00 00 00	 call	 ?_Change_array@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXQAUBORN_PLACE@@II@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  001b4	6b 45 d8 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  001b8	03 45 c8	 add	 eax, DWORD PTR __Newvec$[ebp]
$LN6@Emplace_re:

; 767  :     }

  001bb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001be	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001c5	59		 pop	 ecx
  001c6	5f		 pop	 edi
  001c7	5e		 pop	 esi
  001c8	5b		 pop	 ebx
  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	c2 08 00	 ret	 8
  001cf	cc		 int	 3
  001d0	cc		 int	 3
  001d1	cc		 int	 3
  001d2	cc		 int	 3
  001d3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 7c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-132]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Emplace_reallocate<BORN_PLACE const &>
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$construct@UBORN_PLACE@@ABU1@@?$_Default_allocator_traits@V?$allocator@UBORN_PLACE@@@std@@@std@@SAXAAV?$allocator@UBORN_PLACE@@@1@QAUBORN_PLACE@@ABU3@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UBORN_PLACE@@ABU1@@?$_Default_allocator_traits@V?$allocator@UBORN_PLACE@@@std@@@std@@SAXAAV?$allocator@UBORN_PLACE@@@1@QAUBORN_PLACE@@ABU3@@Z PROC ; std::_Default_allocator_traits<std::allocator<BORN_PLACE> >::construct<BORN_PLACE,BORN_PLACE const &>, COMDAT

; 693  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 694  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	50		 push	 eax
  0000d	6a 0c		 push	 12			; 0000000cH
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00014	83 c4 08	 add	 esp, 8
  00017	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 ??$forward@ABUBORN_PLACE@@@std@@YAABUBORN_PLACE@@ABU1@@Z ; std::forward<BORN_PLACE const &>
  00023	83 c4 04	 add	 esp, 4
  00026	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	89 0a		 mov	 DWORD PTR [edx], ecx
  0002d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00030	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00033	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00036	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 695  :     }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??$construct@UBORN_PLACE@@ABU1@@?$_Default_allocator_traits@V?$allocator@UBORN_PLACE@@@std@@@std@@SAXAAV?$allocator@UBORN_PLACE@@@1@QAUBORN_PLACE@@ABU3@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BORN_PLACE> >::construct<BORN_PLACE,BORN_PLACE const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$_Unfancy@UBORN_PLACE@@@std@@YAPAUBORN_PLACE@@PAU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@UBORN_PLACE@@@std@@YAPAUBORN_PLACE@@PAU1@@Z PROC ; std::_Unfancy<BORN_PLACE>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 289  :     return _Ptr;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Unfancy@UBORN_PLACE@@@std@@YAPAUBORN_PLACE@@PAU1@@Z ENDP ; std::_Unfancy<BORN_PLACE>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAE@ABUBORN_PLACE@@@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAE@ABUBORN_PLACE@@@Z PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Emplace_back_with_unused_capacity<BORN_PLACE const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 686  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$forward@ABUBORN_PLACE@@@std@@YAABUBORN_PLACE@@ABU1@@Z ; std::forward<BORN_PLACE const &>
  00024	83 c4 04	 add	 esp, 4
  00027	50		 push	 eax
  00028	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ??$_Unfancy@UBORN_PLACE@@@std@@YAPAUBORN_PLACE@@PAU1@@Z ; std::_Unfancy<BORN_PLACE>
  00033	83 c4 04	 add	 esp, 4
  00036	50		 push	 eax
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Getal@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEAAV?$allocator@UBORN_PLACE@@@2@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Getal
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$construct@UBORN_PLACE@@ABU1@@?$_Default_allocator_traits@V?$allocator@UBORN_PLACE@@@std@@@std@@SAXAAV?$allocator@UBORN_PLACE@@@1@QAUBORN_PLACE@@ABU3@@Z ; std::_Default_allocator_traits<std::allocator<BORN_PLACE> >::construct<BORN_PLACE,BORN_PLACE const &>
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 688  :         _Orphan_range(_Mylast, _Mylast);

  00048	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	51		 push	 ecx
  0004e	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	50		 push	 eax
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@ABEXPAUBORN_PLACE@@0@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Orphan_range

; 689  :         _Ty& _Result = *_Mylast;

  0005c	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	89 4d f0	 mov	 DWORD PTR __Result$[ebp], ecx

; 690  :         ++_Mylast;

  00064	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0006c	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0006f	89 0a		 mov	 DWORD PTR [edx], ecx

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAE@ABUBORN_PLACE@@@Z ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Emplace_back_with_unused_capacity<BORN_PLACE const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\type_traits
;	COMDAT ??$forward@ABUBORN_PLACE@@@std@@YAABUBORN_PLACE@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUBORN_PLACE@@@std@@YAABUBORN_PLACE@@ABU1@@Z PROC ; std::forward<BORN_PLACE const &>, COMDAT

; 1454 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1455 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1456 : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$forward@ABUBORN_PLACE@@@std@@YAABUBORN_PLACE@@ABU1@@Z ENDP ; std::forward<BORN_PLACE const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??$emplace_back@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE@ABUBORN_PLACE@@@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE@ABUBORN_PLACE@@@Z PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::emplace_back<BORN_PLACE const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001e	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00021	8b 10		 mov	 edx, DWORD PTR [eax]
  00023	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00026	74 17		 je	 SHORT $LN2@emplace_ba

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00028	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$forward@ABUBORN_PLACE@@@std@@YAABUBORN_PLACE@@ABU1@@Z ; std::forward<BORN_PLACE const &>
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAE@ABUBORN_PLACE@@@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Emplace_back_with_unused_capacity<BORN_PLACE const &>
  0003d	eb 1e		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$forward@ABUBORN_PLACE@@@std@@YAABUBORN_PLACE@@ABU1@@Z ; std::forward<BORN_PLACE const &>
  00048	83 c4 04	 add	 esp, 4
  0004b	50		 push	 eax
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	52		 push	 edx
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEPAUBORN_PLACE@@QAU2@ABU2@@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Emplace_reallocate<BORN_PLACE const &>
  0005a	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
??$emplace_back@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE@ABUBORN_PLACE@@@Z ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::emplace_back<BORN_PLACE const &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  :     return __builtin_addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$addressof@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >, COMDAT
; _this$ = ecx

; 750  :     void _Erase_head(_Alnode& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 751  :         this->_Orphan_all();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001c	52		 push	 edx
  0001d	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  00020	50		 push	 eax
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >

; 753  :         _Alnode::value_type::_Freenode0(_Al, _Myhead);

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002e	51		 push	 ecx
  0002f	8b 55 08	 mov	 edx, DWORD PTR __Al$[ebp]
  00032	52		 push	 edx
  00033	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<int const ,NPC_DATA>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
  00038	83 c4 08	 add	 esp, 8

; 754  :     }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$_Find@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@ABH@Z
_TEXT	SEGMENT
__Loc$ = -16						; size = 12
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??$_Find@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Find<int>, COMDAT
; _this$ = ecx

; 1457 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1458 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f0	 lea	 ecx, DWORD PTR __Loc$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Find_lower_bound<int>

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  0001c	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f8	 mov	 ecx, DWORD PTR __Loc$[ebp+8]
  00023	51		 push	 ecx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??$_Lower_bound_duplicate@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Lower_bound_duplicate<int>
  0002c	0f b6 d0	 movzx	 edx, al
  0002f	85 d2		 test	 edx, edx
  00031	74 05		 je	 SHORT $LN2@Find

; 1460 :             return _Loc._Bound;

  00033	8b 45 f8	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  00036	eb 0a		 jmp	 SHORT $LN1@Find
$LN2@Find:

; 1461 :         }
; 1462 : 
; 1463 :         return _Get_scary()->_Myhead;

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
  00040	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Find:

; 1464 :     }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
??$_Find@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Find<int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xutility
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@$$CBHUNPC_DATA@@@std@@@std@@SAPAU?$pair@$$CBHUNPC_DATA@@@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAU?$pair@$$CBHUNPC_DATA@@@std@@@std@@SAPAU?$pair@$$CBHUNPC_DATA@@@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<int const ,NPC_DATA> *>::pointer_to, COMDAT

; 146  :     _NODISCARD static _CONSTEXPR20 pointer pointer_to(_Reftype _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 147  :         return _STD addressof(_Val);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@YAPAU?$pair@$$CBHUNPC_DATA@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,NPC_DATA> >
  00012	83 c4 04	 add	 esp, 4

; 148  :     }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?pointer_to@?$pointer_traits@PAU?$pair@$$CBHUNPC_DATA@@@std@@@std@@SAPAU?$pair@$$CBHUNPC_DATA@@@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<int const ,NPC_DATA> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@1@V21@@Z
_TEXT	SEGMENT
$T2 = -92						; size = 4
$T3 = -88						; size = 4
__Scary$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@1@V21@@Z PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::erase<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >,0>, COMDAT
; _this$ = ecx

; 1413 :     iterator erase(iterator _Where) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@1@V21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1414 :         const auto _Scary = _Get_scary();

  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
  00033	89 45 ec	 mov	 DWORD PTR __Scary$[ebp], eax

; 1415 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1416 :         _STL_VERIFY(_Where._Getcont() == _Scary, "map/set erase iterator from incorrect container");
; 1417 :         _STL_VERIFY(!_Where._Ptr->_Isnil, "cannot erase map/set end() iterator");
; 1418 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1419 :         return iterator(_Erase_unchecked(_Where._Unwrapped()), _Scary);

  00036	8d 45 a4	 lea	 eax, DWORD PTR $T2[ebp]
  00039	50		 push	 eax
  0003a	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::_Unwrapped
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	89 4d a8	 mov	 DWORD PTR $T3[ebp], ecx
  00047	8b 55 ec	 mov	 edx, DWORD PTR __Scary$[ebp]
  0004a	52		 push	 edx
  0004b	8b 45 a8	 mov	 eax, DWORD PTR $T3[ebp]
  0004e	50		 push	 eax
  0004f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Erase_unchecked
  00057	50		 push	 eax
  00058	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0005b	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z
  00060	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1420 :     }

  00063	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00066	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006d	59		 pop	 ecx
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c2 08 00	 ret	 8
  00077	cc		 int	 3
  00078	cc		 int	 3
  00079	cc		 int	 3
  0007a	cc		 int	 3
  0007b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@1@V21@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@1@V21@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@1@V21@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::erase<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >,0>
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::_Unwrapped, COMDAT
; _this$ = ecx

; 304  :     _NODISCARD _Tree_unchecked_iterator<_Mytree> _Unwrapped() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 305  :         return _Tree_unchecked_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ; std::_Iterator_base0::_Getcont
  00014	50		 push	 eax
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	51		 push	 ecx
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z
  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 306  :     }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?_Unwrapped@?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBE?AV?$_Tree_unchecked_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHUNPC_DATA@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHUNPC_DATA@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator->, COMDAT
; _this$ = ecx

; 276  :     _NODISCARD pointer operator->() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHUNPC_DATA@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator*
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?pointer_to@?$pointer_traits@PAU?$pair@$$CBHUNPC_DATA@@@std@@@std@@SAPAU?$pair@$$CBHUNPC_DATA@@@2@AAU32@@Z ; std::pointer_traits<std::pair<int const ,NPC_DATA> *>::pointer_to
  0001a	83 c4 04	 add	 esp, 4

; 278  :     }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHUNPC_DATA@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHUNPC_DATA@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHUNPC_DATA@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator*, COMDAT
; _this$ = ecx

; 272  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 273  :         return const_cast<reference>(_Mybase::operator*());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHUNPC_DATA@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator*

; 274  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBEAAU?$pair@$$CBHUNPC_DATA@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,std::_Iterator_base0>
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator!=, COMDAT
; _this$ = ecx

; 235  :     _NODISCARD bool operator!=(const _Tree_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 236  :         return !(*this == _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator==
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 09		 jne	 SHORT $LN3@operator
  0001f	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00028	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002f	8a 45 b8	 mov	 al, BYTE PTR tv69[ebp]

; 237  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv75 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator==, COMDAT
; _this$ = ecx

; 227  :     _NODISCARD bool operator==(const _Tree_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 228  : #if _ITERATOR_DEBUG_LEVEL == 2
; 229  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");
; 230  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 231  : 
; 232  :         return this->_Ptr == _Right._Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00016	75 09		 jne	 SHORT $LN3@operator
  00018	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  0001f	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00021	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN4@operator:
  00028	8a 45 b8	 mov	 al, BYTE PTR tv75[ebp]

; 233  :     }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHUNPC_DATA@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHUNPC_DATA@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator*, COMDAT
; _this$ = ecx

; 178  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 179  : #if _ITERATOR_DEBUG_LEVEL == 2
; 180  :         const auto _Mycont = static_cast<const _Mytree*>(this->_Getcont());
; 181  :         _STL_ASSERT(_Mycont, "cannot dereference value-initialized map/set iterator");
; 182  :         _STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end map/set iterator");
; 183  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 184  : 
; 185  :         return this->_Ptr->_Myval;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	83 c0 10	 add	 eax, 16			; 00000010H

; 186  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBHUNPC_DATA@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$1 = -8						; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 51   :     _Tree_unchecked_const_iterator& operator++() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00014	0f be 42 0d	 movsx	 eax, BYTE PTR [edx+13]
  00018	85 c0		 test	 eax, eax
  0001a	74 37		 je	 SHORT $LN4@operator
$LN2@operator:

; 53   :             _Nodeptr _Pnode;
; 54   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00024	89 55 f8	 mov	 DWORD PTR __Pnode$1[ebp], edx
  00027	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$1[ebp]
  0002a	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  0002e	85 c9		 test	 ecx, ecx
  00030	75 17		 jne	 SHORT $LN3@operator
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$1[ebp]
  00038	8b 10		 mov	 edx, DWORD PTR [eax]
  0003a	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003d	75 0a		 jne	 SHORT $LN3@operator

; 55   :                 _Ptr = _Pnode; // ==> parent while right subtree

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$1[ebp]
  00045	89 08		 mov	 DWORD PTR [eax], ecx

; 56   :             }

  00047	eb d3		 jmp	 SHORT $LN2@operator
$LN3@operator:

; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())

  00049	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$1[ebp]
  0004f	89 08		 mov	 DWORD PTR [eax], ecx

; 59   :         } else {

  00051	eb 16		 jmp	 SHORT $LN5@operator
$LN4@operator:

; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00053	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Min
  00061	83 c4 04	 add	 esp, 4
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	89 01		 mov	 DWORD PTR [ecx], eax
$LN5@operator:

; 61   :         }
; 62   : 
; 63   :         return *this;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 64   :     }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 40   :         this->_Adopt(_Plist);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Plist$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 41   :     }

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\map
;	COMDAT ??$insert@U?$pair@HUNPC_DATA@@@std@@$0A@@?$map@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@HUNPC_DATA@@@std@@$0A@@?$map@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z PROC ; std::map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >::insert<std::pair<int,NPC_DATA>,0>, COMDAT
; _this$ = ecx

; 164  :     pair<iterator, bool> insert(_Valty&& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 165  :         return this->emplace(_STD forward<_Valty>(_Val));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@U?$pair@HUNPC_DATA@@@std@@@std@@YA$$QAU?$pair@HUNPC_DATA@@@0@AAU10@@Z ; std::forward<std::pair<int,NPC_DATA> >
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$emplace@U?$pair@HUNPC_DATA@@@std@@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::emplace<std::pair<int,NPC_DATA> >
  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 166  :     }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??$insert@U?$pair@HUNPC_DATA@@@std@@$0A@@?$map@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z ENDP ; std::map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >::insert<std::pair<int,NPC_DATA>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$?0HUNPC_DATA@@$0A@@?$pair@$$CBHUNPC_DATA@@@std@@QAE@$$QAU?$pair@HUNPC_DATA@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?0HUNPC_DATA@@$0A@@?$pair@$$CBHUNPC_DATA@@@std@@QAE@$$QAU?$pair@HUNPC_DATA@@@1@@Z PROC ; std::pair<int const ,NPC_DATA>::pair<int const ,NPC_DATA><int,NPC_DATA,0>, COMDAT
; _this$ = ecx

; 248  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00015	83 c4 04	 add	 esp, 4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00022	83 c0 04	 add	 eax, 4
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??$forward@UNPC_DATA@@@std@@YA$$QAUNPC_DATA@@AAU1@@Z ; std::forward<NPC_DATA>
  0002b	83 c4 04	 add	 esp, 4
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	83 c1 04	 add	 ecx, 4
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	89 11		 mov	 DWORD PTR [ecx], edx
  00038	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0003e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00041	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00044	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00047	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  0004a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0004d	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
??$?0HUNPC_DATA@@$0A@@?$pair@$$CBHUNPC_DATA@@@std@@QAE@$$QAU?$pair@HUNPC_DATA@@@1@@Z ENDP ; std::pair<int const ,NPC_DATA>::pair<int const ,NPC_DATA><int,NPC_DATA,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$make_pair@AAHAAUNPC_DATA@@@std@@YA?AU?$pair@HUNPC_DATA@@@0@AAHAAUNPC_DATA@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 4
??$make_pair@AAHAAUNPC_DATA@@@std@@YA?AU?$pair@HUNPC_DATA@@@0@AAHAAUNPC_DATA@@@Z PROC ; std::make_pair<int &,NPC_DATA &>, COMDAT

; 389  :         is_nothrow_constructible_v<_Unrefwrap_t<_Ty2>, _Ty2>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 390  :     // return pair composed from arguments
; 391  :     using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
; 392  :     return _Mypair(_STD forward<_Ty1>(_Val1), _STD forward<_Ty2>(_Val2));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Val2$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$forward@AAUNPC_DATA@@@std@@YAAAUNPC_DATA@@AAU1@@Z ; std::forward<NPC_DATA &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  0001f	83 c4 04	 add	 esp, 4
  00022	50		 push	 eax
  00023	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00026	e8 00 00 00 00	 call	 ??$?0AAHAAUNPC_DATA@@$0A@@?$pair@HUNPC_DATA@@@std@@QAE@AAHAAUNPC_DATA@@@Z ; std::pair<int,NPC_DATA>::pair<int,NPC_DATA><int &,NPC_DATA &,0>
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 393  : }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$make_pair@AAHAAUNPC_DATA@@@std@@YA?AU?$pair@HUNPC_DATA@@@0@AAHAAUNPC_DATA@@@Z ENDP ; std::make_pair<int &,NPC_DATA &>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE@PAUREQUIRE_SPECIAL_ITEM@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE@PAUREQUIRE_SPECIAL_ITEM@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE@PAUREQUIRE_SPECIAL_ITEM@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE@PAUREQUIRE_SPECIAL_ITEM@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator++, COMDAT
; _this$ = ecx

; 264  :     _Vector_iterator operator++(int) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 265  :         _Vector_iterator _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 266  :         _Mybase::operator++();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator++

; 267  :         return _Tmp;

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 268  :     }

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*, COMDAT
; _this$ = ecx

; 251  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 252  :         return const_cast<reference>(_Mybase::operator*());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEABUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*

; 253  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::_Compat, COMDAT
; _this$ = ecx

; 173  :     void _Compat(const _Vector_const_iterator& _Right) const { // test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 174  : #if _ITERATOR_DEBUG_LEVEL == 0
; 175  :         (void) _Right;
; 176  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 177  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 178  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 179  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator!=, COMDAT
; _this$ = ecx

; 152  :     _NODISCARD bool operator!=(const _Vector_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  :         return !(*this == _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator==
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 09		 jne	 SHORT $LN3@operator
  0001f	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00028	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002f	8a 45 b8	 mov	 al, BYTE PTR tv69[ebp]

; 154  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator==, COMDAT
; _this$ = ecx

; 147  :     _NODISCARD bool operator==(const _Vector_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 148  :         _Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::_Compat

; 149  :         return _Ptr == _Right._Ptr;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00022	75 09		 jne	 SHORT $LN3@operator
  00024	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  0002b	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002d	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00034	8a 45 b8	 mov	 al, BYTE PTR tv69[ebp]

; 150  :     }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator++, COMDAT
; _this$ = ecx

; 68   :     _Vector_const_iterator& operator++() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 69   : #if _ITERATOR_DEBUG_LEVEL != 0
; 70   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 71   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 72   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 73   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 74   : 
; 75   :         ++_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 76   :         return *this;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 77   :     }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEABUREQUIRE_SPECIAL_ITEM@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEABUREQUIRE_SPECIAL_ITEM@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*, COMDAT
; _this$ = ecx

; 46   :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 47   : #if _ITERATOR_DEBUG_LEVEL != 0
; 48   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 49   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 50   :         _STL_VERIFY(
; 51   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 52   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 53   : 
; 54   :         return *_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 55   :     }

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEABUREQUIRE_SPECIAL_ITEM@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE@PAUREQUIRE_SPECIAL_ITEM@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE@PAUREQUIRE_SPECIAL_ITEM@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >, COMDAT
; _this$ = ecx

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 43   :         this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 44   :     }

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE@PAUREQUIRE_SPECIAL_ITEM@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAE@PAUBORN_PLACE@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAE@PAUBORN_PLACE@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAE@PAUBORN_PLACE@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAE@PAUBORN_PLACE@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator++, COMDAT
; _this$ = ecx

; 264  :     _Vector_iterator operator++(int) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 265  :         _Vector_iterator _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 266  :         _Mybase::operator++();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator++

; 267  :         return _Tmp;

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 268  :     }

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEAAUBORN_PLACE@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEAAUBORN_PLACE@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator*, COMDAT
; _this$ = ecx

; 251  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 252  :         return const_cast<reference>(_Mybase::operator*());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEABUBORN_PLACE@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator*

; 253  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEAAUBORN_PLACE@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::_Compat, COMDAT
; _this$ = ecx

; 173  :     void _Compat(const _Vector_const_iterator& _Right) const { // test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 174  : #if _ITERATOR_DEBUG_LEVEL == 0
; 175  :         (void) _Right;
; 176  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 177  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 178  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 179  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator!=, COMDAT
; _this$ = ecx

; 152  :     _NODISCARD bool operator!=(const _Vector_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  :         return !(*this == _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator==
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 09		 jne	 SHORT $LN3@operator
  0001f	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00028	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002f	8a 45 b8	 mov	 al, BYTE PTR tv69[ebp]

; 154  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator==, COMDAT
; _this$ = ecx

; 147  :     _NODISCARD bool operator==(const _Vector_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 148  :         _Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::_Compat

; 149  :         return _Ptr == _Right._Ptr;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00022	75 09		 jne	 SHORT $LN3@operator
  00024	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  0002b	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002d	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00034	8a 45 b8	 mov	 al, BYTE PTR tv69[ebp]

; 150  :     }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator++, COMDAT
; _this$ = ecx

; 68   :     _Vector_const_iterator& operator++() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 69   : #if _ITERATOR_DEBUG_LEVEL != 0
; 70   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 71   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 72   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 73   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 74   : 
; 75   :         ++_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 76   :         return *this;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 77   :     }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEABUBORN_PLACE@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEABUBORN_PLACE@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator*, COMDAT
; _this$ = ecx

; 46   :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 47   : #if _ITERATOR_DEBUG_LEVEL != 0
; 48   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 49   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 50   :         _STL_VERIFY(
; 51   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 52   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 53   : 
; 54   :         return *_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 55   :     }

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEABUBORN_PLACE@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAE@PAUBORN_PLACE@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAE@PAUBORN_PLACE@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >, COMDAT
; _this$ = ecx

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 43   :         this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 44   :     }

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAE@PAUBORN_PLACE@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE@PAUNON_TABLE_RESET@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE@PAUNON_TABLE_RESET@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE@PAUNON_TABLE_RESET@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE@PAUNON_TABLE_RESET@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator++, COMDAT
; _this$ = ecx

; 264  :     _Vector_iterator operator++(int) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 265  :         _Vector_iterator _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 266  :         _Mybase::operator++();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator++

; 267  :         return _Tmp;

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 268  :     }

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*, COMDAT
; _this$ = ecx

; 251  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 252  :         return const_cast<reference>(_Mybase::operator*());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEABUNON_TABLE_RESET@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*

; 253  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::_Compat, COMDAT
; _this$ = ecx

; 173  :     void _Compat(const _Vector_const_iterator& _Right) const { // test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 174  : #if _ITERATOR_DEBUG_LEVEL == 0
; 175  :         (void) _Right;
; 176  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 177  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 178  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 179  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator!=, COMDAT
; _this$ = ecx

; 152  :     _NODISCARD bool operator!=(const _Vector_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  :         return !(*this == _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator==
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 09		 jne	 SHORT $LN3@operator
  0001f	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00028	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002f	8a 45 b8	 mov	 al, BYTE PTR tv69[ebp]

; 154  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator==, COMDAT
; _this$ = ecx

; 147  :     _NODISCARD bool operator==(const _Vector_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 148  :         _Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::_Compat

; 149  :         return _Ptr == _Right._Ptr;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00022	75 09		 jne	 SHORT $LN3@operator
  00024	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  0002b	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002d	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00034	8a 45 b8	 mov	 al, BYTE PTR tv69[ebp]

; 150  :     }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator++, COMDAT
; _this$ = ecx

; 68   :     _Vector_const_iterator& operator++() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 69   : #if _ITERATOR_DEBUG_LEVEL != 0
; 70   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 71   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 72   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 73   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 74   : 
; 75   :         ++_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 34	 add	 ecx, 52			; 00000034H
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 76   :         return *this;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 77   :     }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEABUNON_TABLE_RESET@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEABUNON_TABLE_RESET@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*, COMDAT
; _this$ = ecx

; 46   :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 47   : #if _ITERATOR_DEBUG_LEVEL != 0
; 48   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 49   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 50   :         _STL_VERIFY(
; 51   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 52   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 53   : 
; 54   :         return *_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 55   :     }

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEABUNON_TABLE_RESET@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE@PAUNON_TABLE_RESET@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE@PAUNON_TABLE_RESET@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >, COMDAT
; _this$ = ecx

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 43   :         this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 44   :     }

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE@PAUNON_TABLE_RESET@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE@PAUTABLE_RESET@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE@PAUTABLE_RESET@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00013	51		 push	 ecx
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE@PAUTABLE_RESET@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE@PAUTABLE_RESET@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator++, COMDAT
; _this$ = ecx

; 264  :     _Vector_iterator operator++(int) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 265  :         _Vector_iterator _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 266  :         _Mybase::operator++();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator++

; 267  :         return _Tmp;

  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 268  :     }

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*, COMDAT
; _this$ = ecx

; 251  :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 252  :         return const_cast<reference>(_Mybase::operator*());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEABUTABLE_RESET@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*

; 253  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::_Compat, COMDAT
; _this$ = ecx

; 173  :     void _Compat(const _Vector_const_iterator& _Right) const { // test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 174  : #if _ITERATOR_DEBUG_LEVEL == 0
; 175  :         (void) _Right;
; 176  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 177  :         _STL_VERIFY(this->_Getcont() == _Right._Getcont(), "vector iterators incompatible");
; 178  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 179  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator!=, COMDAT
; _this$ = ecx

; 152  :     _NODISCARD bool operator!=(const _Vector_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 153  :         return !(*this == _Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator==
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 09		 jne	 SHORT $LN3@operator
  0001f	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00028	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002f	8a 45 b8	 mov	 al, BYTE PTR tv69[ebp]

; 154  :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator==, COMDAT
; _this$ = ecx

; 147  :     _NODISCARD bool operator==(const _Vector_const_iterator& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 148  :         _Compat(_Right);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::_Compat

; 149  :         return _Ptr == _Right._Ptr;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00022	75 09		 jne	 SHORT $LN3@operator
  00024	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  0002b	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002d	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00034	8a 45 b8	 mov	 al, BYTE PTR tv69[ebp]

; 150  :     }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator++, COMDAT
; _this$ = ecx

; 68   :     _Vector_const_iterator& operator++() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 69   : #if _ITERATOR_DEBUG_LEVEL != 0
; 70   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 71   :         _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
; 72   :         _STL_VERIFY(_Ptr < _Mycont->_Mylast, "can't increment vector iterator past end");
; 73   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 74   : 
; 75   :         ++_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	83 c1 3c	 add	 ecx, 60			; 0000003cH
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 76   :         return *this;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 77   :     }

  0001c	5f		 pop	 edi
  0001d	5e		 pop	 esi
  0001e	5b		 pop	 ebx
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEABUTABLE_RESET@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEABUTABLE_RESET@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*, COMDAT
; _this$ = ecx

; 46   :     _NODISCARD reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 47   : #if _ITERATOR_DEBUG_LEVEL != 0
; 48   :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 49   :         _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
; 50   :         _STL_VERIFY(
; 51   :             _Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast, "can't dereference out of range vector iterator");
; 52   : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 53   : 
; 54   :         return *_Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 55   :     }

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEABUTABLE_RESET@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE@PAUTABLE_RESET@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE@PAUTABLE_RESET@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >, COMDAT
; _this$ = ecx

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 43   :         this->_Adopt(_Pvector);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Pvector$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt

; 44   :     }

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE@PAUTABLE_RESET@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__Fg_ResetSystem@@YAXXZ
text$yd	SEGMENT
??__Fg_ResetSystem@@YAXXZ PROC				; `dynamic atexit destructor for 'g_ResetSystem'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ResetSystem@@3VCResetSystem@@A ; g_ResetSystem
  0000e	e8 00 00 00 00	 call	 ??1CResetSystem@@UAE@XZ	; CResetSystem::~CResetSystem
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Fg_ResetSystem@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_ResetSystem''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ??__Eg_ResetSystem@@YAXXZ
text$di	SEGMENT
??__Eg_ResetSystem@@YAXXZ PROC				; `dynamic initializer for 'g_ResetSystem'', COMDAT

; 40   : CResetSystem g_ResetSystem;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ResetSystem@@3VCResetSystem@@A ; g_ResetSystem
  0000e	e8 00 00 00 00	 call	 ??0CResetSystem@@QAE@XZ	; CResetSystem::CResetSystem
  00013	68 00 00 00 00	 push	 OFFSET ??__Fg_ResetSystem@@YAXXZ ; `dynamic atexit destructor for 'g_ResetSystem''
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??__Eg_ResetSystem@@YAXXZ ENDP				; `dynamic initializer for 'g_ResetSystem''
text$di	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??__FRESET_SYSTEM_LOG@@YAXXZ
text$yd	SEGMENT
??__FRESET_SYSTEM_LOG@@YAXXZ PROC			; `dynamic atexit destructor for 'RESET_SYSTEM_LOG'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?RESET_SYSTEM_LOG@@3VCLogToFile@@A ; RESET_SYSTEM_LOG
  0000e	e8 00 00 00 00	 call	 ??1CLogToFile@@QAE@XZ	; CLogToFile::~CLogToFile
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__FRESET_SYSTEM_LOG@@YAXXZ ENDP			; `dynamic atexit destructor for 'RESET_SYSTEM_LOG''
text$yd	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ??__ERESET_SYSTEM_LOG@@YAXXZ
text$di	SEGMENT
??__ERESET_SYSTEM_LOG@@YAXXZ PROC			; `dynamic initializer for 'RESET_SYSTEM_LOG'', COMDAT

; 38   : CLogToFile RESET_SYSTEM_LOG( "RESET_SYSTEM_LOG", ".\\RESET_BUGTRACER_LOG", 1);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	6a 01		 push	 1
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@PCEAKJNF@?4?2RESET_BUGTRACER_LOG@
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@BFFKLPEJ@RESET_SYSTEM_LOG@
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET ?RESET_SYSTEM_LOG@@3VCLogToFile@@A ; RESET_SYSTEM_LOG
  0001a	e8 00 00 00 00	 call	 ??0CLogToFile@@QAE@QAD0H@Z ; CLogToFile::CLogToFile
  0001f	68 00 00 00 00	 push	 OFFSET ??__FRESET_SYSTEM_LOG@@YAXXZ ; `dynamic atexit destructor for 'RESET_SYSTEM_LOG''
  00024	e8 00 00 00 00	 call	 _atexit
  00029	83 c4 04	 add	 esp, 4
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??__ERESET_SYSTEM_LOG@@YAXXZ ENDP			; `dynamic initializer for 'RESET_SYSTEM_LOG''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ChaosCastle.h
;	COMDAT ??__Eg_iChaosCastle_MonsterItems@@YAXXZ
text$di	SEGMENT
??__Eg_iChaosCastle_MonsterItems@@YAXXZ PROC		; `dynamic initializer for 'g_iChaosCastle_MonsterItems'', COMDAT

; 359  : };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 337  : 	MAKE_ITEMNUM(14, 13),		1,								// 1  - 

  00009	6a 0d		 push	 13			; 0000000dH
  0000b	6a 0e		 push	 14			; 0000000eH
  0000d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00012	83 c4 08	 add	 esp, 8
  00015	a3 00 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA, eax
  0001a	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+4, 1

; 338  : 	MAKE_ITEMNUM(14, 14),		2,								// 1  - 

  00024	6a 0e		 push	 14			; 0000000eH
  00026	6a 0e		 push	 14			; 0000000eH
  00028	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0002d	83 c4 08	 add	 esp, 8
  00030	a3 08 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+8, eax
  00035	c7 05 0c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+12, 2

; 339  : 	
; 340  : 	MAKE_ITEMNUM(14, 13),		1,								// 2  - 

  0003f	6a 0d		 push	 13			; 0000000dH
  00041	6a 0e		 push	 14			; 0000000eH
  00043	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00048	83 c4 08	 add	 esp, 8
  0004b	a3 10 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+16, eax
  00050	c7 05 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+20, 1

; 341  : 	MAKE_ITEMNUM(14, 14),		3,								// 2  - 

  0005a	6a 0e		 push	 14			; 0000000eH
  0005c	6a 0e		 push	 14			; 0000000eH
  0005e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00063	83 c4 08	 add	 esp, 8
  00066	a3 18 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+24, eax
  0006b	c7 05 1c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+28, 3

; 342  : 	
; 343  : 	MAKE_ITEMNUM(14, 13),		1,								// 3  - 

  00075	6a 0d		 push	 13			; 0000000dH
  00077	6a 0e		 push	 14			; 0000000eH
  00079	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0007e	83 c4 08	 add	 esp, 8
  00081	a3 20 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+32, eax
  00086	c7 05 24 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+36, 1

; 344  : 	MAKE_ITEMNUM(14, 14),		3,								// 3  - 

  00090	6a 0e		 push	 14			; 0000000eH
  00092	6a 0e		 push	 14			; 0000000eH
  00094	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00099	83 c4 08	 add	 esp, 8
  0009c	a3 28 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+40, eax
  000a1	c7 05 2c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+44, 3

; 345  : 	
; 346  : 	MAKE_ITEMNUM(14, 13),		2,								// 4  - 

  000ab	6a 0d		 push	 13			; 0000000dH
  000ad	6a 0e		 push	 14			; 0000000eH
  000af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b4	83 c4 08	 add	 esp, 8
  000b7	a3 30 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+48, eax
  000bc	c7 05 34 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+52, 2

; 347  : 	MAKE_ITEMNUM(14, 14),		2,								// 4  - 

  000c6	6a 0e		 push	 14			; 0000000eH
  000c8	6a 0e		 push	 14			; 0000000eH
  000ca	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000cf	83 c4 08	 add	 esp, 8
  000d2	a3 38 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+56, eax
  000d7	c7 05 3c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+60, 2

; 348  : 	
; 349  : 	MAKE_ITEMNUM(14, 13),		2,								// 5  - 

  000e1	6a 0d		 push	 13			; 0000000dH
  000e3	6a 0e		 push	 14			; 0000000eH
  000e5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ea	83 c4 08	 add	 esp, 8
  000ed	a3 40 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+64, eax
  000f2	c7 05 44 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+68, 2

; 350  : 	MAKE_ITEMNUM(14, 14),		3,								// 5  - 

  000fc	6a 0e		 push	 14			; 0000000eH
  000fe	6a 0e		 push	 14			; 0000000eH
  00100	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00105	83 c4 08	 add	 esp, 8
  00108	a3 48 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+72, eax
  0010d	c7 05 4c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+76, 3

; 351  : 	
; 352  : 	MAKE_ITEMNUM(14, 13),		2,								// 6  - 

  00117	6a 0d		 push	 13			; 0000000dH
  00119	6a 0e		 push	 14			; 0000000eH
  0011b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00120	83 c4 08	 add	 esp, 8
  00123	a3 50 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+80, eax
  00128	c7 05 54 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+84, 2

; 353  : 	MAKE_ITEMNUM(14, 14),		3,								// 6  - 

  00132	6a 0e		 push	 14			; 0000000eH
  00134	6a 0e		 push	 14			; 0000000eH
  00136	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0013b	83 c4 08	 add	 esp, 8
  0013e	a3 58 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+88, eax
  00143	c7 05 5c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+92, 3
  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
??__Eg_iChaosCastle_MonsterItems@@YAXXZ ENDP		; `dynamic initializer for 'g_iChaosCastle_MonsterItems''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\include\readscript.h
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
tv93 = -184						; size = 4
$T1 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 26   : 	unsigned char ch;
; 27   : 	TokenString[0] = '\0';

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	6b c8 00	 imul	 ecx, eax, 0
  0001e	89 8d 4c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00024	83 bd 4c ff ff
	ff 64		 cmp	 DWORD PTR $T1[ebp], 100	; 00000064H
  0002b	73 02		 jae	 SHORT $LN31@GetToken
  0002d	eb 05		 jmp	 SHORT $LN32@GetToken
$LN31@GetToken:
  0002f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN32@GetToken:
  00034	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0003a	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?TokenString@@3PADA[edx], 0
$LN4@GetToken:

; 28   : 	do
; 29   : 	{
; 30   : 		if ( (ch =(unsigned char) fgetc(SMDFile)) == (BYTE)EOF) return END;

  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _fgetc
  0004c	83 c4 04	 add	 esp, 4
  0004f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00052	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00056	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0005c	75 0a		 jne	 SHORT $LN15@GetToken
  0005e	b8 02 00 00 00	 mov	 eax, 2
  00063	e9 d9 02 00 00	 jmp	 $LN7@GetToken
$LN15@GetToken:

; 31   : 		if (ch=='/' && (ch =(unsigned char) fgetc(SMDFile) )=='/')	

  00068	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0006c	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0006f	75 56		 jne	 SHORT $LN17@GetToken
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _fgetc
  0007c	83 c4 04	 add	 esp, 4
  0007f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00082	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00086	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00089	75 3c		 jne	 SHORT $LN17@GetToken
$LN5@GetToken:

; 32   : 		{
; 33   : 			while((ch != '\n') && (ch != (BYTE)EOF)) {			// 2003.09.02 H.J.I 

  0008b	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0008f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00092	74 1e		 je	 SHORT $LN6@GetToken
  00094	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00098	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0009d	74 13		 je	 SHORT $LN6@GetToken

; 34   : 				ch = (unsigned char) fgetc( SMDFile);

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _fgetc
  000aa	83 c4 04	 add	 esp, 4
  000ad	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 35   : 			}

  000b0	eb d9		 jmp	 SHORT $LN5@GetToken
$LN6@GetToken:

; 36   : 
; 37   : 			if (ch == (BYTE)EOF)

  000b2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000b6	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000bb	75 0a		 jne	 SHORT $LN17@GetToken

; 38   : 				return END;

  000bd	b8 02 00 00 00	 mov	 eax, 2
  000c2	e9 7a 02 00 00	 jmp	 $LN7@GetToken
$LN17@GetToken:

; 39   : 		}
; 40   : 	} while(  isspace(ch) );

  000c7	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _isspace
  000d1	83 c4 04	 add	 esp, 4
  000d4	85 c0		 test	 eax, eax
  000d6	0f 85 65 ff ff
	ff		 jne	 $LN4@GetToken

; 41   : 	
; 42   : 	char *p, TempString[100];
; 43   : 	switch(ch)

  000dc	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000e0	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], eax
  000e6	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv93[ebp]
  000ec	83 e9 22	 sub	 ecx, 34			; 00000022H
  000ef	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], ecx
  000f5	83 bd 48 ff ff
	ff 5b		 cmp	 DWORD PTR tv93[ebp], 91	; 0000005bH
  000fc	0f 87 86 01 00
	00		 ja	 $LN27@GetToken
  00102	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv93[ebp]
  00108	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN33@GetToken[edx]
  0010f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN34@GetToken[eax*4]
$LN18@GetToken:

; 44   : 	{	
; 45   : 	case '#':
; 46   : 		return CurrentToken = COMMAND;

  00116	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 35 ; 00000023H
  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00125	e9 17 02 00 00	 jmp	 $LN7@GetToken
$LN19@GetToken:

; 47   : 	case ';':
; 48   : 		return CurrentToken = SEMICOLON;

  0012a	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 59 ; 0000003bH
  00134	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00139	e9 03 02 00 00	 jmp	 $LN7@GetToken
$LN20@GetToken:

; 49   : 	case ',':
; 50   : 		return CurrentToken = COMMA;

  0013e	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 44 ; 0000002cH
  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0014d	e9 ef 01 00 00	 jmp	 $LN7@GetToken
$LN21@GetToken:

; 51   : 	case '{':
; 52   : 		return CurrentToken = LP;

  00152	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 123 ; 0000007bH
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00161	e9 db 01 00 00	 jmp	 $LN7@GetToken
$LN22@GetToken:

; 53   : 	case '}':
; 54   : 		return CurrentToken = RP;

  00166	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 125 ; 0000007dH
  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00175	e9 c7 01 00 00	 jmp	 $LN7@GetToken
$LN23@GetToken:

; 55   : 	case '0':	case '1':	case '2':	case '3':	case '4':
; 56   : 	case '5':	case '6':	case '7':	case '8':	case '9':
; 57   : 	case '.':	case '-':
; 58   : 		ungetc(ch,SMDFile);

  0017a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0017f	50		 push	 eax
  00180	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 _ungetc
  0018a	83 c4 08	 add	 esp, 8

; 59   : 		p = TempString;

  0018d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00190	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN9@GetToken:

; 60   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || isdigit(ch) || ch=='-') )

  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _getc
  0019e	83 c4 04	 add	 esp, 4
  001a1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  001a4	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  001a8	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  001ae	74 36		 je	 SHORT $LN10@GetToken
  001b0	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001b4	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001b7	74 1a		 je	 SHORT $LN24@GetToken
  001b9	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001bd	50		 push	 eax
  001be	e8 00 00 00 00	 call	 _isdigit
  001c3	83 c4 04	 add	 esp, 4
  001c6	85 c0		 test	 eax, eax
  001c8	75 09		 jne	 SHORT $LN24@GetToken
  001ca	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001ce	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  001d1	75 13		 jne	 SHORT $LN10@GetToken
$LN24@GetToken:

; 61   : 			*p++ = ch;

  001d3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001d6	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  001d9	88 08		 mov	 BYTE PTR [eax], cl
  001db	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  001de	83 c2 01	 add	 edx, 1
  001e1	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  001e4	eb ad		 jmp	 SHORT $LN9@GetToken
$LN10@GetToken:

; 62   : 		*p = 0;

  001e6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001e9	c6 00 00	 mov	 BYTE PTR [eax], 0

; 63   : 		TokenNumber = (float)atof(TempString);

  001ec	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _atof
  001f5	83 c4 04	 add	 esp, 4
  001f8	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?TokenNumber@@3MA

; 64   : 		//			sscanf(TempString," %f ",&TokenNumber);
; 65   : 		return CurrentToken = NUMBER;

  001fe	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 1
  00208	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0020d	e9 2f 01 00 00	 jmp	 $LN7@GetToken
$LN25@GetToken:

; 66   : 	case '"':
; 67   : 		p = TokenString;

  00212	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA
$LN11@GetToken:

; 68   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch!='"'))// || isalnum(ch)) )

  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _getc
  00224	83 c4 04	 add	 esp, 4
  00227	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0022a	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  0022e	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00234	74 1c		 je	 SHORT $LN12@GetToken
  00236	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0023a	83 f8 22	 cmp	 eax, 34			; 00000022H
  0023d	74 13		 je	 SHORT $LN12@GetToken

; 69   : 			*p++ = ch;

  0023f	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00242	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00245	88 08		 mov	 BYTE PTR [eax], cl
  00247	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  0024a	83 c2 01	 add	 edx, 1
  0024d	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00250	eb c7		 jmp	 SHORT $LN11@GetToken
$LN12@GetToken:

; 70   : 		if (ch!='"')

  00252	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00256	83 f8 22	 cmp	 eax, 34			; 00000022H
  00259	74 13		 je	 SHORT $LN26@GetToken

; 71   : 			ungetc(ch,SMDFile);

  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00260	50		 push	 eax
  00261	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00265	51		 push	 ecx
  00266	e8 00 00 00 00	 call	 _ungetc
  0026b	83 c4 08	 add	 esp, 8
$LN26@GetToken:

; 72   : 		*p = 0;

  0026e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00271	c6 00 00	 mov	 BYTE PTR [eax], 0

; 73   : 		return CurrentToken = NAME;

  00274	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0027e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00283	e9 b9 00 00 00	 jmp	 $LN7@GetToken
$LN27@GetToken:

; 74   : 	default:
; 75   : 		if (isalpha(ch))	

  00288	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0028c	50		 push	 eax
  0028d	e8 00 00 00 00	 call	 _isalpha
  00292	83 c4 04	 add	 esp, 4
  00295	85 c0		 test	 eax, eax
  00297	0f 84 95 00 00
	00		 je	 $LN28@GetToken

; 76   : 		{
; 77   : 			p = TokenString;

  0029d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA

; 78   : 			*p++ = ch;

  002a4	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002a7	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002aa	88 08		 mov	 BYTE PTR [eax], cl
  002ac	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  002af	83 c2 01	 add	 edx, 1
  002b2	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
$LN13@GetToken:

; 79   : 			while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || ch=='_' || isalnum(ch)) )

  002b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  002ba	50		 push	 eax
  002bb	e8 00 00 00 00	 call	 _getc
  002c0	83 c4 04	 add	 esp, 4
  002c3	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  002c6	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  002ca	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  002d0	74 36		 je	 SHORT $LN14@GetToken
  002d2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002d6	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  002d9	74 1a		 je	 SHORT $LN29@GetToken
  002db	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002df	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  002e2	74 11		 je	 SHORT $LN29@GetToken
  002e4	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 _isalnum
  002ee	83 c4 04	 add	 esp, 4
  002f1	85 c0		 test	 eax, eax
  002f3	74 13		 je	 SHORT $LN14@GetToken
$LN29@GetToken:

; 80   : 				*p++ = ch;

  002f5	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002f8	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002fb	88 08		 mov	 BYTE PTR [eax], cl
  002fd	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00300	83 c2 01	 add	 edx, 1
  00303	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00306	eb ad		 jmp	 SHORT $LN13@GetToken
$LN14@GetToken:

; 81   : 			ungetc(ch,SMDFile);

  00308	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0030d	50		 push	 eax
  0030e	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00312	51		 push	 ecx
  00313	e8 00 00 00 00	 call	 _ungetc
  00318	83 c4 08	 add	 esp, 8

; 82   : 			*p = 0;

  0031b	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0031e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 83   : 			return CurrentToken = NAME;

  00321	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0032b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00330	eb 0f		 jmp	 SHORT $LN7@GetToken
$LN28@GetToken:

; 84   : 		}
; 85   : 		return CurrentToken = SMD_ERROR;

  00332	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 60 ; 0000003cH
  0033c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
$LN7@GetToken:

; 86   : 	}
; 87   : }

  00341	5f		 pop	 edi
  00342	5e		 pop	 esi
  00343	5b		 pop	 ebx
  00344	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00347	33 cd		 xor	 ecx, ebp
  00349	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034e	8b e5		 mov	 esp, ebp
  00350	5d		 pop	 ebp
  00351	c3		 ret	 0
  00352	66 90		 npad	 2
$LN34@GetToken:
  00354	00 00 00 00	 DD	 $LN25@GetToken
  00358	00 00 00 00	 DD	 $LN18@GetToken
  0035c	00 00 00 00	 DD	 $LN20@GetToken
  00360	00 00 00 00	 DD	 $LN23@GetToken
  00364	00 00 00 00	 DD	 $LN19@GetToken
  00368	00 00 00 00	 DD	 $LN21@GetToken
  0036c	00 00 00 00	 DD	 $LN22@GetToken
  00370	00 00 00 00	 DD	 $LN27@GetToken
$LN33@GetToken:
  00374	00		 DB	 0
  00375	01		 DB	 1
  00376	07		 DB	 7
  00377	07		 DB	 7
  00378	07		 DB	 7
  00379	07		 DB	 7
  0037a	07		 DB	 7
  0037b	07		 DB	 7
  0037c	07		 DB	 7
  0037d	07		 DB	 7
  0037e	02		 DB	 2
  0037f	03		 DB	 3
  00380	03		 DB	 3
  00381	07		 DB	 7
  00382	03		 DB	 3
  00383	03		 DB	 3
  00384	03		 DB	 3
  00385	03		 DB	 3
  00386	03		 DB	 3
  00387	03		 DB	 3
  00388	03		 DB	 3
  00389	03		 DB	 3
  0038a	03		 DB	 3
  0038b	03		 DB	 3
  0038c	07		 DB	 7
  0038d	04		 DB	 4
  0038e	07		 DB	 7
  0038f	07		 DB	 7
  00390	07		 DB	 7
  00391	07		 DB	 7
  00392	07		 DB	 7
  00393	07		 DB	 7
  00394	07		 DB	 7
  00395	07		 DB	 7
  00396	07		 DB	 7
  00397	07		 DB	 7
  00398	07		 DB	 7
  00399	07		 DB	 7
  0039a	07		 DB	 7
  0039b	07		 DB	 7
  0039c	07		 DB	 7
  0039d	07		 DB	 7
  0039e	07		 DB	 7
  0039f	07		 DB	 7
  003a0	07		 DB	 7
  003a1	07		 DB	 7
  003a2	07		 DB	 7
  003a3	07		 DB	 7
  003a4	07		 DB	 7
  003a5	07		 DB	 7
  003a6	07		 DB	 7
  003a7	07		 DB	 7
  003a8	07		 DB	 7
  003a9	07		 DB	 7
  003aa	07		 DB	 7
  003ab	07		 DB	 7
  003ac	07		 DB	 7
  003ad	07		 DB	 7
  003ae	07		 DB	 7
  003af	07		 DB	 7
  003b0	07		 DB	 7
  003b1	07		 DB	 7
  003b2	07		 DB	 7
  003b3	07		 DB	 7
  003b4	07		 DB	 7
  003b5	07		 DB	 7
  003b6	07		 DB	 7
  003b7	07		 DB	 7
  003b8	07		 DB	 7
  003b9	07		 DB	 7
  003ba	07		 DB	 7
  003bb	07		 DB	 7
  003bc	07		 DB	 7
  003bd	07		 DB	 7
  003be	07		 DB	 7
  003bf	07		 DB	 7
  003c0	07		 DB	 7
  003c1	07		 DB	 7
  003c2	07		 DB	 7
  003c3	07		 DB	 7
  003c4	07		 DB	 7
  003c5	07		 DB	 7
  003c6	07		 DB	 7
  003c7	07		 DB	 7
  003c8	07		 DB	 7
  003c9	07		 DB	 7
  003ca	07		 DB	 7
  003cb	07		 DB	 7
  003cc	07		 DB	 7
  003cd	05		 DB	 5
  003ce	07		 DB	 7
  003cf	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Ptr_container$ = -8					; size = 4
__Block_size$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000c	83 c0 23	 add	 eax, 35			; 00000023H
  0000f	89 45 fc	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  00012	8b 45 fc	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00015	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00018	77 05		 ja	 SHORT $LN8@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  0001a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0001f	8b 45 fc	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002e	83 7d f8 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  00032	74 02		 je	 SHORT $LN7@Allocate_m
  00034	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00036	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0003b	33 c0		 xor	 eax, eax
  0003d	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  0003f	33 c0		 xor	 eax, eax
  00041	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00043	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00046	83 c0 23	 add	 eax, 35			; 00000023H
  00049	83 e0 e0	 and	 eax, -32		; ffffffe0H
  0004c	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0004f	b8 04 00 00 00	 mov	 eax, 4
  00054	6b c8 ff	 imul	 ecx, eax, -1
  00057	8b 55 f4	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  0005d	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00060	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00009	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00010	72 0e		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00012	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0001b	83 c4 04	 add	 esp, 4
  0001e	eb 16		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00020	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00024	74 0e		 je	 SHORT $LN3@Allocate

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0002f	83 c4 04	 add	 esp, 4
  00032	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00034	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00028	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0002f	72 10		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  00031	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  00034	50		 push	 eax
  00035	8d 4d 08	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0003e	83 c4 08	 add	 esp, 8
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00041	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00044	50		 push	 eax
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004e	83 c4 08	 add	 esp, 8

; 222  : }

  00051	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00054	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005b	59		 pop	 ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
  00063	cc		 int	 3
  00064	cc		 int	 3
  00065	cc		 int	 3
  00066	cc		 int	 3
  00067	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -72						; size = 4
$T1 = -68						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 67   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 68   :     // return smaller of _Left and _Right
; 69   :     return _Right < _Left ? _Right : _Left;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00013	73 08		 jae	 SHORT $LN3@min
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00018	89 45 b8	 mov	 DWORD PTR tv65[ebp], eax
  0001b	eb 06		 jmp	 SHORT $LN4@min
$LN3@min:
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00020	89 4d b8	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@min:
  00023	8b 55 b8	 mov	 edx, DWORD PTR tv65[ebp]
  00026	89 55 bc	 mov	 DWORD PTR $T1[ebp], edx
  00029	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]

; 70   : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCResetSystem@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCResetSystem@@UAEPAXI@Z PROC			; CResetSystem::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CResetSystem@@UAE@XZ	; CResetSystem::~CResetSystem
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 11		 je	 SHORT $LN2@scalar
  0001c	68 84 00 00 00	 push	 132			; 00000084H
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??_GCResetSystem@@UAEPAXI@Z ENDP			; CResetSystem::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$map@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >::~map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::~_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$map@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >::~map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\map
;	COMDAT ??0?$map@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -69						; size = 1
_this$ = -4						; size = 4
??0?$map@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >::map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >, COMDAT
; _this$ = ecx

; 107  :     map() : _Mybase(key_compare()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 bb	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??0?$map@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >::map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1348 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1349 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1348 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1349 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1344 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1345 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Orphan_ptr, COMDAT
; _this$ = ecx

; 713  :     void _Orphan_ptr(const _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 714  : #if _ITERATOR_DEBUG_LEVEL == 2
; 715  :         _Lockit _Lock(_LOCK_DEBUG);
; 716  :         _Iterator_base12** _Pnext = &this->_Myproxy->_Myfirstiter;
; 717  :         while (*_Pnext) {
; 718  :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 719  :             if (_Pnextptr == _Myhead || (_Ptr != nullptr && _Pnextptr != _Ptr)) {
; 720  :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 721  :             } else { // orphan the iterator
; 722  :                 (*_Pnext)->_Myproxy = nullptr;
; 723  :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 724  :             }
; 725  :         }
; 726  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 727  :         (void) _Ptr;
; 728  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 729  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Orphan_ptr
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Parent_sibling$1 = -20				; size = 4
__Parent_sibling$2 = -16				; size = 4
__Pnode$3 = -12						; size = 4
__Head$ = -8						; size = 4
_this$ = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 645  :         ++_Mysize;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	83 c1 01	 add	 ecx, 1
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 646  :         const auto _Head  = _Myhead;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00020	89 4d f8	 mov	 DWORD PTR __Head$[ebp], ecx

; 647  :         _Newnode->_Parent = _Loc._Parent;

  00023	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00029	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  0002c	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  0002f	3b 45 f8	 cmp	 eax, DWORD PTR __Head$[ebp]
  00032	75 29		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  00034	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00037	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0003a	89 08		 mov	 DWORD PTR [eax], ecx

; 650  :             _Head->_Parent   = _Newnode;

  0003c	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0003f	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00042	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 651  :             _Head->_Right    = _Newnode;

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00048	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0004b	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 652  :             _Newnode->_Color = _Black; // the root is black

  0004e	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00051	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 653  :             return _Newnode;

  00055	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00058	e9 a7 01 00 00	 jmp	 $LN18@Insert_nod
$LN5@Insert_nod:

; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  0005d	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  00061	75 1f		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  00063	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00066	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00069	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  0006c	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00072	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00075	75 09		 jne	 SHORT $LN8@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00077	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0007a	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0007d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN8@Insert_nod:

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  00080	eb 1a		 jmp	 SHORT $LN7@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  00082	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00085	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00088	89 08		 mov	 DWORD PTR [eax], ecx

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  0008a	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00090	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00092	75 08		 jne	 SHORT $LN7@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  00094	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00097	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0009a	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  0009c	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0009f	89 45 f4	 mov	 DWORD PTR __Pnode$3[ebp], eax
$LN4@Insert_nod:
  000a2	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000a5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a8	0f be 51 0c	 movsx	 edx, BYTE PTR [ecx+12]
  000ac	85 d2		 test	 edx, edx
  000ae	0f 85 43 01 00
	00		 jne	 $LN3@Insert_nod

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  000b4	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000b7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ba	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000bd	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c3	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  000c5	0f 85 97 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  000cb	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000ce	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000d1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d4	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000d7	89 45 f0	 mov	 DWORD PTR __Parent_sibling$2[ebp], eax

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  000da	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000dd	0f be 48 0c	 movsx	 ecx, BYTE PTR [eax+12]
  000e1	85 c9		 test	 ecx, ecx
  000e3	75 2c		 jne	 SHORT $LN12@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;

  000e5	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000e8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000eb	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 676  :                     _Parent_sibling->_Color          = _Black;

  000ef	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000f2	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000f6	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000f9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fc	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ff	c6 42 0c 00	 mov	 BYTE PTR [edx+12], 0

; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  00103	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00106	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00109	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0010c	89 55 f4	 mov	 DWORD PTR __Pnode$3[ebp], edx

; 679  :                 } else { // parent's sibling has red and black children

  0010f	eb 4c		 jmp	 SHORT $LN13@Insert_nod
$LN12@Insert_nod:

; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  00111	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00114	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00117	8b 55 f4	 mov	 edx, DWORD PTR __Pnode$3[ebp]
  0011a	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0011d	75 15		 jne	 SHORT $LN14@Insert_nod

; 681  :                         _Pnode = _Pnode->_Parent;

  0011f	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00122	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00125	89 4d f4	 mov	 DWORD PTR __Pnode$3[ebp], ecx

; 682  :                         _Lrotate(_Pnode);

  00128	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0012b	50		 push	 eax
  0012c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Lrotate
$LN14@Insert_nod:

; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  00134	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00137	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013a	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  0013e	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00141	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00144	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00147	c6 42 0c 00	 mov	 BYTE PTR [edx+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  0014b	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0014e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00151	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00154	52		 push	 edx
  00155	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00158	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Rrotate
$LN13@Insert_nod:

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  0015d	e9 90 00 00 00	 jmp	 $LN11@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;

  00162	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00165	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00168	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0016b	8b 02		 mov	 eax, DWORD PTR [edx]
  0016d	89 45 ec	 mov	 DWORD PTR __Parent_sibling$1[ebp], eax

; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00170	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  00173	0f be 48 0c	 movsx	 ecx, BYTE PTR [eax+12]
  00177	85 c9		 test	 ecx, ecx
  00179	75 2c		 jne	 SHORT $LN15@Insert_nod

; 692  :                     _Pnode->_Parent->_Color          = _Black;

  0017b	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0017e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00181	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 693  :                     _Parent_sibling->_Color          = _Black;

  00185	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  00188	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  0018c	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0018f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00192	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00195	c6 42 0c 00	 mov	 BYTE PTR [edx+12], 0

; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  00199	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0019c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0019f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001a2	89 55 f4	 mov	 DWORD PTR __Pnode$3[ebp], edx

; 696  :                 } else { // parent's sibling has red and black children

  001a5	eb 4b		 jmp	 SHORT $LN11@Insert_nod
$LN15@Insert_nod:

; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  001a7	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001aa	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001ad	8b 55 f4	 mov	 edx, DWORD PTR __Pnode$3[ebp]
  001b0	3b 11		 cmp	 edx, DWORD PTR [ecx]
  001b2	75 15		 jne	 SHORT $LN17@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  001b4	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001b7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001ba	89 4d f4	 mov	 DWORD PTR __Pnode$3[ebp], ecx

; 699  :                         _Rrotate(_Pnode);

  001bd	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001c0	50		 push	 eax
  001c1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001c4	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Rrotate
$LN17@Insert_nod:

; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  001c9	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001cc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001cf	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  001d3	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001d6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001d9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001dc	c6 42 0c 00	 mov	 BYTE PTR [edx+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001e0	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001e3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001e6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001e9	52		 push	 edx
  001ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ed	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Lrotate
$LN11@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }

  001f2	e9 ab fe ff ff	 jmp	 $LN4@Insert_nod
$LN3@Insert_nod:

; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001f7	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  001fa	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001fd	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 710  :         return _Newnode;

  00201	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
$LN18@Insert_nod:

; 711  :     }

  00204	5f		 pop	 edi
  00205	5e		 pop	 esi
  00206	5b		 pop	 ebx
  00207	8b e5		 mov	 esp, ebp
  00209	5d		 pop	 ebp
  0020a	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
tv144 = -100						; size = 4
tv133 = -100						; size = 4
__Pnode$ = -32						; size = 4
__Fixnodeparent$ = -28					; size = 4
__Fixnode$ = -24					; size = 4
__Erasednode$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Where$ = 8						; size = 4
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Extract, COMDAT
; _this$ = ecx

; 502  :     _Nodeptr _Extract(_Unchecked_const_iterator _Where) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 503  :         _Nodeptr _Erasednode = _Where._Ptr; // node to erase

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __Erasednode$[ebp], eax

; 504  :         ++_Where; // save successor iterator for return

  00031	8d 4d 08	 lea	 ecx, DWORD PTR __Where$[ebp]
  00034	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,std::_Iterator_base0>::operator++

; 505  : 
; 506  :         _Nodeptr _Fixnode; // the node to recolor as needed
; 507  :         _Nodeptr _Fixnodeparent; // parent of _Fixnode (which may be nil)
; 508  :         _Nodeptr _Pnode = _Erasednode;

  00039	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0003c	89 45 e0	 mov	 DWORD PTR __Pnode$[ebp], eax

; 509  : 
; 510  :         if (_Pnode->_Left->_Isnil) {

  0003f	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00042	8b 08		 mov	 ecx, DWORD PTR [eax]
  00044	0f be 51 0d	 movsx	 edx, BYTE PTR [ecx+13]
  00048	85 d2		 test	 edx, edx
  0004a	74 0b		 je	 SHORT $LN5@Extract

; 511  :             _Fixnode = _Pnode->_Right; // stitch up right subtree

  0004c	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0004f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00052	89 4d e8	 mov	 DWORD PTR __Fixnode$[ebp], ecx
  00055	eb 27		 jmp	 SHORT $LN6@Extract
$LN5@Extract:

; 512  :         } else if (_Pnode->_Right->_Isnil) {

  00057	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005d	0f be 51 0d	 movsx	 edx, BYTE PTR [ecx+13]
  00061	85 d2		 test	 edx, edx
  00063	74 0a		 je	 SHORT $LN7@Extract

; 513  :             _Fixnode = _Pnode->_Left; // stitch up left subtree

  00065	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00068	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006a	89 4d e8	 mov	 DWORD PTR __Fixnode$[ebp], ecx

; 514  :         } else { // two subtrees, must lift successor node to replace erased

  0006d	eb 0f		 jmp	 SHORT $LN6@Extract
$LN7@Extract:

; 515  :             _Pnode   = _Where._Ptr; // _Pnode is successor node

  0006f	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00072	89 45 e0	 mov	 DWORD PTR __Pnode$[ebp], eax

; 516  :             _Fixnode = _Pnode->_Right; // _Fixnode is only subtree

  00075	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00078	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0007b	89 4d e8	 mov	 DWORD PTR __Fixnode$[ebp], ecx
$LN6@Extract:

; 517  :         }
; 518  : 
; 519  :         if (_Pnode == _Erasednode) { // at most one subtree, relink it

  0007e	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00081	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00084	0f 85 cb 00 00
	00		 jne	 $LN9@Extract

; 520  :             _Fixnodeparent = _Erasednode->_Parent;

  0008a	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0008d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00090	89 4d e4	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 521  :             if (!_Fixnode->_Isnil) {

  00093	8b 45 e8	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00096	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  0009a	85 c9		 test	 ecx, ecx
  0009c	75 09		 jne	 SHORT $LN11@Extract

; 522  :                 _Fixnode->_Parent = _Fixnodeparent; // link up

  0009e	8b 45 e8	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000a1	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  000a4	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN11@Extract:

; 523  :             }
; 524  : 
; 525  :             if (_Myhead->_Parent == _Erasednode) {

  000a7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ac	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000af	3b 55 ec	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  000b2	75 0d		 jne	 SHORT $LN12@Extract

; 526  :                 _Myhead->_Parent = _Fixnode; // link down from root

  000b4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	8b 55 e8	 mov	 edx, DWORD PTR __Fixnode$[ebp]
  000bc	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000bf	eb 1d		 jmp	 SHORT $LN13@Extract
$LN12@Extract:

; 527  :             } else if (_Fixnodeparent->_Left == _Erasednode) {

  000c1	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  000c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c6	3b 4d ec	 cmp	 ecx, DWORD PTR __Erasednode$[ebp]
  000c9	75 0a		 jne	 SHORT $LN14@Extract

; 528  :                 _Fixnodeparent->_Left = _Fixnode; // link down to left

  000cb	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  000ce	8b 4d e8	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  000d1	89 08		 mov	 DWORD PTR [eax], ecx

; 529  :             } else {

  000d3	eb 09		 jmp	 SHORT $LN13@Extract
$LN14@Extract:

; 530  :                 _Fixnodeparent->_Right = _Fixnode; // link down to right

  000d5	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  000d8	8b 4d e8	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  000db	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN13@Extract:

; 531  :             }
; 532  : 
; 533  :             if (_Myhead->_Left == _Erasednode) {

  000de	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e5	3b 55 ec	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  000e8	75 2c		 jne	 SHORT $LN16@Extract

; 534  :                 _Myhead->_Left = _Fixnode->_Isnil ? _Fixnodeparent // smallest is parent of erased node

  000ea	8b 45 e8	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000ed	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  000f1	85 c9		 test	 ecx, ecx
  000f3	74 08		 je	 SHORT $LN42@Extract
  000f5	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  000f8	89 55 9c	 mov	 DWORD PTR tv133[ebp], edx
  000fb	eb 0f		 jmp	 SHORT $LN43@Extract
$LN42@Extract:
  000fd	8b 45 e8	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00100	50		 push	 eax
  00101	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Min
  00106	83 c4 04	 add	 esp, 4
  00109	89 45 9c	 mov	 DWORD PTR tv133[ebp], eax
$LN43@Extract:
  0010c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00111	8b 45 9c	 mov	 eax, DWORD PTR tv133[ebp]
  00114	89 02		 mov	 DWORD PTR [edx], eax
$LN16@Extract:

; 535  :                                                   : _Min(_Fixnode); // smallest in relinked subtree
; 536  :             }
; 537  : 
; 538  :             if (_Myhead->_Right == _Erasednode) {

  00116	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00119	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0011e	3b 55 ec	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  00121	75 2d		 jne	 SHORT $LN17@Extract

; 539  :                 _Myhead->_Right = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

  00123	8b 45 e8	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00126	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  0012a	85 c9		 test	 ecx, ecx
  0012c	74 08		 je	 SHORT $LN44@Extract
  0012e	8b 55 e4	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  00131	89 55 9c	 mov	 DWORD PTR tv144[ebp], edx
  00134	eb 0f		 jmp	 SHORT $LN45@Extract
$LN44@Extract:
  00136	8b 45 e8	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Max
  0013f	83 c4 04	 add	 esp, 4
  00142	89 45 9c	 mov	 DWORD PTR tv144[ebp], eax
$LN45@Extract:
  00145	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00148	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014a	8b 45 9c	 mov	 eax, DWORD PTR tv144[ebp]
  0014d	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN17@Extract:

; 540  :                                                    : _Max(_Fixnode); // largest in relinked subtree
; 541  :             }
; 542  :         } else { // erased has two subtrees, _Pnode is successor to erased

  00150	e9 c7 00 00 00	 jmp	 $LN10@Extract
$LN9@Extract:

; 543  :             _Erasednode->_Left->_Parent = _Pnode; // link left up

  00155	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00158	8b 08		 mov	 ecx, DWORD PTR [eax]
  0015a	8b 55 e0	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0015d	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 544  :             _Pnode->_Left               = _Erasednode->_Left; // link successor down

  00160	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00163	8b 4d ec	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  00166	8b 11		 mov	 edx, DWORD PTR [ecx]
  00168	89 10		 mov	 DWORD PTR [eax], edx

; 545  : 
; 546  :             if (_Pnode == _Erasednode->_Right) {

  0016a	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0016d	8b 4d e0	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00170	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00173	75 08		 jne	 SHORT $LN18@Extract

; 547  :                 _Fixnodeparent = _Pnode; // successor is next to erased

  00175	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00178	89 45 e4	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax

; 548  :             } else { // successor further down, link in place of erased

  0017b	eb 3d		 jmp	 SHORT $LN19@Extract
$LN18@Extract:

; 549  :                 _Fixnodeparent = _Pnode->_Parent; // parent is successor's

  0017d	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00180	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00183	89 4d e4	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 550  :                 if (!_Fixnode->_Isnil) {

  00186	8b 45 e8	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00189	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  0018d	85 c9		 test	 ecx, ecx
  0018f	75 09		 jne	 SHORT $LN20@Extract

; 551  :                     _Fixnode->_Parent = _Fixnodeparent; // link fix up

  00191	8b 45 e8	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00194	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00197	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN20@Extract:

; 552  :                 }
; 553  : 
; 554  :                 _Fixnodeparent->_Left        = _Fixnode; // link fix down

  0019a	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0019d	8b 4d e8	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  001a0	89 08		 mov	 DWORD PTR [eax], ecx

; 555  :                 _Pnode->_Right               = _Erasednode->_Right; // link next down

  001a2	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  001a5	8b 4d ec	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  001a8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001ab	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 556  :                 _Erasednode->_Right->_Parent = _Pnode; // right up

  001ae	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001b1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001b4	8b 55 e0	 mov	 edx, DWORD PTR __Pnode$[ebp]
  001b7	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN19@Extract:

; 557  :             }
; 558  : 
; 559  :             if (_Myhead->_Parent == _Erasednode) {

  001ba	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  001bf	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001c2	3b 55 ec	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  001c5	75 0d		 jne	 SHORT $LN21@Extract

; 560  :                 _Myhead->_Parent = _Pnode; // link down from root

  001c7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  001cc	8b 55 e0	 mov	 edx, DWORD PTR __Pnode$[ebp]
  001cf	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  001d2	eb 26		 jmp	 SHORT $LN22@Extract
$LN21@Extract:

; 561  :             } else if (_Erasednode->_Parent->_Left == _Erasednode) {

  001d4	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001d7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001da	8b 11		 mov	 edx, DWORD PTR [ecx]
  001dc	3b 55 ec	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  001df	75 0d		 jne	 SHORT $LN23@Extract

; 562  :                 _Erasednode->_Parent->_Left = _Pnode; // link down to left

  001e1	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001e4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001e7	8b 55 e0	 mov	 edx, DWORD PTR __Pnode$[ebp]
  001ea	89 11		 mov	 DWORD PTR [ecx], edx

; 563  :             } else {

  001ec	eb 0c		 jmp	 SHORT $LN22@Extract
$LN23@Extract:

; 564  :                 _Erasednode->_Parent->_Right = _Pnode; // link down to right

  001ee	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001f1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001f4	8b 55 e0	 mov	 edx, DWORD PTR __Pnode$[ebp]
  001f7	89 51 08	 mov	 DWORD PTR [ecx+8], edx
$LN22@Extract:

; 565  :             }
; 566  : 
; 567  :             _Pnode->_Parent = _Erasednode->_Parent; // link successor up

  001fa	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  001fd	8b 4d ec	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  00200	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00203	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 568  :             _STD swap(_Pnode->_Color, _Erasednode->_Color); // recolor it

  00206	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00209	83 c0 0c	 add	 eax, 12			; 0000000cH
  0020c	50		 push	 eax
  0020d	8b 4d e0	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00210	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00213	51		 push	 ecx
  00214	e8 00 00 00 00	 call	 ??$swap@D$0A@@std@@YAXAAD0@Z ; std::swap<char,0>
  00219	83 c4 08	 add	 esp, 8
$LN10@Extract:

; 569  :         }
; 570  : 
; 571  :         if (_Erasednode->_Color == _Black) { // erasing black link, must recolor/rebalance tree

  0021c	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0021f	0f be 48 0c	 movsx	 ecx, BYTE PTR [eax+12]
  00223	83 f9 01	 cmp	 ecx, 1
  00226	0f 85 fa 01 00
	00		 jne	 $LN25@Extract

; 572  :             for (; _Fixnode != _Myhead->_Parent && _Fixnode->_Color == _Black; _Fixnodeparent = _Fixnode->_Parent) {

  0022c	eb 09		 jmp	 SHORT $LN4@Extract
$LN2@Extract:
  0022e	8b 45 e8	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00231	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00234	89 4d e4	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx
$LN4@Extract:
  00237	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0023a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023c	8b 55 e8	 mov	 edx, DWORD PTR __Fixnode$[ebp]
  0023f	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00242	0f 84 d7 01 00
	00		 je	 $LN3@Extract
  00248	8b 45 e8	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0024b	0f be 48 0c	 movsx	 ecx, BYTE PTR [eax+12]
  0024f	83 f9 01	 cmp	 ecx, 1
  00252	0f 85 c7 01 00
	00		 jne	 $LN3@Extract

; 573  :                 if (_Fixnode == _Fixnodeparent->_Left) { // fixup left subtree

  00258	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0025b	8b 4d e8	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  0025e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00260	0f 85 e0 00 00
	00		 jne	 $LN26@Extract

; 574  :                     _Pnode = _Fixnodeparent->_Right;

  00266	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00269	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0026c	89 4d e0	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 575  :                     if (_Pnode->_Color == _Red) { // rotate red up from right subtree

  0026f	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00272	0f be 48 0c	 movsx	 ecx, BYTE PTR [eax+12]
  00276	85 c9		 test	 ecx, ecx
  00278	75 23		 jne	 SHORT $LN28@Extract

; 576  :                         _Pnode->_Color         = _Black;

  0027a	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0027d	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 577  :                         _Fixnodeparent->_Color = _Red;

  00281	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00284	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 578  :                         _Lrotate(_Fixnodeparent);

  00288	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0028b	50		 push	 eax
  0028c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0028f	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Lrotate

; 579  :                         _Pnode = _Fixnodeparent->_Right;

  00294	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00297	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0029a	89 4d e0	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN28@Extract:

; 580  :                     }
; 581  : 
; 582  :                     if (_Pnode->_Isnil) {

  0029d	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002a0	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  002a4	85 c9		 test	 ecx, ecx
  002a6	74 0b		 je	 SHORT $LN29@Extract

; 583  :                         _Fixnode = _Fixnodeparent; // shouldn't happen

  002a8	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  002ab	89 45 e8	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 584  :                     } else if (_Pnode->_Left->_Color == _Black

  002ae	e9 8e 00 00 00	 jmp	 $LN30@Extract
$LN29@Extract:

; 585  :                                && _Pnode->_Right->_Color == _Black) { // redden right subtree with black children

  002b3	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  002b8	0f be 51 0c	 movsx	 edx, BYTE PTR [ecx+12]
  002bc	83 fa 01	 cmp	 edx, 1
  002bf	75 1e		 jne	 SHORT $LN31@Extract
  002c1	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002c4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002c7	0f be 51 0c	 movsx	 edx, BYTE PTR [ecx+12]
  002cb	83 fa 01	 cmp	 edx, 1
  002ce	75 0f		 jne	 SHORT $LN31@Extract

; 586  :                         _Pnode->_Color = _Red;

  002d0	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002d3	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 587  :                         _Fixnode       = _Fixnodeparent;

  002d7	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  002da	89 45 e8	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 588  :                     } else { // must rearrange right subtree

  002dd	eb 62		 jmp	 SHORT $LN30@Extract
$LN31@Extract:

; 589  :                         if (_Pnode->_Right->_Color == _Black) { // rotate red up from left sub-subtree

  002df	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002e2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002e5	0f be 51 0c	 movsx	 edx, BYTE PTR [ecx+12]
  002e9	83 fa 01	 cmp	 edx, 1
  002ec	75 25		 jne	 SHORT $LN33@Extract

; 590  :                             _Pnode->_Left->_Color = _Black;

  002ee	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f3	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 591  :                             _Pnode->_Color        = _Red;

  002f7	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002fa	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 592  :                             _Rrotate(_Pnode);

  002fe	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00301	50		 push	 eax
  00302	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00305	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Rrotate

; 593  :                             _Pnode = _Fixnodeparent->_Right;

  0030a	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0030d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00310	89 4d e0	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN33@Extract:

; 594  :                         }
; 595  : 
; 596  :                         _Pnode->_Color         = _Fixnodeparent->_Color;

  00313	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00316	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00319	8a 51 0c	 mov	 dl, BYTE PTR [ecx+12]
  0031c	88 50 0c	 mov	 BYTE PTR [eax+12], dl

; 597  :                         _Fixnodeparent->_Color = _Black;

  0031f	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00322	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 598  :                         _Pnode->_Right->_Color = _Black;

  00326	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00329	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0032c	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 599  :                         _Lrotate(_Fixnodeparent);

  00330	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00333	50		 push	 eax
  00334	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00337	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Lrotate

; 600  :                         break; // tree now recolored/rebalanced

  0033c	e9 de 00 00 00	 jmp	 $LN3@Extract
$LN30@Extract:

; 601  :                     }
; 602  :                 } else { // fixup right subtree

  00341	e9 d4 00 00 00	 jmp	 $LN27@Extract
$LN26@Extract:

; 603  :                     _Pnode = _Fixnodeparent->_Left;

  00346	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00349	8b 08		 mov	 ecx, DWORD PTR [eax]
  0034b	89 4d e0	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 604  :                     if (_Pnode->_Color == _Red) { // rotate red up from left subtree

  0034e	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00351	0f be 48 0c	 movsx	 ecx, BYTE PTR [eax+12]
  00355	85 c9		 test	 ecx, ecx
  00357	75 22		 jne	 SHORT $LN34@Extract

; 605  :                         _Pnode->_Color         = _Black;

  00359	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0035c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 606  :                         _Fixnodeparent->_Color = _Red;

  00360	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00363	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 607  :                         _Rrotate(_Fixnodeparent);

  00367	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0036a	50		 push	 eax
  0036b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0036e	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Rrotate

; 608  :                         _Pnode = _Fixnodeparent->_Left;

  00373	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00376	8b 08		 mov	 ecx, DWORD PTR [eax]
  00378	89 4d e0	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN34@Extract:

; 609  :                     }
; 610  : 
; 611  :                     if (_Pnode->_Isnil) {

  0037b	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0037e	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  00382	85 c9		 test	 ecx, ecx
  00384	74 0b		 je	 SHORT $LN35@Extract

; 612  :                         _Fixnode = _Fixnodeparent; // shouldn't happen

  00386	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00389	89 45 e8	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 613  :                     } else if (_Pnode->_Right->_Color == _Black

  0038c	e9 89 00 00 00	 jmp	 $LN27@Extract
$LN35@Extract:

; 614  :                                && _Pnode->_Left->_Color == _Black) { // redden left subtree with black children

  00391	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00394	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00397	0f be 51 0c	 movsx	 edx, BYTE PTR [ecx+12]
  0039b	83 fa 01	 cmp	 edx, 1
  0039e	75 1d		 jne	 SHORT $LN37@Extract
  003a0	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003a3	8b 08		 mov	 ecx, DWORD PTR [eax]
  003a5	0f be 51 0c	 movsx	 edx, BYTE PTR [ecx+12]
  003a9	83 fa 01	 cmp	 edx, 1
  003ac	75 0f		 jne	 SHORT $LN37@Extract

; 615  :                         _Pnode->_Color = _Red;

  003ae	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003b1	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 616  :                         _Fixnode       = _Fixnodeparent;

  003b5	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003b8	89 45 e8	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 617  :                     } else { // must rearrange left subtree

  003bb	eb 5d		 jmp	 SHORT $LN27@Extract
$LN37@Extract:

; 618  :                         if (_Pnode->_Left->_Color == _Black) { // rotate red up from right sub-subtree

  003bd	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c2	0f be 51 0c	 movsx	 edx, BYTE PTR [ecx+12]
  003c6	83 fa 01	 cmp	 edx, 1
  003c9	75 25		 jne	 SHORT $LN39@Extract

; 619  :                             _Pnode->_Right->_Color = _Black;

  003cb	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003ce	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  003d1	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 620  :                             _Pnode->_Color         = _Red;

  003d5	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003d8	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 621  :                             _Lrotate(_Pnode);

  003dc	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003df	50		 push	 eax
  003e0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  003e3	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Lrotate

; 622  :                             _Pnode = _Fixnodeparent->_Left;

  003e8	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ed	89 4d e0	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN39@Extract:

; 623  :                         }
; 624  : 
; 625  :                         _Pnode->_Color         = _Fixnodeparent->_Color;

  003f0	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003f3	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  003f6	8a 51 0c	 mov	 dl, BYTE PTR [ecx+12]
  003f9	88 50 0c	 mov	 BYTE PTR [eax+12], dl

; 626  :                         _Fixnodeparent->_Color = _Black;

  003fc	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003ff	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 627  :                         _Pnode->_Left->_Color  = _Black;

  00403	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00406	8b 08		 mov	 ecx, DWORD PTR [eax]
  00408	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 628  :                         _Rrotate(_Fixnodeparent);

  0040c	8b 45 e4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0040f	50		 push	 eax
  00410	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00413	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Rrotate

; 629  :                         break; // tree now recolored/rebalanced

  00418	eb 05		 jmp	 SHORT $LN3@Extract
$LN27@Extract:

; 630  :                     }
; 631  :                 }
; 632  :             }

  0041a	e9 0f fe ff ff	 jmp	 $LN2@Extract
$LN3@Extract:

; 633  : 
; 634  :             _Fixnode->_Color = _Black; // stopping node is black

  0041f	8b 45 e8	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00422	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
$LN25@Extract:

; 635  :         }
; 636  : 
; 637  :         if (0 < _Mysize) {

  00426	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00429	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0042d	76 0f		 jbe	 SHORT $LN40@Extract

; 638  :             --_Mysize;

  0042f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00432	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00435	83 e9 01	 sub	 ecx, 1
  00438	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0043b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN40@Extract:

; 639  :         }
; 640  : 
; 641  :         return _Erasednode;

  0043e	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]

; 642  :     }

  00441	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00444	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0044b	59		 pop	 ecx
  0044c	5f		 pop	 edi
  0044d	5e		 pop	 esi
  0044e	5b		 pop	 ebx
  0044f	8b e5		 mov	 esp, ebp
  00451	5d		 pop	 ebp
  00452	c2 04 00	 ret	 4
  00455	cc		 int	 3
  00456	cc		 int	 3
  00457	cc		 int	 3
  00458	cc		 int	 3
  00459	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Extract
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Rrotate, COMDAT
; _this$ = ecx

; 480  :     void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  00014	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00017	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0001a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001d	89 10		 mov	 DWORD PTR [eax], edx

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  0001f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00022	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00025	0f be 51 0d	 movsx	 edx, BYTE PTR [ecx+13]
  00029	85 d2		 test	 edx, edx
  0002b	75 0c		 jne	 SHORT $LN2@Rrotate

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00030	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00033	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00036	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN2@Rrotate:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  00039	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00042	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0004d	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00050	75 0d		 jne	 SHORT $LN3@Rrotate

; 491  :             _Myhead->_Parent = _Pnode;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 08		 mov	 ecx, DWORD PTR [eax]
  00057	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0005a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0005d	eb 27		 jmp	 SHORT $LN4@Rrotate
$LN3@Rrotate:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  0005f	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00062	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00065	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00068	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0006b	75 0e		 jne	 SHORT $LN5@Rrotate

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  0006d	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00070	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00073	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00076	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 494  :         } else {

  00079	eb 0b		 jmp	 SHORT $LN4@Rrotate
$LN5@Rrotate:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  0007b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0007e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00081	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00084	89 11		 mov	 DWORD PTR [ecx], edx
$LN4@Rrotate:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00086	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00089	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0008c	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 499  :         _Wherenode->_Parent = _Pnode;

  0008f	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00092	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00095	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 500  :     }

  00098	5f		 pop	 edi
  00099	5e		 pop	 esi
  0009a	5b		 pop	 ebx
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 04 00	 ret	 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Lrotate, COMDAT
; _this$ = ecx

; 458  :     void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00012	89 4d f8	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  00015	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00018	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0001b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	0f be 51 0d	 movsx	 edx, BYTE PTR [ecx+13]
  00029	85 d2		 test	 edx, edx
  0002b	75 0b		 jne	 SHORT $LN2@Lrotate

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00035	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN2@Lrotate:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  00038	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00041	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0004c	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0004f	75 0d		 jne	 SHORT $LN3@Lrotate

; 469  :             _Myhead->_Parent = _Pnode;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00059	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0005c	eb 26		 jmp	 SHORT $LN4@Lrotate
$LN3@Lrotate:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  0005e	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00061	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00064	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00067	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00069	75 0d		 jne	 SHORT $LN5@Lrotate

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  0006b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00071	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00074	89 11		 mov	 DWORD PTR [ecx], edx

; 472  :         } else {

  00076	eb 0c		 jmp	 SHORT $LN4@Lrotate
$LN5@Lrotate:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  00078	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0007b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007e	8b 55 f8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00081	89 51 08	 mov	 DWORD PTR [ecx+8], edx
$LN4@Lrotate:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  00084	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00087	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0008a	89 08		 mov	 DWORD PTR [eax], ecx

; 477  :         _Wherenode->_Parent = _Pnode;

  0008c	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008f	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00092	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 478  :     }

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 04 00	 ret	 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Min, COMDAT

; 450  :     static _Nodeptr _Min(_Nodeptr _Pnode) noexcept { // return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Min:

; 451  :         while (!_Pnode->_Left->_Isnil) {

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	0f be 51 0d	 movsx	 edx, BYTE PTR [ecx+13]
  00012	85 d2		 test	 edx, edx
  00014	75 0a		 jne	 SHORT $LN3@Min

; 452  :             _Pnode = _Pnode->_Left;

  00016	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 453  :         }

  0001e	eb e9		 jmp	 SHORT $LN2@Min
$LN3@Min:

; 454  : 
; 455  :         return _Pnode;

  00020	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 456  :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Min
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Max, COMDAT

; 442  :     static _Nodeptr _Max(_Nodeptr _Pnode) noexcept { // return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@Max:

; 443  :         while (!_Pnode->_Right->_Isnil) {

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	0f be 51 0d	 movsx	 edx, BYTE PTR [ecx+13]
  00013	85 d2		 test	 edx, edx
  00015	75 0b		 jne	 SHORT $LN3@Max

; 444  :             _Pnode = _Pnode->_Right;

  00017	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001d	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 445  :         }

  00020	eb e7		 jmp	 SHORT $LN2@Max
$LN3@Max:

; 446  : 
; 447  :         return _Pnode;

  00022	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 448  :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Max
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >, COMDAT
; _this$ = ecx

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 2050 :     const _Scary_val* _Get_scary() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@0@ABV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > const >
  00015	83 c4 04	 add	 esp, 4

; 2052 :     }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary, COMDAT
; _this$ = ecx

; 2046 :     _Scary_val* _Get_scary() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >
  00015	83 c4 04	 add	 esp, 4

; 2048 :     }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 2042 :     const _Alnode& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2043 :         return _Mypair._Myval2._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>::_Get_first

; 2044 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Getal@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 2038 :     _Alnode& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2039 :         return _Mypair._Myval2._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>::_Get_first

; 2040 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Getcomp@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcomp@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 2034 :     const key_compare& _Getcomp() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2035 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>,1>::_Get_first

; 2036 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getcomp@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEABU?$less@H@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Proxy$ = -14						; size = 1
_$S23$ = -13						; size = 1
__Alproxy$ = -12					; size = 4
__Scary$ = -8						; size = 4
_this$ = -4						; size = 4
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2017 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2018 :         const auto _Scary = _Get_scary();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 2019 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00017	8d 45 f3	 lea	 eax, DWORD PTR _$S23$[ebp]
  0001a	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2020 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00020	50		 push	 eax
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  00024	51		 push	 ecx
  00025	8d 4d f2	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00028	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2021 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Getal@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Getal
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<int const ,NPC_DATA>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
  0003b	83 c4 04	 add	 esp, 4
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00041	89 01		 mov	 DWORD PTR [ecx], eax

; 2022 :         _Proxy._Release();

  00043	8d 4d f2	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00046	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 2023 :     }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Check_grow_by_1, COMDAT
; _this$ = ecx

; 1718 :     void _Check_grow_by_1() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1719 :         if (max_size() == _Get_scary()->_Mysize) {

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::max_size
  00014	8b f0		 mov	 esi, eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
  0001e	3b 70 04	 cmp	 esi, DWORD PTR [eax+4]
  00021	75 05		 jne	 SHORT $LN3@Check_grow

; 1720 :             _Throw_tree_length_error();

  00023	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN3@Check_grow:

; 1721 :         }
; 1722 :     }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::find, COMDAT
; _this$ = ecx

; 1467 :     _NODISCARD iterator find(const key_type& _Keyval) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
  00014	50		 push	 eax
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??$_Find@H@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Find<int>
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00025	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z
  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1469 :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
__Erasednode$ = -28					; size = 4
__Successor$ = -24					; size = 4
__Scary$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Where$ = 8						; size = 4
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Erase_unchecked, COMDAT
; _this$ = ecx

; 1385 :     _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _Where) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1386 :         const auto _Scary                    = _Get_scary();

  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
  00033	89 45 ec	 mov	 DWORD PTR __Scary$[ebp], eax

; 1387 :         _Unchecked_const_iterator _Successor = _Where;

  00036	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00039	89 45 e8	 mov	 DWORD PTR __Successor$[ebp], eax

; 1388 :         ++_Successor; // save successor iterator for return

  0003c	8d 4d e8	 lea	 ecx, DWORD PTR __Successor$[ebp]
  0003f	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,std::_Iterator_base0>::operator++

; 1389 :         _Nodeptr _Erasednode = _Scary->_Extract(_Where); // node to erase

  00044	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00047	50		 push	 eax
  00048	8b 4d ec	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Extract
  00050	89 45 e4	 mov	 DWORD PTR __Erasednode$[ebp], eax

; 1390 :         _Scary->_Orphan_ptr(_Erasednode);

  00053	8b 45 e4	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00056	50		 push	 eax
  00057	8b 4d ec	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0005a	e8 00 00 00 00	 call	 ?_Orphan_ptr@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Orphan_ptr

; 1391 :         _Node::_Freenode(_Getal(), _Erasednode); // delete erased node

  0005f	8b 45 e4	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00062	50		 push	 eax
  00063	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?_Getal@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Getal
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<int const ,NPC_DATA>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >
  00071	83 c4 08	 add	 esp, 8

; 1392 :         return _Successor._Ptr; // return successor nodeptr

  00074	8b 45 e8	 mov	 eax, DWORD PTR __Successor$[ebp]

; 1393 :     }

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
  0008b	cc		 int	 3
  0008c	cc		 int	 3
  0008d	cc		 int	 3
  0008e	cc		 int	 3
  0008f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Erase_unchecked
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
_this$ = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::max_size, COMDAT
; _this$ = ecx

; 1310 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1311 :         return (_STD min)(

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEABV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Getal
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::max_size
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
  00020	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00025	89 45 b4	 mov	 DWORD PTR $T1[ebp], eax
  00028	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  0002b	50		 push	 eax
  0002c	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00035	83 c4 08	 add	 esp, 8
  00038	8b 00		 mov	 eax, DWORD PTR [eax]

; 1312 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1313 :     }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::size, COMDAT
; _this$ = ecx

; 1306 :     _NODISCARD size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1307 :         return _Get_scary()->_Mysize;

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IBEPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1308 :     }

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__Scary$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::end, COMDAT
; _this$ = ecx

; 1248 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1249 :         const auto _Scary = _Get_scary();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	52		 push	 edx
  00021	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z
  00029	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1251 :     }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__Scary$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::begin, COMDAT
; _this$ = ecx

; 1238 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1239 :         const auto _Scary = _Get_scary();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1240 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	50		 push	 eax
  00023	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@1@@Z
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1241 :     }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__Scary$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::~_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >, COMDAT
; _this$ = ecx

; 1189 :     ~_Tree() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1190 :         const auto _Scary = _Get_scary();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_scary@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Get_scary
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1191 :         _Scary->_Erase_head(_Getal());

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Getal@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Getal
  0001f	50		 push	 eax
  00020	8b 4d f8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Erase_head@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >::_Erase_head<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >

; 1192 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1193 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1194 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1195 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1196 :     }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::~_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z
_TEXT	SEGMENT
$T1 = -70						; size = 1
$T2 = -69						; size = 1
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >, COMDAT
; _this$ = ecx

; 885  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 bb	 lea	 eax, DWORD PTR $T2[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00013	51		 push	 ecx
  00014	0f b6 55 ba	 movzx	 edx, BYTE PTR $T1[ebp]
  00018	52		 push	 edx
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??$?0ABU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>

; 886  :         _Alloc_sentinel_and_proxy();

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Alloc_sentinel_and_proxy

; 887  :     }

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::max_size, COMDAT

; 702  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 703  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00009	b8 66 66 66 06	 mov	 eax, 107374182		; 06666666H

; 704  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::deallocate, COMDAT

; 687  :     static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 688  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 689  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00009	6b 45 10 28	 imul	 eax, DWORD PTR __Count$[ebp], 40
  0000d	50		 push	 eax
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00017	83 c4 08	 add	 esp, 8

; 690  :     }

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >::allocate, COMDAT
; _this$ = ecx

; 806  :     _NODISCARD __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0CI@@std@@YAII@Z ; std::_Get_size_of_n<40>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0001e	83 c4 04	 add	 esp, 4

; 808  :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >::deallocate, COMDAT
; _this$ = ecx

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000c	6b 45 0c 28	 imul	 eax, DWORD PTR __Count$[ebp], 40
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001a	83 c4 08	 add	 esp, 8

; 804  :     }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >, COMDAT
; _this$ = ecx

; 795  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBHUNPC_DATA@@@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >::allocator<std::_Tree_node<std::pair<int const ,NPC_DATA>,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UBORN_PLACE@@@std@@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@2@$00@std@@QBEABV?$allocator@UBORN_PLACE@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@UBORN_PLACE@@@std@@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@2@$00@std@@QBEABV?$allocator@UBORN_PLACE@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<BORN_PLACE>,std::_Vector_val<std::_Simple_types<BORN_PLACE> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1348 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1349 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@UBORN_PLACE@@@std@@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@2@$00@std@@QBEABV?$allocator@UBORN_PLACE@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<BORN_PLACE>,std::_Vector_val<std::_Simple_types<BORN_PLACE> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UBORN_PLACE@@@std@@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@2@$00@std@@QAEAAV?$allocator@UBORN_PLACE@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@UBORN_PLACE@@@std@@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@2@$00@std@@QAEAAV?$allocator@UBORN_PLACE@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<BORN_PLACE>,std::_Vector_val<std::_Simple_types<BORN_PLACE> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1344 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1345 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@UBORN_PLACE@@@std@@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@2@$00@std@@QAEAAV?$allocator@UBORN_PLACE@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<BORN_PLACE>,std::_Vector_val<std::_Simple_types<BORN_PLACE> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<BORN_PLACE> >::_Vector_val<std::_Simple_types<BORN_PLACE> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<BORN_PLACE> >::_Vector_val<std::_Simple_types<BORN_PLACE> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@ABEABV?$allocator@UBORN_PLACE@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@ABEABV?$allocator@UBORN_PLACE@@@2@XZ PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Getal, COMDAT
; _this$ = ecx

; 1735 :     const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1736 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@UBORN_PLACE@@@std@@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@2@$00@std@@QBEABV?$allocator@UBORN_PLACE@@@2@XZ ; std::_Compressed_pair<std::allocator<BORN_PLACE>,std::_Vector_val<std::_Simple_types<BORN_PLACE> >,1>::_Get_first

; 1737 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@ABEABV?$allocator@UBORN_PLACE@@@2@XZ ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEAAV?$allocator@UBORN_PLACE@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEAAV?$allocator@UBORN_PLACE@@@2@XZ PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Getal, COMDAT
; _this$ = ecx

; 1731 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1732 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@UBORN_PLACE@@@std@@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@2@$00@std@@QAEAAV?$allocator@UBORN_PLACE@@@2@XZ ; std::_Compressed_pair<std::allocator<BORN_PLACE>,std::_Vector_val<std::_Simple_types<BORN_PLACE> >,1>::_Get_first

; 1733 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEAAV?$allocator@UBORN_PLACE@@@2@XZ ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Orphan_range@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@ABEXPAUBORN_PLACE@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@ABEXPAUBORN_PLACE@@0@Z PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1711 :     void _Orphan_range(pointer _First, pointer _Last) const { // orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1712 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1713 :         _Lockit _Lock(_LOCK_DEBUG);
; 1714 : 
; 1715 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;
; 1716 :         while (*_Pnext) {
; 1717 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 1718 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator
; 1719 :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 1720 :             } else { // orphan the iterator
; 1721 :                 (*_Pnext)->_Myproxy = nullptr;
; 1722 :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 1723 :             }
; 1724 :         }
; 1725 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1726 :         (void) _First;
; 1727 :         (void) _Last;
; 1728 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1729 :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@ABEXPAUBORN_PLACE@@0@Z ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@CAXXZ PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Xlength, COMDAT

; 1703 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1704 :         _Xlength_error("vector too long");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  0000e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1705 :     }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Xlength@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@CAXXZ ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Tidy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -32						; size = 4
__Mylast$ = -28						; size = 4
__Myfirst$ = -24					; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXXZ PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Tidy, COMDAT
; _this$ = ecx

; 1685 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1686 :         auto& _My_data    = _Mypair._Myval2;

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 1687 :         pointer& _Myfirst = _My_data._Myfirst;

  00031	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00034	89 45 e8	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1688 :         pointer& _Mylast  = _My_data._Mylast;

  00037	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003a	83 c0 04	 add	 eax, 4
  0003d	89 45 e4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1689 :         pointer& _Myend   = _My_data._Myend;

  00040	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00043	83 c0 08	 add	 eax, 8
  00046	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1690 : 
; 1691 :         _My_data._Orphan_all();

  00049	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1692 : 
; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00054	83 38 00	 cmp	 DWORD PTR [eax], 0
  00057	74 57		 je	 SHORT $LN3@Tidy

; 1694 :             _Destroy(_Myfirst, _Mylast);

  00059	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	51		 push	 ecx
  0005f	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00062	8b 02		 mov	 eax, DWORD PTR [edx]
  00064	50		 push	 eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@0@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Destroy

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0006d	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00070	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00073	8b 00		 mov	 eax, DWORD PTR [eax]
  00075	2b 01		 sub	 eax, DWORD PTR [ecx]
  00077	99		 cdq
  00078	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0007d	f7 f9		 idiv	 ecx
  0007f	50		 push	 eax
  00080	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
  00085	50		 push	 eax
  00086	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?_Getal@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEAAV?$allocator@UBORN_PLACE@@@2@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Getal
  0008e	8b c8		 mov	 ecx, eax
  00090	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UBORN_PLACE@@@std@@QAEXQAUBORN_PLACE@@I@Z ; std::allocator<BORN_PLACE>::deallocate

; 1696 : 
; 1697 :             _Myfirst = pointer();

  00095	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00098	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1698 :             _Mylast  = pointer();

  0009e	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a1	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1699 :             _Myend   = pointer();

  000a7	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000aa	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1700 :         }
; 1701 :     }

  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
  000c2	cc		 int	 3
  000c3	cc		 int	 3
  000c4	cc		 int	 3
  000c5	cc		 int	 3
  000c6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXXZ ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Tidy
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Change_array@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXQAUBORN_PLACE@@II@Z
_TEXT	SEGMENT
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
__Myfirst$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXQAUBORN_PLACE@@II@Z PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Change_array, COMDAT
; _this$ = ecx

; 1666 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1667 :         // orphan all iterators, discard old array, acquire new array
; 1668 :         auto& _My_data    = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1669 :         pointer& _Myfirst = _My_data._Myfirst;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1670 :         pointer& _Mylast  = _My_data._Mylast;

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001b	83 c0 04	 add	 eax, 4
  0001e	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1671 :         pointer& _Myend   = _My_data._Myend;

  00021	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00024	83 c0 08	 add	 eax, 8
  00027	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1672 : 
; 1673 :         _My_data._Orphan_all();

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1674 : 
; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00032	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00035	83 38 00	 cmp	 DWORD PTR [eax], 0
  00038	74 3c		 je	 SHORT $LN2@Change_arr

; 1676 :             _Destroy(_Myfirst, _Mylast);

  0003a	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	51		 push	 ecx
  00040	8b 55 f4	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00043	8b 02		 mov	 eax, DWORD PTR [edx]
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@0@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Destroy

; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0004e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]
  00056	2b 01		 sub	 eax, DWORD PTR [ecx]
  00058	99		 cdq
  00059	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0005e	f7 f9		 idiv	 ecx
  00060	50		 push	 eax
  00061	8b 55 f4	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00064	8b 02		 mov	 eax, DWORD PTR [edx]
  00066	50		 push	 eax
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?_Getal@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEAAV?$allocator@UBORN_PLACE@@@2@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Getal
  0006f	8b c8		 mov	 ecx, eax
  00071	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UBORN_PLACE@@@std@@QAEXQAUBORN_PLACE@@I@Z ; std::allocator<BORN_PLACE>::deallocate
$LN2@Change_arr:

; 1678 :         }
; 1679 : 
; 1680 :         _Myfirst = _Newvec;

  00076	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00079	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0007c	89 08		 mov	 DWORD PTR [eax], ecx

; 1681 :         _Mylast  = _Newvec + _Newsize;

  0007e	6b 45 0c 0c	 imul	 eax, DWORD PTR __Newsize$[ebp], 12
  00082	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  00085	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00088	89 01		 mov	 DWORD PTR [ecx], eax

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  0008a	6b 45 10 0c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 12
  0008e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  00091	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  00094	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :     }

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXQAUBORN_PLACE@@II@Z ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Geometric$ = -12					; size = 4
__Oldcapacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@ABEII@Z PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1618 : 
; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Oldcapacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	39 45 f8	 cmp	 DWORD PTR __Oldcapacity$[ebp], eax
  00029	76 05		 jbe	 SHORT $LN2@Calculate_

; 1620 :             return _Newsize; // geometric growth would overflow

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0002e	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00030	8b 45 f8	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 f8	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00038	89 45 f4	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0003b	8b 45 f4	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0003e	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00041	73 05		 jae	 SHORT $LN3@Calculate_

; 1626 :             return _Newsize; // geometric growth would be insufficient

  00043	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00046	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1627 :         }
; 1628 : 
; 1629 :         return _Geometric; // geometric growth is sufficient

  00048	8b 45 f4	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1630 :     }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@ABEII@Z ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Destroy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@0@Z PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEAAV?$allocator@UBORN_PLACE@@@2@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UBORN_PLACE@@@std@@@std@@YAXPAUBORN_PLACE@@QAU1@AAV?$allocator@UBORN_PLACE@@@0@@Z ; std::_Destroy_range<std::allocator<BORN_PLACE> >
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?_Destroy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@0@Z ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@00@Z
_TEXT	SEGMENT
$T1 = -69						; size = 1
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@00@Z PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1605 :     void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1606 :         // move_if_noexcept [_First, _Last) to raw _Dest, using allocator
; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  0000c	33 c0		 xor	 eax, eax
  0000e	88 45 bb	 mov	 BYTE PTR $T1[ebp], al
  00011	0f b6 4d bb	 movzx	 ecx, BYTE PTR $T1[ebp]
  00015	51		 push	 ecx
  00016	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00021	51		 push	 ecx
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Umove_if_noexcept1@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@00U?$integral_constant@_N$00@2@@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Umove_if_noexcept1

; 1608 :             bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
; 1609 :     }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@00@Z ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1595 :     void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1596 :         // move [_First, _Last) to raw _Dest, using allocator
; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEAAV?$allocator@UBORN_PLACE@@@2@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@YAPAUBORN_PLACE@@QAU1@0PAU1@AAV?$allocator@UBORN_PLACE@@@0@@Z ; std::_Uninitialized_move<BORN_PLACE *,std::allocator<BORN_PLACE> >
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 1598 :     }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEPAUBORN_PLACE@@PAU3@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEPAUBORN_PLACE@@PAU3@00@Z PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Umove, COMDAT
; _this$ = ecx

; 1591 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEAAV?$allocator@UBORN_PLACE@@@2@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@YAPAUBORN_PLACE@@QAU1@0PAU1@AAV?$allocator@UBORN_PLACE@@@0@@Z ; std::_Uninitialized_move<BORN_PLACE *,std::allocator<BORN_PLACE> >
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 1593 :     }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?_Umove@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEPAUBORN_PLACE@@PAU3@00@Z ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Umove
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?capacity@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::capacity, COMDAT
; _this$ = ecx

; 1492 :     _NODISCARD size_type capacity() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001d	99		 cdq
  0001e	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00023	f7 f9		 idiv	 ecx

; 1495 :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?capacity@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?max_size@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
_this$ = -4						; size = 4
?max_size@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::max_size, COMDAT
; _this$ = ecx

; 1487 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1488 :         return (_STD min)(

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@ABEABV?$allocator@UBORN_PLACE@@@2@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Getal
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@UBORN_PLACE@@@std@@@std@@SAIABV?$allocator@UBORN_PLACE@@@2@@Z ; std::_Default_allocator_traits<std::allocator<BORN_PLACE> >::max_size
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
  00020	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00025	89 45 b4	 mov	 DWORD PTR $T1[ebp], eax
  00028	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  0002b	50		 push	 eax
  0002c	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00035	83 c4 08	 add	 esp, 8
  00038	8b 00		 mov	 eax, DWORD PTR [eax]

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?max_size@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?size@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::size, COMDAT
; _this$ = ecx

; 1482 :     _NODISCARD size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1483 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001d	99		 cdq
  0001e	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00023	f7 f9		 idiv	 ecx

; 1485 :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?size@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?end@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@2@XZ PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::end, COMDAT
; _this$ = ecx

; 1419 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >
  0001b	83 c4 04	 add	 esp, 4
  0001e	50		 push	 eax
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00022	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00025	52		 push	 edx
  00026	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAE@PAUBORN_PLACE@@PBU_Container_base0@1@@Z
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1422 :     }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?end@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@2@XZ ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?begin@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@2@XZ PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::begin, COMDAT
; _this$ = ecx

; 1409 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >
  0001b	83 c4 04	 add	 esp, 4
  0001e	50		 push	 eax
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	52		 push	 edx
  00025	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00028	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAE@PAUBORN_PLACE@@PBU_Container_base0@1@@Z
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1412 :     }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?begin@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@2@XZ ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?clear@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Mylast$ = -28						; size = 4
__Myfirst$ = -24					; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?clear@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEXXZ PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?clear@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  00031	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00034	89 45 e8	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00037	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003a	83 c0 04	 add	 eax, 4
  0003d	89 45 e4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();

  00040	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00043	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1389 :         _Destroy(_Myfirst, _Mylast);

  00048	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	51		 push	 ecx
  0004e	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	50		 push	 eax
  00054	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXPAUBORN_PLACE@@0@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Destroy

; 1390 :         _Mylast = _Myfirst;

  0005c	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005f	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00062	8b 11		 mov	 edx, DWORD PTR [ecx]
  00064	89 10		 mov	 DWORD PTR [eax], edx

; 1391 :     }

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
  00078	cc		 int	 3
  00079	cc		 int	 3
  0007a	cc		 int	 3
  0007b	cc		 int	 3
  0007c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?clear@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?clear@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEXXZ ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::clear
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?push_back@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEXABUBORN_PLACE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEXABUBORN_PLACE@@@Z PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::push_back, COMDAT
; _this$ = ecx

; 716  :     void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 717  :         emplace_back(_Val);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$emplace_back@ABUBORN_PLACE@@@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE@ABUBORN_PLACE@@@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::emplace_back<BORN_PLACE const &>

; 718  :     }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?push_back@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEXABUBORN_PLACE@@@Z ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE@XZ PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::~vector<BORN_PLACE,std::allocator<BORN_PLACE> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@AAEXXZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE@XZ ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::~vector<BORN_PLACE,std::allocator<BORN_PLACE> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -70						; size = 1
$T2 = -69						; size = 1
_this$ = -4						; size = 4
??0?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE@XZ PROC ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::vector<BORN_PLACE,std::allocator<BORN_PLACE> >, COMDAT
; _this$ = ecx

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	0f b6 45 bb	 movzx	 eax, BYTE PTR $T2[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@UBORN_PLACE@@@std@@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<BORN_PLACE>,std::_Vector_val<std::_Simple_types<BORN_PLACE> >,1>::_Compressed_pair<std::allocator<BORN_PLACE>,std::_Vector_val<std::_Simple_types<BORN_PLACE> >,1><>

; 446  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00019	8d 45 ba	 lea	 eax, DWORD PTR $T1[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 447  :     }

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??0?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE@XZ ENDP ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::vector<BORN_PLACE,std::allocator<BORN_PLACE> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UBORN_PLACE@@@std@@@std@@SAIABV?$allocator@UBORN_PLACE@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@UBORN_PLACE@@@std@@@std@@SAIABV?$allocator@UBORN_PLACE@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<BORN_PLACE> >::max_size, COMDAT

; 702  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 703  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00009	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 704  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@UBORN_PLACE@@@std@@@std@@SAIABV?$allocator@UBORN_PLACE@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<BORN_PLACE> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?allocate@?$allocator@UBORN_PLACE@@@std@@QAEPAUBORN_PLACE@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UBORN_PLACE@@@std@@QAEPAUBORN_PLACE@@I@Z PROC ; std::allocator<BORN_PLACE>::allocate, COMDAT
; _this$ = ecx

; 806  :     _NODISCARD __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0M@@std@@YAII@Z ; std::_Get_size_of_n<12>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0001e	83 c4 04	 add	 esp, 4

; 808  :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$allocator@UBORN_PLACE@@@std@@QAEPAUBORN_PLACE@@I@Z ENDP ; std::allocator<BORN_PLACE>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@UBORN_PLACE@@@std@@QAEXQAUBORN_PLACE@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UBORN_PLACE@@@std@@QAEXQAUBORN_PLACE@@I@Z PROC ; std::allocator<BORN_PLACE>::deallocate, COMDAT
; _this$ = ecx

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000c	6b 45 0c 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001a	83 c4 08	 add	 esp, 8

; 804  :     }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?deallocate@?$allocator@UBORN_PLACE@@@std@@QAEXQAUBORN_PLACE@@I@Z ENDP ; std::allocator<BORN_PLACE>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@UBORN_PLACE@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UBORN_PLACE@@@std@@QAE@XZ PROC		; std::allocator<BORN_PLACE>::allocator<BORN_PLACE>, COMDAT
; _this$ = ecx

; 795  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UBORN_PLACE@@@std@@QAE@XZ ENDP		; std::allocator<BORN_PLACE>::allocator<BORN_PLACE>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@2@$00@std@@QBEABV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@2@$00@std@@QBEABV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<REQUIRE_SPECIAL_ITEM>,std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1348 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1349 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@2@$00@std@@QBEABV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<REQUIRE_SPECIAL_ITEM>,std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@2@$00@std@@QAEAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@2@$00@std@@QAEAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<REQUIRE_SPECIAL_ITEM>,std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1344 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1345 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@2@$00@std@@QAEAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<REQUIRE_SPECIAL_ITEM>,std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@ABEABV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@ABEABV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Getal, COMDAT
; _this$ = ecx

; 1735 :     const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1736 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@2@$00@std@@QBEABV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ; std::_Compressed_pair<std::allocator<REQUIRE_SPECIAL_ITEM>,std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >,1>::_Get_first

; 1737 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@ABEABV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Getal, COMDAT
; _this$ = ecx

; 1731 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1732 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@2@$00@std@@QAEAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ; std::_Compressed_pair<std::allocator<REQUIRE_SPECIAL_ITEM>,std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >,1>::_Get_first

; 1733 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Orphan_range@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@ABEXPAUREQUIRE_SPECIAL_ITEM@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@ABEXPAUREQUIRE_SPECIAL_ITEM@@0@Z PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1711 :     void _Orphan_range(pointer _First, pointer _Last) const { // orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1712 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1713 :         _Lockit _Lock(_LOCK_DEBUG);
; 1714 : 
; 1715 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;
; 1716 :         while (*_Pnext) {
; 1717 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 1718 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator
; 1719 :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 1720 :             } else { // orphan the iterator
; 1721 :                 (*_Pnext)->_Myproxy = nullptr;
; 1722 :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 1723 :             }
; 1724 :         }
; 1725 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1726 :         (void) _First;
; 1727 :         (void) _Last;
; 1728 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1729 :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@ABEXPAUREQUIRE_SPECIAL_ITEM@@0@Z ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@CAXXZ PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Xlength, COMDAT

; 1703 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1704 :         _Xlength_error("vector too long");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  0000e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1705 :     }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Xlength@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@CAXXZ ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Tidy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -32						; size = 4
__Mylast$ = -28						; size = 4
__Myfirst$ = -24					; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXXZ PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Tidy, COMDAT
; _this$ = ecx

; 1685 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1686 :         auto& _My_data    = _Mypair._Myval2;

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 1687 :         pointer& _Myfirst = _My_data._Myfirst;

  00031	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00034	89 45 e8	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1688 :         pointer& _Mylast  = _My_data._Mylast;

  00037	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003a	83 c0 04	 add	 eax, 4
  0003d	89 45 e4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1689 :         pointer& _Myend   = _My_data._Myend;

  00040	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00043	83 c0 08	 add	 eax, 8
  00046	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1690 : 
; 1691 :         _My_data._Orphan_all();

  00049	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1692 : 
; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00054	83 38 00	 cmp	 DWORD PTR [eax], 0
  00057	74 57		 je	 SHORT $LN3@Tidy

; 1694 :             _Destroy(_Myfirst, _Mylast);

  00059	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	51		 push	 ecx
  0005f	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00062	8b 02		 mov	 eax, DWORD PTR [edx]
  00064	50		 push	 eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@0@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Destroy

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0006d	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00070	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00073	8b 00		 mov	 eax, DWORD PTR [eax]
  00075	2b 01		 sub	 eax, DWORD PTR [ecx]
  00077	99		 cdq
  00078	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0007d	f7 f9		 idiv	 ecx
  0007f	50		 push	 eax
  00080	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
  00085	50		 push	 eax
  00086	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?_Getal@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Getal
  0008e	8b c8		 mov	 ecx, eax
  00090	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAEXQAUREQUIRE_SPECIAL_ITEM@@I@Z ; std::allocator<REQUIRE_SPECIAL_ITEM>::deallocate

; 1696 : 
; 1697 :             _Myfirst = pointer();

  00095	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00098	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1698 :             _Mylast  = pointer();

  0009e	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a1	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1699 :             _Myend   = pointer();

  000a7	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000aa	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1700 :         }
; 1701 :     }

  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
  000c2	cc		 int	 3
  000c3	cc		 int	 3
  000c4	cc		 int	 3
  000c5	cc		 int	 3
  000c6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXXZ ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Tidy
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Change_array@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXQAUREQUIRE_SPECIAL_ITEM@@II@Z
_TEXT	SEGMENT
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
__Myfirst$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXQAUREQUIRE_SPECIAL_ITEM@@II@Z PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Change_array, COMDAT
; _this$ = ecx

; 1666 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1667 :         // orphan all iterators, discard old array, acquire new array
; 1668 :         auto& _My_data    = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1669 :         pointer& _Myfirst = _My_data._Myfirst;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1670 :         pointer& _Mylast  = _My_data._Mylast;

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001b	83 c0 04	 add	 eax, 4
  0001e	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1671 :         pointer& _Myend   = _My_data._Myend;

  00021	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00024	83 c0 08	 add	 eax, 8
  00027	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1672 : 
; 1673 :         _My_data._Orphan_all();

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1674 : 
; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00032	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00035	83 38 00	 cmp	 DWORD PTR [eax], 0
  00038	74 3c		 je	 SHORT $LN2@Change_arr

; 1676 :             _Destroy(_Myfirst, _Mylast);

  0003a	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	51		 push	 ecx
  00040	8b 55 f4	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00043	8b 02		 mov	 eax, DWORD PTR [edx]
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@0@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Destroy

; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0004e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]
  00056	2b 01		 sub	 eax, DWORD PTR [ecx]
  00058	99		 cdq
  00059	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0005e	f7 f9		 idiv	 ecx
  00060	50		 push	 eax
  00061	8b 55 f4	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00064	8b 02		 mov	 eax, DWORD PTR [edx]
  00066	50		 push	 eax
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?_Getal@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Getal
  0006f	8b c8		 mov	 ecx, eax
  00071	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAEXQAUREQUIRE_SPECIAL_ITEM@@I@Z ; std::allocator<REQUIRE_SPECIAL_ITEM>::deallocate
$LN2@Change_arr:

; 1678 :         }
; 1679 : 
; 1680 :         _Myfirst = _Newvec;

  00076	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00079	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0007c	89 08		 mov	 DWORD PTR [eax], ecx

; 1681 :         _Mylast  = _Newvec + _Newsize;

  0007e	6b 45 0c 1c	 imul	 eax, DWORD PTR __Newsize$[ebp], 28
  00082	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  00085	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00088	89 01		 mov	 DWORD PTR [ecx], eax

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  0008a	6b 45 10 1c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 28
  0008e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  00091	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  00094	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :     }

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXQAUREQUIRE_SPECIAL_ITEM@@II@Z ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Geometric$ = -12					; size = 4
__Oldcapacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@ABEII@Z PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1618 : 
; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Oldcapacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	39 45 f8	 cmp	 DWORD PTR __Oldcapacity$[ebp], eax
  00029	76 05		 jbe	 SHORT $LN2@Calculate_

; 1620 :             return _Newsize; // geometric growth would overflow

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0002e	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00030	8b 45 f8	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 f8	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00038	89 45 f4	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0003b	8b 45 f4	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0003e	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00041	73 05		 jae	 SHORT $LN3@Calculate_

; 1626 :             return _Newsize; // geometric growth would be insufficient

  00043	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00046	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1627 :         }
; 1628 : 
; 1629 :         return _Geometric; // geometric growth is sufficient

  00048	8b 45 f4	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1630 :     }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@ABEII@Z ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Destroy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@0@Z PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@YAXPAUREQUIRE_SPECIAL_ITEM@@QAU1@AAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@0@@Z ; std::_Destroy_range<std::allocator<REQUIRE_SPECIAL_ITEM> >
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?_Destroy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@0@Z ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@00@Z
_TEXT	SEGMENT
$T1 = -69						; size = 1
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@00@Z PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1605 :     void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1606 :         // move_if_noexcept [_First, _Last) to raw _Dest, using allocator
; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  0000c	33 c0		 xor	 eax, eax
  0000e	88 45 bb	 mov	 BYTE PTR $T1[ebp], al
  00011	0f b6 4d bb	 movzx	 ecx, BYTE PTR $T1[ebp]
  00015	51		 push	 ecx
  00016	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00021	51		 push	 ecx
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Umove_if_noexcept1@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@00U?$integral_constant@_N$00@2@@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Umove_if_noexcept1

; 1608 :             bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
; 1609 :     }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@00@Z ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1595 :     void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1596 :         // move [_First, _Last) to raw _Dest, using allocator
; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@QAU1@0PAU1@AAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@0@@Z ; std::_Uninitialized_move<REQUIRE_SPECIAL_ITEM *,std::allocator<REQUIRE_SPECIAL_ITEM> >
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 1598 :     }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEPAUREQUIRE_SPECIAL_ITEM@@PAU3@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEPAUREQUIRE_SPECIAL_ITEM@@PAU3@00@Z PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Umove, COMDAT
; _this$ = ecx

; 1591 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEAAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@YAPAUREQUIRE_SPECIAL_ITEM@@QAU1@0PAU1@AAV?$allocator@UREQUIRE_SPECIAL_ITEM@@@0@@Z ; std::_Uninitialized_move<REQUIRE_SPECIAL_ITEM *,std::allocator<REQUIRE_SPECIAL_ITEM> >
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 1593 :     }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?_Umove@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEPAUREQUIRE_SPECIAL_ITEM@@PAU3@00@Z ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Umove
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?capacity@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::capacity, COMDAT
; _this$ = ecx

; 1492 :     _NODISCARD size_type capacity() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001d	99		 cdq
  0001e	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00023	f7 f9		 idiv	 ecx

; 1495 :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?capacity@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?max_size@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
_this$ = -4						; size = 4
?max_size@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::max_size, COMDAT
; _this$ = ecx

; 1487 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1488 :         return (_STD min)(

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@ABEABV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Getal
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@SAIABV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@@Z ; std::_Default_allocator_traits<std::allocator<REQUIRE_SPECIAL_ITEM> >::max_size
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
  00020	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00025	89 45 b4	 mov	 DWORD PTR $T1[ebp], eax
  00028	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  0002b	50		 push	 eax
  0002c	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00035	83 c4 08	 add	 esp, 8
  00038	8b 00		 mov	 eax, DWORD PTR [eax]

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?max_size@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?size@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::size, COMDAT
; _this$ = ecx

; 1482 :     _NODISCARD size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1483 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001d	99		 cdq
  0001e	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00023	f7 f9		 idiv	 ecx

; 1485 :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?size@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?end@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@2@XZ PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::end, COMDAT
; _this$ = ecx

; 1419 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >
  0001b	83 c4 04	 add	 esp, 4
  0001e	50		 push	 eax
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00022	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00025	52		 push	 edx
  00026	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE@PAUREQUIRE_SPECIAL_ITEM@@PBU_Container_base0@1@@Z
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1422 :     }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?end@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@2@XZ ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?begin@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@2@XZ PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::begin, COMDAT
; _this$ = ecx

; 1409 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >
  0001b	83 c4 04	 add	 esp, 4
  0001e	50		 push	 eax
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	52		 push	 edx
  00025	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00028	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE@PAUREQUIRE_SPECIAL_ITEM@@PBU_Container_base0@1@@Z
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1412 :     }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?begin@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@2@XZ ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?clear@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Mylast$ = -28						; size = 4
__Myfirst$ = -24					; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?clear@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEXXZ PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?clear@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  00031	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00034	89 45 e8	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00037	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003a	83 c0 04	 add	 eax, 4
  0003d	89 45 e4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();

  00040	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00043	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1389 :         _Destroy(_Myfirst, _Mylast);

  00048	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	51		 push	 ecx
  0004e	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	50		 push	 eax
  00054	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXPAUREQUIRE_SPECIAL_ITEM@@0@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Destroy

; 1390 :         _Mylast = _Myfirst;

  0005c	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005f	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00062	8b 11		 mov	 edx, DWORD PTR [ecx]
  00064	89 10		 mov	 DWORD PTR [eax], edx

; 1391 :     }

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
  00078	cc		 int	 3
  00079	cc		 int	 3
  0007a	cc		 int	 3
  0007b	cc		 int	 3
  0007c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?clear@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?clear@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEXXZ ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::clear
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?push_back@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEXABUREQUIRE_SPECIAL_ITEM@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEXABUREQUIRE_SPECIAL_ITEM@@@Z PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::push_back, COMDAT
; _this$ = ecx

; 716  :     void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 717  :         emplace_back(_Val);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$emplace_back@ABUREQUIRE_SPECIAL_ITEM@@@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@ABUREQUIRE_SPECIAL_ITEM@@@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::emplace_back<REQUIRE_SPECIAL_ITEM const &>

; 718  :     }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?push_back@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEXABUREQUIRE_SPECIAL_ITEM@@@Z ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@XZ PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::~vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@AAEXXZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@XZ ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::~vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -70						; size = 1
$T2 = -69						; size = 1
_this$ = -4						; size = 4
??0?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@XZ PROC ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >, COMDAT
; _this$ = ecx

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	0f b6 45 bb	 movzx	 eax, BYTE PTR $T2[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<REQUIRE_SPECIAL_ITEM>,std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >,1>::_Compressed_pair<std::allocator<REQUIRE_SPECIAL_ITEM>,std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> >,1><>

; 446  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00019	8d 45 ba	 lea	 eax, DWORD PTR $T1[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 447  :     }

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??0?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@XZ ENDP ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@SAIABV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@SAIABV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<REQUIRE_SPECIAL_ITEM> >::max_size, COMDAT

; 702  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 703  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00009	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 704  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@SAIABV?$allocator@UREQUIRE_SPECIAL_ITEM@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<REQUIRE_SPECIAL_ITEM> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?allocate@?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@I@Z PROC ; std::allocator<REQUIRE_SPECIAL_ITEM>::allocate, COMDAT
; _this$ = ecx

; 806  :     _NODISCARD __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0BM@@std@@YAII@Z ; std::_Get_size_of_n<28>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0001e	83 c4 04	 add	 esp, 4

; 808  :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAEPAUREQUIRE_SPECIAL_ITEM@@I@Z ENDP ; std::allocator<REQUIRE_SPECIAL_ITEM>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAEXQAUREQUIRE_SPECIAL_ITEM@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAEXQAUREQUIRE_SPECIAL_ITEM@@I@Z PROC ; std::allocator<REQUIRE_SPECIAL_ITEM>::deallocate, COMDAT
; _this$ = ecx

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000c	6b 45 0c 1c	 imul	 eax, DWORD PTR __Count$[ebp], 28
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001a	83 c4 08	 add	 esp, 8

; 804  :     }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?deallocate@?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAEXQAUREQUIRE_SPECIAL_ITEM@@I@Z ENDP ; std::allocator<REQUIRE_SPECIAL_ITEM>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAE@XZ PROC	; std::allocator<REQUIRE_SPECIAL_ITEM>::allocator<REQUIRE_SPECIAL_ITEM>, COMDAT
; _this$ = ecx

; 795  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@QAE@XZ ENDP	; std::allocator<REQUIRE_SPECIAL_ITEM>::allocator<REQUIRE_SPECIAL_ITEM>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UTABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@2@$00@std@@QBEABV?$allocator@UTABLE_RESET@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@UTABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@2@$00@std@@QBEABV?$allocator@UTABLE_RESET@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<TABLE_RESET>,std::_Vector_val<std::_Simple_types<TABLE_RESET> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1348 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1349 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@UTABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@2@$00@std@@QBEABV?$allocator@UTABLE_RESET@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<TABLE_RESET>,std::_Vector_val<std::_Simple_types<TABLE_RESET> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UTABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@2@$00@std@@QAEAAV?$allocator@UTABLE_RESET@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@UTABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@2@$00@std@@QAEAAV?$allocator@UTABLE_RESET@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<TABLE_RESET>,std::_Vector_val<std::_Simple_types<TABLE_RESET> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1344 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1345 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@UTABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@2@$00@std@@QAEAAV?$allocator@UTABLE_RESET@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<TABLE_RESET>,std::_Vector_val<std::_Simple_types<TABLE_RESET> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<TABLE_RESET> >::_Vector_val<std::_Simple_types<TABLE_RESET> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<TABLE_RESET> >::_Vector_val<std::_Simple_types<TABLE_RESET> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@ABEABV?$allocator@UTABLE_RESET@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@ABEABV?$allocator@UTABLE_RESET@@@2@XZ PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Getal, COMDAT
; _this$ = ecx

; 1735 :     const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1736 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@UTABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@2@$00@std@@QBEABV?$allocator@UTABLE_RESET@@@2@XZ ; std::_Compressed_pair<std::allocator<TABLE_RESET>,std::_Vector_val<std::_Simple_types<TABLE_RESET> >,1>::_Get_first

; 1737 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@ABEABV?$allocator@UTABLE_RESET@@@2@XZ ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UTABLE_RESET@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UTABLE_RESET@@@2@XZ PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Getal, COMDAT
; _this$ = ecx

; 1731 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1732 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@UTABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@2@$00@std@@QAEAAV?$allocator@UTABLE_RESET@@@2@XZ ; std::_Compressed_pair<std::allocator<TABLE_RESET>,std::_Vector_val<std::_Simple_types<TABLE_RESET> >,1>::_Get_first

; 1733 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UTABLE_RESET@@@2@XZ ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Orphan_range@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@ABEXPAUTABLE_RESET@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@ABEXPAUTABLE_RESET@@0@Z PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1711 :     void _Orphan_range(pointer _First, pointer _Last) const { // orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1712 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1713 :         _Lockit _Lock(_LOCK_DEBUG);
; 1714 : 
; 1715 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;
; 1716 :         while (*_Pnext) {
; 1717 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 1718 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator
; 1719 :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 1720 :             } else { // orphan the iterator
; 1721 :                 (*_Pnext)->_Myproxy = nullptr;
; 1722 :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 1723 :             }
; 1724 :         }
; 1725 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1726 :         (void) _First;
; 1727 :         (void) _Last;
; 1728 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1729 :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@ABEXPAUTABLE_RESET@@0@Z ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@CAXXZ PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Xlength, COMDAT

; 1703 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1704 :         _Xlength_error("vector too long");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  0000e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1705 :     }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Xlength@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@CAXXZ ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Tidy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -32						; size = 4
__Mylast$ = -28						; size = 4
__Myfirst$ = -24					; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXXZ PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Tidy, COMDAT
; _this$ = ecx

; 1685 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1686 :         auto& _My_data    = _Mypair._Myval2;

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 1687 :         pointer& _Myfirst = _My_data._Myfirst;

  00031	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00034	89 45 e8	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1688 :         pointer& _Mylast  = _My_data._Mylast;

  00037	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003a	83 c0 04	 add	 eax, 4
  0003d	89 45 e4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1689 :         pointer& _Myend   = _My_data._Myend;

  00040	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00043	83 c0 08	 add	 eax, 8
  00046	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1690 : 
; 1691 :         _My_data._Orphan_all();

  00049	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1692 : 
; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00054	83 38 00	 cmp	 DWORD PTR [eax], 0
  00057	74 57		 je	 SHORT $LN3@Tidy

; 1694 :             _Destroy(_Myfirst, _Mylast);

  00059	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	51		 push	 ecx
  0005f	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00062	8b 02		 mov	 eax, DWORD PTR [edx]
  00064	50		 push	 eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@0@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Destroy

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0006d	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00070	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00073	8b 00		 mov	 eax, DWORD PTR [eax]
  00075	2b 01		 sub	 eax, DWORD PTR [ecx]
  00077	99		 cdq
  00078	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0007d	f7 f9		 idiv	 ecx
  0007f	50		 push	 eax
  00080	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
  00085	50		 push	 eax
  00086	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?_Getal@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UTABLE_RESET@@@2@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Getal
  0008e	8b c8		 mov	 ecx, eax
  00090	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTABLE_RESET@@@std@@QAEXQAUTABLE_RESET@@I@Z ; std::allocator<TABLE_RESET>::deallocate

; 1696 : 
; 1697 :             _Myfirst = pointer();

  00095	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00098	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1698 :             _Mylast  = pointer();

  0009e	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a1	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1699 :             _Myend   = pointer();

  000a7	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000aa	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1700 :         }
; 1701 :     }

  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
  000c2	cc		 int	 3
  000c3	cc		 int	 3
  000c4	cc		 int	 3
  000c5	cc		 int	 3
  000c6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXXZ ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Tidy
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Change_array@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXQAUTABLE_RESET@@II@Z
_TEXT	SEGMENT
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
__Myfirst$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXQAUTABLE_RESET@@II@Z PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Change_array, COMDAT
; _this$ = ecx

; 1666 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1667 :         // orphan all iterators, discard old array, acquire new array
; 1668 :         auto& _My_data    = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1669 :         pointer& _Myfirst = _My_data._Myfirst;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1670 :         pointer& _Mylast  = _My_data._Mylast;

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001b	83 c0 04	 add	 eax, 4
  0001e	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1671 :         pointer& _Myend   = _My_data._Myend;

  00021	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00024	83 c0 08	 add	 eax, 8
  00027	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1672 : 
; 1673 :         _My_data._Orphan_all();

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1674 : 
; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00032	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00035	83 38 00	 cmp	 DWORD PTR [eax], 0
  00038	74 3c		 je	 SHORT $LN2@Change_arr

; 1676 :             _Destroy(_Myfirst, _Mylast);

  0003a	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	51		 push	 ecx
  00040	8b 55 f4	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00043	8b 02		 mov	 eax, DWORD PTR [edx]
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@0@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Destroy

; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0004e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]
  00056	2b 01		 sub	 eax, DWORD PTR [ecx]
  00058	99		 cdq
  00059	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0005e	f7 f9		 idiv	 ecx
  00060	50		 push	 eax
  00061	8b 55 f4	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00064	8b 02		 mov	 eax, DWORD PTR [edx]
  00066	50		 push	 eax
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?_Getal@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UTABLE_RESET@@@2@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Getal
  0006f	8b c8		 mov	 ecx, eax
  00071	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTABLE_RESET@@@std@@QAEXQAUTABLE_RESET@@I@Z ; std::allocator<TABLE_RESET>::deallocate
$LN2@Change_arr:

; 1678 :         }
; 1679 : 
; 1680 :         _Myfirst = _Newvec;

  00076	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00079	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0007c	89 08		 mov	 DWORD PTR [eax], ecx

; 1681 :         _Mylast  = _Newvec + _Newsize;

  0007e	6b 45 0c 3c	 imul	 eax, DWORD PTR __Newsize$[ebp], 60
  00082	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  00085	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00088	89 01		 mov	 DWORD PTR [ecx], eax

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  0008a	6b 45 10 3c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 60
  0008e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  00091	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  00094	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :     }

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXQAUTABLE_RESET@@II@Z ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Geometric$ = -12					; size = 4
__Oldcapacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@ABEII@Z PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QBEIXZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1618 : 
; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QBEIXZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Oldcapacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	39 45 f8	 cmp	 DWORD PTR __Oldcapacity$[ebp], eax
  00029	76 05		 jbe	 SHORT $LN2@Calculate_

; 1620 :             return _Newsize; // geometric growth would overflow

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0002e	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00030	8b 45 f8	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 f8	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00038	89 45 f4	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0003b	8b 45 f4	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0003e	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00041	73 05		 jae	 SHORT $LN3@Calculate_

; 1626 :             return _Newsize; // geometric growth would be insufficient

  00043	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00046	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1627 :         }
; 1628 : 
; 1629 :         return _Geometric; // geometric growth is sufficient

  00048	8b 45 f4	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1630 :     }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@ABEII@Z ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Destroy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@0@Z PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UTABLE_RESET@@@2@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTABLE_RESET@@@std@@@std@@YAXPAUTABLE_RESET@@QAU1@AAV?$allocator@UTABLE_RESET@@@0@@Z ; std::_Destroy_range<std::allocator<TABLE_RESET> >
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?_Destroy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@0@Z ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@00@Z
_TEXT	SEGMENT
$T1 = -69						; size = 1
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@00@Z PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1605 :     void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1606 :         // move_if_noexcept [_First, _Last) to raw _Dest, using allocator
; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  0000c	33 c0		 xor	 eax, eax
  0000e	88 45 bb	 mov	 BYTE PTR $T1[ebp], al
  00011	0f b6 4d bb	 movzx	 ecx, BYTE PTR $T1[ebp]
  00015	51		 push	 ecx
  00016	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00021	51		 push	 ecx
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Umove_if_noexcept1@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@00U?$integral_constant@_N$00@2@@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Umove_if_noexcept1

; 1608 :             bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
; 1609 :     }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@00@Z ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1595 :     void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1596 :         // move [_First, _Last) to raw _Dest, using allocator
; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UTABLE_RESET@@@2@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@YAPAUTABLE_RESET@@QAU1@0PAU1@AAV?$allocator@UTABLE_RESET@@@0@@Z ; std::_Uninitialized_move<TABLE_RESET *,std::allocator<TABLE_RESET> >
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 1598 :     }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEPAUTABLE_RESET@@PAU3@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEPAUTABLE_RESET@@PAU3@00@Z PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Umove, COMDAT
; _this$ = ecx

; 1591 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UTABLE_RESET@@@2@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@YAPAUTABLE_RESET@@QAU1@0PAU1@AAV?$allocator@UTABLE_RESET@@@0@@Z ; std::_Uninitialized_move<TABLE_RESET *,std::allocator<TABLE_RESET> >
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 1593 :     }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?_Umove@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEPAUTABLE_RESET@@PAU3@00@Z ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Umove
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?capacity@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QBEIXZ PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::capacity, COMDAT
; _this$ = ecx

; 1492 :     _NODISCARD size_type capacity() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001d	99		 cdq
  0001e	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00023	f7 f9		 idiv	 ecx

; 1495 :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?capacity@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QBEIXZ ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?max_size@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
_this$ = -4						; size = 4
?max_size@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QBEIXZ PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::max_size, COMDAT
; _this$ = ecx

; 1487 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1488 :         return (_STD min)(

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@ABEABV?$allocator@UTABLE_RESET@@@2@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Getal
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@UTABLE_RESET@@@std@@@std@@SAIABV?$allocator@UTABLE_RESET@@@2@@Z ; std::_Default_allocator_traits<std::allocator<TABLE_RESET> >::max_size
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
  00020	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00025	89 45 b4	 mov	 DWORD PTR $T1[ebp], eax
  00028	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  0002b	50		 push	 eax
  0002c	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00035	83 c4 08	 add	 esp, 8
  00038	8b 00		 mov	 eax, DWORD PTR [eax]

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?max_size@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QBEIXZ ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?empty@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv69 = -76						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?empty@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QBE_NXZ PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::empty, COMDAT
; _this$ = ecx

; 1477 :     _NODISCARD bool empty() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1478 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0001d	75 09		 jne	 SHORT $LN3@empty
  0001f	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN4@empty
$LN3@empty:
  00028	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@empty:
  0002f	8a 45 b4	 mov	 al, BYTE PTR tv69[ebp]

; 1480 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?empty@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QBE_NXZ ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?end@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@2@XZ PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::end, COMDAT
; _this$ = ecx

; 1419 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >
  0001b	83 c4 04	 add	 esp, 4
  0001e	50		 push	 eax
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00022	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00025	52		 push	 edx
  00026	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE@PAUTABLE_RESET@@PBU_Container_base0@1@@Z
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1422 :     }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?end@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@2@XZ ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?begin@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@2@XZ PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::begin, COMDAT
; _this$ = ecx

; 1409 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >
  0001b	83 c4 04	 add	 esp, 4
  0001e	50		 push	 eax
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	52		 push	 edx
  00025	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00028	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE@PAUTABLE_RESET@@PBU_Container_base0@1@@Z
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1412 :     }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?begin@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@2@XZ ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?clear@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Mylast$ = -28						; size = 4
__Myfirst$ = -24					; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?clear@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEXXZ PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?clear@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  00031	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00034	89 45 e8	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00037	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003a	83 c0 04	 add	 eax, 4
  0003d	89 45 e4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();

  00040	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00043	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1389 :         _Destroy(_Myfirst, _Mylast);

  00048	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	51		 push	 ecx
  0004e	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	50		 push	 eax
  00054	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXPAUTABLE_RESET@@0@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Destroy

; 1390 :         _Mylast = _Myfirst;

  0005c	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005f	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00062	8b 11		 mov	 edx, DWORD PTR [ecx]
  00064	89 10		 mov	 DWORD PTR [eax], edx

; 1391 :     }

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
  00078	cc		 int	 3
  00079	cc		 int	 3
  0007a	cc		 int	 3
  0007b	cc		 int	 3
  0007c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?clear@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?clear@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEXXZ ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::clear
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?push_back@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEXABUTABLE_RESET@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEXABUTABLE_RESET@@@Z PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::push_back, COMDAT
; _this$ = ecx

; 716  :     void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 717  :         emplace_back(_Val);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$emplace_back@ABUTABLE_RESET@@@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE@ABUTABLE_RESET@@@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::emplace_back<TABLE_RESET const &>

; 718  :     }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?push_back@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEXABUTABLE_RESET@@@Z ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE@XZ PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::~vector<TABLE_RESET,std::allocator<TABLE_RESET> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@AAEXXZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE@XZ ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::~vector<TABLE_RESET,std::allocator<TABLE_RESET> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -70						; size = 1
$T2 = -69						; size = 1
_this$ = -4						; size = 4
??0?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE@XZ PROC ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::vector<TABLE_RESET,std::allocator<TABLE_RESET> >, COMDAT
; _this$ = ecx

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	0f b6 45 bb	 movzx	 eax, BYTE PTR $T2[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@UTABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<TABLE_RESET>,std::_Vector_val<std::_Simple_types<TABLE_RESET> >,1>::_Compressed_pair<std::allocator<TABLE_RESET>,std::_Vector_val<std::_Simple_types<TABLE_RESET> >,1><>

; 446  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00019	8d 45 ba	 lea	 eax, DWORD PTR $T1[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 447  :     }

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??0?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE@XZ ENDP ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::vector<TABLE_RESET,std::allocator<TABLE_RESET> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UTABLE_RESET@@@std@@@std@@SAIABV?$allocator@UTABLE_RESET@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@UTABLE_RESET@@@std@@@std@@SAIABV?$allocator@UTABLE_RESET@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<TABLE_RESET> >::max_size, COMDAT

; 702  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 703  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00009	b8 44 44 44 04	 mov	 eax, 71582788		; 04444444H

; 704  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@UTABLE_RESET@@@std@@@std@@SAIABV?$allocator@UTABLE_RESET@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<TABLE_RESET> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?allocate@?$allocator@UTABLE_RESET@@@std@@QAEPAUTABLE_RESET@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UTABLE_RESET@@@std@@QAEPAUTABLE_RESET@@I@Z PROC ; std::allocator<TABLE_RESET>::allocate, COMDAT
; _this$ = ecx

; 806  :     _NODISCARD __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0DM@@std@@YAII@Z ; std::_Get_size_of_n<60>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0001e	83 c4 04	 add	 esp, 4

; 808  :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$allocator@UTABLE_RESET@@@std@@QAEPAUTABLE_RESET@@I@Z ENDP ; std::allocator<TABLE_RESET>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@UTABLE_RESET@@@std@@QAEXQAUTABLE_RESET@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UTABLE_RESET@@@std@@QAEXQAUTABLE_RESET@@I@Z PROC ; std::allocator<TABLE_RESET>::deallocate, COMDAT
; _this$ = ecx

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000c	6b 45 0c 3c	 imul	 eax, DWORD PTR __Count$[ebp], 60
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001a	83 c4 08	 add	 esp, 8

; 804  :     }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?deallocate@?$allocator@UTABLE_RESET@@@std@@QAEXQAUTABLE_RESET@@I@Z ENDP ; std::allocator<TABLE_RESET>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@UTABLE_RESET@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UTABLE_RESET@@@std@@QAE@XZ PROC		; std::allocator<TABLE_RESET>::allocator<TABLE_RESET>, COMDAT
; _this$ = ecx

; 795  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UTABLE_RESET@@@std@@QAE@XZ ENDP		; std::allocator<TABLE_RESET>::allocator<TABLE_RESET>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UNON_TABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@2@$00@std@@QBEABV?$allocator@UNON_TABLE_RESET@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@UNON_TABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@2@$00@std@@QBEABV?$allocator@UNON_TABLE_RESET@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<NON_TABLE_RESET>,std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1347 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1348 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1349 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@UNON_TABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@2@$00@std@@QBEABV?$allocator@UNON_TABLE_RESET@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<NON_TABLE_RESET>,std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@UNON_TABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@2@$00@std@@QAEAAV?$allocator@UNON_TABLE_RESET@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@UNON_TABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@2@$00@std@@QAEAAV?$allocator@UNON_TABLE_RESET@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<NON_TABLE_RESET>,std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1343 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1344 :         return *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1345 :     }

  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@UNON_TABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@2@$00@std@@QAEAAV?$allocator@UNON_TABLE_RESET@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<NON_TABLE_RESET>,std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@ABEABV?$allocator@UNON_TABLE_RESET@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@ABEABV?$allocator@UNON_TABLE_RESET@@@2@XZ PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Getal, COMDAT
; _this$ = ecx

; 1735 :     const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1736 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@UNON_TABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@2@$00@std@@QBEABV?$allocator@UNON_TABLE_RESET@@@2@XZ ; std::_Compressed_pair<std::allocator<NON_TABLE_RESET>,std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >,1>::_Get_first

; 1737 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@ABEABV?$allocator@UNON_TABLE_RESET@@@2@XZ ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Getal@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UNON_TABLE_RESET@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UNON_TABLE_RESET@@@2@XZ PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Getal, COMDAT
; _this$ = ecx

; 1731 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1732 :         return _Mypair._Get_first();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@UNON_TABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@2@$00@std@@QAEAAV?$allocator@UNON_TABLE_RESET@@@2@XZ ; std::_Compressed_pair<std::allocator<NON_TABLE_RESET>,std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >,1>::_Get_first

; 1733 :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Getal@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UNON_TABLE_RESET@@@2@XZ ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Orphan_range@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@ABEXPAUNON_TABLE_RESET@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@ABEXPAUNON_TABLE_RESET@@0@Z PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1711 :     void _Orphan_range(pointer _First, pointer _Last) const { // orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1712 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1713 :         _Lockit _Lock(_LOCK_DEBUG);
; 1714 : 
; 1715 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;
; 1716 :         while (*_Pnext) {
; 1717 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;
; 1718 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator
; 1719 :                 _Pnext = &(*_Pnext)->_Mynextiter;
; 1720 :             } else { // orphan the iterator
; 1721 :                 (*_Pnext)->_Myproxy = nullptr;
; 1722 :                 *_Pnext             = (*_Pnext)->_Mynextiter;
; 1723 :             }
; 1724 :         }
; 1725 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1726 :         (void) _First;
; 1727 :         (void) _Last;
; 1728 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1729 :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@ABEXPAUNON_TABLE_RESET@@0@Z ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Xlength@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@CAXXZ PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Xlength, COMDAT

; 1703 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1704 :         _Xlength_error("vector too long");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  0000e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1705 :     }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Xlength@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@CAXXZ ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Tidy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -32						; size = 4
__Mylast$ = -28						; size = 4
__Myfirst$ = -24					; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXXZ PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Tidy, COMDAT
; _this$ = ecx

; 1685 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1686 :         auto& _My_data    = _Mypair._Myval2;

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 1687 :         pointer& _Myfirst = _My_data._Myfirst;

  00031	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00034	89 45 e8	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1688 :         pointer& _Mylast  = _My_data._Mylast;

  00037	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003a	83 c0 04	 add	 eax, 4
  0003d	89 45 e4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1689 :         pointer& _Myend   = _My_data._Myend;

  00040	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00043	83 c0 08	 add	 eax, 8
  00046	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1690 : 
; 1691 :         _My_data._Orphan_all();

  00049	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1692 : 
; 1693 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00054	83 38 00	 cmp	 DWORD PTR [eax], 0
  00057	74 57		 je	 SHORT $LN3@Tidy

; 1694 :             _Destroy(_Myfirst, _Mylast);

  00059	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	51		 push	 ecx
  0005f	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00062	8b 02		 mov	 eax, DWORD PTR [edx]
  00064	50		 push	 eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@0@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Destroy

; 1695 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0006d	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00070	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00073	8b 00		 mov	 eax, DWORD PTR [eax]
  00075	2b 01		 sub	 eax, DWORD PTR [ecx]
  00077	99		 cdq
  00078	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  0007d	f7 f9		 idiv	 ecx
  0007f	50		 push	 eax
  00080	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
  00085	50		 push	 eax
  00086	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?_Getal@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UNON_TABLE_RESET@@@2@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Getal
  0008e	8b c8		 mov	 ecx, eax
  00090	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UNON_TABLE_RESET@@@std@@QAEXQAUNON_TABLE_RESET@@I@Z ; std::allocator<NON_TABLE_RESET>::deallocate

; 1696 : 
; 1697 :             _Myfirst = pointer();

  00095	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00098	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1698 :             _Mylast  = pointer();

  0009e	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a1	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1699 :             _Myend   = pointer();

  000a7	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000aa	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1700 :         }
; 1701 :     }

  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ba	59		 pop	 ecx
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
  000c2	cc		 int	 3
  000c3	cc		 int	 3
  000c4	cc		 int	 3
  000c5	cc		 int	 3
  000c6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXXZ ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Tidy
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Change_array@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXQAUNON_TABLE_RESET@@II@Z
_TEXT	SEGMENT
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
__Myfirst$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXQAUNON_TABLE_RESET@@II@Z PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Change_array, COMDAT
; _this$ = ecx

; 1666 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1667 :         // orphan all iterators, discard old array, acquire new array
; 1668 :         auto& _My_data    = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1669 :         pointer& _Myfirst = _My_data._Myfirst;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1670 :         pointer& _Mylast  = _My_data._Mylast;

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001b	83 c0 04	 add	 eax, 4
  0001e	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1671 :         pointer& _Myend   = _My_data._Myend;

  00021	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00024	83 c0 08	 add	 eax, 8
  00027	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1672 : 
; 1673 :         _My_data._Orphan_all();

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1674 : 
; 1675 :         if (_Myfirst) { // destroy and deallocate old array

  00032	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00035	83 38 00	 cmp	 DWORD PTR [eax], 0
  00038	74 3c		 je	 SHORT $LN2@Change_arr

; 1676 :             _Destroy(_Myfirst, _Mylast);

  0003a	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	51		 push	 ecx
  00040	8b 55 f4	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00043	8b 02		 mov	 eax, DWORD PTR [edx]
  00045	50		 push	 eax
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@0@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Destroy

; 1677 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0004e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]
  00056	2b 01		 sub	 eax, DWORD PTR [ecx]
  00058	99		 cdq
  00059	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  0005e	f7 f9		 idiv	 ecx
  00060	50		 push	 eax
  00061	8b 55 f4	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00064	8b 02		 mov	 eax, DWORD PTR [edx]
  00066	50		 push	 eax
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?_Getal@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UNON_TABLE_RESET@@@2@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Getal
  0006f	8b c8		 mov	 ecx, eax
  00071	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UNON_TABLE_RESET@@@std@@QAEXQAUNON_TABLE_RESET@@I@Z ; std::allocator<NON_TABLE_RESET>::deallocate
$LN2@Change_arr:

; 1678 :         }
; 1679 : 
; 1680 :         _Myfirst = _Newvec;

  00076	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00079	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0007c	89 08		 mov	 DWORD PTR [eax], ecx

; 1681 :         _Mylast  = _Newvec + _Newsize;

  0007e	6b 45 0c 34	 imul	 eax, DWORD PTR __Newsize$[ebp], 52
  00082	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  00085	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00088	89 01		 mov	 DWORD PTR [ecx], eax

; 1682 :         _Myend   = _Newvec + _Newcapacity;

  0008a	6b 45 10 34	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 52
  0008e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  00091	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  00094	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :     }

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXQAUNON_TABLE_RESET@@II@Z ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Geometric$ = -12					; size = 4
__Oldcapacity$ = -8					; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@ABEII@Z PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?capacity@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QBEIXZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::capacity
  00014	89 45 f8	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1618 : 
; 1619 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?max_size@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QBEIXZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::max_size
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __Oldcapacity$[ebp]
  00022	d1 e9		 shr	 ecx, 1
  00024	2b c1		 sub	 eax, ecx
  00026	39 45 f8	 cmp	 DWORD PTR __Oldcapacity$[ebp], eax
  00029	76 05		 jbe	 SHORT $LN2@Calculate_

; 1620 :             return _Newsize; // geometric growth would overflow

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0002e	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1621 :         }
; 1622 : 
; 1623 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00030	8b 45 f8	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 f8	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00038	89 45 f4	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1624 : 
; 1625 :         if (_Geometric < _Newsize) {

  0003b	8b 45 f4	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0003e	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00041	73 05		 jae	 SHORT $LN3@Calculate_

; 1626 :             return _Newsize; // geometric growth would be insufficient

  00043	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00046	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1627 :         }
; 1628 : 
; 1629 :         return _Geometric; // geometric growth is sufficient

  00048	8b 45 f4	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1630 :     }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@ABEII@Z ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Destroy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@0@Z PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UNON_TABLE_RESET@@@2@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@YAXPAUNON_TABLE_RESET@@QAU1@AAV?$allocator@UNON_TABLE_RESET@@@0@@Z ; std::_Destroy_range<std::allocator<NON_TABLE_RESET> >
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?_Destroy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@0@Z ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@00@Z
_TEXT	SEGMENT
$T1 = -69						; size = 1
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@00@Z PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1605 :     void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1606 :         // move_if_noexcept [_First, _Last) to raw _Dest, using allocator
; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  0000c	33 c0		 xor	 eax, eax
  0000e	88 45 bb	 mov	 BYTE PTR $T1[ebp], al
  00011	0f b6 4d bb	 movzx	 ecx, BYTE PTR $T1[ebp]
  00015	51		 push	 ecx
  00016	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00019	52		 push	 edx
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00021	51		 push	 ecx
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Umove_if_noexcept1@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@00U?$integral_constant@_N$00@2@@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Umove_if_noexcept1

; 1608 :             bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
; 1609 :     }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@00@Z ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1595 :     void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1596 :         // move [_First, _Last) to raw _Dest, using allocator
; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UNON_TABLE_RESET@@@2@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@YAPAUNON_TABLE_RESET@@QAU1@0PAU1@AAV?$allocator@UNON_TABLE_RESET@@@0@@Z ; std::_Uninitialized_move<NON_TABLE_RESET *,std::allocator<NON_TABLE_RESET> >
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 1598 :     }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?_Umove@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEPAUNON_TABLE_RESET@@PAU3@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEPAUNON_TABLE_RESET@@PAU3@00@Z PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Umove, COMDAT
; _this$ = ecx

; 1591 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEAAV?$allocator@UNON_TABLE_RESET@@@2@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Getal
  00014	50		 push	 eax
  00015	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@YAPAUNON_TABLE_RESET@@QAU1@0PAU1@AAV?$allocator@UNON_TABLE_RESET@@@0@@Z ; std::_Uninitialized_move<NON_TABLE_RESET *,std::allocator<NON_TABLE_RESET> >
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 1593 :     }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
?_Umove@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEPAUNON_TABLE_RESET@@PAU3@00@Z ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Umove
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?capacity@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QBEIXZ PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::capacity, COMDAT
; _this$ = ecx

; 1492 :     _NODISCARD size_type capacity() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00018	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001d	99		 cdq
  0001e	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00023	f7 f9		 idiv	 ecx

; 1495 :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?capacity@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QBEIXZ ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?max_size@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
_this$ = -4						; size = 4
?max_size@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QBEIXZ PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::max_size, COMDAT
; _this$ = ecx

; 1487 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1488 :         return (_STD min)(

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Getal@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@ABEABV?$allocator@UNON_TABLE_RESET@@@2@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Getal
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@SAIABV?$allocator@UNON_TABLE_RESET@@@2@@Z ; std::_Default_allocator_traits<std::allocator<NON_TABLE_RESET> >::max_size
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
  00020	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00025	89 45 b4	 mov	 DWORD PTR $T1[ebp], eax
  00028	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  0002b	50		 push	 eax
  0002c	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00035	83 c4 08	 add	 esp, 8
  00038	8b 00		 mov	 eax, DWORD PTR [eax]

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?max_size@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QBEIXZ ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?empty@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv69 = -76						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?empty@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QBE_NXZ PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::empty, COMDAT
; _this$ = ecx

; 1477 :     _NODISCARD bool empty() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1478 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0001d	75 09		 jne	 SHORT $LN3@empty
  0001f	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN4@empty
$LN3@empty:
  00028	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@empty:
  0002f	8a 45 b4	 mov	 al, BYTE PTR tv69[ebp]

; 1480 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?empty@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QBE_NXZ ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?end@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@2@XZ PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::end, COMDAT
; _this$ = ecx

; 1419 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >
  0001b	83 c4 04	 add	 esp, 4
  0001e	50		 push	 eax
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00022	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00025	52		 push	 edx
  00026	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE@PAUNON_TABLE_RESET@@PBU_Container_base0@1@@Z
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1422 :     }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?end@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@2@XZ ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?begin@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@2@XZ PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::begin, COMDAT
; _this$ = ecx

; 1409 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >
  0001b	83 c4 04	 add	 esp, 4
  0001e	50		 push	 eax
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	52		 push	 edx
  00025	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00028	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE@PAUNON_TABLE_RESET@@PBU_Container_base0@1@@Z
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1412 :     }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?begin@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@2@XZ ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?clear@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Mylast$ = -28						; size = 4
__Myfirst$ = -24					; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?clear@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEXXZ PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?clear@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  00031	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00034	89 45 e8	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00037	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003a	83 c0 04	 add	 eax, 4
  0003d	89 45 e4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();

  00040	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00043	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1389 :         _Destroy(_Myfirst, _Mylast);

  00048	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	51		 push	 ecx
  0004e	8b 55 e8	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	50		 push	 eax
  00054	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXPAUNON_TABLE_RESET@@0@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Destroy

; 1390 :         _Mylast = _Myfirst;

  0005c	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005f	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00062	8b 11		 mov	 edx, DWORD PTR [ecx]
  00064	89 10		 mov	 DWORD PTR [eax], edx

; 1391 :     }

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
  00078	cc		 int	 3
  00079	cc		 int	 3
  0007a	cc		 int	 3
  0007b	cc		 int	 3
  0007c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?clear@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?clear@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEXXZ ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::clear
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ?push_back@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEXABUNON_TABLE_RESET@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEXABUNON_TABLE_RESET@@@Z PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::push_back, COMDAT
; _this$ = ecx

; 716  :     void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 717  :         emplace_back(_Val);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$emplace_back@ABUNON_TABLE_RESET@@@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE@ABUNON_TABLE_RESET@@@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::emplace_back<NON_TABLE_RESET const &>

; 718  :     }

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?push_back@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEXABUNON_TABLE_RESET@@@Z ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??1?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE@XZ PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::~vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@AAEXXZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE@XZ ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::~vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vector
;	COMDAT ??0?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -70						; size = 1
$T2 = -69						; size = 1
_this$ = -4						; size = 4
??0?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE@XZ PROC ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >, COMDAT
; _this$ = ecx

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	0f b6 45 bb	 movzx	 eax, BYTE PTR $T2[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@UNON_TABLE_RESET@@@std@@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<NON_TABLE_RESET>,std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >,1>::_Compressed_pair<std::allocator<NON_TABLE_RESET>,std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> >,1><>

; 446  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00019	8d 45 ba	 lea	 eax, DWORD PTR $T1[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 447  :     }

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??0?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE@XZ ENDP ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@SAIABV?$allocator@UNON_TABLE_RESET@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@SAIABV?$allocator@UNON_TABLE_RESET@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<NON_TABLE_RESET> >::max_size, COMDAT

; 702  :     _NODISCARD static size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 703  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00009	b8 c4 4e ec 04	 mov	 eax, 82595524		; 04ec4ec4H

; 704  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@SAIABV?$allocator@UNON_TABLE_RESET@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<NON_TABLE_RESET> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?allocate@?$allocator@UNON_TABLE_RESET@@@std@@QAEPAUNON_TABLE_RESET@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UNON_TABLE_RESET@@@std@@QAEPAUNON_TABLE_RESET@@I@Z PROC ; std::allocator<NON_TABLE_RESET>::allocate, COMDAT
; _this$ = ecx

; 806  :     _NODISCARD __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 807  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0DE@@std@@YAII@Z ; std::_Get_size_of_n<52>
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0001e	83 c4 04	 add	 esp, 4

; 808  :     }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?allocate@?$allocator@UNON_TABLE_RESET@@@std@@QAEPAUNON_TABLE_RESET@@I@Z ENDP ; std::allocator<NON_TABLE_RESET>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?deallocate@?$allocator@UNON_TABLE_RESET@@@std@@QAEXQAUNON_TABLE_RESET@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UNON_TABLE_RESET@@@std@@QAEXQAUNON_TABLE_RESET@@I@Z PROC ; std::allocator<NON_TABLE_RESET>::deallocate, COMDAT
; _this$ = ecx

; 801  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 803  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000c	6b 45 0c 34	 imul	 eax, DWORD PTR __Count$[ebp], 52
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001a	83 c4 08	 add	 esp, 8

; 804  :     }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?deallocate@?$allocator@UNON_TABLE_RESET@@@std@@QAEXQAUNON_TABLE_RESET@@I@Z ENDP ; std::allocator<NON_TABLE_RESET>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0?$allocator@UNON_TABLE_RESET@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UNON_TABLE_RESET@@@std@@QAE@XZ PROC	; std::allocator<NON_TABLE_RESET>::allocator<NON_TABLE_RESET>, COMDAT
; _this$ = ecx

; 795  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@UNON_TABLE_RESET@@@std@@QAE@XZ ENDP	; std::allocator<NON_TABLE_RESET>::allocator<NON_TABLE_RESET>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?ClearMagicList@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_s_pos$1 = -20						; size = 4
_lpItem$2 = -16						; size = 4
_n$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?ClearMagicList@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z PROC ; CResetSystem::ClearMagicList, COMDAT
; _this$ = ecx

; 1221 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1222 : 	int i;
; 1223 : 	int n;
; 1224 : 
; 1225 : 	for(i = 0; i < MAX_MAGIC; i++) //Clear all the magic first

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@ClearMagic
$LN2@ClearMagic:
  00015	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@ClearMagic:
  0001e	83 7d f8 3c	 cmp	 DWORD PTR _i$[ebp], 60	; 0000003cH
  00022	7d 6e		 jge	 SHORT $LN3@ClearMagic

; 1226 : 	{
; 1227 : 		if(lpObj->Magic[i].IsMagic() == TRUE )

  00024	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00027	c1 e1 04	 shl	 ecx, 4
  0002a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002d	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  00033	e8 00 00 00 00	 call	 ?IsMagic@CMagicInf@@QAEHXZ ; CMagicInf::IsMagic
  00038	83 f8 01	 cmp	 eax, 1
  0003b	75 53		 jne	 SHORT $LN8@ClearMagic

; 1228 : 		{
; 1229 : 			::GCMagicListOneDelSend(lpObj->m_Index, i, lpObj->Magic[i].m_Skill, lpObj->Magic[i].m_Level, 0);

  0003d	6a 00		 push	 0
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00042	c1 e0 04	 shl	 eax, 4
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00048	8b 91 10 03 00
	00		 mov	 edx, DWORD PTR [ecx+784]
  0004e	0f b6 44 02 04	 movzx	 eax, BYTE PTR [edx+eax+4]
  00053	50		 push	 eax
  00054	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00057	c1 e1 04	 shl	 ecx, 4
  0005a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0005d	8b 82 10 03 00
	00		 mov	 eax, DWORD PTR [edx+784]
  00063	0f b6 4c 08 05	 movzx	 ecx, BYTE PTR [eax+ecx+5]
  00068	51		 push	 ecx
  00069	0f b6 55 f8	 movzx	 edx, BYTE PTR _i$[ebp]
  0006d	52		 push	 edx
  0006e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ?GCMagicListOneDelSend@@YAXHDEEE@Z ; GCMagicListOneDelSend
  00079	83 c4 14	 add	 esp, 20			; 00000014H

; 1230 : 			lpObj->Magic[i].Clear();

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0007f	c1 e1 04	 shl	 ecx, 4
  00082	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00085	03 88 10 03 00
	00		 add	 ecx, DWORD PTR [eax+784]
  0008b	e8 00 00 00 00	 call	 ?Clear@CMagicInf@@QAEXXZ ; CMagicInf::Clear
$LN8@ClearMagic:

; 1231 : 		}
; 1232 : 	}

  00090	eb 83		 jmp	 SHORT $LN2@ClearMagic
$LN3@ClearMagic:

; 1233 : 
; 1234 : 	if ( lpObj->Class == CLASS_WIZARD || lpObj->Class == CLASS_ELF || lpObj->Class == CLASS_KNIGHT || lpObj->Class == CLASS_MAGUMSA ) //Re-create all the default Skills and Non_Scroll(Quest) Skill

  00092	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00095	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  0009c	85 c9		 test	 ecx, ecx
  0009e	74 2d		 je	 SHORT $LN10@ClearMagic
  000a0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a3	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000aa	83 f9 02	 cmp	 ecx, 2
  000ad	74 1e		 je	 SHORT $LN10@ClearMagic
  000af	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b2	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000b9	83 f9 01	 cmp	 ecx, 1
  000bc	74 0f		 je	 SHORT $LN10@ClearMagic
  000be	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c1	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000c8	83 f9 03	 cmp	 ecx, 3
  000cb	75 32		 jne	 SHORT $LN9@ClearMagic
$LN10@ClearMagic:

; 1235 : 	{
; 1236 : 		gObjMagicAddEnergyCheckOnOff(FALSE);

  000cd	6a 00		 push	 0
  000cf	e8 00 00 00 00	 call	 ?gObjMagicAddEnergyCheckOnOff@@YAXH@Z ; gObjMagicAddEnergyCheckOnOff
  000d4	83 c4 04	 add	 esp, 4

; 1237 : 
; 1238 : 		if ( lpObj->Class == CLASS_WIZARD )

  000d7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000da	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000e1	85 c9		 test	 ecx, ecx
  000e3	75 10		 jne	 SHORT $LN11@ClearMagic

; 1239 : 		{
; 1240 : 			gObjMagicAdd(lpObj, 17, 0);

  000e5	6a 00		 push	 0
  000e7	6a 11		 push	 17			; 00000011H
  000e9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ec	50		 push	 eax
  000ed	e8 00 00 00 00	 call	 ?gObjMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjMagicAdd
  000f2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@ClearMagic:

; 1241 : 		}
; 1242 : 
; 1243 : 		::gObjMagicAddEnergyCheckOnOff(TRUE);

  000f5	6a 01		 push	 1
  000f7	e8 00 00 00 00	 call	 ?gObjMagicAddEnergyCheckOnOff@@YAXH@Z ; gObjMagicAddEnergyCheckOnOff
  000fc	83 c4 04	 add	 esp, 4
$LN9@ClearMagic:

; 1244 : 	}
; 1245 : 
; 1246 : 	::GCMagicListMultiSend(lpObj); //Send the Info to MuClient

  000ff	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00102	50		 push	 eax
  00103	e8 00 00 00 00	 call	 ?GCMagicListMultiSend@@YAXPAVOBJECTSTRUCT@@@Z ; GCMagicListMultiSend
  00108	83 c4 04	 add	 esp, 4

; 1247 : 
; 1248 : 	for(n = 0; n < 11; n++) //Re-create the Equiped Weapon Skill

  0010b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  00112	eb 09		 jmp	 SHORT $LN7@ClearMagic
$LN5@ClearMagic:
  00114	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00117	83 c0 01	 add	 eax, 1
  0011a	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
$LN7@ClearMagic:
  0011d	83 7d f4 0b	 cmp	 DWORD PTR _n$[ebp], 11	; 0000000bH
  00121	0f 8d 99 00 00
	00		 jge	 $LN1@ClearMagic

; 1249 : 	{
; 1250 : 		if(lpObj->pInventory[n].IsItem() == TRUE)

  00127	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$[ebp], 168
  0012e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00131	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00137	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0013c	83 f8 01	 cmp	 eax, 1
  0013f	75 7a		 jne	 SHORT $LN12@ClearMagic

; 1251 : 		{
; 1252 : 			CItem * lpItem = &lpObj->pInventory[n];

  00141	69 45 f4 a8 00
	00 00		 imul	 eax, DWORD PTR _n$[ebp], 168
  00148	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0014b	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  00151	89 45 f0	 mov	 DWORD PTR _lpItem$2[ebp], eax

; 1253 : 
; 1254 : 			if(lpItem->m_Option1)

  00154	8b 45 f0	 mov	 eax, DWORD PTR _lpItem$2[ebp]
  00157	0f b6 48 78	 movzx	 ecx, BYTE PTR [eax+120]
  0015b	85 c9		 test	 ecx, ecx
  0015d	74 5c		 je	 SHORT $LN12@ClearMagic

; 1255 : 			{
; 1256 : 				int s_pos = gObjWeaponMagicAdd(lpObj,lpItem->m_Special[0],lpItem->m_Level);

  0015f	8b 45 f0	 mov	 eax, DWORD PTR _lpItem$2[ebp]
  00162	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00166	51		 push	 ecx
  00167	ba 01 00 00 00	 mov	 edx, 1
  0016c	6b c2 00	 imul	 eax, edx, 0
  0016f	8b 4d f0	 mov	 ecx, DWORD PTR _lpItem$2[ebp]
  00172	0f b6 54 01 31	 movzx	 edx, BYTE PTR [ecx+eax+49]
  00177	52		 push	 edx
  00178	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0017b	50		 push	 eax
  0017c	e8 00 00 00 00	 call	 ?gObjWeaponMagicAdd@@YAHPAVOBJECTSTRUCT@@EE@Z ; gObjWeaponMagicAdd
  00181	83 c4 0c	 add	 esp, 12			; 0000000cH
  00184	89 45 ec	 mov	 DWORD PTR _s_pos$1[ebp], eax

; 1257 : 
; 1258 : 				if(s_pos >= 0)

  00187	83 7d ec 00	 cmp	 DWORD PTR _s_pos$1[ebp], 0
  0018b	7c 2e		 jl	 SHORT $LN12@ClearMagic

; 1259 : 				{
; 1260 : 					::GCMagicListOneSend(lpObj->m_Index,s_pos,lpItem->m_Special[0],lpItem->m_Level,0);

  0018d	6a 00		 push	 0
  0018f	8b 45 f0	 mov	 eax, DWORD PTR _lpItem$2[ebp]
  00192	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00196	51		 push	 ecx
  00197	ba 01 00 00 00	 mov	 edx, 1
  0019c	6b c2 00	 imul	 eax, edx, 0
  0019f	8b 4d f0	 mov	 ecx, DWORD PTR _lpItem$2[ebp]
  001a2	0f b6 54 01 31	 movzx	 edx, BYTE PTR [ecx+eax+49]
  001a7	52		 push	 edx
  001a8	0f b6 45 ec	 movzx	 eax, BYTE PTR _s_pos$1[ebp]
  001ac	50		 push	 eax
  001ad	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001b0	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b2	52		 push	 edx
  001b3	e8 00 00 00 00	 call	 ?GCMagicListOneSend@@YAXHDEEE@Z ; GCMagicListOneSend
  001b8	83 c4 14	 add	 esp, 20			; 00000014H
$LN12@ClearMagic:

; 1261 : 				}
; 1262 : 			}
; 1263 : 		}
; 1264 : 	}

  001bb	e9 54 ff ff ff	 jmp	 $LN5@ClearMagic
$LN1@ClearMagic:

; 1265 : }

  001c0	5f		 pop	 edi
  001c1	5e		 pop	 esi
  001c2	5b		 pop	 ebx
  001c3	8b e5		 mov	 esp, ebp
  001c5	5d		 pop	 ebp
  001c6	c2 04 00	 ret	 4
?ClearMagicList@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ENDP ; CResetSystem::ClearMagicList
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?CheckUserEquipment@CResetSystem@@QAEHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pos$1 = -12						; size = 4
_bFind$ = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?CheckUserEquipment@CResetSystem@@QAEHPAVOBJECTSTRUCT@@@Z PROC ; CResetSystem::CheckUserEquipment, COMDAT
; _this$ = ecx

; 1197 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1198 : 	//EnterCriticalSection(&this->m_cs);
; 1199 : 
; 1200 : 	BOOL bFind = FALSE;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bFind$[ebp], 0

; 1201 : 
; 1202 : 	for ( int pos = 0; pos < 11; pos++)

  00013	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pos$1[ebp], 0
  0001a	eb 09		 jmp	 SHORT $LN4@CheckUserE
$LN2@CheckUserE:
  0001c	8b 45 f4	 mov	 eax, DWORD PTR _pos$1[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 f4	 mov	 DWORD PTR _pos$1[ebp], eax
$LN4@CheckUserE:
  00025	83 7d f4 0b	 cmp	 DWORD PTR _pos$1[ebp], 11 ; 0000000bH
  00029	7d 23		 jge	 SHORT $LN3@CheckUserE

; 1203 : 	{
; 1204 : 		if(lpObj->pInventory[pos].IsItem() == TRUE)

  0002b	69 4d f4 a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$1[ebp], 168
  00032	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00035	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  0003b	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00040	83 f8 01	 cmp	 eax, 1
  00043	75 07		 jne	 SHORT $LN5@CheckUserE

; 1205 : 		{
; 1206 : 			bFind = TRUE;

  00045	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bFind$[ebp], 1
$LN5@CheckUserE:

; 1207 : 		}
; 1208 : 	}

  0004c	eb ce		 jmp	 SHORT $LN2@CheckUserE
$LN3@CheckUserE:

; 1209 : 
; 1210 : 	//LeaveCriticalSection(&this->m_cs);
; 1211 : 
; 1212 : 	if(bFind == TRUE)

  0004e	83 7d f8 01	 cmp	 DWORD PTR _bFind$[ebp], 1
  00052	75 04		 jne	 SHORT $LN6@CheckUserE

; 1213 : 	{
; 1214 : 		return FALSE;

  00054	33 c0		 xor	 eax, eax
  00056	eb 05		 jmp	 SHORT $LN1@CheckUserE
$LN6@CheckUserE:

; 1215 : 	}
; 1216 : 
; 1217 : 	return TRUE;

  00058	b8 01 00 00 00	 mov	 eax, 1
$LN1@CheckUserE:

; 1218 : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
?CheckUserEquipment@CResetSystem@@QAEHPAVOBJECTSTRUCT@@@Z ENDP ; CResetSystem::CheckUserEquipment
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?GetNPCResetData@CResetSystem@@QAEHH@Z
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
_this$ = -4						; size = 4
_iIndex$ = 8						; size = 4
?GetNPCResetData@CResetSystem@@QAEHH@Z PROC		; CResetSystem::GetNPCResetData, COMDAT
; _this$ = ecx

; 1187 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1188 : 	if(m_mNpcData.find(iIndex) != m_mNpcData.end())

  0000c	8d 45 b4	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 68	 add	 ecx, 104		; 00000068H
  00016	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::end
  0001b	50		 push	 eax
  0001c	8d 4d 08	 lea	 ecx, DWORD PTR _iIndex$[ebp]
  0001f	51		 push	 ecx
  00020	8d 55 b8	 lea	 edx, DWORD PTR $T2[ebp]
  00023	52		 push	 edx
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	83 c1 68	 add	 ecx, 104		; 00000068H
  0002a	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::find
  0002f	8b c8		 mov	 ecx, eax
  00031	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator!=
  00036	0f b6 c0	 movzx	 eax, al
  00039	85 c0		 test	 eax, eax
  0003b	74 07		 je	 SHORT $LN2@GetNPCRese

; 1189 : 	{
; 1190 : 		return TRUE;

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	eb 02		 jmp	 SHORT $LN1@GetNPCRese
$LN2@GetNPCRese:

; 1191 : 	}
; 1192 : 
; 1193 : 	return FALSE;

  00044	33 c0		 xor	 eax, eax
$LN1@GetNPCRese:

; 1194 : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?GetNPCResetData@CResetSystem@@QAEHH@Z ENDP		; CResetSystem::GetNPCResetData
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?ClearResetNPCData@CResetSystem@@QAEXXZ
_TEXT	SEGMENT
$T1 = -80						; size = 4
$T2 = -76						; size = 4
_it$3 = -8						; size = 4
_this$ = -4						; size = 4
?ClearResetNPCData@CResetSystem@@QAEXXZ PROC		; CResetSystem::ClearResetNPCData, COMDAT
; _this$ = ecx

; 1177 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1178 : 	for(NPC_DATA_MAP::iterator it = m_mNpcData.begin();it != m_mNpcData.end();)

  0000c	8d 45 f8	 lea	 eax, DWORD PTR _it$3[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 68	 add	 ecx, 104		; 00000068H
  00016	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::begin
$LN4@ClearReset:
  0001b	8d 45 b4	 lea	 eax, DWORD PTR $T2[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 c1 68	 add	 ecx, 104		; 00000068H
  00025	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::end
  0002a	50		 push	 eax
  0002b	8d 4d f8	 lea	 ecx, DWORD PTR _it$3[ebp]
  0002e	e8 00 00 00 00	 call	 ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator!=
  00033	0f b6 c8	 movzx	 ecx, al
  00036	85 c9		 test	 ecx, ecx
  00038	74 46		 je	 SHORT $LN1@ClearReset

; 1179 : 	{
; 1180 : 		LogAddTD("[Reset System] To Delete Npc : Index(%d)", it->first);

  0003a	8d 4d f8	 lea	 ecx, DWORD PTR _it$3[ebp]
  0003d	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHUNPC_DATA@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator->
  00042	8b 00		 mov	 eax, DWORD PTR [eax]
  00044	50		 push	 eax
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@FMODDEJG@?$FLReset?5System?$FN?5To?5Delete?5Npc?5?3?5@
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00050	83 c4 08	 add	 esp, 8

; 1181 : 		gObjDel(it->first);

  00053	8d 4d f8	 lea	 ecx, DWORD PTR _it$3[ebp]
  00056	e8 00 00 00 00	 call	 ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@QBEPAU?$pair@$$CBHUNPC_DATA@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >::operator->
  0005b	8b 00		 mov	 eax, DWORD PTR [eax]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00063	83 c4 04	 add	 esp, 4

; 1182 : 		it = m_mNpcData.erase(it);

  00066	8b 45 f8	 mov	 eax, DWORD PTR _it$3[ebp]
  00069	50		 push	 eax
  0006a	8d 4d b0	 lea	 ecx, DWORD PTR $T1[ebp]
  0006d	51		 push	 ecx
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	83 c1 68	 add	 ecx, 104		; 00000068H
  00074	e8 00 00 00 00	 call	 ??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@1@V21@@Z ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::erase<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,NPC_DATA> > > >,0>
  00079	8b 10		 mov	 edx, DWORD PTR [eax]
  0007b	89 55 f8	 mov	 DWORD PTR _it$3[ebp], edx

; 1183 : 	}

  0007e	eb 9b		 jmp	 SHORT $LN4@ClearReset
$LN1@ClearReset:

; 1184 : }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
?ClearResetNPCData@CResetSystem@@QAEXXZ ENDP		; CResetSystem::ClearResetNPCData
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?SetResetNPCData@CResetSystem@@QAEXAAUNPC_DATA@@@Z
_TEXT	SEGMENT
$T1 = -112						; size = 8
$T2 = -104						; size = 24
_MAttr$3 = -16						; size = 4
_iMonsterIndex$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_npc$ = 8						; size = 4
?SetResetNPCData@CResetSystem@@QAEXAAUNPC_DATA@@@Z PROC	; CResetSystem::SetResetNPCData, COMDAT
; _this$ = ecx

; 1132 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1133 : 	int iMonsterIndex = gObjAddMonster(npc.m_iMapIndex);

  00016	8b 45 08	 mov	 eax, DWORD PTR _npc$[ebp]
  00019	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00022	83 c4 04	 add	 esp, 4
  00025	0f bf d0	 movsx	 edx, ax
  00028	89 55 f4	 mov	 DWORD PTR _iMonsterIndex$[ebp], edx

; 1134 : 
; 1135 : 	if(iMonsterIndex >= 0)

  0002b	83 7d f4 00	 cmp	 DWORD PTR _iMonsterIndex$[ebp], 0
  0002f	0f 8c e3 02 00
	00		 jl	 $LN2@SetResetNP

; 1136 : 	{
; 1137 : 		MONSTER_ATTRIBUTE * MAttr = gMAttr.GetAttr(npc.m_iNpcIndex);

  00035	8b 45 08	 mov	 eax, DWORD PTR _npc$[ebp]
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	51		 push	 ecx
  0003b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMAttr@@3VCMonsterAttr@@A ; gMAttr
  00040	e8 00 00 00 00	 call	 ?GetAttr@CMonsterAttr@@QAEPAUMONSTER_ATTRIBUTE@@H@Z ; CMonsterAttr::GetAttr
  00045	89 45 f0	 mov	 DWORD PTR _MAttr$3[ebp], eax

; 1138 : 	
; 1139 : 		if ( MAttr == NULL )

  00048	83 7d f0 00	 cmp	 DWORD PTR _MAttr$3[ebp], 0
  0004c	75 11		 jne	 SHORT $LN3@SetResetNP

; 1140 : 		{
; 1141 : 			gObjDel(iMonsterIndex);

  0004e	8b 45 f4	 mov	 eax, DWORD PTR _iMonsterIndex$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00057	83 c4 04	 add	 esp, 4

; 1142 : 			return;

  0005a	e9 b9 02 00 00	 jmp	 $LN1@SetResetNP
$LN3@SetResetNP:

; 1143 : 		}
; 1144 : 
; 1145 : 		gObjSetMonster(iMonsterIndex, npc.m_iNpcIndex);

  0005f	8b 45 08	 mov	 eax, DWORD PTR _npc$[ebp]
  00062	8b 08		 mov	 ecx, DWORD PTR [eax]
  00064	51		 push	 ecx
  00065	8b 55 f4	 mov	 edx, DWORD PTR _iMonsterIndex$[ebp]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 ?gObjSetMonster@@YAHHH@Z ; gObjSetMonster
  0006e	83 c4 08	 add	 esp, 8

; 1146 : 		gObj[iMonsterIndex].Live = TRUE;

  00071	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  00078	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0007e	c6 44 01 66 01	 mov	 BYTE PTR [ecx+eax+102], 1

; 1147 : 		gObj[iMonsterIndex].Life = MAttr->m_Hp;

  00083	8b 45 f0	 mov	 eax, DWORD PTR _MAttr$3[ebp]
  00086	f3 0f 2a 40 24	 cvtsi2ss xmm0, DWORD PTR [eax+36]
  0008b	69 4d f4 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iMonsterIndex$[ebp], 7072
  00092	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00098	f3 0f 11 84 0a
	bc 00 00 00	 movss	 DWORD PTR [edx+ecx+188], xmm0

; 1148 : 		gObj[iMonsterIndex].MaxLife = MAttr->m_Hp;

  000a1	8b 45 f0	 mov	 eax, DWORD PTR _MAttr$3[ebp]
  000a4	f3 0f 2a 40 24	 cvtsi2ss xmm0, DWORD PTR [eax+36]
  000a9	69 4d f4 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iMonsterIndex$[ebp], 7072
  000b0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000b6	f3 0f 11 84 0a
	c0 00 00 00	 movss	 DWORD PTR [edx+ecx+192], xmm0

; 1149 : 		gObj[iMonsterIndex].m_PosNum = -1;

  000bf	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  000c6	83 c9 ff	 or	 ecx, -1
  000c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000cf	66 89 8c 02 0c
	02 00 00	 mov	 WORD PTR [edx+eax+524], cx

; 1150 : 		gObj[iMonsterIndex].X = npc.m_icX;

  000d7	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  000de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e4	8b 55 08	 mov	 edx, DWORD PTR _npc$[ebp]
  000e7	66 8b 52 08	 mov	 dx, WORD PTR [edx+8]
  000eb	66 89 94 01 04
	01 00 00	 mov	 WORD PTR [ecx+eax+260], dx

; 1151 : 		gObj[iMonsterIndex].Y = npc.m_icY;

  000f3	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  000fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00100	8b 55 08	 mov	 edx, DWORD PTR _npc$[ebp]
  00103	66 8b 52 0c	 mov	 dx, WORD PTR [edx+12]
  00107	66 89 94 01 06
	01 00 00	 mov	 WORD PTR [ecx+eax+262], dx

; 1152 : 		gObj[iMonsterIndex].MTX = npc.m_icX;

  0010f	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  00116	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0011c	8b 55 08	 mov	 edx, DWORD PTR _npc$[ebp]
  0011f	66 8b 52 08	 mov	 dx, WORD PTR [edx+8]
  00123	66 89 94 01 24
	01 00 00	 mov	 WORD PTR [ecx+eax+292], dx

; 1153 : 		gObj[iMonsterIndex].MTY = npc.m_icY;

  0012b	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  00132	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00138	8b 55 08	 mov	 edx, DWORD PTR _npc$[ebp]
  0013b	66 8b 52 0c	 mov	 dx, WORD PTR [edx+12]
  0013f	66 89 94 01 26
	01 00 00	 mov	 WORD PTR [ecx+eax+294], dx

; 1154 : 		gObj[iMonsterIndex].TX = npc.m_icX;

  00147	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  0014e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00154	8b 55 08	 mov	 edx, DWORD PTR _npc$[ebp]
  00157	66 8b 52 08	 mov	 dx, WORD PTR [edx+8]
  0015b	66 89 94 01 20
	01 00 00	 mov	 WORD PTR [ecx+eax+288], dx

; 1155 : 		gObj[iMonsterIndex].TY = npc.m_icY;

  00163	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  0016a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00170	8b 55 08	 mov	 edx, DWORD PTR _npc$[ebp]
  00173	66 8b 52 0c	 mov	 dx, WORD PTR [edx+12]
  00177	66 89 94 01 22
	01 00 00	 mov	 WORD PTR [ecx+eax+290], dx

; 1156 : 		gObj[iMonsterIndex].m_OldX = npc.m_icX;

  0017f	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  00186	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0018c	8b 55 08	 mov	 edx, DWORD PTR _npc$[ebp]
  0018f	66 8b 52 08	 mov	 dx, WORD PTR [edx+8]
  00193	66 89 94 01 1c
	01 00 00	 mov	 WORD PTR [ecx+eax+284], dx

; 1157 : 		gObj[iMonsterIndex].m_OldY = npc.m_icY;

  0019b	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  001a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001a8	8b 55 08	 mov	 edx, DWORD PTR _npc$[ebp]
  001ab	66 8b 52 0c	 mov	 dx, WORD PTR [edx+12]
  001af	66 89 94 01 1e
	01 00 00	 mov	 WORD PTR [ecx+eax+286], dx

; 1158 : 		gObj[iMonsterIndex].StartX = npc.m_icX;

  001b7	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  001be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001c4	8b 55 08	 mov	 edx, DWORD PTR _npc$[ebp]
  001c7	8a 52 08	 mov	 dl, BYTE PTR [edx+8]
  001ca	88 94 01 1a 01
	00 00		 mov	 BYTE PTR [ecx+eax+282], dl

; 1159 : 		gObj[iMonsterIndex].StartY = npc.m_icY;

  001d1	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  001d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001de	8b 55 08	 mov	 edx, DWORD PTR _npc$[ebp]
  001e1	8a 52 0c	 mov	 dl, BYTE PTR [edx+12]
  001e4	88 94 01 1b 01
	00 00		 mov	 BYTE PTR [ecx+eax+283], dl

; 1160 : 		gObj[iMonsterIndex].MapNumber = npc.m_iMapIndex;

  001eb	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  001f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  001f8	8b 55 08	 mov	 edx, DWORD PTR _npc$[ebp]
  001fb	8a 52 04	 mov	 dl, BYTE PTR [edx+4]
  001fe	88 94 01 09 01
	00 00		 mov	 BYTE PTR [ecx+eax+265], dl

; 1161 : 		gObj[iMonsterIndex].m_MoveRange = 0;

  00205	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  0020c	33 c9		 xor	 ecx, ecx
  0020e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00214	66 89 8c 02 f6
	02 00 00	 mov	 WORD PTR [edx+eax+758], cx

; 1162 : 		gObj[iMonsterIndex].Level = MAttr->m_Level;

  0021c	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  00223	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00229	8b 55 f0	 mov	 edx, DWORD PTR _MAttr$3[ebp]
  0022c	66 8b 52 1c	 mov	 dx, WORD PTR [edx+28]
  00230	66 89 94 01 a0
	00 00 00	 mov	 WORD PTR [ecx+eax+160], dx

; 1163 : 		gObj[iMonsterIndex].Type = OBJTYPE_NPC;

  00238	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  0023f	b9 03 00 00 00	 mov	 ecx, 3
  00244	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0024a	66 89 4c 02 64	 mov	 WORD PTR [edx+eax+100], cx

; 1164 : 		gObj[iMonsterIndex].MaxRegenTime = 1000;

  0024f	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  00256	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0025c	c7 84 01 08 02
	00 00 e8 03 00
	00		 mov	 DWORD PTR [ecx+eax+520], 1000 ; 000003e8H

; 1165 : 		gObj[iMonsterIndex].Dir = npc.m_iDir;

  00267	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  0026e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00274	8b 55 08	 mov	 edx, DWORD PTR _npc$[ebp]
  00277	8a 52 10	 mov	 dl, BYTE PTR [edx+16]
  0027a	88 94 01 08 01
	00 00		 mov	 BYTE PTR [ecx+eax+264], dl

; 1166 : 		gObj[iMonsterIndex].RegenTime = GetTickCount();

  00281	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00287	69 4d f4 a0 1b
	00 00		 imul	 ecx, DWORD PTR _iMonsterIndex$[ebp], 7072
  0028e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00294	89 84 0a 04 02
	00 00		 mov	 DWORD PTR [edx+ecx+516], eax

; 1167 : 		gObj[iMonsterIndex].m_Attribute = 0;

  0029b	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  002a2	33 c9		 xor	 ecx, ecx
  002a4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002aa	66 89 8c 02 fe
	02 00 00	 mov	 WORD PTR [edx+eax+766], cx

; 1168 : 		gObj[iMonsterIndex].DieRegen = 0;

  002b2	69 45 f4 a0 1b
	00 00		 imul	 eax, DWORD PTR _iMonsterIndex$[ebp], 7072
  002b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  002bf	c6 84 01 fe 01
	00 00 00	 mov	 BYTE PTR [ecx+eax+510], 0

; 1169 : 
; 1170 : 		LogAddTD("[Reset System] Npc Addition : Index(%d) NpcID(%d) MapID(%d) PosX(%d) PosY(%d)", iMonsterIndex, npc.m_iNpcIndex, npc.m_iMapIndex, npc.m_icX, npc.m_icY);

  002c7	8b 45 08	 mov	 eax, DWORD PTR _npc$[ebp]
  002ca	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  002cd	51		 push	 ecx
  002ce	8b 55 08	 mov	 edx, DWORD PTR _npc$[ebp]
  002d1	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002d4	50		 push	 eax
  002d5	8b 4d 08	 mov	 ecx, DWORD PTR _npc$[ebp]
  002d8	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  002db	52		 push	 edx
  002dc	8b 45 08	 mov	 eax, DWORD PTR _npc$[ebp]
  002df	8b 08		 mov	 ecx, DWORD PTR [eax]
  002e1	51		 push	 ecx
  002e2	8b 55 f4	 mov	 edx, DWORD PTR _iMonsterIndex$[ebp]
  002e5	52		 push	 edx
  002e6	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@GAODGINP@?$FLReset?5System?$FN?5Npc?5Addition?5?3?5I@
  002eb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  002f1	83 c4 18	 add	 esp, 24			; 00000018H

; 1171 : 
; 1172 : 		this->m_mNpcData.insert(std::make_pair(iMonsterIndex,npc));

  002f4	8b 45 08	 mov	 eax, DWORD PTR _npc$[ebp]
  002f7	50		 push	 eax
  002f8	8d 4d f4	 lea	 ecx, DWORD PTR _iMonsterIndex$[ebp]
  002fb	51		 push	 ecx
  002fc	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  002ff	52		 push	 edx
  00300	e8 00 00 00 00	 call	 ??$make_pair@AAHAAUNPC_DATA@@@std@@YA?AU?$pair@HUNPC_DATA@@@0@AAHAAUNPC_DATA@@@Z ; std::make_pair<int &,NPC_DATA &>
  00305	83 c4 0c	 add	 esp, 12			; 0000000cH
  00308	50		 push	 eax
  00309	8d 45 90	 lea	 eax, DWORD PTR $T1[ebp]
  0030c	50		 push	 eax
  0030d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00310	83 c1 68	 add	 ecx, 104		; 00000068H
  00313	e8 00 00 00 00	 call	 ??$insert@U?$pair@HUNPC_DATA@@@std@@$0A@@?$map@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHUNPC_DATA@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@HUNPC_DATA@@@1@@Z ; std::map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >::insert<std::pair<int,NPC_DATA>,0>
$LN2@SetResetNP:
$LN1@SetResetNP:

; 1173 : 	}
; 1174 : }

  00318	5f		 pop	 edi
  00319	5e		 pop	 esi
  0031a	5b		 pop	 ebx
  0031b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0031e	33 cd		 xor	 ecx, ebp
  00320	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00325	8b e5		 mov	 esp, ebp
  00327	5d		 pop	 ebp
  00328	c2 04 00	 ret	 4
?SetResetNPCData@CResetSystem@@QAEXAAUNPC_DATA@@@Z ENDP	; CResetSystem::SetResetNPCData
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?ExecResetApply@CResetSystem@@QAEXPAVOBJECTSTRUCT@@HHHHHHHHH@Z
_TEXT	SEGMENT
_szTemp$ = -264						; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iRuleIndex$ = 12					; size = 4
_iClearStatPoint$ = 16					; size = 4
_iLevelAfter$ = 20					; size = 4
_iLevelUpPoint$ = 24					; size = 4
_iReqSpecialItem$ = 28					; size = 4
_iBornPlace$ = 32					; size = 4
_iResetNumber$ = 36					; size = 4
_iClearAllBuffState$ = 40				; size = 4
_iClearMagicList$ = 44					; size = 4
?ExecResetApply@CResetSystem@@QAEXPAVOBJECTSTRUCT@@HHHHHHHHH@Z PROC ; CResetSystem::ExecResetApply, COMDAT
; _this$ = ecx

; 1070 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1071 : 	//EnterCriticalSection(&this->m_cs);
; 1072 : 
; 1073 : 	lpObj->Level = iLevelAfter;

  00019	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	66 8b 4d 14	 mov	 cx, WORD PTR _iLevelAfter$[ebp]
  00020	66 89 88 a0 00
	00 00		 mov	 WORD PTR [eax+160], cx

; 1074 : 	lpObj->Experience = 0;

  00027	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0002a	c7 80 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+168], 0

; 1075 : 
; 1076 : 	if(iLevelUpPoint != -1)

  00034	83 7d 18 ff	 cmp	 DWORD PTR _iLevelUpPoint$[ebp], -1
  00038	74 10		 je	 SHORT $LN2@ExecResetA

; 1077 : 	{
; 1078 : 		lpObj->LevelUpPoint = iLevelUpPoint * iResetNumber;

  0003a	8b 45 18	 mov	 eax, DWORD PTR _iLevelUpPoint$[ebp]
  0003d	0f af 45 24	 imul	 eax, DWORD PTR _iResetNumber$[ebp]
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00044	89 81 a4 00 00
	00		 mov	 DWORD PTR [ecx+164], eax
$LN2@ExecResetA:

; 1079 : 	}
; 1080 : 
; 1081 : 	lpObj->m_iResetNumber = iResetNumber;

  0004a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004d	8b 4d 24	 mov	 ecx, DWORD PTR _iResetNumber$[ebp]
  00050	89 88 78 1a 00
	00		 mov	 DWORD PTR [eax+6776], ecx

; 1082 : 
; 1083 : 	if(iClearStatPoint == TRUE)

  00056	83 7d 10 01	 cmp	 DWORD PTR _iClearStatPoint$[ebp], 1
  0005a	75 0c		 jne	 SHORT $LN3@ExecResetA

; 1084 : 	{
; 1085 : 		this->UpdateUserStatusPoint(lpObj);

  0005c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005f	50		 push	 eax
  00060	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?UpdateUserStatusPoint@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CResetSystem::UpdateUserStatusPoint
$LN3@ExecResetA:

; 1086 : 	}
; 1087 : 
; 1088 : 	if(iBornPlace == TRUE)

  00068	83 7d 20 01	 cmp	 DWORD PTR _iBornPlace$[ebp], 1
  0006c	75 1b		 jne	 SHORT $LN4@ExecResetA

; 1089 : 	{
; 1090 : 		this->SetUserBornPlace(lpObj,iRuleIndex,lpObj->Class);

  0006e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00071	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00078	51		 push	 ecx
  00079	8b 55 0c	 mov	 edx, DWORD PTR _iRuleIndex$[ebp]
  0007c	52		 push	 edx
  0007d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00080	50		 push	 eax
  00081	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ?SetUserBornPlace@CResetSystem@@QAEXPAVOBJECTSTRUCT@@HH@Z ; CResetSystem::SetUserBornPlace
$LN4@ExecResetA:

; 1091 : 	}
; 1092 : 
; 1093 : 	if(iReqSpecialItem == TRUE)

  00089	83 7d 1c 01	 cmp	 DWORD PTR _iReqSpecialItem$[ebp], 1
  0008d	75 10		 jne	 SHORT $LN5@ExecResetA

; 1094 : 	{
; 1095 : 		this->DeleteResetRequiredItem(lpObj,iRuleIndex); //only one RuleIndex

  0008f	8b 45 0c	 mov	 eax, DWORD PTR _iRuleIndex$[ebp]
  00092	50		 push	 eax
  00093	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00096	51		 push	 ecx
  00097	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?DeleteResetRequiredItem@CResetSystem@@QAEXPAVOBJECTSTRUCT@@H@Z ; CResetSystem::DeleteResetRequiredItem
$LN5@ExecResetA:

; 1096 : 	}
; 1097 : 
; 1098 : 	if(iClearAllBuffState == TRUE)

  0009f	83 7d 28 01	 cmp	 DWORD PTR _iClearAllBuffState$[ebp], 1
  000a3	75 0c		 jne	 SHORT $LN6@ExecResetA

; 1099 : 	{
; 1100 : 		this->ClearAllBuffStates(lpObj);

  000a5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	e8 00 00 00 00	 call	 ?ClearAllBuffStates@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CResetSystem::ClearAllBuffStates
$LN6@ExecResetA:

; 1101 : 	}
; 1102 : 
; 1103 : 	if(iClearMagicList == TRUE)

  000b1	83 7d 2c 01	 cmp	 DWORD PTR _iClearMagicList$[ebp], 1
  000b5	75 0c		 jne	 SHORT $LN7@ExecResetA

; 1104 : 	{
; 1105 : 		this->ClearMagicList(lpObj);

  000b7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ba	50		 push	 eax
  000bb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?ClearMagicList@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CResetSystem::ClearMagicList
$LN7@ExecResetA:

; 1106 : 	}
; 1107 : 
; 1108 : 	this->SetUserDefaultLifePlusMana(lpObj);

  000c3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c6	50		 push	 eax
  000c7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	e8 00 00 00 00	 call	 ?SetUserDefaultLifePlusMana@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CResetSystem::SetUserDefaultLifePlusMana

; 1109 : 	this->CalculateEquipment(lpObj);

  000cf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d2	50		 push	 eax
  000d3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ?CalculateEquipment@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CResetSystem::CalculateEquipment

; 1110 : 	this->FixUserExpInterface(lpObj);

  000db	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000de	50		 push	 eax
  000df	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	e8 00 00 00 00	 call	 ?FixUserExpInterface@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CResetSystem::FixUserExpInterface

; 1111 : 
; 1112 : 	lpObj->m_bReqUpdateReset = false; //clear

  000e7	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ea	c6 80 7c 1a 00
	00 00		 mov	 BYTE PTR [eax+6780], 0

; 1113 : 
; 1114 : 	if(m_bZenMultiply)

  000f1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f4	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  000f8	74 26		 je	 SHORT $LN8@ExecResetA

; 1115 : 		lpObj->Money -= this->m_iZenPrice*lpObj->m_iResetNumber;

  000fa	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000fd	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00100	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00103	0f af 91 78 1a
	00 00		 imul	 edx, DWORD PTR [ecx+6776]
  0010a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010d	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00113	2b ca		 sub	 ecx, edx
  00115	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00118	89 8a b0 00 00
	00		 mov	 DWORD PTR [edx+176], ecx
  0011e	eb 18		 jmp	 SHORT $LN9@ExecResetA
$LN8@ExecResetA:

; 1116 : 	else
; 1117 : 		lpObj->Money -= this->m_iZenPrice;

  00120	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00123	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00126	8b 90 b0 00 00
	00		 mov	 edx, DWORD PTR [eax+176]
  0012c	2b 51 30	 sub	 edx, DWORD PTR [ecx+48]
  0012f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00132	89 90 b0 00 00
	00		 mov	 DWORD PTR [eax+176], edx
$LN9@ExecResetA:

; 1118 : 
; 1119 : 	GCMoneySend(lpObj->m_Index, lpObj->Money);

  00138	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013b	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00141	51		 push	 ecx
  00142	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00145	8b 02		 mov	 eax, DWORD PTR [edx]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0014d	83 c4 08	 add	 esp, 8

; 1120 : 
; 1121 : 	GJSetCharacterInfo(lpObj, lpObj->m_Index);

  00150	6a 00		 push	 0
  00152	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00155	8b 08		 mov	 ecx, DWORD PTR [eax]
  00157	51		 push	 ecx
  00158	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0015b	52		 push	 edx
  0015c	e8 00 00 00 00	 call	 ?GJSetCharacterInfo@@YAXPAVOBJECTSTRUCT@@HH@Z ; GJSetCharacterInfo
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1122 : 
; 1123 : 	char szTemp[256];
; 1124 : 	wsprintf(szTemp,"[RESET SYSTEM]: Tienes %d Reset(s).", lpObj->m_iResetNumber); //[Reset System] You currently have %d Reset(s).

  00164	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00167	8b 88 78 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6776]
  0016d	51		 push	 ecx
  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@JDMKFIAN@?$FLRESET?5SYSTEM?$FN?3?5Tienes?5?$CFd?5Reset@
  00173	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  00179	52		 push	 edx
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00180	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1125 : 	GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  00183	6a 01		 push	 1
  00185	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00188	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018a	51		 push	 ecx
  0018b	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  00191	52		 push	 edx
  00192	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00197	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1126 : 
; 1127 : 
; 1128 : 	//LeaveCriticalSection(&this->m_cs);
; 1129 : }

  0019a	5f		 pop	 edi
  0019b	5e		 pop	 esi
  0019c	5b		 pop	 ebx
  0019d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a0	33 cd		 xor	 ecx, ebp
  001a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a7	8b e5		 mov	 esp, ebp
  001a9	5d		 pop	 ebp
  001aa	c2 28 00	 ret	 40			; 00000028H
?ExecResetApply@CResetSystem@@QAEXPAVOBJECTSTRUCT@@HHHHHHHHH@Z ENDP ; CResetSystem::ExecResetApply
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?CheckUserCondition@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv148 = -380						; size = 4
tv136 = -380						; size = 4
tv173 = -376						; size = 4
tv149 = -376						; size = 4
tv137 = -376						; size = 4
$T1 = -372						; size = 4
$T2 = -368						; size = 4
$T3 = -364						; size = 4
$T4 = -360						; size = 4
_Result$5 = -292					; size = 4
_FindItem$6 = -285					; size = 1
_it$7 = -284						; size = 4
_Result$8 = -280					; size = 4
_FindItem$9 = -273					; size = 1
_it$10 = -272						; size = 4
_bError$ = -268						; size = 4
_szMsg$11 = -264					; size = 256
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?CheckUserCondition@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z PROC ; CResetSystem::CheckUserCondition, COMDAT
; _this$ = ecx

; 882  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 7c 01 00
	00		 sub	 esp, 380		; 0000017cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 883  : 	if (lpObj->CloseCount > 0 || lpObj->CloseType >= 0)

  00019	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	0f be 48 0a	 movsx	 ecx, BYTE PTR [eax+10]
  00020	85 c9		 test	 ecx, ecx
  00022	7f 0b		 jg	 SHORT $LN9@CheckUserC
  00024	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00027	0f be 48 0b	 movsx	 ecx, BYTE PTR [eax+11]
  0002b	85 c9		 test	 ecx, ecx
  0002d	7c 05		 jl	 SHORT $LN8@CheckUserC
$LN9@CheckUserC:

; 884  : 	{
; 885  : 		return;

  0002f	e9 a0 06 00 00	 jmp	 $LN1@CheckUserC
$LN8@CheckUserC:

; 886  : 	}
; 887  : 
; 888  : 	if(lpObj->m_bResetState == 0)

  00034	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00037	0f b6 88 76 1a
	00 00		 movzx	 ecx, BYTE PTR [eax+6774]
  0003e	85 c9		 test	 ecx, ecx
  00040	75 11		 jne	 SHORT $LN10@CheckUserC

; 889  : 	{
; 890  : 		this->DBGetResetInfo(lpObj);

  00042	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00045	50		 push	 eax
  00046	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?DBGetResetInfo@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ; CResetSystem::DBGetResetInfo

; 891  : 		return;

  0004e	e9 81 06 00 00	 jmp	 $LN1@CheckUserC
$LN10@CheckUserC:

; 892  : 	}
; 893  : 
; 894  : 	if(lpObj->m_IfState.use == 1 && lpObj->m_IfState.type == 6)

  00053	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00056	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  0005c	80 e1 03	 and	 cl, 3
  0005f	0f b6 d1	 movzx	 edx, cl
  00062	83 fa 01	 cmp	 edx, 1
  00065	75 25		 jne	 SHORT $LN11@CheckUserC
  00067	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006a	8a 88 56 0c 00
	00		 mov	 cl, BYTE PTR [eax+3158]
  00070	c0 e9 04	 shr	 cl, 4
  00073	80 e1 0f	 and	 cl, 15			; 0000000fH
  00076	0f b6 d1	 movzx	 edx, cl
  00079	83 fa 06	 cmp	 edx, 6
  0007c	75 0e		 jne	 SHORT $LN11@CheckUserC

; 895  : 	{
; 896  : 		CGWarehouseUseEnd(lpObj->m_Index); //Lock the Vault

  0007e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00081	8b 08		 mov	 ecx, DWORD PTR [eax]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 ?CGWarehouseUseEnd@@YAXH@Z ; CGWarehouseUseEnd
  00089	83 c4 04	 add	 esp, 4
$LN11@CheckUserC:

; 897  : 	}
; 898  : 
; 899  : 	if(lpObj->m_ReqWarehouseOpen != false)

  0008c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008f	0f b6 88 24 0f
	00 00		 movzx	 ecx, BYTE PTR [eax+3876]
  00096	85 c9		 test	 ecx, ecx
  00098	74 05		 je	 SHORT $LN12@CheckUserC

; 900  : 	{
; 901  : 		return;

  0009a	e9 35 06 00 00	 jmp	 $LN1@CheckUserC
$LN12@CheckUserC:

; 902  : 	}
; 903  : 
; 904  : 	if(lpObj->m_iResetNumber == -1)

  0009f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a2	83 b8 78 1a 00
	00 ff		 cmp	 DWORD PTR [eax+6776], -1
  000a9	75 05		 jne	 SHORT $LN13@CheckUserC

; 905  : 	{
; 906  : 		return;

  000ab	e9 24 06 00 00	 jmp	 $LN1@CheckUserC
$LN13@CheckUserC:

; 907  : 	}
; 908  : 
; 909  : 	if(lpObj->m_bReqUpdateReset == true)

  000b0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b3	0f b6 88 7c 1a
	00 00		 movzx	 ecx, BYTE PTR [eax+6780]
  000ba	83 f9 01	 cmp	 ecx, 1
  000bd	75 05		 jne	 SHORT $LN14@CheckUserC

; 910  : 	{
; 911  : 		return;

  000bf	e9 10 06 00 00	 jmp	 $LN1@CheckUserC
$LN14@CheckUserC:

; 912  : 	}
; 913  : 
; 914  : 	if(lpObj->m_stateEngagePVP == PVP_USER_PLAYING)

  000c4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c7	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  000ce	75 05		 jne	 SHORT $LN15@CheckUserC

; 915  : 		return;

  000d0	e9 ff 05 00 00	 jmp	 $LN1@CheckUserC
$LN15@CheckUserC:

; 916  : 
; 917  : 	if(CHECK_BLOODCASTLE(lpObj->MapNumber)
; 918  : #ifdef DEVILSQUARE_EXTEND_20050221
; 919  : 		|| CHECK_DEVILSQUARE(lpObj->MapNumber)
; 920  : #else
; 921  : 		|| lpObj->MapNumber == 9
; 922  : #endif
; 923  : #ifdef CHAOSCASTLE_SYSTEM_20040408
; 924  : 		|| CHECK_CHAOSCASTLE(lpObj->MapNumber)

  000d5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d8	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000df	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  000e2	7d 0c		 jge	 SHORT $LN48@CheckUserC
  000e4	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv137[ebp], 0
  000ee	eb 31		 jmp	 SHORT $LN49@CheckUserC
$LN48@CheckUserC:
  000f0	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000f3	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  000fa	83 f8 11	 cmp	 eax, 17			; 00000011H
  000fd	7e 0c		 jle	 SHORT $LN46@CheckUserC
  000ff	c7 85 84 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv136[ebp], 0
  00109	eb 0a		 jmp	 SHORT $LN47@CheckUserC
$LN46@CheckUserC:
  0010b	c7 85 84 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv136[ebp], 1
$LN47@CheckUserC:
  00115	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv136[ebp]
  0011b	89 8d 88 fe ff
	ff		 mov	 DWORD PTR tv137[ebp], ecx
$LN49@CheckUserC:
  00121	83 bd 88 fe ff
	ff 00		 cmp	 DWORD PTR tv137[ebp], 0
  00128	75 64		 jne	 SHORT $LN17@CheckUserC
  0012a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012d	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00134	83 f9 09	 cmp	 ecx, 9
  00137	74 55		 je	 SHORT $LN17@CheckUserC
  00139	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013c	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00143	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00146	7d 0c		 jge	 SHORT $LN52@CheckUserC
  00148	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv149[ebp], 0
  00152	eb 31		 jmp	 SHORT $LN53@CheckUserC
$LN52@CheckUserC:
  00154	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00157	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0015e	83 f8 17	 cmp	 eax, 23			; 00000017H
  00161	7e 0c		 jle	 SHORT $LN50@CheckUserC
  00163	c7 85 84 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv148[ebp], 0
  0016d	eb 0a		 jmp	 SHORT $LN51@CheckUserC
$LN50@CheckUserC:
  0016f	c7 85 84 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv148[ebp], 1
$LN51@CheckUserC:
  00179	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv148[ebp]
  0017f	89 8d 88 fe ff
	ff		 mov	 DWORD PTR tv149[ebp], ecx
$LN53@CheckUserC:
  00185	83 bd 88 fe ff
	ff 00		 cmp	 DWORD PTR tv149[ebp], 0
  0018c	74 05		 je	 SHORT $LN16@CheckUserC
$LN17@CheckUserC:

; 925  : #endif
; 926  : 		)
; 927  : 	{
; 928  : 		return;

  0018e	e9 41 05 00 00	 jmp	 $LN1@CheckUserC
$LN16@CheckUserC:

; 929  : 	}
; 930  : 
; 931  : 	if((lpObj->Money < this->m_iZenPrice) || (this->m_bZenMultiply && lpObj->Money < this->m_iZenPrice*(lpObj->m_iResetNumber+1)))

  00193	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00196	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00199	8b 90 b0 00 00
	00		 mov	 edx, DWORD PTR [eax+176]
  0019f	3b 51 30	 cmp	 edx, DWORD PTR [ecx+48]
  001a2	7c 2b		 jl	 SHORT $LN19@CheckUserC
  001a4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001a7	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  001ab	0f 84 9b 00 00
	00		 je	 $LN18@CheckUserC
  001b1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b4	8b 88 78 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6776]
  001ba	83 c1 01	 add	 ecx, 1
  001bd	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001c0	0f af 4a 30	 imul	 ecx, DWORD PTR [edx+48]
  001c4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001c7	39 88 b0 00 00
	00		 cmp	 DWORD PTR [eax+176], ecx
  001cd	7d 7d		 jge	 SHORT $LN18@CheckUserC
$LN19@CheckUserC:

; 932  : 	{
; 933  : 		char szMsg[256] = {0};

  001cf	68 00 01 00 00	 push	 256			; 00000100H
  001d4	6a 00		 push	 0
  001d6	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szMsg$11[ebp]
  001dc	50		 push	 eax
  001dd	e8 00 00 00 00	 call	 _memset
  001e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 934  : 
; 935  : 		sprintf(szMsg, "No tienen suficiente zen(%d)...", (this->m_bZenMultiply ? this->m_iZenPrice*(lpObj->m_iResetNumber+1) : this->m_iZenPrice));

  001e5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001e8	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  001ec	74 1b		 je	 SHORT $LN54@CheckUserC
  001ee	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001f1	8b 91 78 1a 00
	00		 mov	 edx, DWORD PTR [ecx+6776]
  001f7	83 c2 01	 add	 edx, 1
  001fa	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001fd	0f af 50 30	 imul	 edx, DWORD PTR [eax+48]
  00201	89 95 88 fe ff
	ff		 mov	 DWORD PTR tv173[ebp], edx
  00207	eb 0c		 jmp	 SHORT $LN55@CheckUserC
$LN54@CheckUserC:
  00209	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0020c	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0020f	89 95 88 fe ff
	ff		 mov	 DWORD PTR tv173[ebp], edx
$LN55@CheckUserC:
  00215	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR tv173[ebp]
  0021b	50		 push	 eax
  0021c	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@DIPDIDAL@No?5tienen?5suficiente?5zen?$CI?$CFd?$CJ?4?4?4@
  00221	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szMsg$11[ebp]
  00227	51		 push	 ecx
  00228	e8 00 00 00 00	 call	 _sprintf
  0022d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 936  : 
; 937  : 		GCServerMsgStringSend(szMsg, lpObj->m_Index, 1);

  00230	6a 01		 push	 1
  00232	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00235	8b 08		 mov	 ecx, DWORD PTR [eax]
  00237	51		 push	 ecx
  00238	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _szMsg$11[ebp]
  0023e	52		 push	 edx
  0023f	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00244	83 c4 0c	 add	 esp, 12			; 0000000cH

; 938  : 		return;

  00247	e9 88 04 00 00	 jmp	 $LN1@CheckUserC
$LN18@CheckUserC:

; 939  : 	}
; 940  : 
; 941  : 	BOOL bError = TRUE;

  0024c	c7 85 f4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _bError$[ebp], 1

; 942  : 
; 943  : 	if(this->m_bResetSystemType == 1)

  00256	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00259	83 78 24 01	 cmp	 DWORD PTR [eax+36], 1
  0025d	0f 85 49 02 00
	00		 jne	 $LN20@CheckUserC

; 944  : 	{
; 945  : 		for ( std::vector<TABLE_RESET>::iterator it = this->m_vtTableReset.begin() ; it != this->m_vtTableReset.end() ; it++ )

  00263	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _it$10[ebp]
  00269	50		 push	 eax
  0026a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0026d	83 c1 44	 add	 ecx, 68			; 00000044H
  00270	e8 00 00 00 00	 call	 ?begin@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@2@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::begin
  00275	eb 14		 jmp	 SHORT $LN4@CheckUserC
$LN2@CheckUserC:
  00277	6a 00		 push	 0
  00279	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  0027f	50		 push	 eax
  00280	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  00286	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator++
$LN4@CheckUserC:
  0028b	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00291	50		 push	 eax
  00292	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00295	83 c1 44	 add	 ecx, 68			; 00000044H
  00298	e8 00 00 00 00	 call	 ?end@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@2@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::end
  0029d	50		 push	 eax
  0029e	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  002a4	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator!=
  002a9	0f b6 c8	 movzx	 ecx, al
  002ac	85 c9		 test	 ecx, ecx
  002ae	0f 84 f3 01 00
	00		 je	 $LN3@CheckUserC

; 946  : 		{
; 947  : 			if((*(it)).m_iVipCode != -1)

  002b4	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  002ba	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  002bf	83 78 30 ff	 cmp	 DWORD PTR [eax+48], -1
  002c3	74 1c		 je	 SHORT $LN22@CheckUserC

; 948  : 			{
; 949  : 				if(lpObj->m_AccountType != (*(it)).m_iVipCode)

  002c5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c8	0f b6 b0 5d 1a
	00 00		 movzx	 esi, BYTE PTR [eax+6749]
  002cf	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  002d5	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  002da	3b 70 30	 cmp	 esi, DWORD PTR [eax+48]
  002dd	74 02		 je	 SHORT $LN22@CheckUserC

; 950  : 				{
; 951  : 					continue;

  002df	eb 96		 jmp	 SHORT $LN2@CheckUserC
$LN22@CheckUserC:

; 952  : 				}
; 953  : 			}
; 954  : 
; 955  : 			if(lpObj->m_iResetNumber < (*it).m_iMinResetNumber || lpObj->m_iResetNumber+1 > (*(it)).m_iResetNumber) //Dangerous

  002e1	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  002e7	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  002ec	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002ef	8b 91 78 1a 00
	00		 mov	 edx, DWORD PTR [ecx+6776]
  002f5	3b 50 24	 cmp	 edx, DWORD PTR [eax+36]
  002f8	7c 1c		 jl	 SHORT $LN25@CheckUserC
  002fa	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002fd	8b b0 78 1a 00
	00		 mov	 esi, DWORD PTR [eax+6776]
  00303	83 c6 01	 add	 esi, 1
  00306	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  0030c	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  00311	3b 70 28	 cmp	 esi, DWORD PTR [eax+40]
  00314	7e 05		 jle	 SHORT $LN24@CheckUserC
$LN25@CheckUserC:

; 956  : 			{
; 957  : 				continue;

  00316	e9 5c ff ff ff	 jmp	 $LN2@CheckUserC
$LN24@CheckUserC:

; 958  : 			}
; 959  : 			
; 960  : 			if((*(it)).m_iCharClassType != -1)

  0031b	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  00321	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  00326	83 78 04 ff	 cmp	 DWORD PTR [eax+4], -1
  0032a	74 1f		 je	 SHORT $LN26@CheckUserC

; 961  : 			{
; 962  : 				if(lpObj->Class != (*(it)).m_iCharClassType)

  0032c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0032f	0f b7 b0 9c 00
	00 00		 movzx	 esi, WORD PTR [eax+156]
  00336	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  0033c	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  00341	3b 70 04	 cmp	 esi, DWORD PTR [eax+4]
  00344	74 05		 je	 SHORT $LN26@CheckUserC

; 963  : 				{
; 964  : 					continue;

  00346	e9 2c ff ff ff	 jmp	 $LN2@CheckUserC
$LN26@CheckUserC:

; 965  : 				}
; 966  : 			}
; 967  : 
; 968  : 			if(lpObj->Level < (*(it)).m_iMinLevel)

  0034b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0034e	0f bf b0 a0 00
	00 00		 movsx	 esi, WORD PTR [eax+160]
  00355	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  0035b	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  00360	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00363	7d 05		 jge	 SHORT $LN28@CheckUserC

; 969  : 			{
; 970  : 				continue;

  00365	e9 0d ff ff ff	 jmp	 $LN2@CheckUserC
$LN28@CheckUserC:

; 971  : 			}
; 972  : 
; 973  : 			if(lpObj->Level > (*(it)).m_iMaxLevel)

  0036a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0036d	0f bf b0 a0 00
	00 00		 movsx	 esi, WORD PTR [eax+160]
  00374	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  0037a	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  0037f	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  00382	7e 05		 jle	 SHORT $LN29@CheckUserC

; 974  : 			{
; 975  : 				continue;

  00384	e9 ee fe ff ff	 jmp	 $LN2@CheckUserC
$LN29@CheckUserC:

; 976  : 			}
; 977  : 
; 978  : 			if((*(it)).m_bReqSpecialItem != FALSE)

  00389	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  0038f	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  00394	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00398	74 3b		 je	 SHORT $LN30@CheckUserC

; 979  : 			{
; 980  : 				bool FindItem = this->SearchResetRequiredItem(lpObj,(*(it)).m_iRuleIndex);

  0039a	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  003a0	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  003a5	8b 00		 mov	 eax, DWORD PTR [eax]
  003a7	50		 push	 eax
  003a8	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  003ab	51		 push	 ecx
  003ac	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003af	e8 00 00 00 00	 call	 ?SearchResetRequiredItem@CResetSystem@@QAE_NPAVOBJECTSTRUCT@@H@Z ; CResetSystem::SearchResetRequiredItem
  003b4	88 85 ef fe ff
	ff		 mov	 BYTE PTR _FindItem$9[ebp], al

; 981  : 
; 982  : 				if( FindItem != true)

  003ba	0f b6 85 ef fe
	ff ff		 movzx	 eax, BYTE PTR _FindItem$9[ebp]
  003c1	83 f8 01	 cmp	 eax, 1
  003c4	74 0f		 je	 SHORT $LN30@CheckUserC

; 983  : 				{
; 984  : 					bError = 2;

  003c6	c7 85 f4 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _bError$[ebp], 2

; 985  : 					continue;

  003d0	e9 a2 fe ff ff	 jmp	 $LN2@CheckUserC
$LN30@CheckUserC:

; 986  : 				}
; 987  : 			}
; 988  : 
; 989  : 			if((*(it)).m_iCheckInventory != FALSE)

  003d5	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  003db	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  003e0	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  003e4	74 20		 je	 SHORT $LN32@CheckUserC

; 990  : 			{
; 991  : 				BOOL Result = this->CheckUserEquipment(lpObj);

  003e6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  003e9	50		 push	 eax
  003ea	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003ed	e8 00 00 00 00	 call	 ?CheckUserEquipment@CResetSystem@@QAEHPAVOBJECTSTRUCT@@@Z ; CResetSystem::CheckUserEquipment
  003f2	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _Result$8[ebp], eax

; 992  : 
; 993  : 				if( Result != TRUE)

  003f8	83 bd e8 fe ff
	ff 01		 cmp	 DWORD PTR _Result$8[ebp], 1
  003ff	74 05		 je	 SHORT $LN32@CheckUserC

; 994  : 				{
; 995  : 					continue;

  00401	e9 71 fe ff ff	 jmp	 $LN2@CheckUserC
$LN32@CheckUserC:

; 996  : 				}
; 997  : 			}
; 998  : 
; 999  : 			//EnterCriticalSection(&this->m_cs);
; 1000 : 			this->DBReqUpdateReset(lpObj, (*(it)).m_iRuleIndex, (*(it)).m_bClearStat, (*(it)).m_iLevelAfterReset, (*(it)).m_iLevelUpPoint, (*(it)).m_bReqSpecialItem, (*(it)).m_bBornPlace, lpObj->m_iResetNumber+1, (*(it)).m_bClearBuffState, (*(it)).m_bClearMagicList);

  00406	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  0040c	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  00411	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00414	50		 push	 eax
  00415	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  0041b	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  00420	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00423	51		 push	 ecx
  00424	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00427	8b 82 78 1a 00
	00		 mov	 eax, DWORD PTR [edx+6776]
  0042d	83 c0 01	 add	 eax, 1
  00430	50		 push	 eax
  00431	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  00437	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  0043c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0043f	51		 push	 ecx
  00440	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  00446	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  0044b	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0044e	52		 push	 edx
  0044f	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  00455	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  0045a	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0045d	50		 push	 eax
  0045e	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  00464	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  00469	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0046c	51		 push	 ecx
  0046d	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  00473	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  00478	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0047b	52		 push	 edx
  0047c	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR _it$10[ebp]
  00482	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  00487	8b 00		 mov	 eax, DWORD PTR [eax]
  00489	50		 push	 eax
  0048a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0048d	51		 push	 ecx
  0048e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00491	e8 00 00 00 00	 call	 ?DBReqUpdateReset@CResetSystem@@QAEXPAVOBJECTSTRUCT@@HHHHHHHHH@Z ; CResetSystem::DBReqUpdateReset

; 1001 : 			bError = FALSE;

  00496	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _bError$[ebp], 0

; 1002 : 			break;

  004a0	eb 05		 jmp	 SHORT $LN3@CheckUserC

; 1003 : 		}

  004a2	e9 d0 fd ff ff	 jmp	 $LN2@CheckUserC
$LN3@CheckUserC:

; 1004 : 	}

  004a7	e9 0a 02 00 00	 jmp	 $LN21@CheckUserC
$LN20@CheckUserC:

; 1005 : 	else
; 1006 : 	{
; 1007 : 		for ( std::vector<NON_TABLE_RESET>::iterator it = this->m_vtNonTableReset.begin() ; it != this->m_vtNonTableReset.end() ; it++ )

  004ac	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _it$7[ebp]
  004b2	50		 push	 eax
  004b3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004b6	83 c1 38	 add	 ecx, 56			; 00000038H
  004b9	e8 00 00 00 00	 call	 ?begin@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@2@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::begin
  004be	eb 14		 jmp	 SHORT $LN7@CheckUserC
$LN5@CheckUserC:
  004c0	6a 00		 push	 0
  004c2	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  004c8	50		 push	 eax
  004c9	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  004cf	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator++
$LN7@CheckUserC:
  004d4	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  004da	50		 push	 eax
  004db	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004de	83 c1 38	 add	 ecx, 56			; 00000038H
  004e1	e8 00 00 00 00	 call	 ?end@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@2@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::end
  004e6	50		 push	 eax
  004e7	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  004ed	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator!=
  004f2	0f b6 c8	 movzx	 ecx, al
  004f5	85 c9		 test	 ecx, ecx
  004f7	0f 84 b9 01 00
	00		 je	 $LN21@CheckUserC

; 1008 : 		{
; 1009 : 			if((*(it)).m_iVipCode != -1)

  004fd	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  00503	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  00508	83 78 28 ff	 cmp	 DWORD PTR [eax+40], -1
  0050c	74 1c		 je	 SHORT $LN34@CheckUserC

; 1010 : 			{
; 1011 : 				if(lpObj->m_AccountType != (*(it)).m_iVipCode)

  0050e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00511	0f b6 b0 5d 1a
	00 00		 movzx	 esi, BYTE PTR [eax+6749]
  00518	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  0051e	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  00523	3b 70 28	 cmp	 esi, DWORD PTR [eax+40]
  00526	74 02		 je	 SHORT $LN34@CheckUserC

; 1012 : 				{
; 1013 : 					continue;

  00528	eb 96		 jmp	 SHORT $LN5@CheckUserC
$LN34@CheckUserC:

; 1014 : 				}
; 1015 : 			}
; 1016 : 
; 1017 : 			if((*(it)).m_iCharClassType != -1)

  0052a	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  00530	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  00535	83 78 04 ff	 cmp	 DWORD PTR [eax+4], -1
  00539	74 1f		 je	 SHORT $LN36@CheckUserC

; 1018 : 			{
; 1019 : 				if(lpObj->Class != (*(it)).m_iCharClassType)

  0053b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0053e	0f b7 b0 9c 00
	00 00		 movzx	 esi, WORD PTR [eax+156]
  00545	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  0054b	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  00550	3b 70 04	 cmp	 esi, DWORD PTR [eax+4]
  00553	74 05		 je	 SHORT $LN36@CheckUserC

; 1020 : 				{
; 1021 : 					continue;

  00555	e9 66 ff ff ff	 jmp	 $LN5@CheckUserC
$LN36@CheckUserC:

; 1022 : 				}
; 1023 : 			}
; 1024 : 
; 1025 : 			if(lpObj->Level < (*(it)).m_iMinLevel)

  0055a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0055d	0f bf b0 a0 00
	00 00		 movsx	 esi, WORD PTR [eax+160]
  00564	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  0056a	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  0056f	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00572	7d 05		 jge	 SHORT $LN38@CheckUserC

; 1026 : 			{
; 1027 : 				continue;

  00574	e9 47 ff ff ff	 jmp	 $LN5@CheckUserC
$LN38@CheckUserC:

; 1028 : 			}
; 1029 : 
; 1030 : 			if(lpObj->Level > (*(it)).m_iMaxLevel)

  00579	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0057c	0f bf b0 a0 00
	00 00		 movsx	 esi, WORD PTR [eax+160]
  00583	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  00589	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  0058e	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  00591	7e 05		 jle	 SHORT $LN39@CheckUserC

; 1031 : 			{
; 1032 : 				continue;

  00593	e9 28 ff ff ff	 jmp	 $LN5@CheckUserC
$LN39@CheckUserC:

; 1033 : 			}
; 1034 : 
; 1035 : 			if((*(it)).m_bReqSpecialItem != FALSE)

  00598	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  0059e	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  005a3	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  005a7	74 3b		 je	 SHORT $LN40@CheckUserC

; 1036 : 			{
; 1037 : 				bool FindItem = this->SearchResetRequiredItem(lpObj,(*(it)).m_iRuleIndex);

  005a9	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  005af	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  005b4	8b 00		 mov	 eax, DWORD PTR [eax]
  005b6	50		 push	 eax
  005b7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  005ba	51		 push	 ecx
  005bb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005be	e8 00 00 00 00	 call	 ?SearchResetRequiredItem@CResetSystem@@QAE_NPAVOBJECTSTRUCT@@H@Z ; CResetSystem::SearchResetRequiredItem
  005c3	88 85 e3 fe ff
	ff		 mov	 BYTE PTR _FindItem$6[ebp], al

; 1038 : 
; 1039 : 				if( FindItem != true)

  005c9	0f b6 85 e3 fe
	ff ff		 movzx	 eax, BYTE PTR _FindItem$6[ebp]
  005d0	83 f8 01	 cmp	 eax, 1
  005d3	74 0f		 je	 SHORT $LN40@CheckUserC

; 1040 : 				{
; 1041 : 					bError = 2;

  005d5	c7 85 f4 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR _bError$[ebp], 2

; 1042 : 					continue;

  005df	e9 dc fe ff ff	 jmp	 $LN5@CheckUserC
$LN40@CheckUserC:

; 1043 : 				}
; 1044 : 			}
; 1045 : 			
; 1046 : 			if((*(it)).m_iCheckInventory != FALSE)

  005e4	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  005ea	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  005ef	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  005f3	74 20		 je	 SHORT $LN42@CheckUserC

; 1047 : 			{
; 1048 : 				BOOL Result = this->CheckUserEquipment(lpObj);

  005f5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  005f8	50		 push	 eax
  005f9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005fc	e8 00 00 00 00	 call	 ?CheckUserEquipment@CResetSystem@@QAEHPAVOBJECTSTRUCT@@@Z ; CResetSystem::CheckUserEquipment
  00601	89 85 dc fe ff
	ff		 mov	 DWORD PTR _Result$5[ebp], eax

; 1049 : 
; 1050 : 				if( Result != TRUE)

  00607	83 bd dc fe ff
	ff 01		 cmp	 DWORD PTR _Result$5[ebp], 1
  0060e	74 05		 je	 SHORT $LN42@CheckUserC

; 1051 : 				{
; 1052 : 					continue;

  00610	e9 ab fe ff ff	 jmp	 $LN5@CheckUserC
$LN42@CheckUserC:

; 1053 : 				}
; 1054 : 			}
; 1055 : 
; 1056 : 			//EnterCriticalSection(&this->m_cs);
; 1057 : 			this->DBReqUpdateReset(lpObj, (*(it)).m_iRuleIndex, (*(it)).m_bClearStat, (*(it)).m_iLevelAfterReset, (*(it)).m_iLevelUpPoint, (*(it)).m_bReqSpecialItem, (*(it)).m_bBornPlace, lpObj->m_iResetNumber+1, (*(it)).m_bClearBuffState, (*(it)).m_bClearMagicList);

  00615	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  0061b	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  00620	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  00623	50		 push	 eax
  00624	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  0062a	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  0062f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00632	51		 push	 ecx
  00633	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00636	8b 82 78 1a 00
	00		 mov	 eax, DWORD PTR [edx+6776]
  0063c	83 c0 01	 add	 eax, 1
  0063f	50		 push	 eax
  00640	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  00646	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  0064b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0064e	51		 push	 ecx
  0064f	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  00655	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  0065a	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0065d	52		 push	 edx
  0065e	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  00664	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  00669	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0066c	50		 push	 eax
  0066d	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  00673	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  00678	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0067b	51		 push	 ecx
  0067c	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  00682	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  00687	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0068a	52		 push	 edx
  0068b	8d 8d e4 fe ff
	ff		 lea	 ecx, DWORD PTR _it$7[ebp]
  00691	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  00696	8b 00		 mov	 eax, DWORD PTR [eax]
  00698	50		 push	 eax
  00699	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0069c	51		 push	 ecx
  0069d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  006a0	e8 00 00 00 00	 call	 ?DBReqUpdateReset@CResetSystem@@QAEXPAVOBJECTSTRUCT@@HHHHHHHHH@Z ; CResetSystem::DBReqUpdateReset

; 1058 : 			bError = FALSE;

  006a5	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _bError$[ebp], 0

; 1059 : 			break;

  006af	eb 05		 jmp	 SHORT $LN21@CheckUserC

; 1060 : 		}

  006b1	e9 0a fe ff ff	 jmp	 $LN5@CheckUserC
$LN21@CheckUserC:

; 1061 : 	}
; 1062 : 
; 1063 : 	if(bError == TRUE)

  006b6	83 bd f4 fe ff
	ff 01		 cmp	 DWORD PTR _bError$[ebp], 1
  006bd	75 15		 jne	 SHORT $LN1@CheckUserC

; 1064 : 	{
; 1065 : 		GCServerMsgStringSend("No tienes el nivel necesario para resetear!", lpObj->m_Index, 1); //[Reset System] Your current status doesn't meet the Requeriments. Try again later!

  006bf	6a 01		 push	 1
  006c1	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  006c4	8b 08		 mov	 ecx, DWORD PTR [eax]
  006c6	51		 push	 ecx
  006c7	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@OEAKHNJB@No?5tienes?5el?5nivel?5necesario?5pa@
  006cc	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  006d1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@CheckUserC:

; 1066 : 	}
; 1067 : }

  006d4	5f		 pop	 edi
  006d5	5e		 pop	 esi
  006d6	5b		 pop	 ebx
  006d7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006da	33 cd		 xor	 ecx, ebp
  006dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006e1	8b e5		 mov	 esp, ebp
  006e3	5d		 pop	 ebp
  006e4	c2 04 00	 ret	 4
?CheckUserCondition@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ENDP ; CResetSystem::CheckUserCondition
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?DeleteResetRequiredItem@CResetSystem@@QAEXPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
$T1 = -96						; size = 4
$T2 = -92						; size = 4
_iNEWOPTION$3 = -24					; size = 1
_iOPTION3$4 = -23					; size = 1
_iOPTION2$5 = -22					; size = 1
_iOPTION1$6 = -21					; size = 1
_iLEVEL$7 = -20						; size = 4
_pos$8 = -16						; size = 4
_ItemCount$9 = -12					; size = 4
_it$10 = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_iRuleIndex$ = 12					; size = 4
?DeleteResetRequiredItem@CResetSystem@@QAEXPAVOBJECTSTRUCT@@H@Z PROC ; CResetSystem::DeleteResetRequiredItem, COMDAT
; _this$ = ecx

; 807  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 808  : 	for ( std::vector<REQUIRE_SPECIAL_ITEM>::iterator it = this->m_vtReqSpecialItem.begin() ; it != this->m_vtReqSpecialItem.end() ; it++ ) //it will check all rules

  0000c	8d 45 f8	 lea	 eax, DWORD PTR _it$10[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 50	 add	 ecx, 80			; 00000050H
  00016	e8 00 00 00 00	 call	 ?begin@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@2@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::begin
  0001b	eb 0e		 jmp	 SHORT $LN4@DeleteRese
$LN2@DeleteRese:
  0001d	6a 00		 push	 0
  0001f	8d 45 a4	 lea	 eax, DWORD PTR $T2[ebp]
  00022	50		 push	 eax
  00023	8d 4d f8	 lea	 ecx, DWORD PTR _it$10[ebp]
  00026	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator++
$LN4@DeleteRese:
  0002b	8d 45 a0	 lea	 eax, DWORD PTR $T1[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	83 c1 50	 add	 ecx, 80			; 00000050H
  00035	e8 00 00 00 00	 call	 ?end@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@2@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::end
  0003a	50		 push	 eax
  0003b	8d 4d f8	 lea	 ecx, DWORD PTR _it$10[ebp]
  0003e	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator!=
  00043	0f b6 c8	 movzx	 ecx, al
  00046	85 c9		 test	 ecx, ecx
  00048	0f 84 60 02 00
	00		 je	 $LN1@DeleteRese

; 809  : 	{
; 810  : 		if((*(it)).m_iResetRuleIndex != iRuleIndex)

  0004e	8d 4d f8	 lea	 ecx, DWORD PTR _it$10[ebp]
  00051	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  00056	8b 00		 mov	 eax, DWORD PTR [eax]
  00058	3b 45 0c	 cmp	 eax, DWORD PTR _iRuleIndex$[ebp]
  0005b	74 02		 je	 SHORT $LN8@DeleteRese

; 811  : 		{
; 812  : 			continue;

  0005d	eb be		 jmp	 SHORT $LN2@DeleteRese
$LN8@DeleteRese:

; 813  : 		}
; 814  : 
; 815  : 		int ItemCount = 0; //

  0005f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ItemCount$9[ebp], 0

; 816  : 
; 817  : #ifdef PERSONAL_SHOP_20040113
; 818  : 		for( int pos=0; pos<MAX_INVENTORY_EXTEND; pos++)

  00066	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pos$8[ebp], 0
  0006d	eb 09		 jmp	 SHORT $LN7@DeleteRese
$LN5@DeleteRese:
  0006f	8b 45 f0	 mov	 eax, DWORD PTR _pos$8[ebp]
  00072	83 c0 01	 add	 eax, 1
  00075	89 45 f0	 mov	 DWORD PTR _pos$8[ebp], eax
$LN7@DeleteRese:
  00078	83 7d f0 6c	 cmp	 DWORD PTR _pos$8[ebp], 108 ; 0000006cH
  0007c	0f 8d 27 02 00
	00		 jge	 $LN6@DeleteRese

; 819  : #else
; 820  : 		for( int pos=0; pos<MAX_INVENTORY; pos++)
; 821  : #endif
; 822  : 		{
; 823  : 			if ( lpObj->pInventory[pos].IsItem() == TRUE )

  00082	69 4d f0 a8 00
	00 00		 imul	 ecx, DWORD PTR _pos$8[ebp], 168
  00089	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008c	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00092	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00097	83 f8 01	 cmp	 eax, 1
  0009a	0f 85 04 02 00
	00		 jne	 $LN9@DeleteRese

; 824  : 			{
; 825  : 				if ( lpObj->pInventory[pos].m_Type == MAKE_ITEMNUM((*(it)).m_iItemCategory,(*(it)).m_iItemCode) )

  000a0	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _pos$8[ebp], 168
  000a7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000aa	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000b0	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000b5	8d 4d f8	 lea	 ecx, DWORD PTR _it$10[ebp]
  000b8	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  000bd	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c0	50		 push	 eax
  000c1	8d 4d f8	 lea	 ecx, DWORD PTR _it$10[ebp]
  000c4	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  000c9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cc	51		 push	 ecx
  000cd	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000d2	83 c4 08	 add	 esp, 8
  000d5	3b f0		 cmp	 esi, eax
  000d7	0f 85 c7 01 00
	00		 jne	 $LN9@DeleteRese

; 826  : 				{
; 827  : 					int iLEVEL = lpObj->pInventory[pos].m_Level;

  000dd	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _pos$8[ebp], 168
  000e4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000e7	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000ed	0f bf 44 02 08	 movsx	 eax, WORD PTR [edx+eax+8]
  000f2	89 45 ec	 mov	 DWORD PTR _iLEVEL$7[ebp], eax

; 828  : 					BYTE iOPTION1 = lpObj->pInventory[pos].m_Option1;

  000f5	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _pos$8[ebp], 168
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ff	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00105	8a 44 02 78	 mov	 al, BYTE PTR [edx+eax+120]
  00109	88 45 eb	 mov	 BYTE PTR _iOPTION1$6[ebp], al

; 829  : 					BYTE iOPTION2 = lpObj->pInventory[pos].m_Option2;

  0010c	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _pos$8[ebp], 168
  00113	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00116	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0011c	8a 44 02 79	 mov	 al, BYTE PTR [edx+eax+121]
  00120	88 45 ea	 mov	 BYTE PTR _iOPTION2$5[ebp], al

; 830  : 					BYTE iOPTION3 = lpObj->pInventory[pos].m_Option3;

  00123	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _pos$8[ebp], 168
  0012a	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0012d	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00133	8a 44 02 7a	 mov	 al, BYTE PTR [edx+eax+122]
  00137	88 45 e9	 mov	 BYTE PTR _iOPTION3$4[ebp], al

; 831  : 					BYTE iNEWOPTION = lpObj->pInventory[pos].m_NewOption;

  0013a	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _pos$8[ebp], 168
  00141	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00144	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0014a	8a 44 02 7b	 mov	 al, BYTE PTR [edx+eax+123]
  0014e	88 45 e8	 mov	 BYTE PTR _iNEWOPTION$3[ebp], al

; 832  : 
; 833  : 					if ( iLEVEL != -1 && iLEVEL != (*(it)).m_iItemLevel)

  00151	83 7d ec ff	 cmp	 DWORD PTR _iLEVEL$7[ebp], -1
  00155	74 15		 je	 SHORT $LN11@DeleteRese
  00157	8d 4d f8	 lea	 ecx, DWORD PTR _it$10[ebp]
  0015a	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  0015f	8b 4d ec	 mov	 ecx, DWORD PTR _iLEVEL$7[ebp]
  00162	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00165	74 05		 je	 SHORT $LN11@DeleteRese

; 834  : 					{
; 835  : 						continue;

  00167	e9 03 ff ff ff	 jmp	 $LN5@DeleteRese
$LN11@DeleteRese:

; 836  : 					}
; 837  : 
; 838  : 					if ( iOPTION1 != -1 && iOPTION1 != (*(it)).m_btOption1)

  0016c	0f b6 45 eb	 movzx	 eax, BYTE PTR _iOPTION1$6[ebp]
  00170	83 f8 ff	 cmp	 eax, -1
  00173	74 19		 je	 SHORT $LN12@DeleteRese
  00175	0f b6 75 eb	 movzx	 esi, BYTE PTR _iOPTION1$6[ebp]
  00179	8d 4d f8	 lea	 ecx, DWORD PTR _it$10[ebp]
  0017c	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  00181	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  00185	3b f0		 cmp	 esi, eax
  00187	74 05		 je	 SHORT $LN12@DeleteRese

; 839  : 					{
; 840  : 						continue;

  00189	e9 e1 fe ff ff	 jmp	 $LN5@DeleteRese
$LN12@DeleteRese:

; 841  : 					}
; 842  : 
; 843  : 					if ( iOPTION2 != -1 && iOPTION2 != (*(it)).m_btOption2)

  0018e	0f b6 45 ea	 movzx	 eax, BYTE PTR _iOPTION2$5[ebp]
  00192	83 f8 ff	 cmp	 eax, -1
  00195	74 19		 je	 SHORT $LN13@DeleteRese
  00197	0f b6 75 ea	 movzx	 esi, BYTE PTR _iOPTION2$5[ebp]
  0019b	8d 4d f8	 lea	 ecx, DWORD PTR _it$10[ebp]
  0019e	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  001a3	0f b6 40 11	 movzx	 eax, BYTE PTR [eax+17]
  001a7	3b f0		 cmp	 esi, eax
  001a9	74 05		 je	 SHORT $LN13@DeleteRese

; 844  : 					{
; 845  : 						continue;

  001ab	e9 bf fe ff ff	 jmp	 $LN5@DeleteRese
$LN13@DeleteRese:

; 846  : 					}
; 847  : 
; 848  : 					if ( iOPTION3 != -1 && iOPTION3 != (*(it)).m_btOption3)

  001b0	0f b6 45 e9	 movzx	 eax, BYTE PTR _iOPTION3$4[ebp]
  001b4	83 f8 ff	 cmp	 eax, -1
  001b7	74 19		 je	 SHORT $LN14@DeleteRese
  001b9	0f b6 75 e9	 movzx	 esi, BYTE PTR _iOPTION3$4[ebp]
  001bd	8d 4d f8	 lea	 ecx, DWORD PTR _it$10[ebp]
  001c0	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  001c5	0f b6 40 12	 movzx	 eax, BYTE PTR [eax+18]
  001c9	3b f0		 cmp	 esi, eax
  001cb	74 05		 je	 SHORT $LN14@DeleteRese

; 849  : 					{
; 850  : 						continue;

  001cd	e9 9d fe ff ff	 jmp	 $LN5@DeleteRese
$LN14@DeleteRese:

; 851  : 					}
; 852  : 
; 853  : 					if ( iNEWOPTION != -1 && iNEWOPTION != (*(it)).m_btNewOption)

  001d2	0f b6 45 e8	 movzx	 eax, BYTE PTR _iNEWOPTION$3[ebp]
  001d6	83 f8 ff	 cmp	 eax, -1
  001d9	74 19		 je	 SHORT $LN15@DeleteRese
  001db	0f b6 75 e8	 movzx	 esi, BYTE PTR _iNEWOPTION$3[ebp]
  001df	8d 4d f8	 lea	 ecx, DWORD PTR _it$10[ebp]
  001e2	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  001e7	0f b6 40 13	 movzx	 eax, BYTE PTR [eax+19]
  001eb	3b f0		 cmp	 esi, eax
  001ed	74 05		 je	 SHORT $LN15@DeleteRese

; 854  : 					{
; 855  : 						continue;

  001ef	e9 7b fe ff ff	 jmp	 $LN5@DeleteRese
$LN15@DeleteRese:

; 856  : 					}
; 857  : 
; 858  : 					if ( (*(it)).m_iItemPosition != -1 && pos != (*(it)).m_iItemPosition)

  001f4	8d 4d f8	 lea	 ecx, DWORD PTR _it$10[ebp]
  001f7	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  001fc	83 78 18 ff	 cmp	 DWORD PTR [eax+24], -1
  00200	74 15		 je	 SHORT $LN16@DeleteRese
  00202	8d 4d f8	 lea	 ecx, DWORD PTR _it$10[ebp]
  00205	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  0020a	8b 4d f0	 mov	 ecx, DWORD PTR _pos$8[ebp]
  0020d	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00210	74 05		 je	 SHORT $LN16@DeleteRese

; 859  : 					{
; 860  : 						continue;

  00212	e9 58 fe ff ff	 jmp	 $LN5@DeleteRese
$LN16@DeleteRese:

; 861  : 					}
; 862  : 
; 863  : 					LogAddTD("[Reset System] Force (Account:%s, Name:%s) to Delete Required Item in Pos:(%d) [Serial:%d]", lpObj->AccountID, lpObj->Name, pos, lpObj->pInventory[pos].m_Number);

  00217	69 45 f0 a8 00
	00 00		 imul	 eax, DWORD PTR _pos$8[ebp], 168
  0021e	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00221	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00227	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0022a	50		 push	 eax
  0022b	8b 4d f0	 mov	 ecx, DWORD PTR _pos$8[ebp]
  0022e	51		 push	 ecx
  0022f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00232	83 c2 73	 add	 edx, 115		; 00000073H
  00235	52		 push	 edx
  00236	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00239	83 c0 68	 add	 eax, 104		; 00000068H
  0023c	50		 push	 eax
  0023d	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@KIAHIDBE@?$FLReset?5System?$FN?5Force?5?$CIAccount?3?$CF@
  00242	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00248	83 c4 14	 add	 esp, 20			; 00000014H

; 864  : 							
; 865  : 					::gObjInventoryItemSet(lpObj->m_Index, pos, -1);

  0024b	68 ff 00 00 00	 push	 255			; 000000ffH
  00250	8b 45 f0	 mov	 eax, DWORD PTR _pos$8[ebp]
  00253	50		 push	 eax
  00254	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00257	8b 11		 mov	 edx, DWORD PTR [ecx]
  00259	52		 push	 edx
  0025a	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet
  0025f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 866  : 					::gObjInventoryDeleteItem(lpObj->m_Index, pos);

  00262	8b 45 f0	 mov	 eax, DWORD PTR _pos$8[ebp]
  00265	50		 push	 eax
  00266	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00269	8b 11		 mov	 edx, DWORD PTR [ecx]
  0026b	52		 push	 edx
  0026c	e8 00 00 00 00	 call	 ?gObjInventoryDeleteItem@@YAEHH@Z ; gObjInventoryDeleteItem
  00271	83 c4 08	 add	 esp, 8

; 867  : 					::GCInventoryItemDeleteSend(lpObj->m_Index, pos, true);

  00274	6a 01		 push	 1
  00276	0f b6 45 f0	 movzx	 eax, BYTE PTR _pos$8[ebp]
  0027a	50		 push	 eax
  0027b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0027e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00280	52		 push	 edx
  00281	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00286	83 c4 0c	 add	 esp, 12			; 0000000cH

; 868  : 
; 869  : 					ItemCount++;

  00289	8b 45 f4	 mov	 eax, DWORD PTR _ItemCount$9[ebp]
  0028c	83 c0 01	 add	 eax, 1
  0028f	89 45 f4	 mov	 DWORD PTR _ItemCount$9[ebp], eax

; 870  : 
; 871  : 					if(ItemCount >= (*(it)).m_iItemNumber) //Prevent Multi Delete

  00292	8d 4d f8	 lea	 ecx, DWORD PTR _it$10[ebp]
  00295	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  0029a	8b 4d f4	 mov	 ecx, DWORD PTR _ItemCount$9[ebp]
  0029d	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  002a0	7c 02		 jl	 SHORT $LN9@DeleteRese

; 872  : 					{
; 873  : 						break; //break the "for" of inventory not the vector "for"

  002a2	eb 05		 jmp	 SHORT $LN6@DeleteRese
$LN9@DeleteRese:

; 874  : 					}
; 875  : 				}
; 876  : 			}
; 877  : 		}

  002a4	e9 c6 fd ff ff	 jmp	 $LN5@DeleteRese
$LN6@DeleteRese:

; 878  : 	}

  002a9	e9 6f fd ff ff	 jmp	 $LN2@DeleteRese
$LN1@DeleteRese:

; 879  : }

  002ae	5f		 pop	 edi
  002af	5e		 pop	 esi
  002b0	5b		 pop	 ebx
  002b1	8b e5		 mov	 esp, ebp
  002b3	5d		 pop	 ebp
  002b4	c2 08 00	 ret	 8
?DeleteResetRequiredItem@CResetSystem@@QAEXPAVOBJECTSTRUCT@@H@Z ENDP ; CResetSystem::DeleteResetRequiredItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?SearchResetRequiredItem@CResetSystem@@QAE_NPAVOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
$T1 = -680						; size = 4
$T2 = -676						; size = 4
_szTemp$3 = -544					; size = 256
_p$4 = -288						; size = 4
_szTemp$5 = -284					; size = 256
_p$6 = -28						; size = 4
_n$7 = -24						; size = 4
_it$8 = -20						; size = 4
_itemcount$ = -16					; size = 4
_SearchCount$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iRuleIndex$ = 12					; size = 4
?SearchResetRequiredItem@CResetSystem@@QAE_NPAVOBJECTSTRUCT@@H@Z PROC ; CResetSystem::SearchResetRequiredItem, COMDAT
; _this$ = ecx

; 702  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 02 00
	00		 sub	 esp, 680		; 000002a8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 703  : 	int SearchCount = 0;

  00019	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _SearchCount$[ebp], 0

; 704  : 	int itemcount = 0;

  00020	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _itemcount$[ebp], 0

; 705  : 
; 706  : 	for ( std::vector<REQUIRE_SPECIAL_ITEM>::iterator it = this->m_vtReqSpecialItem.begin() ; it != this->m_vtReqSpecialItem.end() ; it++ )

  00027	8d 45 ec	 lea	 eax, DWORD PTR _it$8[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	83 c1 50	 add	 ecx, 80			; 00000050H
  00031	e8 00 00 00 00	 call	 ?begin@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@2@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::begin
  00036	eb 11		 jmp	 SHORT $LN4@SearchRese
$LN2@SearchRese:
  00038	6a 00		 push	 0
  0003a	8d 85 5c fd ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00040	50		 push	 eax
  00041	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  00044	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator++
$LN4@SearchRese:
  00049	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0004f	50		 push	 eax
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 c1 50	 add	 ecx, 80			; 00000050H
  00056	e8 00 00 00 00	 call	 ?end@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@2@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::end
  0005b	50		 push	 eax
  0005c	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  0005f	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator!=
  00064	0f b6 c8	 movzx	 ecx, al
  00067	85 c9		 test	 ecx, ecx
  00069	0f 84 eb 02 00
	00		 je	 $LN3@SearchRese

; 707  : 	{
; 708  : 		if((*(it)).m_iResetRuleIndex != iRuleIndex)

  0006f	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  00072	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  00077	8b 00		 mov	 eax, DWORD PTR [eax]
  00079	3b 45 0c	 cmp	 eax, DWORD PTR _iRuleIndex$[ebp]
  0007c	74 02		 je	 SHORT $LN8@SearchRese

; 709  : 		{
; 710  : 			continue;

  0007e	eb b8		 jmp	 SHORT $LN2@SearchRese
$LN8@SearchRese:

; 711  : 		}
; 712  : 
; 713  : 		itemcount++;

  00080	8b 45 f0	 mov	 eax, DWORD PTR _itemcount$[ebp]
  00083	83 c0 01	 add	 eax, 1
  00086	89 45 f0	 mov	 DWORD PTR _itemcount$[ebp], eax

; 714  : 		SearchCount = 0;

  00089	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _SearchCount$[ebp], 0

; 715  : 
; 716  : 		//EnterCriticalSection(&this->m_cs);
; 717  : 
; 718  : #ifdef PERSONAL_SHOP_20040113
; 719  : 		for( int n=0; n<MAX_INVENTORY_EXTEND; n++)

  00090	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _n$7[ebp], 0
  00097	eb 09		 jmp	 SHORT $LN7@SearchRese
$LN5@SearchRese:
  00099	8b 45 e8	 mov	 eax, DWORD PTR _n$7[ebp]
  0009c	83 c0 01	 add	 eax, 1
  0009f	89 45 e8	 mov	 DWORD PTR _n$7[ebp], eax
$LN7@SearchRese:
  000a2	83 7d e8 6c	 cmp	 DWORD PTR _n$7[ebp], 108 ; 0000006cH
  000a6	0f 8d ad 01 00
	00		 jge	 $LN6@SearchRese

; 720  : #else
; 721  : 		for( int n=0; n<MAX_INVENTORY; n++)
; 722  : #endif
; 723  : 		{
; 724  : 			if ( lpObj->pInventory[n].IsItem() == TRUE )

  000ac	69 4d e8 a8 00
	00 00		 imul	 ecx, DWORD PTR _n$7[ebp], 168
  000b3	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b6	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  000bc	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000c1	83 f8 01	 cmp	 eax, 1
  000c4	0f 85 8a 01 00
	00		 jne	 $LN9@SearchRese

; 725  : 			{
; 726  : 				if ( lpObj->pInventory[n].m_Type == MakeItemNumber((*(it)).m_iItemCategory,(*(it)).m_iItemCode) )

  000ca	69 45 e8 a8 00
	00 00		 imul	 eax, DWORD PTR _n$7[ebp], 168
  000d1	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000d4	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  000da	0f bf 74 02 06	 movsx	 esi, WORD PTR [edx+eax+6]
  000df	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  000e2	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  000e7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000ea	50		 push	 eax
  000eb	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  000ee	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  000f3	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000f6	51		 push	 ecx
  000f7	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000fc	83 c4 08	 add	 esp, 8
  000ff	3b f0		 cmp	 esi, eax
  00101	0f 85 4d 01 00
	00		 jne	 $LN9@SearchRese

; 727  : 				{
; 728  : 					if ( (*(it)).m_iItemLevel != -1 )

  00107	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  0010a	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  0010f	83 78 0c ff	 cmp	 DWORD PTR [eax+12], -1
  00113	74 27		 je	 SHORT $LN11@SearchRese

; 729  : 					{
; 730  : 						if (  lpObj->pInventory[n].m_Level != (*(it)).m_iItemLevel )

  00115	69 45 e8 a8 00
	00 00		 imul	 eax, DWORD PTR _n$7[ebp], 168
  0011c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0011f	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00125	0f bf 74 02 08	 movsx	 esi, WORD PTR [edx+eax+8]
  0012a	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  0012d	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  00132	3b 70 0c	 cmp	 esi, DWORD PTR [eax+12]
  00135	74 05		 je	 SHORT $LN11@SearchRese

; 731  : 						{
; 732  : 							continue;

  00137	e9 5d ff ff ff	 jmp	 $LN5@SearchRese
$LN11@SearchRese:

; 733  : 						}
; 734  : 					}
; 735  : 
; 736  : 					if ( (*(it)).m_btOption1 != -1 )

  0013c	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  0013f	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  00144	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  00148	83 f8 ff	 cmp	 eax, -1
  0014b	74 2a		 je	 SHORT $LN13@SearchRese

; 737  : 					{
; 738  : 						if (  lpObj->pInventory[n].m_Option1 != (*(it)).m_btOption1 )

  0014d	69 45 e8 a8 00
	00 00		 imul	 eax, DWORD PTR _n$7[ebp], 168
  00154	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00157	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0015d	0f b6 74 02 78	 movzx	 esi, BYTE PTR [edx+eax+120]
  00162	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  00165	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  0016a	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  0016e	3b f0		 cmp	 esi, eax
  00170	74 05		 je	 SHORT $LN13@SearchRese

; 739  : 						{
; 740  : 							continue;

  00172	e9 22 ff ff ff	 jmp	 $LN5@SearchRese
$LN13@SearchRese:

; 741  : 						}
; 742  : 					}
; 743  : 
; 744  : 					if ( (*(it)).m_btOption2 != -1 )

  00177	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  0017a	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  0017f	0f b6 40 11	 movzx	 eax, BYTE PTR [eax+17]
  00183	83 f8 ff	 cmp	 eax, -1
  00186	74 2a		 je	 SHORT $LN15@SearchRese

; 745  : 					{
; 746  : 						if (  lpObj->pInventory[n].m_Option2 != (*(it)).m_btOption2 )

  00188	69 45 e8 a8 00
	00 00		 imul	 eax, DWORD PTR _n$7[ebp], 168
  0018f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00192	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  00198	0f b6 74 02 79	 movzx	 esi, BYTE PTR [edx+eax+121]
  0019d	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  001a0	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  001a5	0f b6 40 11	 movzx	 eax, BYTE PTR [eax+17]
  001a9	3b f0		 cmp	 esi, eax
  001ab	74 05		 je	 SHORT $LN15@SearchRese

; 747  : 						{
; 748  : 							continue;

  001ad	e9 e7 fe ff ff	 jmp	 $LN5@SearchRese
$LN15@SearchRese:

; 749  : 						}
; 750  : 					}
; 751  : 
; 752  : 					if ( (*(it)).m_btOption3 != -1 )

  001b2	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  001b5	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  001ba	0f b6 40 12	 movzx	 eax, BYTE PTR [eax+18]
  001be	83 f8 ff	 cmp	 eax, -1
  001c1	74 2a		 je	 SHORT $LN17@SearchRese

; 753  : 					{
; 754  : 						if (  lpObj->pInventory[n].m_Option3 != (*(it)).m_btOption3 )

  001c3	69 45 e8 a8 00
	00 00		 imul	 eax, DWORD PTR _n$7[ebp], 168
  001ca	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  001cd	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  001d3	0f b6 74 02 7a	 movzx	 esi, BYTE PTR [edx+eax+122]
  001d8	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  001db	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  001e0	0f b6 40 12	 movzx	 eax, BYTE PTR [eax+18]
  001e4	3b f0		 cmp	 esi, eax
  001e6	74 05		 je	 SHORT $LN17@SearchRese

; 755  : 						{
; 756  : 							continue;

  001e8	e9 ac fe ff ff	 jmp	 $LN5@SearchRese
$LN17@SearchRese:

; 757  : 						}
; 758  : 					}
; 759  : 
; 760  : 					if ( (*(it)).m_btNewOption != -1 )

  001ed	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  001f0	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  001f5	0f b6 40 13	 movzx	 eax, BYTE PTR [eax+19]
  001f9	83 f8 ff	 cmp	 eax, -1
  001fc	74 2a		 je	 SHORT $LN19@SearchRese

; 761  : 					{
; 762  : 						if (  lpObj->pInventory[n].m_NewOption != (*(it)).m_btNewOption )

  001fe	69 45 e8 a8 00
	00 00		 imul	 eax, DWORD PTR _n$7[ebp], 168
  00205	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00208	8b 91 5c 0c 00
	00		 mov	 edx, DWORD PTR [ecx+3164]
  0020e	0f b6 74 02 7b	 movzx	 esi, BYTE PTR [edx+eax+123]
  00213	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  00216	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  0021b	0f b6 40 13	 movzx	 eax, BYTE PTR [eax+19]
  0021f	3b f0		 cmp	 esi, eax
  00221	74 05		 je	 SHORT $LN19@SearchRese

; 763  : 						{
; 764  : 							continue;

  00223	e9 71 fe ff ff	 jmp	 $LN5@SearchRese
$LN19@SearchRese:

; 765  : 						}
; 766  : 					}
; 767  : 
; 768  : 					if ( (*(it)).m_iItemPosition != -1 )

  00228	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  0022b	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  00230	83 78 18 ff	 cmp	 DWORD PTR [eax+24], -1
  00234	74 15		 je	 SHORT $LN21@SearchRese

; 769  : 					{
; 770  : 						if (n != (*(it)).m_iItemPosition )

  00236	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  00239	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  0023e	8b 4d e8	 mov	 ecx, DWORD PTR _n$7[ebp]
  00241	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00244	74 05		 je	 SHORT $LN21@SearchRese

; 771  : 						{
; 772  : 							continue;

  00246	e9 4e fe ff ff	 jmp	 $LN5@SearchRese
$LN21@SearchRese:

; 773  : 						}
; 774  : 					}
; 775  : 
; 776  : 					SearchCount++;

  0024b	8b 45 f4	 mov	 eax, DWORD PTR _SearchCount$[ebp]
  0024e	83 c0 01	 add	 eax, 1
  00251	89 45 f4	 mov	 DWORD PTR _SearchCount$[ebp], eax
$LN9@SearchRese:

; 777  : 				}
; 778  : 			}
; 779  : 		}

  00254	e9 40 fe ff ff	 jmp	 $LN5@SearchRese
$LN6@SearchRese:

; 780  : 
; 781  : 		if ( SearchCount < (*(it)).m_iItemNumber)

  00259	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  0025c	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  00261	8b 4d f4	 mov	 ecx, DWORD PTR _SearchCount$[ebp]
  00264	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00267	7d 71		 jge	 SHORT $LN23@SearchRese

; 782  : 		{
; 783  : 			ITEM_ATTRIBUTE *p = &ItemAttribute[MAKE_ITEMNUM((*(it)).m_iItemCategory, (*(it)).m_iItemCode) ];

  00269	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  0026c	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  00271	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00274	50		 push	 eax
  00275	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  00278	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  0027d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00280	51		 push	 ecx
  00281	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00286	83 c4 08	 add	 esp, 8
  00289	6b d0 6c	 imul	 edx, eax, 108
  0028c	81 c2 00 00 00
	00		 add	 edx, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00292	89 55 e4	 mov	 DWORD PTR _p$6[ebp], edx

; 784  : 			char szTemp[256];
; 785  : 			wsprintf(szTemp,"Fallo al resetear. Tienes (%d of %d -> %s) de los objetos necesarios para resetear.", SearchCount, (*(it)).m_iItemNumber, p->Name); //[Reset System] Failed to Reset. You have (%d of %d -> %s) Required Item.

  00295	8b 45 e4	 mov	 eax, DWORD PTR _p$6[ebp]
  00298	50		 push	 eax
  00299	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  0029c	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  002a1	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002a4	51		 push	 ecx
  002a5	8b 55 f4	 mov	 edx, DWORD PTR _SearchCount$[ebp]
  002a8	52		 push	 edx
  002a9	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@BLGOPBEG@Fallo?5al?5resetear?4?5Tienes?5?$CI?$CFd?5o@
  002ae	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$5[ebp]
  002b4	50		 push	 eax
  002b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  002bb	83 c4 14	 add	 esp, 20			; 00000014H

; 786  : 			GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  002be	6a 01		 push	 1
  002c0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c5	51		 push	 ecx
  002c6	8d 95 e4 fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$5[ebp]
  002cc	52		 push	 edx
  002cd	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  002d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 787  : 			continue;

  002d5	e9 5e fd ff ff	 jmp	 $LN2@SearchRese
$LN23@SearchRese:

; 788  : 		}
; 789  : 
; 790  : 		itemcount--;

  002da	8b 45 f0	 mov	 eax, DWORD PTR _itemcount$[ebp]
  002dd	83 e8 01	 sub	 eax, 1
  002e0	89 45 f0	 mov	 DWORD PTR _itemcount$[ebp], eax

; 791  : 		
; 792  : 		ITEM_ATTRIBUTE *p = &ItemAttribute[MAKE_ITEMNUM((*(it)).m_iItemCategory, (*(it)).m_iItemCode) ];

  002e3	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  002e6	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  002eb	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  002ee	50		 push	 eax
  002ef	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  002f2	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  002f7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002fa	51		 push	 ecx
  002fb	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00300	83 c4 08	 add	 esp, 8
  00303	6b d0 6c	 imul	 edx, eax, 108
  00306	81 c2 00 00 00
	00		 add	 edx, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  0030c	89 95 e0 fe ff
	ff		 mov	 DWORD PTR _p$4[ebp], edx

; 793  : 		char szTemp[256];
; 794  : 		wsprintf(szTemp,"Se encontraron (%d de %d -> %s) de los objetos necesarios para resetear.", SearchCount, (*(it)).m_iItemNumber, p->Name); //[Reset System] Found Valid (%d of %d -> %s) Required Item.

  00312	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _p$4[ebp]
  00318	50		 push	 eax
  00319	8d 4d ec	 lea	 ecx, DWORD PTR _it$8[ebp]
  0031c	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@@std@@QBEAAUREQUIRE_SPECIAL_ITEM@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<REQUIRE_SPECIAL_ITEM> > >::operator*
  00321	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00324	51		 push	 ecx
  00325	8b 55 f4	 mov	 edx, DWORD PTR _SearchCount$[ebp]
  00328	52		 push	 edx
  00329	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@KAAHMMNN@Se?5encontraron?5?$CI?$CFd?5de?5?$CFd?5?9?$DO?5?$CFs?$CJ@
  0032e	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _szTemp$3[ebp]
  00334	50		 push	 eax
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0033b	83 c4 14	 add	 esp, 20			; 00000014H

; 795  : 		GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  0033e	6a 01		 push	 1
  00340	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00343	8b 08		 mov	 ecx, DWORD PTR [eax]
  00345	51		 push	 ecx
  00346	8d 95 e0 fd ff
	ff		 lea	 edx, DWORD PTR _szTemp$3[ebp]
  0034c	52		 push	 edx
  0034d	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  00352	83 c4 0c	 add	 esp, 12			; 0000000cH

; 796  : 	}

  00355	e9 de fc ff ff	 jmp	 $LN2@SearchRese
$LN3@SearchRese:

; 797  : 
; 798  : 	if(itemcount == 0) //Perfect

  0035a	83 7d f0 00	 cmp	 DWORD PTR _itemcount$[ebp], 0
  0035e	75 04		 jne	 SHORT $LN24@SearchRese

; 799  : 	{
; 800  : 		return true;

  00360	b0 01		 mov	 al, 1
  00362	eb 02		 jmp	 SHORT $LN1@SearchRese
$LN24@SearchRese:

; 801  : 	}
; 802  : 
; 803  : 	return false;

  00364	32 c0		 xor	 al, al
$LN1@SearchRese:

; 804  : }

  00366	5f		 pop	 edi
  00367	5e		 pop	 esi
  00368	5b		 pop	 ebx
  00369	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0036c	33 cd		 xor	 ecx, ebp
  0036e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00373	8b e5		 mov	 esp, ebp
  00375	5d		 pop	 ebp
  00376	c2 08 00	 ret	 8
?SearchResetRequiredItem@CResetSystem@@QAE_NPAVOBJECTSTRUCT@@H@Z ENDP ; CResetSystem::SearchResetRequiredItem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?UpdateUserStatusPoint@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iCharacterClass$ = -8					; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?UpdateUserStatusPoint@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z PROC ; CResetSystem::UpdateUserStatusPoint, COMDAT
; _this$ = ecx

; 659  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 660  : 	/*PMSG_STAT_UPDATE pMsg;
; 661  : 	::PHeadSetB((LPBYTE)&pMsg,0x2C,sizeof(PMSG_STAT_UPDATE));
; 662  : 
; 663  : 	pMsg.result = 3;
; 664  : 
; 665  : 	int iCharacterClass = lpObj->Class;
; 666  : 	int iReduceStr = 0;
; 667  : 	int iReduceDtx = 0;
; 668  : 	int iReduceVit = 0;
; 669  : 	int iReduceEne = 0;
; 670  : 	int iReduceCmd = 0;
; 671  : 
; 672  : 	if(lpObj->Strength > DCInfo.DefClass[iCharacterClass].Strength){iReduceStr = lpObj->Strength - DCInfo.DefClass[iCharacterClass].Strength;}
; 673  : 	if(lpObj->Dexterity > DCInfo.DefClass[iCharacterClass].Dexterity){iReduceDtx = lpObj->Dexterity - DCInfo.DefClass[iCharacterClass].Dexterity;}
; 674  : 	if(lpObj->Vitality > DCInfo.DefClass[iCharacterClass].Vitality){iReduceVit = lpObj->Vitality - DCInfo.DefClass[iCharacterClass].Vitality;}
; 675  : 	if(lpObj->Energy > DCInfo.DefClass[iCharacterClass].Energy){iReduceEne = lpObj->Energy - DCInfo.DefClass[iCharacterClass].Energy;}
; 676  : 	if(lpObj->Leadership > DCInfo.DefClass[iCharacterClass].Leadership){iReduceCmd = lpObj->Leadership - DCInfo.DefClass[iCharacterClass].Leadership;}
; 677  : 
; 678  : 	int i; for(i = 0; i < 5; i++) // -> GameServer 1.00.19 Specialty
; 679  : 	{
; 680  : 		switch(i)
; 681  : 		{
; 682  : 			case 4:{pMsg.btFruitType = 4;	pMsg.btStatValue = iReduceCmd;	lpObj->Leadership	-= iReduceCmd;}		break;
; 683  : 			case 3:{pMsg.btFruitType = 3;	pMsg.btStatValue = iReduceStr;	lpObj->Strength		-= iReduceStr;}		break;
; 684  : 			case 2:{pMsg.btFruitType = 2;	pMsg.btStatValue = iReduceDtx;	lpObj->Dexterity	-= iReduceDtx;}		break;
; 685  : 			case 1:{pMsg.btFruitType = 1;	pMsg.btStatValue = iReduceVit;	lpObj->Vitality		-= iReduceVit;}		break;
; 686  : 			case 0:{pMsg.btFruitType = 0;	pMsg.btStatValue = iReduceEne;	lpObj->Energy		-= iReduceEne;}		break;
; 687  : 		}
; 688  : 		DataSend(lpObj->m_Index,(LPBYTE)&pMsg,pMsg.h.size);
; 689  : 	}*/
; 690  : 
; 691  : 	int iCharacterClass = lpObj->Class;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000f	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00016	89 4d f8	 mov	 DWORD PTR _iCharacterClass$[ebp], ecx

; 692  : 	if(lpObj->Strength > DCInfo.DefClass[iCharacterClass].Strength){lpObj->Strength = DCInfo.DefClass[iCharacterClass].Strength;}

  00019	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	0f b7 88 b4 00
	00 00		 movzx	 ecx, WORD PTR [eax+180]
  00023	69 55 f8 60 09
	00 00		 imul	 edx, DWORD PTR _iCharacterClass$[ebp], 2400
  0002a	0f b7 82 08 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[edx+8]
  00031	3b c8		 cmp	 ecx, eax
  00033	7e 18		 jle	 SHORT $LN2@UpdateUser
  00035	69 45 f8 60 09
	00 00		 imul	 eax, DWORD PTR _iCharacterClass$[ebp], 2400
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0003f	66 8b 90 08 00
	00 00		 mov	 dx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+8]
  00046	66 89 91 b4 00
	00 00		 mov	 WORD PTR [ecx+180], dx
$LN2@UpdateUser:

; 693  : 	if(lpObj->Dexterity > DCInfo.DefClass[iCharacterClass].Dexterity){lpObj->Dexterity = DCInfo.DefClass[iCharacterClass].Dexterity;}

  0004d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00050	0f b7 88 b6 00
	00 00		 movzx	 ecx, WORD PTR [eax+182]
  00057	69 55 f8 60 09
	00 00		 imul	 edx, DWORD PTR _iCharacterClass$[ebp], 2400
  0005e	0f b7 82 0a 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[edx+10]
  00065	3b c8		 cmp	 ecx, eax
  00067	7e 18		 jle	 SHORT $LN3@UpdateUser
  00069	69 45 f8 60 09
	00 00		 imul	 eax, DWORD PTR _iCharacterClass$[ebp], 2400
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00073	66 8b 90 0a 00
	00 00		 mov	 dx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+10]
  0007a	66 89 91 b6 00
	00 00		 mov	 WORD PTR [ecx+182], dx
$LN3@UpdateUser:

; 694  : 	if(lpObj->Vitality > DCInfo.DefClass[iCharacterClass].Vitality){lpObj->Vitality = DCInfo.DefClass[iCharacterClass].Vitality;}

  00081	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00084	0f b7 88 b8 00
	00 00		 movzx	 ecx, WORD PTR [eax+184]
  0008b	69 55 f8 60 09
	00 00		 imul	 edx, DWORD PTR _iCharacterClass$[ebp], 2400
  00092	0f b7 82 0c 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[edx+12]
  00099	3b c8		 cmp	 ecx, eax
  0009b	7e 18		 jle	 SHORT $LN4@UpdateUser
  0009d	69 45 f8 60 09
	00 00		 imul	 eax, DWORD PTR _iCharacterClass$[ebp], 2400
  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000a7	66 8b 90 0c 00
	00 00		 mov	 dx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+12]
  000ae	66 89 91 b8 00
	00 00		 mov	 WORD PTR [ecx+184], dx
$LN4@UpdateUser:

; 695  : 	if(lpObj->Energy > DCInfo.DefClass[iCharacterClass].Energy){lpObj->Energy = DCInfo.DefClass[iCharacterClass].Energy;}

  000b5	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b8	0f b7 88 ba 00
	00 00		 movzx	 ecx, WORD PTR [eax+186]
  000bf	69 55 f8 60 09
	00 00		 imul	 edx, DWORD PTR _iCharacterClass$[ebp], 2400
  000c6	0f b7 82 0e 00
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[edx+14]
  000cd	3b c8		 cmp	 ecx, eax
  000cf	7e 18		 jle	 SHORT $LN5@UpdateUser
  000d1	69 45 f8 60 09
	00 00		 imul	 eax, DWORD PTR _iCharacterClass$[ebp], 2400
  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000db	66 8b 90 0e 00
	00 00		 mov	 dx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+14]
  000e2	66 89 91 ba 00
	00 00		 mov	 WORD PTR [ecx+186], dx
$LN5@UpdateUser:

; 696  : 	if(m_bLeadershipReset == false && lpObj->Leadership > DCInfo.DefClass[iCharacterClass].Leadership){lpObj->Leadership = DCInfo.DefClass[iCharacterClass].Leadership;}

  000e9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ec	0f b6 48 34	 movzx	 ecx, BYTE PTR [eax+52]
  000f0	85 c9		 test	 ecx, ecx
  000f2	75 34		 jne	 SHORT $LN6@UpdateUser
  000f4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f7	0f b7 88 d8 00
	00 00		 movzx	 ecx, WORD PTR [eax+216]
  000fe	69 55 f8 60 09
	00 00		 imul	 edx, DWORD PTR _iCharacterClass$[ebp], 2400
  00105	0f b7 82 60 09
	00 00		 movzx	 eax, WORD PTR ?DCInfo@@3Vclassdef@@A[edx+2400]
  0010c	3b c8		 cmp	 ecx, eax
  0010e	7e 18		 jle	 SHORT $LN6@UpdateUser
  00110	69 45 f8 60 09
	00 00		 imul	 eax, DWORD PTR _iCharacterClass$[ebp], 2400
  00117	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0011a	66 8b 90 60 09
	00 00		 mov	 dx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+2400]
  00121	66 89 91 d8 00
	00 00		 mov	 WORD PTR [ecx+216], dx
$LN6@UpdateUser:

; 697  : 
; 698  : 	cManager.ResetViewport(lpObj);

  00128	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012b	50		 push	 eax
  0012c	b9 00 00 00 00	 mov	 ecx, OFFSET ?cManager@@3VCGMMng@@A ; cManager
  00131	e8 00 00 00 00	 call	 ?ResetViewport@CGMMng@@QAEXPAVOBJECTSTRUCT@@@Z ; CGMMng::ResetViewport

; 699  : }

  00136	5f		 pop	 edi
  00137	5e		 pop	 esi
  00138	5b		 pop	 ebx
  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c2 04 00	 ret	 4
?UpdateUserStatusPoint@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ENDP ; CResetSystem::UpdateUserStatusPoint
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?SetUserBornPlace@CResetSystem@@QAEXPAVOBJECTSTRUCT@@HH@Z
_TEXT	SEGMENT
$T1 = -80						; size = 4
$T2 = -76						; size = 4
_it$3 = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_iRuleIndex$ = 12					; size = 4
_Class$ = 16						; size = 4
?SetUserBornPlace@CResetSystem@@QAEXPAVOBJECTSTRUCT@@HH@Z PROC ; CResetSystem::SetUserBornPlace, COMDAT
; _this$ = ecx

; 642  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 643  : 	for(std::vector<BORN_PLACE>::iterator it = this->m_vtBornPlace.begin(); it != this->m_vtBornPlace.end(); it++)

  0000c	8d 45 f8	 lea	 eax, DWORD PTR _it$3[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00016	e8 00 00 00 00	 call	 ?begin@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@2@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::begin
  0001b	eb 0e		 jmp	 SHORT $LN4@SetUserBor
$LN2@SetUserBor:
  0001d	6a 00		 push	 0
  0001f	8d 45 b4	 lea	 eax, DWORD PTR $T2[ebp]
  00022	50		 push	 eax
  00023	8d 4d f8	 lea	 ecx, DWORD PTR _it$3[ebp]
  00026	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator++
$LN4@SetUserBor:
  0002b	8d 45 b0	 lea	 eax, DWORD PTR $T1[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00035	e8 00 00 00 00	 call	 ?end@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@2@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::end
  0003a	50		 push	 eax
  0003b	8d 4d f8	 lea	 ecx, DWORD PTR _it$3[ebp]
  0003e	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator!=
  00043	0f b6 c8	 movzx	 ecx, al
  00046	85 c9		 test	 ecx, ecx
  00048	74 42		 je	 SHORT $LN1@SetUserBor

; 644  : 	{
; 645  : 		if ((*(it)).m_iResetRuleIndex == iRuleIndex)

  0004a	8d 4d f8	 lea	 ecx, DWORD PTR _it$3[ebp]
  0004d	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEAAUBORN_PLACE@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator*
  00052	8b 00		 mov	 eax, DWORD PTR [eax]
  00054	3b 45 0c	 cmp	 eax, DWORD PTR _iRuleIndex$[ebp]
  00057	75 31		 jne	 SHORT $LN5@SetUserBor

; 646  : 		{
; 647  : 			if((*(it)).m_iCharClassType == Class)

  00059	8d 4d f8	 lea	 ecx, DWORD PTR _it$3[ebp]
  0005c	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEAAUBORN_PLACE@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator*
  00061	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00064	3b 45 10	 cmp	 eax, DWORD PTR _Class$[ebp]
  00067	75 21		 jne	 SHORT $LN5@SetUserBor

; 648  : 			{
; 649  : 				if(::gObjMoveGate(lpObj->m_Index, (*(it)).m_iGateNumber) == TRUE)

  00069	8d 4d f8	 lea	 ecx, DWORD PTR _it$3[ebp]
  0006c	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UBORN_PLACE@@@std@@@std@@@std@@QBEAAUBORN_PLACE@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<BORN_PLACE> > >::operator*
  00071	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00074	50		 push	 eax
  00075	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00078	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007a	52		 push	 edx
  0007b	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00080	83 c4 08	 add	 esp, 8
  00083	83 f8 01	 cmp	 eax, 1
  00086	75 02		 jne	 SHORT $LN5@SetUserBor

; 650  : 				{
; 651  : 					break;

  00088	eb 02		 jmp	 SHORT $LN1@SetUserBor
$LN5@SetUserBor:

; 652  : 				}
; 653  : 			}
; 654  : 		}
; 655  : 	}

  0008a	eb 91		 jmp	 SHORT $LN2@SetUserBor
$LN1@SetUserBor:

; 656  : }

  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 0c 00	 ret	 12			; 0000000cH
?SetUserBornPlace@CResetSystem@@QAEXPAVOBJECTSTRUCT@@HH@Z ENDP ; CResetSystem::SetUserBornPlace
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?SetUserDefaultLifePlusMana@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?SetUserDefaultLifePlusMana@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z PROC ; CResetSystem::SetUserDefaultLifePlusMana, COMDAT
; _this$ = ecx

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 630  : 	lpObj->MaxLife = DCInfo.DefClass[lpObj->Class].Life + (lpObj->Level - 1) * DCInfo.DefClass[lpObj->Class].LevelLife  + ((lpObj->Vitality - DCInfo.DefClass[lpObj->Class].Vitality ) * DCInfo.DefClass[lpObj->Class].VitalityToLife);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000f	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00016	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  0001c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001f	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00026	83 e9 01	 sub	 ecx, 1
  00029	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0002d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00030	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00037	69 c1 60 09 00
	00		 imul	 eax, ecx, 2400
  0003d	f3 0f 59 80 10
	00 00 00	 mulss	 xmm0, DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+16]
  00045	f3 0f 58 82 14
	00 00 00	 addss	 xmm0, DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+20]
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00050	0f b7 91 b8 00
	00 00		 movzx	 edx, WORD PTR [ecx+184]
  00057	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005a	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00061	69 c1 60 09 00
	00		 imul	 eax, ecx, 2400
  00067	0f b7 88 0c 00
	00 00		 movzx	 ecx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+12]
  0006e	2b d1		 sub	 edx, ecx
  00070	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  00074	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00077	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  0007e	69 c8 60 09 00
	00		 imul	 ecx, eax, 2400
  00084	f3 0f 59 89 28
	00 00 00	 mulss	 xmm1, DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+40]
  0008c	f3 0f 58 c1	 addss	 xmm0, xmm1
  00090	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00093	f3 0f 11 82 c0
	00 00 00	 movss	 DWORD PTR [edx+192], xmm0

; 631  : 	lpObj->MaxMana = DCInfo.DefClass[lpObj->Class].Mana + (lpObj->Level - 1) * DCInfo.DefClass[lpObj->Class].LevelMana  + ((lpObj->Energy - DCInfo.DefClass[lpObj->Class].Energy ) * DCInfo.DefClass[lpObj->Class].EnergyToMana);

  0009b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009e	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000a5	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  000ab	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ae	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  000b5	83 e9 01	 sub	 ecx, 1
  000b8	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  000bc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bf	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000c6	69 c1 60 09 00
	00		 imul	 eax, ecx, 2400
  000cc	f3 0f 59 80 1c
	00 00 00	 mulss	 xmm0, DWORD PTR ?DCInfo@@3Vclassdef@@A[eax+28]
  000d4	f3 0f 58 82 20
	00 00 00	 addss	 xmm0, DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+32]
  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000df	0f b7 91 ba 00
	00 00		 movzx	 edx, WORD PTR [ecx+186]
  000e6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000e9	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  000f0	69 c1 60 09 00
	00		 imul	 eax, ecx, 2400
  000f6	0f b7 88 0e 00
	00 00		 movzx	 ecx, WORD PTR ?DCInfo@@3Vclassdef@@A[eax+14]
  000fd	2b d1		 sub	 edx, ecx
  000ff	f3 0f 2a ca	 cvtsi2ss xmm1, edx
  00103	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00106	0f b7 82 9c 00
	00 00		 movzx	 eax, WORD PTR [edx+156]
  0010d	69 c8 60 09 00
	00		 imul	 ecx, eax, 2400
  00113	f3 0f 59 89 2c
	00 00 00	 mulss	 xmm1, DWORD PTR ?DCInfo@@3Vclassdef@@A[ecx+44]
  0011b	f3 0f 58 c1	 addss	 xmm0, xmm1
  0011f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00122	f3 0f 11 82 d4
	00 00 00	 movss	 DWORD PTR [edx+212], xmm0

; 632  : 
; 633  : 	lpObj->VitalityToLife = DCInfo.DefClass[lpObj->Class].VitalityToLife;

  0012a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0012d	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00134	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  0013a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0013d	8b 8a 28 00 00
	00		 mov	 ecx, DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+40]
  00143	89 88 f4 00 00
	00		 mov	 DWORD PTR [eax+244], ecx

; 634  : 	lpObj->EnergyToMana = DCInfo.DefClass[lpObj->Class].EnergyToMana;

  00149	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0014c	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00153	69 d1 60 09 00
	00		 imul	 edx, ecx, 2400
  00159	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0015c	8b 8a 2c 00 00
	00		 mov	 ecx, DWORD PTR ?DCInfo@@3Vclassdef@@A[edx+44]
  00162	89 88 f8 00 00
	00		 mov	 DWORD PTR [eax+248], ecx

; 635  : 
; 636  : 	::gObjSetBP(lpObj->m_Index);

  00168	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016d	51		 push	 ecx
  0016e	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP
  00173	83 c4 04	 add	 esp, 4

; 637  : 	lpObj->BP = lpObj->MaxBP / 2;

  00176	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00179	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [eax+236]
  0017f	99		 cdq
  00180	2b c2		 sub	 eax, edx
  00182	d1 f8		 sar	 eax, 1
  00184	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00187	89 81 e8 00 00
	00		 mov	 DWORD PTR [ecx+232], eax

; 638  : 	::gObjCalcMaxLifePower(lpObj->m_Index);

  0018d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00190	8b 08		 mov	 ecx, DWORD PTR [eax]
  00192	51		 push	 ecx
  00193	e8 00 00 00 00	 call	 ?gObjCalcMaxLifePower@@YAXH@Z ; gObjCalcMaxLifePower
  00198	83 c4 04	 add	 esp, 4

; 639  : }

  0019b	5f		 pop	 edi
  0019c	5e		 pop	 esi
  0019d	5b		 pop	 ebx
  0019e	8b e5		 mov	 esp, ebp
  001a0	5d		 pop	 ebp
  001a1	c2 04 00	 ret	 4
?SetUserDefaultLifePlusMana@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ENDP ; CResetSystem::SetUserDefaultLifePlusMana
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?FixUserExpInterface@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pMsg$ = -32						; size = 24
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?FixUserExpInterface@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z PROC ; CResetSystem::FixUserExpInterface, COMDAT
; _this$ = ecx

; 610  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 611  : 	PMSG_UPDATE_EXP pMsg;
; 612  : 	pMsg.h.c = 0xC3;

  00016	c6 45 e0 c3	 mov	 BYTE PTR _pMsg$[ebp], 195 ; 000000c3H

; 613  : 	pMsg.h.headcode = 0xF3;

  0001a	c6 45 e2 f3	 mov	 BYTE PTR _pMsg$[ebp+2], 243 ; 000000f3H

; 614  : 	pMsg.h.size = 0x18; //size defined o.O

  0001e	c6 45 e1 18	 mov	 BYTE PTR _pMsg$[ebp+1], 24 ; 00000018H

; 615  : 	pMsg.subcode = 4; //unk

  00022	c6 45 e3 04	 mov	 BYTE PTR _pMsg$[ebp+3], 4

; 616  : 	pMsg.Dir = lpObj->Dir;

  00026	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00029	8a 88 08 01 00
	00		 mov	 cl, BYTE PTR [eax+264]
  0002f	88 4d e7	 mov	 BYTE PTR _pMsg$[ebp+7], cl

; 617  : 	pMsg.MapX = lpObj->X;

  00032	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00035	8a 88 04 01 00
	00		 mov	 cl, BYTE PTR [eax+260]
  0003b	88 4d e4	 mov	 BYTE PTR _pMsg$[ebp+4], cl

; 618  : 	pMsg.MapY = lpObj->Y;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00041	8a 88 06 01 00
	00		 mov	 cl, BYTE PTR [eax+262]
  00047	88 4d e5	 mov	 BYTE PTR _pMsg$[ebp+5], cl

; 619  : 	pMsg.Life = lpObj->Life;

  0004a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004d	f3 0f 2c 88 bc
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+188]
  00055	66 89 4d e8	 mov	 WORD PTR _pMsg$[ebp+8], cx

; 620  : 	pMsg.Mana = lpObj->Mana;

  00059	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005c	f3 0f 2c 88 d0
	00 00 00	 cvttss2si ecx, DWORD PTR [eax+208]
  00064	66 89 4d ea	 mov	 WORD PTR _pMsg$[ebp+10], cx

; 621  : 	pMsg.Exp = lpObj->Experience;

  00068	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006b	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]
  00071	89 4d f0	 mov	 DWORD PTR _pMsg$[ebp+16], ecx

; 622  : 	pMsg.MapNumber = lpObj->MapNumber;

  00074	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00077	8a 88 09 01 00
	00		 mov	 cl, BYTE PTR [eax+265]
  0007d	88 4d e6	 mov	 BYTE PTR _pMsg$[ebp+6], cl

; 623  : 	pMsg.Money = lpObj->Money;

  00080	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00083	8b 88 b0 00 00
	00		 mov	 ecx, DWORD PTR [eax+176]
  00089	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+20], ecx

; 624  : 	pMsg.BP = lpObj->BP;

  0008c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008f	66 8b 88 e8 00
	00 00		 mov	 cx, WORD PTR [eax+232]
  00096	66 89 4d ee	 mov	 WORD PTR _pMsg$[ebp+14], cx

; 625  : 	DataSend(lpObj->m_Index,(LPBYTE)&pMsg,pMsg.h.size);

  0009a	0f b6 45 e1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0009e	50		 push	 eax
  0009f	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000a2	51		 push	 ecx
  000a3	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000a6	8b 02		 mov	 eax, DWORD PTR [edx]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 626  : }

  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b7	33 cd		 xor	 ecx, ebp
  000b9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c2 04 00	 ret	 4
?FixUserExpInterface@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ENDP ; CResetSystem::FixUserExpInterface
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?CalculateEquipment@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_MaxAddPoint$ = -12					; size = 2
_AddPoint$ = -8						; size = 2
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?CalculateEquipment@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z PROC ; CResetSystem::CalculateEquipment, COMDAT
; _this$ = ecx

; 588  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 589  : 	gObjCalCharacter(lpObj->m_Index);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00017	83 c4 04	 add	 esp, 4

; 590  : #ifdef ADD_SHIELD_POINT_01_20060403
; 591  : 	GCReFillSend(lpObj->m_Index,lpObj->MaxLife + lpObj->AddLife,0xFE,0,lpObj->iMaxShield+lpObj->iAddShield);
; 592  : #else
; 593  : 	GCReFillSend(lpObj->m_Index,lpObj->MaxLife + lpObj->AddLife,0xFE,0);

  0001a	6a 00		 push	 0
  0001c	68 fe 00 00 00	 push	 254			; 000000feH
  00021	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00024	f3 0f 2a 80 0c
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [eax+268]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0002f	f3 0f 58 81 c0
	00 00 00	 addss	 xmm0, DWORD PTR [ecx+192]
  00037	f3 0f 2c d0	 cvttss2si edx, xmm0
  0003b	0f b7 c2	 movzx	 eax, dx
  0003e	50		 push	 eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00042	8b 11		 mov	 edx, DWORD PTR [ecx]
  00044	52		 push	 edx
  00045	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEE@Z ; GCReFillSend
  0004a	83 c4 10	 add	 esp, 16			; 00000010H

; 594  : #endif
; 595  : 	gObjSetBP(lpObj->m_Index);

  0004d	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ?gObjSetBP@@YAXH@Z	; gObjSetBP
  00058	83 c4 04	 add	 esp, 4

; 596  : 	GCManaSend(lpObj->m_Index,lpObj->MaxMana+lpObj->AddMana,0xFE,0,lpObj->MaxBP);

  0005b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005e	0f b7 88 ec 00
	00 00		 movzx	 ecx, WORD PTR [eax+236]
  00065	51		 push	 ecx
  00066	6a 00		 push	 0
  00068	68 fe 00 00 00	 push	 254			; 000000feH
  0006d	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00070	f3 0f 2a 82 10
	01 00 00	 cvtsi2ss xmm0, DWORD PTR [edx+272]
  00078	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007b	f3 0f 58 80 d4
	00 00 00	 addss	 xmm0, DWORD PTR [eax+212]
  00083	f3 0f 2c c8	 cvttss2si ecx, xmm0
  00087	0f b7 d1	 movzx	 edx, cx
  0008a	52		 push	 edx
  0008b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend
  00096	83 c4 14	 add	 esp, 20			; 00000014H

; 597  : 	gObjNextExpCal(lpObj);

  00099	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 ?gObjNextExpCal@@YAXPAVOBJECTSTRUCT@@@Z ; gObjNextExpCal
  000a2	83 c4 04	 add	 esp, 4

; 598  : #ifdef ADD_MINUS_STAT_SYSTEM_USING_FRUIT_20050712
; 599  : 	GCLevelUpMsgSend(lpObj->m_Index);
; 600  : #else
; 601  : 	short AddPoint = 0, MaxAddPoint = 0;

  000a5	33 c0		 xor	 eax, eax
  000a7	66 89 45 f8	 mov	 WORD PTR _AddPoint$[ebp], ax
  000ab	33 c0		 xor	 eax, eax
  000ad	66 89 45 f4	 mov	 WORD PTR _MaxAddPoint$[ebp], ax

; 602  : 
; 603  : 	gObjGetStatPointState(lpObj->m_Index, AddPoint, MaxAddPoint);

  000b1	8d 45 f4	 lea	 eax, DWORD PTR _MaxAddPoint$[ebp]
  000b4	50		 push	 eax
  000b5	8d 4d f8	 lea	 ecx, DWORD PTR _AddPoint$[ebp]
  000b8	51		 push	 ecx
  000b9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000bc	8b 02		 mov	 eax, DWORD PTR [edx]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 ?gObjGetStatPointState@@YAXHAAF0@Z ; gObjGetStatPointState
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 604  : 
; 605  : 	GCLevelUpMsgSend(lpObj->m_Index, lpObj->Level, lpObj->LevelUpPoint, lpObj->MaxLife, lpObj->MaxMana, lpObj->MaxBP, AddPoint, MaxAddPoint);

  000c7	0f b7 45 f4	 movzx	 eax, WORD PTR _MaxAddPoint$[ebp]
  000cb	50		 push	 eax
  000cc	0f b7 4d f8	 movzx	 ecx, WORD PTR _AddPoint$[ebp]
  000d0	51		 push	 ecx
  000d1	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000d4	0f b7 82 ec 00
	00 00		 movzx	 eax, WORD PTR [edx+236]
  000db	50		 push	 eax
  000dc	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000df	f3 0f 2c 91 d4
	00 00 00	 cvttss2si edx, DWORD PTR [ecx+212]
  000e7	0f b7 c2	 movzx	 eax, dx
  000ea	50		 push	 eax
  000eb	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ee	f3 0f 2c 91 c0
	00 00 00	 cvttss2si edx, DWORD PTR [ecx+192]
  000f6	0f b7 c2	 movzx	 eax, dx
  000f9	50		 push	 eax
  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000fd	0f b7 91 a4 00
	00 00		 movzx	 edx, WORD PTR [ecx+164]
  00104	52		 push	 edx
  00105	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00108	0f b7 88 a0 00
	00 00		 movzx	 ecx, WORD PTR [eax+160]
  0010f	51		 push	 ecx
  00110	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00113	8b 02		 mov	 eax, DWORD PTR [edx]
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 ?GCLevelUpMsgSend@@YAXHGGGGGFF@Z ; GCLevelUpMsgSend
  0011b	83 c4 20	 add	 esp, 32			; 00000020H

; 606  : #endif
; 607  : }

  0011e	5f		 pop	 edi
  0011f	5e		 pop	 esi
  00120	5b		 pop	 ebx
  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 04 00	 ret	 4
?CalculateEquipment@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ENDP ; CResetSystem::CalculateEquipment
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?ClearAllBuffStates@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?ClearAllBuffStates@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z PROC ; CResetSystem::ClearAllBuffStates, COMDAT
; _this$ = ecx

; 566  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 567  : 	lpObj->m_bAttackerKilled = 0;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000f	c6 80 3c 02 00
	00 00		 mov	 BYTE PTR [eax+572], 0

; 568  : 	lpObj->m_ViewState = 0;

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00019	c6 80 be 01 00
	00 00		 mov	 BYTE PTR [eax+446], 0

; 569  : 	lpObj->Teleport = 0;

  00020	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00023	c6 80 fc 01 00
	00 00		 mov	 BYTE PTR [eax+508], 0

; 570  : 
; 571  : 	int i; for(i = 0; i < MAXSELFDEFENSE; i++)

  0002a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00031	eb 09		 jmp	 SHORT $LN4@ClearAllBu
$LN2@ClearAllBu:
  00033	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00036	83 c0 01	 add	 eax, 1
  00039	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@ClearAllBu:
  0003c	83 7d f8 07	 cmp	 DWORD PTR _i$[ebp], 7
  00040	7d 13		 jge	 SHORT $LN3@ClearAllBu

; 572  : 	{
; 573  : 		lpObj->SelfDefenseTime[i] = 0;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00048	c7 84 81 5c 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+604], 0

; 574  : 	}

  00053	eb de		 jmp	 SHORT $LN2@ClearAllBu
$LN3@ClearAllBu:

; 575  : 
; 576  : 	gObjTimeCheckSelfDefense(lpObj);

  00055	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?gObjTimeCheckSelfDefense@@YAXPAVOBJECTSTRUCT@@@Z ; gObjTimeCheckSelfDefense
  0005e	83 c4 04	 add	 esp, 4

; 577  : 
; 578  : #ifdef ADD_NEW_SKILL_FOR_CASTLE_01_20041116
; 579  : 	gObjUseSkill.RemoveAllCharacterInvalidMagicAndSkillState(lpObj);
; 580  : #endif
; 581  : 
; 582  : #ifdef CHARACTER_AUTO_RECUPERATION_SYSTEM_20050614
; 583  : 	lpObj->m_iAutoRecuperationTime = GetTickCount();
; 584  : #endif
; 585  : }

  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
?ClearAllBuffStates@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ENDP ; CResetSystem::ClearAllBuffStates
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?DBAnsUpdateReset@CResetSystem@@QAEXPAE@Z
_TEXT	SEGMENT
_lpObj$ = -276						; size = 4
_aIndex$ = -272						; size = 4
_szTemp$ = -268						; size = 256
_pRecv$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
?DBAnsUpdateReset@CResetSystem@@QAEXPAE@Z PROC		; CResetSystem::DBAnsUpdateReset, COMDAT
; _this$ = ecx

; 532  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 54 01 00
	00		 sub	 esp, 340		; 00000154H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 533  : 	//LeaveCriticalSection(&this->m_cs);
; 534  : 
; 535  : 	PMSG_ANS_SAVE_CHARACTER_RESET * pRecv = (PMSG_ANS_SAVE_CHARACTER_RESET *)aRecv;

  00019	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0001c	89 45 f4	 mov	 DWORD PTR _pRecv$[ebp], eax

; 536  : 	
; 537  : 	char szTemp[256];
; 538  : 
; 539  : 	if(!gObjIsConnectedGP(pRecv->iUserIndex))

  0001f	8b 45 f4	 mov	 eax, DWORD PTR _pRecv$[ebp]
  00022	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0002b	83 c4 04	 add	 esp, 4
  0002e	85 c0		 test	 eax, eax
  00030	75 35		 jne	 SHORT $LN2@DBAnsUpdat

; 540  : 	{
; 541  : 		wsprintf(szTemp,"[Reset System] DBAnsUpdateReset ERROR (%d)", pRecv->iUserIndex);

  00032	8b 45 f4	 mov	 eax, DWORD PTR _pRecv$[ebp]
  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	51		 push	 ecx
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@JBOFKBMJ@?$FLReset?5System?$FN?5DBAnsUpdateReset@
  0003e	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$[ebp]
  00044	52		 push	 edx
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 542  : 		RESET_SYSTEM_LOG.Output(szTemp);

  0004e	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  00054	50		 push	 eax
  00055	68 00 00 00 00	 push	 OFFSET ?RESET_SYSTEM_LOG@@3VCLogToFile@@A ; RESET_SYSTEM_LOG
  0005a	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  0005f	83 c4 08	 add	 esp, 8

; 543  : 		return;

  00062	e9 2c 01 00 00	 jmp	 $LN1@DBAnsUpdat
$LN2@DBAnsUpdat:

; 544  : 	}
; 545  : 
; 546  : 	int aIndex = pRecv->iUserIndex;

  00067	8b 45 f4	 mov	 eax, DWORD PTR _pRecv$[ebp]
  0006a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006d	89 8d f0 fe ff
	ff		 mov	 DWORD PTR _aIndex$[ebp], ecx

; 547  : 
; 548  : 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00073	69 85 f0 fe ff
	ff a0 1b 00 00	 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  0007d	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  00083	89 85 ec fe ff
	ff		 mov	 DWORD PTR _lpObj$[ebp], eax

; 549  : 
; 550  : 	if(pRecv->m_iResetNumber == lpObj->m_iResetNumber+1)

  00089	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0008f	8b 88 78 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6776]
  00095	83 c1 01	 add	 ecx, 1
  00098	8b 55 f4	 mov	 edx, DWORD PTR _pRecv$[ebp]
  0009b	39 4a 20	 cmp	 DWORD PTR [edx+32], ecx
  0009e	75 79		 jne	 SHORT $LN3@DBAnsUpdat

; 551  : 	{
; 552  : 		LogAddTD("[Reset System] Ans Update User ResetInfo - SUCCESS [%s][%s](%d)", lpObj->AccountID, lpObj->Name, pRecv->m_iResetNumber);

  000a0	8b 45 f4	 mov	 eax, DWORD PTR _pRecv$[ebp]
  000a3	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000a6	51		 push	 ecx
  000a7	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ad	83 c2 73	 add	 edx, 115		; 00000073H
  000b0	52		 push	 edx
  000b1	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b7	83 c0 68	 add	 eax, 104		; 00000068H
  000ba	50		 push	 eax
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@IOHPDFLJ@?$FLReset?5System?$FN?5Ans?5Update?5User?5@
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c6	83 c4 10	 add	 esp, 16			; 00000010H

; 553  : 		this->ExecResetApply(lpObj, pRecv->m_iRuleIndex, pRecv->m_bClearStat, pRecv->m_iLevelAfterReset, pRecv->m_iLevelUpPoint, pRecv->m_bReqSpecialItem, pRecv->m_bBornPlace, pRecv->m_iResetNumber, pRecv->m_bClearBuffState, pRecv->m_bClearMagicList);

  000c9	8b 45 f4	 mov	 eax, DWORD PTR _pRecv$[ebp]
  000cc	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000cf	51		 push	 ecx
  000d0	8b 55 f4	 mov	 edx, DWORD PTR _pRecv$[ebp]
  000d3	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000d6	50		 push	 eax
  000d7	8b 4d f4	 mov	 ecx, DWORD PTR _pRecv$[ebp]
  000da	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000dd	52		 push	 edx
  000de	8b 45 f4	 mov	 eax, DWORD PTR _pRecv$[ebp]
  000e1	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000e4	51		 push	 ecx
  000e5	8b 55 f4	 mov	 edx, DWORD PTR _pRecv$[ebp]
  000e8	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000eb	50		 push	 eax
  000ec	8b 4d f4	 mov	 ecx, DWORD PTR _pRecv$[ebp]
  000ef	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000f2	52		 push	 edx
  000f3	8b 45 f4	 mov	 eax, DWORD PTR _pRecv$[ebp]
  000f6	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000f9	51		 push	 ecx
  000fa	8b 55 f4	 mov	 edx, DWORD PTR _pRecv$[ebp]
  000fd	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00100	50		 push	 eax
  00101	8b 4d f4	 mov	 ecx, DWORD PTR _pRecv$[ebp]
  00104	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00107	52		 push	 edx
  00108	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  0010e	50		 push	 eax
  0010f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	e8 00 00 00 00	 call	 ?ExecResetApply@CResetSystem@@QAEXPAVOBJECTSTRUCT@@HHHHHHHHH@Z ; CResetSystem::ExecResetApply

; 554  : 	}

  00117	eb 7a		 jmp	 SHORT $LN1@DBAnsUpdat
$LN3@DBAnsUpdat:

; 555  : 	else
; 556  : 	{
; 557  : 		LogAddTD("[Reset System] Ans Update User ResetInfo - FAIL [%s][%s](%d)", lpObj->AccountID, lpObj->Name, pRecv->m_iResetNumber);

  00119	8b 45 f4	 mov	 eax, DWORD PTR _pRecv$[ebp]
  0011c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0011f	51		 push	 ecx
  00120	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  00126	83 c2 73	 add	 edx, 115		; 00000073H
  00129	52		 push	 edx
  0012a	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00130	83 c0 68	 add	 eax, 104		; 00000068H
  00133	50		 push	 eax
  00134	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@KAKCNPHO@?$FLReset?5System?$FN?5Ans?5Update?5User?5@
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0013f	83 c4 10	 add	 esp, 16			; 00000010H

; 558  : 		lpObj->m_bReqUpdateReset = false;

  00142	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00148	c6 80 7c 1a 00
	00 00		 mov	 BYTE PTR [eax+6780], 0

; 559  : 		
; 560  : 		wsprintf(szTemp,"[Reset System] Ans Update User ResetInfo - FAIL [%s][%s](%d)", lpObj->AccountID, lpObj->Name, pRecv->m_iResetNumber);

  0014f	8b 45 f4	 mov	 eax, DWORD PTR _pRecv$[ebp]
  00152	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00155	51		 push	 ecx
  00156	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR _lpObj$[ebp]
  0015c	83 c2 73	 add	 edx, 115		; 00000073H
  0015f	52		 push	 edx
  00160	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR _lpObj$[ebp]
  00166	83 c0 68	 add	 eax, 104		; 00000068H
  00169	50		 push	 eax
  0016a	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@KAKCNPHO@?$FLReset?5System?$FN?5Ans?5Update?5User?5@
  0016f	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$[ebp]
  00175	51		 push	 ecx
  00176	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0017c	83 c4 14	 add	 esp, 20			; 00000014H

; 561  : 		RESET_SYSTEM_LOG.Output(szTemp);

  0017f	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$[ebp]
  00185	50		 push	 eax
  00186	68 00 00 00 00	 push	 OFFSET ?RESET_SYSTEM_LOG@@3VCLogToFile@@A ; RESET_SYSTEM_LOG
  0018b	e8 00 00 00 00	 call	 ?Output@CLogToFile@@QAAXPADZZ ; CLogToFile::Output
  00190	83 c4 08	 add	 esp, 8
$LN1@DBAnsUpdat:

; 562  : 	}
; 563  : }

  00193	5f		 pop	 edi
  00194	5e		 pop	 esi
  00195	5b		 pop	 ebx
  00196	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00199	33 cd		 xor	 ecx, ebp
  0019b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a0	8b e5		 mov	 esp, ebp
  001a2	5d		 pop	 ebp
  001a3	c2 04 00	 ret	 4
?DBAnsUpdateReset@CResetSystem@@QAEXPAE@Z ENDP		; CResetSystem::DBAnsUpdateReset
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?DBReqUpdateReset@CResetSystem@@QAEXPAVOBJECTSTRUCT@@HHHHHHHHH@Z
_TEXT	SEGMENT
_pMsg$ = -76						; size = 68
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iRuleIndex$ = 12					; size = 4
_iClearStatPoint$ = 16					; size = 4
_iLevelAfter$ = 20					; size = 4
_iLevelUpPoint$ = 24					; size = 4
_iReqSpecialItem$ = 28					; size = 4
_iBornPlace$ = 32					; size = 4
_iResetNumber$ = 36					; size = 4
_iClearAllBuffState$ = 40				; size = 4
_iClearMagicList$ = 44					; size = 4
?DBReqUpdateReset@CResetSystem@@QAEXPAVOBJECTSTRUCT@@HHHHHHHHH@Z PROC ; CResetSystem::DBReqUpdateReset, COMDAT
; _this$ = ecx

; 502  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 503  : 	PMSG_REQ_SAVE_CHARACTER_RESET pMsg;
; 504  : 
; 505  : 	if(lpObj->m_bReqUpdateReset == true)

  00019	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001c	0f b6 88 7c 1a
	00 00		 movzx	 ecx, BYTE PTR [eax+6780]
  00023	83 f9 01	 cmp	 ecx, 1
  00026	75 05		 jne	 SHORT $LN2@DBReqUpdat

; 506  : 	{
; 507  : 		return;

  00028	e9 bb 00 00 00	 jmp	 $LN1@DBReqUpdat
$LN2@DBReqUpdat:

; 508  : 	}
; 509  : 
; 510  : 	PHeadSetB( (LPBYTE)&pMsg, 0xA9, sizeof(pMsg));

  0002d	6a 44		 push	 68			; 00000044H
  0002f	68 a9 00 00 00	 push	 169			; 000000a9H
  00034	8d 45 b4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 511  : 	memcpy(pMsg.chAccountID, lpObj->AccountID, 10);

  00040	6a 0a		 push	 10			; 0000000aH
  00042	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00045	83 c0 68	 add	 eax, 104		; 00000068H
  00048	50		 push	 eax
  00049	8d 4d bc	 lea	 ecx, DWORD PTR _pMsg$[ebp+8]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 _memcpy
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH

; 512  : 	memcpy(pMsg.chCharacterName, lpObj->Name, 10);

  00055	6a 0a		 push	 10			; 0000000aH
  00057	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0005a	83 c0 73	 add	 eax, 115		; 00000073H
  0005d	50		 push	 eax
  0005e	8d 4d c7	 lea	 ecx, DWORD PTR _pMsg$[ebp+19]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 _memcpy
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 513  : 	pMsg.iUserIndex = lpObj->m_Index;

  0006a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006f	89 4d b8	 mov	 DWORD PTR _pMsg$[ebp+4], ecx

; 514  : 	pMsg.m_iRuleIndex = iRuleIndex;

  00072	8b 45 0c	 mov	 eax, DWORD PTR _iRuleIndex$[ebp]
  00075	89 45 d4	 mov	 DWORD PTR _pMsg$[ebp+32], eax

; 515  : 	pMsg.m_bClearStat = iClearStatPoint;

  00078	8b 45 10	 mov	 eax, DWORD PTR _iClearStatPoint$[ebp]
  0007b	89 45 d8	 mov	 DWORD PTR _pMsg$[ebp+36], eax

; 516  : 	pMsg.m_iLevelAfterReset = iLevelAfter;

  0007e	8b 45 14	 mov	 eax, DWORD PTR _iLevelAfter$[ebp]
  00081	89 45 dc	 mov	 DWORD PTR _pMsg$[ebp+40], eax

; 517  : 	pMsg.m_iLevelUpPoint = iLevelUpPoint;

  00084	8b 45 18	 mov	 eax, DWORD PTR _iLevelUpPoint$[ebp]
  00087	89 45 e0	 mov	 DWORD PTR _pMsg$[ebp+44], eax

; 518  : 	pMsg.m_bReqSpecialItem = iReqSpecialItem;

  0008a	8b 45 1c	 mov	 eax, DWORD PTR _iReqSpecialItem$[ebp]
  0008d	89 45 e4	 mov	 DWORD PTR _pMsg$[ebp+48], eax

; 519  : 	pMsg.m_bBornPlace = iBornPlace;

  00090	8b 45 20	 mov	 eax, DWORD PTR _iBornPlace$[ebp]
  00093	89 45 e8	 mov	 DWORD PTR _pMsg$[ebp+52], eax

; 520  : 	pMsg.m_iResetNumber = iResetNumber;

  00096	8b 45 24	 mov	 eax, DWORD PTR _iResetNumber$[ebp]
  00099	89 45 ec	 mov	 DWORD PTR _pMsg$[ebp+56], eax

; 521  : 	pMsg.m_bClearBuffState = iClearAllBuffState;

  0009c	8b 45 28	 mov	 eax, DWORD PTR _iClearAllBuffState$[ebp]
  0009f	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+60], eax

; 522  : 	pMsg.m_bClearMagicList = iClearMagicList;

  000a2	8b 45 2c	 mov	 eax, DWORD PTR _iClearMagicList$[ebp]
  000a5	89 45 f4	 mov	 DWORD PTR _pMsg$[ebp+64], eax

; 523  : 
; 524  : 	LogAddTD("[Reset System] Req Update User ResetInfo [%s][%s](%d)", lpObj->AccountID, lpObj->Name, lpObj->m_iResetNumber);

  000a8	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000ab	8b 88 78 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6776]
  000b1	51		 push	 ecx
  000b2	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000b5	83 c2 73	 add	 edx, 115		; 00000073H
  000b8	52		 push	 edx
  000b9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000bc	83 c0 68	 add	 eax, 104		; 00000068H
  000bf	50		 push	 eax
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@NMEDGBB@?$FLReset?5System?$FN?5Req?5Update?5User?5@
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000cb	83 c4 10	 add	 esp, 16			; 00000010H

; 525  : 
; 526  : 	lpObj->m_bReqUpdateReset = true;

  000ce	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d1	c6 80 7c 1a 00
	00 01		 mov	 BYTE PTR [eax+6780], 1

; 527  : 
; 528  : 	cDBSMng.Send((char*)&pMsg, sizeof(pMsg));

  000d8	6a 44		 push	 68			; 00000044H
  000da	8d 45 b4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000dd	50		 push	 eax
  000de	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  000e3	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@DBReqUpdat:

; 529  : }

  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	5b		 pop	 ebx
  000eb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ee	33 cd		 xor	 ecx, ebp
  000f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c2 28 00	 ret	 40			; 00000028H
?DBReqUpdateReset@CResetSystem@@QAEXPAVOBJECTSTRUCT@@HHHHHHHHH@Z ENDP ; CResetSystem::DBReqUpdateReset
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?DBLoadReset@CResetSystem@@QAEXPAE@Z
_TEXT	SEGMENT
_szTemp$1 = -276					; size = 256
_lpObj$ = -20						; size = 4
_aIndex$ = -16						; size = 4
_pRecv$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_aRecv$ = 8						; size = 4
?DBLoadReset@CResetSystem@@QAEXPAE@Z PROC		; CResetSystem::DBLoadReset, COMDAT
; _this$ = ecx

; 475  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 54 01 00
	00		 sub	 esp, 340		; 00000154H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 476  : 	PMSG_ANS_CHARACTER_RESET * pRecv = (PMSG_ANS_CHARACTER_RESET *)aRecv;

  00019	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  0001c	89 45 f4	 mov	 DWORD PTR _pRecv$[ebp], eax

; 477  : 
; 478  : 	if(!gObjIsConnectedGP(pRecv->iUserIndex))

  0001f	8b 45 f4	 mov	 eax, DWORD PTR _pRecv$[ebp]
  00022	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ?gObjIsConnectedGP@@YAHH@Z ; gObjIsConnectedGP
  0002b	83 c4 04	 add	 esp, 4
  0002e	85 c0		 test	 eax, eax
  00030	75 05		 jne	 SHORT $LN2@DBLoadRese

; 479  : 	{
; 480  : 		return;

  00032	e9 9c 00 00 00	 jmp	 $LN1@DBLoadRese
$LN2@DBLoadRese:

; 481  : 	}
; 482  : 
; 483  : 	int aIndex = pRecv->iUserIndex;

  00037	8b 45 f4	 mov	 eax, DWORD PTR _pRecv$[ebp]
  0003a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003d	89 4d f0	 mov	 DWORD PTR _aIndex$[ebp], ecx

; 484  : 
; 485  : 	LPOBJECTSTRUCT lpObj = &gObj[aIndex];

  00040	69 45 f0 a0 1b
	00 00		 imul	 eax, DWORD PTR _aIndex$[ebp], 7072
  00047	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  0004d	89 45 ec	 mov	 DWORD PTR _lpObj$[ebp], eax

; 486  : 
; 487  : 	if(lpObj->m_bResetState == 0)

  00050	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00053	0f b6 88 76 1a
	00 00		 movzx	 ecx, BYTE PTR [eax+6774]
  0005a	85 c9		 test	 ecx, ecx
  0005c	75 75		 jne	 SHORT $LN1@DBLoadRese

; 488  : 	{
; 489  : 		lpObj->m_iResetNumber = pRecv->ResetNumber;

  0005e	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00061	8b 4d f4	 mov	 ecx, DWORD PTR _pRecv$[ebp]
  00064	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00067	89 90 78 1a 00
	00		 mov	 DWORD PTR [eax+6776], edx

; 490  : 		lpObj->m_bResetState = 1;

  0006d	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00070	c6 80 76 1a 00
	00 01		 mov	 BYTE PTR [eax+6774], 1

; 491  : 
; 492  : 		char szTemp[256];
; 493  : 		wsprintf(szTemp,"[RESET SYSTEM]: Tienes %d Reset(s).", lpObj->m_iResetNumber); //[Reset System] You currently have %d Reset(s).

  00077	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0007a	8b 88 78 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6776]
  00080	51		 push	 ecx
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@JDMKFIAN@?$FLRESET?5SYSTEM?$FN?3?5Tienes?5?$CFd?5Reset@
  00086	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$1[ebp]
  0008c	52		 push	 edx
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH

; 494  : 		GCServerMsgStringSend(szTemp, lpObj->m_Index, 1);

  00096	6a 01		 push	 1
  00098	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0009b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009d	51		 push	 ecx
  0009e	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$1[ebp]
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 495  : 
; 496  : 
; 497  : 		LogAddTD("[Reset System] Set User ResetInfo [%s][%s](%d)", lpObj->AccountID, lpObj->Name, lpObj->m_iResetNumber);

  000ad	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b0	8b 88 78 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6776]
  000b6	51		 push	 ecx
  000b7	8b 55 ec	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ba	83 c2 73	 add	 edx, 115		; 00000073H
  000bd	52		 push	 edx
  000be	8b 45 ec	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c1	83 c0 68	 add	 eax, 104		; 00000068H
  000c4	50		 push	 eax
  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@OPBOKLMI@?$FLReset?5System?$FN?5Set?5User?5ResetIn@
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000d0	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@DBLoadRese:

; 498  : 	}
; 499  : }

  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c2 04 00	 ret	 4
?DBLoadReset@CResetSystem@@QAEXPAE@Z ENDP		; CResetSystem::DBLoadReset
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?DBGetResetInfo@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pMsg$ = -40						; size = 32
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?DBGetResetInfo@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z PROC ; CResetSystem::DBGetResetInfo, COMDAT
; _this$ = ecx

; 458  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 459  : 	if(lpObj->m_bResetState == 1)

  00016	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00019	0f b6 88 76 1a
	00 00		 movzx	 ecx, BYTE PTR [eax+6774]
  00020	83 f9 01	 cmp	 ecx, 1
  00023	75 02		 jne	 SHORT $LN2@DBGetReset

; 460  : 	{
; 461  : 		return;

  00025	eb 6f		 jmp	 SHORT $LN1@DBGetReset
$LN2@DBGetReset:

; 462  : 	}
; 463  : 
; 464  : 	PMSG_CHARACTER_RESET pMsg;
; 465  : 	pMsg.h.set((LPBYTE)&pMsg, 0xA8, sizeof(pMsg));

  00027	6a 20		 push	 32			; 00000020H
  00029	68 a8 00 00 00	 push	 168			; 000000a8H
  0002e	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00031	50		 push	 eax
  00032	8d 4d d8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00035	e8 00 00 00 00	 call	 ?set@PBMSG_HEAD@@QAEXPAEEE@Z ; PBMSG_HEAD::set

; 466  : 	pMsg.iUserIndex = lpObj->m_Index;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	89 4d dc	 mov	 DWORD PTR _pMsg$[ebp+4], ecx

; 467  : 	memcpy(pMsg.chAccountID, lpObj->AccountID, MAX_IDSTRING);

  00042	6a 0a		 push	 10			; 0000000aH
  00044	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00047	83 c0 68	 add	 eax, 104		; 00000068H
  0004a	50		 push	 eax
  0004b	8d 4d e0	 lea	 ecx, DWORD PTR _pMsg$[ebp+8]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 _memcpy
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 468  : 	pMsg.chAccountID[MAX_IDSTRING] = '\0';

  00057	b8 01 00 00 00	 mov	 eax, 1
  0005c	6b c8 0a	 imul	 ecx, eax, 10
  0005f	c6 44 0d e0 00	 mov	 BYTE PTR _pMsg$[ebp+ecx+8], 0

; 469  : 	memcpy(pMsg.chCharacterName, lpObj->Name, MAX_IDSTRING);

  00064	6a 0a		 push	 10			; 0000000aH
  00066	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00069	83 c0 73	 add	 eax, 115		; 00000073H
  0006c	50		 push	 eax
  0006d	8d 4d eb	 lea	 ecx, DWORD PTR _pMsg$[ebp+19]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 _memcpy
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH

; 470  : 	pMsg.chCharacterName[MAX_IDSTRING] = '\0';

  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	6b c8 0a	 imul	 ecx, eax, 10
  00081	c6 44 0d eb 00	 mov	 BYTE PTR _pMsg$[ebp+ecx+19], 0

; 471  : 	cDBSMng.Send((char*)&pMsg, sizeof(pMsg));

  00086	6a 20		 push	 32			; 00000020H
  00088	8d 45 d8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0008b	50		 push	 eax
  0008c	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  00091	e8 00 00 00 00	 call	 ?Send@DBSockMng@@QAEHPADH@Z ; DBSockMng::Send
$LN1@DBGetReset:

; 472  : }

  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	5b		 pop	 ebx
  00099	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009c	33 cd		 xor	 ecx, ebp
  0009e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c2 04 00	 ret	 4
?DBGetResetInfo@CResetSystem@@QAEXPAVOBJECTSTRUCT@@@Z ENDP ; CResetSystem::DBGetResetInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?Load@CResetSystem@@QAEHPAD@Z
_TEXT	SEGMENT
tv455 = -280						; size = 4
tv454 = -280						; size = 4
tv453 = -280						; size = 4
tv452 = -280						; size = 4
tv451 = -280						; size = 4
tv450 = -280						; size = 4
tv449 = -280						; size = 4
tv448 = -280						; size = 4
tv447 = -280						; size = 4
tv446 = -280						; size = 4
tv445 = -280						; size = 4
tv444 = -280						; size = 4
tv443 = -280						; size = 4
tv442 = -280						; size = 4
tv441 = -280						; size = 4
tv440 = -280						; size = 4
tv439 = -280						; size = 4
tv438 = -280						; size = 4
tv437 = -280						; size = 4
tv436 = -280						; size = 4
tv435 = -280						; size = 4
tv434 = -280						; size = 4
tv433 = -280						; size = 4
tv432 = -280						; size = 4
tv431 = -280						; size = 4
tv430 = -280						; size = 4
tv429 = -280						; size = 4
tv428 = -280						; size = 4
tv427 = -280						; size = 4
tv426 = -280						; size = 4
tv425 = -280						; size = 4
tv424 = -280						; size = 4
tv423 = -280						; size = 4
tv422 = -280						; size = 4
tv421 = -280						; size = 4
tv420 = -280						; size = 4
tv419 = -280						; size = 4
tv418 = -280						; size = 4
tv417 = -280						; size = 4
tv416 = -280						; size = 4
tv383 = -280						; size = 4
tv382 = -280						; size = 4
tv381 = -280						; size = 4
tv380 = -280						; size = 4
tv379 = -280						; size = 4
tv378 = -280						; size = 4
tv377 = -280						; size = 4
tv376 = -280						; size = 4
tv375 = -280						; size = 4
tv374 = -280						; size = 4
tv373 = -280						; size = 4
tv372 = -280						; size = 4
tv371 = -280						; size = 4
tv370 = -280						; size = 4
tv369 = -280						; size = 4
tv141 = -280						; size = 4
tv134 = -280						; size = 4
$T2 = -276						; size = 4
_NpcData$3 = -208					; size = 20
_Index$4 = -188						; size = 4
_BornPlace$5 = -184					; size = 12
_ReqSpecialItem$6 = -172				; size = 28
_NonTableReset$7 = -144					; size = 52
_type$8 = -92						; size = 4
_Token$9 = -88						; size = 4
_TableReset$ = -84					; size = 60
_this$ = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_lpszFileName$ = 8					; size = 4
?Load@CResetSystem@@QAEHPAD@Z PROC			; CResetSystem::Load, COMDAT
; _this$ = ecx

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Load@CResetSystem@@QAEHPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	57		 push	 edi
  00025	50		 push	 eax
  00026	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00029	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00032	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 156  : 	this->Clear();

  00035	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?Clear@CResetSystem@@QAEXXZ ; CResetSystem::Clear

; 157  : 
; 158  : 	if ( !lpszFileName || !strcmp(lpszFileName , "") )

  0003d	83 7d 08 00	 cmp	 DWORD PTR _lpszFileName$[ebp], 0
  00041	74 15		 je	 SHORT $LN7@Load
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00048	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _strcmp
  00051	83 c4 08	 add	 esp, 8
  00054	85 c0		 test	 eax, eax
  00056	75 14		 jne	 SHORT $LN6@Load
$LN7@Load:

; 159  : 	{
; 160  : 		MsgBox("[Reset System] - File load error : File Name Error");

  00058	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@GLFDECHM@?$FLReset?5System?$FN?5?9?5File?5load?5erro@
  0005d	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00062	83 c4 04	 add	 esp, 4

; 161  : 		return FALSE;

  00065	33 c0		 xor	 eax, eax
  00067	e9 e0 09 00 00	 jmp	 $LN1@Load
$LN6@Load:

; 162  : 	}
; 163  : 
; 164  : 	TABLE_RESET TableReset;
; 165  : 
; 166  : 	memset(&TableReset, 0, sizeof(TableReset));

  0006c	6a 3c		 push	 60			; 0000003cH
  0006e	6a 00		 push	 0
  00070	8d 45 ac	 lea	 eax, DWORD PTR _TableReset$[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _memset
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH

; 167  : 
; 168  : 	try

  0007c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 169  : 	{
; 170  : 		SMDFile = fopen(lpszFileName, "r");

  00083	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  00088	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _fopen
  00091	83 c4 08	 add	 esp, 8
  00094	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax

; 171  : 
; 172  : 		if ( SMDFile == NULL )

  00099	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, 0
  000a0	75 18		 jne	 SHORT $LN9@Load

; 173  : 		{
; 174  : 			MsgBox("[Reset System] Info file Load Fail [%s]", lpszFileName);

  000a2	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  000a5	50		 push	 eax
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@LILKLNJA@?$FLReset?5System?$FN?5Info?5file?5Load?5F@
  000ab	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  000b0	83 c4 08	 add	 esp, 8

; 175  : 
; 176  : 			return false;

  000b3	33 c0		 xor	 eax, eax
  000b5	e9 92 09 00 00	 jmp	 $LN1@Load
$LN9@Load:

; 177  : 		}
; 178  : 
; 179  : 		int Token;
; 180  : 		int type = -1;

  000ba	c7 45 a4 ff ff
	ff ff		 mov	 DWORD PTR _type$8[ebp], -1
$LN2@Load:

; 181  : 
; 182  : 		while ( true )

  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	85 c0		 test	 eax, eax
  000c8	0f 84 28 09 00
	00		 je	 $LN3@Load

; 183  : 		{
; 184  : 			Token = GetToken();

  000ce	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000d3	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv369[ebp], eax
  000d9	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv369[ebp]
  000df	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 185  : 
; 186  : 			if ( Token == END )

  000e2	83 7d a8 02	 cmp	 DWORD PTR _Token$9[ebp], 2
  000e6	75 05		 jne	 SHORT $LN10@Load

; 187  : 			{
; 188  : 				break;

  000e8	e9 09 09 00 00	 jmp	 $LN3@Load
$LN10@Load:

; 189  : 			}
; 190  : 
; 191  : 			type = TokenNumber;

  000ed	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000f5	89 45 a4	 mov	 DWORD PTR _type$8[ebp], eax
$LN4@Load:

; 192  : 
; 193  : 			while ( true )

  000f8	b8 01 00 00 00	 mov	 eax, 1
  000fd	85 c0		 test	 eax, eax
  000ff	0f 84 ec 08 00
	00		 je	 $LN5@Load

; 194  : 			{
; 195  : 				if ( type == 0 ) //Reset Settings

  00105	83 7d a4 00	 cmp	 DWORD PTR _type$8[ebp], 0
  00109	0f 85 36 01 00
	00		 jne	 $LN11@Load

; 196  : 				{
; 197  : 					Token = GetToken();

  0010f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00114	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv370[ebp], eax
  0011a	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv370[ebp]
  00120	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 198  : 
; 199  : 					if ( strcmp("end", TokenString) == 0 )

  00123	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  0012d	e8 00 00 00 00	 call	 _strcmp
  00132	83 c4 08	 add	 esp, 8
  00135	85 c0		 test	 eax, eax
  00137	75 05		 jne	 SHORT $LN13@Load

; 200  : 					{
; 201  : 						break;

  00139	e9 b3 08 00 00	 jmp	 $LN5@Load
$LN13@Load:

; 202  : 					}
; 203  : 
; 204  : 					this->m_bUseResetSystem = TokenNumber;

  0013e	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00146	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00149	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 205  : 					
; 206  : 					Token = GetToken();

  0014c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00151	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv371[ebp], eax
  00157	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv371[ebp]
  0015d	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 207  : 					this->m_bResetSystemType = TokenNumber;

  00160	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00168	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016b	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 208  : 
; 209  : 					Token = GetToken();

  0016e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00173	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv372[ebp], eax
  00179	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv372[ebp]
  0017f	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 210  : 					this->m_bUseResetCommand = TokenNumber;

  00182	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0018a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018d	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 211  : 
; 212  : 					Token = GetToken();

  00190	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00195	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv373[ebp], eax
  0019b	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv373[ebp]
  001a1	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 213  : 					this->m_bZenMultiply = TokenNumber > 0;

  001a4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?TokenNumber@@3MA
  001ac	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  001b3	76 0c		 jbe	 SHORT $LN33@Load
  001b5	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv134[ebp], 1
  001bf	eb 0a		 jmp	 SHORT $LN34@Load
$LN33@Load:
  001c1	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv134[ebp], 0
$LN34@Load:
  001cb	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001ce	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv134[ebp]
  001d4	89 48 2c	 mov	 DWORD PTR [eax+44], ecx

; 214  : 
; 215  : 					Token = GetToken();

  001d7	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001dc	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv374[ebp], eax
  001e2	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv374[ebp]
  001e8	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 216  : 					this->m_iZenPrice = TokenNumber;

  001eb	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001f3	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f6	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 217  : 
; 218  : 					Token = GetToken();

  001f9	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  001fe	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv375[ebp], eax
  00204	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv375[ebp]
  0020a	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 219  : 					this->m_bLeadershipReset = TokenNumber > 0;

  0020d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?TokenNumber@@3MA
  00215	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0021c	76 0c		 jbe	 SHORT $LN35@Load
  0021e	c7 85 e8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv141[ebp], 1
  00228	eb 0a		 jmp	 SHORT $LN36@Load
$LN35@Load:
  0022a	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv141[ebp], 0
$LN36@Load:
  00234	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00237	8a 8d e8 fe ff
	ff		 mov	 cl, BYTE PTR tv141[ebp]
  0023d	88 48 34	 mov	 BYTE PTR [eax+52], cl

; 220  : 				}

  00240	e9 a7 07 00 00	 jmp	 $LN30@Load
$LN11@Load:

; 221  : 
; 222  : 				else if ( type == 1 ) //Simple Reset Settings

  00245	83 7d a4 01	 cmp	 DWORD PTR _type$8[ebp], 1
  00249	0f 85 d1 01 00
	00		 jne	 $LN14@Load

; 223  : 				{
; 224  : 					Token = GetToken();

  0024f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00254	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv376[ebp], eax
  0025a	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv376[ebp]
  00260	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 225  : 
; 226  : 					if ( strcmp("end", TokenString) == 0 )

  00263	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  00268	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  0026d	e8 00 00 00 00	 call	 _strcmp
  00272	83 c4 08	 add	 esp, 8
  00275	85 c0		 test	 eax, eax
  00277	75 05		 jne	 SHORT $LN16@Load

; 227  : 					{
; 228  : 						break;

  00279	e9 73 07 00 00	 jmp	 $LN5@Load
$LN16@Load:

; 229  : 					}
; 230  : 
; 231  : 					NON_TABLE_RESET NonTableReset;
; 232  : 
; 233  : 					NonTableReset.m_iRuleIndex = TokenNumber;

  0027e	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00286	89 85 70 ff ff
	ff		 mov	 DWORD PTR _NonTableReset$7[ebp], eax

; 234  : 
; 235  : 					Token = GetToken();

  0028c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00291	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv377[ebp], eax
  00297	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv377[ebp]
  0029d	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 236  : 					NonTableReset.m_iCharClassType = TokenNumber;

  002a0	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002a8	89 85 74 ff ff
	ff		 mov	 DWORD PTR _NonTableReset$7[ebp+4], eax

; 237  : 
; 238  : 					Token = GetToken();

  002ae	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002b3	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv378[ebp], eax
  002b9	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv378[ebp]
  002bf	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 239  : 					NonTableReset.m_iMinLevel = TokenNumber;

  002c2	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002ca	89 85 78 ff ff
	ff		 mov	 DWORD PTR _NonTableReset$7[ebp+8], eax

; 240  : 
; 241  : 					Token = GetToken();

  002d0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002d5	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv379[ebp], eax
  002db	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv379[ebp]
  002e1	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 242  : 					NonTableReset.m_iMaxLevel = TokenNumber;

  002e4	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002ec	89 85 7c ff ff
	ff		 mov	 DWORD PTR _NonTableReset$7[ebp+12], eax

; 243  : 
; 244  : 					Token = GetToken();

  002f2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002f7	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv380[ebp], eax
  002fd	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv380[ebp]
  00303	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 245  : 					NonTableReset.m_bClearStat = TokenNumber;

  00306	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0030e	89 45 80	 mov	 DWORD PTR _NonTableReset$7[ebp+16], eax

; 246  : 
; 247  : 					Token = GetToken();

  00311	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00316	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv381[ebp], eax
  0031c	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv381[ebp]
  00322	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 248  : 					NonTableReset.m_iLevelAfterReset = TokenNumber;

  00325	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0032d	89 45 84	 mov	 DWORD PTR _NonTableReset$7[ebp+20], eax

; 249  : 
; 250  : 					Token = GetToken();

  00330	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00335	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv382[ebp], eax
  0033b	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv382[ebp]
  00341	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 251  : 					NonTableReset.m_iLevelUpPoint = TokenNumber;

  00344	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0034c	89 45 88	 mov	 DWORD PTR _NonTableReset$7[ebp+24], eax

; 252  : 
; 253  : 					Token = GetToken();

  0034f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00354	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv383[ebp], eax
  0035a	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv383[ebp]
  00360	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 254  : 					NonTableReset.m_bReqSpecialItem = TokenNumber;

  00363	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0036b	89 45 8c	 mov	 DWORD PTR _NonTableReset$7[ebp+28], eax

; 255  : 
; 256  : 					Token = GetToken();

  0036e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00373	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv416[ebp], eax
  00379	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv416[ebp]
  0037f	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 257  : 					NonTableReset.m_bBornPlace = TokenNumber;

  00382	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0038a	89 45 90	 mov	 DWORD PTR _NonTableReset$7[ebp+32], eax

; 258  : 
; 259  : 					Token = GetToken();

  0038d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00392	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv417[ebp], eax
  00398	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv417[ebp]
  0039e	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 260  : 					NonTableReset.m_bClearBuffState = TokenNumber;

  003a1	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  003a9	89 45 94	 mov	 DWORD PTR _NonTableReset$7[ebp+36], eax

; 261  : 
; 262  : 					Token = GetToken();

  003ac	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003b1	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv418[ebp], eax
  003b7	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv418[ebp]
  003bd	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 263  : 					NonTableReset.m_iVipCode = TokenNumber;

  003c0	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  003c8	89 45 98	 mov	 DWORD PTR _NonTableReset$7[ebp+40], eax

; 264  : 
; 265  : 					Token = GetToken();

  003cb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003d0	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv419[ebp], eax
  003d6	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv419[ebp]
  003dc	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 266  : 					NonTableReset.m_iCheckInventory = TokenNumber;

  003df	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  003e7	89 45 9c	 mov	 DWORD PTR _NonTableReset$7[ebp+44], eax

; 267  : 
; 268  : 					Token = GetToken();

  003ea	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  003ef	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv420[ebp], eax
  003f5	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv420[ebp]
  003fb	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 269  : 					NonTableReset.m_bClearMagicList = TokenNumber;

  003fe	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00406	89 45 a0	 mov	 DWORD PTR _NonTableReset$7[ebp+48], eax

; 270  : 
; 271  : 					this->m_vtNonTableReset.push_back(NonTableReset);

  00409	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _NonTableReset$7[ebp]
  0040f	50		 push	 eax
  00410	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00413	83 c1 38	 add	 ecx, 56			; 00000038H
  00416	e8 00 00 00 00	 call	 ?push_back@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEXABUNON_TABLE_RESET@@@Z ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::push_back

; 272  : 				}

  0041b	e9 cc 05 00 00	 jmp	 $LN30@Load
$LN14@Load:

; 273  : 
; 274  : 				else if ( type == 2 ) //Table Reset Settings

  00420	83 7d a4 02	 cmp	 DWORD PTR _type$8[ebp], 2
  00424	0f 85 e7 01 00
	00		 jne	 $LN17@Load

; 275  : 				{
; 276  : 					Token = GetToken();

  0042a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0042f	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv421[ebp], eax
  00435	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv421[ebp]
  0043b	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 277  : 
; 278  : 					if ( strcmp("end", TokenString) == 0 )

  0043e	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  00443	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  00448	e8 00 00 00 00	 call	 _strcmp
  0044d	83 c4 08	 add	 esp, 8
  00450	85 c0		 test	 eax, eax
  00452	75 05		 jne	 SHORT $LN19@Load

; 279  : 					{
; 280  : 						break;

  00454	e9 98 05 00 00	 jmp	 $LN5@Load
$LN19@Load:

; 281  : 					}
; 282  : 
; 283  : 					TableReset.m_iRuleIndex = TokenNumber;

  00459	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00461	89 45 ac	 mov	 DWORD PTR _TableReset$[ebp], eax

; 284  : 
; 285  : 					Token = GetToken();

  00464	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00469	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv422[ebp], eax
  0046f	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv422[ebp]
  00475	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 286  : 					TableReset.m_iCharClassType = TokenNumber;

  00478	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00480	89 45 b0	 mov	 DWORD PTR _TableReset$[ebp+4], eax

; 287  : 
; 288  : 					Token = GetToken();

  00483	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00488	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv423[ebp], eax
  0048e	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv423[ebp]
  00494	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 289  : 					TableReset.m_iMinLevel = TokenNumber;

  00497	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0049f	89 45 b4	 mov	 DWORD PTR _TableReset$[ebp+8], eax

; 290  : 
; 291  : 					Token = GetToken();

  004a2	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004a7	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv424[ebp], eax
  004ad	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv424[ebp]
  004b3	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 292  : 					TableReset.m_iMaxLevel = TokenNumber;

  004b6	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  004be	89 45 b8	 mov	 DWORD PTR _TableReset$[ebp+12], eax

; 293  : 
; 294  : 					Token = GetToken();

  004c1	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004c6	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv425[ebp], eax
  004cc	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv425[ebp]
  004d2	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 295  : 					TableReset.m_bClearStat = TokenNumber;

  004d5	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  004dd	89 45 bc	 mov	 DWORD PTR _TableReset$[ebp+16], eax

; 296  : 
; 297  : 					Token = GetToken();

  004e0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  004e5	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv426[ebp], eax
  004eb	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv426[ebp]
  004f1	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 298  : 					TableReset.m_iLevelAfterReset = TokenNumber;

  004f4	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  004fc	89 45 c0	 mov	 DWORD PTR _TableReset$[ebp+20], eax

; 299  : 
; 300  : 					Token = GetToken();

  004ff	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00504	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv427[ebp], eax
  0050a	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv427[ebp]
  00510	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 301  : 					TableReset.m_iLevelUpPoint = TokenNumber;

  00513	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0051b	89 45 c4	 mov	 DWORD PTR _TableReset$[ebp+24], eax

; 302  : 
; 303  : 					Token = GetToken();

  0051e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00523	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv428[ebp], eax
  00529	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv428[ebp]
  0052f	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 304  : 					TableReset.m_bReqSpecialItem = TokenNumber;

  00532	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0053a	89 45 c8	 mov	 DWORD PTR _TableReset$[ebp+28], eax

; 305  : 
; 306  : 					Token = GetToken();

  0053d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00542	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv429[ebp], eax
  00548	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv429[ebp]
  0054e	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 307  : 					TableReset.m_bBornPlace = TokenNumber;

  00551	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00559	89 45 cc	 mov	 DWORD PTR _TableReset$[ebp+32], eax

; 308  : 
; 309  : 					TableReset.m_iMinResetNumber = TableReset.m_iResetNumber;

  0055c	8b 45 d4	 mov	 eax, DWORD PTR _TableReset$[ebp+40]
  0055f	89 45 d0	 mov	 DWORD PTR _TableReset$[ebp+36], eax

; 310  : 
; 311  : 					Token = GetToken();

  00562	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00567	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv430[ebp], eax
  0056d	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv430[ebp]
  00573	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 312  : 					TableReset.m_iResetNumber = TokenNumber;

  00576	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0057e	89 45 d4	 mov	 DWORD PTR _TableReset$[ebp+40], eax

; 313  : 
; 314  : 					Token = GetToken();

  00581	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00586	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv431[ebp], eax
  0058c	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv431[ebp]
  00592	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 315  : 					TableReset.m_bClearBuffState = TokenNumber;

  00595	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0059d	89 45 d8	 mov	 DWORD PTR _TableReset$[ebp+44], eax

; 316  : 
; 317  : 					Token = GetToken();

  005a0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  005a5	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv432[ebp], eax
  005ab	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv432[ebp]
  005b1	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 318  : 					TableReset.m_iVipCode = TokenNumber;

  005b4	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  005bc	89 45 dc	 mov	 DWORD PTR _TableReset$[ebp+48], eax

; 319  : 
; 320  : 					Token = GetToken();

  005bf	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  005c4	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv433[ebp], eax
  005ca	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv433[ebp]
  005d0	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 321  : 					TableReset.m_iCheckInventory = TokenNumber;

  005d3	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  005db	89 45 e0	 mov	 DWORD PTR _TableReset$[ebp+52], eax

; 322  : 
; 323  : 					Token = GetToken();

  005de	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  005e3	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv434[ebp], eax
  005e9	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv434[ebp]
  005ef	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 324  : 					TableReset.m_bClearMagicList = TokenNumber;

  005f2	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  005fa	89 45 e4	 mov	 DWORD PTR _TableReset$[ebp+56], eax

; 325  : 
; 326  : 					this->m_vtTableReset.push_back(TableReset);

  005fd	8d 45 ac	 lea	 eax, DWORD PTR _TableReset$[ebp]
  00600	50		 push	 eax
  00601	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00604	83 c1 44	 add	 ecx, 68			; 00000044H
  00607	e8 00 00 00 00	 call	 ?push_back@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEXABUTABLE_RESET@@@Z ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::push_back

; 327  : 				}

  0060c	e9 db 03 00 00	 jmp	 $LN30@Load
$LN17@Load:

; 328  : 
; 329  : 				else if ( type == 3 ) //Special Item Settings

  00611	83 7d a4 03	 cmp	 DWORD PTR _type$8[ebp], 3
  00615	0f 85 86 01 00
	00		 jne	 $LN20@Load

; 330  : 				{
; 331  : 					Token = GetToken();

  0061b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00620	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv435[ebp], eax
  00626	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv435[ebp]
  0062c	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 332  : 
; 333  : 					if ( strcmp("end", TokenString) == 0 )

  0062f	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  00634	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  00639	e8 00 00 00 00	 call	 _strcmp
  0063e	83 c4 08	 add	 esp, 8
  00641	85 c0		 test	 eax, eax
  00643	75 05		 jne	 SHORT $LN22@Load

; 334  : 					{
; 335  : 						break;

  00645	e9 a7 03 00 00	 jmp	 $LN5@Load
$LN22@Load:

; 336  : 					}
; 337  : 
; 338  : 					REQUIRE_SPECIAL_ITEM ReqSpecialItem;
; 339  : 
; 340  : 					ReqSpecialItem.m_iResetRuleIndex = TokenNumber;

  0064a	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00652	89 85 54 ff ff
	ff		 mov	 DWORD PTR _ReqSpecialItem$6[ebp], eax

; 341  : 
; 342  : 					Token = GetToken();

  00658	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0065d	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv436[ebp], eax
  00663	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv436[ebp]
  00669	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 343  : 					ReqSpecialItem.m_iItemCategory = TokenNumber;

  0066c	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00674	89 85 58 ff ff
	ff		 mov	 DWORD PTR _ReqSpecialItem$6[ebp+4], eax

; 344  : 
; 345  : 					Token = GetToken();

  0067a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0067f	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv437[ebp], eax
  00685	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv437[ebp]
  0068b	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 346  : 					ReqSpecialItem.m_iItemCode = TokenNumber;

  0068e	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00696	89 85 5c ff ff
	ff		 mov	 DWORD PTR _ReqSpecialItem$6[ebp+8], eax

; 347  : 
; 348  : 					Token = GetToken();

  0069c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006a1	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv438[ebp], eax
  006a7	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv438[ebp]
  006ad	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 349  : 					ReqSpecialItem.m_iItemLevel = TokenNumber;

  006b0	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  006b8	89 85 60 ff ff
	ff		 mov	 DWORD PTR _ReqSpecialItem$6[ebp+12], eax

; 350  : 
; 351  : 					Token = GetToken();

  006be	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006c3	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv439[ebp], eax
  006c9	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv439[ebp]
  006cf	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 352  : 					ReqSpecialItem.m_btOption1 = TokenNumber;

  006d2	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  006da	88 85 64 ff ff
	ff		 mov	 BYTE PTR _ReqSpecialItem$6[ebp+16], al

; 353  : 
; 354  : 					Token = GetToken();

  006e0	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  006e5	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv440[ebp], eax
  006eb	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv440[ebp]
  006f1	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 355  : 					ReqSpecialItem.m_btOption2 = TokenNumber;

  006f4	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  006fc	88 85 65 ff ff
	ff		 mov	 BYTE PTR _ReqSpecialItem$6[ebp+17], al

; 356  : 
; 357  : 					Token = GetToken();

  00702	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00707	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv441[ebp], eax
  0070d	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv441[ebp]
  00713	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 358  : 					ReqSpecialItem.m_btOption3 = TokenNumber;

  00716	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0071e	88 85 66 ff ff
	ff		 mov	 BYTE PTR _ReqSpecialItem$6[ebp+18], al

; 359  : 
; 360  : 					Token = GetToken();

  00724	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00729	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv442[ebp], eax
  0072f	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv442[ebp]
  00735	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 361  : 					ReqSpecialItem.m_btNewOption = TokenNumber;

  00738	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00740	88 85 67 ff ff
	ff		 mov	 BYTE PTR _ReqSpecialItem$6[ebp+19], al

; 362  : 
; 363  : 					Token = GetToken();

  00746	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0074b	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv443[ebp], eax
  00751	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv443[ebp]
  00757	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 364  : 					ReqSpecialItem.m_iItemNumber = TokenNumber;

  0075a	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00762	89 85 68 ff ff
	ff		 mov	 DWORD PTR _ReqSpecialItem$6[ebp+20], eax

; 365  : 
; 366  : 					Token = GetToken();

  00768	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0076d	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv444[ebp], eax
  00773	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv444[ebp]
  00779	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 367  : 					ReqSpecialItem.m_iItemPosition = TokenNumber;

  0077c	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00784	89 85 6c ff ff
	ff		 mov	 DWORD PTR _ReqSpecialItem$6[ebp+24], eax

; 368  : 
; 369  : 					this->m_vtReqSpecialItem.push_back(ReqSpecialItem);

  0078a	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _ReqSpecialItem$6[ebp]
  00790	50		 push	 eax
  00791	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00794	83 c1 50	 add	 ecx, 80			; 00000050H
  00797	e8 00 00 00 00	 call	 ?push_back@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEXABUREQUIRE_SPECIAL_ITEM@@@Z ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::push_back

; 370  : 				}

  0079c	e9 4b 02 00 00	 jmp	 $LN30@Load
$LN20@Load:

; 371  : 
; 372  : 				else if ( type == 4 ) //Born Place Settings

  007a1	83 7d a4 04	 cmp	 DWORD PTR _type$8[ebp], 4
  007a5	0f 85 98 00 00
	00		 jne	 $LN23@Load

; 373  : 				{
; 374  : 					Token = GetToken();

  007ab	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  007b0	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv445[ebp], eax
  007b6	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv445[ebp]
  007bc	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 375  : 
; 376  : 					if ( strcmp("end", TokenString) == 0 )

  007bf	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  007c4	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  007c9	e8 00 00 00 00	 call	 _strcmp
  007ce	83 c4 08	 add	 esp, 8
  007d1	85 c0		 test	 eax, eax
  007d3	75 05		 jne	 SHORT $LN25@Load

; 377  : 					{
; 378  : 						break;

  007d5	e9 17 02 00 00	 jmp	 $LN5@Load
$LN25@Load:

; 379  : 					}
; 380  : 
; 381  : 					BORN_PLACE BornPlace;
; 382  : 
; 383  : 					BornPlace.m_iResetRuleIndex = TokenNumber;

  007da	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  007e2	89 85 48 ff ff
	ff		 mov	 DWORD PTR _BornPlace$5[ebp], eax

; 384  : 
; 385  : 					Token = GetToken();

  007e8	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  007ed	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv446[ebp], eax
  007f3	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv446[ebp]
  007f9	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 386  : 					BornPlace.m_iCharClassType = TokenNumber;

  007fc	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00804	89 85 4c ff ff
	ff		 mov	 DWORD PTR _BornPlace$5[ebp+4], eax

; 387  : 
; 388  : 					Token = GetToken();

  0080a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0080f	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv447[ebp], eax
  00815	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv447[ebp]
  0081b	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 389  : 					BornPlace.m_iGateNumber = TokenNumber;

  0081e	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00826	89 85 50 ff ff
	ff		 mov	 DWORD PTR _BornPlace$5[ebp+8], eax

; 390  : 
; 391  : 					this->m_vtBornPlace.push_back(BornPlace);

  0082c	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR _BornPlace$5[ebp]
  00832	50		 push	 eax
  00833	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00836	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00839	e8 00 00 00 00	 call	 ?push_back@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEXABUBORN_PLACE@@@Z ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::push_back

; 392  : 				}

  0083e	e9 a9 01 00 00	 jmp	 $LN30@Load
$LN23@Load:

; 393  : 
; 394  : 				else if ( type == 5 ) //Message Settings

  00843	83 7d a4 05	 cmp	 DWORD PTR _type$8[ebp], 5
  00847	0f 85 c1 00 00
	00		 jne	 $LN26@Load

; 395  : 				{
; 396  : 					Token = GetToken();

  0084d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00852	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv448[ebp], eax
  00858	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv448[ebp]
  0085e	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 397  : 
; 398  : 					if ( strcmp("end", TokenString) == 0 )

  00861	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  00866	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  0086b	e8 00 00 00 00	 call	 _strcmp
  00870	83 c4 08	 add	 esp, 8
  00873	85 c0		 test	 eax, eax
  00875	75 05		 jne	 SHORT $LN28@Load

; 399  : 					{
; 400  : 						break;

  00877	e9 75 01 00 00	 jmp	 $LN5@Load
$LN28@Load:

; 401  : 					}
; 402  : 
; 403  : 					int Index = TokenNumber;

  0087c	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00884	89 85 44 ff ff
	ff		 mov	 DWORD PTR _Index$4[ebp], eax

; 404  : 
; 405  : 					Token = GetToken();

  0088a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0088f	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv449[ebp], eax
  00895	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv449[ebp]
  0089b	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 406  : 					
; 407  : 					if(Index < MAX_MESSAGE && Index >= 0)

  0089e	83 bd 44 ff ff
	ff 05		 cmp	 DWORD PTR _Index$4[ebp], 5
  008a5	7d 62		 jge	 SHORT $LN29@Load
  008a7	83 bd 44 ff ff
	ff 00		 cmp	 DWORD PTR _Index$4[ebp], 0
  008ae	7c 59		 jl	 SHORT $LN29@Load

; 408  : 					{
; 409  : 						this->lpMessage[Index] = new char[strlen(TokenString)+1];

  008b0	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  008b5	e8 00 00 00 00	 call	 _strlen
  008ba	83 c4 04	 add	 esp, 4
  008bd	83 c0 01	 add	 eax, 1
  008c0	50		 push	 eax
  008c1	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  008c6	83 c4 04	 add	 esp, 4
  008c9	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv450[ebp], eax
  008cf	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv450[ebp]
  008d5	89 85 ec fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  008db	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR _Index$4[ebp]
  008e1	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  008e4	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  008ea	89 44 8a 70	 mov	 DWORD PTR [edx+ecx*4+112], eax

; 410  : 						strcpy(this->lpMessage[Index], TokenString);

  008ee	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  008f3	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _Index$4[ebp]
  008f9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  008fc	8b 54 81 70	 mov	 edx, DWORD PTR [ecx+eax*4+112]
  00900	52		 push	 edx
  00901	e8 00 00 00 00	 call	 _strcpy
  00906	83 c4 08	 add	 esp, 8
$LN29@Load:

; 411  : 					}
; 412  : 				}

  00909	e9 de 00 00 00	 jmp	 $LN30@Load
$LN26@Load:

; 413  : 
; 414  : 				else if ( type == 6 ) //NPC Settings

  0090e	83 7d a4 06	 cmp	 DWORD PTR _type$8[ebp], 6
  00912	0f 85 d4 00 00
	00		 jne	 $LN30@Load

; 415  : 				{
; 416  : 					Token = GetToken();

  00918	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0091d	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv451[ebp], eax
  00923	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv451[ebp]
  00929	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 417  : 
; 418  : 					if ( strcmp("end", TokenString) == 0 )

  0092c	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  00931	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  00936	e8 00 00 00 00	 call	 _strcmp
  0093b	83 c4 08	 add	 esp, 8
  0093e	85 c0		 test	 eax, eax
  00940	75 05		 jne	 SHORT $LN31@Load

; 419  : 					{
; 420  : 						break;

  00942	e9 aa 00 00 00	 jmp	 $LN5@Load
$LN31@Load:

; 421  : 					}
; 422  : 
; 423  : 					NPC_DATA NpcData;
; 424  : 
; 425  : 					NpcData.m_iNpcIndex = TokenNumber;

  00947	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0094f	89 85 30 ff ff
	ff		 mov	 DWORD PTR _NpcData$3[ebp], eax

; 426  : 
; 427  : 					Token = GetToken();

  00955	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0095a	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv452[ebp], eax
  00960	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv452[ebp]
  00966	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 428  : 					NpcData.m_iMapIndex = TokenNumber;

  00969	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00971	89 85 34 ff ff
	ff		 mov	 DWORD PTR _NpcData$3[ebp+4], eax

; 429  : 
; 430  : 					Token = GetToken();

  00977	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0097c	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv453[ebp], eax
  00982	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv453[ebp]
  00988	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 431  : 					NpcData.m_icX = TokenNumber;

  0098b	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00993	89 85 38 ff ff
	ff		 mov	 DWORD PTR _NpcData$3[ebp+8], eax

; 432  : 
; 433  : 					Token = GetToken();

  00999	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  0099e	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv454[ebp], eax
  009a4	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv454[ebp]
  009aa	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 434  : 					NpcData.m_icY = TokenNumber;

  009ad	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  009b5	89 85 3c ff ff
	ff		 mov	 DWORD PTR _NpcData$3[ebp+12], eax

; 435  : 
; 436  : 					Token = GetToken();

  009bb	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  009c0	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv455[ebp], eax
  009c6	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv455[ebp]
  009cc	89 45 a8	 mov	 DWORD PTR _Token$9[ebp], eax

; 437  : 					NpcData.m_iDir = TokenNumber;

  009cf	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  009d7	89 85 40 ff ff
	ff		 mov	 DWORD PTR _NpcData$3[ebp+16], eax

; 438  : 
; 439  : 					this->SetResetNPCData(NpcData);

  009dd	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _NpcData$3[ebp]
  009e3	50		 push	 eax
  009e4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  009e7	e8 00 00 00 00	 call	 ?SetResetNPCData@CResetSystem@@QAEXAAUNPC_DATA@@@Z ; CResetSystem::SetResetNPCData
$LN30@Load:

; 440  : 				}
; 441  : 			}

  009ec	e9 07 f7 ff ff	 jmp	 $LN4@Load
$LN5@Load:

; 442  : 		}

  009f1	e9 cb f6 ff ff	 jmp	 $LN2@Load
$LN3@Load:

; 443  : 
; 444  : 		fclose(SMDFile);

  009f6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  009fb	50		 push	 eax
  009fc	e8 00 00 00 00	 call	 _fclose
  00a01	83 c4 04	 add	 esp, 4

; 445  : 		LogAdd("[Reset System] %s file load!", lpszFileName);

  00a04	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00a07	50		 push	 eax
  00a08	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PJBHKEBH@?$FLReset?5System?$FN?5?$CFs?5file?5load?$CB@
  00a0d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00a13	83 c4 08	 add	 esp, 8

; 446  : 
; 447  : 		this->Init(); //check settings from the file

  00a16	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a19	e8 00 00 00 00	 call	 ?Init@CResetSystem@@QAEXXZ ; CResetSystem::Init

; 448  : 	}	// __try

  00a1e	eb 17		 jmp	 SHORT $LN37@Load
__catch$?Load@CResetSystem@@QAEHPAD@Z$0:

; 449  : 	catch ( DWORD )
; 450  : 	{
; 451  : 		MsgBox("[Reset System] - Loading Exception Error (%s) File. ", lpszFileName);

  00a20	8b 45 08	 mov	 eax, DWORD PTR _lpszFileName$[ebp]
  00a23	50		 push	 eax
  00a24	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@GGODGFJG@?$FLReset?5System?$FN?5?9?5Loading?5Except@
  00a29	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00a2e	83 c4 08	 add	 esp, 8

; 452  : 	}

  00a31	b8 00 00 00 00	 mov	 eax, $LN40@Load
  00a36	c3		 ret	 0
$LN37@Load:
  00a37	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00a3e	eb 07		 jmp	 SHORT $LN39@Load
$LN40@Load:
  00a40	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN39@Load:

; 453  : 
; 454  : 	return true;

  00a47	b8 01 00 00 00	 mov	 eax, 1
$LN1@Load:

; 455  : }

  00a4c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00a4f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00a56	59		 pop	 ecx
  00a57	5f		 pop	 edi
  00a58	5e		 pop	 esi
  00a59	5b		 pop	 ebx
  00a5a	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a5d	33 cd		 xor	 ecx, ebp
  00a5f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a64	8b e5		 mov	 esp, ebp
  00a66	5d		 pop	 ebp
  00a67	c2 04 00	 ret	 4
  00a6a	cc		 int	 3
  00a6b	cc		 int	 3
  00a6c	cc		 int	 3
  00a6d	cc		 int	 3
  00a6e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Load@CResetSystem@@QAEHPAD@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a e4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-284]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@CResetSystem@@QAEHPAD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@CResetSystem@@QAEHPAD@Z ENDP			; CResetSystem::Load
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?Init@CResetSystem@@QAEXXZ
_TEXT	SEGMENT
$T1 = -96						; size = 4
$T2 = -92						; size = 4
$T3 = -88						; size = 4
$T4 = -84						; size = 4
_it$5 = -16						; size = 4
_it$6 = -12						; size = 4
_bError$ = -8						; size = 4
_this$ = -4						; size = 4
?Init@CResetSystem@@QAEXXZ PROC				; CResetSystem::Init, COMDAT
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 73   : 	BOOL bError = FALSE;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bError$[ebp], 0

; 74   : 
; 75   : 	LogAddTD("[Reset System] Selected Setting: USE_RESET_SYSTEM -> %d || RESET_SYSTEM_TYPE -> %d || USE_RESET_CMD -> %d", this->m_bUseResetSystem, this->m_bResetSystemType, this->m_bUseResetCommand);

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00019	51		 push	 ecx
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00020	50		 push	 eax
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00027	52		 push	 edx
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0GK@PNLFBAGA@?$FLReset?5System?$FN?5Selected?5Setting@
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00033	83 c4 10	 add	 esp, 16			; 00000010H

; 76   : 
; 77   : 	if(this->m_bResetSystemType == 1)

  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	83 78 24 01	 cmp	 DWORD PTR [eax+36], 1
  0003d	0f 85 af 01 00
	00		 jne	 $LN8@Init

; 78   : 	{
; 79   : 		if(this->m_vtTableReset.empty() != false)

  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 44	 add	 ecx, 68			; 00000044H
  00049	e8 00 00 00 00	 call	 ?empty@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QBE_NXZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::empty
  0004e	0f b6 c0	 movzx	 eax, al
  00051	85 c0		 test	 eax, eax
  00053	74 1f		 je	 SHORT $LN10@Init

; 80   : 		{
; 81   : 			LogAddC(2,"[Reset System] CResetSystem::Init() - Table Reset Setting Is Empty (m_vtTableReset is Zero)");

  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@JPHLMJOB@?$FLReset?5System?$FN?5CResetSystem?3?3In@
  0005a	6a 02		 push	 2
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00062	83 c4 08	 add	 esp, 8

; 82   : 			this->m_bHasData = FALSE;

  00065	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00068	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 83   : 			return;

  0006f	e9 57 03 00 00	 jmp	 $LN1@Init
$LN10@Init:

; 84   : 		}
; 85   : 
; 86   : 		for ( std::vector<TABLE_RESET>::iterator it = this->m_vtTableReset.begin() ; it != this->m_vtTableReset.end() ; it++ )

  00074	8d 45 f4	 lea	 eax, DWORD PTR _it$6[ebp]
  00077	50		 push	 eax
  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	83 c1 44	 add	 ecx, 68			; 00000044H
  0007e	e8 00 00 00 00	 call	 ?begin@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@2@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::begin
  00083	eb 0e		 jmp	 SHORT $LN4@Init
$LN2@Init:
  00085	6a 00		 push	 0
  00087	8d 45 ac	 lea	 eax, DWORD PTR $T4[ebp]
  0008a	50		 push	 eax
  0008b	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  0008e	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator++
$LN4@Init:
  00093	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  00096	50		 push	 eax
  00097	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	83 c1 44	 add	 ecx, 68			; 00000044H
  0009d	e8 00 00 00 00	 call	 ?end@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@2@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::end
  000a2	50		 push	 eax
  000a3	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  000a6	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator!=
  000ab	0f b6 c8	 movzx	 ecx, al
  000ae	85 c9		 test	 ecx, ecx
  000b0	0f 84 22 01 00
	00		 je	 $LN3@Init

; 87   : 		{
; 88   : 			if((*(it)).m_bReqSpecialItem == TRUE && this->m_vtReqSpecialItem.size() <= 0)

  000b6	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  000b9	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  000be	83 78 1c 01	 cmp	 DWORD PTR [eax+28], 1
  000c2	75 26		 jne	 SHORT $LN11@Init
  000c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	83 c1 50	 add	 ecx, 80			; 00000050H
  000ca	e8 00 00 00 00	 call	 ?size@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::size
  000cf	85 c0		 test	 eax, eax
  000d1	77 17		 ja	 SHORT $LN11@Init

; 89   : 			{
; 90   : 				LogAddC(2,"[Reset System] CResetSystem::Init() - Require Special Item Is Empty (m_vtReqSpecialItem is Zero)");

  000d3	68 00 00 00 00	 push	 OFFSET ??_C@_0GB@ODDJKOIG@?$FLReset?5System?$FN?5CResetSystem?3?3In@
  000d8	6a 02		 push	 2
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  000e0	83 c4 08	 add	 esp, 8

; 91   : 				bError = TRUE;

  000e3	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bError$[ebp], 1
$LN11@Init:

; 92   : 			}
; 93   : 
; 94   : 			if((*(it)).m_bBornPlace == TRUE && this->m_vtBornPlace.size() <= 0)

  000ea	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  000ed	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  000f2	83 78 20 01	 cmp	 DWORD PTR [eax+32], 1
  000f6	75 26		 jne	 SHORT $LN12@Init
  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fb	83 c1 5c	 add	 ecx, 92			; 0000005cH
  000fe	e8 00 00 00 00	 call	 ?size@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::size
  00103	85 c0		 test	 eax, eax
  00105	77 17		 ja	 SHORT $LN12@Init

; 95   : 			{
; 96   : 				LogAddC(2,"[Reset System] CResetSystem::Init() - Born Place Is Empty (m_vtBornPlace is Zero)");

  00107	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@DFADEEFM@?$FLReset?5System?$FN?5CResetSystem?3?3In@
  0010c	6a 02		 push	 2
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00114	83 c4 08	 add	 esp, 8

; 97   : 				bError = TRUE;

  00117	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bError$[ebp], 1
$LN12@Init:

; 98   : 			}
; 99   : 
; 100  : 			LogAddTD("[Reset System] R_IDX: %d, C_TYPE: %d, MIN_LVL: %d, MAX_LVL: %d, CLR_STAT: %d, LVL_AFTER: %d, POINT: %d, RQ_ITEM: %d, B_PLACE: %d, RST_NUM: %d,CLR_BUFF: %d, VIP: %d, CHK_INVENT: %d, CLR_MAGIC_LIST: %d",

  0011e	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  00121	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  00126	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00129	50		 push	 eax
  0012a	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  0012d	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  00132	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00135	51		 push	 ecx
  00136	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  00139	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  0013e	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00141	52		 push	 edx
  00142	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  00145	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  0014a	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  0014d	50		 push	 eax
  0014e	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  00151	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  00156	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00159	51		 push	 ecx
  0015a	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  0015d	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  00162	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  00165	52		 push	 edx
  00166	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  00169	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  0016e	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00171	50		 push	 eax
  00172	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  00175	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  0017a	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0017d	51		 push	 ecx
  0017e	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  00181	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  00186	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00189	52		 push	 edx
  0018a	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  0018d	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  00192	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00195	50		 push	 eax
  00196	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  00199	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  0019e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001a1	51		 push	 ecx
  001a2	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  001a5	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  001aa	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001ad	52		 push	 edx
  001ae	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  001b1	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  001b6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b9	50		 push	 eax
  001ba	8d 4d f4	 lea	 ecx, DWORD PTR _it$6[ebp]
  001bd	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTABLE_RESET@@@std@@@std@@@std@@QBEAAUTABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<TABLE_RESET> > >::operator*
  001c2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c4	51		 push	 ecx
  001c5	68 00 00 00 00	 push	 OFFSET ??_C@_0MI@IGIKPDAC@?$FLReset?5System?$FN?5R_IDX?3?5?$CFd?0?5C_TYP@
  001ca	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  001d0	83 c4 3c	 add	 esp, 60			; 0000003cH

; 101  : 				(*(it)).m_iRuleIndex, (*(it)).m_iCharClassType, (*(it)).m_iMinLevel, (*(it)).m_iMaxLevel, (*(it)).m_bClearStat, (*(it)).m_iLevelAfterReset, (*(it)).m_iLevelUpPoint, (*(it)).m_bReqSpecialItem, (*(it)).m_bBornPlace, (*(it)).m_iResetNumber, (*(it)).m_bClearBuffState, (*(it)).m_iVipCode, (*(it)).m_iCheckInventory, (*(it)).m_bClearMagicList);
; 102  : 		}

  001d3	e9 ad fe ff ff	 jmp	 $LN2@Init
$LN3@Init:

; 103  : 
; 104  : 		if(bError == TRUE)

  001d8	83 7d f8 01	 cmp	 DWORD PTR _bError$[ebp], 1
  001dc	75 0f		 jne	 SHORT $LN13@Init

; 105  : 		{
; 106  : 			this->m_bHasData = FALSE;

  001de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001e1	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 107  : 			return;

  001e8	e9 de 01 00 00	 jmp	 $LN1@Init
$LN13@Init:

; 108  : 		}
; 109  : 	}

  001ed	e9 9b 01 00 00	 jmp	 $LN9@Init
$LN8@Init:

; 110  : 	else
; 111  : 	{
; 112  : 		if(this->m_vtNonTableReset.empty() != false)

  001f2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f5	83 c1 38	 add	 ecx, 56			; 00000038H
  001f8	e8 00 00 00 00	 call	 ?empty@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QBE_NXZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::empty
  001fd	0f b6 c0	 movzx	 eax, al
  00200	85 c0		 test	 eax, eax
  00202	74 1f		 je	 SHORT $LN14@Init

; 113  : 		{
; 114  : 			LogAddC(2,"[Reset System] CResetSystem::Init() - Non Table Reset Setting Is Empty (m_vtNonTableReset is Zero)");

  00204	68 00 00 00 00	 push	 OFFSET ??_C@_0GD@CDCOMDIE@?$FLReset?5System?$FN?5CResetSystem?3?3In@
  00209	6a 02		 push	 2
  0020b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00211	83 c4 08	 add	 esp, 8

; 115  : 			this->m_bHasData = FALSE;

  00214	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00217	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 116  : 			return;

  0021e	e9 a8 01 00 00	 jmp	 $LN1@Init
$LN14@Init:

; 117  : 		}
; 118  : 
; 119  : 		for ( std::vector<NON_TABLE_RESET>::iterator it = this->m_vtNonTableReset.begin() ; it != this->m_vtNonTableReset.end() ; it++ )

  00223	8d 45 f0	 lea	 eax, DWORD PTR _it$5[ebp]
  00226	50		 push	 eax
  00227	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0022a	83 c1 38	 add	 ecx, 56			; 00000038H
  0022d	e8 00 00 00 00	 call	 ?begin@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@2@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::begin
  00232	eb 0e		 jmp	 SHORT $LN7@Init
$LN5@Init:
  00234	6a 00		 push	 0
  00236	8d 45 a4	 lea	 eax, DWORD PTR $T2[ebp]
  00239	50		 push	 eax
  0023a	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  0023d	e8 00 00 00 00	 call	 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator++
$LN7@Init:
  00242	8d 45 a0	 lea	 eax, DWORD PTR $T1[ebp]
  00245	50		 push	 eax
  00246	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00249	83 c1 38	 add	 ecx, 56			; 00000038H
  0024c	e8 00 00 00 00	 call	 ?end@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@2@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::end
  00251	50		 push	 eax
  00252	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  00255	e8 00 00 00 00	 call	 ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator!=
  0025a	0f b6 c8	 movzx	 ecx, al
  0025d	85 c9		 test	 ecx, ecx
  0025f	0f 84 16 01 00
	00		 je	 $LN6@Init

; 120  : 		{
; 121  : 			if((*(it)).m_bReqSpecialItem == TRUE && this->m_vtReqSpecialItem.size() <= 0)

  00265	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  00268	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  0026d	83 78 1c 01	 cmp	 DWORD PTR [eax+28], 1
  00271	75 26		 jne	 SHORT $LN15@Init
  00273	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00276	83 c1 50	 add	 ecx, 80			; 00000050H
  00279	e8 00 00 00 00	 call	 ?size@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QBEIXZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::size
  0027e	85 c0		 test	 eax, eax
  00280	77 17		 ja	 SHORT $LN15@Init

; 122  : 			{
; 123  : 				LogAddC(2,"[Reset System] CResetSystem::Init() - Require Special Item Is Empty (m_vtReqSpecialItem is Zero)");

  00282	68 00 00 00 00	 push	 OFFSET ??_C@_0GB@ODDJKOIG@?$FLReset?5System?$FN?5CResetSystem?3?3In@
  00287	6a 02		 push	 2
  00289	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0028f	83 c4 08	 add	 esp, 8

; 124  : 				bError = TRUE;

  00292	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bError$[ebp], 1
$LN15@Init:

; 125  : 			}
; 126  : 
; 127  : 			if((*(it)).m_bBornPlace == TRUE && this->m_vtBornPlace.size() <= 0)

  00299	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  0029c	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  002a1	83 78 20 01	 cmp	 DWORD PTR [eax+32], 1
  002a5	75 26		 jne	 SHORT $LN16@Init
  002a7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002aa	83 c1 5c	 add	 ecx, 92			; 0000005cH
  002ad	e8 00 00 00 00	 call	 ?size@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QBEIXZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::size
  002b2	85 c0		 test	 eax, eax
  002b4	77 17		 ja	 SHORT $LN16@Init

; 128  : 			{
; 129  : 				LogAddC(2,"[Reset System] CResetSystem::Init() - Born Place Is Empty (m_vtBornPlace is Zero)");

  002b6	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@DFADEEFM@?$FLReset?5System?$FN?5CResetSystem?3?3In@
  002bb	6a 02		 push	 2
  002bd	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  002c3	83 c4 08	 add	 esp, 8

; 130  : 				bError = TRUE;

  002c6	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bError$[ebp], 1
$LN16@Init:

; 131  : 			}
; 132  : 
; 133  : 			LogAddTD("[Reset System] R_IDX: %d, C_TYPE: %d, MIN_LVL: %d, MAX_LVL: %d, CLR_STAT: %d, LVL_AFTER: %d, POINT: %d, RQ_ITEM: %d, B_PLACE: %d, CLR_BUFF: %d, VIP: %d, CHK_INVENT: %d, CLR_MAGIC_LIST: %d",

  002cd	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  002d0	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  002d5	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  002d8	50		 push	 eax
  002d9	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  002dc	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  002e1	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  002e4	51		 push	 ecx
  002e5	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  002e8	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  002ed	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  002f0	52		 push	 edx
  002f1	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  002f4	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  002f9	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  002fc	50		 push	 eax
  002fd	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  00300	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  00305	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00308	51		 push	 ecx
  00309	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  0030c	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  00311	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00314	52		 push	 edx
  00315	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  00318	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  0031d	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00320	50		 push	 eax
  00321	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  00324	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  00329	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0032c	51		 push	 ecx
  0032d	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  00330	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  00335	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00338	52		 push	 edx
  00339	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  0033c	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  00341	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00344	50		 push	 eax
  00345	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  00348	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  0034d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00350	51		 push	 ecx
  00351	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  00354	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  00359	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0035c	52		 push	 edx
  0035d	8d 4d f0	 lea	 ecx, DWORD PTR _it$5[ebp]
  00360	e8 00 00 00 00	 call	 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UNON_TABLE_RESET@@@std@@@std@@@std@@QBEAAUNON_TABLE_RESET@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NON_TABLE_RESET> > >::operator*
  00365	8b 00		 mov	 eax, DWORD PTR [eax]
  00367	50		 push	 eax
  00368	68 00 00 00 00	 push	 OFFSET ??_C@_0LM@LANKAEMK@?$FLReset?5System?$FN?5R_IDX?3?5?$CFd?0?5C_TYP@
  0036d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00373	83 c4 38	 add	 esp, 56			; 00000038H

; 134  : 				(*(it)).m_iRuleIndex, (*(it)).m_iCharClassType, (*(it)).m_iMinLevel, (*(it)).m_iMaxLevel, (*(it)).m_bClearStat, (*(it)).m_iLevelAfterReset, (*(it)).m_iLevelUpPoint, (*(it)).m_bReqSpecialItem, (*(it)).m_bBornPlace, (*(it)).m_bClearBuffState, (*(it)).m_iVipCode, (*(it)).m_iCheckInventory, (*(it)).m_bClearMagicList);
; 135  : 		}

  00376	e9 b9 fe ff ff	 jmp	 $LN5@Init
$LN6@Init:

; 136  : 
; 137  : 		if(bError == TRUE)

  0037b	83 7d f8 01	 cmp	 DWORD PTR _bError$[ebp], 1
  0037f	75 0c		 jne	 SHORT $LN9@Init

; 138  : 		{
; 139  : 			this->m_bHasData = FALSE;

  00381	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00384	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 140  : 			return;

  0038b	eb 3e		 jmp	 SHORT $LN1@Init
$LN9@Init:

; 141  : 		}
; 142  : 	}
; 143  : 
; 144  : 	if(this->m_bUseResetCommand == 0 && this->m_mNpcData.size() == 0)

  0038d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00390	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00394	75 2b		 jne	 SHORT $LN18@Init
  00396	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00399	83 c1 68	 add	 ecx, 104		; 00000068H
  0039c	e8 00 00 00 00	 call	 ?size@?$_Tree@V?$_Tmap_traits@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> >,0> >::size
  003a1	85 c0		 test	 eax, eax
  003a3	75 1c		 jne	 SHORT $LN18@Init

; 145  : 	{
; 146  : 		LogAddC(2,"[Reset System] CResetSystem::Init() - Reset Command is Disable and NPC Setting is empty (m_mNpcData is Zero)");

  003a5	68 00 00 00 00	 push	 OFFSET ??_C@_0GN@HPBNHHNI@?$FLReset?5System?$FN?5CResetSystem?3?3In@
  003aa	6a 02		 push	 2
  003ac	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  003b2	83 c4 08	 add	 esp, 8

; 147  : 		this->m_bHasData = FALSE;

  003b5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003b8	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 148  : 		return;

  003bf	eb 0a		 jmp	 SHORT $LN1@Init
$LN18@Init:

; 149  : 	}
; 150  : 
; 151  : 	this->m_bHasData = TRUE;

  003c1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003c4	c7 40 1c 01 00
	00 00		 mov	 DWORD PTR [eax+28], 1
$LN1@Init:

; 152  : }

  003cb	5f		 pop	 edi
  003cc	5e		 pop	 esi
  003cd	5b		 pop	 ebx
  003ce	8b e5		 mov	 esp, ebp
  003d0	5d		 pop	 ebp
  003d1	c3		 ret	 0
?Init@CResetSystem@@QAEXXZ ENDP				; CResetSystem::Init
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?Clear@CResetSystem@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?Clear@CResetSystem@@QAEXXZ PROC			; CResetSystem::Clear, COMDAT
; _this$ = ecx

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 	this->m_vtNonTableReset.clear();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 38	 add	 ecx, 56			; 00000038H
  00012	e8 00 00 00 00	 call	 ?clear@?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAEXXZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::clear

; 60   : 	this->m_vtTableReset.clear();

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	83 c1 44	 add	 ecx, 68			; 00000044H
  0001d	e8 00 00 00 00	 call	 ?clear@?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAEXXZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::clear

; 61   : 	this->m_vtReqSpecialItem.clear();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 50	 add	 ecx, 80			; 00000050H
  00028	e8 00 00 00 00	 call	 ?clear@?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAEXXZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::clear

; 62   : 	this->m_vtBornPlace.clear();

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00033	e8 00 00 00 00	 call	 ?clear@?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAEXXZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::clear

; 63   : 	this->ClearResetNPCData();

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?ClearResetNPCData@CResetSystem@@QAEXXZ ; CResetSystem::ClearResetNPCData

; 64   : 
; 65   : 	for(int i= 0; i < MAX_MESSAGE; i++) //Clear Messages

  00040	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00047	eb 09		 jmp	 SHORT $LN4@Clear
$LN2@Clear:
  00049	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0004c	83 c0 01	 add	 eax, 1
  0004f	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Clear:
  00052	83 7d f8 05	 cmp	 DWORD PTR _i$1[ebp], 5
  00056	7d 10		 jge	 SHORT $LN1@Clear

; 66   : 	{
; 67   : 		this->lpMessage[i] = NULL;

  00058	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	c7 44 81 70 00
	00 00 00	 mov	 DWORD PTR [ecx+eax*4+112], 0

; 68   : 	}

  00066	eb e1		 jmp	 SHORT $LN2@Clear
$LN1@Clear:

; 69   : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?Clear@CResetSystem@@QAEXXZ ENDP			; CResetSystem::Clear
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ??1CResetSystem@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CResetSystem@@UAE@XZ PROC				; CResetSystem::~CResetSystem, COMDAT
; _this$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CResetSystem@@6B@

; 54   : 	//DeleteCriticalSection(&this->m_cs);
; 55   : }

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 68	 add	 ecx, 104		; 00000068H
  0001b	e8 00 00 00 00	 call	 ??1?$map@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@@std@@QAE@XZ
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00026	e8 00 00 00 00	 call	 ??1?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::~vector<BORN_PLACE,std::allocator<BORN_PLACE> >
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	83 c1 50	 add	 ecx, 80			; 00000050H
  00031	e8 00 00 00 00	 call	 ??1?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::~vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 c1 44	 add	 ecx, 68			; 00000044H
  0003c	e8 00 00 00 00	 call	 ??1?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::~vector<TABLE_RESET,std::allocator<TABLE_RESET> >
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	83 c1 38	 add	 ecx, 56			; 00000038H
  00047	e8 00 00 00 00	 call	 ??1?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::~vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
??1CResetSystem@@UAE@XZ ENDP				; CResetSystem::~CResetSystem
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ??0CResetSystem@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CResetSystem@@QAE@XZ PROC				; CResetSystem::CResetSystem, COMDAT
; _this$ = ecx

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CResetSystem@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CResetSystem@@6B@
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 38	 add	 ecx, 56			; 00000038H
  0003a	e8 00 00 00 00	 call	 ??0?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 44	 add	 ecx, 68			; 00000044H
  0004c	e8 00 00 00 00	 call	 ??0?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::vector<TABLE_RESET,std::allocator<TABLE_RESET> >
  00051	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00055	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	83 c1 50	 add	 ecx, 80			; 00000050H
  0005b	e8 00 00 00 00	 call	 ??0?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >
  00060	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00064	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	83 c1 5c	 add	 ecx, 92			; 0000005cH
  0006a	e8 00 00 00 00	 call	 ??0?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::vector<BORN_PLACE,std::allocator<BORN_PLACE> >
  0006f	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00073	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	83 c1 68	 add	 ecx, 104		; 00000068H
  00079	e8 00 00 00 00	 call	 ??0?$map@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@@std@@QAE@XZ ; std::map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >::map<int,NPC_DATA,std::less<int>,std::allocator<std::pair<int const ,NPC_DATA> > >
  0007e	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 44   : 	this->m_bHasData = FALSE;

  00082	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00085	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 45   : 	this->m_bUseResetSystem = FALSE;

  0008c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 46   : 	this->m_bResetSystemType = 0;

  00096	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00099	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 47   : 	this->Clear();

  000a0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	e8 00 00 00 00	 call	 ?Clear@CResetSystem@@QAEXXZ ; CResetSystem::Clear

; 48   : 
; 49   : 	//InitializeCriticalSection(&this->m_cs);
; 50   : }

  000a8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000af	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CResetSystem@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 38	 add	 ecx, 56			; 00000038H
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@UNON_TABLE_RESET@@V?$allocator@UNON_TABLE_RESET@@@std@@@std@@QAE@XZ ; std::vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >::~vector<NON_TABLE_RESET,std::allocator<NON_TABLE_RESET> >
__unwindfunclet$??0CResetSystem@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 44	 add	 ecx, 68			; 00000044H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@UTABLE_RESET@@V?$allocator@UTABLE_RESET@@@std@@@std@@QAE@XZ ; std::vector<TABLE_RESET,std::allocator<TABLE_RESET> >::~vector<TABLE_RESET,std::allocator<TABLE_RESET> >
__unwindfunclet$??0CResetSystem@@QAE@XZ$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 50	 add	 ecx, 80			; 00000050H
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@UREQUIRE_SPECIAL_ITEM@@V?$allocator@UREQUIRE_SPECIAL_ITEM@@@std@@@std@@QAE@XZ ; std::vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >::~vector<REQUIRE_SPECIAL_ITEM,std::allocator<REQUIRE_SPECIAL_ITEM> >
__unwindfunclet$??0CResetSystem@@QAE@XZ$3:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@UBORN_PLACE@@V?$allocator@UBORN_PLACE@@@std@@@std@@QAE@XZ ; std::vector<BORN_PLACE,std::allocator<BORN_PLACE> >::~vector<BORN_PLACE,std::allocator<BORN_PLACE> >
__unwindfunclet$??0CResetSystem@@QAE@XZ$4:
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 68	 add	 ecx, 104		; 00000068H
  00032	e9 00 00 00 00	 jmp	 ??1?$map@HUNPC_DATA@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHUNPC_DATA@@@std@@@3@@std@@QAE@XZ
  00037	cc		 int	 3
  00038	cc		 int	 3
  00039	cc		 int	 3
  0003a	cc		 int	 3
  0003b	cc		 int	 3
__ehhandler$??0CResetSystem@@QAE@XZ:
  0003c	90		 npad	 1
  0003d	90		 npad	 1
  0003e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00042	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00045	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00048	33 c8		 xor	 ecx, eax
  0004a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CResetSystem@@QAE@XZ
  00054	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CResetSystem@@QAE@XZ ENDP				; CResetSystem::CResetSystem
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xstddef
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
tv65 = -72						; size = 4
_this$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 126  :     constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  :         return _Left < _Right;

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00016	7d 09		 jge	 SHORT $LN3@operator
  00018	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  0001f	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00021	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
$LN4@operator:
  00028	8a 45 b8	 mov	 al, BYTE PTR tv65[ebp]

; 128  :     }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Include\ProDef.h
;	COMDAT ?set@PBMSG_HEAD@@QAEXPAEEE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpBuf$ = 8						; size = 4
_head$ = 12						; size = 1
_size$ = 16						; size = 1
?set@PBMSG_HEAD@@QAEXPAEEE@Z PROC			; PBMSG_HEAD::set, COMDAT
; _this$ = ecx

; 25   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 26   : 		lpBuf[0] = PMHC_BYTE;

  0000c	b8 01 00 00 00	 mov	 eax, 1
  00011	6b c8 00	 imul	 ecx, eax, 0
  00014	8b 55 08	 mov	 edx, DWORD PTR _lpBuf$[ebp]
  00017	c6 04 0a c1	 mov	 BYTE PTR [edx+ecx], 193	; 000000c1H

; 27   : 		lpBuf[1] = size;

  0001b	b8 01 00 00 00	 mov	 eax, 1
  00020	c1 e0 00	 shl	 eax, 0
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]
  00026	8a 55 10	 mov	 dl, BYTE PTR _size$[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 28   : 		lpBuf[2] = head;

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	d1 e0		 shl	 eax, 1
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _lpBuf$[ebp]
  00036	8a 55 0c	 mov	 dl, BYTE PTR _head$[ebp]
  00039	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 29   : 	}

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
?set@PBMSG_HEAD@@QAEXPAEEE@Z ENDP			; PBMSG_HEAD::set
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xtree
;	COMDAT ?_Throw_tree_length_error@std@@YAXXZ
_TEXT	SEGMENT
?_Throw_tree_length_error@std@@YAXXZ PROC		; std::_Throw_tree_length_error, COMDAT

; 414  : [[noreturn]] inline void _Throw_tree_length_error() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 415  :     _Xlength_error("map/set too long");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
  0000e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Throw_tree:

; 416  : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Throw_tree_length_error@std@@YAXXZ ENDP		; std::_Throw_tree_length_error
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ PROC		; std::_Fake_proxy_ptr_impl::_Release, COMDAT
; _this$ = ecx

; 1259 :     void _Release() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ENDP		; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT
; _this$ = ecx

; 1256 :     _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ PROC ; std::_Iterator_base0::_Getcont, COMDAT
; _this$ = ecx

; 1073 :     const _Container_base0* _Getcont() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1074 :         return nullptr;

  0000c	33 c0		 xor	 eax, eax

; 1075 :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ENDP ; std::_Iterator_base0::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 1072 :     void _Adopt(const void*) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT
; _this$ = ecx

; 1067 :     void _Alloc_proxy(const _Fake_allocator&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 1065 :     void _Orphan_all() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -16					; size = 4
__Min_back_shift$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Ptr_user$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	83 c1 23	 add	 ecx, 35			; 00000023H
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00014	89 0a		 mov	 DWORD PTR [edx], ecx

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00016	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	89 4d fc	 mov	 DWORD PTR __Ptr_user$[ebp], ecx

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001e	b8 04 00 00 00	 mov	 eax, 4
  00023	6b c8 ff	 imul	 ecx, eax, -1
  00026	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  00029	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0002c	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002f	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00036	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	2b 4d f8	 sub	 ecx, DWORD PTR __Ptr_container$[ebp]
  0003e	89 4d f0	 mov	 DWORD PTR __Back_shift$[ebp], ecx
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00041	83 7d f0 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00045	72 08		 jb	 SHORT $LN7@Adjust_man
  00047	83 7d f0 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  0004b	77 02		 ja	 SHORT $LN7@Adjust_man
  0004d	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00054	33 c0		 xor	 eax, eax
  00056	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00058	33 c0		 xor	 eax, eax
  0005a	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  00062	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 76   :     __declspec(allocator) static void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 77   :         return ::operator new(_Bytes);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00012	83 c4 04	 add	 esp, 4

; 78   :     }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 554  :     _NODISCARD static constexpr int(max)() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 555  :         return INT_MAX;

  00009	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 556  :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -76						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 321  :     _THROW(bad_array_new_length{});

  00009	8d 4d b4	 lea	 ecx, DWORD PTR $T1[ebp]
  0000c	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  00011	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00016	8d 45 b4	 lea	 eax, DWORD PTR $T1[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UAE@XZ
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@ABV01@@Z
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 140  :         : bad_alloc("bad array new length")

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AAE@QBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 130  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 129  :         : exception(_Message, 1)

  0000c	6a 01		 push	 1
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception

; 130  :     {

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 131  :     }

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 0c		 push	 12			; 0000000cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -72						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00013	74 0b		 je	 SHORT $LN3@what
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001b	89 55 b8	 mov	 DWORD PTR tv69[ebp], edx
  0001e	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  00020	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00027	8b 45 b8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 89   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ___std_exception_destroy
  00021	83 c4 04	 add	 esp, 4

; 91   :     }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00015	33 c0		 xor	 eax, eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	83 c1 04	 add	 ecx, 4
  0001d	89 01		 mov	 DWORD PTR [ecx], eax
  0001f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 c0 04	 add	 eax, 4
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  0002c	83 c1 04	 add	 ecx, 4
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ___std_exception_copy
  00035	83 c4 08	 add	 esp, 8

; 74   :     }

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00015	33 c0		 xor	 eax, eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	83 c1 04	 add	 ecx, 4
  0001d	89 01		 mov	 DWORD PTR [ecx], eax
  0001f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00028	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 68   :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1792 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1793 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1459 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1460 :         #pragma warning(push)
; 1461 :         #pragma warning(disable: 4996) // Deprecation
; 1462 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1463 :         #pragma warning(pop)
; 1464 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1389 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00031	83 c4 1c	 add	 esp, 28			; 0000001cH
  00034	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00037	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003b	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003d	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00049	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004c	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1395 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 167  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 168  :         (void)_Size;
; 169  :         return _Where;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 170  :     }

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ResetSystem.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
