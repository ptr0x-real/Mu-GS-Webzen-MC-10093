; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ObjBaseAttack.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0CObjBaseAttack@@QAE@XZ			; CObjBaseAttack::CObjBaseAttack
PUBLIC	??1CObjBaseAttack@@UAE@XZ			; CObjBaseAttack::~CObjBaseAttack
PUBLIC	?DecreaseArrow@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@@Z ; CObjBaseAttack::DecreaseArrow
PUBLIC	?CheckAttackArea@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0@Z ; CObjBaseAttack::CheckAttackArea
PUBLIC	?PkCheck@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0@Z ; CObjBaseAttack::PkCheck
PUBLIC	?ResistanceCheck@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0H@Z ; CObjBaseAttack::ResistanceCheck
PUBLIC	?MissCheck@CObjBaseAttack@@UAEHPAVOBJECTSTRUCT@@0HHHAAH@Z ; CObjBaseAttack::MissCheck
PUBLIC	?GetTargetDefense@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0AAE@Z ; CObjBaseAttack::GetTargetDefense
PUBLIC	?GetPartyMemberCount@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@@Z ; CObjBaseAttack::GetPartyMemberCount
PUBLIC	??_GCObjBaseAttack@@UAEPAXI@Z			; CObjBaseAttack::`scalar deleting destructor'
PUBLIC	??_7CObjBaseAttack@@6B@				; CObjBaseAttack::`vftable'
PUBLIC	??_C@_0EB@NNCLBAOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Atta@ ; `string'
PUBLIC	?__LINE__Var@?0??GetPartyMemberCount@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@@Z@4JA ; `CObjBaseAttack::GetPartyMemberCount'::`1'::__LINE__Var
PUBLIC	??_C@_0EA@KHFDDLEK@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ ; `string'
PUBLIC	??_C@_0CE@CEJHKGA@error?5?3?5DecPartyMemberHPandMP?5?$CF@ ; `string'
PUBLIC	??_R4CObjBaseAttack@@6B@			; CObjBaseAttack::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCObjBaseAttack@@@8			; CObjBaseAttack `RTTI Type Descriptor'
PUBLIC	??_R3CObjBaseAttack@@8				; CObjBaseAttack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObjBaseAttack@@8				; CObjBaseAttack::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CObjBaseAttack@@8			; CObjBaseAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3f800000
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_rand:PROC
EXTRN	__imp_?Get@CMsg@@QAEPADH@Z:PROC
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?IsWingOpGetOnePercentDamage@CItem@@QAEHXZ:PROC	; CItem::IsWingOpGetOnePercentDamage
EXTRN	?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z:PROC ; gObjAddMsgSendDelay
EXTRN	?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z:PROC	; gObjCalDistance
EXTRN	?gObjBackSpring2@@YAHPAVOBJECTSTRUCT@@0H@Z:PROC	; gObjBackSpring2
EXTRN	?gObjCheckAttackArea@@YAHHH@Z:PROC		; gObjCheckAttackArea
EXTRN	?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@@Z:PROC	; gObjDuelCheck
EXTRN	?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@0@Z:PROC	; gObjDuelCheck
EXTRN	?gObjSetPosition@@YAXHHH@Z:PROC			; gObjSetPosition
EXTRN	?gObjTargetGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z:PROC ; gObjTargetGuildWarCheck
EXTRN	?retResistance@@YAHPAVOBJECTSTRUCT@@H@Z:PROC	; retResistance
EXTRN	?GCDamageSend@@YAXHHHHH@Z:PROC			; GCDamageSend
EXTRN	?GCMagicAttackNumberSend@@YAXPAVOBJECTSTRUCT@@EHE@Z:PROC ; GCMagicAttackNumberSend
EXTRN	?GCItemDurSend@@YAXHEEE@Z:PROC			; GCItemDurSend
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?GCStateInfoSend@@YAXPAVOBJECTSTRUCT@@EG@Z:PROC	; GCStateInfoSend
EXTRN	?CheckArrow@CArrowSystem@@QAE_NH@Z:PROC		; CArrowSystem::CheckArrow
EXTRN	?MakeItemNumber@@YAHHH@Z:PROC			; MakeItemNumber
EXTRN	??_ECObjBaseAttack@@UAEPAXI@Z:PROC		; CObjBaseAttack::`vector deleting destructor'
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	?GetCurrentState@CChaosCastle@@QAEHH@Z:PROC	; CChaosCastle::GetCurrentState
EXTRN	__except_handler4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObj@@3PAVOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?g_GlobalConfig@@3VCGlobalConfig@@A:BYTE	; g_GlobalConfig
EXTRN	?g_ArrowSystem@@3VCArrowSystem@@A:BYTE		; g_ArrowSystem
EXTRN	?lMsg@@3VCMsg@@A:BYTE				; lMsg
EXTRN	?MapC@@3PAVMapClass@@A:DWORD			; MapC
EXTRN	?gLanguage@@3HA:DWORD				; gLanguage
EXTRN	?gNonPK@@3HA:DWORD				; gNonPK
EXTRN	?gPkLimitFree@@3HA:DWORD			; gPkLimitFree
EXTRN	?bIsIgnorePacketSpeedHackDetect@@3HA:DWORD	; bIsIgnorePacketSpeedHackDetect
EXTRN	?g_ChaosCastle@@3VCChaosCastle@@A:BYTE		; g_ChaosCastle
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?g_iChaosCastle_MonsterItems@@3PAY111HA DD 018H DUP (?)	; g_iChaosCastle_MonsterItems
_BSS	ENDS
CRT$XCU	SEGMENT
?g_iChaosCastle_MonsterItems$initializer$@@3P6AXXZA DD FLAT:??__Eg_iChaosCastle_MonsterItems@@YAXXZ ; g_iChaosCastle_MonsterItems$initializer$
CRT$XCU	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CObjBaseAttack@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CObjBaseAttack@@8 DD FLAT:??_R0?AVCObjBaseAttack@@@8 ; CObjBaseAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObjBaseAttack@@8
rdata$r	ENDS
;	COMDAT ??_R2CObjBaseAttack@@8
rdata$r	SEGMENT
??_R2CObjBaseAttack@@8 DD FLAT:??_R1A@?0A@EA@CObjBaseAttack@@8 ; CObjBaseAttack::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObjBaseAttack@@8
rdata$r	SEGMENT
??_R3CObjBaseAttack@@8 DD 00H				; CObjBaseAttack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObjBaseAttack@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObjBaseAttack@@@8
data$r	SEGMENT
??_R0?AVCObjBaseAttack@@@8 DD FLAT:??_7type_info@@6B@	; CObjBaseAttack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObjBaseAttack@@', 00H
data$r	ENDS
;	COMDAT ??_R4CObjBaseAttack@@6B@
rdata$r	SEGMENT
??_R4CObjBaseAttack@@6B@ DD 00H				; CObjBaseAttack::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCObjBaseAttack@@@8
	DD	FLAT:??_R3CObjBaseAttack@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CE@CEJHKGA@error?5?3?5DecPartyMemberHPandMP?5?$CF@
CONST	SEGMENT
??_C@_0CE@CEJHKGA@error?5?3?5DecPartyMemberHPandMP?5?$CF@ DB 'error : Dec'
	DB	'PartyMemberHPandMP %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@KHFDDLEK@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
CONST	SEGMENT
??_C@_0EA@KHFDDLEK@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ DB 'C:\Mu Onl'
	DB	'ine\Mu-GS-Webzen-MC-10093\GameServer\ObjBaseAttack.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetPartyMemberCount@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetPartyMemberCount@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@@Z@4JA DD 0544H ; `CObjBaseAttack::GetPartyMemberCount'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EB@NNCLBAOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Atta@
CONST	SEGMENT
??_C@_0EB@NNCLBAOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Atta@ DB '['
	DB	'%s][%s] Try Attack In Not Attack Area (%s,%d,%d) errortype = '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_7CObjBaseAttack@@6B@
CONST	SEGMENT
??_7CObjBaseAttack@@6B@ DD FLAT:??_R4CObjBaseAttack@@6B@ ; CObjBaseAttack::`vftable'
	DD	FLAT:??_ECObjBaseAttack@@UAEPAXI@Z
	DD	FLAT:?MissCheck@CObjBaseAttack@@UAEHPAVOBJECTSTRUCT@@0HHHAAH@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?MissCheck@CObjBaseAttack@@UAEHPAVOBJECTSTRUCT@@0HHHAAH@Z DD 0fffffffeH
	DD	00H
	DD	0ffffff80H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN22@MissCheck
	DD	FLAT:$LN18@MissCheck
xdata$x	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ChaosCastle.h
;	COMDAT ??__Eg_iChaosCastle_MonsterItems@@YAXXZ
text$di	SEGMENT
??__Eg_iChaosCastle_MonsterItems@@YAXXZ PROC		; `dynamic initializer for 'g_iChaosCastle_MonsterItems'', COMDAT

; 359  : };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 337  : 	MAKE_ITEMNUM(14, 13),		1,								// 1번 캐슬 - 축석

  00009	6a 0d		 push	 13			; 0000000dH
  0000b	6a 0e		 push	 14			; 0000000eH
  0000d	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00012	83 c4 08	 add	 esp, 8
  00015	a3 00 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA, eax
  0001a	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+4, 1

; 338  : 	MAKE_ITEMNUM(14, 14),		2,								// 1번 캐슬 - 영석

  00024	6a 0e		 push	 14			; 0000000eH
  00026	6a 0e		 push	 14			; 0000000eH
  00028	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0002d	83 c4 08	 add	 esp, 8
  00030	a3 08 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+8, eax
  00035	c7 05 0c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+12, 2

; 339  : 	
; 340  : 	MAKE_ITEMNUM(14, 13),		1,								// 2번 캐슬 - 축석

  0003f	6a 0d		 push	 13			; 0000000dH
  00041	6a 0e		 push	 14			; 0000000eH
  00043	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00048	83 c4 08	 add	 esp, 8
  0004b	a3 10 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+16, eax
  00050	c7 05 14 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+20, 1

; 341  : 	MAKE_ITEMNUM(14, 14),		3,								// 2번 캐슬 - 영석

  0005a	6a 0e		 push	 14			; 0000000eH
  0005c	6a 0e		 push	 14			; 0000000eH
  0005e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00063	83 c4 08	 add	 esp, 8
  00066	a3 18 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+24, eax
  0006b	c7 05 1c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+28, 3

; 342  : 	
; 343  : 	MAKE_ITEMNUM(14, 13),		1,								// 3번 캐슬 - 축석

  00075	6a 0d		 push	 13			; 0000000dH
  00077	6a 0e		 push	 14			; 0000000eH
  00079	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0007e	83 c4 08	 add	 esp, 8
  00081	a3 20 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+32, eax
  00086	c7 05 24 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+36, 1

; 344  : 	MAKE_ITEMNUM(14, 14),		3,								// 3번 캐슬 - 영석

  00090	6a 0e		 push	 14			; 0000000eH
  00092	6a 0e		 push	 14			; 0000000eH
  00094	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00099	83 c4 08	 add	 esp, 8
  0009c	a3 28 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+40, eax
  000a1	c7 05 2c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+44, 3

; 345  : 	
; 346  : 	MAKE_ITEMNUM(14, 13),		2,								// 4번 캐슬 - 축석

  000ab	6a 0d		 push	 13			; 0000000dH
  000ad	6a 0e		 push	 14			; 0000000eH
  000af	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000b4	83 c4 08	 add	 esp, 8
  000b7	a3 30 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+48, eax
  000bc	c7 05 34 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+52, 2

; 347  : 	MAKE_ITEMNUM(14, 14),		2,								// 4번 캐슬 - 영석

  000c6	6a 0e		 push	 14			; 0000000eH
  000c8	6a 0e		 push	 14			; 0000000eH
  000ca	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000cf	83 c4 08	 add	 esp, 8
  000d2	a3 38 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+56, eax
  000d7	c7 05 3c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+60, 2

; 348  : 	
; 349  : 	MAKE_ITEMNUM(14, 13),		2,								// 5번 캐슬 - 축석

  000e1	6a 0d		 push	 13			; 0000000dH
  000e3	6a 0e		 push	 14			; 0000000eH
  000e5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ea	83 c4 08	 add	 esp, 8
  000ed	a3 40 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+64, eax
  000f2	c7 05 44 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+68, 2

; 350  : 	MAKE_ITEMNUM(14, 14),		3,								// 5번 캐슬 - 영석

  000fc	6a 0e		 push	 14			; 0000000eH
  000fe	6a 0e		 push	 14			; 0000000eH
  00100	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00105	83 c4 08	 add	 esp, 8
  00108	a3 48 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+72, eax
  0010d	c7 05 4c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+76, 3

; 351  : 	
; 352  : 	MAKE_ITEMNUM(14, 13),		2,								// 6번 캐슬 - 축석

  00117	6a 0d		 push	 13			; 0000000dH
  00119	6a 0e		 push	 14			; 0000000eH
  0011b	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00120	83 c4 08	 add	 esp, 8
  00123	a3 50 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+80, eax
  00128	c7 05 54 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+84, 2

; 353  : 	MAKE_ITEMNUM(14, 14),		3,								// 6번 캐슬 - 영석

  00132	6a 0e		 push	 14			; 0000000eH
  00134	6a 0e		 push	 14			; 0000000eH
  00136	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0013b	83 c4 08	 add	 esp, 8
  0013e	a3 58 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+88, eax
  00143	c7 05 5c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?g_iChaosCastle_MonsterItems@@3PAY111HA+92, 3
  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
??__Eg_iChaosCastle_MonsterItems@@YAXXZ ENDP		; `dynamic initializer for 'g_iChaosCastle_MonsterItems''
text$di	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCObjBaseAttack@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCObjBaseAttack@@UAEPAXI@Z PROC			; CObjBaseAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CObjBaseAttack@@UAE@XZ ; CObjBaseAttack::~CObjBaseAttack
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 04		 push	 4
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_GCObjBaseAttack@@UAEPAXI@Z ENDP			; CObjBaseAttack::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ObjBaseAttack.cpp
;	COMDAT ?GetPartyMemberCount@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv67 = -104						; size = 4
tv68 = -100						; size = 4
_dis$1 = -32						; size = 4
_number$2 = -28						; size = 4
_n$3 = -24						; size = 4
_retcount$ = -20					; size = 4
_partycount$ = -16					; size = 4
_partynum$ = -12					; size = 4
_lpPartyObj$ = -8					; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?GetPartyMemberCount@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@@Z PROC ; CObjBaseAttack::GetPartyMemberCount, COMDAT
; _this$ = ecx

; 1348 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1349 : 	LPOBJECTSTRUCT lpPartyObj;
; 1350 : 
; 1351 : 	int partynum = lpObj->PartyNumber;

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000f	8b 88 88 02 00
	00		 mov	 ecx, DWORD PTR [eax+648]
  00015	89 4d f4	 mov	 DWORD PTR _partynum$[ebp], ecx

; 1352 : 	
; 1353 : 	if( !CHECK_LIMIT(partynum, MAX_PARTY) )

  00018	83 7d f4 00	 cmp	 DWORD PTR _partynum$[ebp], 0
  0001c	7d 09		 jge	 SHORT $LN12@GetPartyMe
  0001e	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  00025	eb 1f		 jmp	 SHORT $LN13@GetPartyMe
$LN12@GetPartyMe:
  00027	81 7d f4 e7 1c
	00 00		 cmp	 DWORD PTR _partynum$[ebp], 7399 ; 00001ce7H
  0002e	7e 09		 jle	 SHORT $LN10@GetPartyMe
  00030	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
  00037	eb 07		 jmp	 SHORT $LN11@GetPartyMe
$LN10@GetPartyMe:
  00039	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
$LN11@GetPartyMe:
  00040	8b 45 98	 mov	 eax, DWORD PTR tv67[ebp]
  00043	89 45 9c	 mov	 DWORD PTR tv68[ebp], eax
$LN13@GetPartyMe:
  00046	83 7d 9c 00	 cmp	 DWORD PTR tv68[ebp], 0
  0004a	75 23		 jne	 SHORT $LN5@GetPartyMe

; 1354 : 	{
; 1355 : 		LogAdd("error : DecPartyMemberHPandMP %s %d",__FILE__, __LINE__);

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??GetPartyMemberCount@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@@Z@4JA
  00051	83 c0 07	 add	 eax, 7
  00054	50		 push	 eax
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@KHFDDLEK@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@CEJHKGA@error?5?3?5DecPartyMemberHPandMP?5?$CF@
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1356 : 		return 0;

  00068	33 c0		 xor	 eax, eax
  0006a	e9 9c 00 00 00	 jmp	 $LN1@GetPartyMe
$LN5@GetPartyMe:

; 1357 : 	}
; 1358 : 
; 1359 : 	int partycount = gParty.m_PartyS[partynum].Count;

  0006f	6b 45 f4 30	 imul	 eax, DWORD PTR _partynum$[ebp], 48
  00073	8b 88 08 00 00
	00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+8]
  00079	89 4d f0	 mov	 DWORD PTR _partycount$[ebp], ecx

; 1360 : 	int retcount = 0;

  0007c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _retcount$[ebp], 0

; 1361 : 	for( int n=0; n<MAX_PARTYUSER; n++)

  00083	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _n$3[ebp], 0
  0008a	eb 09		 jmp	 SHORT $LN4@GetPartyMe
$LN2@GetPartyMe:
  0008c	8b 45 e8	 mov	 eax, DWORD PTR _n$3[ebp]
  0008f	83 c0 01	 add	 eax, 1
  00092	89 45 e8	 mov	 DWORD PTR _n$3[ebp], eax
$LN4@GetPartyMe:
  00095	83 7d e8 05	 cmp	 DWORD PTR _n$3[ebp], 5
  00099	7d 6d		 jge	 SHORT $LN3@GetPartyMe

; 1362 : 	{
; 1363 : 		int number = gParty.m_PartyS[partynum].Number[n];

  0009b	6b 45 f4 30	 imul	 eax, DWORD PTR _partynum$[ebp], 48
  0009f	8b 4d e8	 mov	 ecx, DWORD PTR _n$3[ebp]
  000a2	8b 94 88 0c 00
	00 00		 mov	 edx, DWORD PTR ?gParty@@3VPartyClass@@A[eax+ecx*4+12]
  000a9	89 55 e4	 mov	 DWORD PTR _number$2[ebp], edx

; 1364 : 		if( number >= 0 )

  000ac	83 7d e4 00	 cmp	 DWORD PTR _number$2[ebp], 0
  000b0	7c 54		 jl	 SHORT $LN6@GetPartyMe

; 1365 : 		{
; 1366 : 			lpPartyObj = (LPOBJECTSTRUCT)&gObj[number];

  000b2	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$2[ebp], 7072
  000b9	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000bf	89 45 f8	 mov	 DWORD PTR _lpPartyObj$[ebp], eax

; 1367 : 			
; 1368 : 			// 같은 맵에 존재하거나..
; 1369 : 			if( lpObj->MapNumber == lpPartyObj->MapNumber) 

  000c2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000c5	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  000cc	8b 55 f8	 mov	 edx, DWORD PTR _lpPartyObj$[ebp]
  000cf	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  000d6	3b c8		 cmp	 ecx, eax
  000d8	75 2c		 jne	 SHORT $LN6@GetPartyMe

; 1370 : 			{
; 1371 : 				int dis = gObjCalDistance(lpObj, &gObj[number]);

  000da	69 45 e4 a0 1b
	00 00		 imul	 eax, DWORD PTR _number$2[ebp], 7072
  000e1	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAVOBJECTSTRUCT@@A ; gObj
  000e7	50		 push	 eax
  000e8	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000eb	51		 push	 ecx
  000ec	e8 00 00 00 00	 call	 ?gObjCalDistance@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjCalDistance
  000f1	83 c4 08	 add	 esp, 8
  000f4	89 45 e0	 mov	 DWORD PTR _dis$1[ebp], eax

; 1372 : 				if( dis < 10 )

  000f7	83 7d e0 0a	 cmp	 DWORD PTR _dis$1[ebp], 10 ; 0000000aH
  000fb	7d 09		 jge	 SHORT $LN6@GetPartyMe

; 1373 : 				{	
; 1374 : 					retcount++;

  000fd	8b 45 ec	 mov	 eax, DWORD PTR _retcount$[ebp]
  00100	83 c0 01	 add	 eax, 1
  00103	89 45 ec	 mov	 DWORD PTR _retcount$[ebp], eax
$LN6@GetPartyMe:

; 1375 : 				}
; 1376 : 			}
; 1377 : 		}
; 1378 : 	}

  00106	eb 84		 jmp	 SHORT $LN2@GetPartyMe
$LN3@GetPartyMe:

; 1379 : 	return retcount;

  00108	8b 45 ec	 mov	 eax, DWORD PTR _retcount$[ebp]
$LN1@GetPartyMe:

; 1380 : }

  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c2 04 00	 ret	 4
?GetPartyMemberCount@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@@Z ENDP ; CObjBaseAttack::GetPartyMemberCount
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ObjBaseAttack.cpp
;	COMDAT ?GetTargetDefense@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0AAE@Z
_TEXT	SEGMENT
_percentdamage$ = -16					; size = 4
_targetdefense$ = -12					; size = 4
_skilldefense$ = -8					; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_MsgDamage$ = 16					; size = 4
?GetTargetDefense@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0AAE@Z PROC ; CObjBaseAttack::GetTargetDefense, COMDAT
; _this$ = ecx

; 1277 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1278 : #ifdef MODIFY_BUFFSYSTEM_BUGFIX_06_20080102
; 1279 : 	int targetdefense = lpTargetObj->m_Defense;
; 1280 : #else
; 1281 : 	#ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1282 : 	int skilldefense = gObjGetTotalValueOfEffect( lpTargetObj, EFFECTTYPE_IMPROVE_DEFENSE );
; 1283 : 	skilldefense += gObjGetTotalValueOfEffect( lpTargetObj, EFFECTTYPE_IMPROVE_MELEE_DEFENSE );
; 1284 : 	int targetdefense = lpTargetObj->m_Defense + skilldefense;
; 1285 : 	#else
; 1286 : 	int skilldefense = lpTargetObj->m_SkillDefense;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0000f	8b 88 1c 1a 00
	00		 mov	 ecx, DWORD PTR [eax+6684]
  00015	89 4d f8	 mov	 DWORD PTR _skilldefense$[ebp], ecx

; 1287 : 	int targetdefense = lpTargetObj->m_Defense+skilldefense;

  00018	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0001b	8b 88 e8 02 00
	00		 mov	 ecx, DWORD PTR [eax+744]
  00021	03 4d f8	 add	 ecx, DWORD PTR _skilldefense$[ebp]
  00024	89 4d f4	 mov	 DWORD PTR _targetdefense$[ebp], ecx

; 1288 : 	#endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1289 : #endif // MODIFY_BUFFSYSTEM_BUGFIX_06_20080102
; 1290 : 
; 1291 : #ifdef ADD_380ITEM_NEWOPTION_20060711
; 1292 : 	// 380 추가 아이템 옵션 : 대인간 방어력 증가 +%d. 서버계산은 /2를 유지.
; 1293 : 	if( lpObj->Type == OBJTYPE_CHARACTER && lpTargetObj->Type == OBJTYPE_CHARACTER )
; 1294 : 	{
; 1295 : 		targetdefense += lpTargetObj->m_ItemOptionExFor380.OpAddDefense/2;
; 1296 : 	}
; 1297 : #endif // ADD_380ITEM_NEWOPTION_20060711
; 1298 : 
; 1299 : #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1300 : 	int iDecreaseDefense = 0;
; 1301 : 	iDecreaseDefense = gObjGetTotalValueOfEffect( lpTargetObj, EFFECTTYPE_DECREASE_DEFENSE );
; 1302 : 	targetdefense -= ( targetdefense * iDecreaseDefense ) / 100;
; 1303 : #elif defined(NEW_SKILL_FORSKYLAND)
; 1304 : 	targetdefense -= targetdefense*lpTargetObj->m_SkillMagumReduceDefense/100;

  00027	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0002a	8b 4d f4	 mov	 ecx, DWORD PTR _targetdefense$[ebp]
  0002d	0f af 88 04 1a
	00 00		 imul	 ecx, DWORD PTR [eax+6660]
  00034	8b c1		 mov	 eax, ecx
  00036	99		 cdq
  00037	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0003c	f7 f9		 idiv	 ecx
  0003e	8b 55 f4	 mov	 edx, DWORD PTR _targetdefense$[ebp]
  00041	2b d0		 sub	 edx, eax
  00043	89 55 f4	 mov	 DWORD PTR _targetdefense$[ebp], edx

; 1305 : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 1306 : 	
; 1307 : #ifdef ADD_NEW_MONSTER_SYSTEM_01_20050714
; 1308 : // 방어력 증가&감소
; 1309 : 	if( lpObj->m_MonsterSkillElementInfo.m_iSkillElementDefenseTime > 0 )
; 1310 : 	{
; 1311 : #if TESTSERVER == 1
; 1312 : 		MsgOutput(lpObj->m_Index, "%d 방증&감상태", lpObj->m_MonsterSkillElementInfo.m_iSkillElementAttack);
; 1313 : #endif
; 1314 : 		
; 1315 : 		targetdefense += lpObj->m_MonsterSkillElementInfo.m_iSkillElementDefense;
; 1316 : 
; 1317 : 		if( targetdefense < 0 ) targetdefense = 0;
; 1318 : 	}
; 1319 : #endif
; 1320 : 
; 1321 : 	int percentdamage = 0;

  00046	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _percentdamage$[ebp], 0

; 1322 : 	if( lpObj->pInventory[EQUIPMENT_WING].IsItem() )

  0004d	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00052	6b c8 07	 imul	 ecx, eax, 7
  00055	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00058	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  0005e	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  00063	85 c0		 test	 eax, eax
  00065	74 19		 je	 SHORT $LN2@GetTargetD

; 1323 : 	{
; 1324 : 		percentdamage = lpObj->pInventory[EQUIPMENT_WING].IsWingOpGetOnePercentDamage();		

  00067	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  0006c	6b c8 07	 imul	 ecx, eax, 7
  0006f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00072	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00078	e8 00 00 00 00	 call	 ?IsWingOpGetOnePercentDamage@CItem@@QAEHXZ ; CItem::IsWingOpGetOnePercentDamage
  0007d	89 45 f0	 mov	 DWORD PTR _percentdamage$[ebp], eax
$LN2@GetTargetD:

; 1325 : 		
; 1326 : #ifdef ADD_THIRD_WING_20070525	// 3차 날개 
; 1327 : 		// 5% 확률로 적의 방어력 무시 옵션이 적용되어 있으면.
; 1328 : 		percentdamage += lpObj->pInventory[EQUIPMENT_WING].GetIgnoreDefencePer();
; 1329 : #endif
; 1330 : 	}	
; 1331 : 	percentdamage += lpObj->SetOpIgnoreDefense;		// 세트 옵션 적 방어 무시

  00080	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00083	0f b6 88 46 0f
	00 00		 movzx	 ecx, BYTE PTR [eax+3910]
  0008a	03 4d f0	 add	 ecx, DWORD PTR _percentdamage$[ebp]
  0008d	89 4d f0	 mov	 DWORD PTR _percentdamage$[ebp], ecx

; 1332 : 	if( percentdamage )

  00090	74 1f		 je	 SHORT $LN3@GetTargetD

; 1333 : 	{	// 3%확률로 적의 방어력 무시 공격옵션이 적용되어 있으면
; 1334 : 
; 1335 : 		if( rand()%100 <= percentdamage )

  00092	e8 00 00 00 00	 call	 _rand
  00097	99		 cdq
  00098	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0009d	f7 f9		 idiv	 ecx
  0009f	3b 55 f0	 cmp	 edx, DWORD PTR _percentdamage$[ebp]
  000a2	7f 0d		 jg	 SHORT $LN3@GetTargetD

; 1336 : 		{
; 1337 : 			targetdefense = 0;

  000a4	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _targetdefense$[ebp], 0

; 1338 : 			MsgDamage = DT_PERFECT;	// 방어율 무시 공격

  000ab	8b 45 10	 mov	 eax, DWORD PTR _MsgDamage$[ebp]
  000ae	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN3@GetTargetD:

; 1339 : 		}
; 1340 : 	}
; 1341 : 
; 1342 : 	return targetdefense;

  000b1	8b 45 f4	 mov	 eax, DWORD PTR _targetdefense$[ebp]

; 1343 : }

  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c2 0c 00	 ret	 12			; 0000000cH
?GetTargetDefense@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0AAE@Z ENDP ; CObjBaseAttack::GetTargetDefense
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ObjBaseAttack.cpp
;	COMDAT ?MissCheck@CObjBaseAttack@@UAEHPAVOBJECTSTRUCT@@0HHHAAH@Z
_TEXT	SEGMENT
$T2 = -112						; size = 4
_MsgDamage$3 = -44					; size = 4
_TargetSuccessfulBlocking$4 = -40			; size = 4
_SuccessAttackRate$5 = -36				; size = 4
_bRet$ = -32						; size = 4
_this$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_skill$ = 16						; size = 4
_skillSuccess$ = 20					; size = 4
_magicsend$ = 24					; size = 4
_bAllMiss$ = 28						; size = 4
?MissCheck@CObjBaseAttack@@UAEHPAVOBJECTSTRUCT@@0HHHAAH@Z PROC ; CObjBaseAttack::MissCheck, COMDAT
; _this$ = ecx

; 868  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?MissCheck@CObjBaseAttack@@UAEHPAVOBJECTSTRUCT@@0HHHAAH@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 c4 a0	 add	 esp, -96		; ffffffa0H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00033	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 869  : 	BOOL bRet = FALSE;

  00036	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 0

; 870  : 
; 871  : #define LEAVE_SET(x) {bRet = x; __leave;}
; 872  : 
; 873  : 	__try

  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 874  : 	{
; 875  : 		int SuccessAttackRate = 0;

  00044	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _SuccessAttackRate$5[ebp], 0

; 876  : 		int TargetSuccessfulBlocking = lpTargetObj->m_SuccessfulBlocking;

  0004b	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0004e	8b 88 f0 02 00
	00		 mov	 ecx, DWORD PTR [eax+752]
  00054	89 4d d8	 mov	 DWORD PTR _TargetSuccessfulBlocking$4[ebp], ecx

; 877  : 		int	MsgDamage = 0;

  00057	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _MsgDamage$3[ebp], 0

; 878  : 
; 879  : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328		// 환영 사원 전용스킬 보호의 주문 적용
; 880  : 	if(CHECK_ILLUSION_TEMPLE(lpTargetObj->MapNumber) 
; 881  : 		&& g_IllusionTempleEvent.GetIllusionTempleState(lpTargetObj->MapNumber) == ILLUSION_TEMPLE_STATE_PLAYING)
; 882  : 	{
; 883  : #ifdef MODIFY_ILLUSIONTEMPLE_BUGFIX_4_20070802
; 884  : 		if(lpTargetObj->Type == OBJTYPE_CHARACTER 
; 885  : 			&& g_IllusionTempleEvent.CheckSkillProdection(lpTargetObj->m_iIllusionTempleIndex, lpTargetObj->MapNumber))
; 886  : #else
; 887  : 		if((lpTargetObj->m_ViewSkillState & STATE_ILLUSION_TEMPLE_PRODECTION) == STATE_ILLUSION_TEMPLE_PRODECTION)
; 888  : #endif
; 889  : 		{
; 890  : 			GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index , 0, 0, 0, 0);
; 891  : 			LEAVE_SET(FALSE);
; 892  : 		}
; 893  : 
; 894  : 		// 같은 파티원끼리는 데미지 없게
; 895  : 		if(lpObj->PartyNumber == lpTargetObj->PartyNumber)
; 896  : 		{
; 897  : 			GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index , 0, 0, 0, 0);
; 898  : 			LEAVE_SET(FALSE);
; 899  : 		}
; 900  : 	}
; 901  : #endif
; 902  : 
; 903  : 		if( lpObj->Type == OBJTYPE_CHARACTER )

  0005e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00061	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00065	83 f9 01	 cmp	 ecx, 1
  00068	0f 85 15 01 00
	00		 jne	 $LN3@MissCheck

; 904  : 		{
; 905  : #ifdef MASTER_LEVEL_UP_SYSTEM_20070912	// 종합레벨 - 공격 성공률 조정
; 906  : 			int iTotalLevel = lpObj->Level + lpObj->m_nMasterLevel;
; 907  : 			if( lpObj->Class == CLASS_DARKLORD )
; 908  : 			{	// 다크로드만 공격 성공률이 틀리다				
; 909  : 				SuccessAttackRate = (iTotalLevel*5)+(( (lpObj->Dexterity+lpObj->AddDexterity)*6)/2)+((lpObj->Strength+lpObj->AddStrength)/4)+((lpObj->Leadership+lpObj->AddLeadership)/10);
; 910  : 				// 세트 옵션 공격 성공률 증가
; 911  : 				SuccessAttackRate += SuccessAttackRate * lpObj->SetOpImproveSuccessAttackRate / 100;
; 912  : 			}
; 913  : 			else
; 914  : 			{
; 915  : 				SuccessAttackRate = (iTotalLevel*5)+(( (lpObj->Dexterity+lpObj->AddDexterity)*3)/2)+((lpObj->Strength+lpObj->AddStrength)/4);
; 916  : 				// 세트 옵션 공격 성공률 증가
; 917  : 				SuccessAttackRate += SuccessAttackRate * lpObj->SetOpImproveSuccessAttackRate / 100;
; 918  : 			}			
; 919  : #else			
; 920  : #ifdef DARKLORD_WORK
; 921  : 			if( lpObj->Class == CLASS_DARKLORD )

  0006e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00071	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00078	83 f9 04	 cmp	 ecx, 4
  0007b	0f 85 91 00 00
	00		 jne	 $LN5@MissCheck

; 922  : 			{	// 다크로드만 공격 성공률이 틀리다
; 923  : 				SuccessAttackRate = (lpObj->Level*5)+(( (lpObj->Dexterity+lpObj->AddDexterity)*6)/2)+((lpObj->Strength+lpObj->AddStrength)/4)+((lpObj->Leadership+lpObj->AddLeadership)/10);

  00081	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00084	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0008b	6b c9 05	 imul	 ecx, ecx, 5
  0008e	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00091	0f b7 82 b6 00
	00 00		 movzx	 eax, WORD PTR [edx+182]
  00098	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0009b	0f b7 92 e2 00
	00 00		 movzx	 edx, WORD PTR [edx+226]
  000a2	03 c2		 add	 eax, edx
  000a4	6b c0 06	 imul	 eax, eax, 6
  000a7	99		 cdq
  000a8	2b c2		 sub	 eax, edx
  000aa	d1 f8		 sar	 eax, 1
  000ac	03 c8		 add	 ecx, eax
  000ae	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000b1	0f b7 80 b4 00
	00 00		 movzx	 eax, WORD PTR [eax+180]
  000b8	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000bb	0f b7 92 e0 00
	00 00		 movzx	 edx, WORD PTR [edx+224]
  000c2	03 c2		 add	 eax, edx
  000c4	99		 cdq
  000c5	83 e2 03	 and	 edx, 3
  000c8	03 c2		 add	 eax, edx
  000ca	c1 f8 02	 sar	 eax, 2
  000cd	03 c8		 add	 ecx, eax
  000cf	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d2	0f b7 80 d8 00
	00 00		 movzx	 eax, WORD PTR [eax+216]
  000d9	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000dc	0f b7 92 da 00
	00 00		 movzx	 edx, WORD PTR [edx+218]
  000e3	03 c2		 add	 eax, edx
  000e5	99		 cdq
  000e6	be 0a 00 00 00	 mov	 esi, 10			; 0000000aH
  000eb	f7 fe		 idiv	 esi
  000ed	03 c8		 add	 ecx, eax
  000ef	89 4d dc	 mov	 DWORD PTR _SuccessAttackRate$5[ebp], ecx

; 924  : 				// 세트 옵션 공격 성공률 증가
; 925  : 				SuccessAttackRate += SuccessAttackRate*lpObj->SetOpImproveSuccessAttackRate/100;

  000f2	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000f5	0f b6 88 49 0f
	00 00		 movzx	 ecx, BYTE PTR [eax+3913]
  000fc	8b c1		 mov	 eax, ecx
  000fe	0f af 45 dc	 imul	 eax, DWORD PTR _SuccessAttackRate$5[ebp]
  00102	99		 cdq
  00103	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00108	f7 f9		 idiv	 ecx
  0010a	03 45 dc	 add	 eax, DWORD PTR _SuccessAttackRate$5[ebp]
  0010d	89 45 dc	 mov	 DWORD PTR _SuccessAttackRate$5[ebp], eax

; 926  : 			}

  00110	eb 6f		 jmp	 SHORT $LN6@MissCheck
$LN5@MissCheck:

; 927  : 			else
; 928  : 			{
; 929  : 				SuccessAttackRate = (lpObj->Level*5)+(( (lpObj->Dexterity+lpObj->AddDexterity)*3)/2)+((lpObj->Strength+lpObj->AddStrength)/4);

  00112	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00115	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  0011c	6b c9 05	 imul	 ecx, ecx, 5
  0011f	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00122	0f b7 82 b6 00
	00 00		 movzx	 eax, WORD PTR [edx+182]
  00129	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0012c	0f b7 92 e2 00
	00 00		 movzx	 edx, WORD PTR [edx+226]
  00133	03 c2		 add	 eax, edx
  00135	6b c0 03	 imul	 eax, eax, 3
  00138	99		 cdq
  00139	2b c2		 sub	 eax, edx
  0013b	d1 f8		 sar	 eax, 1
  0013d	03 c8		 add	 ecx, eax
  0013f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00142	0f b7 80 b4 00
	00 00		 movzx	 eax, WORD PTR [eax+180]
  00149	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0014c	0f b7 92 e0 00
	00 00		 movzx	 edx, WORD PTR [edx+224]
  00153	03 c2		 add	 eax, edx
  00155	99		 cdq
  00156	83 e2 03	 and	 edx, 3
  00159	03 c2		 add	 eax, edx
  0015b	c1 f8 02	 sar	 eax, 2
  0015e	03 c8		 add	 ecx, eax
  00160	89 4d dc	 mov	 DWORD PTR _SuccessAttackRate$5[ebp], ecx

; 930  : 				// 세트 옵션 공격 성공률 증가
; 931  : 				SuccessAttackRate += SuccessAttackRate*lpObj->SetOpImproveSuccessAttackRate/100;

  00163	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00166	0f b6 88 49 0f
	00 00		 movzx	 ecx, BYTE PTR [eax+3913]
  0016d	8b c1		 mov	 eax, ecx
  0016f	0f af 45 dc	 imul	 eax, DWORD PTR _SuccessAttackRate$5[ebp]
  00173	99		 cdq
  00174	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00179	f7 f9		 idiv	 ecx
  0017b	03 45 dc	 add	 eax, DWORD PTR _SuccessAttackRate$5[ebp]
  0017e	89 45 dc	 mov	 DWORD PTR _SuccessAttackRate$5[ebp], eax
$LN6@MissCheck:

; 932  : 			}
; 933  : #else
; 934  : 				SuccessAttackRate = (lpObj->Level*5)+(( (lpObj->Dexterity+lpObj->AddDexterity)*3)/2)+((lpObj->Strength+lpObj->AddStrength)/4);
; 935  : 				// 세트 옵션 공격 성공률 증가
; 936  : 				SuccessAttackRate += SuccessAttackRate*lpObj->SetOpImproveSuccessAttackRate/100;
; 937  : #endif
; 938  : #endif // MASTER_LEVEL_UP_SYSTEM_20070912
; 939  : 		}

  00181	eb 0c		 jmp	 SHORT $LN4@MissCheck
$LN3@MissCheck:

; 940  : 		else
; 941  : 		{
; 942  : 			SuccessAttackRate = lpObj->m_AttackRating;

  00183	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00186	8b 88 dc 02 00
	00		 mov	 ecx, DWORD PTR [eax+732]
  0018c	89 4d dc	 mov	 DWORD PTR _SuccessAttackRate$5[ebp], ecx
$LN4@MissCheck:

; 943  : 		}
; 944  : 		
; 945  : #ifdef MASTER_LEVEL_SKILL_SYSTEM_20071122	// 패시브 1차 - 공격성공률 상승
; 946  : 		SuccessAttackRate += lpObj->m_MPSkillOpt.iMpsAttackSuccessRate;		
; 947  : #endif	
; 948  : 
; 949  : 		if(TargetSuccessfulBlocking > g_GlobalConfig.m_iMaxMissRate)

  0018f	8b 45 d8	 mov	 eax, DWORD PTR _TargetSuccessfulBlocking$4[ebp]
  00192	3b 05 e4 00 00
	00		 cmp	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+228
  00198	7e 08		 jle	 SHORT $LN7@MissCheck

; 950  : 			TargetSuccessfulBlocking = g_GlobalConfig.m_iMaxMissRate;

  0019a	a1 e4 00 00 00	 mov	 eax, DWORD PTR ?g_GlobalConfig@@3VCGlobalConfig@@A+228
  0019f	89 45 d8	 mov	 DWORD PTR _TargetSuccessfulBlocking$4[ebp], eax
$LN7@MissCheck:

; 951  : 
; 952  : #ifdef NEW_FORSKYLAND3
; 953  : 		if( SuccessAttackRate < TargetSuccessfulBlocking )

  001a2	8b 45 dc	 mov	 eax, DWORD PTR _SuccessAttackRate$5[ebp]
  001a5	3b 45 d8	 cmp	 eax, DWORD PTR _TargetSuccessfulBlocking$4[ebp]
  001a8	7d 09		 jge	 SHORT $LN8@MissCheck

; 954  : 		{
; 955  : 			bAllMiss = TRUE;

  001aa	8b 45 1c	 mov	 eax, DWORD PTR _bAllMiss$[ebp]
  001ad	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
$LN8@MissCheck:

; 956  : 		}
; 957  : #endif
; 958  : 
; 959  : #ifdef NEW_FORSKYLAND3
; 960  : 		if( bAllMiss )

  001b3	8b 45 1c	 mov	 eax, DWORD PTR _bAllMiss$[ebp]
  001b6	83 38 00	 cmp	 DWORD PTR [eax], 0
  001b9	74 5b		 je	 SHORT $LN9@MissCheck

; 961  : 		{	
; 962  : 
; 963  : #ifdef MODIFY_SUCCESSBLOCKING_ALLMISS_20040408
; 964  : 			if( rand()%100 >= 5 )

  001bb	e8 00 00 00 00	 call	 _rand
  001c0	99		 cdq
  001c1	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  001c6	f7 f9		 idiv	 ecx
  001c8	83 fa 05	 cmp	 edx, 5
  001cb	7c 47		 jl	 SHORT $LN11@MissCheck

; 965  : #else
; 966  : 			if( rand()%100 >= 3 )
; 967  : #endif
; 968  : 			{	// all 미스는 3%의 확률로 데미지가 들어 온다
; 969  : 
; 970  : #ifdef ADD_SKILL_WITH_COMBO
; 971  : #else
; 972  : 				MsgDamage = 0x20;
; 973  : #endif
; 974  : #ifdef ADD_SHIELD_POINT_01_20060403
; 975  : 				GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index , 0, 0, MsgDamage, 0);
; 976  : #else
; 977  : 				GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index , 0, 0, MsgDamage);

  001cd	8b 45 d4	 mov	 eax, DWORD PTR _MsgDamage$3[ebp]
  001d0	50		 push	 eax
  001d1	6a 00		 push	 0
  001d3	6a 00		 push	 0
  001d5	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  001d8	8b 11		 mov	 edx, DWORD PTR [ecx]
  001da	52		 push	 edx
  001db	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001de	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e0	51		 push	 ecx
  001e1	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHHH@Z ; GCDamageSend
  001e6	83 c4 14	 add	 esp, 20			; 00000014H

; 978  : #endif //ADD_SHIELD_POINT_01_20060403
; 979  : 				if( magicsend )

  001e9	83 7d 18 00	 cmp	 DWORD PTR _magicsend$[ebp], 0
  001ed	74 1c		 je	 SHORT $LN12@MissCheck

; 980  : 				{
; 981  : 					GCMagicAttackNumberSend(lpObj, skill, lpTargetObj->m_Index, skillSuccess);

  001ef	0f b6 45 14	 movzx	 eax, BYTE PTR _skillSuccess$[ebp]
  001f3	50		 push	 eax
  001f4	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  001f7	8b 11		 mov	 edx, DWORD PTR [ecx]
  001f9	52		 push	 edx
  001fa	0f b6 45 10	 movzx	 eax, BYTE PTR _skill$[ebp]
  001fe	50		 push	 eax
  001ff	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00202	51		 push	 ecx
  00203	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAVOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  00208	83 c4 10	 add	 esp, 16			; 00000010H
$LN12@MissCheck:

; 982  : 				}
; 983  : 
; 984  : 				LEAVE_SET(FALSE);

  0020b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 0
  00212	eb 5e		 jmp	 SHORT $LN2@MissCheck
$LN11@MissCheck:

; 985  : 			}
; 986  : 		}

  00214	eb 55		 jmp	 SHORT $LN10@MissCheck
$LN9@MissCheck:

; 987  : 		else 
; 988  : #endif
; 989  : 		if( (rand()%SuccessAttackRate) < TargetSuccessfulBlocking) 

  00216	e8 00 00 00 00	 call	 _rand
  0021b	99		 cdq
  0021c	f7 7d dc	 idiv	 DWORD PTR _SuccessAttackRate$5[ebp]
  0021f	3b 55 d8	 cmp	 edx, DWORD PTR _TargetSuccessfulBlocking$4[ebp]
  00222	7d 47		 jge	 SHORT $LN10@MissCheck

; 990  : 		{
; 991  : 
; 992  : #ifdef ADD_SKILL_WITH_COMBO
; 993  : #else
; 994  : 			int MsgDamage = 0x20;
; 995  : #endif
; 996  : 			
; 997  : #ifdef ADD_SHIELD_POINT_01_20060403
; 998  : 			GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index , 0, 0, MsgDamage, 0);
; 999  : #else
; 1000 : 			GCDamageSend(lpObj->m_Index,lpTargetObj->m_Index , 0, 0, MsgDamage);

  00224	8b 45 d4	 mov	 eax, DWORD PTR _MsgDamage$3[ebp]
  00227	50		 push	 eax
  00228	6a 00		 push	 0
  0022a	6a 00		 push	 0
  0022c	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  0022f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00231	52		 push	 edx
  00232	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00235	8b 08		 mov	 ecx, DWORD PTR [eax]
  00237	51		 push	 ecx
  00238	e8 00 00 00 00	 call	 ?GCDamageSend@@YAXHHHHH@Z ; GCDamageSend
  0023d	83 c4 14	 add	 esp, 20			; 00000014H

; 1001 : #endif
; 1002 : 			if( magicsend )

  00240	83 7d 18 00	 cmp	 DWORD PTR _magicsend$[ebp], 0
  00244	74 1c		 je	 SHORT $LN14@MissCheck

; 1003 : 			{
; 1004 : 				GCMagicAttackNumberSend(lpObj, skill, lpTargetObj->m_Index, skillSuccess);

  00246	0f b6 45 14	 movzx	 eax, BYTE PTR _skillSuccess$[ebp]
  0024a	50		 push	 eax
  0024b	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  0024e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00250	52		 push	 edx
  00251	0f b6 45 10	 movzx	 eax, BYTE PTR _skill$[ebp]
  00255	50		 push	 eax
  00256	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00259	51		 push	 ecx
  0025a	e8 00 00 00 00	 call	 ?GCMagicAttackNumberSend@@YAXPAVOBJECTSTRUCT@@EHE@Z ; GCMagicAttackNumberSend
  0025f	83 c4 10	 add	 esp, 16			; 00000010H
$LN14@MissCheck:

; 1005 : 			}
; 1006 : 			LEAVE_SET(FALSE);

  00262	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 0
  00269	eb 07		 jmp	 SHORT $LN2@MissCheck
$LN10@MissCheck:

; 1007 : 		}
; 1008 : 
; 1009 : 		bRet = TRUE;

  0026b	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _bRet$[ebp], 1
$LN2@MissCheck:

; 1010 : 	}

  00272	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  00279	eb 51		 jmp	 SHORT $LN20@MissCheck
$LN17@MissCheck:
$LN22@MissCheck:

; 1011 : 	__except(lpObj->Level =1, EXCEPTION_CONTINUE_EXECUTION  )

  0027b	b8 01 00 00 00	 mov	 eax, 1
  00280	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00283	66 89 81 a0 00
	00 00		 mov	 WORD PTR [ecx+160], ax
  0028a	83 c8 ff	 or	 eax, -1
$LN19@MissCheck:
$LN21@MissCheck:
  0028d	c3		 ret	 0
$LN18@MissCheck:
  0028e	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 1012 : 	{
; 1013 : 		LogAdd(lMsg.Get(524), lpObj->Name);

  00291	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00294	83 c0 73	 add	 eax, 115		; 00000073H
  00297	50		 push	 eax
  00298	68 0c 02 00 00	 push	 524			; 0000020cH
  0029d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  002a8	50		 push	 eax
  002a9	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  002af	83 c4 08	 add	 esp, 8

; 1014 : 		return FALSE;

  002b2	c7 45 90 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  002b9	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  002c0	8b 45 90	 mov	 eax, DWORD PTR $T2[ebp]
  002c3	eb 0a		 jmp	 SHORT $LN16@MissCheck

; 1010 : 	}

  002c5	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
$LN20@MissCheck:

; 1015 : 	}	
; 1016 : 
; 1017 : 	return bRet;

  002cc	8b 45 e0	 mov	 eax, DWORD PTR _bRet$[ebp]
$LN16@MissCheck:

; 1018 : }

  002cf	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  002d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002d9	59		 pop	 ecx
  002da	5f		 pop	 edi
  002db	5e		 pop	 esi
  002dc	5b		 pop	 ebx
  002dd	8b e5		 mov	 esp, ebp
  002df	5d		 pop	 ebp
  002e0	c2 18 00	 ret	 24			; 00000018H
?MissCheck@CObjBaseAttack@@UAEHPAVOBJECTSTRUCT@@0HHHAAH@Z ENDP ; CObjBaseAttack::MissCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ObjBaseAttack.cpp
;	COMDAT ?ResistanceCheck@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
_skill$ = 16						; size = 4
?ResistanceCheck@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0H@Z PROC ; CObjBaseAttack::ResistanceCheck, COMDAT
; _this$ = ecx

; 559  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 560  : #ifdef CASTLE_MAIN_SCHEDULER_20041111			// 공성전 NPC - 석상, 성문 등은 각종 중독마법에 걸리면 않된다.
; 561  : 	if (lpTargetObj->Type != OBJTYPE_CHARACTER) 
; 562  : 	{
; 563  : 		if ((lpTargetObj->Class == 277)||			// 성문
; 564  : 			(lpTargetObj->Class == 283)||			// 수호석상
; 565  : 			(lpTargetObj->Class == 288)||			// 캐논타워
; 566  : 			(lpTargetObj->Class == 278)||			// 라이프스톤
; 567  : 			(lpTargetObj->Class == 215)||			// 방어막
; 568  : 			(lpTargetObj->Class == 216)||			// 왕관
; 569  : 			(lpTargetObj->Class == 217)||			// 왕관스위치
; 570  : 			(lpTargetObj->Class == 218)||			// 왕관스위치
; 571  : 			(lpTargetObj->Class == 219)				// 성문레버
; 572  : 			)
; 573  : 		{
; 574  : 			return 0;
; 575  : 		}
; 576  : 	}
; 577  : #endif
; 578  : 
; 579  : #ifdef CRYWOLF_NPC_WORK_20050912
; 580  : 	// 크라이울프 NPC들 저항처리
; 581  : 	if( lpTargetObj->Type != OBJTYPE_CHARACTER ) 
; 582  : 	{
; 583  : 		if( 
; 584  : 			CHECK_CRYWOLF_NPC_ALTAR(lpTargetObj->Class)			// 늑대의 제단
; 585  : 			|| CHECK_CRYWOLF_NPC_STATUE(lpTargetObj->Class)		// 늑대의 신상
; 586  : 		  )
; 587  : 		{
; 588  : 			return 0;
; 589  : 		}
; 590  : 	}
; 591  : 
; 592  : #endif
; 593  : 
; 594  : #ifdef DARKLORD_WORK
; 595  : 	if( skill == AT_SKILL_DARKHORSE_ATTACK )

  0000c	83 7d 10 3e	 cmp	 DWORD PTR _skill$[ebp], 62 ; 0000003eH
  00010	75 12		 jne	 SHORT $LN2@Resistance

; 596  : 	{
; 597  : 		gObjBackSpring2(lpTargetObj, lpObj,3);

  00012	6a 03		 push	 3
  00014	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00017	50		 push	 eax
  00018	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ?gObjBackSpring2@@YAHPAVOBJECTSTRUCT@@0H@Z ; gObjBackSpring2
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Resistance:

; 598  : 	}
; 599  : #endif
; 600  : 	
; 601  : #ifdef ADD_MASTER_LEVEL_SKILL_SYSTEM_ACTIVE_20080107	// 어스쉐이크 강화 - 뒤로 밀리게.
; 602  : 	if( g_MasterSkillSystem.GetBaseMasterLevelSkill( skill ) == AT_SKILL_ML_STRENGTHEN_DARKHORSE_ATTACK )
; 603  : 	{
; 604  : 		gObjBackSpring2( lpTargetObj, lpObj, 3 );
; 605  : 	}
; 606  : #endif
; 607  : 	
; 608  : 	////////////////////////////////////////////////////////////////////////////////
; 609  : 	// 스킬 공격일땐 뒤로 물러나게 한다.	-> 사람 몬스터 둘 다
; 610  : 	if( skill == AT_SKILL_SWORD1  || 
; 611  : 		skill == AT_SKILL_SWORD2  || 
; 612  : 		skill == AT_SKILL_SWORD3  || 
; 613  : 		skill == AT_SKILL_SWORD4  || 

  00024	83 7d 10 13	 cmp	 DWORD PTR _skill$[ebp], 19 ; 00000013H
  00028	74 18		 je	 SHORT $LN5@Resistance
  0002a	83 7d 10 14	 cmp	 DWORD PTR _skill$[ebp], 20 ; 00000014H
  0002e	74 12		 je	 SHORT $LN5@Resistance
  00030	83 7d 10 15	 cmp	 DWORD PTR _skill$[ebp], 21 ; 00000015H
  00034	74 0c		 je	 SHORT $LN5@Resistance
  00036	83 7d 10 16	 cmp	 DWORD PTR _skill$[ebp], 22 ; 00000016H
  0003a	74 06		 je	 SHORT $LN5@Resistance
  0003c	83 7d 10 17	 cmp	 DWORD PTR _skill$[ebp], 23 ; 00000017H
  00040	75 20		 jne	 SHORT $LN3@Resistance
$LN5@Resistance:

; 614  : 		skill == AT_SKILL_SWORD5 )
; 615  : 	{		
; 616  : 		gObjAddMsgSendDelay(lpTargetObj, 2, lpObj->m_Index, 150);

  00042	6a 00		 push	 0
  00044	68 96 00 00 00	 push	 150			; 00000096H
  00049	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	51		 push	 ecx
  0004f	6a 02		 push	 2
  00051	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  0005a	83 c4 14	 add	 esp, 20			; 00000014H

; 617  : 	}

  0005d	e9 ca 02 00 00	 jmp	 $LN4@Resistance
$LN3@Resistance:

; 618  : 	// 번개 저항력
; 619  : 	else if( skill == AT_SKILL_THUNDER )

  00062	83 7d 10 03	 cmp	 DWORD PTR _skill$[ebp], 3
  00066	75 45		 jne	 SHORT $LN6@Resistance

; 620  : 	{	// 상대가 번개에 대한 저항력 없다면
; 621  : 		if( retResistance(lpTargetObj, RESISTANCE_THUNDER) == FALSE ) 

  00068	6a 02		 push	 2
  0006a	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?retResistance@@YAHPAVOBJECTSTRUCT@@H@Z ; retResistance
  00073	83 c4 08	 add	 esp, 8
  00076	85 c0		 test	 eax, eax
  00078	75 27		 jne	 SHORT $LN8@Resistance

; 622  : 		{
; 623  : 			gObjAddMsgSendDelay(lpTargetObj, 2, lpObj->m_Index, 150);

  0007a	6a 00		 push	 0
  0007c	68 96 00 00 00	 push	 150			; 00000096H
  00081	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	51		 push	 ecx
  00087	6a 02		 push	 2
  00089	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  0008c	52		 push	 edx
  0008d	e8 00 00 00 00	 call	 ?gObjAddMsgSendDelay@@YAXPAVOBJECTSTRUCT@@HHHH@Z ; gObjAddMsgSendDelay
  00092	83 c4 14	 add	 esp, 20			; 00000014H

; 624  : 			return 1;

  00095	b8 01 00 00 00	 mov	 eax, 1
  0009a	e9 92 02 00 00	 jmp	 $LN1@Resistance

; 625  : 		}

  0009f	eb 07		 jmp	 SHORT $LN9@Resistance
$LN8@Resistance:

; 626  : 		else return 0;

  000a1	33 c0		 xor	 eax, eax
  000a3	e9 89 02 00 00	 jmp	 $LN1@Resistance
$LN9@Resistance:

; 627  : 	}	

  000a8	e9 7f 02 00 00	 jmp	 $LN4@Resistance
$LN6@Resistance:

; 628  : 	else if( skill == AT_SKILL_POISON )	// 중독 공격 세팅

  000ad	83 7d 10 01	 cmp	 DWORD PTR _skill$[ebp], 1
  000b1	75 6e		 jne	 SHORT $LN10@Resistance

; 629  : 	{	// 독저항력
; 630  : #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 631  : 		if( gObjCheckUsedBuffEffect( lpTargetObj, BUFFTYPE_POISON ) == false )
; 632  : 		{
; 633  : 			if( retResistance( lpTargetObj, RESISTANCE_POISON ) == FALSE )
; 634  : 			{
; 635  : 				lpTargetObj->lpAttackObj = lpObj;
; 636  : 				gObjAddBuffEffect( lpTargetObj, BUFFTYPE_POISON, EFFECTTYPE_POISON_DMG_TICK, 3, 0, 0, 20 );
; 637  : 				return 1;
; 638  : 			}
; 639  : 			else
; 640  : 			{
; 641  : 				return 0;
; 642  : 			}
; 643  : 		}
; 644  : 		else
; 645  : 		{
; 646  : 			return 0;
; 647  : 		}
; 648  : #else
; 649  : #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 650  : 		if( gObjCheckUsedBuffEffect( lpTargetObj, BUFFTYPE_POISON ) == false )
; 651  : 		{
; 652  : 			if( retResistance( lpTargetObj, RESISTANCE_POISON ) == FALSE )
; 653  : 			{
; 654  : #ifdef MODIFY_BUFFSYSTEM_BUGFIX_01_20071128
; 655  : 				lpTargetObj->lpAttackObj = lpObj;
; 656  : #endif // MODIFY_BUFFSYSTEM_BUGFIX_01_20071128
; 657  : 				gObjAddBuffEffect( lpTargetObj, BUFFTYPE_POISON, EFFECTTYPE_POISON_DMG_TICK, 3, 0, 0, 20 );
; 658  : 			}
; 659  : 			else
; 660  : 			{
; 661  : 				return 0;
; 662  : 			}
; 663  : 		}
; 664  : 		else
; 665  : 		{
; 666  : 			return 0;
; 667  : 		}
; 668  : #else
; 669  : 	#ifdef ADD_SKILL_WITH_COMBO		
; 670  : 		if( lpTargetObj->m_PoisonType == 0 ) // 현재 중독 마법에 걸려있다면 다시 걸리지 않게..

  000b3	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000b6	0f be 88 21 02
	00 00		 movsx	 ecx, BYTE PTR [eax+545]
  000bd	85 c9		 test	 ecx, ecx
  000bf	75 54		 jne	 SHORT $LN12@Resistance

; 671  : 	#else
; 672  : 		if( lpTargetObj->m_PoisonBeattackCount == 0 ) // 현재 중독 마법에 걸려있다면 다시 걸리지 않게..
; 673  : 	#endif	//#ifdef ADD_SKILL_WITH_COMBO
; 674  : 		{
; 675  : 			if( retResistance(lpTargetObj, RESISTANCE_POISON) == FALSE ) 

  000c1	6a 01		 push	 1
  000c3	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 ?retResistance@@YAHPAVOBJECTSTRUCT@@H@Z ; retResistance
  000cc	83 c4 08	 add	 esp, 8
  000cf	85 c0		 test	 eax, eax
  000d1	75 39		 jne	 SHORT $LN14@Resistance

; 676  : 			{
; 677  : #ifdef ADD_SKILL_WITH_COMBO
; 678  : 				lpTargetObj->m_PoisonType = AT_SKILL_POISON;

  000d3	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000d6	c6 80 21 02 00
	00 01		 mov	 BYTE PTR [eax+545], 1

; 679  : #endif	//#ifdef ADD_SKILL_WITH_COMBO
; 680  : 				lpTargetObj->m_PoisonBeattackCount	= 20;	// 10초 동안 중독 상태로..

  000dd	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000e0	c6 80 18 1a 00
	00 14		 mov	 BYTE PTR [eax+6680], 20	; 00000014H

; 681  : 				lpTargetObj->lpAttackObj			= lpObj;

  000e7	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000ea	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ed	89 88 30 02 00
	00		 mov	 DWORD PTR [eax+560], ecx

; 682  : 				lpTargetObj->m_ViewSkillState		|= 0x01; //	1번째 비트

  000f3	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000f6	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  000fd	83 c9 01	 or	 ecx, 1
  00100	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00103	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 683  : 			}

  0010a	eb 07		 jmp	 SHORT $LN15@Resistance
$LN14@Resistance:

; 684  : 			else return 0;	// 독에 대한 저항력이 있다면 공격은 실패

  0010c	33 c0		 xor	 eax, eax
  0010e	e9 1e 02 00 00	 jmp	 $LN1@Resistance
$LN15@Resistance:

; 685  : 		}

  00113	eb 07		 jmp	 SHORT $LN13@Resistance
$LN12@Resistance:

; 686  : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 687  : 		else
; 688  : 		{
; 689  : 			return 0;

  00115	33 c0		 xor	 eax, eax
  00117	e9 15 02 00 00	 jmp	 $LN1@Resistance
$LN13@Resistance:

; 690  : 		}
; 691  : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 692  : 	}

  0011c	e9 0b 02 00 00	 jmp	 $LN4@Resistance
$LN10@Resistance:

; 693  : #ifdef ADD_SKILL_WITH_COMBO		
; 694  : 	// 독공격2(데쓰포이즌)
; 695  : 	else if( skill == AT_SKILL_EXPPOISON )	// 중독 공격 세팅(데쓰포이즌)

  00121	83 7d 10 26	 cmp	 DWORD PTR _skill$[ebp], 38 ; 00000026H
  00125	0f 85 a0 00 00
	00		 jne	 $LN16@Resistance

; 696  : 	{
; 697  : #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 698  : 		if( gObjCheckUsedBuffEffect( lpTargetObj, BUFFTYPE_POISON ) == false )
; 699  : 		{
; 700  : 			if( retResistance( lpTargetObj, RESISTANCE_POISON ) == FALSE )
; 701  : 			{
; 702  : 				lpTargetObj->lpAttackObj = lpObj;
; 703  : 				gObjAddBuffEffect( lpTargetObj, BUFFTYPE_POISON, EFFECTTYPE_POISON_DMG_TICK, 3, 0, 0, 10 );
; 704  : 				return 1;
; 705  : 			}
; 706  : 			else
; 707  : 			{
; 708  : 				return 0;
; 709  : 			}
; 710  : 		}
; 711  : 		else
; 712  : 		{
; 713  : 			return 0;
; 714  : 		}
; 715  : #else
; 716  : 		if( lpTargetObj->m_PoisonType == 0 || lpTargetObj->m_PoisonType == AT_SKILL_POISON )		// 현재 중독 마법에 걸려있다면 다시 걸리지 않게..

  0012b	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0012e	0f be 88 21 02
	00 00		 movsx	 ecx, BYTE PTR [eax+545]
  00135	85 c9		 test	 ecx, ecx
  00137	74 0f		 je	 SHORT $LN20@Resistance
  00139	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0013c	0f be 88 21 02
	00 00		 movsx	 ecx, BYTE PTR [eax+545]
  00143	83 f9 01	 cmp	 ecx, 1
  00146	75 6d		 jne	 SHORT $LN18@Resistance
$LN20@Resistance:

; 717  : 		{
; 718  : 			if( retResistance(lpTargetObj, RESISTANCE_POISON) == FALSE ) 

  00148	6a 01		 push	 1
  0014a	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ?retResistance@@YAHPAVOBJECTSTRUCT@@H@Z ; retResistance
  00153	83 c4 08	 add	 esp, 8
  00156	85 c0		 test	 eax, eax
  00158	75 52		 jne	 SHORT $LN21@Resistance

; 719  : 			{	
; 720  : 				lpTargetObj->m_PoisonType = AT_SKILL_EXPPOISON;

  0015a	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0015d	c6 80 21 02 00
	00 26		 mov	 BYTE PTR [eax+545], 38	; 00000026H

; 721  : 
; 722  : 				lpTargetObj->m_PoisonBeattackCount	= 10;	// 10초 동안 중독 상태로..

  00164	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00167	c6 80 18 1a 00
	00 0a		 mov	 BYTE PTR [eax+6680], 10	; 0000000aH

; 723  : 				lpTargetObj->lpAttackObj			= lpObj;

  0016e	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00171	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00174	89 88 30 02 00
	00		 mov	 DWORD PTR [eax+560], ecx

; 724  : 				lpTargetObj->m_ViewSkillState		|= 0x01; //	1번째 비트

  0017a	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0017d	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  00184	83 c9 01	 or	 ecx, 1
  00187	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  0018a	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 725  : 
; 726  : 				GCStateInfoSend(lpTargetObj, 1, lpTargetObj->m_ViewSkillState);

  00191	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00194	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  0019b	51		 push	 ecx
  0019c	6a 01		 push	 1
  0019e	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  001a1	52		 push	 edx
  001a2	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAVOBJECTSTRUCT@@EG@Z ; GCStateInfoSend
  001a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 727  : 			}

  001aa	eb 07		 jmp	 SHORT $LN22@Resistance
$LN21@Resistance:

; 728  : 			else return 0;	// 독에 대한 저항력이 있다면 공격은 실패

  001ac	33 c0		 xor	 eax, eax
  001ae	e9 7e 01 00 00	 jmp	 $LN1@Resistance
$LN22@Resistance:

; 729  : 		}

  001b3	eb 07		 jmp	 SHORT $LN19@Resistance
$LN18@Resistance:

; 730  : 		else
; 731  : 		{
; 732  : 			return 0;

  001b5	33 c0		 xor	 eax, eax
  001b7	e9 75 01 00 00	 jmp	 $LN1@Resistance
$LN19@Resistance:

; 733  : 		}
; 734  : 		return 1;

  001bc	b8 01 00 00 00	 mov	 eax, 1
  001c1	e9 6b 01 00 00	 jmp	 $LN1@Resistance

; 735  : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 736  : 	}

  001c6	e9 61 01 00 00	 jmp	 $LN4@Resistance
$LN16@Resistance:

; 737  : #endif	// #ifdef ADD_SKILL_WITH_COMBO		
; 738  : #ifdef ADD_SKILL_WITH_COMBO		// 얼음 공격
; 739  : #ifdef UPDATE_MASTER_LEVEL_4RANK_20080428			// 서든 아이스 강화
; 740  : 	else if( skill == AT_SKILL_SLOW || skill == AT_SKILL_EXPICE 
; 741  : 		|| g_MasterSkillSystem.GetBaseMasterLevelSkill( skill ) == AT_SKILL_ML_STRENGTHEN_EXPICE // 서든 아이스 강화 (grooving)
; 742  : 		)
; 743  : #else	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 744  : 	else if( skill == AT_SKILL_SLOW || skill == AT_SKILL_EXPICE )

  001cb	83 7d 10 07	 cmp	 DWORD PTR _skill$[ebp], 7
  001cf	74 0a		 je	 SHORT $LN25@Resistance
  001d1	83 7d 10 27	 cmp	 DWORD PTR _skill$[ebp], 39 ; 00000027H
  001d5	0f 85 a1 00 00
	00		 jne	 $LN23@Resistance
$LN25@Resistance:

; 745  : #endif	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 746  : #else
; 747  : 	else if( skill == AT_SKILL_SLOW )
; 748  : #endif	//#ifdef ADD_SKILL_WITH_COMBO		
; 749  : 	{	
; 750  : #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 751  : 		if( gObjCheckUsedBuffEffect( lpTargetObj, BUFFTYPE_FREEZE ) == false )
; 752  : 		{
; 753  : 			if( retResistance( lpTargetObj, RESISTANCE_COLD ) == FALSE )
; 754  : 			{
; 755  : 				lpTargetObj->lpAttackObj = lpObj;
; 756  : 				lpTargetObj->DelayActionTime = 800;
; 757  : 				lpTargetObj->DelayLevel = 1;
; 758  : 				gObjAddBuffEffect( lpTargetObj, BUFFTYPE_FREEZE, EFFECTTYPE_REDUCE_MOVE_SPEED, 0, 0, 0, 10 );
; 759  : 			}
; 760  : 			else
; 761  : 			{
; 762  : 				return 0;
; 763  : 			}
; 764  : 		}
; 765  : 		else
; 766  : 		{
; 767  : 			return 0;
; 768  : 		}
; 769  : #else
; 770  : 		if( lpTargetObj->m_ColdBeattackCount == 0 )

  001db	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001de	0f be 88 19 1a
	00 00		 movsx	 ecx, BYTE PTR [eax+6681]
  001e5	85 c9		 test	 ecx, ecx
  001e7	0f 85 83 00 00
	00		 jne	 $LN26@Resistance

; 771  : 		{
; 772  : 			if( retResistance(lpTargetObj, RESISTANCE_COLD ) == FALSE )

  001ed	6a 00		 push	 0
  001ef	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  001f2	50		 push	 eax
  001f3	e8 00 00 00 00	 call	 ?retResistance@@YAHPAVOBJECTSTRUCT@@H@Z ; retResistance
  001f8	83 c4 08	 add	 esp, 8
  001fb	85 c0		 test	 eax, eax
  001fd	75 68		 jne	 SHORT $LN28@Resistance

; 773  : 			{
; 774  : 				lpTargetObj->m_ColdBeattackCount = 10;

  001ff	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00202	c6 80 19 1a 00
	00 0a		 mov	 BYTE PTR [eax+6681], 10	; 0000000aH

; 775  : 				lpTargetObj->lpAttackObj = lpObj;

  00209	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0020c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0020f	89 88 30 02 00
	00		 mov	 DWORD PTR [eax+560], ecx

; 776  : 				lpTargetObj->DelayActionTime = 800;

  00215	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00218	c7 80 1c 02 00
	00 20 03 00 00	 mov	 DWORD PTR [eax+540], 800 ; 00000320H

; 777  : 				lpTargetObj->DelayLevel = 1;

  00222	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00225	c6 80 20 02 00
	00 01		 mov	 BYTE PTR [eax+544], 1

; 778  : 				
; 779  : #ifdef EXPAND_VIEWSKILLSTATE_WORD_TO_INT_20041122
; 780  : 				ADD_VIEWSKILLSTATE( lpTargetObj->m_ViewSkillState, STATE_FREEZE );
; 781  : #else
; 782  : 				lpTargetObj->m_ViewSkillState |= 0x02; //	2번째 비트

  0022c	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0022f	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  00236	83 c9 02	 or	 ecx, 2
  00239	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  0023c	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 783  : #endif
; 784  : 
; 785  : #ifdef ADD_SKILL_WITH_COMBO		
; 786  : 				lpTargetObj->m_IceType = skill;

  00243	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00246	8a 4d 10	 mov	 cl, BYTE PTR _skill$[ebp]
  00249	88 88 22 02 00
	00		 mov	 BYTE PTR [eax+546], cl

; 787  : #ifdef UPDATE_MASTER_LEVEL_4RANK_20080428			// 서든 아이스 강화
; 788  : 				if( skill == AT_SKILL_EXPICE 
; 789  : 					|| skill == AT_SKILL_ML_STRENGTHEN_EXPICE	// 서든 아이스 강화
; 790  : 					)
; 791  : #else	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 792  : 				if( skill == AT_SKILL_EXPICE )

  0024f	83 7d 10 27	 cmp	 DWORD PTR _skill$[ebp], 39 ; 00000027H
  00253	75 10		 jne	 SHORT $LN30@Resistance

; 793  : #endif	// UPDATE_MASTER_LEVEL_4RANK_20080428
; 794  : 				{
; 795  : 					GCStateInfoSend(lpTargetObj, 1, 0x02);

  00255	6a 02		 push	 2
  00257	6a 01		 push	 1
  00259	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0025c	50		 push	 eax
  0025d	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAVOBJECTSTRUCT@@EG@Z ; GCStateInfoSend
  00262	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN30@Resistance:

; 796  : 				}
; 797  : #endif	//#ifdef ADD_SKILL_WITH_COMBO
; 798  : 			}

  00265	eb 07		 jmp	 SHORT $LN29@Resistance
$LN28@Resistance:

; 799  : 			else {
; 800  : 				return 0;

  00267	33 c0		 xor	 eax, eax
  00269	e9 c3 00 00 00	 jmp	 $LN1@Resistance
$LN29@Resistance:

; 801  : 			}
; 802  : 		}

  0026e	eb 07		 jmp	 SHORT $LN27@Resistance
$LN26@Resistance:

; 803  : 		else
; 804  : 		{
; 805  : 			return 0;

  00270	33 c0		 xor	 eax, eax
  00272	e9 ba 00 00 00	 jmp	 $LN1@Resistance
$LN27@Resistance:

; 806  : 		}
; 807  : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004	
; 808  : 	}

  00277	e9 b0 00 00 00	 jmp	 $LN4@Resistance
$LN23@Resistance:

; 809  : 	else if( skill == AT_SKILL_ELFHARDEN )	// 아이스에로우

  0027c	83 7d 10 33	 cmp	 DWORD PTR _skill$[ebp], 51 ; 00000033H
  00280	0f 85 a6 00 00
	00		 jne	 $LN4@Resistance

; 810  : 	{	
; 811  : #ifdef MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 812  : 		if( gObjCheckUsedBuffEffect( lpTargetObj, BUFFTYPE_STONE ) == false )
; 813  : 		{
; 814  : 			if( retResistance( lpTargetObj, RESISTANCE_COLD ) == FALSE )
; 815  : 			{
; 816  : 				gObjAddBuffEffect( lpTargetObj, BUFFTYPE_STONE, 0, 0, 0, 0, 7 );
; 817  : 				lpTargetObj->PathCount = 0;
; 818  : 				lpTargetObj->PathStartEnd = 0;
; 819  : 				gObjSetPosition(lpTargetObj->m_Index, lpTargetObj->X, lpTargetObj->Y);
; 820  : 			}
; 821  : 			else
; 822  : 			{
; 823  : 				return 0;
; 824  : 			}
; 825  : 		}
; 826  : 		else
; 827  : 		{
; 828  : 			return 0;
; 829  : 		}
; 830  : #elif defined(NEW_SKILL_FORSKYLAND)
; 831  : 		if( lpTargetObj->m_SkillHardenTime <= 0 )

  00286	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00289	83 b8 00 1a 00
	00 00		 cmp	 DWORD PTR [eax+6656], 0
  00290	0f 8f 92 00 00
	00		 jg	 $LN32@Resistance

; 832  : 		{	
; 833  : 			if( retResistance(lpTargetObj, RESISTANCE_COLD) == FALSE )

  00296	6a 00		 push	 0
  00298	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0029b	50		 push	 eax
  0029c	e8 00 00 00 00	 call	 ?retResistance@@YAHPAVOBJECTSTRUCT@@H@Z ; retResistance
  002a1	83 c4 08	 add	 esp, 8
  002a4	85 c0		 test	 eax, eax
  002a6	75 7a		 jne	 SHORT $LN34@Resistance

; 834  : 			{	
; 835  : 				// 아이스 애로우 스킬은 이곳에서 성공여부만 판단하고, Miss 체크 후에 
; 836  : 				// 아래 내용을 적용하도록 한다.
; 837  : #ifndef MODIFY_ELF_ICEARROWSKILL_BUGFIX_20060914 // not define
; 838  : 				lpTargetObj->m_SkillHarden = 7;

  002a8	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  002ab	c7 80 fc 19 00
	00 07 00 00 00	 mov	 DWORD PTR [eax+6652], 7

; 839  : 				lpTargetObj->m_SkillHardenTime = 7;

  002b5	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  002b8	c7 80 00 1a 00
	00 07 00 00 00	 mov	 DWORD PTR [eax+6656], 7

; 840  : 
; 841  : 				lpTargetObj->lpAttackObj = lpObj;

  002c2	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  002c5	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002c8	89 88 30 02 00
	00		 mov	 DWORD PTR [eax+560], ecx

; 842  : 				lpTargetObj->m_ViewSkillState |= STATE_HARDEN; //	석화

  002ce	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  002d1	0f b7 88 c0 01
	00 00		 movzx	 ecx, WORD PTR [eax+448]
  002d8	83 c9 20	 or	 ecx, 32			; 00000020H
  002db	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  002de	66 89 8a c0 01
	00 00		 mov	 WORD PTR [edx+448], cx

; 843  : 				lpTargetObj->PathCount = 0;

  002e5	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  002e8	c7 80 28 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+296], 0

; 844  : 
; 845  : 	#ifdef MODIFY_MONSTER_ACT_BY_ICEARROW_20050914
; 846  : 				lpTargetObj->PathStartEnd = 0;

  002f2	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  002f5	c6 80 30 01 00
	00 00		 mov	 BYTE PTR [eax+304], 0

; 847  : 	#endif
; 848  : 
; 849  : 				gObjSetPosition(lpTargetObj->m_Index, lpTargetObj->X, lpTargetObj->Y);

  002fc	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  002ff	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  00306	51		 push	 ecx
  00307	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  0030a	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  00311	50		 push	 eax
  00312	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  00315	8b 11		 mov	 edx, DWORD PTR [ecx]
  00317	52		 push	 edx
  00318	e8 00 00 00 00	 call	 ?gObjSetPosition@@YAXHHH@Z ; gObjSetPosition
  0031d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 850  : #endif // MODIFY_ELF_ICEARROWSKILL_BUGFIX_20060914
; 851  : 			}

  00320	eb 04		 jmp	 SHORT $LN35@Resistance
$LN34@Resistance:

; 852  : 			else
; 853  : 			{
; 854  : 				return 0;

  00322	33 c0		 xor	 eax, eax
  00324	eb 0b		 jmp	 SHORT $LN1@Resistance
$LN35@Resistance:

; 855  : 			}
; 856  : 		}

  00326	eb 04		 jmp	 SHORT $LN4@Resistance
$LN32@Resistance:

; 857  : 		else
; 858  : 		{
; 859  : 			return 0;

  00328	33 c0		 xor	 eax, eax
  0032a	eb 05		 jmp	 SHORT $LN1@Resistance
$LN4@Resistance:

; 860  : 		}
; 861  : #endif // MODIFY_OLD_BUFF_EFFECT_SYSTEM_20071004
; 862  : 	}
; 863  : 
; 864  : 	return 1;

  0032c	b8 01 00 00 00	 mov	 eax, 1
$LN1@Resistance:

; 865  : }

  00331	5f		 pop	 edi
  00332	5e		 pop	 esi
  00333	5b		 pop	 ebx
  00334	8b e5		 mov	 esp, ebp
  00336	5d		 pop	 ebp
  00337	c2 0c 00	 ret	 12			; 0000000cH
?ResistanceCheck@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0H@Z ENDP ; CObjBaseAttack::ResistanceCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ObjBaseAttack.cpp
;	COMDAT ?PkCheck@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
tv191 = -76						; size = 4
tv169 = -76						; size = 4
tv160 = -76						; size = 4
tv192 = -72						; size = 4
tv170 = -72						; size = 4
tv161 = -72						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?PkCheck@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0@Z PROC	; CObjBaseAttack::PkCheck, COMDAT
; _this$ = ecx

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 248  : #ifndef FOR_CHINA
; 249  : //#ifdef FOR_CHINA
; 250  : 	if( gNonPK )		// 중국도 논피케이 서버에서는 몬스터 공격이 안되게 한다

  0000c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gNonPK@@3HA, 0 ; gNonPK
  00013	74 3a		 je	 SHORT $LN2@PkCheck

; 251  : #else
; 252  : //	#ifdef FOR_TAIWAN	// 대만도 한국 설정과 같이 가도록 요청옴 20050914 (b4nfter)
; 253  : //		if( gNonPK )	// 대만은 논피케이 서버에서만 살인마가 몬스터 공격이 안되게 한다
; 254  : //	#else
; 255  : 			if( gLanguage == 0 || gLanguage == 2 || gLanguage == 4)
; 256  : //	#endif
; 257  : #endif
; 258  : 	{
; 259  : 		// 살인마는 몬스터도 공격도 할 수 없다.
; 260  : 		if( lpObj->Type == OBJTYPE_CHARACTER )

  00015	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00018	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0001c	83 f9 01	 cmp	 ecx, 1
  0001f	75 2e		 jne	 SHORT $LN2@PkCheck

; 261  : 		{
; 262  : #ifdef UPDATE_PK_SYSTEM_20070302	// 살인마는 몬스터를 공격할수도 공격 받을 수도 없음
; 263  : 			BOOL	PKFlag = FALSE;
; 264  : 			if(lpObj->PartyNumber >= 0)	// 파티에 속할경우
; 265  : 			{
; 266  : 				if( gParty.GetPKPartyPenalty(lpObj->PartyNumber) >= PK_LEVEL_DEFAULT+3)
; 267  : 				{
; 268  : 					PKFlag = TRUE;
; 269  : 				}
; 270  : 			}
; 271  : 			else
; 272  : 			{
; 273  : 				if(lpObj->m_PK_Level >= PK_LEVEL_DEFAULT+3)
; 274  : 				{
; 275  : 					PKFlag = TRUE;
; 276  : 				}
; 277  : 			}
; 278  : 
; 279  : 			if(PKFlag == TRUE)
; 280  : #else
; 281  : 			if( lpObj->m_PK_Level >= PK_LEVEL_DEFAULT+3 ) 

  00021	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00024	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  0002b	83 f9 06	 cmp	 ecx, 6
  0002e	7c 1f		 jl	 SHORT $LN2@PkCheck

; 282  : #endif
; 283  : 			{
; 284  : #ifdef UPDATE_PK_SYSTEM_20070302	//파티에 속해 있해 있고 파티 PK레벨3일 경우 공격 안됨
; 285  : 				if(lpObj->PartyNumber >= 0)	// 파티에 속할경우
; 286  : 				{
; 287  : 					if (!gPkLimitFree)
; 288  : 						return FALSE;
; 289  : 				}
; 290  : 				else
; 291  : 				{
; 292  : 					if( lpObj->m_PK_Count >= 3 ) 
; 293  : 					{
; 294  : 	#ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 295  : 						if (!gPkLimitFree)
; 296  : 	#endif
; 297  : 						return FALSE;
; 298  : 					}
; 299  : 				}
; 300  : #else	// UPDATE_PK_SYSTEM_20070302
; 301  : 				if( lpObj->m_PK_Count >= 3 ) 

  00030	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00033	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  0003a	83 f9 03	 cmp	 ecx, 3
  0003d	7c 10		 jl	 SHORT $LN2@PkCheck

; 302  : 				{
; 303  : #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 304  : 					if (!gPkLimitFree)

  0003f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  00046	75 07		 jne	 SHORT $LN2@PkCheck

; 305  : #endif
; 306  : 					return FALSE;

  00048	33 c0		 xor	 eax, eax
  0004a	e9 d8 02 00 00	 jmp	 $LN1@PkCheck
$LN2@PkCheck:

; 307  : 				}
; 308  : #endif	// UPDATE_PK_SYSTEM_20070302
; 309  : 			}
; 310  : 		}
; 311  : 	}
; 312  : 
; 313  : 	////////////////////////////////////////////////////////////////////////////////
; 314  : 	// 사용자끼리 싸울때 
; 315  : 	if( lpObj->Type	  == OBJTYPE_CHARACTER && 

  0004f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00052	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00056	83 f9 01	 cmp	 ecx, 1
  00059	0f 85 c3 02 00
	00		 jne	 $LN7@PkCheck
  0005f	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00062	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00066	83 f9 01	 cmp	 ecx, 1
  00069	0f 85 b3 02 00
	00		 jne	 $LN7@PkCheck

; 316  : 		lpTargetObj->Type == OBJTYPE_CHARACTER )
; 317  : 	{
; 318  : 		// PK최소 레벨 이하는 죽이지 못한다.	
; 319  : 		if( lpTargetObj->Level  <= PK_MINIMUM_LEVEL || 

  0006f	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00072	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00079	83 f9 05	 cmp	 ecx, 5
  0007c	7e 0f		 jle	 SHORT $LN9@PkCheck
  0007e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00081	0f bf 88 a0 00
	00 00		 movsx	 ecx, WORD PTR [eax+160]
  00088	83 f9 05	 cmp	 ecx, 5
  0008b	7f 07		 jg	 SHORT $LN8@PkCheck
$LN9@PkCheck:

; 320  : 			lpObj->Level    <= PK_MINIMUM_LEVEL )
; 321  : 		{
; 322  : 			return FALSE;

  0008d	33 c0		 xor	 eax, eax
  0008f	e9 93 02 00 00	 jmp	 $LN1@PkCheck
$LN8@PkCheck:

; 323  : 		}
; 324  : 
; 325  : 
; 326  : #ifdef ADD_NEW_UNION_01_20041006
; 327  : 		// ★★★ 적대일 경우 공격 할 수 있음.
; 328  : 		if( gObjGetRelationShip(lpObj, lpTargetObj) == G_RELATIONSHIP_RIVAL )
; 329  : 		{
; 330  : 			// NON PVP 서버에서는 적대 공격 안됨.
; 331  : 			if( !gNonPK ) return TRUE;
; 332  : 		}
; 333  : #endif
; 334  : 
; 335  : 
; 336  : //#ifdef APPLY_TESTSERVER
; 337  : 		// 길드전 시 같은 길드원 공격 않되게 (b4nfter - 2003-09-30)
; 338  : 		if( lpObj->lpGuild && lpTargetObj->lpGuild )

  00094	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00097	83 b8 94 02 00
	00 00		 cmp	 DWORD PTR [eax+660], 0
  0009e	74 55		 je	 SHORT $LN10@PkCheck
  000a0	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000a3	83 b8 94 02 00
	00 00		 cmp	 DWORD PTR [eax+660], 0
  000aa	74 49		 je	 SHORT $LN10@PkCheck

; 339  : 		{
; 340  : 			if (( lpObj->lpGuild->WarState == 1 && lpTargetObj->lpGuild->WarState == 1 ) &&

  000ac	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000af	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  000b5	0f b6 91 91 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1425]
  000bc	83 fa 01	 cmp	 edx, 1
  000bf	75 34		 jne	 SHORT $LN10@PkCheck
  000c1	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000c4	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  000ca	0f b6 91 91 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1425]
  000d1	83 fa 01	 cmp	 edx, 1
  000d4	75 1f		 jne	 SHORT $LN10@PkCheck
  000d6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000d9	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  000df	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  000e2	8b 82 94 02 00
	00		 mov	 eax, DWORD PTR [edx+660]
  000e8	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000ea	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000ec	75 07		 jne	 SHORT $LN10@PkCheck

; 341  : 				(lpObj->lpGuild->Number == lpTargetObj->lpGuild->Number)
; 342  : 				)
; 343  : 			{
; 344  : 				// 현재 길드전 중 이고 같은 길드원이라면 공격않됨
; 345  : 				return FALSE;

  000ee	33 c0		 xor	 eax, eax
  000f0	e9 32 02 00 00	 jmp	 $LN1@PkCheck
$LN10@PkCheck:

; 346  : 			}
; 347  : 		}
; 348  : 
; 349  : 		// 길드전 중인 사람도 못 때리게
; 350  : 		if (
; 351  : #ifdef _NEW_EXDB_
; 352  : 			!gObjTargetGuildWarCheck(lpObj, lpTargetObj) &&
; 353  : #endif
; 354  : 			lpTargetObj->lpGuild && 

  000f5	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  000f8	50		 push	 eax
  000f9	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000fc	51		 push	 ecx
  000fd	e8 00 00 00 00	 call	 ?gObjTargetGuildWarCheck@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjTargetGuildWarCheck
  00102	83 c4 08	 add	 esp, 8
  00105	85 c0		 test	 eax, eax
  00107	0f 85 a9 00 00
	00		 jne	 $LN12@PkCheck
  0010d	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00110	83 b8 94 02 00
	00 00		 cmp	 DWORD PTR [eax+660], 0
  00117	0f 84 99 00 00
	00		 je	 $LN12@PkCheck
  0011d	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00120	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  00126	0f b6 91 91 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1425]
  0012d	85 d2		 test	 edx, edx
  0012f	0f 84 81 00 00
	00		 je	 $LN12@PkCheck

; 355  : 			lpTargetObj->lpGuild->WarState
; 356  : 			) 
; 357  : 		{
; 358  : 
; 359  : #ifdef MODIFY_BATTLESOCCER_PKCHECK_20050714
; 360  : 			// 배틀사커 걸어 놓고 다른 맵에서 공격 안당하는 버그 수정
; 361  : 			if ( lpTargetObj->lpGuild->WarType == BTT_SOCCER )

  00135	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00138	8b 88 94 02 00
	00		 mov	 ecx, DWORD PTR [eax+660]
  0013e	0f b6 91 92 05
	00 00		 movzx	 edx, BYTE PTR [ecx+1426]
  00145	83 fa 01	 cmp	 edx, 1
  00148	75 22		 jne	 SHORT $LN13@PkCheck

; 362  : 			{
; 363  : 				 if( lpTargetObj->MapNumber != 6 )

  0014a	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0014d	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00154	83 f9 06	 cmp	 ecx, 6
  00157	74 13		 je	 SHORT $LN13@PkCheck

; 364  : 					 if( !gNonPK ) return TRUE;

  00159	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gNonPK@@3HA, 0 ; gNonPK
  00160	75 0a		 jne	 SHORT $LN13@PkCheck
  00162	b8 01 00 00 00	 mov	 eax, 1
  00167	e9 bb 01 00 00	 jmp	 $LN1@PkCheck
$LN13@PkCheck:

; 365  : 			}
; 366  : #endif
; 367  : 			
; 368  : #ifdef CHAOSCASTLE_SYSTEM_20040408		// 길드전 중이라고 해도 카오스 캐슬 안에 있다면 공격이 되어야 한다.
; 369  : 			if (!CHECK_CHAOSCASTLE(lpTargetObj->MapNumber))

  0016c	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0016f	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00176	83 f9 12	 cmp	 ecx, 18			; 00000012H
  00179	7d 09		 jge	 SHORT $LN34@PkCheck
  0017b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv161[ebp], 0
  00182	eb 25		 jmp	 SHORT $LN35@PkCheck
$LN34@PkCheck:
  00184	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00187	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  0018e	83 f8 17	 cmp	 eax, 23			; 00000017H
  00191	7e 09		 jle	 SHORT $LN32@PkCheck
  00193	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv160[ebp], 0
  0019a	eb 07		 jmp	 SHORT $LN33@PkCheck
$LN32@PkCheck:
  0019c	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv160[ebp], 1
$LN33@PkCheck:
  001a3	8b 4d b4	 mov	 ecx, DWORD PTR tv160[ebp]
  001a6	89 4d b8	 mov	 DWORD PTR tv161[ebp], ecx
$LN35@PkCheck:
  001a9	83 7d b8 00	 cmp	 DWORD PTR tv161[ebp], 0
  001ad	75 07		 jne	 SHORT $LN12@PkCheck

; 370  : #endif			
; 371  : 			return FALSE;

  001af	33 c0		 xor	 eax, eax
  001b1	e9 71 01 00 00	 jmp	 $LN1@PkCheck
$LN12@PkCheck:

; 372  : 
; 373  : 		}
; 374  : //#endif
; 375  : 
; 376  : #ifdef ADD_EVENT_MAP_ILLUSION_TEMPLE_20070328	// 환영 사원에서는 pk가 허용됨
; 377  : 		if(CHECK_ILLUSION_TEMPLE(lpObj->MapNumber))
; 378  : 		{
; 379  : 			
; 380  : 		}
; 381  : 		else
; 382  : #endif
; 383  : 
; 384  : #ifdef CHAOSCASTLE_SYSTEM_20040408
; 385  : 	#ifndef WORLD_TOURNAMENT_EVENT_SETTING
; 386  : 		if(CHECK_CHAOSCASTLE(lpObj->MapNumber))

  001b6	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001b9	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  001c0	83 f9 12	 cmp	 ecx, 18			; 00000012H
  001c3	7d 09		 jge	 SHORT $LN38@PkCheck
  001c5	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv170[ebp], 0
  001cc	eb 25		 jmp	 SHORT $LN39@PkCheck
$LN38@PkCheck:
  001ce	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  001d1	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  001d8	83 f8 17	 cmp	 eax, 23			; 00000017H
  001db	7e 09		 jle	 SHORT $LN36@PkCheck
  001dd	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv169[ebp], 0
  001e4	eb 07		 jmp	 SHORT $LN37@PkCheck
$LN36@PkCheck:
  001e6	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv169[ebp], 1
$LN37@PkCheck:
  001ed	8b 4d b4	 mov	 ecx, DWORD PTR tv169[ebp]
  001f0	89 4d b8	 mov	 DWORD PTR tv170[ebp], ecx
$LN39@PkCheck:
  001f3	83 7d b8 00	 cmp	 DWORD PTR tv170[ebp], 0
  001f7	74 26		 je	 SHORT $LN17@PkCheck

; 387  : 		{	// 카오스 캐슬에서는 경기시간이 아니면 죽일 수 없다
; 388  : #ifdef ADD_CHAOSCASTLE_FOR_MASTER_LEVEL_20071010	// 카오스캐슬 번호 구하기
; 389  : 			if (g_ChaosCastle.GetCurrentState( g_ChaosCastle.GetChaosCastleByMapNum( lpObj->MapNumber ) ) != CHAOSCASTLE_STATE_PLAYING)
; 390  : 				return FALSE;
; 391  : #else
; 392  : 			if (g_ChaosCastle.GetCurrentState(lpObj->MapNumber - MAP_INDEX_CHAOSCASTLE1) != CHAOSCASTLE_STATE_PLAYING)

  001f9	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001fc	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00203	83 e9 12	 sub	 ecx, 18			; 00000012H
  00206	51		 push	 ecx
  00207	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  0020c	e8 00 00 00 00	 call	 ?GetCurrentState@CChaosCastle@@QAEHH@Z ; CChaosCastle::GetCurrentState
  00211	83 f8 02	 cmp	 eax, 2
  00214	74 07		 je	 SHORT $LN19@PkCheck

; 393  : 				return FALSE;

  00216	33 c0		 xor	 eax, eax
  00218	e9 0a 01 00 00	 jmp	 $LN1@PkCheck
$LN19@PkCheck:

; 394  : #endif
; 395  : 		}

  0021d	eb 10		 jmp	 SHORT $LN18@PkCheck
$LN17@PkCheck:

; 396  : 		else	// NON PK 서버에서도 죽일 수 있어야 한다.
; 397  : 	#endif
; 398  : #endif
; 399  : 		// NonPK 서버는 죽이지 못한다
; 400  : 		if( gNonPK ) return FALSE;

  0021f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gNonPK@@3HA, 0 ; gNonPK
  00226	74 07		 je	 SHORT $LN18@PkCheck
  00228	33 c0		 xor	 eax, eax
  0022a	e9 f8 00 00 00	 jmp	 $LN1@PkCheck
$LN18@PkCheck:

; 401  : 
; 402  : #ifdef DEVILSQUARE_EXTEND_20050221		// 데빌스퀘어 맵번호 체크 수정
; 403  : 		if( CHECK_DEVILSQUARE(lpObj->MapNumber) && lpObj->m_stateEngagePVP != PVP_USER_PLAYING )
; 404  : #else
; 405  : 		if( lpObj->MapNumber == MAP_INDEX_DEVILSQUARE && lpObj->m_stateEngagePVP != PVP_USER_PLAYING )

  0022f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00232	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  00239	83 f9 09	 cmp	 ecx, 9
  0023c	75 13		 jne	 SHORT $LN21@PkCheck
  0023e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00241	83 b8 80 1a 00
	00 02		 cmp	 DWORD PTR [eax+6784], 2
  00248	74 07		 je	 SHORT $LN21@PkCheck

; 406  : #endif
; 407  : 		{	// 악마의 광장에서는 죽일수 없다
; 408  : 			return FALSE;

  0024a	33 c0		 xor	 eax, eax
  0024c	e9 d6 00 00 00	 jmp	 $LN1@PkCheck
$LN21@PkCheck:

; 409  : 		}
; 410  : 
; 411  : #ifdef FOR_BLOODCASTLE
; 412  : 		if(CHECK_BLOODCASTLE(lpObj->MapNumber))

  00251	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00254	0f b6 88 09 01
	00 00		 movzx	 ecx, BYTE PTR [eax+265]
  0025b	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  0025e	7d 09		 jge	 SHORT $LN42@PkCheck
  00260	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv192[ebp], 0
  00267	eb 25		 jmp	 SHORT $LN43@PkCheck
$LN42@PkCheck:
  00269	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0026c	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  00273	83 f8 11	 cmp	 eax, 17			; 00000011H
  00276	7e 09		 jle	 SHORT $LN40@PkCheck
  00278	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv191[ebp], 0
  0027f	eb 07		 jmp	 SHORT $LN41@PkCheck
$LN40@PkCheck:
  00281	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv191[ebp], 1
$LN41@PkCheck:
  00288	8b 4d b4	 mov	 ecx, DWORD PTR tv191[ebp]
  0028b	89 4d b8	 mov	 DWORD PTR tv192[ebp], ecx
$LN43@PkCheck:
  0028e	83 7d b8 00	 cmp	 DWORD PTR tv192[ebp], 0
  00292	74 07		 je	 SHORT $LN22@PkCheck

; 413  : 		{	// 블러드 캐슬에서도 역시 죽일수 없다
; 414  : 			return FALSE;

  00294	33 c0		 xor	 eax, eax
  00296	e9 8c 00 00 00	 jmp	 $LN1@PkCheck
$LN22@PkCheck:

; 415  : 		}
; 416  : #endif
; 417  : 
; 418  : 		
; 419  : #ifdef DUEL_SYSTEM_20031028
; 420  : 		if (!gObjDuelCheck(lpObj, lpTargetObj) &&

  0029b	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0029e	50		 push	 eax
  0029f	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  002a2	51		 push	 ecx
  002a3	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@0@Z ; gObjDuelCheck
  002a8	83 c4 08	 add	 esp, 8
  002ab	85 c0		 test	 eax, eax
  002ad	75 14		 jne	 SHORT $LN23@PkCheck
  002af	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  002b2	50		 push	 eax
  002b3	e8 00 00 00 00	 call	 ?gObjDuelCheck@@YAHPAVOBJECTSTRUCT@@@Z ; gObjDuelCheck
  002b8	83 c4 04	 add	 esp, 4
  002bb	85 c0		 test	 eax, eax
  002bd	74 04		 je	 SHORT $LN23@PkCheck

; 421  : 			gObjDuelCheck(lpTargetObj)
; 422  : 			) 
; 423  : 		{
; 424  : 			// 결투 중인 사용자를 공격할 수 없다.
; 425  : 			return FALSE;

  002bf	33 c0		 xor	 eax, eax
  002c1	eb 64		 jmp	 SHORT $LN1@PkCheck
$LN23@PkCheck:

; 426  : 		}
; 427  : 
; 428  : #endif
; 429  : 
; 430  : 		if( gLanguage > 6)

  002c3	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR ?gLanguage@@3HA, 6 ; gLanguage
  002ca	7e 56		 jle	 SHORT $LN7@PkCheck

; 431  : 		{
; 432  : 			// 살인마는 살인을 할 수 없다.
; 433  : #ifdef UPDATE_PK_SYSTEM_20070302	// 살인마는 살인을 못함
; 434  : 			BOOL	PKFlag = FALSE;
; 435  : 			if(lpObj->PartyNumber >= 0)	// 파티에 속할경우
; 436  : 			{
; 437  : 				if( gParty.GetPKPartyPenalty(lpObj->PartyNumber) >= PK_LEVEL_DEFAULT+3)
; 438  : 				{
; 439  : 					PKFlag = TRUE;
; 440  : 				}
; 441  : 			}
; 442  : 			else
; 443  : 			{
; 444  : 				if(lpObj->m_PK_Level >= PK_LEVEL_DEFAULT+3)
; 445  : 				{
; 446  : 					PKFlag = TRUE;
; 447  : 				}
; 448  : 			}
; 449  : 			
; 450  : 			if(PKFlag == TRUE)
; 451  : #else	// UPDATE_PK_SYSTEM_20070302
; 452  : 			if( lpObj->m_PK_Level >= PK_LEVEL_DEFAULT+3 ) 

  002cc	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002cf	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  002d6	83 f9 06	 cmp	 ecx, 6
  002d9	7c 1c		 jl	 SHORT $LN25@PkCheck

; 453  : #endif	// UPDATE_PK_SYSTEM_20070302
; 454  : 			{
; 455  : #ifdef UPDATE_PK_SYSTEM_20070302	//파티에 속해 있해 있고 파티 PK레벨3일 경우
; 456  : 				if(lpObj->PartyNumber >= 0)	// 파티에 속할경우
; 457  : 				{
; 458  : 					if (!gPkLimitFree)
; 459  : 						return FALSE;
; 460  : 				}
; 461  : 				else
; 462  : 				{
; 463  : 					if( lpObj->m_PK_Count >= 3 ) 
; 464  : 					{
; 465  : 	#ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 466  : 						if (!gPkLimitFree)
; 467  : 	#endif
; 468  : 						return FALSE;
; 469  : 					}
; 470  : 				}
; 471  : #else	// UPDATE_PK_SYSTEM_20070302
; 472  : 				if( lpObj->m_PK_Count >= 3 ) 

  002db	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002de	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  002e5	83 f9 03	 cmp	 ecx, 3
  002e8	7c 0d		 jl	 SHORT $LN25@PkCheck

; 473  : 				{
; 474  : #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 475  : 					if (!gPkLimitFree)

  002ea	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  002f1	75 04		 jne	 SHORT $LN25@PkCheck

; 476  : #endif
; 477  : 					return FALSE;

  002f3	33 c0		 xor	 eax, eax
  002f5	eb 30		 jmp	 SHORT $LN1@PkCheck
$LN25@PkCheck:

; 478  : 				}
; 479  : #endif	// UPDATE_PK_SYSTEM_20070302
; 480  : 			}
; 481  : #ifndef HERO_SYSTEM_MODIFY
; 482  : #ifdef UPDATE_PK_SYSTEM_20070302	// 살인마는 살인을 못함
; 483  : 			PKFlag = FALSE;
; 484  : 			if(lpTargetObj->PartyNumber >= 0)	// 파티에 속할경우
; 485  : 			{
; 486  : 				if( gParty.GetPKPartyPenalty(lpTargetObj->PartyNumber) >= PK_LEVEL_DEFAULT+3)
; 487  : 				{
; 488  : 					PKFlag = TRUE;
; 489  : 				}
; 490  : 			}
; 491  : 			else
; 492  : 			{
; 493  : 				if(lpTargetObj->m_PK_Level >= PK_LEVEL_DEFAULT+3)
; 494  : 				{
; 495  : 					PKFlag = TRUE;
; 496  : 				}
; 497  : 			}
; 498  : 			
; 499  : 			if(PKFlag == TRUE)
; 500  : #else	// UPDATE_PK_SYSTEM_20070302
; 501  : 			if( lpTargetObj->m_PK_Level >= PK_LEVEL_DEFAULT+3 ) 

  002f7	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  002fa	0f be 88 fd 00
	00 00		 movsx	 ecx, BYTE PTR [eax+253]
  00301	83 f9 06	 cmp	 ecx, 6
  00304	7c 1c		 jl	 SHORT $LN7@PkCheck

; 502  : #endif	// UPDATE_PK_SYSTEM_20070302
; 503  : 			{ 
; 504  : #ifdef UPDATE_PK_SYSTEM_20070302
; 505  : 				if(lpTargetObj->PartyNumber >= 0)	// 파티에 속할경우
; 506  : 				{
; 507  : #ifdef MODIFY_PK_SYSTEM_BUGFIX_2_20070731	// 공성전 중에는 풀카오 사용자도 죽일 수 있다.
; 508  : 					if (!gPkLimitFree)	
; 509  : 					{
; 510  : #ifdef GAMESERVER_TO_CASTLESIEGESERVER			// 공성전 중에는 풀카오 사용자도 죽일 수 있다.
; 511  : 						if (g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_STARTSIEGE)
; 512  : #endif	
; 513  : 							return FALSE;
; 514  : 					}
; 515  : #else					
; 516  : 					if (!gPkLimitFree)
; 517  : 						return FALSE;
; 518  : #endif
; 519  : 				}
; 520  : 				else
; 521  : 				{
; 522  : 					if( lpTargetObj->m_PK_Count >= 3 ) 
; 523  : 					{
; 524  : #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 525  : 						if (!gPkLimitFree)	{
; 526  : #endif
; 527  : #ifdef GAMESERVER_TO_CASTLESIEGESERVER			// 공성전 중에는 풀카오 사용자도 죽일 수 있다.
; 528  : 							if (g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_STARTSIEGE)
; 529  : #endif			
; 530  : 								return FALSE;
; 531  : #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 532  : 						}
; 533  : #endif
; 534  : 					}
; 535  : 				}
; 536  : #else	// UPDATE_PK_SYSTEM_20070302
; 537  : 				if( lpTargetObj->m_PK_Count >= 3 ) 

  00306	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00309	0f be 88 fc 00
	00 00		 movsx	 ecx, BYTE PTR [eax+252]
  00310	83 f9 03	 cmp	 ecx, 3
  00313	7c 0d		 jl	 SHORT $LN7@PkCheck

; 538  : 				{
; 539  : #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 540  : 					if (!gPkLimitFree)	{

  00315	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  0031c	75 04		 jne	 SHORT $LN7@PkCheck

; 541  : #endif
; 542  : #ifdef GAMESERVER_TO_CASTLESIEGESERVER			// 공성전 중에는 풀카오 사용자도 죽일 수 있다.
; 543  : 					if (g_CastleSiege.GetCastleState() != CASTLESIEGE_STATE_STARTSIEGE)
; 544  : #endif			
; 545  : 					return FALSE;

  0031e	33 c0		 xor	 eax, eax
  00320	eb 05		 jmp	 SHORT $LN1@PkCheck
$LN7@PkCheck:

; 546  : #ifdef ADD_PK_LIMIT_FREE_OPTION_20050324
; 547  : 					}
; 548  : #endif
; 549  : 				}
; 550  : #endif	// UPDATE_PK_SYSTEM_20070302
; 551  : 			}
; 552  : #endif			
; 553  : 		}
; 554  : 	}
; 555  : 	return TRUE;

  00322	b8 01 00 00 00	 mov	 eax, 1
$LN1@PkCheck:

; 556  : }

  00327	5f		 pop	 edi
  00328	5e		 pop	 esi
  00329	5b		 pop	 ebx
  0032a	8b e5		 mov	 esp, ebp
  0032c	5d		 pop	 ebp
  0032d	c2 08 00	 ret	 8
?PkCheck@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0@Z ENDP	; CObjBaseAttack::PkCheck
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ObjBaseAttack.cpp
;	COMDAT ?CheckAttackArea@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_attackret$1 = -12					; size = 4
_attr$2 = -5						; size = 1
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
_lpTargetObj$ = 12					; size = 4
?CheckAttackArea@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0@Z PROC ; CObjBaseAttack::CheckAttackArea, COMDAT
; _this$ = ecx

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 149  : #ifdef WORLD_TOURNAMENT_EVENT_SETTING		
; 150  : 	return TRUE;
; 151  : #endif
; 152  : 	////////////////////////////////////////////////////////////////////////////////
; 153  : 	if( lpTargetObj->Type == OBJTYPE_CHARACTER || (lpTargetObj->m_RecallMon>=0))

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0000f	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00013	83 f9 01	 cmp	 ecx, 1
  00016	74 0c		 je	 SHORT $LN3@CheckAttac
  00018	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  0001b	83 b8 a4 02 00
	00 00		 cmp	 DWORD PTR [eax+676], 0
  00022	7c 44		 jl	 SHORT $LN2@CheckAttac
$LN3@CheckAttac:

; 154  : 	{
; 155  : 		// 캐릭터는 안전지대에 있을때에는 죽지 않게한다.
; 156  : 		BYTE attr= MapC[lpTargetObj->MapNumber].GetAttr(lpTargetObj->X, lpTargetObj->Y);

  00024	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00027	0f bf 88 06 01
	00 00		 movsx	 ecx, WORD PTR [eax+262]
  0002e	51		 push	 ecx
  0002f	8b 55 0c	 mov	 edx, DWORD PTR _lpTargetObj$[ebp]
  00032	0f bf 82 04 01
	00 00		 movsx	 eax, WORD PTR [edx+260]
  00039	50		 push	 eax
  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR _lpTargetObj$[ebp]
  0003d	0f b6 91 09 01
	00 00		 movzx	 edx, BYTE PTR [ecx+265]
  00044	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  0004a	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  00050	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00055	88 45 fb	 mov	 BYTE PTR _attr$2[ebp], al

; 157  : 
; 158  : 		if( (attr&MAP_ATTR_SAFTYZONE) == MAP_ATTR_SAFTYZONE) // 안전지대일땐..

  00058	0f b6 45 fb	 movzx	 eax, BYTE PTR _attr$2[ebp]
  0005c	83 e0 01	 and	 eax, 1
  0005f	74 07		 je	 SHORT $LN2@CheckAttac

; 159  : 			return FALSE;

  00061	33 c0		 xor	 eax, eax
  00063	e9 8d 00 00 00	 jmp	 $LN1@CheckAttac
$LN2@CheckAttac:

; 160  : 	}
; 161  : 
; 162  : 	// 캐릭터도 안전지대와 못가는 지역에선 공격이 안된다.
; 163  : 	if( lpObj->Type == OBJTYPE_CHARACTER )

  00068	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0006b	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  0006f	83 f9 01	 cmp	 ecx, 1
  00072	75 7c		 jne	 SHORT $LN5@CheckAttac

; 164  : 	{
; 165  : 		//attr= MapC[lpObj->MapNumber].GetAttr(lpObj->X, lpObj->Y);
; 166  : 		//if( (attr&MAP_ATTR_SAFTYZONE) == MAP_ATTR_SAFTYZONE || (attr&MAP_ATTR_BLOCK) == MAP_ATTR_BLOCK ) return FALSE;
; 167  : 		// 공격 가능한 지역인지 검사
; 168  : 		int attackret = gObjCheckAttackArea(lpObj->m_Index, lpTargetObj->m_Index);

  00074	8b 45 0c	 mov	 eax, DWORD PTR _lpTargetObj$[ebp]
  00077	8b 08		 mov	 ecx, DWORD PTR [eax]
  00079	51		 push	 ecx
  0007a	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0007d	8b 02		 mov	 eax, DWORD PTR [edx]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ?gObjCheckAttackArea@@YAHHH@Z ; gObjCheckAttackArea
  00085	83 c4 08	 add	 esp, 8
  00088	89 45 f4	 mov	 DWORD PTR _attackret$1[ebp], eax

; 169  : 		if( attackret )

  0008b	83 7d f4 00	 cmp	 DWORD PTR _attackret$1[ebp], 0
  0008f	74 5f		 je	 SHORT $LN5@CheckAttac

; 170  : 		{
; 171  : 
; 172  : #ifdef CHECK_ATTACK_AREA
; 173  : 			lpObj->m_NotAttackAreaCount++;
; 174  : 
; 175  : 	#ifdef MODIFY_HACKLOG_OF_ATTACK_20050518
; 176  : 			lpObj->m_NotAttackAreaCountFor10Min++;
; 177  : 	#endif
; 178  : 			
; 179  : 	#ifdef CHINA_HACKUSER_KICK_SYSTEM			
; 180  : 			ChinaHackUserKick.InsertCataNCount(lpObj->m_Index);
; 181  : 	#endif
; 182  : 
; 183  : 			if( gIsKickNotAttackAreaCountLimit )
; 184  : 			{	// 시도 횟수가 일정이상 넘어 가면 킥이 가능하면
; 185  : 	#ifdef MODIFY_HACKLOG_OF_ATTACK_20050518			
; 186  : 				if( lpObj->m_NotAttackAreaCountFor10Min >= gNotAttackAreaKickCount )
; 187  : 				{
; 188  : 		#ifdef CHINA_HACKUSER_KICK_SYSTEM
; 189  : 					ChinaHackLogFile.Output("[%s][%s] Kick NotAttackAreaKickCount Over User (%d) @%d", 
; 190  : 						                    lpObj->AccountID,
; 191  : 											lpObj->Name,
; 192  : 											lpObj->m_NotAttackAreaCount,
; 193  : 											lpObj->MapNumber);
; 194  : 		#else
; 195  : 					LogAddTD("[%s][%s] Kick NotAttackAreaKickCount Over User (%d, %d) @%d", 
; 196  : 							 lpObj->AccountID, 
; 197  : 							 lpObj->Name, 
; 198  : 							 lpObj->m_NotAttackAreaCountFor10Min, 
; 199  : 							 lpObj->m_NotAttackAreaCount,
; 200  : 							 lpObj->MapNumber);
; 201  : 		#endif
; 202  : 					CloseClient(lpObj->m_Index);					
; 203  : 					return FALSE;
; 204  : 				}			
; 205  : 	#else // else MODIFY_HACKLOG_OF_ATTACK_20050518
; 206  : 				if( lpObj->m_NotAttackAreaCount >= gNotAttackAreaKickCount )
; 207  : 				{
; 208  : 		#ifdef CHINA_HACKUSER_KICK_SYSTEM
; 209  : 					ChinaHackLogFile.Output("[%s][%s] Kick NotAttackAreaKickCount Over User (%d)", 
; 210  : 											lpObj->AccountID, lpObj->Name, lpObj->m_NotAttackAreaCount);
; 211  : 		#else
; 212  : 					LogAddTD("[%s][%s] Kick NotAttackAreaKickCount Over User (%d)", 
; 213  : 							  lpObj->AccountID, lpObj->Name, lpObj->m_NotAttackAreaCount);					
; 214  : 		#endif
; 215  : 					CloseClient(lpObj->m_Index);					
; 216  : 					return FALSE;
; 217  : 				}
; 218  : 	#endif // MODIFY_HACKLOG_OF_ATTACK_20050518
; 219  : 			}
; 220  : #else // else CHECK_ATTACK_AREA
; 221  : 
; 222  : 	#ifdef MODIFY_LOG_OF_HACK_20050607
; 223  : 			lpObj->m_NotAttackAreaCount++;
; 224  : 			if( lpObj->m_NotAttackAreaCount % 100 == 0 )
; 225  : 			{
; 226  : 				LogAddTD("[%s][%s] Try Attack In Not Attack Area (%d) (%s,%d,%d) errortype = %d", 
; 227  : 				         lpObj->AccountID, lpObj->Name, lpObj->m_NotAttackAreaCount, lMsg.Get(lpObj->MapNumber+2000), lpObj->X, lpObj->Y, attackret);
; 228  : 			}
; 229  : 	#else
; 230  : 			LogAddTD("[%s][%s] Try Attack In Not Attack Area (%s,%d,%d) errortype = %d", 

  00091	8b 45 f4	 mov	 eax, DWORD PTR _attackret$1[ebp]
  00094	50		 push	 eax
  00095	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00098	0f bf 91 06 01
	00 00		 movsx	 edx, WORD PTR [ecx+262]
  0009f	52		 push	 edx
  000a0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a3	0f bf 88 04 01
	00 00		 movsx	 ecx, WORD PTR [eax+260]
  000aa	51		 push	 ecx
  000ab	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000ae	0f b6 82 09 01
	00 00		 movzx	 eax, BYTE PTR [edx+265]
  000b5	05 d0 07 00 00	 add	 eax, 2000		; 000007d0H
  000ba	50		 push	 eax
  000bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VCMsg@@A ; lMsg
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Get@CMsg@@QAEPADH@Z
  000c6	50		 push	 eax
  000c7	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  000ca	83 c1 73	 add	 ecx, 115		; 00000073H
  000cd	51		 push	 ecx
  000ce	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  000d1	83 c2 68	 add	 edx, 104		; 00000068H
  000d4	52		 push	 edx
  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@NNCLBAOH@?$FL?$CFs?$FN?$FL?$CFs?$FN?5Try?5Attack?5In?5Not?5Atta@
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e0	83 c4 1c	 add	 esp, 28			; 0000001cH

; 231  : 				    lpObj->AccountID, lpObj->Name, lMsg.Get(lpObj->MapNumber+2000), lpObj->X, lpObj->Y, attackret);
; 232  : 	#endif
; 233  : 
; 234  : #endif // CHECK_ATTACK_AREA
; 235  : 
; 236  : 			if( bIsIgnorePacketSpeedHackDetect )

  000e3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bIsIgnorePacketSpeedHackDetect@@3HA, 0 ; bIsIgnorePacketSpeedHackDetect
  000ea	74 04		 je	 SHORT $LN5@CheckAttac

; 237  : 			{
; 238  : 				return FALSE;

  000ec	33 c0		 xor	 eax, eax
  000ee	eb 05		 jmp	 SHORT $LN1@CheckAttac
$LN5@CheckAttac:

; 239  : 			}
; 240  : 		}
; 241  : 	}	
; 242  : 
; 243  : 	return TRUE;

  000f0	b8 01 00 00 00	 mov	 eax, 1
$LN1@CheckAttac:

; 244  : }

  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx
  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c2 08 00	 ret	 8
?CheckAttackArea@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@0@Z ENDP ; CObjBaseAttack::CheckAttackArea
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ObjBaseAttack.cpp
;	COMDAT ?DecreaseArrow@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_Left$1 = -12						; size = 4
_Right$2 = -8						; size = 4
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?DecreaseArrow@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@@Z PROC ; CObjBaseAttack::DecreaseArrow, COMDAT
; _this$ = ecx

; 78   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 79   : 	if( lpObj->Class == CLASS_ELF && lpObj->Type == OBJTYPE_CHARACTER )

  0000c	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0000f	0f b7 88 9c 00
	00 00		 movzx	 ecx, WORD PTR [eax+156]
  00016	83 f9 02	 cmp	 ecx, 2
  00019	0f 85 b9 02 00
	00		 jne	 $LN17@DecreaseAr
  0001f	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00022	0f b7 48 64	 movzx	 ecx, WORD PTR [eax+100]
  00026	83 f9 01	 cmp	 ecx, 1
  00029	0f 85 a9 02 00
	00		 jne	 $LN17@DecreaseAr

; 80   : 	{
; 81   : 		CItem	*Right = &lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT];

  0002f	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00034	6b c8 00	 imul	 ecx, eax, 0
  00037	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  0003a	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  00040	89 4d f8	 mov	 DWORD PTR _Right$2[ebp], ecx

; 82   : 		CItem	*Left  = &lpObj->pInventory[EQUIPMENT_WEAPON_LEFT];

  00043	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  00048	c1 e0 00	 shl	 eax, 0
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0004e	03 81 5c 0c 00
	00		 add	 eax, DWORD PTR [ecx+3164]
  00054	89 45 f4	 mov	 DWORD PTR _Left$1[ebp], eax

; 83   : 
; 84   : 		if(g_ArrowSystem.CheckArrow(Right->m_Type) == true || g_ArrowSystem.CheckArrow(Left->m_Type) == true)

  00057	8b 45 f8	 mov	 eax, DWORD PTR _Right$2[ebp]
  0005a	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0005e	51		 push	 ecx
  0005f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ArrowSystem@@3VCArrowSystem@@A ; g_ArrowSystem
  00064	e8 00 00 00 00	 call	 ?CheckArrow@CArrowSystem@@QAE_NH@Z ; CArrowSystem::CheckArrow
  00069	0f b6 d0	 movzx	 edx, al
  0006c	83 fa 01	 cmp	 edx, 1
  0006f	74 1a		 je	 SHORT $LN4@DecreaseAr
  00071	8b 45 f4	 mov	 eax, DWORD PTR _Left$1[ebp]
  00074	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  00078	51		 push	 ecx
  00079	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ArrowSystem@@3VCArrowSystem@@A ; g_ArrowSystem
  0007e	e8 00 00 00 00	 call	 ?CheckArrow@CArrowSystem@@QAE_NH@Z ; CArrowSystem::CheckArrow
  00083	0f b6 d0	 movzx	 edx, al
  00086	83 fa 01	 cmp	 edx, 1
  00089	75 0a		 jne	 SHORT $LN3@DecreaseAr
$LN4@DecreaseAr:

; 85   : 			return TRUE;

  0008b	b8 01 00 00 00	 mov	 eax, 1
  00090	e9 48 02 00 00	 jmp	 $LN1@DecreaseAr
$LN3@DecreaseAr:

; 86   : 		
; 87   : 		// 석궁을 착용하고 있다면..
; 88   : 		if( (Right->m_Type >= MAKE_ITEMNUM(4,8)) && (Right->m_Type <= MAKE_ITEMNUM(4,14)) ||
; 89   : 			(Right->m_Type == MAKE_ITEMNUM(4,16)) || (Right->m_Type == MAKE_ITEMNUM(4,18)) || 

  00095	8b 45 f8	 mov	 eax, DWORD PTR _Right$2[ebp]
  00098	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0009c	6a 08		 push	 8
  0009e	6a 04		 push	 4
  000a0	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000a5	83 c4 08	 add	 esp, 8
  000a8	3b f0		 cmp	 esi, eax
  000aa	7c 17		 jl	 SHORT $LN8@DecreaseAr
  000ac	8b 45 f8	 mov	 eax, DWORD PTR _Right$2[ebp]
  000af	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  000b3	6a 0e		 push	 14			; 0000000eH
  000b5	6a 04		 push	 4
  000b7	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000bc	83 c4 08	 add	 esp, 8
  000bf	3b f0		 cmp	 esi, eax
  000c1	7e 49		 jle	 SHORT $LN7@DecreaseAr
$LN8@DecreaseAr:
  000c3	8b 45 f8	 mov	 eax, DWORD PTR _Right$2[ebp]
  000c6	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  000ca	6a 10		 push	 16			; 00000010H
  000cc	6a 04		 push	 4
  000ce	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000d3	83 c4 08	 add	 esp, 8
  000d6	3b f0		 cmp	 esi, eax
  000d8	74 32		 je	 SHORT $LN7@DecreaseAr
  000da	8b 45 f8	 mov	 eax, DWORD PTR _Right$2[ebp]
  000dd	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  000e1	6a 12		 push	 18			; 00000012H
  000e3	6a 04		 push	 4
  000e5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  000ea	83 c4 08	 add	 esp, 8
  000ed	3b f0		 cmp	 esi, eax
  000ef	74 1b		 je	 SHORT $LN7@DecreaseAr
  000f1	8b 45 f8	 mov	 eax, DWORD PTR _Right$2[ebp]
  000f4	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  000f8	6a 13		 push	 19			; 00000013H
  000fa	6a 04		 push	 4
  000fc	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00101	83 c4 08	 add	 esp, 8
  00104	3b f0		 cmp	 esi, eax
  00106	0f 85 b0 00 00
	00		 jne	 $LN5@DecreaseAr
$LN7@DecreaseAr:

; 90   : 			(Right->m_Type == MAKE_ITEMNUM(4,19)) )
; 91   : 		{
; 92   : 			if( (Left->m_Type == MAKE_ITEMNUM(4,7)) )

  0010c	8b 45 f4	 mov	 eax, DWORD PTR _Left$1[ebp]
  0010f	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00113	6a 07		 push	 7
  00115	6a 04		 push	 4
  00117	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  0011c	83 c4 08	 add	 esp, 8
  0011f	3b f0		 cmp	 esi, eax
  00121	0f 85 89 00 00
	00		 jne	 $LN9@DecreaseAr

; 93   : 			{
; 94   : 				if ( Left->m_Durability < 1 ) 

  00127	8b 45 f4	 mov	 eax, DWORD PTR _Left$1[ebp]
  0012a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00132	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  00136	76 07		 jbe	 SHORT $LN11@DecreaseAr

; 95   : 					return FALSE;

  00138	33 c0		 xor	 eax, eax
  0013a	e9 9e 01 00 00	 jmp	 $LN1@DecreaseAr
$LN11@DecreaseAr:

; 96   : 				Left->m_Durability--;					// 석궁용 화살 수량을 줄인다.

  0013f	8b 45 f4	 mov	 eax, DWORD PTR _Left$1[ebp]
  00142	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00147	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0014f	8b 4d f4	 mov	 ecx, DWORD PTR _Left$1[ebp]
  00152	f3 0f 11 41 24	 movss	 DWORD PTR [ecx+36], xmm0

; 97   : 				GCItemDurSend(lpObj->m_Index, EQUIPMENT_WEAPON_LEFT, (BYTE)Left->m_Durability, 0);

  00157	6a 00		 push	 0
  00159	8b 45 f4	 mov	 eax, DWORD PTR _Left$1[ebp]
  0015c	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  00161	0f b6 d1	 movzx	 edx, cl
  00164	52		 push	 edx
  00165	6a 01		 push	 1
  00167	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0016a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00172	83 c4 10	 add	 esp, 16			; 00000010H

; 98   : 				if( Left->m_Durability < 1 )

  00175	8b 45 f4	 mov	 eax, DWORD PTR _Left$1[ebp]
  00178	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00180	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  00184	76 28		 jbe	 SHORT $LN12@DecreaseAr

; 99   : 				{
; 100  : 					lpObj->pInventory[EQUIPMENT_WEAPON_LEFT].Clear();

  00186	b9 a8 00 00 00	 mov	 ecx, 168		; 000000a8H
  0018b	c1 e1 00	 shl	 ecx, 0
  0018e	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00191	03 88 5c 0c 00
	00		 add	 ecx, DWORD PTR [eax+3164]
  00197	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 101  : 					GCInventoryItemDeleteSend(lpObj->m_Index, EQUIPMENT_WEAPON_LEFT, 0);

  0019c	6a 00		 push	 0
  0019e	6a 01		 push	 1
  001a0	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  001a3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a5	51		 push	 ecx
  001a6	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  001ab	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN12@DecreaseAr:

; 102  : 				}
; 103  : 			}

  001ae	eb 07		 jmp	 SHORT $LN10@DecreaseAr
$LN9@DecreaseAr:

; 104  : 			else return FALSE;

  001b0	33 c0		 xor	 eax, eax
  001b2	e9 26 01 00 00	 jmp	 $LN1@DecreaseAr
$LN10@DecreaseAr:

; 105  : 		}

  001b7	e9 1c 01 00 00	 jmp	 $LN17@DecreaseAr
$LN5@DecreaseAr:

; 106  : 		else if( (Left->m_Type >= MAKE_ITEMNUM(4,0)) && (Left->m_Type <= MAKE_ITEMNUM(4,6)) || 
; 107  : 				 (Left->m_Type == MAKE_ITEMNUM(4,17)) 
; 108  : #ifdef ADD_NEW_MAP_KALIMA_20040518
; 109  : 				 || (Left->m_Type == MAKE_ITEMNUM(4,20))		// 칼리마에 추가된 요정활
; 110  : #endif				 
; 111  : 				 
; 112  : #ifdef ADD_NEW_ITEM_01_20050823
; 113  : 				 || (Left->m_Type == MAKE_ITEMNUM(4,21))		// 아이템 확장시 추가된 요정활
; 114  : #endif
; 115  : 				 
; 116  : #ifdef MODIFY_350ITEM_BUGFIX_20060811
; 117  : 				 || (Left->m_Type == MAKE_ITEMNUM(4,22))		// 알바트로스보우 활 추가

  001bc	8b 45 f4	 mov	 eax, DWORD PTR _Left$1[ebp]
  001bf	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  001c3	6a 00		 push	 0
  001c5	6a 04		 push	 4
  001c7	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001cc	83 c4 08	 add	 esp, 8
  001cf	3b f0		 cmp	 esi, eax
  001d1	7c 17		 jl	 SHORT $LN15@DecreaseAr
  001d3	8b 45 f4	 mov	 eax, DWORD PTR _Left$1[ebp]
  001d6	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  001da	6a 06		 push	 6
  001dc	6a 04		 push	 4
  001de	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001e3	83 c4 08	 add	 esp, 8
  001e6	3b f0		 cmp	 esi, eax
  001e8	7e 49		 jle	 SHORT $LN14@DecreaseAr
$LN15@DecreaseAr:
  001ea	8b 45 f4	 mov	 eax, DWORD PTR _Left$1[ebp]
  001ed	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  001f1	6a 11		 push	 17			; 00000011H
  001f3	6a 04		 push	 4
  001f5	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  001fa	83 c4 08	 add	 esp, 8
  001fd	3b f0		 cmp	 esi, eax
  001ff	74 32		 je	 SHORT $LN14@DecreaseAr
  00201	8b 45 f4	 mov	 eax, DWORD PTR _Left$1[ebp]
  00204	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  00208	6a 14		 push	 20			; 00000014H
  0020a	6a 04		 push	 4
  0020c	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00211	83 c4 08	 add	 esp, 8
  00214	3b f0		 cmp	 esi, eax
  00216	74 1b		 je	 SHORT $LN14@DecreaseAr
  00218	8b 45 f4	 mov	 eax, DWORD PTR _Left$1[ebp]
  0021b	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0021f	6a 16		 push	 22			; 00000016H
  00221	6a 04		 push	 4
  00223	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00228	83 c4 08	 add	 esp, 8
  0022b	3b f0		 cmp	 esi, eax
  0022d	0f 85 a5 00 00
	00		 jne	 $LN17@DecreaseAr
$LN14@DecreaseAr:

; 118  : #endif
; 119  : 				 
; 120  : #ifdef MODIFY_SEASON4_UPDATE_BUGFIX_01_20080722
; 121  : 				 || (Left->m_Type == MAKE_ITEMNUM(4,23))		// 다크스팅거 활 추가
; 122  : #endif // MODIFY_SEASON4_UPDATE_BUGFIX_01_20080722
; 123  : #ifdef ADD_AERINBOW_20090309
; 124  : 				 || (Left->m_Type == MAKE_ITEMNUM(4,24))		// 에어린보우 추가
; 125  : #endif // ADD_AERINBOW_20090309
; 126  : 
; 127  : 				 )	// 활을 착용하고 있다면..
; 128  : 		{
; 129  : 			if( (Right->m_Type == MAKE_ITEMNUM(4,15)))	// 반대편 손에는 화살

  00233	8b 45 f8	 mov	 eax, DWORD PTR _Right$2[ebp]
  00236	0f bf 70 06	 movsx	 esi, WORD PTR [eax+6]
  0023a	6a 0f		 push	 15			; 0000000fH
  0023c	6a 04		 push	 4
  0023e	e8 00 00 00 00	 call	 ?MakeItemNumber@@YAHHH@Z ; MakeItemNumber
  00243	83 c4 08	 add	 esp, 8
  00246	3b f0		 cmp	 esi, eax
  00248	0f 85 86 00 00
	00		 jne	 $LN16@DecreaseAr

; 130  : 			{
; 131  : 				if ( Right->m_Durability < 1 ) 

  0024e	8b 45 f8	 mov	 eax, DWORD PTR _Right$2[ebp]
  00251	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00259	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  0025d	76 04		 jbe	 SHORT $LN18@DecreaseAr

; 132  : 					return FALSE;

  0025f	33 c0		 xor	 eax, eax
  00261	eb 7a		 jmp	 SHORT $LN1@DecreaseAr
$LN18@DecreaseAr:

; 133  : 				Right->m_Durability--;					// 화살 수량을 줄인다.

  00263	8b 45 f8	 mov	 eax, DWORD PTR _Right$2[ebp]
  00266	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  0026b	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00273	8b 4d f8	 mov	 ecx, DWORD PTR _Right$2[ebp]
  00276	f3 0f 11 41 24	 movss	 DWORD PTR [ecx+36], xmm0

; 134  : 				GCItemDurSend(lpObj->m_Index, EQUIPMENT_WEAPON_RIGHT, (BYTE)Right->m_Durability, 0);

  0027b	6a 00		 push	 0
  0027d	8b 45 f8	 mov	 eax, DWORD PTR _Right$2[ebp]
  00280	f3 0f 2c 48 24	 cvttss2si ecx, DWORD PTR [eax+36]
  00285	0f b6 d1	 movzx	 edx, cl
  00288	52		 push	 edx
  00289	6a 00		 push	 0
  0028b	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0028e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00290	51		 push	 ecx
  00291	e8 00 00 00 00	 call	 ?GCItemDurSend@@YAXHEEE@Z ; GCItemDurSend
  00296	83 c4 10	 add	 esp, 16			; 00000010H

; 135  : 				if( Right->m_Durability < 1 )

  00299	8b 45 f8	 mov	 eax, DWORD PTR _Right$2[ebp]
  0029c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002a4	0f 2f 40 24	 comiss	 xmm0, DWORD PTR [eax+36]
  002a8	76 28		 jbe	 SHORT $LN19@DecreaseAr

; 136  : 				{
; 137  : 					lpObj->pInventory[EQUIPMENT_WEAPON_RIGHT].Clear();

  002aa	b8 a8 00 00 00	 mov	 eax, 168		; 000000a8H
  002af	6b c8 00	 imul	 ecx, eax, 0
  002b2	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  002b5	03 8a 5c 0c 00
	00		 add	 ecx, DWORD PTR [edx+3164]
  002bb	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 138  : 					GCInventoryItemDeleteSend(lpObj->m_Index, EQUIPMENT_WEAPON_RIGHT, 0);

  002c0	6a 00		 push	 0
  002c2	6a 00		 push	 0
  002c4	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  002c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  002c9	51		 push	 ecx
  002ca	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  002cf	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@DecreaseAr:

; 139  : 				}
; 140  : 			}

  002d2	eb 04		 jmp	 SHORT $LN17@DecreaseAr
$LN16@DecreaseAr:

; 141  : 			else return FALSE;

  002d4	33 c0		 xor	 eax, eax
  002d6	eb 05		 jmp	 SHORT $LN1@DecreaseAr
$LN17@DecreaseAr:

; 142  : 		}
; 143  : 	}
; 144  : 	return TRUE;

  002d8	b8 01 00 00 00	 mov	 eax, 1
$LN1@DecreaseAr:

; 145  : }

  002dd	5f		 pop	 edi
  002de	5e		 pop	 esi
  002df	5b		 pop	 ebx
  002e0	8b e5		 mov	 esp, ebp
  002e2	5d		 pop	 ebp
  002e3	c2 04 00	 ret	 4
?DecreaseArrow@CObjBaseAttack@@QAEHPAVOBJECTSTRUCT@@@Z ENDP ; CObjBaseAttack::DecreaseArrow
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ObjBaseAttack.cpp
;	COMDAT ??1CObjBaseAttack@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CObjBaseAttack@@UAE@XZ PROC				; CObjBaseAttack::~CObjBaseAttack, COMDAT
; _this$ = ecx

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CObjBaseAttack@@6B@

; 74   : 
; 75   : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CObjBaseAttack@@UAE@XZ ENDP				; CObjBaseAttack::~CObjBaseAttack
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ObjBaseAttack.cpp
;	COMDAT ??0CObjBaseAttack@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CObjBaseAttack@@QAE@XZ PROC				; CObjBaseAttack::CObjBaseAttack, COMDAT
; _this$ = ecx

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CObjBaseAttack@@6B@

; 69   : 
; 70   : }

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CObjBaseAttack@@QAE@XZ ENDP				; CObjBaseAttack::CObjBaseAttack
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ObjBaseAttack.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\ObjBaseAttack.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
