; Listing generated by Microsoft (R) Optimizing Compiler Version 19.27.29111.0 

	TITLE	C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MonsterSetBase.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?LoadSetBase@CMonsterSetBase@@QAEXPAD@Z		; CMonsterSetBase::LoadSetBase
PUBLIC	??0CMonsterSetBase@@QAE@XZ			; CMonsterSetBase::CMonsterSetBase
PUBLIC	??1CMonsterSetBase@@UAE@XZ			; CMonsterSetBase::~CMonsterSetBase
PUBLIC	?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z	; CMonsterSetBase::GetPosition
PUBLIC	?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z ; CMonsterSetBase::GetBoxPosition
PUBLIC	?SetBoxPosition@CMonsterSetBase@@QAEXHHHHHH@Z	; CMonsterSetBase::SetBoxPosition
PUBLIC	??_GCMonsterSetBase@@UAEPAXI@Z			; CMonsterSetBase::`scalar deleting destructor'
PUBLIC	??_7CMonsterSetBase@@6B@			; CMonsterSetBase::`vftable'
PUBLIC	?__LINE__Var@?0??GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z@4JA ; `CMonsterSetBase::GetPosition'::`1'::__LINE__Var
PUBLIC	??_C@_0EB@JHHENDIE@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ ; `string'
PUBLIC	??_C@_0O@IFOOJNNH@ERROR?5?3?5?$CFs?5?$CFd@	; `string'
PUBLIC	?__LINE__Var@?0??LoadSetBase@CMonsterSetBase@@QAEXPAD@Z@4JA ; `CMonsterSetBase::LoadSetBase'::`1'::__LINE__Var
PUBLIC	??_C@_01KDCPPGHE@r@				; `string'
PUBLIC	??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs@	; `string'
PUBLIC	??_C@_03JBJLGPFL@end@				; `string'
PUBLIC	??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CF@ ; `string'
PUBLIC	??_C@_0CG@CBICGAHP@Monster?5attribute?5max?5over?5?$CFd?5?$CI@ ; `string'
PUBLIC	??_R4CMonsterSetBase@@6B@			; CMonsterSetBase::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMonsterSetBase@@@8			; CMonsterSetBase `RTTI Type Descriptor'
PUBLIC	??_R3CMonsterSetBase@@8				; CMonsterSetBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMonsterSetBase@@8				; CMonsterSetBase::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMonsterSetBase@@8		; CMonsterSetBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_isalpha:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	_strcmp:PROC
EXTRN	_fclose:PROC
EXTRN	_fgetc:PROC
EXTRN	_fopen:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_rand:PROC
EXTRN	_atof:PROC
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	?GetAttr@MapClass@@QAEEHH@Z:PROC		; MapClass::GetAttr
EXTRN	??_ECMonsterSetBase@@UAEPAXI@Z:PROC		; CMonsterSetBase::`vector deleting destructor'
EXTRN	?GetLargeRand@@YAKXZ:PROC			; GetLargeRand
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__except_handler4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?MapC@@3PAVMapClass@@A:DWORD			; MapC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?SMDFile@@3PAU_iobuf@@A DD 01H DUP (?)			; SMDFile
?TokenNumber@@3MA DD 01H DUP (?)			; TokenNumber
?TokenString@@3PADA DB 064H DUP (?)			; TokenString
?CurrentToken@@3W4SMDToken@@A DD 01H DUP (?)		; CurrentToken
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@CMonsterSetBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMonsterSetBase@@8 DD FLAT:??_R0?AVCMonsterSetBase@@@8 ; CMonsterSetBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMonsterSetBase@@8
rdata$r	ENDS
;	COMDAT ??_R2CMonsterSetBase@@8
rdata$r	SEGMENT
??_R2CMonsterSetBase@@8 DD FLAT:??_R1A@?0A@EA@CMonsterSetBase@@8 ; CMonsterSetBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMonsterSetBase@@8
rdata$r	SEGMENT
??_R3CMonsterSetBase@@8 DD 00H				; CMonsterSetBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMonsterSetBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMonsterSetBase@@@8
data$r	SEGMENT
??_R0?AVCMonsterSetBase@@@8 DD FLAT:??_7type_info@@6B@	; CMonsterSetBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMonsterSetBase@@', 00H
data$r	ENDS
;	COMDAT ??_R4CMonsterSetBase@@6B@
rdata$r	SEGMENT
??_R4CMonsterSetBase@@6B@ DD 00H			; CMonsterSetBase::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMonsterSetBase@@@8
	DD	FLAT:??_R3CMonsterSetBase@@8
rdata$r	ENDS
;	COMDAT ??_C@_0CG@CBICGAHP@Monster?5attribute?5max?5over?5?$CFd?5?$CI@
CONST	SEGMENT
??_C@_0CG@CBICGAHP@Monster?5attribute?5max?5over?5?$CFd?5?$CI@ DB 'Monste'
	DB	'r attribute max over %d (%s %d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CF@
CONST	SEGMENT
??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CF@ DB 'Monste'
	DB	'r attribute max over %s %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end@
CONST	SEGMENT
??_C@_03JBJLGPFL@end@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs@
CONST	SEGMENT
??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs@ DB 'file open error %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r@
CONST	SEGMENT
??_C@_01KDCPPGHE@r@ DB 'r', 00H				; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??LoadSetBase@CMonsterSetBase@@QAEXPAD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??LoadSetBase@CMonsterSetBase@@QAEXPAD@Z@4JA DD 0126H ; `CMonsterSetBase::LoadSetBase'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0O@IFOOJNNH@ERROR?5?3?5?$CFs?5?$CFd@
CONST	SEGMENT
??_C@_0O@IFOOJNNH@ERROR?5?3?5?$CFs?5?$CFd@ DB 'ERROR : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@JHHENDIE@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
CONST	SEGMENT
??_C@_0EB@JHHENDIE@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@ DB 'C:\Mu Onl'
	DB	'ine\Mu-GS-Webzen-MC-10093\GameServer\MonsterSetBase.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z@4JA DD 054H ; `CMonsterSetBase::GetPosition'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_7CMonsterSetBase@@6B@
CONST	SEGMENT
??_7CMonsterSetBase@@6B@ DD FLAT:??_R4CMonsterSetBase@@6B@ ; CMonsterSetBase::`vftable'
	DD	FLAT:??_ECMonsterSetBase@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z DD 0fffffffeH
	DD	00H
	DD	0ffffff78H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN13@GetBoxPosi
	DD	FLAT:$LN9@GetBoxPosi
xdata$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCMonsterSetBase@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCMonsterSetBase@@UAEPAXI@Z PROC			; CMonsterSetBase::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CMonsterSetBase@@UAE@XZ ; CMonsterSetBase::~CMonsterSetBase
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 11		 je	 SHORT $LN2@scalar
  0001c	68 e8 0f 01 00	 push	 69608			; 00010fe8H
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002a	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??_GCMonsterSetBase@@UAEPAXI@Z ENDP			; CMonsterSetBase::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MonsterSetBase.cpp
;	COMDAT ?SetBoxPosition@CMonsterSetBase@@QAEXHHHHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_TableNum$ = 8						; size = 4
_mapnumber$ = 12					; size = 4
_ax$ = 16						; size = 4
_ay$ = 20						; size = 4
_aw$ = 24						; size = 4
_ah$ = 28						; size = 4
?SetBoxPosition@CMonsterSetBase@@QAEXHHHHHH@Z PROC	; CMonsterSetBase::SetBoxPosition, COMDAT
; _this$ = ecx

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 38   : 	m_Mp[TableNum].m_MapNumber	= mapnumber;

  0000c	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8a 55 0c	 mov	 dl, BYTE PTR _mapnumber$[ebp]
  00016	88 54 01 08	 mov	 BYTE PTR [ecx+eax+8], dl

; 39   : 	m_Mp[TableNum].m_W          = aw;

  0001a	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	8a 55 18	 mov	 dl, BYTE PTR _aw$[ebp]
  00024	88 54 01 0d	 mov	 BYTE PTR [ecx+eax+13], dl

; 40   : 	m_Mp[TableNum].m_H          = ah;

  00028	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8a 55 1c	 mov	 dl, BYTE PTR _ah$[ebp]
  00032	88 54 01 0e	 mov	 BYTE PTR [ecx+eax+14], dl

; 41   : 	m_Mp[TableNum].m_X			= ax;

  00036	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8a 55 10	 mov	 dl, BYTE PTR _ax$[ebp]
  00040	88 54 01 0a	 mov	 BYTE PTR [ecx+eax+10], dl

; 42   : 	m_Mp[TableNum].m_Y			= ay;

  00044	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	8a 55 14	 mov	 dl, BYTE PTR _ay$[ebp]
  0004e	88 54 01 0b	 mov	 BYTE PTR [ecx+eax+11], dl

; 43   : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 18 00	 ret	 24			; 00000018H
?SetBoxPosition@CMonsterSetBase@@QAEXHHHHHH@Z ENDP	; CMonsterSetBase::SetBoxPosition
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MonsterSetBase.cpp
;	COMDAT ?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z
_TEXT	SEGMENT
tv66 = -120						; size = 4
_attr$ = -49						; size = 1
_ty$ = -48						; size = 4
_tx$ = -44						; size = 4
_h$ = -40						; size = 4
_w$ = -36						; size = 4
_count$ = -32						; size = 4
_this$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_mapnumber$ = 8						; size = 4
_ax$ = 12						; size = 4
_ay$ = 16						; size = 4
_aw$ = 20						; size = 4
_ah$ = 24						; size = 4
_mx$ = 28						; size = 4
_my$ = 32						; size = 4
?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z PROC	; CMonsterSetBase::GetBoxPosition, COMDAT
; _this$ = ecx

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 c4 98	 add	 esp, -104		; ffffff98H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00033	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 47   : 	int count=100;

  00036	c7 45 e0 64 00
	00 00		 mov	 DWORD PTR _count$[ebp], 100 ; 00000064H
$LN2@GetBoxPosi:

; 48   : 	int w, h;
; 49   : 	int tx, ty;
; 50   : 	BYTE attr;
; 51   : 
; 52   : 	while(count--)

  0003d	8b 45 e0	 mov	 eax, DWORD PTR _count$[ebp]
  00040	89 45 88	 mov	 DWORD PTR tv66[ebp], eax
  00043	8b 4d e0	 mov	 ecx, DWORD PTR _count$[ebp]
  00046	83 e9 01	 sub	 ecx, 1
  00049	89 4d e0	 mov	 DWORD PTR _count$[ebp], ecx
  0004c	83 7d 88 00	 cmp	 DWORD PTR tv66[ebp], 0
  00050	0f 84 ba 00 00
	00		 je	 $LN3@GetBoxPosi

; 53   : 	{
; 54   : 		w = aw-ax;

  00056	8b 45 14	 mov	 eax, DWORD PTR _aw$[ebp]
  00059	2b 45 0c	 sub	 eax, DWORD PTR _ax$[ebp]
  0005c	89 45 dc	 mov	 DWORD PTR _w$[ebp], eax

; 55   : 		h = ah-ay;

  0005f	8b 45 18	 mov	 eax, DWORD PTR _ah$[ebp]
  00062	2b 45 10	 sub	 eax, DWORD PTR _ay$[ebp]
  00065	89 45 d8	 mov	 DWORD PTR _h$[ebp], eax

; 56   : 		
; 57   : 		__try

  00068	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 58   : 		{
; 59   : 			tx = ax+(rand()%w);

  0006f	e8 00 00 00 00	 call	 _rand
  00074	8b 4d dc	 mov	 ecx, DWORD PTR _w$[ebp]
  00077	99		 cdq
  00078	f7 f9		 idiv	 ecx
  0007a	03 55 0c	 add	 edx, DWORD PTR _ax$[ebp]
  0007d	89 55 d4	 mov	 DWORD PTR _tx$[ebp], edx

; 60   : 			ty = ay+(rand()%h);

  00080	e8 00 00 00 00	 call	 _rand
  00085	8b 4d d8	 mov	 ecx, DWORD PTR _h$[ebp]
  00088	99		 cdq
  00089	f7 f9		 idiv	 ecx
  0008b	03 55 10	 add	 edx, DWORD PTR _ay$[ebp]
  0008e	89 55 d0	 mov	 DWORD PTR _ty$[ebp], edx

; 61   : 		}

  00091	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  00098	eb 1e		 jmp	 SHORT $LN11@GetBoxPosi
$LN8@GetBoxPosi:
$LN13@GetBoxPosi:

; 62   : 		__except ( w=1, h=1, EXCEPTION_EXECUTE_HANDLER )

  0009a	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _w$[ebp], 1
  000a1	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR _h$[ebp], 1
  000a8	b8 01 00 00 00	 mov	 eax, 1
$LN10@GetBoxPosi:
$LN12@GetBoxPosi:
  000ad	c3		 ret	 0
$LN9@GetBoxPosi:
  000ae	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 61   : 		}

  000b1	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
$LN11@GetBoxPosi:

; 63   : 		{
; 64   : 		}
; 65   : 		
; 66   : 		attr = MapC[mapnumber].GetAttr(tx, ty);

  000b8	8b 45 d0	 mov	 eax, DWORD PTR _ty$[ebp]
  000bb	50		 push	 eax
  000bc	8b 4d d4	 mov	 ecx, DWORD PTR _tx$[ebp]
  000bf	51		 push	 ecx
  000c0	69 4d 08 8c 04
	05 00		 imul	 ecx, DWORD PTR _mapnumber$[ebp], 328844
  000c7	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  000cd	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  000d2	88 45 cf	 mov	 BYTE PTR _attr$[ebp], al

; 67   : 		if( ((attr&MAP_ATTR_SAFTYZONE) != MAP_ATTR_SAFTYZONE) && 
; 68   : 			((attr&MAP_ATTR_BLOCK) != MAP_ATTR_BLOCK) && 

  000d5	0f b6 45 cf	 movzx	 eax, BYTE PTR _attr$[ebp]
  000d9	83 e0 01	 and	 eax, 1
  000dc	75 2d		 jne	 SHORT $LN5@GetBoxPosi
  000de	0f b6 45 cf	 movzx	 eax, BYTE PTR _attr$[ebp]
  000e2	83 e0 04	 and	 eax, 4
  000e5	75 24		 jne	 SHORT $LN5@GetBoxPosi
  000e7	0f b6 45 cf	 movzx	 eax, BYTE PTR _attr$[ebp]
  000eb	83 e0 08	 and	 eax, 8
  000ee	75 1b		 jne	 SHORT $LN5@GetBoxPosi

; 69   : 			((attr&MAP_ATTR_HOLLOW) != MAP_ATTR_HOLLOW)) // 비어있다면..
; 70   : 		{
; 71   : 			mx = tx;

  000f0	8b 45 1c	 mov	 eax, DWORD PTR _mx$[ebp]
  000f3	66 8b 4d d4	 mov	 cx, WORD PTR _tx$[ebp]
  000f7	66 89 08	 mov	 WORD PTR [eax], cx

; 72   : 			my = ty;

  000fa	8b 45 20	 mov	 eax, DWORD PTR _my$[ebp]
  000fd	66 8b 4d d0	 mov	 cx, WORD PTR _ty$[ebp]
  00101	66 89 08	 mov	 WORD PTR [eax], cx

; 73   : 			return TRUE;

  00104	b8 01 00 00 00	 mov	 eax, 1
  00109	eb 07		 jmp	 SHORT $LN7@GetBoxPosi
$LN5@GetBoxPosi:

; 74   : 		}
; 75   : 	}

  0010b	e9 2d ff ff ff	 jmp	 $LN2@GetBoxPosi
$LN3@GetBoxPosi:

; 76   : 	return FALSE;

  00110	33 c0		 xor	 eax, eax
$LN7@GetBoxPosi:

; 77   : }

  00112	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00115	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011c	59		 pop	 ecx
  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 1c 00	 ret	 28			; 0000001cH
?GetBoxPosition@CMonsterSetBase@@QAEHHHHHHAAF0@Z ENDP	; CMonsterSetBase::GetBoxPosition
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MonsterSetBase.cpp
;	COMDAT ?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z
_TEXT	SEGMENT
tv197 = -112						; size = 4
tv84 = -112						; size = 4
_Ory$1 = -44						; size = 4
_Orx$2 = -40						; size = 4
_iRY$3 = -36						; size = 4
_iRX$4 = -32						; size = 4
_h$ = -28						; size = 4
_w$ = -24						; size = 4
_ty$ = -20						; size = 4
_tx$ = -16						; size = 4
_attr$ = -9						; size = 1
_count$ = -8						; size = 4
_this$ = -4						; size = 4
_TableNum$ = 8						; size = 4
_MapNumber$ = 12					; size = 2
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z PROC		; CMonsterSetBase::GetPosition, COMDAT
; _this$ = ecx

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 85   : 	int count=100;

  0000c	c7 45 f8 64 00
	00 00		 mov	 DWORD PTR _count$[ebp], 100 ; 00000064H

; 86   : 	BYTE attr;
; 87   : 	int  tx, ty;
; 88   : 	int  w, h;
; 89   : 	
; 90   : 	if( TableNum < 0 || (TableNum > (MAX_MONSTER-1)) ) 

  00013	83 7d 08 00	 cmp	 DWORD PTR _TableNum$[ebp], 0
  00017	7c 09		 jl	 SHORT $LN7@GetPositio
  00019	81 7d 08 a7 16
	00 00		 cmp	 DWORD PTR _TableNum$[ebp], 5799 ; 000016a7H
  00020	7e 23		 jle	 SHORT $LN6@GetPositio
$LN7@GetPositio:

; 91   : 	{
; 92   : 		LogAdd("ERROR : %s %d",__FILE__, __LINE__);

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z@4JA
  00027	83 c0 08	 add	 eax, 8
  0002a	50		 push	 eax
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@JHHENDIE@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0O@IFOOJNNH@ERROR?5?3?5?$CFs?5?$CFd@
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 93   : 		return FALSE;

  0003e	33 c0		 xor	 eax, eax
  00040	e9 a8 02 00 00	 jmp	 $LN1@GetPositio
$LN6@GetPositio:

; 94   : 	}
; 95   : 	if( m_Mp[TableNum].m_ArrangeType == 1 || m_Mp[TableNum].m_ArrangeType == 3)

  00045	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	0f b6 54 01 04	 movzx	 edx, BYTE PTR [ecx+eax+4]
  00051	83 fa 01	 cmp	 edx, 1
  00054	74 15		 je	 SHORT $LN2@GetPositio
  00056	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	0f b6 54 01 04	 movzx	 edx, BYTE PTR [ecx+eax+4]
  00062	83 fa 03	 cmp	 edx, 3
  00065	0f 85 0e 01 00
	00		 jne	 $LN8@GetPositio
$LN2@GetPositio:

; 96   : 	{
; 97   : 		while(count--)

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  0006e	89 45 90	 mov	 DWORD PTR tv84[ebp], eax
  00071	8b 4d f8	 mov	 ecx, DWORD PTR _count$[ebp]
  00074	83 e9 01	 sub	 ecx, 1
  00077	89 4d f8	 mov	 DWORD PTR _count$[ebp], ecx
  0007a	83 7d 90 00	 cmp	 DWORD PTR tv84[ebp], 0
  0007e	0f 84 f0 00 00
	00		 je	 $LN3@GetPositio

; 98   : 		{
; 99   : 			w = m_Mp[TableNum].m_W-m_Mp[TableNum].m_X;

  00084	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  00088	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	0f b6 54 01 0d	 movzx	 edx, BYTE PTR [ecx+eax+13]
  00090	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  00094	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	0f b6 44 01 0a	 movzx	 eax, BYTE PTR [ecx+eax+10]
  0009c	2b d0		 sub	 edx, eax
  0009e	89 55 e8	 mov	 DWORD PTR _w$[ebp], edx

; 100  : 			h = m_Mp[TableNum].m_H-m_Mp[TableNum].m_Y;

  000a1	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	0f b6 54 01 0e	 movzx	 edx, BYTE PTR [ecx+eax+14]
  000ad	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  000b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	0f b6 44 01 0b	 movzx	 eax, BYTE PTR [ecx+eax+11]
  000b9	2b d0		 sub	 edx, eax
  000bb	89 55 e4	 mov	 DWORD PTR _h$[ebp], edx

; 101  : 			
; 102  : 			if( w < 1 ) w = 1;

  000be	83 7d e8 01	 cmp	 DWORD PTR _w$[ebp], 1
  000c2	7d 07		 jge	 SHORT $LN11@GetPositio
  000c4	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _w$[ebp], 1
$LN11@GetPositio:

; 103  : 			if( h < 1 ) h = 1;

  000cb	83 7d e4 01	 cmp	 DWORD PTR _h$[ebp], 1
  000cf	7d 07		 jge	 SHORT $LN12@GetPositio
  000d1	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _h$[ebp], 1
$LN12@GetPositio:

; 104  : 
; 105  : #ifdef MODIFY_MONSTER_RANDOM_POS_CREATION_20051202
; 106  : 			int iRX = GetLargeRand()%w;

  000d8	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  000dd	33 d2		 xor	 edx, edx
  000df	f7 75 e8	 div	 DWORD PTR _w$[ebp]
  000e2	89 55 e0	 mov	 DWORD PTR _iRX$4[ebp], edx

; 107  : 			int iRY = GetLargeRand()%h;

  000e5	e8 00 00 00 00	 call	 ?GetLargeRand@@YAKXZ	; GetLargeRand
  000ea	33 d2		 xor	 edx, edx
  000ec	f7 75 e4	 div	 DWORD PTR _h$[ebp]
  000ef	89 55 dc	 mov	 DWORD PTR _iRY$3[ebp], edx

; 108  : 			
; 109  : 			tx = m_Mp[TableNum].m_X + iRX;

  000f2	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  000f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	0f b6 54 01 0a	 movzx	 edx, BYTE PTR [ecx+eax+10]
  000fe	03 55 e0	 add	 edx, DWORD PTR _iRX$4[ebp]
  00101	89 55 f0	 mov	 DWORD PTR _tx$[ebp], edx

; 110  : 			ty = m_Mp[TableNum].m_Y + iRY;

  00104	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  00108	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	0f b6 54 01 0b	 movzx	 edx, BYTE PTR [ecx+eax+11]
  00110	03 55 dc	 add	 edx, DWORD PTR _iRY$3[ebp]
  00113	89 55 ec	 mov	 DWORD PTR _ty$[ebp], edx

; 111  : #else
; 112  : 			tx = m_Mp[TableNum].m_X+(rand()%w);
; 113  : 			ty = m_Mp[TableNum].m_Y+(rand()%h);
; 114  : #endif
; 115  : 
; 116  : 			attr = MapC[MapNumber].GetAttr(tx, ty);

  00116	8b 45 ec	 mov	 eax, DWORD PTR _ty$[ebp]
  00119	50		 push	 eax
  0011a	8b 4d f0	 mov	 ecx, DWORD PTR _tx$[ebp]
  0011d	51		 push	 ecx
  0011e	0f bf 55 0c	 movsx	 edx, WORD PTR _MapNumber$[ebp]
  00122	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00128	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0012e	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00133	88 45 f7	 mov	 BYTE PTR _attr$[ebp], al

; 117  : 			if( ((attr&MAP_ATTR_SAFTYZONE) != MAP_ATTR_SAFTYZONE) && 
; 118  : 				((attr&MAP_ATTR_BLOCK) != MAP_ATTR_BLOCK) && 

  00136	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  0013a	83 e0 01	 and	 eax, 1
  0013d	75 30		 jne	 SHORT $LN13@GetPositio
  0013f	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  00143	83 e0 04	 and	 eax, 4
  00146	75 27		 jne	 SHORT $LN13@GetPositio
  00148	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  0014c	83 e0 08	 and	 eax, 8
  0014f	75 1e		 jne	 SHORT $LN13@GetPositio

; 119  : 				((attr&MAP_ATTR_HOLLOW) != MAP_ATTR_HOLLOW)) // 비어있다면..
; 120  : 			{
; 121  : 				x = tx;

  00151	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  00154	66 8b 4d f0	 mov	 cx, WORD PTR _tx$[ebp]
  00158	66 89 08	 mov	 WORD PTR [eax], cx

; 122  : 				y = ty;

  0015b	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  0015e	66 8b 4d ec	 mov	 cx, WORD PTR _ty$[ebp]
  00162	66 89 08	 mov	 WORD PTR [eax], cx

; 123  : 				return TRUE;

  00165	b8 01 00 00 00	 mov	 eax, 1
  0016a	e9 7e 01 00 00	 jmp	 $LN1@GetPositio
$LN13@GetPositio:

; 124  : 			}
; 125  : 		}

  0016f	e9 f7 fe ff ff	 jmp	 $LN2@GetPositio
$LN3@GetPositio:

; 126  : 	}

  00174	e9 72 01 00 00	 jmp	 $LN9@GetPositio
$LN8@GetPositio:

; 127  : 	else if( m_Mp[TableNum].m_ArrangeType == 0 ) //if( m_Mp[TableNum].m_W && m_Mp[TableNum].m_H )

  00179	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  0017d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00180	0f b6 54 01 04	 movzx	 edx, BYTE PTR [ecx+eax+4]
  00185	85 d2		 test	 edx, edx
  00187	75 35		 jne	 SHORT $LN14@GetPositio

; 128  : 	{
; 129  : 		x = m_Mp[TableNum].m_X;

  00189	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  0018d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00190	66 0f b6 54 01
	0a		 movzx	 dx, BYTE PTR [ecx+eax+10]
  00196	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  00199	66 89 10	 mov	 WORD PTR [eax], dx

; 130  : 		y = m_Mp[TableNum].m_Y;

  0019c	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  001a0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a3	66 0f b6 54 01
	0b		 movzx	 dx, BYTE PTR [ecx+eax+11]
  001a9	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  001ac	66 89 10	 mov	 WORD PTR [eax], dx

; 131  : 		return TRUE;

  001af	b8 01 00 00 00	 mov	 eax, 1
  001b4	e9 34 01 00 00	 jmp	 $LN1@GetPositio

; 132  : 	}

  001b9	e9 2d 01 00 00	 jmp	 $LN9@GetPositio
$LN14@GetPositio:

; 133  : 	else if( m_Mp[TableNum].m_ArrangeType == 2 )

  001be	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  001c2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001c5	0f b6 54 01 04	 movzx	 edx, BYTE PTR [ecx+eax+4]
  001ca	83 fa 02	 cmp	 edx, 2
  001cd	0f 85 c0 00 00
	00		 jne	 $LN16@GetPositio
$LN4@GetPositio:

; 134  : 	{
; 135  : 		int Orx, Ory;
; 136  : 		
; 137  : 		while(count--)

  001d3	8b 45 f8	 mov	 eax, DWORD PTR _count$[ebp]
  001d6	89 45 90	 mov	 DWORD PTR tv197[ebp], eax
  001d9	8b 4d f8	 mov	 ecx, DWORD PTR _count$[ebp]
  001dc	83 e9 01	 sub	 ecx, 1
  001df	89 4d f8	 mov	 DWORD PTR _count$[ebp], ecx
  001e2	83 7d 90 00	 cmp	 DWORD PTR tv197[ebp], 0
  001e6	0f 84 a5 00 00
	00		 je	 $LN5@GetPositio

; 138  : 		{
; 139  : 			Orx = m_Mp[TableNum].m_X-3;

  001ec	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  001f0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f3	0f b6 54 01 0a	 movzx	 edx, BYTE PTR [ecx+eax+10]
  001f8	83 ea 03	 sub	 edx, 3
  001fb	89 55 d8	 mov	 DWORD PTR _Orx$2[ebp], edx

; 140  : 			Ory = m_Mp[TableNum].m_Y-3;

  001fe	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  00202	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00205	0f b6 54 01 0b	 movzx	 edx, BYTE PTR [ecx+eax+11]
  0020a	83 ea 03	 sub	 edx, 3
  0020d	89 55 d4	 mov	 DWORD PTR _Ory$1[ebp], edx

; 141  : 
; 142  : 			Orx += (rand()%7);

  00210	e8 00 00 00 00	 call	 _rand
  00215	99		 cdq
  00216	b9 07 00 00 00	 mov	 ecx, 7
  0021b	f7 f9		 idiv	 ecx
  0021d	03 55 d8	 add	 edx, DWORD PTR _Orx$2[ebp]
  00220	89 55 d8	 mov	 DWORD PTR _Orx$2[ebp], edx

; 143  : 			Ory += (rand()%7);

  00223	e8 00 00 00 00	 call	 _rand
  00228	99		 cdq
  00229	b9 07 00 00 00	 mov	 ecx, 7
  0022e	f7 f9		 idiv	 ecx
  00230	03 55 d4	 add	 edx, DWORD PTR _Ory$1[ebp]
  00233	89 55 d4	 mov	 DWORD PTR _Ory$1[ebp], edx

; 144  : 
; 145  : 			attr = MapC[MapNumber].GetAttr(Orx, Ory);

  00236	8b 45 d4	 mov	 eax, DWORD PTR _Ory$1[ebp]
  00239	50		 push	 eax
  0023a	8b 4d d8	 mov	 ecx, DWORD PTR _Orx$2[ebp]
  0023d	51		 push	 ecx
  0023e	0f bf 55 0c	 movsx	 edx, WORD PTR _MapNumber$[ebp]
  00242	69 ca 8c 04 05
	00		 imul	 ecx, edx, 328844
  00248	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?MapC@@3PAVMapClass@@A ; MapC
  0024e	e8 00 00 00 00	 call	 ?GetAttr@MapClass@@QAEEHH@Z ; MapClass::GetAttr
  00253	88 45 f7	 mov	 BYTE PTR _attr$[ebp], al

; 146  : 			if( ((attr&MAP_ATTR_SAFTYZONE) != MAP_ATTR_SAFTYZONE) && 
; 147  : 				((attr&MAP_ATTR_BLOCK) != MAP_ATTR_BLOCK) && 

  00256	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  0025a	83 e0 01	 and	 eax, 1
  0025d	75 2d		 jne	 SHORT $LN18@GetPositio
  0025f	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  00263	83 e0 04	 and	 eax, 4
  00266	75 24		 jne	 SHORT $LN18@GetPositio
  00268	0f b6 45 f7	 movzx	 eax, BYTE PTR _attr$[ebp]
  0026c	83 e0 08	 and	 eax, 8
  0026f	75 1b		 jne	 SHORT $LN18@GetPositio

; 148  : 				((attr&MAP_ATTR_HOLLOW) != MAP_ATTR_HOLLOW)) // 비어있다면..
; 149  : 			{
; 150  : 				x = Orx;

  00271	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  00274	66 8b 4d d8	 mov	 cx, WORD PTR _Orx$2[ebp]
  00278	66 89 08	 mov	 WORD PTR [eax], cx

; 151  : 				y = Ory;

  0027b	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  0027e	66 8b 4d d4	 mov	 cx, WORD PTR _Ory$1[ebp]
  00282	66 89 08	 mov	 WORD PTR [eax], cx

; 152  : 				return TRUE;

  00285	b8 01 00 00 00	 mov	 eax, 1
  0028a	eb 61		 jmp	 SHORT $LN1@GetPositio
$LN18@GetPositio:

; 153  : 			}
; 154  : 		}		

  0028c	e9 42 ff ff ff	 jmp	 $LN4@GetPositio
$LN5@GetPositio:

; 155  : 	}

  00291	eb 58		 jmp	 SHORT $LN9@GetPositio
$LN16@GetPositio:

; 156  : 	else if( m_Mp[TableNum].m_ArrangeType == 3 )

  00293	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  00297	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0029a	0f b6 54 01 04	 movzx	 edx, BYTE PTR [ecx+eax+4]
  0029f	83 fa 03	 cmp	 edx, 3
  002a2	75 09		 jne	 SHORT $LN19@GetPositio

; 157  : 	{
; 158  : 		return TRUE;

  002a4	b8 01 00 00 00	 mov	 eax, 1
  002a9	eb 42		 jmp	 SHORT $LN1@GetPositio

; 159  : 	}

  002ab	eb 3e		 jmp	 SHORT $LN9@GetPositio
$LN19@GetPositio:

; 160  : #ifdef FOR_BLOODCASTLE
; 161  : 	else if( m_Mp[TableNum].m_ArrangeType == 4 )

  002ad	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  002b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b4	0f b6 54 01 04	 movzx	 edx, BYTE PTR [ecx+eax+4]
  002b9	83 fa 04	 cmp	 edx, 4
  002bc	75 2d		 jne	 SHORT $LN9@GetPositio

; 162  : 	{	
; 163  : 		x = m_Mp[TableNum].m_X;

  002be	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  002c2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c5	66 0f b6 54 01
	0a		 movzx	 dx, BYTE PTR [ecx+eax+10]
  002cb	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  002ce	66 89 10	 mov	 WORD PTR [eax], dx

; 164  : 		y = m_Mp[TableNum].m_Y;			

  002d1	6b 45 08 0c	 imul	 eax, DWORD PTR _TableNum$[ebp], 12
  002d5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d8	66 0f b6 54 01
	0b		 movzx	 dx, BYTE PTR [ecx+eax+11]
  002de	8b 45 14	 mov	 eax, DWORD PTR _y$[ebp]
  002e1	66 89 10	 mov	 WORD PTR [eax], dx

; 165  : 		return TRUE;		

  002e4	b8 01 00 00 00	 mov	 eax, 1
  002e9	eb 02		 jmp	 SHORT $LN1@GetPositio
$LN9@GetPositio:

; 166  : 	}
; 167  : #endif
; 168  : 
; 169  : 	return FALSE;

  002eb	33 c0		 xor	 eax, eax
$LN1@GetPositio:

; 170  : }

  002ed	5f		 pop	 edi
  002ee	5e		 pop	 esi
  002ef	5b		 pop	 ebx
  002f0	8b e5		 mov	 esp, ebp
  002f2	5d		 pop	 ebp
  002f3	c2 10 00	 ret	 16			; 00000010H
?GetPosition@CMonsterSetBase@@QAEHHFAAF0@Z ENDP		; CMonsterSetBase::GetPosition
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MonsterSetBase.cpp
;	COMDAT ??1CMonsterSetBase@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CMonsterSetBase@@UAE@XZ PROC				; CMonsterSetBase::~CMonsterSetBase, COMDAT
; _this$ = ecx

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMonsterSetBase@@6B@

; 33   : 
; 34   : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CMonsterSetBase@@UAE@XZ ENDP				; CMonsterSetBase::~CMonsterSetBase
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MonsterSetBase.cpp
;	COMDAT ??0CMonsterSetBase@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CMonsterSetBase@@QAE@XZ PROC				; CMonsterSetBase::CMonsterSetBase, COMDAT
; _this$ = ecx

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMonsterSetBase@@6B@

; 28   : 
; 29   : }

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0CMonsterSetBase@@QAE@XZ ENDP				; CMonsterSetBase::CMonsterSetBase
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MonsterSetBase.cpp
;	COMDAT ?LoadSetBase@CMonsterSetBase@@QAEXPAD@Z
_TEXT	SEGMENT
_n$1 = -40						; size = 4
_Ory$2 = -34						; size = 1
_Orx$3 = -33						; size = 1
_Ory$4 = -32						; size = 4
_Orx$5 = -28						; size = 4
_Type$6 = -24						; size = 4
_Sdir$ = -17						; size = 1
_copycount$ = -16					; size = 4
_rcount$ = -12						; size = 4
_Token$ = -8						; size = 4
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?LoadSetBase@CMonsterSetBase@@QAEXPAD@Z PROC		; CMonsterSetBase::LoadSetBase, COMDAT
; _this$ = ecx

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 295  : 	if((SMDFile=fopen(filename,"r")) == NULL)	

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r@
  00011	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _fopen
  0001a	83 c4 08	 add	 esp, 8
  0001d	a3 00 00 00 00	 mov	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, eax
  00022	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?SMDFile@@3PAU_iobuf@@A, 0
  00029	75 16		 jne	 SHORT $LN9@LoadSetBas

; 296  : 	{
; 297  : 		MsgBox("file open error %s", filename);

  0002b	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0002e	50		 push	 eax
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BPJMFINL@file?5open?5error?5?$CFs@
  00034	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00039	83 c4 08	 add	 esp, 8

; 298  : 		return ;

  0003c	e9 5c 05 00 00	 jmp	 $LN1@LoadSetBas
$LN9@LoadSetBas:

; 299  : 	}
; 300  : 	SMDToken Token;
; 301  : 	
; 302  : 	int rcount;
; 303  : 	int copycount;
; 304  : 	m_Count = 0;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	c7 80 e4 0f 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+69604], 0
$LN2@LoadSetBas:

; 305  : 	BYTE Sdir;
; 306  : 
; 307  : 	while( true )

  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	85 c0		 test	 eax, eax
  00055	0f 84 34 05 00
	00		 je	 $LN3@LoadSetBas

; 308  : 	{
; 309  : 		Token = (*GetToken)();

  0005b	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00060	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 310  : 		if(Token == END) break;

  00063	83 7d f8 02	 cmp	 DWORD PTR _Token$[ebp], 2
  00067	75 05		 jne	 SHORT $LN10@LoadSetBas
  00069	e9 21 05 00 00	 jmp	 $LN3@LoadSetBas
$LN10@LoadSetBas:

; 311  : 		if(Token == NUMBER)

  0006e	83 7d f8 01	 cmp	 DWORD PTR _Token$[ebp], 1
  00072	0f 85 12 05 00
	00		 jne	 $LN5@LoadSetBas

; 312  : 		{
; 313  : 			int Type = (int)TokenNumber;

  00078	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00080	89 45 e8	 mov	 DWORD PTR _Type$6[ebp], eax
$LN4@LoadSetBas:

; 314  : 			while(true)

  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	85 c0		 test	 eax, eax
  0008a	0f 84 fa 04 00
	00		 je	 $LN5@LoadSetBas

; 315  : 			{
; 316  : 				Token = (*GetToken)();

  00090	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00095	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax

; 317  : 				if(strcmp("end",TokenString)==NULL) break;

  00098	68 00 00 00 00	 push	 OFFSET ?TokenString@@3PADA
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_03JBJLGPFL@end@
  000a2	e8 00 00 00 00	 call	 _strcmp
  000a7	83 c4 08	 add	 esp, 8
  000aa	85 c0		 test	 eax, eax
  000ac	75 05		 jne	 SHORT $LN12@LoadSetBas
  000ae	e9 d7 04 00 00	 jmp	 $LN5@LoadSetBas
$LN12@LoadSetBas:

; 318  : 
; 319  : 				m_Mp[m_Count].m_Type = (int)TokenNumber;

  000b3	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  000c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	66 89 44 11 06	 mov	 WORD PTR [ecx+edx+6], ax

; 320  : 				Token = (*GetToken)(); m_Mp[m_Count].m_MapNumber = (BYTE)TokenNumber;

  000cd	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000d2	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  000d5	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000dd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e0	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  000e7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ea	88 44 11 08	 mov	 BYTE PTR [ecx+edx+8], al

; 321  : 				Token = (*GetToken)(); m_Mp[m_Count].m_Dis       = (BYTE)TokenNumber;

  000ee	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  000f3	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  000f6	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  000fe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00101	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  00108	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	88 44 11 09	 mov	 BYTE PTR [ecx+edx+9], al

; 322  : 				Token = (*GetToken)(); m_Mp[m_Count].m_X		 = (BYTE)TokenNumber;

  0010f	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00114	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  00117	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0011f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00122	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  00129	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012c	88 44 11 0a	 mov	 BYTE PTR [ecx+edx+10], al

; 323  : 				Token = (*GetToken)(); m_Mp[m_Count].m_Y		 = (BYTE)TokenNumber;

  00130	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00135	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  00138	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00140	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00143	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  0014a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014d	88 44 11 0b	 mov	 BYTE PTR [ecx+edx+11], al

; 324  : 				
; 325  : 				m_Mp[m_Count].m_ArrangeType = Type;

  00151	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00154	6b 88 e4 0f 01
	00 0c		 imul	 ecx, DWORD PTR [eax+69604], 12
  0015b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0015e	8a 45 e8	 mov	 al, BYTE PTR _Type$6[ebp]
  00161	88 44 0a 04	 mov	 BYTE PTR [edx+ecx+4], al

; 326  : 				if( Type == 1 || Type == 3)

  00165	83 7d e8 01	 cmp	 DWORD PTR _Type$6[ebp], 1
  00169	74 06		 je	 SHORT $LN15@LoadSetBas
  0016b	83 7d e8 03	 cmp	 DWORD PTR _Type$6[ebp], 3
  0016f	75 47		 jne	 SHORT $LN13@LoadSetBas
$LN15@LoadSetBas:

; 327  : 				{
; 328  : 					Token = (*GetToken)(); m_Mp[m_Count].m_W = (BYTE)TokenNumber;

  00171	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00176	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  00179	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  00181	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00184	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  0018b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0018e	88 44 11 0d	 mov	 BYTE PTR [ecx+edx+13], al

; 329  : 					Token = (*GetToken)(); m_Mp[m_Count].m_H = (BYTE)TokenNumber;

  00192	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00197	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  0019a	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  001a2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a5	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  001ac	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001af	88 44 11 0e	 mov	 BYTE PTR [ecx+edx+14], al

; 330  : 				}

  001b3	e9 fe 00 00 00	 jmp	 $LN19@LoadSetBas
$LN13@LoadSetBas:

; 331  : 				else if( Type == 2 )

  001b8	83 7d e8 02	 cmp	 DWORD PTR _Type$6[ebp], 2
  001bc	0f 85 a4 00 00
	00		 jne	 $LN16@LoadSetBas

; 332  : 				{
; 333  : 					int Orx, Ory;
; 334  : 
; 335  : 					m_Mp[m_Count].m_W = 0;

  001c2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001c5	6b 88 e4 0f 01
	00 0c		 imul	 ecx, DWORD PTR [eax+69604], 12
  001cc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001cf	c6 44 0a 0d 00	 mov	 BYTE PTR [edx+ecx+13], 0

; 336  : 					m_Mp[m_Count].m_H = 0;

  001d4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001d7	6b 88 e4 0f 01
	00 0c		 imul	 ecx, DWORD PTR [eax+69604], 12
  001de	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001e1	c6 44 0a 0e 00	 mov	 BYTE PTR [edx+ecx+14], 0

; 337  : 					
; 338  : 					Orx = m_Mp[m_Count].m_X-3;

  001e6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001e9	6b 88 e4 0f 01
	00 0c		 imul	 ecx, DWORD PTR [eax+69604], 12
  001f0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  001f3	0f b6 44 0a 0a	 movzx	 eax, BYTE PTR [edx+ecx+10]
  001f8	83 e8 03	 sub	 eax, 3
  001fb	89 45 e4	 mov	 DWORD PTR _Orx$5[ebp], eax

; 339  : 					Ory = m_Mp[m_Count].m_Y-3;

  001fe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00201	6b 88 e4 0f 01
	00 0c		 imul	 ecx, DWORD PTR [eax+69604], 12
  00208	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0020b	0f b6 44 0a 0b	 movzx	 eax, BYTE PTR [edx+ecx+11]
  00210	83 e8 03	 sub	 eax, 3
  00213	89 45 e0	 mov	 DWORD PTR _Ory$4[ebp], eax

; 340  : 					Orx += (rand()%7);

  00216	e8 00 00 00 00	 call	 _rand
  0021b	99		 cdq
  0021c	b9 07 00 00 00	 mov	 ecx, 7
  00221	f7 f9		 idiv	 ecx
  00223	03 55 e4	 add	 edx, DWORD PTR _Orx$5[ebp]
  00226	89 55 e4	 mov	 DWORD PTR _Orx$5[ebp], edx

; 341  : 					Ory += (rand()%7);

  00229	e8 00 00 00 00	 call	 _rand
  0022e	99		 cdq
  0022f	b9 07 00 00 00	 mov	 ecx, 7
  00234	f7 f9		 idiv	 ecx
  00236	03 55 e0	 add	 edx, DWORD PTR _Ory$4[ebp]
  00239	89 55 e0	 mov	 DWORD PTR _Ory$4[ebp], edx

; 342  : 
; 343  : 					m_Mp[m_Count].m_X = Orx;

  0023c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0023f	6b 88 e4 0f 01
	00 0c		 imul	 ecx, DWORD PTR [eax+69604], 12
  00246	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00249	8a 45 e4	 mov	 al, BYTE PTR _Orx$5[ebp]
  0024c	88 44 0a 0a	 mov	 BYTE PTR [edx+ecx+10], al

; 344  : 					m_Mp[m_Count].m_Y = Ory;

  00250	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00253	6b 88 e4 0f 01
	00 0c		 imul	 ecx, DWORD PTR [eax+69604], 12
  0025a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0025d	8a 45 e0	 mov	 al, BYTE PTR _Ory$4[ebp]
  00260	88 44 0a 0b	 mov	 BYTE PTR [edx+ecx+11], al

; 345  : 				}

  00264	eb 50		 jmp	 SHORT $LN19@LoadSetBas
$LN16@LoadSetBas:

; 346  : #ifdef FOR_BLOODCASTLE
; 347  : 				else if( Type == 4 )

  00266	83 7d e8 04	 cmp	 DWORD PTR _Type$6[ebp], 4
  0026a	75 26		 jne	 SHORT $LN18@LoadSetBas

; 348  : 				{
; 349  : 					m_Mp[m_Count].m_W = 0;

  0026c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0026f	6b 88 e4 0f 01
	00 0c		 imul	 ecx, DWORD PTR [eax+69604], 12
  00276	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00279	c6 44 0a 0d 00	 mov	 BYTE PTR [edx+ecx+13], 0

; 350  : 					m_Mp[m_Count].m_H = 0;									

  0027e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00281	6b 88 e4 0f 01
	00 0c		 imul	 ecx, DWORD PTR [eax+69604], 12
  00288	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0028b	c6 44 0a 0e 00	 mov	 BYTE PTR [edx+ecx+14], 0

; 351  : 				}

  00290	eb 24		 jmp	 SHORT $LN19@LoadSetBas
$LN18@LoadSetBas:

; 352  : #endif
; 353  : 				else 
; 354  : 				{ 
; 355  : 					m_Mp[m_Count].m_W = 0;

  00292	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00295	6b 88 e4 0f 01
	00 0c		 imul	 ecx, DWORD PTR [eax+69604], 12
  0029c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0029f	c6 44 0a 0d 00	 mov	 BYTE PTR [edx+ecx+13], 0

; 356  : 					m_Mp[m_Count].m_H = 0;

  002a4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002a7	6b 88 e4 0f 01
	00 0c		 imul	 ecx, DWORD PTR [eax+69604], 12
  002ae	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002b1	c6 44 0a 0e 00	 mov	 BYTE PTR [edx+ecx+14], 0
$LN19@LoadSetBas:

; 357  : 				}
; 358  : 								
; 359  : 				Token = (*GetToken)(); m_Mp[m_Count].m_Dir = (BYTE)TokenNumber;

  002b6	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  002bb	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  002be	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  002c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c9	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  002d0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d3	88 44 11 0c	 mov	 BYTE PTR [ecx+edx+12], al

; 360  : 				Sdir = m_Mp[m_Count].m_Dir;

  002d7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002da	6b 88 e4 0f 01
	00 0c		 imul	 ecx, DWORD PTR [eax+69604], 12
  002e1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002e4	8a 44 0a 0c	 mov	 al, BYTE PTR [edx+ecx+12]
  002e8	88 45 ef	 mov	 BYTE PTR _Sdir$[ebp], al

; 361  : 				if( m_Mp[m_Count].m_Dir == 0xFF )

  002eb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002ee	6b 88 e4 0f 01
	00 0c		 imul	 ecx, DWORD PTR [eax+69604], 12
  002f5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  002f8	0f b6 44 0a 0c	 movzx	 eax, BYTE PTR [edx+ecx+12]
  002fd	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00302	75 22		 jne	 SHORT $LN20@LoadSetBas

; 362  : 					m_Mp[m_Count].m_Dir = (rand()%8);

  00304	e8 00 00 00 00	 call	 _rand
  00309	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  0030e	79 05		 jns	 SHORT $LN29@LoadSetBas
  00310	48		 dec	 eax
  00311	83 c8 f8	 or	 eax, -8			; fffffff8H
  00314	40		 inc	 eax
$LN29@LoadSetBas:
  00315	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00318	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  0031f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00322	88 44 11 0c	 mov	 BYTE PTR [ecx+edx+12], al
$LN20@LoadSetBas:

; 363  : 
; 364  : 				if( Type == 1 || Type == 3 )

  00326	83 7d e8 01	 cmp	 DWORD PTR _Type$6[ebp], 1
  0032a	74 0a		 je	 SHORT $LN22@LoadSetBas
  0032c	83 7d e8 03	 cmp	 DWORD PTR _Type$6[ebp], 3
  00330	0f 85 f6 01 00
	00		 jne	 $LN7@LoadSetBas
$LN22@LoadSetBas:

; 365  : 				{
; 366  : 					BYTE Orx, Ory;
; 367  : 					Orx = m_Mp[m_Count].m_X;

  00336	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00339	6b 88 e4 0f 01
	00 0c		 imul	 ecx, DWORD PTR [eax+69604], 12
  00340	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00343	8a 44 0a 0a	 mov	 al, BYTE PTR [edx+ecx+10]
  00347	88 45 df	 mov	 BYTE PTR _Orx$3[ebp], al

; 368  : 					Ory = m_Mp[m_Count].m_Y;

  0034a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0034d	6b 88 e4 0f 01
	00 0c		 imul	 ecx, DWORD PTR [eax+69604], 12
  00354	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00357	8a 44 0a 0b	 mov	 al, BYTE PTR [edx+ecx+11]
  0035b	88 45 de	 mov	 BYTE PTR _Ory$2[ebp], al

; 369  : 					
; 370  : 					Token = (*GetToken)(); rcount = (int)TokenNumber;

  0035e	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken
  00363	89 45 f8	 mov	 DWORD PTR _Token$[ebp], eax
  00366	f3 0f 2c 05 00
	00 00 00	 cvttss2si eax, DWORD PTR ?TokenNumber@@3MA
  0036e	89 45 f4	 mov	 DWORD PTR _rcount$[ebp], eax

; 371  : 					copycount = m_Count;

  00371	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00374	8b 88 e4 0f 01
	00		 mov	 ecx, DWORD PTR [eax+69604]
  0037a	89 4d f0	 mov	 DWORD PTR _copycount$[ebp], ecx

; 372  : 
; 373  : 					if( rcount > 1 )

  0037d	83 7d f4 01	 cmp	 DWORD PTR _rcount$[ebp], 1
  00381	0f 8e a5 01 00
	00		 jle	 $LN7@LoadSetBas

; 374  : 					{
; 375  : 						for( int n=0; n<rcount-1; n++)

  00387	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _n$1[ebp], 0
  0038e	eb 09		 jmp	 SHORT $LN8@LoadSetBas
$LN6@LoadSetBas:
  00390	8b 45 d8	 mov	 eax, DWORD PTR _n$1[ebp]
  00393	83 c0 01	 add	 eax, 1
  00396	89 45 d8	 mov	 DWORD PTR _n$1[ebp], eax
$LN8@LoadSetBas:
  00399	8b 45 f4	 mov	 eax, DWORD PTR _rcount$[ebp]
  0039c	83 e8 01	 sub	 eax, 1
  0039f	39 45 d8	 cmp	 DWORD PTR _n$1[ebp], eax
  003a2	0f 8d 84 01 00
	00		 jge	 $LN7@LoadSetBas

; 376  : 						{
; 377  : #ifdef MAP_SERVER_ADD_MONSTER_20041216
; 378  : #ifdef MAP_SERVER_WORK_20041030
; 379  : 							if (!g_MapServerManager.CheckMapCanMove(m_Mp[copycount].m_MapNumber)) {
; 380  : 								break;
; 381  : 							}
; 382  : #endif
; 383  : #endif
; 384  : 							m_Count++;

  003a8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003ab	8b 88 e4 0f 01
	00		 mov	 ecx, DWORD PTR [eax+69604]
  003b1	83 c1 01	 add	 ecx, 1
  003b4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  003b7	89 8a e4 0f 01
	00		 mov	 DWORD PTR [edx+69604], ecx

; 385  : 							if( m_Count > MAX_MONSTER-1 ) 

  003bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003c0	81 b8 e4 0f 01
	00 a7 16 00 00	 cmp	 DWORD PTR [eax+69604], 5799 ; 000016a7H
  003ca	7e 2e		 jle	 SHORT $LN24@LoadSetBas

; 386  : 							{
; 387  : 								MsgBox("Monster attribute max over %s %d", __FILE__, __LINE__);

  003cc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??LoadSetBase@CMonsterSetBase@@QAEXPAD@Z@4JA
  003d1	83 c0 5d	 add	 eax, 93			; 0000005dH
  003d4	50		 push	 eax
  003d5	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@JHHENDIE@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  003da	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MPDJJDKE@Monster?5attribute?5max?5over?5?$CFs?5?$CF@
  003df	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  003e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 388  : 								fclose(SMDFile);

  003e7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  003ec	50		 push	 eax
  003ed	e8 00 00 00 00	 call	 _fclose
  003f2	83 c4 04	 add	 esp, 4

; 389  : 								return;

  003f5	e9 a3 01 00 00	 jmp	 $LN1@LoadSetBas
$LN24@LoadSetBas:

; 390  : 							}
; 391  : 							m_Mp[m_Count].m_Dis         = m_Mp[copycount].m_Dis;

  003fa	6b 45 f0 0c	 imul	 eax, DWORD PTR _copycount$[ebp], 12
  003fe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00401	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  00408	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0040b	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0040e	8a 44 06 09	 mov	 al, BYTE PTR [esi+eax+9]
  00412	88 44 11 09	 mov	 BYTE PTR [ecx+edx+9], al

; 392  : 							m_Mp[m_Count].m_Type		= m_Mp[copycount].m_Type;

  00416	6b 45 f0 0c	 imul	 eax, DWORD PTR _copycount$[ebp], 12
  0041a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0041d	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  00424	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00427	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0042a	66 8b 44 06 06	 mov	 ax, WORD PTR [esi+eax+6]
  0042f	66 89 44 11 06	 mov	 WORD PTR [ecx+edx+6], ax

; 393  : 							m_Mp[m_Count].m_MapNumber	= m_Mp[copycount].m_MapNumber;

  00434	6b 45 f0 0c	 imul	 eax, DWORD PTR _copycount$[ebp], 12
  00438	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0043b	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  00442	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00445	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00448	8a 44 06 08	 mov	 al, BYTE PTR [esi+eax+8]
  0044c	88 44 11 08	 mov	 BYTE PTR [ecx+edx+8], al

; 394  : 							m_Mp[m_Count].m_W           = m_Mp[copycount].m_W;

  00450	6b 45 f0 0c	 imul	 eax, DWORD PTR _copycount$[ebp], 12
  00454	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00457	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  0045e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00461	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00464	8a 44 06 0d	 mov	 al, BYTE PTR [esi+eax+13]
  00468	88 44 11 0d	 mov	 BYTE PTR [ecx+edx+13], al

; 395  : 							m_Mp[m_Count].m_H           = m_Mp[copycount].m_H;

  0046c	6b 45 f0 0c	 imul	 eax, DWORD PTR _copycount$[ebp], 12
  00470	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00473	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  0047a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0047d	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00480	8a 44 06 0e	 mov	 al, BYTE PTR [esi+eax+14]
  00484	88 44 11 0e	 mov	 BYTE PTR [ecx+edx+14], al

; 396  : 							m_Mp[m_Count].m_X			= m_Mp[copycount].m_X;

  00488	6b 45 f0 0c	 imul	 eax, DWORD PTR _copycount$[ebp], 12
  0048c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0048f	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  00496	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00499	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0049c	8a 44 06 0a	 mov	 al, BYTE PTR [esi+eax+10]
  004a0	88 44 11 0a	 mov	 BYTE PTR [ecx+edx+10], al

; 397  : 							m_Mp[m_Count].m_Y			= m_Mp[copycount].m_Y;

  004a4	6b 45 f0 0c	 imul	 eax, DWORD PTR _copycount$[ebp], 12
  004a8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004ab	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  004b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004b5	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  004b8	8a 44 06 0b	 mov	 al, BYTE PTR [esi+eax+11]
  004bc	88 44 11 0b	 mov	 BYTE PTR [ecx+edx+11], al

; 398  : 							m_Mp[m_Count].m_ArrangeType = m_Mp[copycount].m_ArrangeType;

  004c0	6b 45 f0 0c	 imul	 eax, DWORD PTR _copycount$[ebp], 12
  004c4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004c7	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  004ce	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004d1	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  004d4	8a 44 06 04	 mov	 al, BYTE PTR [esi+eax+4]
  004d8	88 44 11 04	 mov	 BYTE PTR [ecx+edx+4], al

; 399  : 							if( Sdir == 0xFF ) m_Mp[m_Count].m_Dir = (rand()%8);

  004dc	0f b6 45 ef	 movzx	 eax, BYTE PTR _Sdir$[ebp]
  004e0	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  004e5	75 24		 jne	 SHORT $LN25@LoadSetBas
  004e7	e8 00 00 00 00	 call	 _rand
  004ec	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  004f1	79 05		 jns	 SHORT $LN30@LoadSetBas
  004f3	48		 dec	 eax
  004f4	83 c8 f8	 or	 eax, -8			; fffffff8H
  004f7	40		 inc	 eax
$LN30@LoadSetBas:
  004f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  004fb	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  00502	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00505	88 44 11 0c	 mov	 BYTE PTR [ecx+edx+12], al
  00509	eb 1c		 jmp	 SHORT $LN26@LoadSetBas
$LN25@LoadSetBas:

; 400  : 							else m_Mp[m_Count].m_Dir = m_Mp[copycount].m_Dir;

  0050b	6b 45 f0 0c	 imul	 eax, DWORD PTR _copycount$[ebp], 12
  0050f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00512	6b 91 e4 0f 01
	00 0c		 imul	 edx, DWORD PTR [ecx+69604], 12
  00519	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0051c	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  0051f	8a 44 06 0c	 mov	 al, BYTE PTR [esi+eax+12]
  00523	88 44 11 0c	 mov	 BYTE PTR [ecx+edx+12], al
$LN26@LoadSetBas:

; 401  : 						}

  00527	e9 64 fe ff ff	 jmp	 $LN6@LoadSetBas
$LN7@LoadSetBas:

; 402  : 					}
; 403  : 				}
; 404  : 				
; 405  : #ifdef MAP_SERVER_ADD_MONSTER_20041216
; 406  : #ifdef MAP_SERVER_WORK_20041030
; 407  : 				if (!g_MapServerManager.CheckMapCanMove(m_Mp[m_Count].m_MapNumber)) {
; 408  : 					continue;
; 409  : 				}
; 410  : #endif
; 411  : #endif
; 412  : 				m_Count++;

  0052c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0052f	8b 88 e4 0f 01
	00		 mov	 ecx, DWORD PTR [eax+69604]
  00535	83 c1 01	 add	 ecx, 1
  00538	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0053b	89 8a e4 0f 01
	00		 mov	 DWORD PTR [edx+69604], ecx

; 413  : 				if( m_Count > MAX_MONSTER-1 ) 

  00541	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00544	81 b8 e4 0f 01
	00 a7 16 00 00	 cmp	 DWORD PTR [eax+69604], 5799 ; 000016a7H
  0054e	7e 35		 jle	 SHORT $LN27@LoadSetBas

; 414  : 				{
; 415  : 					MsgBox("Monster attribute max over %d (%s %d)", m_Count, __FILE__, __LINE__);

  00550	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??LoadSetBase@CMonsterSetBase@@QAEXPAD@Z@4JA
  00555	83 c0 79	 add	 eax, 121		; 00000079H
  00558	50		 push	 eax
  00559	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@JHHENDIE@C?3?2Mu?5Online?2Mu?9GS?9Webzen?9MC?910@
  0055e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00561	8b 91 e4 0f 01
	00		 mov	 edx, DWORD PTR [ecx+69604]
  00567	52		 push	 edx
  00568	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@CBICGAHP@Monster?5attribute?5max?5over?5?$CFd?5?$CI@
  0056d	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00572	83 c4 10	 add	 esp, 16			; 00000010H

; 416  : 					fclose(SMDFile);

  00575	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0057a	50		 push	 eax
  0057b	e8 00 00 00 00	 call	 _fclose
  00580	83 c4 04	 add	 esp, 4

; 417  : 					return;

  00583	eb 18		 jmp	 SHORT $LN1@LoadSetBas
$LN27@LoadSetBas:

; 418  : 				}
; 419  : 
; 420  : 			}

  00585	e9 f9 fa ff ff	 jmp	 $LN4@LoadSetBas
$LN5@LoadSetBas:

; 421  : 		}
; 422  : 	}

  0058a	e9 bf fa ff ff	 jmp	 $LN2@LoadSetBas
$LN3@LoadSetBas:

; 423  : 	fclose(SMDFile);

  0058f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00594	50		 push	 eax
  00595	e8 00 00 00 00	 call	 _fclose
  0059a	83 c4 04	 add	 esp, 4
$LN1@LoadSetBas:

; 424  : }

  0059d	5f		 pop	 edi
  0059e	5e		 pop	 esi
  0059f	5b		 pop	 ebx
  005a0	8b e5		 mov	 esp, ebp
  005a2	5d		 pop	 ebp
  005a3	c2 04 00	 ret	 4
?LoadSetBase@CMonsterSetBase@@QAEXPAD@Z ENDP		; CMonsterSetBase::LoadSetBase
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\Include\ReadScript.h
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
tv93 = -184						; size = 4
$T1 = -180						; size = 4
_TempString$ = -112					; size = 100
_p$ = -12						; size = 4
_ch$ = -5						; size = 1
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 26   : 	unsigned char ch;
; 27   : 	TokenString[0] = '\0';

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	6b c8 00	 imul	 ecx, eax, 0
  0001e	89 8d 4c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00024	83 bd 4c ff ff
	ff 64		 cmp	 DWORD PTR $T1[ebp], 100	; 00000064H
  0002b	73 02		 jae	 SHORT $LN31@GetToken
  0002d	eb 05		 jmp	 SHORT $LN32@GetToken
$LN31@GetToken:
  0002f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN32@GetToken:
  00034	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR $T1[ebp]
  0003a	c6 82 00 00 00
	00 00		 mov	 BYTE PTR ?TokenString@@3PADA[edx], 0
$LN4@GetToken:

; 28   : 	do
; 29   : 	{
; 30   : 		if ( (ch =(unsigned char) fgetc(SMDFile)) == (BYTE)EOF) return END;

  00041	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _fgetc
  0004c	83 c4 04	 add	 esp, 4
  0004f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00052	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00056	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0005c	75 0a		 jne	 SHORT $LN15@GetToken
  0005e	b8 02 00 00 00	 mov	 eax, 2
  00063	e9 d9 02 00 00	 jmp	 $LN7@GetToken
$LN15@GetToken:

; 31   : 		if (ch=='/' && (ch =(unsigned char) fgetc(SMDFile) )=='/')	

  00068	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0006c	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0006f	75 56		 jne	 SHORT $LN17@GetToken
  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _fgetc
  0007c	83 c4 04	 add	 esp, 4
  0007f	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  00082	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00086	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00089	75 3c		 jne	 SHORT $LN17@GetToken
$LN5@GetToken:

; 32   : 		{
; 33   : 			while((ch != '\n') && (ch != (BYTE)EOF)) {			// 2003.09.02 H.J.I 수정

  0008b	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0008f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00092	74 1e		 je	 SHORT $LN6@GetToken
  00094	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00098	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0009d	74 13		 je	 SHORT $LN6@GetToken

; 34   : 				ch = (unsigned char) fgetc( SMDFile);

  0009f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _fgetc
  000aa	83 c4 04	 add	 esp, 4
  000ad	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al

; 35   : 			}

  000b0	eb d9		 jmp	 SHORT $LN5@GetToken
$LN6@GetToken:

; 36   : 
; 37   : 			if (ch == (BYTE)EOF)

  000b2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000b6	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000bb	75 0a		 jne	 SHORT $LN17@GetToken

; 38   : 				return END;

  000bd	b8 02 00 00 00	 mov	 eax, 2
  000c2	e9 7a 02 00 00	 jmp	 $LN7@GetToken
$LN17@GetToken:

; 39   : 		}
; 40   : 	} while(  isspace(ch) );

  000c7	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _isspace
  000d1	83 c4 04	 add	 esp, 4
  000d4	85 c0		 test	 eax, eax
  000d6	0f 85 65 ff ff
	ff		 jne	 $LN4@GetToken

; 41   : 	
; 42   : 	char *p, TempString[100];
; 43   : 	switch(ch)

  000dc	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  000e0	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], eax
  000e6	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv93[ebp]
  000ec	83 e9 22	 sub	 ecx, 34			; 00000022H
  000ef	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv93[ebp], ecx
  000f5	83 bd 48 ff ff
	ff 5b		 cmp	 DWORD PTR tv93[ebp], 91	; 0000005bH
  000fc	0f 87 86 01 00
	00		 ja	 $LN27@GetToken
  00102	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv93[ebp]
  00108	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN33@GetToken[edx]
  0010f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN34@GetToken[eax*4]
$LN18@GetToken:

; 44   : 	{	
; 45   : 	case '#':
; 46   : 		return CurrentToken = COMMAND;

  00116	c7 05 00 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 35 ; 00000023H
  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00125	e9 17 02 00 00	 jmp	 $LN7@GetToken
$LN19@GetToken:

; 47   : 	case ';':
; 48   : 		return CurrentToken = SEMICOLON;

  0012a	c7 05 00 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 59 ; 0000003bH
  00134	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00139	e9 03 02 00 00	 jmp	 $LN7@GetToken
$LN20@GetToken:

; 49   : 	case ',':
; 50   : 		return CurrentToken = COMMA;

  0013e	c7 05 00 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 44 ; 0000002cH
  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0014d	e9 ef 01 00 00	 jmp	 $LN7@GetToken
$LN21@GetToken:

; 51   : 	case '{':
; 52   : 		return CurrentToken = LP;

  00152	c7 05 00 00 00
	00 7b 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 123 ; 0000007bH
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00161	e9 db 01 00 00	 jmp	 $LN7@GetToken
$LN22@GetToken:

; 53   : 	case '}':
; 54   : 		return CurrentToken = RP;

  00166	c7 05 00 00 00
	00 7d 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 125 ; 0000007dH
  00170	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00175	e9 c7 01 00 00	 jmp	 $LN7@GetToken
$LN23@GetToken:

; 55   : 	case '0':	case '1':	case '2':	case '3':	case '4':
; 56   : 	case '5':	case '6':	case '7':	case '8':	case '9':
; 57   : 	case '.':	case '-':
; 58   : 		ungetc(ch,SMDFile);

  0017a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0017f	50		 push	 eax
  00180	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00184	51		 push	 ecx
  00185	e8 00 00 00 00	 call	 _ungetc
  0018a	83 c4 08	 add	 esp, 8

; 59   : 		p = TempString;

  0018d	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  00190	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax
$LN9@GetToken:

; 60   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || isdigit(ch) || ch=='-') )

  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _getc
  0019e	83 c4 04	 add	 esp, 4
  001a1	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  001a4	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  001a8	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  001ae	74 36		 je	 SHORT $LN10@GetToken
  001b0	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001b4	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001b7	74 1a		 je	 SHORT $LN24@GetToken
  001b9	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001bd	50		 push	 eax
  001be	e8 00 00 00 00	 call	 _isdigit
  001c3	83 c4 04	 add	 esp, 4
  001c6	85 c0		 test	 eax, eax
  001c8	75 09		 jne	 SHORT $LN24@GetToken
  001ca	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  001ce	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  001d1	75 13		 jne	 SHORT $LN10@GetToken
$LN24@GetToken:

; 61   : 			*p++ = ch;

  001d3	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001d6	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  001d9	88 08		 mov	 BYTE PTR [eax], cl
  001db	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  001de	83 c2 01	 add	 edx, 1
  001e1	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  001e4	eb ad		 jmp	 SHORT $LN9@GetToken
$LN10@GetToken:

; 62   : 		*p = 0;

  001e6	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  001e9	c6 00 00	 mov	 BYTE PTR [eax], 0

; 63   : 		TokenNumber = (float)atof(TempString);

  001ec	8d 45 90	 lea	 eax, DWORD PTR _TempString$[ebp]
  001ef	50		 push	 eax
  001f0	e8 00 00 00 00	 call	 _atof
  001f5	83 c4 04	 add	 esp, 4
  001f8	d9 1d 00 00 00
	00		 fstp	 DWORD PTR ?TokenNumber@@3MA

; 64   : 		//			sscanf(TempString," %f ",&TokenNumber);
; 65   : 		return CurrentToken = NUMBER;

  001fe	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 1
  00208	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  0020d	e9 2f 01 00 00	 jmp	 $LN7@GetToken
$LN25@GetToken:

; 66   : 	case '"':
; 67   : 		p = TokenString;

  00212	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA
$LN11@GetToken:

; 68   : 		while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch!='"'))// || isalnum(ch)) )

  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 _getc
  00224	83 c4 04	 add	 esp, 4
  00227	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  0022a	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  0022e	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00234	74 1c		 je	 SHORT $LN12@GetToken
  00236	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0023a	83 f8 22	 cmp	 eax, 34			; 00000022H
  0023d	74 13		 je	 SHORT $LN12@GetToken

; 69   : 			*p++ = ch;

  0023f	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00242	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  00245	88 08		 mov	 BYTE PTR [eax], cl
  00247	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  0024a	83 c2 01	 add	 edx, 1
  0024d	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00250	eb c7		 jmp	 SHORT $LN11@GetToken
$LN12@GetToken:

; 70   : 		if (ch!='"')

  00252	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  00256	83 f8 22	 cmp	 eax, 34			; 00000022H
  00259	74 13		 je	 SHORT $LN26@GetToken

; 71   : 			ungetc(ch,SMDFile);

  0025b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  00260	50		 push	 eax
  00261	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00265	51		 push	 ecx
  00266	e8 00 00 00 00	 call	 _ungetc
  0026b	83 c4 08	 add	 esp, 8
$LN26@GetToken:

; 72   : 		*p = 0;

  0026e	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  00271	c6 00 00	 mov	 BYTE PTR [eax], 0

; 73   : 		return CurrentToken = NAME;

  00274	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0027e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00283	e9 b9 00 00 00	 jmp	 $LN7@GetToken
$LN27@GetToken:

; 74   : 	default:
; 75   : 		if (isalpha(ch))	

  00288	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  0028c	50		 push	 eax
  0028d	e8 00 00 00 00	 call	 _isalpha
  00292	83 c4 04	 add	 esp, 4
  00295	85 c0		 test	 eax, eax
  00297	0f 84 95 00 00
	00		 je	 $LN28@GetToken

; 76   : 		{
; 77   : 			p = TokenString;

  0029d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], OFFSET ?TokenString@@3PADA

; 78   : 			*p++ = ch;

  002a4	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002a7	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002aa	88 08		 mov	 BYTE PTR [eax], cl
  002ac	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  002af	83 c2 01	 add	 edx, 1
  002b2	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
$LN13@GetToken:

; 79   : 			while ( (  (ch = getc(SMDFile) ) !=(BYTE)EOF) && (ch=='.' || ch=='_' || isalnum(ch)) )

  002b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  002ba	50		 push	 eax
  002bb	e8 00 00 00 00	 call	 _getc
  002c0	83 c4 04	 add	 esp, 4
  002c3	88 45 fb	 mov	 BYTE PTR _ch$[ebp], al
  002c6	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  002ca	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  002d0	74 36		 je	 SHORT $LN14@GetToken
  002d2	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002d6	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  002d9	74 1a		 je	 SHORT $LN29@GetToken
  002db	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002df	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  002e2	74 11		 je	 SHORT $LN29@GetToken
  002e4	0f b6 45 fb	 movzx	 eax, BYTE PTR _ch$[ebp]
  002e8	50		 push	 eax
  002e9	e8 00 00 00 00	 call	 _isalnum
  002ee	83 c4 04	 add	 esp, 4
  002f1	85 c0		 test	 eax, eax
  002f3	74 13		 je	 SHORT $LN14@GetToken
$LN29@GetToken:

; 80   : 				*p++ = ch;

  002f5	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  002f8	8a 4d fb	 mov	 cl, BYTE PTR _ch$[ebp]
  002fb	88 08		 mov	 BYTE PTR [eax], cl
  002fd	8b 55 f4	 mov	 edx, DWORD PTR _p$[ebp]
  00300	83 c2 01	 add	 edx, 1
  00303	89 55 f4	 mov	 DWORD PTR _p$[ebp], edx
  00306	eb ad		 jmp	 SHORT $LN13@GetToken
$LN14@GetToken:

; 81   : 			ungetc(ch,SMDFile);

  00308	a1 00 00 00 00	 mov	 eax, DWORD PTR ?SMDFile@@3PAU_iobuf@@A
  0030d	50		 push	 eax
  0030e	0f b6 4d fb	 movzx	 ecx, BYTE PTR _ch$[ebp]
  00312	51		 push	 ecx
  00313	e8 00 00 00 00	 call	 _ungetc
  00318	83 c4 08	 add	 esp, 8

; 82   : 			*p = 0;

  0031b	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0031e	c6 00 00	 mov	 BYTE PTR [eax], 0

; 83   : 			return CurrentToken = NAME;

  00321	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 0
  0032b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
  00330	eb 0f		 jmp	 SHORT $LN7@GetToken
$LN28@GetToken:

; 84   : 		}
; 85   : 		return CurrentToken = SMD_ERROR;

  00332	c7 05 00 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?CurrentToken@@3W4SMDToken@@A, 60 ; 0000003cH
  0033c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CurrentToken@@3W4SMDToken@@A
$LN7@GetToken:

; 86   : 	}
; 87   : }

  00341	5f		 pop	 edi
  00342	5e		 pop	 esi
  00343	5b		 pop	 ebx
  00344	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00347	33 cd		 xor	 ecx, ebp
  00349	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034e	8b e5		 mov	 esp, ebp
  00350	5d		 pop	 ebp
  00351	c3		 ret	 0
  00352	66 90		 npad	 2
$LN34@GetToken:
  00354	00 00 00 00	 DD	 $LN25@GetToken
  00358	00 00 00 00	 DD	 $LN18@GetToken
  0035c	00 00 00 00	 DD	 $LN20@GetToken
  00360	00 00 00 00	 DD	 $LN23@GetToken
  00364	00 00 00 00	 DD	 $LN19@GetToken
  00368	00 00 00 00	 DD	 $LN21@GetToken
  0036c	00 00 00 00	 DD	 $LN22@GetToken
  00370	00 00 00 00	 DD	 $LN27@GetToken
$LN33@GetToken:
  00374	00		 DB	 0
  00375	01		 DB	 1
  00376	07		 DB	 7
  00377	07		 DB	 7
  00378	07		 DB	 7
  00379	07		 DB	 7
  0037a	07		 DB	 7
  0037b	07		 DB	 7
  0037c	07		 DB	 7
  0037d	07		 DB	 7
  0037e	02		 DB	 2
  0037f	03		 DB	 3
  00380	03		 DB	 3
  00381	07		 DB	 7
  00382	03		 DB	 3
  00383	03		 DB	 3
  00384	03		 DB	 3
  00385	03		 DB	 3
  00386	03		 DB	 3
  00387	03		 DB	 3
  00388	03		 DB	 3
  00389	03		 DB	 3
  0038a	03		 DB	 3
  0038b	03		 DB	 3
  0038c	07		 DB	 7
  0038d	04		 DB	 4
  0038e	07		 DB	 7
  0038f	07		 DB	 7
  00390	07		 DB	 7
  00391	07		 DB	 7
  00392	07		 DB	 7
  00393	07		 DB	 7
  00394	07		 DB	 7
  00395	07		 DB	 7
  00396	07		 DB	 7
  00397	07		 DB	 7
  00398	07		 DB	 7
  00399	07		 DB	 7
  0039a	07		 DB	 7
  0039b	07		 DB	 7
  0039c	07		 DB	 7
  0039d	07		 DB	 7
  0039e	07		 DB	 7
  0039f	07		 DB	 7
  003a0	07		 DB	 7
  003a1	07		 DB	 7
  003a2	07		 DB	 7
  003a3	07		 DB	 7
  003a4	07		 DB	 7
  003a5	07		 DB	 7
  003a6	07		 DB	 7
  003a7	07		 DB	 7
  003a8	07		 DB	 7
  003a9	07		 DB	 7
  003aa	07		 DB	 7
  003ab	07		 DB	 7
  003ac	07		 DB	 7
  003ad	07		 DB	 7
  003ae	07		 DB	 7
  003af	07		 DB	 7
  003b0	07		 DB	 7
  003b1	07		 DB	 7
  003b2	07		 DB	 7
  003b3	07		 DB	 7
  003b4	07		 DB	 7
  003b5	07		 DB	 7
  003b6	07		 DB	 7
  003b7	07		 DB	 7
  003b8	07		 DB	 7
  003b9	07		 DB	 7
  003ba	07		 DB	 7
  003bb	07		 DB	 7
  003bc	07		 DB	 7
  003bd	07		 DB	 7
  003be	07		 DB	 7
  003bf	07		 DB	 7
  003c0	07		 DB	 7
  003c1	07		 DB	 7
  003c2	07		 DB	 7
  003c3	07		 DB	 7
  003c4	07		 DB	 7
  003c5	07		 DB	 7
  003c6	07		 DB	 7
  003c7	07		 DB	 7
  003c8	07		 DB	 7
  003c9	07		 DB	 7
  003ca	07		 DB	 7
  003cb	07		 DB	 7
  003cc	07		 DB	 7
  003cd	05		 DB	 5
  003ce	07		 DB	 7
  003cf	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MonsterSetBase.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File C:\Mu Online\Mu-GS-Webzen-MC-10093\GameServer\MonsterSetBase.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
